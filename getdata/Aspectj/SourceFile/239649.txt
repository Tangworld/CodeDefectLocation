@@ -27,6 +27,89 @@ public class Ajc1612Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	// runTest("anno copying");
 	// }
 
+	// public void testDoubleITDF() throws Exception {
+	// runTest("double itdf");
+	// }
+
+	public void testThisAspectInstance_239649_1() throws Exception {
+		// simple case
+		runTest("thisAspectInstance - 1");
+	}
+
+	public void testThisAspectInstance_239649_2() throws Exception {
+		// before advice toggling on/off through if called method
+		runTest("thisAspectInstance - 2");
+	}
+
+	public void testThisAspectInstance_239649_3() throws Exception {
+		// after advice toggling on/off through if called method
+		runTest("thisAspectInstance - 3");
+	}
+
+	public void testThisAspectInstance_239649_4() throws Exception {
+		// before advice, also using thisJoinPointStaticPart
+		runTest("thisAspectInstance - 4");
+	}
+
+	public void testThisAspectInstance_239649_5() throws Exception {
+		// before advice, also using thisJoinPoint
+		runTest("thisAspectInstance - 5");
+	}
+
+	public void testThisAspectInstance_239649_6() throws Exception {
+		// before advice, also using thisEnclosingJoinPointStaticPart
+		runTest("thisAspectInstance - 6");
+	}
+
+	public void testThisAspectInstance_239649_7() throws Exception {
+		// before advice, also using thisJoinPoint and thisJoinPointStaticPart
+		runTest("thisAspectInstance - 7");
+	}
+
+	public void testThisAspectInstance_239649_8() throws Exception {
+		// before advice, also using abstract aspects
+		runTest("thisAspectInstance - 8");
+	}
+
+	public void testThisAspectInstance_239649_9() throws Exception {
+		// before advice, also using abstract aspects 2
+		runTest("thisAspectInstance - 9");
+	}
+
+	public void testThisAspectInstance_239649_10() throws Exception {
+		// aspects in a package
+		runTest("thisAspectInstance - 10");
+	}
+
+	public void testThisAspectInstance_239649_11() throws Exception {
+		// non-singleton aspect - should be an error for now
+		runTest("thisAspectInstance - 11");
+	}
+
+	public void testThisAspectInstance_239649_12() throws Exception {
+		// arg binding and tjpsp
+		runTest("thisAspectInstance - 12");
+	}
+
+	public void testThisAspectInstance_239649_13() throws Exception {
+		// pass instance
+		runTest("thisAspectInstance - 13");
+	}
+
+	public void testThisAspectInstance_239649_14() throws Exception {
+		// multiple ifs
+		runTest("thisAspectInstance - 14");
+	}
+
+	public void testThisAspectInstance_239649_15() throws Exception {
+		// abstract aspects
+		runTest("thisAspectInstance - 15");
+	}
+
+	public void testVerifyPerthis() throws Exception {
+		runTest("verify perthis");
+	}
+
 	public void testRangeForLocalVariables_353936() throws ClassNotFoundException {
 		runTest("local variable tables");
 		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(), "X");
@@ -2,6 +2,198 @@
 
 <suite>
 
+<ajc-test dir="bugs1612/pr239649" title="thisAspectInstance - 1">
+<compile files="One.java" options="-1.5"/>
+<run class="One">
+  <stdout>
+  <line text="In instance check method doit()"/>
+  <line text="In advice()"/>
+  <line text="Method m() running"/>
+  </stdout>
+</run>
+</ajc-test>
+
+<ajc-test dir="bugs1612/pr239649" title="thisAspectInstance - 2">
+<compile files="Two.java" options="-1.5"/>
+<run class="Two">
+  <stdout>
+  <line text="In instance check method, count=1 so doit returns false"/>
+  <line text="Method m() running"/>
+  <line text="In instance check method, count=2 so doit returns true"/>
+  <line text="In advice()"/>
+  <line text="Method m() running"/>
+  <line text="In instance check method, count=3 so doit returns false"/>
+  <line text="Method m() running"/>
+  <line text="In instance check method, count=4 so doit returns true"/>
+  <line text="In advice()"/>
+  <line text="Method m() running"/>
+  </stdout>
+</run>
+</ajc-test>
+
+<ajc-test dir="bugs1612/pr239649" title="thisAspectInstance - 3">
+<compile files="Three.java" options="-1.5"/>
+<run class="Three">
+  <stdout>
+  <line text="Method m() running"/>
+  <line text="In instance check method, count=1 so doit returns false"/>
+  <line text="Method m() running"/>
+  <line text="In instance check method, count=2 so doit returns true"/>
+  <line text="In advice()"/>
+  <line text="Method m() running"/>
+  <line text="In instance check method, count=3 so doit returns false"/>
+  <line text="Method m() running"/>
+  <line text="In instance check method, count=4 so doit returns true"/>
+  <line text="In advice()"/>
+  </stdout>
+</run>
+</ajc-test>
+
+<ajc-test dir="bugs1612/pr239649" title="thisAspectInstance - 4">
+<compile files="Four.java" options="-1.5"/>
+<run class="Four">
+  <stdout>
+  <line text="In instance check method doit()"/>
+  <line text="In advice() execution(void Four.m())"/>
+  <line text="Method m() running"/>
+  </stdout>
+</run>
+</ajc-test>
+
+<ajc-test dir="bugs1612/pr239649" title="thisAspectInstance - 5">
+<compile files="Five.java" options="-1.5"/>
+<run class="Five">
+  <stdout>
+  <line text="In instance check method doit()"/>
+  <line text="In advice() arg0=abc"/>
+  <line text="Method m() running"/>
+  </stdout>
+</run>
+</ajc-test>
+
+<ajc-test dir="bugs1612/pr239649" title="thisAspectInstance - 6">
+<compile files="Six.java" options="-1.5"/>
+<run class="Six">
+  <stdout>
+  <line text="In instance check method doit()"/>
+  <line text="In advice() execution(void Six.main(String[]))"/>
+  <line text="Method m() running"/>
+  </stdout>
+</run>
+</ajc-test>
+
+<ajc-test dir="bugs1612/pr239649" title="thisAspectInstance - 7">
+<compile files="Seven.java" options="-1.5"/>
+<run class="Seven">
+  <stdout>
+  <line text="In instance check method doit()"/>
+  <line text="In advice() call(void Seven.m()) execution(void Seven.main(String[]))"/>
+  <line text="Method m() running"/>
+  </stdout>
+</run>
+</ajc-test>
+
+<ajc-test dir="bugs1612/pr239649" title="thisAspectInstance - 8">
+<compile files="Eight.java" options="-1.5"/>
+<run class="Eight">
+  <stdout>
+  <line text="in doit(): class=X"/>
+  <line text="In advice()"/>
+  <line text="Method m() running"/>
+  </stdout>
+</run>
+</ajc-test>
+
+<ajc-test dir="bugs1612/pr239649" title="thisAspectInstance - 9">
+<compile files="Nine.java" options="-1.5"/>
+<run class="Nine">
+  <stdout>
+  <line text="in doit(): class=X"/>
+  <line text="In advice()"/>
+  <line text="Method m() running"/>
+  </stdout>
+</run>
+</ajc-test>
+
+<ajc-test dir="bugs1612/pr239649" title="thisAspectInstance - 10">
+<compile files="Ten.java" options="-1.5"/>
+<run class="com.foo.bar.Ten">
+  <stdout>
+  <line text="In instance check method doit() class=com.foo.bar.X"/>
+  <line text="In advice()"/>
+  <line text="Method m() running"/>
+  </stdout>
+</run>
+</ajc-test>
+
+<ajc-test dir="bugs1612/pr239649" title="thisAspectInstance - 11">
+<compile files="Eleven.java" options="-1.5">
+<message kind="error" text="thisAspectInstance can only be used inside an if() clause for singleton aspects (compiler limitation)"/>
+</compile>
+</ajc-test>
+
+<ajc-test dir="bugs1612/pr239649" title="thisAspectInstance - 12">
+<compile files="Twelve.java" options="-1.5"/>
+<run class="Twelve">
+  <stdout>
+  <line text="In instance check method doit()"/>
+  <line text="In advice() arg=abc tjpsp=execution(void Twelve.m(String))"/>
+  <line text="Method m() running"/>
+  </stdout>
+</run>
+</ajc-test>
+
+<ajc-test dir="bugs1612/pr239649" title="thisAspectInstance - 13">
+<compile files="Thirteen.java" options="-1.5"/>
+<run class="Thirteen">
+  <stdout>
+  <line text="instance is X"/>
+  <line text="In advice() arg=abc tjpsp=execution(void Thirteen.m(String))"/>
+  <line text="Method m() running"/>
+  </stdout>
+</run>
+</ajc-test>
+
+<ajc-test dir="bugs1612/pr239649" title="thisAspectInstance - 14">
+<compile files="Fourteen.java" options="-1.5"/>
+<run class="Fourteen">
+  <stdout>
+  <line text="instance is X"/>
+  <line text="In advice()"/>
+  <line text="Method m() running"/>
+  </stdout>
+</run>
+</ajc-test>
+
+<ajc-test dir="bugs1612/pr239649" title="thisAspectInstance - 15">
+<compile files="Fifteen.java" options="-1.5"/>
+<run class="Fifteen">
+  <stdout>
+  <line text="in doit(): class=X"/>
+  <line text="In advice()"/>
+  <line text="Method m() running"/>
+  </stdout>
+</run>
+</ajc-test>
+
+<ajc-test dir="bugs1612/doubleITDF" title="double itdf">
+<compile files="A.java" options="-1.7"/>
+<run class="A">
+  <stdout>
+  <line text="AA"/>
+  </stdout>
+</run>
+</ajc-test>
+
+<ajc-test dir="bugs1612/verify" title="verify perthis">
+<compile files="Runner.aj" inpath="code.jar" classpath="groovy-1.8.0.jar;asm-3.2.jar" options="-1.6 -Xset:generateStackMaps=true"/>
+<run class="Runner">
+  <stdout>
+  <line text="AA"/>
+  </stdout>
+</run>
+</ajc-test>
+
 <ajc-test dir="bugs1612/pr353936" title="local variable tables">
 <compile files="Code.java" options="-1.5"/>
 </ajc-test>
@@ -252,8 +252,8 @@ public class AjdeInteractionTestbed extends TestCase {
 	private void addXmlConfigFilesToBuild(String pname, AjCompiler compiler) {
 		File projectBase = new File(sandboxDir, pname);
 		ICompilerConfiguration icc = compiler.getCompilerConfiguration();
-		List currentXmlFiles = icc.getProjectXmlConfigFiles();
-		List collector = new ArrayList();
+		List<String> currentXmlFiles = icc.getProjectXmlConfigFiles();
+		List<String> collector = new ArrayList<String>();
 		collectUpXmlFiles(projectBase, projectBase, collector);
 		boolean changed = false;
 		for (int i = 0; i < collector.size(); i++) {
@@ -271,7 +271,7 @@ public class AjdeInteractionTestbed extends TestCase {
 		}
 	}
 
-	private void collectUpFiles(File location, File base, List collectionPoint) {
+	private void collectUpFiles(File location, File base, List<String> collectionPoint) {
 		String contents[] = location.list();
 		if (contents == null) {
 			return;
@@ -296,7 +296,7 @@ public class AjdeInteractionTestbed extends TestCase {
 		}
 	}
 
-	private void collectUpXmlFiles(File location, File base, List collectionPoint) {
+	private void collectUpXmlFiles(File location, File base, List<String> collectionPoint) {
 		String contents[] = location.list();
 		if (contents == null) {
 			return;
@@ -400,14 +400,14 @@ public class AjdeInteractionTestbed extends TestCase {
 	public void printBuildReport(String projectName) {
 		System.out.println("\n====== BUILD REPORT (Project " + projectName + ") ===========");
 		System.out.println("Build took: " + getTimeTakenForBuild(projectName) + "ms");
-		List compiled = getCompiledFiles(projectName);
+		List<String> compiled = getCompiledFiles(projectName);
 		System.out.println("Compiled: " + compiled.size() + " files");
-		for (Iterator iter = compiled.iterator(); iter.hasNext();) {
+		for (Iterator<String> iter = compiled.iterator(); iter.hasNext();) {
 			System.out.println("        :" + iter.next());
 		}
-		List woven = getWovenClasses(projectName);
+		List<String> woven = getWovenClasses(projectName);
 		System.out.println("Wove: " + woven.size() + " files");
-		for (Iterator iter = woven.iterator(); iter.hasNext();) {
+		for (Iterator<String> iter = woven.iterator(); iter.hasNext();) {
 			System.out.println("    :" + iter.next());
 		}
 		if (wasFullBuild()) {
@@ -497,7 +497,7 @@ public class AjdeInteractionTestbed extends TestCase {
 
 		public static boolean informedAboutKindOfBuild;
 		public static boolean fullBuildOccurred;
-		public static List detectedDeletions = new ArrayList();
+		public static List<String> detectedDeletions = new ArrayList<String>();
 		public static StringBuffer decisions = new StringBuffer();
 
 		public static void reset() {
@@ -35,7 +35,7 @@ public class MultiProjTestCompilerConfiguration implements ICompilerConfiguratio
 	private IOutputLocationManager outputLocationManager = null;
 	private List dependants;
 	private Map javaOptionsMap;
-	private Set inpath;
+	private Set<File> inpath;
 	private String encoding = null;
 	private String outjar;
 	private String nonstandardoptions;
@@ -83,17 +83,17 @@ public class MultiProjTestCompilerConfiguration implements ICompilerConfiguratio
 		return cp;
 	}
 
-	public Set getInpath() {
+	public Set<File> getInpath() {
 		log("ICompilerConfiguration.getInPath()");
 		return inpath;
 	}
 
-	public Map getJavaOptionsMap() {
+	public Map<String, String> getJavaOptionsMap() {
 		log("ICompilerConfiguration.getJavaOptionsMap()");
 		if (javaOptionsMap != null && !javaOptionsMap.isEmpty())
 			return javaOptionsMap;
 
-		Hashtable ht = new Hashtable();
+		Hashtable<String, String> ht = new Hashtable<String, String>();
 		ht.put("org.eclipse.jdt.core.compiler.compliance", "1.5");
 		ht.put("org.eclipse.jdt.core.compiler.codegen.targetPlatform", "1.5");
 		ht.put("org.eclipse.jdt.core.compiler.source", "1.5");
@@ -155,7 +155,7 @@ public class MultiProjTestCompilerConfiguration implements ICompilerConfiguratio
 		this.changed |= ICompilerConfiguration.ASPECTPATH_CHANGED;
 	}
 
-	public void setInpath(Set inpath) {
+	public void setInpath(Set<File> inpath) {
 		this.inpath = inpath;
 		this.changed |= ICompilerConfiguration.INPATH_CHANGED;
 	}
@@ -112,7 +112,7 @@ public class MultiProjTestMessageHandler implements IBuildMessageHandler {
 		return weavingMessages;
 	}
 
-	public List/* IMessage */getCompilerErrors() {
+	public List<IMessage> getCompilerErrors() {
 		return compilerErrors;
 	}
 
@@ -37,12 +37,13 @@ public abstract class CommandTestCase extends TestCase {
 
 	/**
 	 * Constructor for CommandTestCase.
+	 * 
 	 * @param name
 	 */
 	public CommandTestCase(String name) {
 		super(name);
 	}
-	
+
 	public static final int[] NO_ERRORS = new int[0];
 	public static final int[] TOP_ERROR = new int[0];
 
@@ -51,87 +52,87 @@ public abstract class CommandTestCase extends TestCase {
 	public void checkCompile(String source, int[] expectedErrors) {
 		checkCompile(source, new String[0], expectedErrors, getSandboxName());
 	}
-	
-    protected void runMain(String className) {
+
+	protected void runMain(String className) {
 		TestUtil.runMain(getSandboxName(), className);
-    }
-	
+	}
+
 	public static void checkCompile(String source, String[] extraArgs, int[] expectedErrors, String sandboxName) {
-		List args = new ArrayList();
+		List<String> args = new ArrayList<String>();
 		args.add("-verbose");
-		
+
 		args.add("-d");
 		args.add(sandboxName);
-		
-		args.add("-classpath");		
-
-		args.add(getRuntimeClasspath() + File.pathSeparator + 
-			"../lib/junit/junit.jar");
-		
-		args.add("-g");  //XXX need this to get sourcefile and line numbers, shouldn't
-		
+
+		args.add("-classpath");
+
+		args.add(getRuntimeClasspath() + File.pathSeparator + "../lib/junit/junit.jar");
+
+		args.add("-g"); // XXX need this to get sourcefile and line numbers, shouldn't
+
 		for (int i = 0; i < extraArgs.length; i++) {
 			args.add(extraArgs[i]);
 		}
-		
+
 		args.add(AjdtAjcTests.TESTDATA_PATH + "/" + source);
-		
+
 		runCompiler(args, expectedErrors);
 	}
-	public void testEmptyForAntJUnitSupport() {}
+
+	public void testEmptyForAntJUnitSupport() {
+	}
+
 	public void checkMultipleCompile(String source) throws InterruptedException {
-		List args = new ArrayList();
+		List<String> args = new ArrayList<String>();
 		args.add("-verbose");
-		
+
 		args.add("-d");
 		args.add(getSandboxName());
-		
+
 		args.add("-classpath");
 		args.add(getRuntimeClasspath());
-		
+
 		args.add(AjdtAjcTests.TESTDATA_PATH + "/" + source);
-		
+
 		ICommand compiler = runCompiler(args, NO_ERRORS);
-		Thread.sleep(100); 
-		
+		Thread.sleep(100);
+
 		rerunCompiler(compiler);
-	}		
+	}
 
 	public void rerunCompiler(ICommand command) {
 		MessageHandler myHandler = new MessageHandler();
-//		List recompiledFiles = new ArrayList();
-	    if (!command.repeatCommand(myHandler)) {
-            assertTrue("recompile failed", false);
-        }
-        assertEquals(0, myHandler.numMessages(IMessage.ERROR, true));
+		// List recompiledFiles = new ArrayList();
+		if (!command.repeatCommand(myHandler)) {
+			assertTrue("recompile failed", false);
+		}
+		assertEquals(0, myHandler.numMessages(IMessage.ERROR, true));
 	}
-	
-	
-	
-	public static ICommand runCompiler(List args, int[] expectedErrors) {
+
+	public static ICommand runCompiler(List<String> args, int[] expectedErrors) {
 		ICommand command = new AjdtCommand();
 		MessageHandler myHandler = new MessageHandler();
 		myHandler.setInterceptor(org.aspectj.tools.ajc.Main.MessagePrinter.TERSE);
-	    boolean result = command.runCommand((String[])args.toArray(new String[args.size()]), myHandler);
-        System.out.println("result: " + result);
-//		System.out.println("errors: " + Arrays.asList(myHandler.getErrors()));
-//		System.out.println("warnings: " + Arrays.asList(myHandler.getWarnings()));
-		
-        int nErrors = myHandler.numMessages(IMessage.ERROR, IMessageHolder.EQUAL);
-        if (expectedErrors == NO_ERRORS) {
-            if (0 != nErrors) {
-                String s = ""+Arrays.asList(myHandler.getErrors());
-                assertTrue("unexpected errors: " + s, false);
-            }
+		boolean result = command.runCommand((String[]) args.toArray(new String[args.size()]), myHandler);
+		System.out.println("result: " + result);
+		// System.out.println("errors: " + Arrays.asList(myHandler.getErrors()));
+		// System.out.println("warnings: " + Arrays.asList(myHandler.getWarnings()));
+
+		int nErrors = myHandler.numMessages(IMessage.ERROR, IMessageHolder.EQUAL);
+		if (expectedErrors == NO_ERRORS) {
+			if (0 != nErrors) {
+				String s = "" + Arrays.asList(myHandler.getErrors());
+				assertTrue("unexpected errors: " + s, false);
+			}
 		} else if (expectedErrors == TOP_ERROR) { // ?? what is this?
-            assertTrue("expected error", nErrors > 0);
+			assertTrue("expected error", nErrors > 0);
 		} else {
 			List errors = new ArrayList(Arrays.asList(myHandler.getErrors()));
-			for (int i=0, len=expectedErrors.length; i < len; i++) {
+			for (int i = 0, len = expectedErrors.length; i < len; i++) {
 				int line = expectedErrors[i];
 				boolean found = false;
-				for (Iterator iter = errors.iterator(); iter.hasNext(); ) {
-					IMessage m = (IMessage)iter.next();
+				for (Iterator iter = errors.iterator(); iter.hasNext();) {
+					IMessage m = (IMessage) iter.next();
 					if (m.getSourceLocation() != null && m.getSourceLocation().getLine() == line) {
 						found = true;
 						iter.remove();
@@ -145,42 +146,38 @@ public abstract class CommandTestCase extends TestCase {
 		}
 		return command;
 	}
-	
-	public static void printGenerated(String path, String name) throws IOException {		
+
+	public static void printGenerated(String path, String name) throws IOException {
 		String fullpath = AjdtAjcTests.TESTDATA_PATH + "/" + path;
 		LazyClassGen.disassemble(fullpath, name, System.out);
 	}
-	
-	
-    
-    /** incremental test case adapter to JUnit */
-    public class IncCase extends IncrementalCase {
-        protected void fail(IMessageHandler handler, String mssg) {
+
+	/** incremental test case adapter to JUnit */
+	public class IncCase extends IncrementalCase {
+		protected void fail(IMessageHandler handler, String mssg) {
 			assertTrue(mssg, false);
 		}
-		protected void message(
-			IMessage.Kind kind,
-			String mssg,
-			IMessageHandler handler) {
-            if ((kind == IMessage.FAIL)  || (kind == IMessage.ABORT)) {
-                assertTrue(mssg, false);
-            } else {
-                System.err.println("IncCase " + kind + ": " + mssg); // XXX
-            }
+
+		protected void message(IMessage.Kind kind, String mssg, IMessageHandler handler) {
+			if ((kind == IMessage.FAIL) || (kind == IMessage.ABORT)) {
+				assertTrue(mssg, false);
+			} else {
+				System.err.println("IncCase " + kind + ": " + mssg); // XXX
+			}
 			super.message(kind, mssg, handler);
 		}
 
-    }
+	}
 
 	/** get the location of the org.aspectj.lang & runtime classes */
 	protected static String getRuntimeClasspath() {
-        return AjcTests.aspectjrtClasspath();		
+		return AjcTests.aspectjrtClasspath();
 	}
 
-	protected String getSandboxName () {
+	protected String getSandboxName() {
 		return sandbox.getAbsolutePath();
 	}
-	
+
 	protected void setUp() throws Exception {
 		super.setUp();
 
@@ -188,5 +185,3 @@ public abstract class CommandTestCase extends TestCase {
 	}
 
 }
-
-
@@ -88,7 +88,7 @@ abstract public class AbstractRunSpec implements IRunSpec {
 	protected final ArrayList<String> options;
 	protected final ArrayList<String> paths;
 	// XXXXXunused protected final ArrayList /*ISourceLocation*/ sourceLocations; // XXX remove?
-	protected final ArrayList /* IRunSpec */children;
+	protected final ArrayList<IRunSpec> children;
 	protected final ArrayList /* DirChanges.Spec */dirChanges;
 	protected XMLNames xmlNames;
 	protected String comment;
@@ -112,8 +112,8 @@ abstract public class AbstractRunSpec implements IRunSpec {
 		options = new ArrayList<String>();
 		paths = new ArrayList<String>();
 		// XXXXXunused sourceLocations = new ArrayList();
-		keywords = new ArrayList();
-		children = new ArrayList();
+		keywords = new ArrayList<String>();
+		children = new ArrayList<IRunSpec>();
 		dirChanges = new ArrayList();
 		xmlNames = XMLNames.DEFAULT;
 		runtime = new RT();
@@ -197,14 +197,14 @@ abstract public class AbstractRunSpec implements IRunSpec {
 		}
 	}
 
-	public ArrayList getKeywordsList() {
+	public ArrayList<String> getKeywordsList() {
 		return makeList(keywords);
 	}
 
 	// ------- options - String args
 
 	/** @return ArrayList of String options */
-	public ArrayList getOptionsList() {
+	public ArrayList<String> getOptionsList() {
 		return makeList(options);
 	}
 
@@ -365,22 +365,22 @@ abstract public class AbstractRunSpec implements IRunSpec {
 	}
 
 	/** @return copy of children list */
-	public ArrayList getChildren() {
+	public ArrayList<IRunSpec> getChildren() {
 		return makeList(children);
 	}
 
 	/** @return copy of children list without children to skip */
-	public ArrayList getWorkingChildren() {
+	public ArrayList<IRunSpec> getWorkingChildren() {
 		if (skipAll) {
-			return new ArrayList();
+			return new ArrayList<IRunSpec>();
 		}
 		if (null == skipSet) {
 			return getChildren();
 		}
-		ArrayList result = new ArrayList();
+		ArrayList<IRunSpec> result = new ArrayList<IRunSpec>();
 		int i = 0;
-		for (Iterator iter = children.listIterator(); iter.hasNext(); i++) {
-			Object child = iter.next();
+		for (Iterator<IRunSpec> iter = children.listIterator(); iter.hasNext(); i++) {
+			IRunSpec child = iter.next();
 			if (!skipSet.get(i)) {
 				result.add(child);
 			}
@@ -646,9 +646,9 @@ abstract public class AbstractRunSpec implements IRunSpec {
 		 */
 		spec.badInput = badInput;
 		spec.children.clear();
-		for (Iterator iter = children.iterator(); iter.hasNext();) {
+		for (Iterator<IRunSpec> iter = children.iterator(); iter.hasNext();) {
 			// clone these...
-			IRunSpec child = (IRunSpec) iter.next();
+			IRunSpec child = iter.next();
 			// require all child classes to support clone?
 			if (child instanceof AbstractRunSpec) {
 				spec.addChild((AbstractRunSpec) ((AbstractRunSpec) child).clone());
@@ -700,8 +700,8 @@ abstract public class AbstractRunSpec implements IRunSpec {
 		}
 	}
 
-	private ArrayList makeList(List list) {
-		ArrayList result = new ArrayList();
+	private <T> ArrayList<T> makeList(List<T> list) {
+		ArrayList<T> result = new ArrayList<T>();
 		if (null != list) {
 			result.addAll(list);
 		}
@@ -17,7 +17,6 @@ import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
@@ -65,8 +64,8 @@ public abstract class CommonWorldTests extends TestCase {
 				ResolvedType ty1 = primitives[j];
 				if (ty.equals(ty1)) {
 					isCoerceableFromTest(ty, ty1, true);
-				} else if (ty == ResolvedType.BOOLEAN || ty1 == ResolvedType.BOOLEAN || ty == ResolvedType.VOID
-						|| ty1 == ResolvedType.VOID) {
+				} else if (ty.equals(UnresolvedType.BOOLEAN) || ty1.equals(UnresolvedType.BOOLEAN)
+						|| ty.equals(UnresolvedType.VOID) || ty1.equals(UnresolvedType.VOID)) {
 					isCoerceableFromTest(ty, ty1, false);
 				} else {
 					isCoerceableFromTest(ty, ty1, true);
@@ -90,23 +89,21 @@ public abstract class CommonWorldTests extends TestCase {
 	}
 
 	private void primAssignTest(String sig, String[] lowers) {
-		ResolvedType[] primitives = getWorld().resolve(primitiveTypes);
+		ResolvedType[] primitives = world.resolve(primitiveTypes);
 		UnresolvedType tx = UnresolvedType.forSignature(sig);
-		ResolvedType ty = getWorld().resolve(tx, true);
+		ResolvedType ty = world.resolve(tx, true);
 		assertTrue("Couldnt find type " + tx, !ty.isMissing());
-		ResolvedType[] lowerTyArray = getWorld().resolve(UnresolvedType.forSignatures(lowers));
-		List lowerTys = new ArrayList(Arrays.asList(lowerTyArray));
+		ResolvedType[] lowerTyArray = world.resolve(UnresolvedType.forSignatures(lowers));
+		List<ResolvedType> lowerTys = new ArrayList<ResolvedType>(Arrays.asList(lowerTyArray));
 		lowerTys.add(ty);
-		Set allLowerTys = new HashSet(lowerTys);
-		Set allUpperTys = new HashSet(Arrays.asList(primitives));
+		Set<ResolvedType> allLowerTys = new HashSet<ResolvedType>(lowerTys);
+		Set<ResolvedType> allUpperTys = new HashSet<ResolvedType>(Arrays.asList(primitives));
 		allUpperTys.removeAll(allLowerTys);
 
-		for (Iterator i = allLowerTys.iterator(); i.hasNext();) {
-			ResolvedType other = (ResolvedType) i.next();
+		for (ResolvedType other : allLowerTys) {
 			isAssignableFromTest(ty, other, true);
 		}
-		for (Iterator i = allUpperTys.iterator(); i.hasNext();) {
-			ResolvedType other = (ResolvedType) i.next();
+		for (ResolvedType other : allUpperTys) {
 			isAssignableFromTest(ty, other, false);
 		}
 	}
@@ -116,7 +113,7 @@ public abstract class CommonWorldTests extends TestCase {
 		for (int i = 0, len = primitives.length; i < len; i++) {
 			ResolvedType ty = primitives[i];
 			UnresolvedType tx = UnresolvedType.forSignature("[" + ty.getSignature());
-			ResolvedType aty = getWorld().resolve(tx, true);
+			ResolvedType aty = world.resolve(tx, true);
 			assertTrue("Couldnt find type " + tx, !aty.isMissing());
 			modifiersTest(aty, Modifier.PUBLIC | Modifier.FINAL);
 			fieldsTest(aty, ResolvedMember.NONE);
@@ -150,7 +147,7 @@ public abstract class CommonWorldTests extends TestCase {
 		for (int i = 0, len = primitives.length; i < len; i++) {
 			ResolvedType ty = primitives[i];
 			UnresolvedType tx = UnresolvedType.forSignature("[[" + ty.getSignature());
-			ResolvedType aty = getWorld().resolve(tx, true);
+			ResolvedType aty = world.resolve(tx, true);
 			assertTrue("Couldnt find type " + tx, !aty.isMissing());
 			modifiersTest(aty, Modifier.PUBLIC | Modifier.FINAL);
 			fieldsTest(aty, ResolvedMember.NONE);
@@ -243,12 +240,15 @@ public abstract class CommonWorldTests extends TestCase {
 	}
 
 	protected void isCoerceableFromTest(UnresolvedType ty0, UnresolvedType ty1, boolean x) {
-		assertEquals(ty0 + " is coerceable from " + ty1, x, ty0.resolve(world).isCoerceableFrom(ty1.resolve(world)));
-		assertEquals(ty1 + " is coerceable from " + ty0, x, ty1.resolve(world).isCoerceableFrom(ty0.resolve(world)));
+		assertEquals(ty0 + " is coerceable from " + ty1, ty0.resolve(world).isCoerceableFrom(ty1.resolve(world)), x);
+		assertEquals(ty1 + " is coerceable from " + ty0, ty1.resolve(world).isCoerceableFrom(ty0.resolve(world)), x);
 	}
 
 	protected void isAssignableFromTest(UnresolvedType ty0, UnresolvedType ty1, boolean x) {
-		assertEquals(ty0 + " is assignable from " + ty1, x, ty0.resolve(world).isAssignableFrom(ty1.resolve(world)));
+		ResolvedType rty0 = ty0.resolve(world);
+		ResolvedType rty1 = ty1.resolve(world);
+		boolean result = rty0.isAssignableFrom(rty1);
+		assertEquals(ty0 + " is assignable from " + ty1, result, x);
 	}
 
 	// ---- tests for parts of ResolvedMethod objects
@@ -10,7 +10,6 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.weaver;
 
 import org.aspectj.bridge.ISourceLocation;
@@ -21,39 +20,44 @@ public class TestShadow extends Shadow {
 	private final World world;
 	private final UnresolvedType thisType;
 
-    public TestShadow(Kind kind, Member signature, UnresolvedType thisType, World world) {
-        super(kind, signature, null);
-        this.world = world;
-        this.thisType = thisType;
-    }
+	public TestShadow(Kind kind, Member signature, UnresolvedType thisType, World world) {
+		super(kind, signature, null);
+		this.world = world;
+		this.thisType = thisType;
+	}
 
-    public World getIWorld() {
-        return world;
-    }
+	public World getIWorld() {
+		return world;
+	}
 
-	/** this is subtly wrong.  ha ha */
-    public UnresolvedType getEnclosingType() {
-        return thisType;
-    }
+	/** this is subtly wrong. ha ha */
+	public UnresolvedType getEnclosingType() {
+		return thisType;
+	}
 
-    public Var getThisVar() {
-    	// we should thorw if we don't have a this
-        return new Var(getThisType().resolve(world));
-    }
+	public Var getThisVar() {
+		// we should thorw if we don't have a this
+		return new Var(getThisType().resolve(world));
+	}
 
-    public Var getTargetVar() {
-    	if (! hasTarget()) throw new RuntimeException("bad");
-        return new Var(getTargetType().resolve(world));
-    }
+	public Var getTargetVar() {
+		if (!hasTarget())
+			throw new RuntimeException("bad");
+		return new Var(getTargetType().resolve(world));
+	}
 
-    public Var getArgVar(int i) {
-        return new Var(getArgType(i).resolve(world));
-    }
+	public Var getArgVar(int i) {
+		return new Var(getArgType(i).resolve(world));
+	}
 
 	public Var getThisEnclosingJoinPointStaticPartVar() {
 		throw new RuntimeException("unimplemented");
 	}
 
+	public Var getThisAspectInstanceVar(ResolvedType aspectType) {
+		throw new RuntimeException("unimplemented");
+	}
+
 	public Var getThisJoinPointStaticPartVar() {
 		throw new RuntimeException("unimplemented");
 	}
@@ -70,45 +74,57 @@ public class TestShadow extends Shadow {
 		throw new RuntimeException("unimplemented");
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getKindedAnnotationVar()
 	 */
 	public Var getKindedAnnotationVar(UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getWithinAnnotationVar()
 	 */
 	public Var getWithinAnnotationVar(UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getWithinCodeAnnotationVar()
 	 */
 	public Var getWithinCodeAnnotationVar(UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getThisAnnotationVar()
 	 */
 	public Var getThisAnnotationVar(UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getTargetAnnotationVar()
 	 */
 	public Var getTargetAnnotationVar(UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getArgAnnotationVar(int)
 	 */
-	public Var getArgAnnotationVar(int i,UnresolvedType annotationType) {
+	public Var getArgAnnotationVar(int i, UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
 
@@ -14,6 +14,7 @@ package org.aspectj.weaver.reflect;
 import junit.framework.TestCase;
 
 import org.aspectj.weaver.ResolvedType;
+import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.World;
 
 public class ReflectionWorldSpecificTest extends TestCase {
@@ -34,8 +35,8 @@ public class ReflectionWorldSpecificTest extends TestCase {
 
 	public void testPrimitiveTypes() {
 		IReflectionWorld world = new ReflectionWorld(true, getClass().getClassLoader());
-		assertEquals("int", ResolvedType.INT, world.resolve(int.class));
-		assertEquals("void", ResolvedType.VOID, world.resolve(void.class));
+		assertEquals("int", UnresolvedType.INT, world.resolve(int.class));
+		assertEquals("void", UnresolvedType.VOID, world.resolve(void.class));
 	}
 
 }
@@ -13,29 +13,23 @@
 package org.aspectj.weaver.reflect;
 
 import org.aspectj.weaver.ResolvedPointcutDefinition;
-import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
 
 /**
- * When a Java15ReflectionBasedDelegate gets the pointcuts for a given class it 
- * tries to resolve them before returning.
- * This can cause problems if the resolution of one pointcut in the type depends
- * on another pointcut in the same type. 
- * Therefore the algorithm proceeds in two phases, first we create and store
- * instances of this class in the pointcuts array, and once that is done, we
- * come back round and resolve the actual pointcut expression. This means that
- * if we recurse doing resolution, we will find the named pointcut we are 
- * looking for!
+ * When a Java15ReflectionBasedDelegate gets the pointcuts for a given class it tries to resolve them before returning. This can
+ * cause problems if the resolution of one pointcut in the type depends on another pointcut in the same type. Therefore the
+ * algorithm proceeds in two phases, first we create and store instances of this class in the pointcuts array, and once that is
+ * done, we come back round and resolve the actual pointcut expression. This means that if we recurse doing resolution, we will find
+ * the named pointcut we are looking for!
  * 
  * @author adrian colyer
- *
+ * 
  */
 public class DeferredResolvedPointcutDefinition extends ResolvedPointcutDefinition {
 
-	public DeferredResolvedPointcutDefinition(UnresolvedType declaringType,
-			int modifiers, String name, UnresolvedType[] parameterTypes) {
-		super(declaringType, modifiers, name, parameterTypes,
-				ResolvedType.VOID, null);
+	public DeferredResolvedPointcutDefinition(UnresolvedType declaringType, int modifiers, String name,
+			UnresolvedType[] parameterTypes) {
+		super(declaringType, modifiers, name, parameterTypes, UnresolvedType.VOID, null);
 	}
-	
+
 }
@@ -218,8 +218,8 @@ public class Java15ReflectionBasedReferenceTypeDelegate extends ReflectionBasedR
 
 	private ResolvedMember createGenericMethodMember(Method forMethod) {
 		ReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.METHOD,
-				getGenericResolvedType(), forMethod.getModifiers(), typeConverter.fromType(forMethod.getReturnType()), forMethod
-						.getName(), typeConverter.fromTypes(forMethod.getParameterTypes()), typeConverter.fromTypes(forMethod
+				getGenericResolvedType(), forMethod.getModifiers(), typeConverter.fromType(forMethod.getReturnType()),
+				forMethod.getName(), typeConverter.fromTypes(forMethod.getParameterTypes()), typeConverter.fromTypes(forMethod
 						.getExceptionTypes()), forMethod);
 		ret.setAnnotationFinder(this.annotationFinder);
 		ret.setGenericSignatureInformationProvider(new Java15GenericSignatureInformationProvider(this.getWorld()));
@@ -230,7 +230,7 @@ public class Java15ReflectionBasedReferenceTypeDelegate extends ReflectionBasedR
 		ReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.METHOD,
 				getGenericResolvedType(), forConstructor.getModifiers(),
 				// to return what BCEL returns the return type is void
-				ResolvedType.VOID,// getGenericResolvedType(),
+				UnresolvedType.VOID,// getGenericResolvedType(),
 				"<init>", typeConverter.fromTypes(forConstructor.getParameterTypes()), typeConverter.fromTypes(forConstructor
 						.getExceptionTypes()), forConstructor);
 		ret.setAnnotationFinder(this.annotationFinder);
@@ -11,7 +11,6 @@
  * ******************************************************************/
 package org.aspectj.weaver.reflect;
 
-
 import java.lang.reflect.Method;
 import java.util.HashSet;
 import java.util.Set;
@@ -30,187 +29,185 @@ public abstract class ReflectionBasedReferenceTypeDelegateTest extends TestCase
 	protected ReflectionWorld world;
 	private ResolvedType objectType;
 	private ResolvedType classType;
-	
+
 	public void testIsAspect() {
 		assertFalse(objectType.isAspect());
 	}
-	
+
 	public void testIsAnnotationStyleAspect() {
 		assertFalse(objectType.isAnnotationStyleAspect());
 	}
-	
+
 	public void testIsInterface() {
 		assertFalse(objectType.isInterface());
 		assertTrue(world.resolve("java.io.Serializable").isInterface());
 	}
-	
+
 	public void testIsEnum() {
 		assertFalse(objectType.isEnum());
 	}
-	
+
 	public void testIsAnnotation() {
 		assertFalse(objectType.isAnnotation());
 	}
-	
+
 	public void testIsAnnotationWithRuntimeRetention() {
 		assertFalse(objectType.isAnnotationWithRuntimeRetention());
 	}
-	
+
 	public void testIsClass() {
 		assertTrue(objectType.isClass());
 		assertFalse(world.resolve("java.io.Serializable").isClass());
 	}
-	
+
 	public void testIsGeneric() {
 		assertFalse(objectType.isGenericType());
 	}
-	
+
 	public void testIsExposedToWeaver() {
 		assertFalse(objectType.isExposedToWeaver());
 	}
-	
+
 	public void testHasAnnotation() {
 		assertFalse(objectType.hasAnnotation(UnresolvedType.forName("Foo")));
 	}
-	
+
 	public void testGetAnnotations() {
-		assertEquals("no entries",0,objectType.getAnnotations().length);
+		assertEquals("no entries", 0, objectType.getAnnotations().length);
 	}
-	
+
 	public void testGetAnnotationTypes() {
-		assertEquals("no entries",0,objectType.getAnnotationTypes().length);
+		assertEquals("no entries", 0, objectType.getAnnotationTypes().length);
 	}
-	
+
 	public void testGetTypeVariables() {
-		assertEquals("no entries",0,objectType.getTypeVariables().length);
+		assertEquals("no entries", 0, objectType.getTypeVariables().length);
 	}
-	
+
 	public void testGetPerClause() {
 		assertNull(objectType.getPerClause());
 	}
-	
+
 	public void testGetModifiers() {
-		assertEquals(Object.class.getModifiers(),objectType.getModifiers());
+		assertEquals(Object.class.getModifiers(), objectType.getModifiers());
 	}
-	
+
 	public void testGetSuperclass() {
-		assertTrue("Superclass of object should be null, but it is: "+objectType.getSuperclass(),objectType.getSuperclass()==null);
-		assertEquals(objectType,world.resolve("java.lang.Class").getSuperclass());
+		assertTrue("Superclass of object should be null, but it is: " + objectType.getSuperclass(),
+				objectType.getSuperclass() == null);
+		assertEquals(objectType, world.resolve("java.lang.Class").getSuperclass());
 		ResolvedType d = world.resolve("reflect.tests.D");
-		assertEquals(world.resolve("reflect.tests.C"),d.getSuperclass());
+		assertEquals(world.resolve("reflect.tests.C"), d.getSuperclass());
 	}
-	
 
 	protected int findMethod(String name, ResolvedMember[] methods) {
-		for (int i=0; i<methods.length; i++) {
+		for (int i = 0; i < methods.length; i++) {
 			if (name.equals(methods[i].getName())) {
 				return i;
 			}
 		}
 		return -1;
 	}
-	
+
 	protected int findMethod(String name, int numArgs, ResolvedMember[] methods) {
-		for (int i=0; i<methods.length; i++) {
+		for (int i = 0; i < methods.length; i++) {
 			if (name.equals(methods[i].getName()) && (methods[i].getParameterTypes().length == numArgs)) {
 				return i;
 			}
 		}
 		return -1;
 	}
-	
+
 	public void testGetDeclaredMethods() {
 		ResolvedMember[] methods = objectType.getDeclaredMethods();
 		assertEquals(Object.class.getDeclaredMethods().length + Object.class.getDeclaredConstructors().length, methods.length);
-		
+
 		ResolvedType c = world.resolve("reflect.tests.C");
 		methods = c.getDeclaredMethods();
-		assertEquals(3,methods.length);
+		assertEquals(3, methods.length);
 		int idx = findMethod("foo", methods);
 		assertTrue(idx > -1);
-		
-		assertEquals(world.resolve("java.lang.String"),methods[idx].getReturnType());
+
+		assertEquals(world.resolve("java.lang.String"), methods[idx].getReturnType());
 		assertEquals(1, methods[idx].getParameterTypes().length);
-		assertEquals(objectType,methods[idx].getParameterTypes()[0]);
-		assertEquals(1,methods[idx].getExceptions().length);
-		assertEquals(world.resolve("java.lang.Exception"),methods[idx].getExceptions()[0]);
+		assertEquals(objectType, methods[idx].getParameterTypes()[0]);
+		assertEquals(1, methods[idx].getExceptions().length);
+		assertEquals(world.resolve("java.lang.Exception"), methods[idx].getExceptions()[0]);
 		int baridx = findMethod("bar", methods);
 		int initidx = findMethod("<init>", methods);
 		assertTrue(baridx > -1);
 		assertTrue(initidx > -1);
 		assertTrue(baridx != initidx && baridx != idx && idx <= 2 && initidx <= 2 && baridx <= 2);
-		
+
 		ResolvedType d = world.resolve("reflect.tests.D");
 		methods = d.getDeclaredMethods();
-		assertEquals(2,methods.length);
+		assertEquals(2, methods.length);
 
 		classType = world.resolve("java.lang.Class");
 		methods = classType.getDeclaredMethods();
-		assertEquals(Class.class.getDeclaredMethods().length + Class.class.getDeclaredConstructors().length, methods.length); 
+		assertEquals(Class.class.getDeclaredMethods().length + Class.class.getDeclaredConstructors().length, methods.length);
 	}
-	
+
 	public void testGetDeclaredFields() {
 		ResolvedMember[] fields = objectType.getDeclaredFields();
-		assertEquals(0,fields.length);
+		assertEquals(0, fields.length);
 
 		ResolvedType c = world.resolve("reflect.tests.C");
 		fields = c.getDeclaredFields();
-		
-		assertEquals(2,fields.length);
-		assertEquals("f",fields[0].getName());
-		assertEquals("s",fields[1].getName());
-		assertEquals(ResolvedType.INT,fields[0].getReturnType());
-		assertEquals(world.resolve("java.lang.String"),fields[1].getReturnType());
+
+		assertEquals(2, fields.length);
+		assertEquals("f", fields[0].getName());
+		assertEquals("s", fields[1].getName());
+		assertEquals(UnresolvedType.INT, fields[0].getReturnType());
+		assertEquals(world.resolve("java.lang.String"), fields[1].getReturnType());
 	}
-	
+
 	public void testGetDeclaredInterfaces() {
 		ResolvedType[] interfaces = objectType.getDeclaredInterfaces();
-		assertEquals(0,interfaces.length);
+		assertEquals(0, interfaces.length);
 
 		ResolvedType d = world.resolve("reflect.tests.D");
 		interfaces = d.getDeclaredInterfaces();
-		assertEquals(1,interfaces.length);
-		assertEquals(world.resolve("java.io.Serializable"),interfaces[0]);
-    }
-	
+		assertEquals(1, interfaces.length);
+		assertEquals(world.resolve("java.io.Serializable"), interfaces[0]);
+	}
+
 	public void testGetDeclaredPointcuts() {
 		ResolvedMember[] pointcuts = objectType.getDeclaredPointcuts();
-		assertEquals(0,pointcuts.length);
+		assertEquals(0, pointcuts.length);
 	}
-	
-	
-	
+
 	public void testSerializableSuperclass() {
 		ResolvedType serializableType = world.resolve("java.io.Serializable");
 		ResolvedType superType = serializableType.getSuperclass();
-        assertTrue("Superclass of serializable should be Object but was "+superType,superType.equals(UnresolvedType.OBJECT));    
+		assertTrue("Superclass of serializable should be Object but was " + superType, superType.equals(UnresolvedType.OBJECT));
 
-        BcelWorld bcelworld = new BcelWorld();
-        bcelworld.setBehaveInJava5Way(true);
-        ResolvedType bcelSupertype = bcelworld.resolve(UnresolvedType.SERIALIZABLE).getSuperclass();
-        assertTrue("Should be null but is "+bcelSupertype,bcelSupertype.equals(UnresolvedType.OBJECT));
+		BcelWorld bcelworld = new BcelWorld();
+		bcelworld.setBehaveInJava5Way(true);
+		ResolvedType bcelSupertype = bcelworld.resolve(UnresolvedType.SERIALIZABLE).getSuperclass();
+		assertTrue("Should be null but is " + bcelSupertype, bcelSupertype.equals(UnresolvedType.OBJECT));
 	}
-	
-	public void testSubinterfaceSuperclass() {		
+
+	public void testSubinterfaceSuperclass() {
 		ResolvedType ifaceType = world.resolve("java.security.Key");
 		ResolvedType superType = ifaceType.getSuperclass();
-		assertTrue("Superclass should be Object but was "+superType,superType.equals(UnresolvedType.OBJECT));  
+		assertTrue("Superclass should be Object but was " + superType, superType.equals(UnresolvedType.OBJECT));
 
-        BcelWorld bcelworld = new BcelWorld();
-        bcelworld.setBehaveInJava5Way(true);
-        ResolvedType bcelSupertype = bcelworld.resolve("java.security.Key").getSuperclass();
-        assertTrue("Should be null but is "+bcelSupertype,bcelSupertype.equals(UnresolvedType.OBJECT));
+		BcelWorld bcelworld = new BcelWorld();
+		bcelworld.setBehaveInJava5Way(true);
+		ResolvedType bcelSupertype = bcelworld.resolve("java.security.Key").getSuperclass();
+		assertTrue("Should be null but is " + bcelSupertype, bcelSupertype.equals(UnresolvedType.OBJECT));
 	}
-	
+
 	public void testVoidSuperclass() {
 		ResolvedType voidType = world.resolve(Void.TYPE);
 		ResolvedType superType = voidType.getSuperclass();
 		assertNull(superType);
-		   
-        BcelWorld bcelworld = new BcelWorld();
-        bcelworld.setBehaveInJava5Way(true);
-        ResolvedType bcelSupertype = bcelworld.resolve("void").getSuperclass();
-        assertTrue("Should be null but is "+bcelSupertype,bcelSupertype==null);
+
+		BcelWorld bcelworld = new BcelWorld();
+		bcelworld.setBehaveInJava5Way(true);
+		ResolvedType bcelSupertype = bcelworld.resolve("void").getSuperclass();
+		assertTrue("Should be null but is " + bcelSupertype, bcelSupertype == null);
 	}
 
 	public void testIntSuperclass() {
@@ -218,94 +215,99 @@ public abstract class ReflectionBasedReferenceTypeDelegateTest extends TestCase
 		ResolvedType superType = voidType.getSuperclass();
 		assertNull(superType);
 
-        BcelWorld bcelworld = new BcelWorld();
-        bcelworld.setBehaveInJava5Way(true);
-        ResolvedType bcelSupertype = bcelworld.resolve("int").getSuperclass();
-        assertTrue("Should be null but is "+bcelSupertype,bcelSupertype==null);
+		BcelWorld bcelworld = new BcelWorld();
+		bcelworld.setBehaveInJava5Way(true);
+		ResolvedType bcelSupertype = bcelworld.resolve("int").getSuperclass();
+		assertTrue("Should be null but is " + bcelSupertype, bcelSupertype == null);
 	}
-	
-    public void testGenericInterfaceSuperclass_BcelWorldResolution() {
-        BcelWorld bcelworld = new BcelWorld();
-        bcelworld.setBehaveInJava5Way(true);
-        
-        UnresolvedType javaUtilMap = UnresolvedType.forName("java.util.Map");
-        
-        ReferenceType rawType = (ReferenceType) bcelworld.resolve(javaUtilMap);
-        assertTrue("Should be the raw type ?!? "+rawType.getTypekind(),rawType.isRawType());
-        
-        ReferenceType genericType = (ReferenceType)rawType.getGenericType();
-        assertTrue("Should be the generic type ?!? "+genericType.getTypekind(),genericType.isGenericType());
-        
-        ResolvedType rt = rawType.getSuperclass();
-        assertTrue("Superclass for Map raw type should be Object but was "+rt,rt.equals(UnresolvedType.OBJECT));         
-        
-        ResolvedType rt2 = genericType.getSuperclass();
-        assertTrue("Superclass for Map generic type should be Object but was "+rt2,rt2.equals(UnresolvedType.OBJECT));         
-    }
-    
-    // FIXME asc maybe.  The reflection list of methods returned doesn't include <clinit> (the static initializer) ... is that really a problem.
-    public void testCompareSubclassDelegates() {
-    	
-    	boolean barfIfClinitMissing = false;
-        world.setBehaveInJava5Way(true);
-        
-        BcelWorld bcelWorld = new BcelWorld(getClass().getClassLoader(),IMessageHandler.THROW,null);
-        bcelWorld.setBehaveInJava5Way(true);
-        UnresolvedType javaUtilHashMap = UnresolvedType.forName("java.util.HashMap");
-        ReferenceType rawType =(ReferenceType)bcelWorld.resolve(javaUtilHashMap );
-        
-        ReferenceType rawReflectType =(ReferenceType)world.resolve(javaUtilHashMap );
-        ResolvedMember[] rms1 = rawType.getDelegate().getDeclaredMethods();
-        ResolvedMember[] rms2 = rawReflectType.getDelegate().getDeclaredMethods();
-        StringBuffer errors = new StringBuffer();
-        Set one = new HashSet();
-        for (int i = 0; i < rms1.length; i++) {
+
+	public void testGenericInterfaceSuperclass_BcelWorldResolution() {
+		BcelWorld bcelworld = new BcelWorld();
+		bcelworld.setBehaveInJava5Way(true);
+
+		UnresolvedType javaUtilMap = UnresolvedType.forName("java.util.Map");
+
+		ReferenceType rawType = (ReferenceType) bcelworld.resolve(javaUtilMap);
+		assertTrue("Should be the raw type ?!? " + rawType.getTypekind(), rawType.isRawType());
+
+		ReferenceType genericType = (ReferenceType) rawType.getGenericType();
+		assertTrue("Should be the generic type ?!? " + genericType.getTypekind(), genericType.isGenericType());
+
+		ResolvedType rt = rawType.getSuperclass();
+		assertTrue("Superclass for Map raw type should be Object but was " + rt, rt.equals(UnresolvedType.OBJECT));
+
+		ResolvedType rt2 = genericType.getSuperclass();
+		assertTrue("Superclass for Map generic type should be Object but was " + rt2, rt2.equals(UnresolvedType.OBJECT));
+	}
+
+	// FIXME asc maybe. The reflection list of methods returned doesn't include <clinit> (the static initializer) ... is that really
+	// a problem.
+	public void testCompareSubclassDelegates() {
+
+		boolean barfIfClinitMissing = false;
+		world.setBehaveInJava5Way(true);
+
+		BcelWorld bcelWorld = new BcelWorld(getClass().getClassLoader(), IMessageHandler.THROW, null);
+		bcelWorld.setBehaveInJava5Way(true);
+		UnresolvedType javaUtilHashMap = UnresolvedType.forName("java.util.HashMap");
+		ReferenceType rawType = (ReferenceType) bcelWorld.resolve(javaUtilHashMap);
+
+		ReferenceType rawReflectType = (ReferenceType) world.resolve(javaUtilHashMap);
+		ResolvedMember[] rms1 = rawType.getDelegate().getDeclaredMethods();
+		ResolvedMember[] rms2 = rawReflectType.getDelegate().getDeclaredMethods();
+		StringBuffer errors = new StringBuffer();
+		Set one = new HashSet();
+		for (int i = 0; i < rms1.length; i++) {
 			one.add(rms1[i].toString());
 		}
-        Set two = new HashSet();
-        for (int i = 0; i < rms2.length; i++) {
+		Set two = new HashSet();
+		for (int i = 0; i < rms2.length; i++) {
 			two.add(rms2[i].toString());
 		}
-        for (int i = 0;i<rms2.length;i++) {
-        	if (!one.contains(rms2[i].toString())) {
-        		errors.append("Couldn't find "+rms2[i].toString()+" in the bcel set\n");
-        	}
-        }
-        for (int i = 0;i<rms1.length;i++) {
-        	if (!two.contains(rms1[i].toString())) {
-        		if (!barfIfClinitMissing && rms1[i].getName().equals("<clinit>")) continue;
-        		errors.append("Couldn't find "+rms1[i].toString()+" in the reflection set\n");
-        	}
-        }
-        assertTrue("Errors:"+errors.toString(),errors.length()==0);
-        
-        // the good old ibm vm seems to offer clinit through its reflection support (see pr145322)
-        if (rms1.length==rms2.length) return;
-        if (barfIfClinitMissing) {
-        	// the numbers must be exact
-            assertEquals(rms1.length,rms2.length);        	
-        } else {
-        	// the numbers can be out by one in favour of bcel
-        	if (rms1.length!=(rms2.length+1)) {
-        		for (int i = 0; i < rms1.length; i++) {
-					System.err.println("bcel"+i+" is "+rms1[i]);
+		for (int i = 0; i < rms2.length; i++) {
+			if (!one.contains(rms2[i].toString())) {
+				errors.append("Couldn't find " + rms2[i].toString() + " in the bcel set\n");
+			}
+		}
+		for (int i = 0; i < rms1.length; i++) {
+			if (!two.contains(rms1[i].toString())) {
+				if (!barfIfClinitMissing && rms1[i].getName().equals("<clinit>"))
+					continue;
+				errors.append("Couldn't find " + rms1[i].toString() + " in the reflection set\n");
+			}
+		}
+		assertTrue("Errors:" + errors.toString(), errors.length() == 0);
+
+		// the good old ibm vm seems to offer clinit through its reflection support (see pr145322)
+		if (rms1.length == rms2.length)
+			return;
+		if (barfIfClinitMissing) {
+			// the numbers must be exact
+			assertEquals(rms1.length, rms2.length);
+		} else {
+			// the numbers can be out by one in favour of bcel
+			if (rms1.length != (rms2.length + 1)) {
+				for (int i = 0; i < rms1.length; i++) {
+					System.err.println("bcel" + i + " is " + rms1[i]);
 				}
-        		for (int i = 0; i < rms2.length; i++) {
-					System.err.println("refl"+i+" is "+rms2[i]);
+				for (int i = 0; i < rms2.length; i++) {
+					System.err.println("refl" + i + " is " + rms2[i]);
 				}
-        	}
-        	assertTrue("Should be one extra (clinit) in BCEL case, but bcel="+rms1.length+" reflect="+rms2.length,rms1.length==rms2.length+1);
-        }
-    }
-
-    public void testArrayArgsSig() throws Exception {
-    	Method invokeMethod = Method.class.getMethod("invoke", new Class[] { Object.class, Object[].class});
-    	ResolvedMember reflectionMethod = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(invokeMethod, world);
-    	String exp = "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;";
-    	assertTrue("Expected: \n"+exp+"\n but got:\n"+reflectionMethod.getSignature(), reflectionMethod.getSignature().equals(exp));
-    }
-    	    
-	// todo: array of int	
+			}
+			assertTrue("Should be one extra (clinit) in BCEL case, but bcel=" + rms1.length + " reflect=" + rms2.length,
+					rms1.length == rms2.length + 1);
+		}
+	}
+
+	public void testArrayArgsSig() throws Exception {
+		Method invokeMethod = Method.class.getMethod("invoke", new Class[] { Object.class, Object[].class });
+		ResolvedMember reflectionMethod = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(invokeMethod, world);
+		String exp = "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;";
+		assertTrue("Expected: \n" + exp + "\n but got:\n" + reflectionMethod.getSignature(), reflectionMethod.getSignature()
+				.equals(exp));
+	}
+
+	// todo: array of int
 
 	protected void setUp() throws Exception {
 		world = new ReflectionWorld(getClass().getClassLoader());
@@ -14,6 +14,7 @@ package org.aspectj.weaver.reflect;
 import junit.framework.TestCase;
 
 import org.aspectj.weaver.ResolvedType;
+import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.World;
 
 public class ReflectionWorldTest extends TestCase {
@@ -22,20 +23,20 @@ public class ReflectionWorldTest extends TestCase {
 		World world = new ReflectionWorld(getClass().getClassLoader());
 		ResolvedType rt = world.resolve("java.lang.Object");
 		assertNotNull(rt);
-		assertEquals("Ljava/lang/Object;",rt.getSignature());
+		assertEquals("Ljava/lang/Object;", rt.getSignature());
 	}
-	
+
 	public void testArrayTypes() {
 		IReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());
 		String[] strArray = new String[1];
 		ResolvedType rt = world.resolve(strArray.getClass());
 		assertTrue(rt.isArray());
 	}
-	
+
 	public void testPrimitiveTypes() {
 		IReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());
-		assertEquals("int",ResolvedType.INT,world.resolve(int.class));
-		assertEquals("void",ResolvedType.VOID,world.resolve(void.class));
+		assertEquals("int", UnresolvedType.INT, world.resolve(int.class));
+		assertEquals("void", UnresolvedType.VOID, world.resolve(void.class));
 	}
-	
+
 }
@@ -0,0 +1,119 @@
+/* *******************************************************************
+ * Copyright (c) 2011 Contributors
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *     Andy Clement - SpringSource/vmware
+ * ******************************************************************/
+package org.aspectj.weaver.bcel;
+
+import org.aspectj.apache.bcel.Constants;
+import org.aspectj.apache.bcel.generic.Instruction;
+import org.aspectj.apache.bcel.generic.InstructionFactory;
+import org.aspectj.apache.bcel.generic.InstructionList;
+import org.aspectj.weaver.ResolvedType;
+
+/**
+ * Used to represent a variable reference to an aspect instance. This is used to support the if pointcut usage of
+ * 'thisAspectInstance'. This variable does not have a slot, instead on requesting a reference we call aspectOf() on the aspect in
+ * question to retrieve it. For now it only works with singleton aspects.
+ */
+public class AspectInstanceVar extends BcelVar {
+
+	public AspectInstanceVar(ResolvedType type) {
+		super(type, -1);
+	}
+
+	// fact is used in the subtypes
+	public Instruction createLoad(InstructionFactory fact) {
+
+		throw new IllegalStateException();
+		// return InstructionFactory.createLoad(BcelWorld.makeBcelType(getType()), slot);
+	}
+
+	public Instruction createStore(InstructionFactory fact) {
+		throw new IllegalStateException();
+		// return InstructionFactory.createStore(BcelWorld.makeBcelType(getType()), slot);
+	}
+
+	public void appendStore(InstructionList il, InstructionFactory fact) {
+		throw new IllegalStateException();
+		// il.append(createStore(fact));
+	}
+
+	public void appendLoad(InstructionList il, InstructionFactory fact) {
+		throw new IllegalStateException();
+		// il.append(createLoad(fact));
+	}
+
+	public void appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType) {
+		throw new IllegalStateException();
+		// il.append(createLoad(fact));
+		// Utility.appendConversion(il, fact, getType(), toType);
+	}
+
+	public void insertLoad(InstructionList il, InstructionFactory fact) {
+		InstructionList loadInstructions = new InstructionList();
+		loadInstructions.append(fact.createInvoke(getType().getName(), "aspectOf", "()" + getType().getSignature(),
+				Constants.INVOKESTATIC));
+		il.insert(loadInstructions);
+		// throw new IllegalStateException();
+		// il.insert(createLoad(fact));
+	}
+
+	public InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {
+		throw new IllegalStateException();
+		// InstructionList il = new InstructionList();
+		// il.append(InstructionFactory.createLoad(BcelWorld.makeBcelType(getType()), oldSlot));
+		// il.append(createStore(fact));
+		// return il;
+	}
+
+	// this is an array var
+	void appendConvertableArrayLoad(InstructionList il, InstructionFactory fact, int index, ResolvedType convertTo) {
+		throw new IllegalStateException();
+		// ResolvedType convertFromType = getType().getResolvedComponentType();
+		// appendLoad(il, fact);
+		// il.append(Utility.createConstant(fact, index));
+		// il.append(InstructionFactory.createArrayLoad(BcelWorld.makeBcelType(convertFromType)));
+		// Utility.appendConversion(il, fact, convertFromType, convertTo);
+	}
+
+	void appendConvertableArrayStore(InstructionList il, InstructionFactory fact, int index, BcelVar storee) {
+		throw new IllegalStateException();
+		// ResolvedType convertToType = getType().getResolvedComponentType();
+		// appendLoad(il, fact);
+		// il.append(Utility.createConstant(fact, index));
+		// storee.appendLoad(il, fact);
+		// Utility.appendConversion(il, fact, storee.getType(), convertToType);
+		// il.append(InstructionFactory.createArrayStore(BcelWorld.makeBcelType(convertToType)));
+	}
+
+	InstructionList createConvertableArrayStore(InstructionFactory fact, int index, BcelVar storee) {
+		throw new IllegalStateException();
+		// InstructionList il = new InstructionList();
+		// appendConvertableArrayStore(il, fact, index, storee);
+		// return il;
+	}
+
+	InstructionList createConvertableArrayLoad(InstructionFactory fact, int index, ResolvedType convertTo) {
+		throw new IllegalStateException();
+		// InstructionList il = new InstructionList();
+		// appendConvertableArrayLoad(il, fact, index, convertTo);
+		// return il;
+	}
+
+	public int getPositionInAroundState() {
+		throw new IllegalStateException();
+		// return positionInAroundState;
+	}
+
+	public void setPositionInAroundState(int positionInAroundState) {
+		throw new IllegalStateException();
+		// this.positionInAroundState = positionInAroundState;
+	}
+}
@@ -178,6 +178,7 @@ class BcelAdvice extends Advice {
 		if (!world.areAllLintIgnored()) {
 			suppressLintWarnings(world);
 		}
+		exposedState.setConcreteAspect(concreteAspect);
 		runtimeTest = getPointcut().findResidue(shadow, exposedState);
 		if (!world.areAllLintIgnored()) {
 			clearLintSuppressions(world, this.suppressedLintKinds);
@@ -3063,7 +3063,7 @@ class BcelClassWeaver implements IClassWeaver {
 
 			if (declaredSig.getKind() == Member.FIELD) {
 				Shadow.Kind kind;
-				if (jpSig.getReturnType().equals(ResolvedType.VOID)) {
+				if (jpSig.getReturnType().equals(UnresolvedType.VOID)) {
 					kind = Shadow.FieldSet;
 				} else {
 					kind = Shadow.FieldGet;
@@ -12,6 +12,8 @@
 
 package org.aspectj.weaver.bcel;
 
+import java.lang.reflect.Modifier;
+
 import org.aspectj.apache.bcel.Constants;
 import org.aspectj.apache.bcel.generic.InstructionFactory;
 import org.aspectj.apache.bcel.generic.InstructionHandle;
@@ -22,7 +24,6 @@ import org.aspectj.apache.bcel.generic.Type;
 import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.Member;
 import org.aspectj.weaver.MemberImpl;
-import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.ast.And;
 import org.aspectj.weaver.ast.Call;
@@ -155,15 +156,14 @@ public final class BcelRenderer implements ITestVisitor, IExprVisitor {
 		// Load up the var again
 		il.append(((BcelVar) hasAnnotation.getVar()).createLoad(fact));
 
-		Member getClass = MemberImpl.method(UnresolvedType.OBJECT, 0, UnresolvedType.JL_CLASS, "getClass",
-				UnresolvedType.NONE);
+		Member getClass = MemberImpl.method(UnresolvedType.OBJECT, 0, UnresolvedType.JL_CLASS, "getClass", UnresolvedType.NONE);
 		il.append(Utility.createInvoke(fact, world, getClass));
 		// aload annotationClass
 		il.append(fact.createConstant(new ObjectType(hasAnnotation.getAnnotationType().getName())));
 		// int annClassIndex = fact.getConstantPool().addClass(hasAnnotation.getAnnotationType().getSignature());
 		// il.append(new LDC_W(annClassIndex));
-		Member isAnnotationPresent = MemberImpl.method(UnresolvedType.JL_CLASS, 0, ResolvedType.BOOLEAN,
-				"isAnnotationPresent", new UnresolvedType[] { UnresolvedType.JL_CLASS });
+		Member isAnnotationPresent = MemberImpl.method(UnresolvedType.JL_CLASS, 0, UnresolvedType.BOOLEAN, "isAnnotationPresent",
+				new UnresolvedType[] { UnresolvedType.JL_CLASS });
 		il.append(Utility.createInvoke(fact, world, isAnnotationPresent));
 		il.append(createJumpBasedOnBooleanOnStack());
 		instructions.insert(il);
@@ -210,7 +210,6 @@ public final class BcelRenderer implements ITestVisitor, IExprVisitor {
 		Member method = call.getMethod();
 		// assert method.isStatic()
 		Expr[] args = call.getArgs();
-		// System.out.println("args: " + Arrays.asList(args));
 		InstructionList callIl = new InstructionList();
 		for (int i = 0, len = args.length; i < len; i++) {
 			// XXX only correct for static method calls
@@ -1125,15 +1125,14 @@ public class BcelShadow extends Shadow {
 		return il;
 	}
 
-	/**
-	 * Get the Var for the jpStaticPart
-	 * 
-	 * @return
-	 */
 	public BcelVar getThisJoinPointStaticPartBcelVar() {
 		return getThisJoinPointStaticPartBcelVar(false);
 	}
 
+	public BcelVar getThisAspectInstanceVar(ResolvedType aspectType) {
+		return new AspectInstanceVar(aspectType);
+	}
+
 	/**
 	 * Get the Var for the xxxxJpStaticPart, xxx = this or enclosing
 	 * 
@@ -1406,7 +1405,7 @@ public class BcelShadow extends Shadow {
 					argVars[i] = tmp;
 					tmp.setPositionInAroundState(i + positionOffset);
 				}
-				index += type.getSize();
+				index += type.resolve(world).getSize();
 			}
 		}
 		allArgVarsInitialized = true;
@@ -1790,7 +1789,7 @@ public class BcelShadow extends Shadow {
 	 * @return true, iff this shadow returns a value
 	 */
 	private boolean hasANonVoidReturnType() {
-		return this.getReturnType() != ResolvedType.VOID;
+		return !this.getReturnType().equals(UnresolvedType.VOID);
 	}
 
 	/**
@@ -1821,7 +1820,7 @@ public class BcelShadow extends Shadow {
 	private BcelVar insertAdviceInstructionsForBindingReturningParameter(InstructionList advice) {
 		BcelVar tempVar;
 		UnresolvedType tempVarType = getReturnType();
-		if (tempVarType.equals(ResolvedType.VOID)) {
+		if (tempVarType.equals(UnresolvedType.VOID)) {
 			tempVar = genTempVar(UnresolvedType.OBJECT);
 			advice.append(InstructionConstants.ACONST_NULL);
 			tempVar.appendStore(advice, getFactory());
@@ -2026,7 +2025,7 @@ public class BcelShadow extends Shadow {
 		final Type objectArrayType = new ArrayType(Type.OBJECT, 1);
 		final InstructionFactory fact = getFactory();
 
-		final BcelVar testResult = genTempVar(ResolvedType.BOOLEAN);
+		final BcelVar testResult = genTempVar(UnresolvedType.BOOLEAN);
 
 		InstructionList entryInstructions = new InstructionList();
 		{
@@ -3297,7 +3296,7 @@ public class BcelShadow extends Shadow {
 			if (getKind() == ConstructorCall) {
 				returnType = getSignature().getDeclaringType();
 			} else if (getKind() == FieldSet) {
-				returnType = ResolvedType.VOID;
+				returnType = UnresolvedType.VOID;
 			} else {
 				returnType = getSignature().getReturnType().resolve(world);
 				// returnType = getReturnType(); // for this and above lines, see pr137496
@@ -3333,8 +3332,9 @@ public class BcelShadow extends Shadow {
 		return ret;
 	}
 
-	public BcelVar genTempVar(UnresolvedType typeX) {
-		return new BcelVar(typeX.resolve(world), genTempVarIndex(typeX.getSize()));
+	public BcelVar genTempVar(UnresolvedType utype) {
+		ResolvedType rtype = utype.resolve(world);
+		return new BcelVar(rtype, genTempVarIndex(rtype.getSize()));
 	}
 
 	// public static final boolean CREATE_TEMP_NAMES = true;
@@ -1722,7 +1722,12 @@ public class BcelWeaver {
 					String classDebugInfo = null;
 					try {
 						classDebugInfo = clazz.toLongString();
-					} catch (Exception e) {
+					} catch (OutOfMemoryError oome) {
+						System.err.println("Ran out of memory creating debug info for an error");
+						re.printStackTrace(System.err);
+						// recover from crash whilst producing debug string
+						classDebugInfo = clazz.getClassName();
+					} catch (Throwable e) {
 						// recover from crash whilst producing debug string
 						classDebugInfo = clazz.getClassName();
 					}
@@ -577,7 +577,7 @@ public class BcelWorld extends World implements Repository {
 			Type ot = i.getType(cpg);
 			UnresolvedType ut = fromBcel(ot);
 			ut = UnresolvedType.makeArray(ut, 1);
-			retval = MemberImpl.method(ut, Modifier.PUBLIC, ResolvedType.VOID, "<init>", new ResolvedType[] { ResolvedType.INT });
+			retval = MemberImpl.method(ut, Modifier.PUBLIC, UnresolvedType.VOID, "<init>", new ResolvedType[] { INT });
 		} else if (i instanceof MULTIANEWARRAY) {
 			MULTIANEWARRAY arrayInstruction = (MULTIANEWARRAY) i;
 			UnresolvedType ut = null;
@@ -592,15 +592,15 @@ public class BcelWorld extends World implements Repository {
 			}
 			ResolvedType[] parms = new ResolvedType[dimensions];
 			for (int ii = 0; ii < dimensions; ii++) {
-				parms[ii] = ResolvedType.INT;
+				parms[ii] = INT;
 			}
-			retval = MemberImpl.method(ut, Modifier.PUBLIC, ResolvedType.VOID, "<init>", parms);
+			retval = MemberImpl.method(ut, Modifier.PUBLIC, UnresolvedType.VOID, "<init>", parms);
 
 		} else if (i.opcode == Constants.NEWARRAY) {
 			// NEWARRAY arrayInstruction = (NEWARRAY)i;
 			Type ot = i.getType();
 			UnresolvedType ut = fromBcel(ot);
-			retval = MemberImpl.method(ut, Modifier.PUBLIC, ResolvedType.VOID, "<init>", new ResolvedType[] { ResolvedType.INT });
+			retval = MemberImpl.method(ut, Modifier.PUBLIC, UnresolvedType.VOID, "<init>", new ResolvedType[] { INT });
 		} else {
 			throw new BCException("Cannot create array construction signature for this non-array instruction:" + i);
 		}
@@ -682,7 +682,7 @@ public class BcelWorld extends World implements Repository {
 		classPath.closeArchives();
 		typeMap.report();
 		typeMap.demote(true);
-		ResolvedType.resetPrimitives();
+		// ResolvedType.resetPrimitives();
 	}
 
 	// / The repository interface methods
@@ -268,7 +268,7 @@ public final class LazyClassGen {
 			// for (int i = 0; i < fields.length; i++) {
 			// ResolvedMember field = fields[i];
 			// if (field.getName().equals("serialVersionUID")
-			// && field.isStatic() && field.getType().equals(ResolvedType.LONG))
+			// && field.isStatic() && field.getType().equals(UnresolvedType.LONG))
 			// {
 			// hasSerialVersionUIDField = true;
 			// }
@@ -324,7 +324,7 @@ public final class LazyClassGen {
 		for (int i = 0; i < fields.length; i++) {
 			ResolvedMember field = fields[i];
 			if (field.getName().equals("serialVersionUID") && Modifier.isStatic(field.getModifiers())
-					&& field.getType().equals(ResolvedType.LONG)) {
+					&& field.getType().equals(UnresolvedType.LONG)) {
 				return true;
 			}
 		}
@@ -333,7 +333,6 @@ public final class LazyMethodGen implements Traceable {
 		if (returnType != null) {
 			return;
 		}
-
 		MethodGen gen = new MethodGen(savedMethod, enclosingClass.getName(), enclosingClass.getConstantPool(), true);
 
 		this.returnType = gen.getReturnType();
@@ -1260,7 +1259,7 @@ public final class LazyMethodGen implements Traceable {
 		// due to insertion of advice like cflow entry)
 		int paramSlots = gen.isStatic() ? 0 : 1;
 		Type[] argTypes = gen.getArgumentTypes();
-		if (argTypes!=null) {
+		if (argTypes != null) {
 			for (int i = 0; i < argTypes.length; i++) {
 				if (argTypes[i].getSize() == 2) {
 					paramSlots += 2;
@@ -281,10 +281,10 @@ public class Utility {
 				return;
 			}
 		}
-		if (toType.equals(ResolvedType.VOID)) {
+		if (toType.equals(UnresolvedType.VOID)) {
 			// assert fromType.equals(UnresolvedType.OBJECT)
 			il.append(InstructionFactory.createPop(fromType.getSize()));
-		} else if (fromType.equals(ResolvedType.VOID)) {
+		} else if (fromType.equals(UnresolvedType.VOID)) {
 			// assert toType.equals(UnresolvedType.OBJECT)
 			il.append(InstructionFactory.createNull(Type.OBJECT));
 			return;
@@ -11,24 +11,23 @@
  *******************************************************************************/
 package org.aspectj.weaver.loadtime.definition;
 
+import java.io.Reader;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Map;
-import java.io.Reader;
 
 public class LightXMLParser {
 
 	private final static char NULL_CHAR = '\0';
-	private Map attributes;
+	private Map<String, Object> attributes;
 	private ArrayList children;
 	private String name;
 	private char pushedBackChar;
 	private Reader reader;
 
-	private static Map entities = new HashMap();
-
+	private static Map<String, char[]> entities = new HashMap<String, char[]>();
 
-	static{
+	static {
 		entities.put("amp", new char[] { '&' });
 		entities.put("quot", new char[] { '"' });
 		entities.put("apos", new char[] { '\'' });
@@ -38,7 +37,7 @@ public class LightXMLParser {
 
 	public LightXMLParser() {
 		this.name = null;
-		this.attributes = new HashMap();
+		this.attributes = new HashMap<String, Object>();
 		this.children = new ArrayList();
 	}
 
@@ -52,7 +51,7 @@ public class LightXMLParser {
 
 	public void parseFromReader(Reader reader) throws Exception {
 		this.pushedBackChar = NULL_CHAR;
-		this.attributes = new HashMap();
+		this.attributes = new HashMap<String, Object>();
 		this.name = null;
 		this.children = new ArrayList();
 		this.reader = reader;
@@ -64,8 +63,7 @@ public class LightXMLParser {
 			// All xml should start by <xml, a <!-- or <nodeName, if not throw
 			// exception
 			if (c != '<') {
-				throw new Exception(
-						"LightParser Exception: Expected < but got: " + c);
+				throw new Exception("LightParser Exception: Expected < but got: " + c);
 			}
 
 			// read next character
@@ -122,8 +120,7 @@ public class LightXMLParser {
 			// Iterate while next character is not [a-z] [A-Z] [0-9] [ .:_-] not
 			// null
 			c = this.getNextChar();
-			if (((c < 'a') || (c > 'z')) && ((c > 'Z') || (c < 'A'))
-					&& ((c > '9') || (c < '0')) && (c != '_') && (c != '-')
+			if (((c < 'a') || (c > 'z')) && ((c > 'Z') || (c < 'A')) && ((c > '9') || (c < '0')) && (c != '_') && (c != '-')
 					&& (c != '.') && (c != ':')) {
 				this.pushBackChar(c);
 				return;
@@ -135,12 +132,10 @@ public class LightXMLParser {
 	private void getString(StringBuffer string) throws Exception {
 		char delimiter = this.getNextChar();
 		if ((delimiter != '\'') && (delimiter != '"')) {
-			throw new Exception("Parsing error. Expected ' or \"  but got: "
-					+ delimiter);
+			throw new Exception("Parsing error. Expected ' or \"  but got: " + delimiter);
 
 		}
 
-
 		while (true) {
 			char c = this.getNextChar();
 			if (c == delimiter) {
@@ -339,8 +334,7 @@ public class LightXMLParser {
 					for (int i = 0; i < 2; i++) {
 						c = this.getNextChar();
 						if (c != '-') {
-							throw new Exception(
-							"Parsing error. Expected element or comment");
+							throw new Exception("Parsing error. Expected element or comment");
 						}
 					}
 					this.skipComment();
@@ -353,8 +347,7 @@ public class LightXMLParser {
 				}
 				c = this.skipBlanks();
 				if (c != '<') {
-					throw new Exception("Parsing error. Expected <, but got: "
-							+ c);
+					throw new Exception("Parsing error. Expected <, but got: " + c);
 				}
 				c = this.getNextChar();
 			}
@@ -387,8 +380,7 @@ public class LightXMLParser {
 
 		char nextChar = this.getNextChar();
 		if (nextChar != '>') {
-			throw new Exception("Parsing error. Expected > but got: "
-					+ nextChar);
+			throw new Exception("Parsing error. Expected > but got: " + nextChar);
 		}
 	}
 
@@ -417,10 +409,7 @@ public class LightXMLParser {
 		}
 	}
 
-
-	private void mapEntity(StringBuffer buf)
-	throws Exception
-	{
+	private void mapEntity(StringBuffer buf) throws Exception {
 		char c = this.NULL_CHAR;
 		StringBuffer keyBuf = new StringBuffer();
 		while (true) {
@@ -450,6 +439,7 @@ public class LightXMLParser {
 			buf.append(value);
 		}
 	}
+
 	private void pushBackChar(char c) {
 		this.pushedBackChar = c;
 	}
@@ -462,7 +452,7 @@ public class LightXMLParser {
 		this.attributes.put(name, value.toString());
 	}
 
-	public Map getAttributes() {
+	public Map<String, Object> getAttributes() {
 		return this.attributes;
 	}
 
@@ -48,7 +48,6 @@ import org.aspectj.util.LangUtil;
 import org.aspectj.weaver.IClassFileProvider;
 import org.aspectj.weaver.IUnwovenClassFile;
 import org.aspectj.weaver.IWeaveRequestor;
-import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.bcel.BcelObjectType;
 import org.aspectj.weaver.bcel.BcelWeaver;
@@ -844,11 +843,11 @@ public class WeavingAdaptor implements IMessageContext {
 				}
 
 				public void weaveCompleted() {
-					ResolvedType.resetPrimitives();
+					// ResolvedType.resetPrimitives();
 					if (delegateForCurrentClass != null) {
 						delegateForCurrentClass.weavingCompleted();
 					}
-					ResolvedType.resetPrimitives();
+					// ResolvedType.resetPrimitives();
 					// bcelWorld.discardType(typeBeingProcessed.getResolvedTypeX()); // work in progress
 				}
 			};
@@ -12,7 +12,6 @@
  *     Adrian Colyer, canBeParameterized tests 
  * ******************************************************************/
 
-
 package org.aspectj.weaver;
 
 import java.lang.reflect.Modifier;
@@ -26,154 +25,159 @@ import org.aspectj.testing.util.TestUtil;
  */
 public class MemberTestCase extends TestCase {
 
-    public MemberTestCase(String name) {
-        super(name);
-    }
-
-    public void testMethodConstruction() {
-        Member s = TestUtils.methodFromString("void Foo.goo(int)");
-        Member t = MemberImpl.method(UnresolvedType.forName("Foo"), 0, "goo", "(I)V");
-        Member u = TestUtils.methodFromString("void Foo1.goo(int)");
-        Member v = TestUtils.methodFromString("int Foo.goo(int)");
-
-        TestUtil.assertCommutativeEquals(s, s, true);
-        TestUtil.assertCommutativeEquals(t, t, true);
-        TestUtil.assertCommutativeEquals(u, u, true);
-        TestUtil.assertCommutativeEquals(v, v, true);
-        TestUtil.assertCommutativeEquals(s, t, true);
-        TestUtil.assertCommutativeEquals(s, u, false);
-        TestUtil.assertCommutativeEquals(s, v, false);
-        TestUtil.assertCommutativeEquals(t, u, false);
-        TestUtil.assertCommutativeEquals(t, v, false);
-        TestUtil.assertCommutativeEquals(u, v, false);
-
-        s = TestUtils.fieldFromString("int Foo.goo");
-        t = MemberImpl.field("Foo", 0, "goo", "I");
-        u = TestUtils.fieldFromString("int Foo.goo1");
-        v = TestUtils.fieldFromString("long Foo.goo");
-
-        TestUtil.assertCommutativeEquals(s, s, true);
-        TestUtil.assertCommutativeEquals(t, t, true);
-        TestUtil.assertCommutativeEquals(u, u, true);
-        TestUtil.assertCommutativeEquals(v, v, true);
-        TestUtil.assertCommutativeEquals(s, t, true);
-        TestUtil.assertCommutativeEquals(s, u, false);
-        TestUtil.assertCommutativeEquals(s, v, false);
-        TestUtil.assertCommutativeEquals(t, u, false);
-        TestUtil.assertCommutativeEquals(t, v, false);
-        TestUtil.assertCommutativeEquals(u, v, false);
-    }
-
-
-    public void testMethodContents() {
-        Member m = TestUtils.methodFromString("void Foo.goo(int)");
-        kindTest(m, Member.METHOD);
-        declaringTypeTest(m, "Foo");
-        nameTest(m, "goo");
-        parameterTypesTest(m, new UnresolvedType[] { ResolvedType.INT });
-        returnTypeTest(m, ResolvedType.VOID);
-        isInterfaceTest(m, false);
-        isPrivateTest(m, false);
-        isConstructorTest(m, false);
-        isStaticTest(m, false);
-
-        m = TestUtils.methodFromString("interface java.lang.Object java.util.Iterator.next()");
-        kindTest(m, Member.METHOD);
-        declaringTypeTest(m, "java.util.Iterator");
-        nameTest(m, "next");
-        parameterTypesTest(m, UnresolvedType.NONE);
-        returnTypeTest(m, UnresolvedType.OBJECT);
-        isInterfaceTest(m, true);
-        isPrivateTest(m, false);
-        isConstructorTest(m, false);
-        isStaticTest(m, false);
-
-        m = TestUtils.methodFromString("void Foo.<init>(int, java.lang.Object)");
-        kindTest(m, Member.CONSTRUCTOR);
-        declaringTypeTest(m, "Foo");
-        nameTest(m, "<init>");
-        parameterTypesTest(m, new UnresolvedType[] { ResolvedType.INT, UnresolvedType.OBJECT } );
-        returnTypeTest(m, ResolvedType.VOID);
-        isInterfaceTest(m, false);
-        isPrivateTest(m, false);
-        isConstructorTest(m, true);
-        isStaticTest(m, false);
-
-        m = TestUtils.methodFromString("private double Foo.sqrt(double)");
-        kindTest(m, Member.METHOD);
-        declaringTypeTest(m, "Foo");
-        nameTest(m, "sqrt");
-        parameterTypesTest(m, new UnresolvedType[] { ResolvedType.DOUBLE } );
-        returnTypeTest(m, ResolvedType.DOUBLE);
-        isInterfaceTest(m, false);
-        isPrivateTest(m, true);
-        isConstructorTest(m, false);
-        isStaticTest(m, false);
-
-        m = TestUtils.methodFromString("static int java.lang.Math.max(int, int)");
-        kindTest(m, Member.METHOD);
-        declaringTypeTest(m, "java.lang.Math");
-        nameTest(m, "max");
-        parameterTypesTest(m, new UnresolvedType[] { ResolvedType.INT, ResolvedType.INT } );
-        returnTypeTest(m, ResolvedType.INT);
-        isInterfaceTest(m, false);
-        isPrivateTest(m, false);
-        isConstructorTest(m, false);
-        isStaticTest(m, true);
-    }
-
-    public void testFieldContents() {
-        Member m = TestUtils.fieldFromString("int Foo.goo");
-        kindTest(m, Member.FIELD);
-        declaringTypeTest(m, "Foo");
-        nameTest(m, "goo");
-        parameterTypesTest(m, UnresolvedType.NONE);
-        returnTypeTest(m, ResolvedType.INT);
-        isInterfaceTest(m, false);
-        isPrivateTest(m, false);
-        isConstructorTest(m, false);
-        isStaticTest(m, false);
-
-        m = TestUtils.fieldFromString("static java.util.Iterator goo.Bar.i");
-        kindTest(m, Member.FIELD);
-        declaringTypeTest(m, "goo.Bar");
-        nameTest(m, "i");
-        parameterTypesTest(m, UnresolvedType.NONE);
-        returnTypeTest(m, UnresolvedType.forName("java.util.Iterator"));
-        isInterfaceTest(m, false);
-        isPrivateTest(m, false);
-        isConstructorTest(m, false);
-        isStaticTest(m, true);
-    }
-
-    private void isStaticTest(Member m, boolean b) {
-        assertEquals(m + " is static", b, Modifier.isStatic(m.getModifiers()));
-    }
-    private void isConstructorTest(Member m, boolean b) {
-        assertEquals(m + " is constructor", b, m.getKind() == Member.CONSTRUCTOR);
-    }
-    private void isPrivateTest(Member m, boolean b) {
-        assertEquals(m + " is private", b, Modifier.isPrivate(m.getModifiers()));
-    }
-    private void isInterfaceTest(Member m, boolean b) {
-        assertEquals(m + " is interface", b, Modifier.isInterface(m.getModifiers()));
-    }
-    private void returnTypeTest(Member m, UnresolvedType returnType) {
-        assertEquals(m + " return type", returnType, m.getReturnType());
-    }
-    private void parameterTypesTest(Member m, UnresolvedType[] paramTypes) {
-        TestUtil.assertArrayEquals(m + " parameters", paramTypes, m.getParameterTypes());
-    }
-    private void nameTest(Member m, String name) {
-        assertEquals(m + " name", name, m.getName());
-    }
-    private void declaringTypeTest(Member m, String declaringName) {
-        assertEquals(m + " declared in", UnresolvedType.forName(declaringName), m.getDeclaringType());
-    }
-    private void kindTest(Member m, MemberKind kind) {
-        assertEquals(m + " kind", kind, m.getKind());
-    }   
-   
-    
-    
+	public MemberTestCase(String name) {
+		super(name);
+	}
+
+	public void testMethodConstruction() {
+		Member s = TestUtils.methodFromString("void Foo.goo(int)");
+		Member t = MemberImpl.method(UnresolvedType.forName("Foo"), 0, "goo", "(I)V");
+		Member u = TestUtils.methodFromString("void Foo1.goo(int)");
+		Member v = TestUtils.methodFromString("int Foo.goo(int)");
+
+		TestUtil.assertCommutativeEquals(s, s, true);
+		TestUtil.assertCommutativeEquals(t, t, true);
+		TestUtil.assertCommutativeEquals(u, u, true);
+		TestUtil.assertCommutativeEquals(v, v, true);
+		TestUtil.assertCommutativeEquals(s, t, true);
+		TestUtil.assertCommutativeEquals(s, u, false);
+		TestUtil.assertCommutativeEquals(s, v, false);
+		TestUtil.assertCommutativeEquals(t, u, false);
+		TestUtil.assertCommutativeEquals(t, v, false);
+		TestUtil.assertCommutativeEquals(u, v, false);
+
+		s = TestUtils.fieldFromString("int Foo.goo");
+		t = MemberImpl.field("Foo", 0, "goo", "I");
+		u = TestUtils.fieldFromString("int Foo.goo1");
+		v = TestUtils.fieldFromString("long Foo.goo");
+
+		TestUtil.assertCommutativeEquals(s, s, true);
+		TestUtil.assertCommutativeEquals(t, t, true);
+		TestUtil.assertCommutativeEquals(u, u, true);
+		TestUtil.assertCommutativeEquals(v, v, true);
+		TestUtil.assertCommutativeEquals(s, t, true);
+		TestUtil.assertCommutativeEquals(s, u, false);
+		TestUtil.assertCommutativeEquals(s, v, false);
+		TestUtil.assertCommutativeEquals(t, u, false);
+		TestUtil.assertCommutativeEquals(t, v, false);
+		TestUtil.assertCommutativeEquals(u, v, false);
+	}
+
+	public void testMethodContents() {
+		Member m = TestUtils.methodFromString("void Foo.goo(int)");
+		kindTest(m, Member.METHOD);
+		declaringTypeTest(m, "Foo");
+		nameTest(m, "goo");
+		parameterTypesTest(m, new UnresolvedType[] { UnresolvedType.INT });
+		returnTypeTest(m, UnresolvedType.VOID);
+		isInterfaceTest(m, false);
+		isPrivateTest(m, false);
+		isConstructorTest(m, false);
+		isStaticTest(m, false);
+
+		m = TestUtils.methodFromString("interface java.lang.Object java.util.Iterator.next()");
+		kindTest(m, Member.METHOD);
+		declaringTypeTest(m, "java.util.Iterator");
+		nameTest(m, "next");
+		parameterTypesTest(m, UnresolvedType.NONE);
+		returnTypeTest(m, UnresolvedType.OBJECT);
+		isInterfaceTest(m, true);
+		isPrivateTest(m, false);
+		isConstructorTest(m, false);
+		isStaticTest(m, false);
+
+		m = TestUtils.methodFromString("void Foo.<init>(int, java.lang.Object)");
+		kindTest(m, Member.CONSTRUCTOR);
+		declaringTypeTest(m, "Foo");
+		nameTest(m, "<init>");
+		parameterTypesTest(m, new UnresolvedType[] { UnresolvedType.INT, UnresolvedType.OBJECT });
+		returnTypeTest(m, UnresolvedType.VOID);
+		isInterfaceTest(m, false);
+		isPrivateTest(m, false);
+		isConstructorTest(m, true);
+		isStaticTest(m, false);
+
+		m = TestUtils.methodFromString("private double Foo.sqrt(double)");
+		kindTest(m, Member.METHOD);
+		declaringTypeTest(m, "Foo");
+		nameTest(m, "sqrt");
+		parameterTypesTest(m, new UnresolvedType[] { UnresolvedType.DOUBLE });
+		returnTypeTest(m, UnresolvedType.DOUBLE);
+		isInterfaceTest(m, false);
+		isPrivateTest(m, true);
+		isConstructorTest(m, false);
+		isStaticTest(m, false);
+
+		m = TestUtils.methodFromString("static int java.lang.Math.max(int, int)");
+		kindTest(m, Member.METHOD);
+		declaringTypeTest(m, "java.lang.Math");
+		nameTest(m, "max");
+		parameterTypesTest(m, new UnresolvedType[] { UnresolvedType.INT, UnresolvedType.INT });
+		returnTypeTest(m, UnresolvedType.INT);
+		isInterfaceTest(m, false);
+		isPrivateTest(m, false);
+		isConstructorTest(m, false);
+		isStaticTest(m, true);
+	}
+
+	public void testFieldContents() {
+		Member m = TestUtils.fieldFromString("int Foo.goo");
+		kindTest(m, Member.FIELD);
+		declaringTypeTest(m, "Foo");
+		nameTest(m, "goo");
+		parameterTypesTest(m, UnresolvedType.NONE);
+		returnTypeTest(m, UnresolvedType.INT);
+		isInterfaceTest(m, false);
+		isPrivateTest(m, false);
+		isConstructorTest(m, false);
+		isStaticTest(m, false);
+
+		m = TestUtils.fieldFromString("static java.util.Iterator goo.Bar.i");
+		kindTest(m, Member.FIELD);
+		declaringTypeTest(m, "goo.Bar");
+		nameTest(m, "i");
+		parameterTypesTest(m, UnresolvedType.NONE);
+		returnTypeTest(m, UnresolvedType.forName("java.util.Iterator"));
+		isInterfaceTest(m, false);
+		isPrivateTest(m, false);
+		isConstructorTest(m, false);
+		isStaticTest(m, true);
+	}
+
+	private void isStaticTest(Member m, boolean b) {
+		assertEquals(m + " is static", b, Modifier.isStatic(m.getModifiers()));
+	}
+
+	private void isConstructorTest(Member m, boolean b) {
+		assertEquals(m + " is constructor", b, m.getKind() == Member.CONSTRUCTOR);
+	}
+
+	private void isPrivateTest(Member m, boolean b) {
+		assertEquals(m + " is private", b, Modifier.isPrivate(m.getModifiers()));
+	}
+
+	private void isInterfaceTest(Member m, boolean b) {
+		assertEquals(m + " is interface", b, Modifier.isInterface(m.getModifiers()));
+	}
+
+	private void returnTypeTest(Member m, UnresolvedType returnType) {
+		assertEquals(m + " return type", returnType, m.getReturnType());
+	}
+
+	private void parameterTypesTest(Member m, UnresolvedType[] paramTypes) {
+		TestUtil.assertArrayEquals(m + " parameters", paramTypes, m.getParameterTypes());
+	}
+
+	private void nameTest(Member m, String name) {
+		assertEquals(m + " name", name, m.getName());
+	}
+
+	private void declaringTypeTest(Member m, String declaringName) {
+		assertEquals(m + " declared in", UnresolvedType.forName(declaringName), m.getDeclaringType());
+	}
+
+	private void kindTest(Member m, MemberKind kind) {
+		assertEquals(m + " kind", kind, m.getKind());
+	}
+
 }
@@ -10,7 +10,6 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.weaver;
 
 import org.aspectj.bridge.ISourceLocation;
@@ -21,34 +20,35 @@ public class TestShadow extends Shadow {
 	private final World world;
 	private final UnresolvedType thisType;
 
-    public TestShadow(Kind kind, Member signature, UnresolvedType thisType, World world) {
-        super(kind, signature, null);
-        this.world = world;
-        this.thisType = thisType;
-    }
+	public TestShadow(Kind kind, Member signature, UnresolvedType thisType, World world) {
+		super(kind, signature, null);
+		this.world = world;
+		this.thisType = thisType;
+	}
 
-    public World getIWorld() {
-        return world;
-    }
+	public World getIWorld() {
+		return world;
+	}
 
-	/** this is subtly wrong.  ha ha */
-    public UnresolvedType getEnclosingType() {
-        return thisType;
-    }
+	/** this is subtly wrong. ha ha */
+	public UnresolvedType getEnclosingType() {
+		return thisType;
+	}
 
-    public Var getThisVar() {
-    	// we should thorw if we don't have a this
-        return new Var(getThisType().resolve(world));
-    }
+	public Var getThisVar() {
+		// we should thorw if we don't have a this
+		return new Var(getThisType().resolve(world));
+	}
 
-    public Var getTargetVar() {
-    	if (! hasTarget()) throw new RuntimeException("bad");
-        return new Var(getTargetType().resolve(world));
-    }
+	public Var getTargetVar() {
+		if (!hasTarget())
+			throw new RuntimeException("bad");
+		return new Var(getTargetType().resolve(world));
+	}
 
-    public Var getArgVar(int i) {
-        return new Var(getArgType(i).resolve(world));
-    }
+	public Var getArgVar(int i) {
+		return new Var(getArgType(i).resolve(world));
+	}
 
 	public Var getThisEnclosingJoinPointStaticPartVar() {
 		throw new RuntimeException("unimplemented");
@@ -58,6 +58,10 @@ public class TestShadow extends Shadow {
 		throw new RuntimeException("unimplemented");
 	}
 
+	public Var getThisAspectInstanceVar(ResolvedType aspectType) {
+		throw new RuntimeException("unimplemented");
+	}
+
 	public Var getThisJoinPointVar() {
 		throw new RuntimeException("unimplemented");
 	}
@@ -70,45 +74,57 @@ public class TestShadow extends Shadow {
 		throw new RuntimeException("unimplemented");
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getKindedAnnotationVar()
 	 */
 	public Var getKindedAnnotationVar(UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getWithinAnnotationVar()
 	 */
 	public Var getWithinAnnotationVar(UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getWithinCodeAnnotationVar()
 	 */
 	public Var getWithinCodeAnnotationVar(UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getThisAnnotationVar()
 	 */
 	public Var getThisAnnotationVar(UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getTargetAnnotationVar()
 	 */
 	public Var getTargetAnnotationVar(UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getArgAnnotationVar(int)
 	 */
-	public Var getArgAnnotationVar(int i,UnresolvedType annotationType) {
+	public Var getArgAnnotationVar(int i, UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
 
@@ -23,6 +23,7 @@ import org.aspectj.weaver.BcweaverTests;
 import org.aspectj.weaver.Member;
 import org.aspectj.weaver.MemberImpl;
 import org.aspectj.weaver.Shadow;
+import org.aspectj.weaver.ShadowMunger;
 import org.aspectj.weaver.UnresolvedType;
 
 public class MegaZipTestCase extends WeaveTestCase {
@@ -58,8 +59,8 @@ public class MegaZipTestCase extends WeaveTestCase {
 		};
 	}
 
-	public List getShadowMungers() {
-		List ret = new ArrayList();
+	public List<ShadowMunger> getShadowMungers() {
+		List<ShadowMunger> ret = new ArrayList<ShadowMunger>();
 		ret.add(makeConcreteAdvice("before" + "(): call(* *.println(..)) -> static void fluffy.Aspect.before_method_call()"));
 		ret.add(makeConcreteAdvice("afterReturning"
 				+ "(): call(* *.println(..)) -> static void fluffy.Aspect.afterReturning_method_call()"));
@@ -145,8 +145,9 @@ public class PointcutResidueTestCase extends WeaveTestCase {
 				formalNames)));
 
 		ShadowMunger pp = new BcelAdvice(AdviceKind.Before, rp, MemberImpl.method(UnresolvedType.forName("Aspect"),
-				Modifier.STATIC, "ajc_before_0", MemberImpl.typesToSignature(ResolvedType.VOID, UnresolvedType
-						.forNames(formalTypes), false)), 0, -1, -1, null, null);
+				Modifier.STATIC, "ajc_before_0",
+				MemberImpl.typesToSignature(UnresolvedType.VOID, UnresolvedType.forNames(formalTypes), false)), 0, -1, -1, null,
+				null);
 
 		ResolvedType inAspect = world.resolve("Aspect");
 		CrosscuttingMembers xcut = new CrosscuttingMembers(inAspect, true);
@@ -18,6 +18,7 @@ import java.util.Arrays;
 import org.aspectj.weaver.Advice;
 import org.aspectj.weaver.AdviceKind;
 import org.aspectj.weaver.ResolvedType;
+import org.aspectj.weaver.ShadowMunger;
 import org.aspectj.weaver.TestUtils;
 import org.aspectj.weaver.UnresolvedType;
 
@@ -92,7 +93,7 @@ public class TjpWeaveTestCase extends WeaveTestCase {
 						.methodFromString("static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)"),
 				Advice.ThisJoinPoint | Advice.ExtraArgument, -1, -1, null, rtx);
 
-		weaveTest("HelloWorld", "TjpAround2HelloWorld", Arrays.asList(new BcelAdvice[] { munger1, munger2 }));
+		weaveTest("HelloWorld", "TjpAround2HelloWorld", Arrays.asList(new ShadowMunger[] { munger1, munger2 }));
 	}
 
 }
@@ -81,7 +81,7 @@ public abstract class WeaveTestCase extends TestCase {
 	}
 
 	public void weaveTest(String name, String outName, ShadowMunger planner) throws IOException {
-		List l = new ArrayList(1);
+		List<ShadowMunger> l = new ArrayList<ShadowMunger>(1);
 		l.add(planner);
 		weaveTest(name, outName, l);
 	}
@@ -89,7 +89,7 @@ public abstract class WeaveTestCase extends TestCase {
 	// static String classDir = "../weaver/bin";
 	static String classDir = BcweaverTests.TESTDATA_PATH + File.separator + "bin";
 
-	public void weaveTest(String name, String outName, List planners) throws IOException {
+	public void weaveTest(String name, String outName, List<ShadowMunger> planners) throws IOException {
 		BcelWeaver weaver = new BcelWeaver(world);
 		try {
 			if (behave15)
@@ -97,7 +97,7 @@ public abstract class WeaveTestCase extends TestCase {
 
 			UnwovenClassFile classFile = makeUnwovenClassFile(classDir, name, outDirPath);
 
-			weaver.addClassFile(classFile,false);
+			weaver.addClassFile(classFile, false);
 			weaver.setShadowMungers(planners);
 			weaveTestInner(weaver, classFile, name, outName);
 		} finally {
@@ -170,8 +170,8 @@ public abstract class WeaveTestCase extends TestCase {
 	}
 
 	void realCheckClass(LazyClassGen gen, String outDir, String expectedFile) throws IOException {
-		TestUtil.assertMultiLineStringEquals(expectedFile/* "classes" */, FileUtil
-				.readAsString(new File(TESTDATA_DIR, expectedFile)), gen.toLongString());
+		TestUtil.assertMultiLineStringEquals(expectedFile/* "classes" */,
+				FileUtil.readAsString(new File(TESTDATA_DIR, expectedFile)), gen.toLongString());
 	}
 
 	// ----
@@ -197,18 +197,14 @@ public abstract class WeaveTestCase extends TestCase {
 		return makeConcreteAdvice(kind + "(): get(* *.*) -> static void Aspect.ajc_" + kind + "_field_get(" + extraArgType + ")", 1);
 	}
 
-	public List makeAdviceAll(String kind, boolean matchOnlyPrintln) {
-		List ret = new ArrayList();
+	public List<ShadowMunger> makeAdviceAll(String kind, boolean matchOnlyPrintln) {
+		List<ShadowMunger> ret = new ArrayList<ShadowMunger>();
 		if (matchOnlyPrintln) {
-			ret
-					.add(makeConcreteAdvice(kind + "(): call(* *.println(..)) -> static void Aspect.ajc_" + kind
-							+ "_method_execution()"));
+			ret.add(makeConcreteAdvice(kind + "(): call(* *.println(..)) -> static void Aspect.ajc_" + kind + "_method_execution()"));
 		} else {
 			ret.add(makeConcreteAdvice(kind + "(): call(* *.*(..)) -> static void Aspect.ajc_" + kind + "_method_call()"));
 			ret.add(makeConcreteAdvice(kind + "(): call(*.new(..)) -> static void Aspect.ajc_" + kind + "_constructor_call()"));
-			ret
-					.add(makeConcreteAdvice(kind + "(): execution(* *.*(..)) -> static void Aspect.ajc_" + kind
-							+ "_method_execution()"));
+			ret.add(makeConcreteAdvice(kind + "(): execution(* *.*(..)) -> static void Aspect.ajc_" + kind + "_method_execution()"));
 			ret.add(makeConcreteAdvice(kind + "(): execution(*.new(..)) -> static void Aspect.ajc_" + kind
 					+ "_constructor_execution()"));
 			// ret.add(
@@ -226,7 +222,7 @@ public abstract class WeaveTestCase extends TestCase {
 		return ret;
 	}
 
-	public List makeAdviceAll(final String kind) {
+	public List<ShadowMunger> makeAdviceAll(final String kind) {
 		return makeAdviceAll(kind, false);
 	}
 
@@ -270,7 +266,7 @@ public abstract class WeaveTestCase extends TestCase {
 		}
 	}
 
-	protected void weaveTest(String[] inClassNames, String outKind, List patternMungers) throws IOException {
+	protected void weaveTest(String[] inClassNames, String outKind, List<ShadowMunger> patternMungers) throws IOException {
 		for (int i = 0; i < inClassNames.length; i++) {
 			String inFileName = inClassNames[i];
 			weaveTest(inFileName, outKind + inFileName, patternMungers);
@@ -18,135 +18,139 @@ import junit.framework.TestCase;
 
 import org.aspectj.bridge.AbortException;
 import org.aspectj.bridge.IMessage;
-import org.aspectj.bridge.IMessageHandler;
 import org.aspectj.bridge.IMessage.Kind;
+import org.aspectj.bridge.IMessageHandler;
 import org.aspectj.util.LangUtil;
 import org.aspectj.weaver.BcweaverTests;
 import org.aspectj.weaver.ResolvedMember;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.bcel.BcelWorld;
-import org.aspectj.weaver.patterns.TestScope;
 
 /*
  * Sample types that this program uses are:
- 
-import p.SimpleAnnotation;
 
-@SimpleAnnotation(id=2)
-public class AnnotatedClass {
+ import p.SimpleAnnotation;
 
-  @SimpleAnnotation(id=3)
-  public void m1() { }
+ @SimpleAnnotation(id=2)
+ public class AnnotatedClass {
 
-  @SimpleAnnotation(id=4)
-  int i;
-}
+ @SimpleAnnotation(id=3)
+ public void m1() { }
+
+ @SimpleAnnotation(id=4)
+ int i;
+ }
 
  * with SimpleAnnotation defined as:
 
-package p;
-import java.lang.annotation.*;
+ package p;
+ import java.lang.annotation.*;
 
-@Retention(RetentionPolicy.RUNTIME)
-public @interface SimpleAnnotation {
-  int id();
-  String fruit() default "bananas";
-}
+ @Retention(RetentionPolicy.RUNTIME)
+ public @interface SimpleAnnotation {
+ int id();
+ String fruit() default "bananas";
+ }
 
-*NOTE NOTE NOTE NOTE NOTE NOTE NOTE*
-If you need to rebuild the test data code, run 'ant -f build-15.xml' in the 
-testdata directory.
+ *NOTE NOTE NOTE NOTE NOTE NOTE NOTE*
+ If you need to rebuild the test data code, run 'ant -f build-15.xml' in the 
+ testdata directory.
 
  */
 public class AnnotationPatternMatchingTestCase extends TestCase {
-	
+
 	private BcelWorld world;
-	private AnnotationTypePattern fooTP,simpleAnnotationTP;
-	
+	private AnnotationTypePattern fooTP, simpleAnnotationTP;
+
 	private ResolvedType loadType(String name) {
 		if (world == null) {
-		  world = new BcelWorld(BcweaverTests.TESTDATA_PATH + "/testcode.jar");
-		  world.setBehaveInJava5Way(true);
+			world = new BcelWorld(BcweaverTests.TESTDATA_PATH + "/testcode.jar");
+			world.setBehaveInJava5Way(true);
 		}
 		return world.resolve(name);
 	}
-	
+
 	private void initAnnotationTypePatterns() {
 		PatternParser p = new PatternParser("@Foo");
 		fooTP = p.maybeParseAnnotationPattern();
-		fooTP = fooTP.resolveBindings(makeSimpleScope(),new Bindings(3),true);
-		
+		fooTP = fooTP.resolveBindings(makeSimpleScope(), new Bindings(3), true);
+
 		p = new PatternParser("@p.SimpleAnnotation");
 		simpleAnnotationTP = p.maybeParseAnnotationPattern();
-		simpleAnnotationTP = simpleAnnotationTP.resolveBindings(makeSimpleScope(),new Bindings(3),true);
+		simpleAnnotationTP = simpleAnnotationTP.resolveBindings(makeSimpleScope(), new Bindings(3), true);
 	}
-	
-	
+
 	public void testAnnotationPatternMatchingOnTypes() {
 		if (LangUtil.is15VMOrGreater()) {
-		ResolvedType rtx = loadType("AnnotatedClass");
-        initAnnotationTypePatterns();		
-		
-		// One should match
-		assertTrue("@Foo should not match on the AnnotatedClass",
-				   fooTP.matches(rtx).alwaysFalse());
-		assertTrue("@SimpleAnnotation should match on the AnnotatedClass",
-				   simpleAnnotationTP.matches(rtx).alwaysTrue());
+			ResolvedType rtx = loadType("AnnotatedClass");
+			initAnnotationTypePatterns();
+
+			// One should match
+			assertTrue("@Foo should not match on the AnnotatedClass", fooTP.matches(rtx).alwaysFalse());
+			assertTrue("@SimpleAnnotation should match on the AnnotatedClass", simpleAnnotationTP.matches(rtx).alwaysTrue());
 		}
 
 	}
-	
+
 	static class MyMessageHandler implements IMessageHandler {
-		public List messages = new ArrayList();
+		public List<IMessage> messages = new ArrayList<IMessage>();
+
 		public boolean handleMessage(IMessage message) throws AbortException {
 			messages.add(message);
 			return false;
 		}
-		public boolean isIgnoring(Kind kind) {return false;}
-        public void dontIgnore(IMessage.Kind kind) {}
-		public void ignore(Kind kind) {}
+
+		public boolean isIgnoring(Kind kind) {
+			return false;
+		}
+
+		public void dontIgnore(IMessage.Kind kind) {
+		}
+
+		public void ignore(Kind kind) {
+		}
 	}
-	
+
 	public void testReferenceToNonAnnotationType() {
-//		ResolvedType rtx = 
-			loadType("AnnotatedClass"); // inits the world
+		// ResolvedType rtx =
+		loadType("AnnotatedClass"); // inits the world
 		PatternParser p = new PatternParser("@java.lang.String");
-		
+
 		MyMessageHandler mh = new MyMessageHandler();
 		world.setMessageHandler(mh);
 		AnnotationTypePattern atp = p.maybeParseAnnotationPattern();
-		atp = atp.resolveBindings(makeSimpleScope(),new Bindings(3),true);
-		
-		assertTrue("Expected 1 error message but got "+mh.messages.size(),mh.messages.size()==1);
-		
+		atp = atp.resolveBindings(makeSimpleScope(), new Bindings(3), true);
+
+		assertTrue("Expected 1 error message but got " + mh.messages.size(), mh.messages.size() == 1);
+
 		String expected = "Type referred to is not an annotation type";
-		String msg = ((IMessage)mh.messages.get(0)).toString();
-		assertTrue("Expected: "+expected+" but got "+msg,msg.indexOf(expected)!=-1);
+		String msg = ((IMessage) mh.messages.get(0)).toString();
+		assertTrue("Expected: " + expected + " but got " + msg, msg.indexOf(expected) != -1);
 	}
-	
+
 	public void testReferenceViaFormalToNonAnnotationType() {
-//		ResolvedType rtx = 
-			loadType("AnnotatedClass"); // inits the world
+		// ResolvedType rtx =
+		loadType("AnnotatedClass"); // inits the world
 		PatternParser p = new PatternParser("a");
-		
+
 		MyMessageHandler mh = new MyMessageHandler();
 		world.setMessageHandler(mh);
 		AnnotationTypePattern atp = p.parseAnnotationNameOrVarTypePattern();
-		atp = atp.resolveBindings(makeSimpleScope(),new Bindings(3),true);
-		
-		assertTrue("Expected 2 error messages but got "+mh.messages.size(),mh.messages.size()==1);
-		
+		atp = atp.resolveBindings(makeSimpleScope(), new Bindings(3), true);
+
+		assertTrue("Expected 3 error messages but got " + mh.messages.size(), mh.messages.size() == 3);
+
 		String expected = "Type referred to is not an annotation type";
-		String msg = ((IMessage)mh.messages.get(0)).toString();
-		assertTrue("Expected: "+expected+" but got "+msg,msg.indexOf(expected)!=-1);
-		
-//		expected = "Binding not supported in @pcds (1.5.0 M1 limitation): null";
-//		msg = ((IMessage)mh.messages.get(1)).toString();
-//		assertTrue("Expected: "+expected+" but got "+msg,msg.indexOf(expected)!=-1);
+		String msg = ((IMessage) mh.messages.get(0)).toString();
+		assertTrue("Expected: " + expected + " but got " + msg, msg.indexOf(expected) != -1);
+
+		// expected = "Binding not supported in @pcds (1.5.0 M1 limitation): null";
+		// msg = ((IMessage)mh.messages.get(1)).toString();
+		// assertTrue("Expected: "+expected+" but got "+msg,msg.indexOf(expected)!=-1);
 	}
-	
+
 	public TestScope makeSimpleScope() {
-		return new TestScope(new String[] {"int", "java.lang.String"}, new String[] {"a", "b"}, world);
+		return new TestScope(new String[] { "int", "java.lang.String" }, new String[] { "a", "b" }, world);
 	}
 
 	public void testUnresolvedAnnotationTypes() {
@@ -161,98 +165,88 @@ public class AnnotationPatternMatchingTestCase extends TestCase {
 			// Correct!
 		}
 	}
-	
+
 	public void testAnnotationPatternMatchingOnMethods() {
 		if (LangUtil.is15VMOrGreater()) {
-		ResolvedType rtx = loadType("AnnotatedClass");
-		ResolvedMember aMethod = rtx.getDeclaredMethods()[1];
-        
-		assertTrue("Haven't got the right method, I'm looking for 'm1()': "+aMethod.getName(),
-				aMethod.getName().equals("m1"));
-		
-		initAnnotationTypePatterns();
-		
-		// One should match
-		assertTrue("@Foo should not match on the AnnotatedClass.m1() method",
-				   fooTP.matches(aMethod).alwaysFalse());
-		assertTrue("@SimpleAnnotation should match on the AnnotatedClass.m1() method",
-				   simpleAnnotationTP.matches(aMethod).alwaysTrue());
+			ResolvedType rtx = loadType("AnnotatedClass");
+			ResolvedMember aMethod = rtx.getDeclaredMethods()[1];
+
+			assertTrue("Haven't got the right method, I'm looking for 'm1()': " + aMethod.getName(), aMethod.getName().equals("m1"));
+
+			initAnnotationTypePatterns();
+
+			// One should match
+			assertTrue("@Foo should not match on the AnnotatedClass.m1() method", fooTP.matches(aMethod).alwaysFalse());
+			assertTrue("@SimpleAnnotation should match on the AnnotatedClass.m1() method", simpleAnnotationTP.matches(aMethod)
+					.alwaysTrue());
 		}
 	}
-	
+
 	public void testAnnotationPatternMatchingOnFields() {
 		if (LangUtil.is15VMOrGreater()) {
-		ResolvedType rtx = loadType("AnnotatedClass");
-		ResolvedMember aField = rtx.getDeclaredFields()[0];
+			ResolvedType rtx = loadType("AnnotatedClass");
+			ResolvedMember aField = rtx.getDeclaredFields()[0];
 
-				assertTrue("Haven't got the right field, I'm looking for 'i'"+aField.getName(),
-				aField.getName().equals("i"));
+			assertTrue("Haven't got the right field, I'm looking for 'i'" + aField.getName(), aField.getName().equals("i"));
 
-		initAnnotationTypePatterns();
-		
-		// One should match
-		assertTrue("@Foo should not match on the AnnotatedClass.i field",
-				   fooTP.matches(aField).alwaysFalse());
-		assertTrue("@SimpleAnnotation should match on the AnnotatedClass.i field",
-				   simpleAnnotationTP.matches(aField).alwaysTrue());
+			initAnnotationTypePatterns();
+
+			// One should match
+			assertTrue("@Foo should not match on the AnnotatedClass.i field", fooTP.matches(aField).alwaysFalse());
+			assertTrue("@SimpleAnnotation should match on the AnnotatedClass.i field", simpleAnnotationTP.matches(aField)
+					.alwaysTrue());
 		}
 
 	}
-	
+
 	public void testAnnotationTypeResolutionOnTypes() {
 		ResolvedType rtx = loadType("AnnotatedClass");
 		ResolvedType[] types = rtx.getAnnotationTypes();
-		assertTrue("Did not expect null",types!=null);
-		assertTrue("Expected 1 entry but got "+types.length,types.length==1);
-		assertTrue("Should be 'p.SimpleAnnotation' but is "+types[0],
-				types[0].equals(world.resolve("p.SimpleAnnotation")));
+		assertTrue("Did not expect null", types != null);
+		assertTrue("Expected 1 entry but got " + types.length, types.length == 1);
+		assertTrue("Should be 'p.SimpleAnnotation' but is " + types[0], types[0].equals(world.resolve("p.SimpleAnnotation")));
 	}
-	
+
 	public void testAnnotationTypeResolutionOnMethods() {
 		ResolvedType rtx = loadType("AnnotatedClass");
 
 		ResolvedMember aMethod = rtx.getDeclaredMethods()[1];
-		assertTrue("Haven't got the right method, I'm looking for 'm1()': "+aMethod.getName(),
-				aMethod.getName().equals("m1"));
-		
+		assertTrue("Haven't got the right method, I'm looking for 'm1()': " + aMethod.getName(), aMethod.getName().equals("m1"));
+
 		ResolvedType[] types = aMethod.getAnnotationTypes();
-		assertTrue("Did not expect null",types!=null);
-		assertTrue("Expected 1 entry but got "+types.length,types.length==1);
-		assertTrue("Should be 'p.SimpleAnnotation' but is "+types[0],
-				types[0].equals(world.resolve("p.SimpleAnnotation")));
+		assertTrue("Did not expect null", types != null);
+		assertTrue("Expected 1 entry but got " + types.length, types.length == 1);
+		assertTrue("Should be 'p.SimpleAnnotation' but is " + types[0], types[0].equals(world.resolve("p.SimpleAnnotation")));
 	}
-	
+
 	public void testAnnotationTypeResolutionOnFields() {
 		ResolvedType rtx = loadType("AnnotatedClass");
 
 		ResolvedMember aField = rtx.getDeclaredFields()[0];
 
-		assertTrue("Haven't got the right field, I'm looking for 'i'"+aField.getName(),
-				   aField.getName().equals("i"));
-				
+		assertTrue("Haven't got the right field, I'm looking for 'i'" + aField.getName(), aField.getName().equals("i"));
+
 		ResolvedType[] types = aField.getAnnotationTypes();
-		assertTrue("Did not expect null",types!=null);
-		assertTrue("Expected 1 entry but got "+types.length,types.length==1);
-		assertTrue("Should be 'p.SimpleAnnotation' but is "+types[0],
-				types[0].equals(world.resolve("p.SimpleAnnotation")));
+		assertTrue("Did not expect null", types != null);
+		assertTrue("Expected 1 entry but got " + types.length, types.length == 1);
+		assertTrue("Should be 'p.SimpleAnnotation' but is " + types[0], types[0].equals(world.resolve("p.SimpleAnnotation")));
 	}
-	
+
 	public void testWildPatternMatchingOnTypes() {
-		
+
 		ResolvedType rtx = loadType("AnnotatedClass");
-        initAnnotationTypePatterns();		
-        
-        // Let's create something wild
+		initAnnotationTypePatterns();
+
+		// Let's create something wild
 		PatternParser p = new PatternParser("@(Foo || Boo)");
 		AnnotationTypePattern ap = p.maybeParseAnnotationPattern();
-		ap = ap.resolveBindings(makeSimpleScope(),new Bindings(3),true);
-		assertTrue("shouldnt match the type AnnotatedClass",ap.matches(rtx).alwaysFalse());
-		
-		
+		ap = ap.resolveBindings(makeSimpleScope(), new Bindings(3), true);
+		assertTrue("shouldnt match the type AnnotatedClass", ap.matches(rtx).alwaysFalse());
+
 		p = new PatternParser("@(p.SimpleAnnotation || Boo)");
 		ap = p.maybeParseAnnotationPattern();
-		ap = ap.resolveBindings(makeSimpleScope(),new Bindings(3),true);
-		assertTrue("should match the type AnnotatedClass",ap.matches(rtx).alwaysTrue());
+		ap = ap.resolveBindings(makeSimpleScope(), new Bindings(3), true);
+		assertTrue("should match the type AnnotatedClass", ap.matches(rtx).alwaysTrue());
 	}
 
 }
@@ -10,7 +10,6 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.weaver.patterns;
 
 import org.aspectj.weaver.UnresolvedType;
@@ -20,140 +19,98 @@ public class ConcretizationTestCase extends WeaveTestCase {
 	{
 		regenerate = false;
 	}
+
 	public ConcretizationTestCase(String name) {
 		super(name);
 	}
-    public void testNothingForAntJUnit() {}
-		
-   // String[] none = new String[0];
-	
-	
-	
-	/* XXX temporarily skipping
-	public void testCflowResidual() throws IOException {
-		
-		BcelAdvice a = (BcelAdvice) makeConcreteTestAdviceEntryPart();
-		
-		TestShadow shadow = new TestShadow(Shadow.MethodCall, 
-			Member.methodFromString("int Aspect.i(int x)"), 
-			UnresolvedType.OBJECT, 
-			world);
-		
-		ExposedState state = new ExposedState(1);
-		
-		a.specializeOn(shadow);
-
-		//System.err.println(shadow);
-		//System.err.println(a);
 
-		//System.err.println(a.exposedState);
-		
-		
+	public void testNothingForAntJUnit() {
 	}
 
-	
-	
-	public Advice makeConcreteTestAdviceEntryPart() throws IOException {
-		// XXX copied from below, refactor later
-
-
-		// returns the advice for the entry part of cflow(foo(a))
-		Pointcut in =
-			createResolvedPointcut(
-				"cflow(foo(a)) && (args(b) && !cflow(foo(int)))",
-				new String[] { "b", "a" },
-				new String[] { "float", "int" });
-
-		ResolvedPointcutDefinition ref =
-			new ResolvedPointcutDefinition(
-				UnresolvedType.forName("Aspect"),
-				0,
-				"foo",
-				new UnresolvedType[] { ResolvedType.INT },
-				createResolvedPointcut(
-					"args(refA)",
-					new String[] { "refA" },
-					new String[] { "int" }));
-		BcelObjectType target = (BcelObjectType) world.resolve("Aspect");
-
-		// now munge this to get the pointcut in it
-
-		target.addPointcutDefinition(ref);
-		CrosscuttingMembers xcut = new CrosscuttingMembers(target);
-		target.crosscuttingMembers = xcut;
-
-		Advice adviceMember =
-			new BcelAdvice(
-				AdviceKind.Before,
-				in,
-				Member.method(UnresolvedType.forName("FOO"), 0, "garadf", "(FI)V"),
-				0,
-				0, 0, null, 
-				null);
-		// The pointcut to concretize
-
-		// this returns the actual advice, but we don't care about it now.
-		in.concretize(target, 2, adviceMember);
-		
-		List c = (List)xcut.getCflowEntries(); //target.getExtraConcreteShadowMungers();
-		
-		return (Advice) c.get(0);
-	}
-	
-	public void XtestCflow() throws IOException {
-		Pointcut in = createResolvedPointcut("cflow(foo(a)) && (args(b) && !cflow(foo(int)))", 
-				new String[] {"b", "a"}, new String[] {"float", "int"} ); 
-
-		ResolvedPointcutDefinition ref = 
-			new ResolvedPointcutDefinition(UnresolvedType.forName("Aspect"), 
-				0, "foo", new UnresolvedType[] { ResolvedType.INT }, 
-				createResolvedPointcut("args(refA)",
-					new String[] {"refA"}, new String[] {"int"}));
-
-		List expectedSlots = new ArrayList();		
-		expectedSlots.add(new ConcreteCflowPointcut.Slot(1, ResolvedType.INT, 0));
-
-		checkConcr(in, ref, expectedSlots);
-	}
-	
-	public void checkConcr(
-		Pointcut in, 
-		ResolvedPointcutDefinition referredTo, 
-		List expectedSlots) throws IOException {
-		
-		BcelObjectType target = (BcelObjectType)world.resolve("Aspect");
-		
-		// now munge this to get the pointcut in it
-		
-		target.addPointcutDefinition(referredTo);
-		
-		
-		Advice adviceMember = new BcelAdvice(AdviceKind.Before, in, 
-			Member.method(UnresolvedType.forName("FOO"), 0, "garadf", "(FI)V"), 0, 0, 0, null, null);
-		
-		// The pointcut to concretize
-		AndPointcut ap = (AndPointcut)in.concretize(target, 2, adviceMember);
-		
-		
-		ConcreteCflowPointcut conc = (ConcreteCflowPointcut)ap.left;
-		
-		List slots = conc.slots;
-		TestUtil.assertSetEquals(expectedSlots, slots);
-
-	}
-	*/
-		
-		
-	public Pointcut createResolvedPointcut(
-		String pointcutSource, String[] formalNames, String[] formalTypes) {
-        final Pointcut sp = Pointcut.fromString(pointcutSource);
-        final Pointcut rp =
-            sp.resolve(
-            	new SimpleScope(
-            	world,
-                SimpleScope.makeFormalBindings(UnresolvedType.forNames(formalTypes),
-                formalNames)
-                ));
+	// String[] none = new String[0];
+
+	/*
+	 * XXX temporarily skipping public void testCflowResidual() throws IOException {
+	 * 
+	 * BcelAdvice a = (BcelAdvice) makeConcreteTestAdviceEntryPart();
+	 * 
+	 * TestShadow shadow = new TestShadow(Shadow.MethodCall, Member.methodFromString("int Aspect.i(int x)"), UnresolvedType.OBJECT,
+	 * world);
+	 * 
+	 * ExposedState state = new ExposedState(1);
+	 * 
+	 * a.specializeOn(shadow);
+	 * 
+	 * //System.err.println(shadow); //System.err.println(a);
+	 * 
+	 * //System.err.println(a.exposedState);
+	 * 
+	 * 
+	 * }
+	 * 
+	 * 
+	 * 
+	 * public Advice makeConcreteTestAdviceEntryPart() throws IOException { // XXX copied from below, refactor later
+	 * 
+	 * 
+	 * // returns the advice for the entry part of cflow(foo(a)) Pointcut in = createResolvedPointcut(
+	 * "cflow(foo(a)) && (args(b) && !cflow(foo(int)))", new String[] { "b", "a" }, new String[] { "float", "int" });
+	 * 
+	 * ResolvedPointcutDefinition ref = new ResolvedPointcutDefinition( UnresolvedType.forName("Aspect"), 0, "foo", new
+	 * UnresolvedType[] { UnresolvedType.INT }, createResolvedPointcut( "args(refA)", new String[] { "refA" }, new String[] { "int"
+	 * })); BcelObjectType target = (BcelObjectType) world.resolve("Aspect");
+	 * 
+	 * // now munge this to get the pointcut in it
+	 * 
+	 * target.addPointcutDefinition(ref); CrosscuttingMembers xcut = new CrosscuttingMembers(target); target.crosscuttingMembers =
+	 * xcut;
+	 * 
+	 * Advice adviceMember = new BcelAdvice( AdviceKind.Before, in, Member.method(UnresolvedType.forName("FOO"), 0, "garadf",
+	 * "(FI)V"), 0, 0, 0, null, null); // The pointcut to concretize
+	 * 
+	 * // this returns the actual advice, but we don't care about it now. in.concretize(target, 2, adviceMember);
+	 * 
+	 * List c = (List)xcut.getCflowEntries(); //target.getExtraConcreteShadowMungers();
+	 * 
+	 * return (Advice) c.get(0); }
+	 * 
+	 * public void XtestCflow() throws IOException { Pointcut in =
+	 * createResolvedPointcut("cflow(foo(a)) && (args(b) && !cflow(foo(int)))", new String[] {"b", "a"}, new String[] {"float",
+	 * "int"} );
+	 * 
+	 * ResolvedPointcutDefinition ref = new ResolvedPointcutDefinition(UnresolvedType.forName("Aspect"), 0, "foo", new
+	 * UnresolvedType[] { UnresolvedType.INT }, createResolvedPointcut("args(refA)", new String[] {"refA"}, new String[] {"int"}));
+	 * 
+	 * List expectedSlots = new ArrayList(); expectedSlots.add(new ConcreteCflowPointcut.Slot(1, UnresolvedType.INT, 0));
+	 * 
+	 * checkConcr(in, ref, expectedSlots); }
+	 * 
+	 * public void checkConcr( Pointcut in, ResolvedPointcutDefinition referredTo, List expectedSlots) throws IOException {
+	 * 
+	 * BcelObjectType target = (BcelObjectType)world.resolve("Aspect");
+	 * 
+	 * // now munge this to get the pointcut in it
+	 * 
+	 * target.addPointcutDefinition(referredTo);
+	 * 
+	 * 
+	 * Advice adviceMember = new BcelAdvice(AdviceKind.Before, in, Member.method(UnresolvedType.forName("FOO"), 0, "garadf",
+	 * "(FI)V"), 0, 0, 0, null, null);
+	 * 
+	 * // The pointcut to concretize AndPointcut ap = (AndPointcut)in.concretize(target, 2, adviceMember);
+	 * 
+	 * 
+	 * ConcreteCflowPointcut conc = (ConcreteCflowPointcut)ap.left;
+	 * 
+	 * List slots = conc.slots; TestUtil.assertSetEquals(expectedSlots, slots);
+	 * 
+	 * }
+	 */
+
+	public Pointcut createResolvedPointcut(String pointcutSource, String[] formalNames, String[] formalTypes) {
+		final Pointcut sp = Pointcut.fromString(pointcutSource);
+		final Pointcut rp = sp.resolve(new SimpleScope(world, SimpleScope.makeFormalBindings(UnresolvedType.forNames(formalTypes),
+				formalNames)));
 		return rp;
 	}
 }
@@ -11,7 +11,6 @@
  * ******************************************************************/
 package org.aspectj.weaver.reflect;
 
-
 import java.lang.reflect.Method;
 import java.util.HashSet;
 import java.util.Set;
@@ -30,193 +29,193 @@ public class ReflectionBasedReferenceTypeDelegateTest extends TestCase {
 	protected ReflectionWorld world;
 	private ResolvedType objectType;
 	private ResolvedType classType;
-	
+
 	public void testIsAspect() {
 		assertFalse(objectType.isAspect());
 	}
-	
+
 	public void testIsAnnotationStyleAspect() {
 		assertFalse(objectType.isAnnotationStyleAspect());
 	}
-	
+
 	public void testIsInterface() {
 		assertFalse(objectType.isInterface());
 		assertTrue(world.resolve("java.io.Serializable").isInterface());
 	}
-	
+
 	public void testIsEnum() {
 		assertFalse(objectType.isEnum());
 	}
-	
+
 	public void testIsAnnotation() {
 		assertFalse(objectType.isAnnotation());
 	}
-	
+
 	public void testIsAnnotationWithRuntimeRetention() {
 		assertFalse(objectType.isAnnotationWithRuntimeRetention());
 	}
-	
+
 	public void testIsClass() {
 		assertTrue(objectType.isClass());
 		assertFalse(world.resolve("java.io.Serializable").isClass());
 	}
-	
+
 	public void testIsGeneric() {
 		assertFalse(objectType.isGenericType());
 	}
-	
+
 	public void testIsExposedToWeaver() {
 		assertFalse(objectType.isExposedToWeaver());
 	}
-	
+
 	public void testHasAnnotation() {
 		assertFalse(objectType.hasAnnotation(UnresolvedType.forName("Foo")));
 	}
-	
+
 	public void testGetAnnotations() {
-		assertEquals("no entries",0,objectType.getAnnotations().length);
+		assertEquals("no entries", 0, objectType.getAnnotations().length);
 	}
-	
+
 	public void testGetAnnotationTypes() {
-		assertEquals("no entries",0,objectType.getAnnotationTypes().length);
+		assertEquals("no entries", 0, objectType.getAnnotationTypes().length);
 	}
-	
+
 	public void testGetTypeVariables() {
-		assertEquals("no entries",0,objectType.getTypeVariables().length);
+		assertEquals("no entries", 0, objectType.getTypeVariables().length);
 	}
-	
+
 	public void testGetPerClause() {
 		assertNull(objectType.getPerClause());
 	}
-	
+
 	public void testGetModifiers() {
-		assertEquals(Object.class.getModifiers(),objectType.getModifiers());
+		assertEquals(Object.class.getModifiers(), objectType.getModifiers());
 	}
-	
+
 	public void testGetSuperclass() {
-		assertTrue("Superclass of object should be null, but it is: "+objectType.getSuperclass(),objectType.getSuperclass()==null);
-		assertEquals(objectType,world.resolve("java.lang.Class").getSuperclass());
+		assertTrue("Superclass of object should be null, but it is: " + objectType.getSuperclass(),
+				objectType.getSuperclass() == null);
+		assertEquals(objectType, world.resolve("java.lang.Class").getSuperclass());
 		ResolvedType d = world.resolve("reflect.tests.D");
-		assertEquals(world.resolve("reflect.tests.C"),d.getSuperclass());
+		assertEquals(world.resolve("reflect.tests.C"), d.getSuperclass());
+	}
+
+	public void testArrayArgsSig() throws Exception {
+		Method invokeMethod = Method.class.getMethod("invoke", new Class[] { Object.class, Object[].class });
+		ResolvedMember reflectionMethod = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(invokeMethod, world);
+		String exp = "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;";
+		assertTrue("Expected: \n" + exp + "\n but got:\n" + reflectionMethod.getSignature(), reflectionMethod.getSignature()
+				.equals(exp));
 	}
-	
-    public void testArrayArgsSig() throws Exception {
-    	Method invokeMethod = Method.class.getMethod("invoke", new Class[] { Object.class, Object[].class});
-    	ResolvedMember reflectionMethod = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(invokeMethod, world);
-    	String exp = "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;";
-    	assertTrue("Expected: \n"+exp+"\n but got:\n"+reflectionMethod.getSignature(), reflectionMethod.getSignature().equals(exp));
-    }
 
 	protected int findMethod(String name, ResolvedMember[] methods) {
-		for (int i=0; i<methods.length; i++) {
+		for (int i = 0; i < methods.length; i++) {
 			if (name.equals(methods[i].getName())) {
 				return i;
 			}
 		}
 		return -1;
 	}
-	
+
 	protected int findMethod(String name, int numArgs, ResolvedMember[] methods) {
-		for (int i=0; i<methods.length; i++) {
+		for (int i = 0; i < methods.length; i++) {
 			if (name.equals(methods[i].getName()) && (methods[i].getParameterTypes().length == numArgs)) {
 				return i;
 			}
 		}
 		return -1;
 	}
-	
+
 	public void testGetDeclaredMethods() {
 		ResolvedMember[] methods = objectType.getDeclaredMethods();
 		assertEquals(Object.class.getDeclaredMethods().length + Object.class.getDeclaredConstructors().length, methods.length);
-		
+
 		ResolvedType c = world.resolve("reflect.tests.C");
 		methods = c.getDeclaredMethods();
-		assertEquals(3,methods.length);
+		assertEquals(3, methods.length);
 		int idx = findMethod("foo", methods);
 		assertTrue(idx > -1);
-		
-		assertEquals(world.resolve("java.lang.String"),methods[idx].getReturnType());
+
+		assertEquals(world.resolve("java.lang.String"), methods[idx].getReturnType());
 		assertEquals(1, methods[idx].getParameterTypes().length);
-		assertEquals(objectType,methods[idx].getParameterTypes()[0]);
-		assertEquals(1,methods[idx].getExceptions().length);
-		assertEquals(world.resolve("java.lang.Exception"),methods[idx].getExceptions()[0]);
+		assertEquals(objectType, methods[idx].getParameterTypes()[0]);
+		assertEquals(1, methods[idx].getExceptions().length);
+		assertEquals(world.resolve("java.lang.Exception"), methods[idx].getExceptions()[0]);
 		int baridx = findMethod("bar", methods);
 		int initidx = findMethod("<init>", methods);
 		assertTrue(baridx > -1);
 		assertTrue(initidx > -1);
 		assertTrue(baridx != initidx && baridx != idx && idx <= 2 && initidx <= 2 && baridx <= 2);
-		
+
 		ResolvedType d = world.resolve("reflect.tests.D");
 		methods = d.getDeclaredMethods();
-		assertEquals(2,methods.length);
+		assertEquals(2, methods.length);
 
 		classType = world.resolve("java.lang.Class");
 		methods = classType.getDeclaredMethods();
-		assertEquals(Class.class.getDeclaredMethods().length + Class.class.getDeclaredConstructors().length, methods.length); 
+		assertEquals(Class.class.getDeclaredMethods().length + Class.class.getDeclaredConstructors().length, methods.length);
 	}
-	
+
 	public void testGetDeclaredFields() {
 		ResolvedMember[] fields = objectType.getDeclaredFields();
-		assertEquals(0,fields.length);
+		assertEquals(0, fields.length);
 
 		ResolvedType c = world.resolve("reflect.tests.C");
 		fields = c.getDeclaredFields();
-		
-		assertEquals(2,fields.length);
-		assertEquals("f",fields[0].getName());
-		assertEquals("s",fields[1].getName());
-		assertEquals(ResolvedType.INT,fields[0].getReturnType());
-		assertEquals(world.resolve("java.lang.String"),fields[1].getReturnType());
+
+		assertEquals(2, fields.length);
+		assertEquals("f", fields[0].getName());
+		assertEquals("s", fields[1].getName());
+		assertEquals(UnresolvedType.INT, fields[0].getReturnType());
+		assertEquals(world.resolve("java.lang.String"), fields[1].getReturnType());
 	}
-	
+
 	public void testGetDeclaredInterfaces() {
 		ResolvedType[] interfaces = objectType.getDeclaredInterfaces();
-		assertEquals(0,interfaces.length);
+		assertEquals(0, interfaces.length);
 
 		ResolvedType d = world.resolve("reflect.tests.D");
 		interfaces = d.getDeclaredInterfaces();
-		assertEquals(1,interfaces.length);
-		assertEquals(world.resolve("java.io.Serializable"),interfaces[0]);
-    }
-	
+		assertEquals(1, interfaces.length);
+		assertEquals(world.resolve("java.io.Serializable"), interfaces[0]);
+	}
+
 	public void testGetDeclaredPointcuts() {
 		ResolvedMember[] pointcuts = objectType.getDeclaredPointcuts();
-		assertEquals(0,pointcuts.length);
+		assertEquals(0, pointcuts.length);
 	}
-	
-	
-	
+
 	public void testSerializableSuperclass() {
 		ResolvedType serializableType = world.resolve("java.io.Serializable");
 		ResolvedType superType = serializableType.getSuperclass();
-        assertTrue("Superclass of serializable should be Object but was "+superType,superType.equals(UnresolvedType.OBJECT));    
+		assertTrue("Superclass of serializable should be Object but was " + superType, superType.equals(UnresolvedType.OBJECT));
 
-        BcelWorld bcelworld = new BcelWorld();
-        bcelworld.setBehaveInJava5Way(true);
-        ResolvedType bcelSupertype = bcelworld.resolve(UnresolvedType.SERIALIZABLE).getSuperclass();
-        assertTrue("Should be null but is "+bcelSupertype,bcelSupertype.equals(UnresolvedType.OBJECT));
+		BcelWorld bcelworld = new BcelWorld();
+		bcelworld.setBehaveInJava5Way(true);
+		ResolvedType bcelSupertype = bcelworld.resolve(UnresolvedType.SERIALIZABLE).getSuperclass();
+		assertTrue("Should be null but is " + bcelSupertype, bcelSupertype.equals(UnresolvedType.OBJECT));
 	}
-	
-	public void testSubinterfaceSuperclass() {		
+
+	public void testSubinterfaceSuperclass() {
 		ResolvedType ifaceType = world.resolve("java.security.Key");
 		ResolvedType superType = ifaceType.getSuperclass();
-		assertTrue("Superclass should be Object but was "+superType,superType.equals(UnresolvedType.OBJECT));  
+		assertTrue("Superclass should be Object but was " + superType, superType.equals(UnresolvedType.OBJECT));
 
-        BcelWorld bcelworld = new BcelWorld();
-        bcelworld.setBehaveInJava5Way(true);
-        ResolvedType bcelSupertype = bcelworld.resolve("java.security.Key").getSuperclass();
-        assertTrue("Should be null but is "+bcelSupertype,bcelSupertype.equals(UnresolvedType.OBJECT));
+		BcelWorld bcelworld = new BcelWorld();
+		bcelworld.setBehaveInJava5Way(true);
+		ResolvedType bcelSupertype = bcelworld.resolve("java.security.Key").getSuperclass();
+		assertTrue("Should be null but is " + bcelSupertype, bcelSupertype.equals(UnresolvedType.OBJECT));
 	}
-	
+
 	public void testVoidSuperclass() {
 		ResolvedType voidType = world.resolve(Void.TYPE);
 		ResolvedType superType = voidType.getSuperclass();
 		assertNull(superType);
-		   
-        BcelWorld bcelworld = new BcelWorld();
-        bcelworld.setBehaveInJava5Way(true);
-        ResolvedType bcelSupertype = bcelworld.resolve("void").getSuperclass();
-        assertTrue("Should be null but is "+bcelSupertype,bcelSupertype==null);
+
+		BcelWorld bcelworld = new BcelWorld();
+		bcelworld.setBehaveInJava5Way(true);
+		ResolvedType bcelSupertype = bcelworld.resolve("void").getSuperclass();
+		assertTrue("Should be null but is " + bcelSupertype, bcelSupertype == null);
 	}
 
 	public void testIntSuperclass() {
@@ -224,87 +223,91 @@ public class ReflectionBasedReferenceTypeDelegateTest extends TestCase {
 		ResolvedType superType = voidType.getSuperclass();
 		assertNull(superType);
 
-        BcelWorld bcelworld = new BcelWorld();
-        bcelworld.setBehaveInJava5Way(true);
-        ResolvedType bcelSupertype = bcelworld.resolve("int").getSuperclass();
-        assertTrue("Should be null but is "+bcelSupertype,bcelSupertype==null);
+		BcelWorld bcelworld = new BcelWorld();
+		bcelworld.setBehaveInJava5Way(true);
+		ResolvedType bcelSupertype = bcelworld.resolve("int").getSuperclass();
+		assertTrue("Should be null but is " + bcelSupertype, bcelSupertype == null);
+	}
+
+	public void testGenericInterfaceSuperclass_BcelWorldResolution() {
+		BcelWorld bcelworld = new BcelWorld();
+		bcelworld.setBehaveInJava5Way(true);
+
+		UnresolvedType javaUtilMap = UnresolvedType.forName("java.util.Map");
+
+		ReferenceType rawType = (ReferenceType) bcelworld.resolve(javaUtilMap);
+		assertTrue("Should be the raw type ?!? " + rawType.getTypekind(), rawType.isRawType());
+
+		ReferenceType genericType = (ReferenceType) rawType.getGenericType();
+		assertTrue("Should be the generic type ?!? " + genericType.getTypekind(), genericType.isGenericType());
+
+		ResolvedType rt = rawType.getSuperclass();
+		assertTrue("Superclass for Map raw type should be Object but was " + rt, rt.equals(UnresolvedType.OBJECT));
+
+		ResolvedType rt2 = genericType.getSuperclass();
+		assertTrue("Superclass for Map generic type should be Object but was " + rt2, rt2.equals(UnresolvedType.OBJECT));
 	}
-	
-    public void testGenericInterfaceSuperclass_BcelWorldResolution() {
-        BcelWorld bcelworld = new BcelWorld();
-        bcelworld.setBehaveInJava5Way(true);
-        
-        UnresolvedType javaUtilMap = UnresolvedType.forName("java.util.Map");
-        
-        ReferenceType rawType = (ReferenceType) bcelworld.resolve(javaUtilMap);
-        assertTrue("Should be the raw type ?!? "+rawType.getTypekind(),rawType.isRawType());
-        
-        ReferenceType genericType = (ReferenceType)rawType.getGenericType();
-        assertTrue("Should be the generic type ?!? "+genericType.getTypekind(),genericType.isGenericType());
-        
-        ResolvedType rt = rawType.getSuperclass();
-        assertTrue("Superclass for Map raw type should be Object but was "+rt,rt.equals(UnresolvedType.OBJECT));         
-        
-        ResolvedType rt2 = genericType.getSuperclass();
-        assertTrue("Superclass for Map generic type should be Object but was "+rt2,rt2.equals(UnresolvedType.OBJECT));         
-    }
-    
-    // FIXME asc maybe.  The reflection list of methods returned doesn't include <clinit> (the static initializer) ... is that really a problem.
-    public void testCompareSubclassDelegates() {
-    	
-    	boolean barfIfClinitMissing = false;
-        world.setBehaveInJava5Way(true);
-        
-        BcelWorld bcelWorld = new BcelWorld(getClass().getClassLoader(),IMessageHandler.THROW,null);
-        bcelWorld.setBehaveInJava5Way(true);
-        UnresolvedType javaUtilHashMap = UnresolvedType.forName("java.util.HashMap");
-        ReferenceType rawType =(ReferenceType)bcelWorld.resolve(javaUtilHashMap );
-        
-        ReferenceType rawReflectType =(ReferenceType)world.resolve(javaUtilHashMap );
-        ResolvedMember[] rms1 = rawType.getDelegate().getDeclaredMethods();
-        ResolvedMember[] rms2 = rawReflectType.getDelegate().getDeclaredMethods();
-        StringBuffer errors = new StringBuffer();
-        Set one = new HashSet();
-        for (int i = 0; i < rms1.length; i++) {
+
+	// FIXME asc maybe. The reflection list of methods returned doesn't include <clinit> (the static initializer) ... is that really
+	// a problem.
+	public void testCompareSubclassDelegates() {
+
+		boolean barfIfClinitMissing = false;
+		world.setBehaveInJava5Way(true);
+
+		BcelWorld bcelWorld = new BcelWorld(getClass().getClassLoader(), IMessageHandler.THROW, null);
+		bcelWorld.setBehaveInJava5Way(true);
+		UnresolvedType javaUtilHashMap = UnresolvedType.forName("java.util.HashMap");
+		ReferenceType rawType = (ReferenceType) bcelWorld.resolve(javaUtilHashMap);
+
+		ReferenceType rawReflectType = (ReferenceType) world.resolve(javaUtilHashMap);
+		ResolvedMember[] rms1 = rawType.getDelegate().getDeclaredMethods();
+		ResolvedMember[] rms2 = rawReflectType.getDelegate().getDeclaredMethods();
+		StringBuffer errors = new StringBuffer();
+		Set one = new HashSet();
+		for (int i = 0; i < rms1.length; i++) {
 			one.add(rms1[i].toString());
 		}
-        Set two = new HashSet();
-        for (int i = 0; i < rms2.length; i++) {
+		Set two = new HashSet();
+		for (int i = 0; i < rms2.length; i++) {
 			two.add(rms2[i].toString());
 		}
-        for (int i = 0;i<rms2.length;i++) {
-        	if (!one.contains(rms2[i].toString())) {
-        		errors.append("Couldn't find "+rms2[i].toString()+" in the bcel set\n");
-        	}
-        }
-        for (int i = 0;i<rms1.length;i++) {
-        	if (!two.contains(rms1[i].toString())) {
-        		if (!barfIfClinitMissing && rms1[i].getName().equals("<clinit>")) continue;
-        		errors.append("Couldn't find "+rms1[i].toString()+" in the reflection set\n");
-        	}
-        }
-        assertTrue("Errors:"+errors.toString(),errors.length()==0);
-        
-        // the good old ibm vm seems to offer clinit through its reflection support (see pr145322)
-        if (rms1.length==rms2.length) return;
-        if (barfIfClinitMissing) {
-        	// the numbers must be exact
-            assertEquals(rms1.length,rms2.length);        	
-        } else {
-        	// the numbers can be out by one in favour of bcel
-        	if (rms1.length!=(rms2.length+1)) {
-        		for (int i = 0; i < rms1.length; i++) {
-					System.err.println("bcel"+i+" is "+rms1[i]);
+		for (int i = 0; i < rms2.length; i++) {
+			if (!one.contains(rms2[i].toString())) {
+				errors.append("Couldn't find " + rms2[i].toString() + " in the bcel set\n");
+			}
+		}
+		for (int i = 0; i < rms1.length; i++) {
+			if (!two.contains(rms1[i].toString())) {
+				if (!barfIfClinitMissing && rms1[i].getName().equals("<clinit>"))
+					continue;
+				errors.append("Couldn't find " + rms1[i].toString() + " in the reflection set\n");
+			}
+		}
+		assertTrue("Errors:" + errors.toString(), errors.length() == 0);
+
+		// the good old ibm vm seems to offer clinit through its reflection support (see pr145322)
+		if (rms1.length == rms2.length)
+			return;
+		if (barfIfClinitMissing) {
+			// the numbers must be exact
+			assertEquals(rms1.length, rms2.length);
+		} else {
+			// the numbers can be out by one in favour of bcel
+			if (rms1.length != (rms2.length + 1)) {
+				for (int i = 0; i < rms1.length; i++) {
+					System.err.println("bcel" + i + " is " + rms1[i]);
 				}
-        		for (int i = 0; i < rms2.length; i++) {
-					System.err.println("refl"+i+" is "+rms2[i]);
+				for (int i = 0; i < rms2.length; i++) {
+					System.err.println("refl" + i + " is " + rms2[i]);
 				}
-        	}
-        	assertTrue("Should be one extra (clinit) in BCEL case, but bcel="+rms1.length+" reflect="+rms2.length,rms1.length==rms2.length+1);
-        }
-    }
-    	    
-	// todo: array of int	
+			}
+			assertTrue("Should be one extra (clinit) in BCEL case, but bcel=" + rms1.length + " reflect=" + rms2.length,
+					rms1.length == rms2.length + 1);
+		}
+	}
+
+	// todo: array of int
 
 	protected void setUp() throws Exception {
 		world = new ReflectionWorld(getClass().getClassLoader());
@@ -27,6 +27,8 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.ClassFile;
 import org.aspectj.org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Argument;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.aspectj.org.eclipse.jdt.internal.compiler.codegen.CodeStream;
@@ -370,17 +372,27 @@ public class AdviceDeclaration extends AjMethodDeclaration {
 	}
 
 	// called by IfPseudoToken
-	public static Argument[] addTjpArguments(Argument[] arguments) {
+	public static Argument[] addTjpArguments(Argument[] arguments, TypeDeclaration containingTypeDec) {
 		int index = arguments.length;
-		arguments = extendArgumentsLength(arguments, 3);
+		arguments = extendArgumentsLength(arguments, 4);
 
 		arguments[index++] = makeFinalArgument("thisJoinPointStaticPart", AjTypeConstants.getJoinPointStaticPartType());
 		arguments[index++] = makeFinalArgument("thisJoinPoint", AjTypeConstants.getJoinPointType());
 		arguments[index++] = makeFinalArgument("thisEnclosingJoinPointStaticPart", AjTypeConstants.getJoinPointStaticPartType());
+		arguments[index++] = makeFinalArgument("thisAspectInstance", toReference(containingTypeDec.name));
 
 		return arguments;
 	}
 
+	private static TypeReference toReference(char[] typename) {
+		if (CharOperation.contains('.', typename)) {
+			char[][] compoundName = CharOperation.splitOn('.', typename);
+			return new QualifiedTypeReference(compoundName, new long[compoundName.length]);
+		} else {
+			return new SingleTypeReference(typename, 0);
+		}
+	}
+
 	private static Argument makeFinalArgument(String name, TypeReference typeRef) {
 		long pos = 0; // XXX encode start and end location
 		return new Argument(name.toCharArray(), pos, typeRef, Modifier.FINAL);
@@ -415,13 +427,13 @@ public class AdviceDeclaration extends AjMethodDeclaration {
 	// };
 	// };
 	//		s += ")"; //$NON-NLS-1$
-	//		
+	//
 	// if (extraArgument != null) {
 	// s += "(" + extraArgument.toString(0) + ")";
 	// }
-	//		
-	//		
-	//		
+	//
+	//
+	//
 	// if (thrownExceptions != null) {
 	//			s += " throws "; //$NON-NLS-1$
 	// for (int i = 0; i < thrownExceptions.length; i++) {
@@ -430,7 +442,7 @@ public class AdviceDeclaration extends AjMethodDeclaration {
 	//					s = s + ", "; //$NON-NLS-1$
 	// };
 	// };
-	//		
+	//
 	// s += ": ";
 	// if (pointcutDesignator != null) {
 	// s += pointcutDesignator.toString(0);
@@ -17,11 +17,13 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.ClassFile;
 import org.aspectj.org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ReturnStatement;
+import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ClassScope;
 import org.aspectj.org.eclipse.jdt.internal.compiler.parser.Parser;
 import org.aspectj.weaver.Member;
 import org.aspectj.weaver.ResolvedMemberImpl;
-import org.aspectj.weaver.ResolvedType;
+import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.patterns.IfPointcut;
+import org.aspectj.weaver.patterns.PerClause;
 
 public class IfMethodDeclaration extends AjMethodDeclaration {
 	IfPointcut ifPointcut;
@@ -39,7 +41,6 @@ public class IfMethodDeclaration extends AjMethodDeclaration {
 		return classFile.generateMethodInfoAttribute(binding, false, AstUtil.getAjSyntheticAttribute());
 	}
 
-	// private static class TrueFalseVisitor extends astvi
 	public void resolveStatements() {
 		super.resolveStatements();
 		if (binding != null) {
@@ -61,7 +62,21 @@ public class IfMethodDeclaration extends AjMethodDeclaration {
 			// XXX this is where we should remove unavailable args if we're in a cflow
 			EclipseFactory factory = EclipseFactory.fromScopeLookupEnvironment(scope);
 			ifPointcut.testMethod = new ResolvedMemberImpl(Member.METHOD, factory.fromBinding(binding.declaringClass),
-					this.modifiers, ResolvedType.BOOLEAN, new String(this.selector), factory.fromBindings(this.binding.parameters));
+					this.modifiers, UnresolvedType.BOOLEAN, new String(this.selector),
+					factory.fromBindings(this.binding.parameters));
+			if (tjp.needsThisAspectInstance && scope.parent instanceof ClassScope) { // really should be
+				ClassScope o = (ClassScope) scope.parent;
+				if (o.referenceContext instanceof AspectDeclaration) { // really should be
+					AspectDeclaration aspectDecl = (AspectDeclaration) o.referenceContext;
+					if (aspectDecl.perClause != null && aspectDecl.perClause.getKind() != PerClause.SINGLETON) {
+						scope.problemReporter()
+								.signalError(sourceStart, sourceEnd,
+										"thisAspectInstance can only be used inside an if() clause for singleton aspects (compiler limitation)");
+						ignoreFurtherInvestigation = true;
+						return;
+					}
+				}
+			}
 		}
 	}
 }
@@ -77,12 +77,13 @@ public class IfPseudoToken extends PseudoToken {
 		if (pointcut == null)
 			return;
 
-		testMethod = makeMethod(enclosingDec.compilationResult, enclosingDec);
+		testMethod = makeIfMethod(enclosingDec.compilationResult, enclosingDec, typeDec);
 		AstUtil.addMethodDeclaration(typeDec, testMethod);
 	}
 
 	// XXX todo: make sure that errors in Arguments only get displayed once
-	private MethodDeclaration makeMethod(CompilationResult result, MethodDeclaration enclosingDec) {
+	private MethodDeclaration makeIfMethod(CompilationResult result, MethodDeclaration enclosingDec,
+			TypeDeclaration containingTypeDec) {
 		MethodDeclaration ret = new IfMethodDeclaration(result, pointcut);
 		ret.modifiers = ClassFileConstants.AccStatic | ClassFileConstants.AccFinal | ClassFileConstants.AccPublic;
 		ret.returnType = AstUtil.makeTypeReference(TypeBinding.BOOLEAN);
@@ -107,12 +108,12 @@ public class IfPseudoToken extends PseudoToken {
 		// }
 		// hashcode of expression
 		ret.selector = ifSelector.toString().toCharArray();
-		ret.arguments = makeArguments(enclosingDec);
+		ret.arguments = makeArguments(enclosingDec, containingTypeDec);
 		ret.statements = new Statement[] { new ReturnStatement(expr, expr.sourceStart, expr.sourceEnd) };
 		return ret;
 	}
 
-	private Argument[] makeArguments(MethodDeclaration enclosingDec) {
+	private Argument[] makeArguments(MethodDeclaration enclosingDec, TypeDeclaration containingTypeDec) {
 		Argument[] baseArguments = enclosingDec.arguments;
 		int len = baseArguments.length;
 		if (enclosingDec instanceof AdviceDeclaration) {
@@ -124,7 +125,7 @@ public class IfPseudoToken extends PseudoToken {
 			Argument a = baseArguments[i];
 			ret[i] = new Argument(a.name, AstUtil.makeLongPos(a.sourceStart, a.sourceEnd), a.type, Modifier.FINAL);
 		}
-		ret = AdviceDeclaration.addTjpArguments(ret);
+		ret = AdviceDeclaration.addTjpArguments(ret, containingTypeDec);
 
 		return ret;
 	}
@@ -324,7 +324,7 @@ public class InterTypeConstructorDeclaration extends InterTypeDeclaration {
 			((NewConstructorTypeMunger) munger).setExplicitConstructor(world.makeResolvedMember(explicitConstructor));
 		} else {
 			((NewConstructorTypeMunger) munger).setExplicitConstructor(new ResolvedMemberImpl(Member.CONSTRUCTOR, world
-					.fromBinding(onTypeBinding.superclass()), 0, ResolvedType.VOID, "<init>", UnresolvedType.NONE));
+					.fromBinding(onTypeBinding.superclass()), 0, UnresolvedType.VOID, "<init>", UnresolvedType.NONE));
 		}
 		return new AjAttribute.TypeMunger(munger);
 	}
@@ -109,8 +109,8 @@ public class InterTypeFieldDeclaration extends InterTypeDeclaration {
 		ResolvedMember sig = munger.getSignature();
 		UnresolvedType aspectType = world.fromBinding(upperScope.referenceContext.binding);
 
-		if (sig.getReturnType() == ResolvedType.VOID
-				|| (sig.getReturnType().isArray() && (sig.getReturnType().getComponentType() == ResolvedType.VOID))) {
+		if (sig.getReturnType().equals(UnresolvedType.VOID)
+				|| (sig.getReturnType().isArray() && (sig.getReturnType().getComponentType().equals(UnresolvedType.VOID)))) {
 			upperScope.problemReporter().signalError(sourceStart, sourceEnd, "field type can not be void");
 		}
 
@@ -166,28 +166,29 @@ public class InterTypeFieldDeclaration extends InterTypeDeclaration {
 		if (initialization == null) {
 			this.statements = new Statement[] { new ReturnStatement(null, 0, 0), };
 		} else if (!onTypeBinding.isInterface()) {
-			MethodBinding writeMethod = world.makeMethodBinding(AjcMemberMaker.interFieldSetDispatcher(sig, aspectType), munger
-					.getTypeVariableAliases());
+			MethodBinding writeMethod = world.makeMethodBinding(AjcMemberMaker.interFieldSetDispatcher(sig, aspectType),
+					munger.getTypeVariableAliases());
 			// For the body of an intertype field initalizer, generate a call to the inter field set dispatcher
 			// method as that casts the shadow of a field set join point.
 			if (Modifier.isStatic(declaredModifiers)) {
-				this.statements = new Statement[] { new KnownMessageSend(writeMethod, AstUtil
-						.makeNameReference(writeMethod.declaringClass), new Expression[] { initialization }), };
+				this.statements = new Statement[] { new KnownMessageSend(writeMethod,
+						AstUtil.makeNameReference(writeMethod.declaringClass), new Expression[] { initialization }), };
 			} else {
-				this.statements = new Statement[] { new KnownMessageSend(writeMethod, AstUtil
-						.makeNameReference(writeMethod.declaringClass), new Expression[] {
-						AstUtil.makeLocalVariableReference(arguments[0].binding), initialization }), };
+				this.statements = new Statement[] { new KnownMessageSend(writeMethod,
+						AstUtil.makeNameReference(writeMethod.declaringClass), new Expression[] {
+								AstUtil.makeLocalVariableReference(arguments[0].binding), initialization }), };
 			}
 		} else {
 			// XXX something is broken about this logic. Can we write to static interface fields?
-			MethodBinding writeMethod = world.makeMethodBinding(AjcMemberMaker.interFieldInterfaceSetter(sig, sig
-					.getDeclaringType().resolve(world.getWorld()), aspectType), munger.getTypeVariableAliases());
+			MethodBinding writeMethod = world.makeMethodBinding(
+					AjcMemberMaker.interFieldInterfaceSetter(sig, sig.getDeclaringType().resolve(world.getWorld()), aspectType),
+					munger.getTypeVariableAliases());
 			if (Modifier.isStatic(declaredModifiers)) {
-				this.statements = new Statement[] { new KnownMessageSend(writeMethod, AstUtil
-						.makeNameReference(writeMethod.declaringClass), new Expression[] { initialization }), };
+				this.statements = new Statement[] { new KnownMessageSend(writeMethod,
+						AstUtil.makeNameReference(writeMethod.declaringClass), new Expression[] { initialization }), };
 			} else {
-				this.statements = new Statement[] { new KnownMessageSend(writeMethod, AstUtil
-						.makeLocalVariableReference(arguments[0].binding), new Expression[] { initialization }), };
+				this.statements = new Statement[] { new KnownMessageSend(writeMethod,
+						AstUtil.makeLocalVariableReference(arguments[0].binding), new Expression[] { initialization }), };
 			}
 		}
 
@@ -314,16 +315,16 @@ public class InterTypeFieldDeclaration extends InterTypeDeclaration {
 			ClassFile classFile, boolean isGetter) {
 		MethodBinding binding;
 		if (isGetter) {
-			binding = world.makeMethodBinding(AjcMemberMaker.interFieldGetDispatcher(sig, aspectType), munger
-					.getTypeVariableAliases(), munger.getSignature().getDeclaringType());
+			binding = world.makeMethodBinding(AjcMemberMaker.interFieldGetDispatcher(sig, aspectType),
+					munger.getTypeVariableAliases(), munger.getSignature().getDeclaringType());
 		} else {
-			binding = world.makeMethodBinding(AjcMemberMaker.interFieldSetDispatcher(sig, aspectType), munger
-					.getTypeVariableAliases(), munger.getSignature().getDeclaringType());
+			binding = world.makeMethodBinding(AjcMemberMaker.interFieldSetDispatcher(sig, aspectType),
+					munger.getTypeVariableAliases(), munger.getSignature().getDeclaringType());
 		}
 		classFile.generateMethodInfoHeader(binding);
 		int methodAttributeOffset = classFile.contentsOffset;
-		int attributeNumber = classFile.generateMethodInfoAttribute(binding, false, makeEffectiveSignatureAttribute(sig,
-				isGetter ? Shadow.FieldGet : Shadow.FieldSet, false));
+		int attributeNumber = classFile.generateMethodInfoAttribute(binding, false,
+				makeEffectiveSignatureAttribute(sig, isGetter ? Shadow.FieldGet : Shadow.FieldSet, false));
 		int codeAttributeOffset = classFile.contentsOffset;
 		classFile.generateCodeAttributeHeader();
 		CodeStream codeStream = classFile.codeStream;
@@ -331,7 +332,7 @@ public class InterTypeFieldDeclaration extends InterTypeDeclaration {
 
 		NewFieldTypeMunger fieldMunger = (NewFieldTypeMunger) munger;
 
-        // Force use of version 1 if there is a field with that name on the type already
+		// Force use of version 1 if there is a field with that name on the type already
 		if (world.getItdVersion() == 1) {
 			fieldMunger.version = NewFieldTypeMunger.VersionOne;
 		} else {
@@ -346,24 +347,27 @@ public class InterTypeFieldDeclaration extends InterTypeDeclaration {
 			}
 		}
 
-		FieldBinding classField = world.makeFieldBinding(AjcMemberMaker.interFieldClassField(sig, aspectType,
-				fieldMunger.version == NewFieldTypeMunger.VersionTwo), munger.getTypeVariableAliases());
+		FieldBinding classField = world.makeFieldBinding(
+				AjcMemberMaker.interFieldClassField(sig, aspectType, fieldMunger.version == NewFieldTypeMunger.VersionTwo),
+				munger.getTypeVariableAliases());
 
 		codeStream.initializeMaxLocals(binding);
 		if (isGetter) {
 			if (onTypeBinding.isInterface()) {
 				UnresolvedType declaringTX = sig.getDeclaringType();
 				ResolvedType declaringRTX = world.getWorld().resolve(declaringTX, munger.getSourceLocation());
-				MethodBinding readMethod = world.makeMethodBinding(AjcMemberMaker.interFieldInterfaceGetter(sig, declaringRTX,
-						aspectType), munger.getTypeVariableAliases());
+				MethodBinding readMethod = world.makeMethodBinding(
+						AjcMemberMaker.interFieldInterfaceGetter(sig, declaringRTX, aspectType), munger.getTypeVariableAliases());
 				generateInterfaceReadBody(binding, readMethod, codeStream);
 			} else {
 				generateClassReadBody(binding, classField, codeStream);
 			}
 		} else {
 			if (onTypeBinding.isInterface()) {
-				MethodBinding writeMethod = world.makeMethodBinding(AjcMemberMaker.interFieldInterfaceSetter(sig, world.getWorld()
-						.resolve(sig.getDeclaringType(), munger.getSourceLocation()), aspectType), munger.getTypeVariableAliases());
+				MethodBinding writeMethod = world.makeMethodBinding(
+						AjcMemberMaker.interFieldInterfaceSetter(sig,
+								world.getWorld().resolve(sig.getDeclaringType(), munger.getSourceLocation()), aspectType),
+						munger.getTypeVariableAliases());
 				generateInterfaceWriteBody(binding, writeMethod, codeStream);
 			} else {
 				generateClassWriteBody(binding, classField, codeStream);
@@ -40,6 +40,7 @@ public class ThisJoinPointVisitor extends ASTVisitor {
 	boolean needsDynamic = false;
 	boolean needsStatic = false;
 	boolean needsStaticEnclosing = false;
+	boolean needsThisAspectInstance = false;
 	boolean hasEffectivelyStaticRef = false;
 	boolean hasConstantReference = false;
 	boolean constantReferenceValue = false; // only has valid value when hasConstantReference is true
@@ -47,18 +48,25 @@ public class ThisJoinPointVisitor extends ASTVisitor {
 	LocalVariableBinding thisJoinPointDec;
 	LocalVariableBinding thisJoinPointStaticPartDec;
 	LocalVariableBinding thisEnclosingJoinPointStaticPartDec;
+	LocalVariableBinding thisAspectInstanceDec;
 
 	LocalVariableBinding thisJoinPointDecLocal;
 	LocalVariableBinding thisJoinPointStaticPartDecLocal;
 	LocalVariableBinding thisEnclosingJoinPointStaticPartDecLocal;
+	LocalVariableBinding thisAspectInstanceDecLocal;
 
 	boolean replaceEffectivelyStaticRefs = false;
 
+	boolean isIf = true;
+
 	AbstractMethodDeclaration method;
 
 	ThisJoinPointVisitor(AbstractMethodDeclaration method) {
 		this.method = method;
-		int index = method.arguments.length - 3;
+		if (method instanceof AdviceDeclaration) {
+			isIf = false;
+		}
+		int index = method.arguments.length - 3 - (isIf ? 1 : 0);
 
 		thisJoinPointStaticPartDecLocal = method.scope.locals[index];
 		thisJoinPointStaticPartDec = method.arguments[index++].binding;
@@ -66,6 +74,10 @@ public class ThisJoinPointVisitor extends ASTVisitor {
 		thisJoinPointDec = method.arguments[index++].binding;
 		thisEnclosingJoinPointStaticPartDecLocal = method.scope.locals[index];
 		thisEnclosingJoinPointStaticPartDec = method.arguments[index++].binding;
+		if (isIf) {
+			thisAspectInstanceDecLocal = method.scope.locals[index];
+			thisAspectInstanceDec = method.arguments[index++].binding;
+		}
 	}
 
 	public void computeJoinPointParams() {
@@ -100,6 +112,8 @@ public class ThisJoinPointVisitor extends ASTVisitor {
 			needsStatic = true;
 		} else if (isRef(ref, thisEnclosingJoinPointStaticPartDec)) {
 			needsStaticEnclosing = true;
+		} else if (isIf && isRef(ref, thisAspectInstanceDec)) {
+			needsThisAspectInstance = true;
 		} else if (ref.constant != null && ref.constant != Constant.NotAConstant) {
 			if (ref.constant instanceof BooleanConstant) {
 				hasConstantReference = true;
@@ -196,7 +210,16 @@ public class ThisJoinPointVisitor extends ASTVisitor {
 		this.computeJoinPointParams();
 		MethodBinding binding = method.binding;
 
-		int index = binding.parameters.length - 3;
+		int index = binding.parameters.length - 3 - (isIf ? 1 : 0);
+
+		if (isIf) {
+			if (needsThisAspectInstance) {
+				extraArgumentFlags |= Advice.ThisAspectInstance;
+			} else {
+				removeParameter(index + 3);
+			}
+		}
+
 		if (needsStaticEnclosing) {
 			extraArgumentFlags |= Advice.ThisEnclosingJoinPointStaticPart;
 		} else {
@@ -218,6 +241,10 @@ public class ThisJoinPointVisitor extends ASTVisitor {
 		return extraArgumentFlags;
 	}
 
+	public boolean usedThisAspectInstance() {
+		return needsThisAspectInstance;
+	}
+
 	private void removeParameter(int indexToRemove) {
 		// TypeBinding[] parameters = method.binding.parameters;
 		method.scope.locals = removeLocalBinding(indexToRemove, method.scope.locals);
@@ -639,31 +639,31 @@ public class EclipseFactory {
 
 	private TypeBinding makeTypeBinding1(UnresolvedType typeX) {
 		if (typeX.isPrimitiveType()) {
-			if (typeX == ResolvedType.BOOLEAN) {
+			if (typeX.equals(UnresolvedType.BOOLEAN)) {
 				return TypeBinding.BOOLEAN;
 			}
-			if (typeX == ResolvedType.BYTE) {
+			if (typeX.equals(UnresolvedType.BYTE)) {
 				return TypeBinding.BYTE;
 			}
-			if (typeX == ResolvedType.CHAR) {
+			if (typeX.equals(UnresolvedType.CHAR)) {
 				return TypeBinding.CHAR;
 			}
-			if (typeX == ResolvedType.DOUBLE) {
+			if (typeX.equals(UnresolvedType.DOUBLE)) {
 				return TypeBinding.DOUBLE;
 			}
-			if (typeX == ResolvedType.FLOAT) {
+			if (typeX.equals(UnresolvedType.FLOAT)) {
 				return TypeBinding.FLOAT;
 			}
-			if (typeX == ResolvedType.INT) {
+			if (typeX.equals(UnresolvedType.INT)) {
 				return TypeBinding.INT;
 			}
-			if (typeX == ResolvedType.LONG) {
+			if (typeX.equals(UnresolvedType.LONG)) {
 				return TypeBinding.LONG;
 			}
-			if (typeX == ResolvedType.SHORT) {
+			if (typeX.equals(UnresolvedType.SHORT)) {
 				return TypeBinding.SHORT;
 			}
-			if (typeX == ResolvedType.VOID) {
+			if (typeX.equals(UnresolvedType.VOID)) {
 				return TypeBinding.VOID;
 			}
 			throw new RuntimeException("weird primitive type " + typeX);
@@ -10,33 +10,46 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.ajdt.internal.compiler.lookup;
 
-
-import org.aspectj.ajdt.internal.compiler.ast.*;
+import org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration;
+import org.aspectj.ajdt.internal.compiler.ast.InterTypeConstructorDeclaration;
+import org.aspectj.ajdt.internal.compiler.ast.InterTypeDeclaration;
+import org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration;
+import org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration;
 import org.aspectj.bridge.ISourceLocation;
-import org.aspectj.weaver.*;
-import org.aspectj.weaver.ast.Var;
-import org.aspectj.org.eclipse.jdt.internal.compiler.ast.*;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Clinit;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
+import org.aspectj.weaver.Member;
+import org.aspectj.weaver.MemberImpl;
+import org.aspectj.weaver.ResolvedType;
+import org.aspectj.weaver.Shadow;
+import org.aspectj.weaver.UnresolvedType;
+import org.aspectj.weaver.World;
+import org.aspectj.weaver.ast.Var;
 
 /**
  * This is only used for declare soft right now.
  * 
- * It might be used for other compile-time matching, but in all such cases
- * this and target pcds can't be used.  We might not behave correctly in
- * such cases.
+ * It might be used for other compile-time matching, but in all such cases this and target pcds can't be used. We might not behave
+ * correctly in such cases.
  */
 public class EclipseShadow extends Shadow {
 	EclipseFactory world;
 	ASTNode astNode;
 	ReferenceContext context;
-	//AbstractMethodDeclaration enclosingMethod;
 
-	public EclipseShadow(EclipseFactory world, Kind kind, Member signature, ASTNode astNode, 
-							ReferenceContext context)
-	{
+	// AbstractMethodDeclaration enclosingMethod;
+
+	public EclipseShadow(EclipseFactory world, Kind kind, Member signature, ASTNode astNode, ReferenceContext context) {
 		super(kind, signature, null);
 		this.world = world;
 		this.astNode = astNode;
@@ -47,28 +60,27 @@ public class EclipseShadow extends Shadow {
 		return world.getWorld();
 	}
 
-
 	public UnresolvedType getEnclosingType() {
 		if (context instanceof TypeDeclaration) {
-			return world.fromBinding(((TypeDeclaration)context).binding);
+			return world.fromBinding(((TypeDeclaration) context).binding);
 		} else if (context instanceof AbstractMethodDeclaration) {
-			return world.fromBinding(((AbstractMethodDeclaration)context).binding.declaringClass);
+			return world.fromBinding(((AbstractMethodDeclaration) context).binding.declaringClass);
 		} else {
 			return ResolvedType.MISSING;
 		}
 	}
-	
+
 	public ISourceLocation getSourceLocation() {
-		//XXX need to fill this in ASAP
+		// XXX need to fill this in ASAP
 		return null;
 	}
 
 	public Member getEnclosingCodeSignature() {
 		if (context instanceof TypeDeclaration) {
-			return new MemberImpl(Member.STATIC_INITIALIZATION, getEnclosingType(), 0, 
-						ResolvedType.VOID, "<clinit>", UnresolvedType.NONE);
+			return new MemberImpl(Member.STATIC_INITIALIZATION, getEnclosingType(), 0, UnresolvedType.VOID, "<clinit>",
+					UnresolvedType.NONE);
 		} else if (context instanceof AbstractMethodDeclaration) {
-			return world.makeResolvedMember(((AbstractMethodDeclaration)context).binding);
+			return world.makeResolvedMember(((AbstractMethodDeclaration) context).binding);
 		} else {
 			return null;
 		}
@@ -108,52 +120,52 @@ public class EclipseShadow extends Shadow {
 	public Var getKindedAnnotationVar(UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
-	
+
 	public Var getTargetAnnotationVar(UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
-	
+
 	public Var getThisAnnotationVar(UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
-	
+
+	public Var getThisAspectInstanceVar(ResolvedType aspectType) {
+		throw new RuntimeException("unimplemented");
+	}
+
 	public Var getWithinAnnotationVar(UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
-	
+
 	public Var getWithinCodeAnnotationVar(UnresolvedType annotationType) {
 		throw new RuntimeException("unimplemented");
 	}
 
 	// --- factory methods
-	
-	public static EclipseShadow makeShadow(EclipseFactory world, ASTNode astNode, 
-							ReferenceContext context)
-	{
-		//XXX make sure we're getting the correct declaring type at call-site
+
+	public static EclipseShadow makeShadow(EclipseFactory world, ASTNode astNode, ReferenceContext context) {
+		// XXX make sure we're getting the correct declaring type at call-site
 		if (astNode instanceof AllocationExpression) {
-			AllocationExpression e = (AllocationExpression)astNode;
-			return new EclipseShadow(world, Shadow.ConstructorCall,
-					world.makeResolvedMember(e.binding), astNode, context);
+			AllocationExpression e = (AllocationExpression) astNode;
+			return new EclipseShadow(world, Shadow.ConstructorCall, world.makeResolvedMember(e.binding), astNode, context);
 		} else if (astNode instanceof MessageSend) {
-			MessageSend e = (MessageSend)astNode;
-			if (e.isSuperAccess()) return null;  // super calls don't have shadows
-			return new EclipseShadow(world, Shadow.MethodCall,
-					world.makeResolvedMember(e.binding), astNode, context);
+			MessageSend e = (MessageSend) astNode;
+			if (e.isSuperAccess())
+				return null; // super calls don't have shadows
+			return new EclipseShadow(world, Shadow.MethodCall, world.makeResolvedMember(e.binding), astNode, context);
 		} else if (astNode instanceof ExplicitConstructorCall) {
-			//??? these should be ignored, they don't have shadows
-			return null;				
+			// ??? these should be ignored, they don't have shadows
+			return null;
 		} else if (astNode instanceof AbstractMethodDeclaration) {
-			AbstractMethodDeclaration e = (AbstractMethodDeclaration)astNode;
+			AbstractMethodDeclaration e = (AbstractMethodDeclaration) astNode;
 			Shadow.Kind kind;
 			if (e instanceof AdviceDeclaration) {
 				kind = Shadow.AdviceExecution;
 			} else if (e instanceof InterTypeMethodDeclaration) {
-				return new EclipseShadow(world, Shadow.MethodExecution,
-					((InterTypeDeclaration)e).getSignature(), astNode, context);
+				return new EclipseShadow(world, Shadow.MethodExecution, ((InterTypeDeclaration) e).getSignature(), astNode, context);
 			} else if (e instanceof InterTypeConstructorDeclaration) {
-				return new EclipseShadow(world, Shadow.ConstructorExecution,
-					((InterTypeDeclaration)e).getSignature(), astNode, context);
+				return new EclipseShadow(world, Shadow.ConstructorExecution, ((InterTypeDeclaration) e).getSignature(), astNode,
+						context);
 			} else if (e instanceof InterTypeFieldDeclaration) {
 				return null;
 			} else if (e instanceof MethodDeclaration) {
@@ -161,25 +173,20 @@ public class EclipseShadow extends Shadow {
 			} else if (e instanceof ConstructorDeclaration) {
 				kind = Shadow.ConstructorExecution;
 			} else if (e instanceof Clinit) {
-				kind = Shadow.StaticInitialization; 
+				kind = Shadow.StaticInitialization;
 			} else {
 				return null;
-				//throw new RuntimeException("unimplemented: " + e);
+				// throw new RuntimeException("unimplemented: " + e);
 			}
-			return
-				new EclipseShadow(world, kind,
-					world.makeResolvedMember(e.binding,kind), astNode, context);
+			return new EclipseShadow(world, kind, world.makeResolvedMember(e.binding, kind), astNode, context);
 		} else if (astNode instanceof TypeDeclaration) {
 			return new EclipseShadow(world, Shadow.StaticInitialization,
-							new MemberImpl(Member.STATIC_INITIALIZATION, 
-								world.fromBinding(((TypeDeclaration)astNode).binding), 0, 
-								ResolvedType.VOID, "<clinit>", UnresolvedType.NONE),
-							astNode, context);
+					new MemberImpl(Member.STATIC_INITIALIZATION, world.fromBinding(((TypeDeclaration) astNode).binding), 0,
+							UnresolvedType.VOID, "<clinit>", UnresolvedType.NONE), astNode, context);
 		} else {
 			return null;
-			//throw new RuntimeException("unimplemented: " + astNode);
-		}		
+			// throw new RuntimeException("unimplemented: " + astNode);
+		}
 	}
 
-	
 }
@@ -115,7 +115,7 @@ public class PrivilegedHandler implements IPrivilegedHandler {
 
 	public void notePrivilegedTypeAccess(ReferenceBinding type, ASTNode location) {
 		ResolvedMember key = new ResolvedMemberImpl(Member.STATIC_INITIALIZATION, inAspect.factory.fromEclipse(type), 0,
-				ResolvedType.VOID, "", UnresolvedType.NONE);
+				UnresolvedType.VOID, "", UnresolvedType.NONE);
 
 		checkWeaveAccess(key.getDeclaringType(), location);
 		accessors.put(key, key);
@@ -152,6 +152,16 @@ public abstract class Advice extends ShadowMunger {
 			} else if (kind == AdviceKind.PerTargetEntry) {
 				return shadow.hasTarget();
 			} else if (kind == AdviceKind.PerThisEntry) {
+				// Groovy Constructors have a strange switch statement in them - this switch statement can leave us in places where
+				// the
+				// instance is not initialized (a super ctor hasn't been called yet).
+				// In these situations it isn't safe to do a perObjectBind, the instance is not initialized and cannot be passed
+				// over.
+				if (shadow.getEnclosingCodeSignature().getName().equals("<init>")) {
+					if (world.resolve(shadow.getEnclosingType()).isGroovyObject()) {
+						return false;
+					}
+				}
 				return shadow.hasThis();
 			} else if (kind == AdviceKind.Around) {
 				if (shadow.getKind() == Shadow.PreInitialization) {
@@ -170,8 +180,8 @@ public abstract class Advice extends ShadowMunger {
 				} else {
 					// System.err.println(getSignature().getReturnType() +
 					// " from " + shadow.getReturnType());
-					if (getSignature().getReturnType() == ResolvedType.VOID) {
-						if (shadow.getReturnType() != ResolvedType.VOID) {
+					if (getSignature().getReturnType().equals(UnresolvedType.VOID)) {
+						if (!shadow.getReturnType().equals(UnresolvedType.VOID)) {
 							world.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.NON_VOID_RETURN, shadow),
 									getSourceLocation(), shadow.getSourceLocation());
 							return false;
@@ -351,7 +361,7 @@ public abstract class Advice extends ShadowMunger {
 				while ((baseParmCnt + 1 < parameterTypes.length)
 						&& (parameterTypes[baseParmCnt].equals(AjcMemberMaker.TYPEX_JOINPOINT)
 								|| parameterTypes[baseParmCnt].equals(AjcMemberMaker.TYPEX_STATICJOINPOINT) || parameterTypes[baseParmCnt]
-								.equals(AjcMemberMaker.TYPEX_ENCLOSINGSTATICJOINPOINT))) {
+									.equals(AjcMemberMaker.TYPEX_ENCLOSINGSTATICJOINPOINT))) {
 					baseParmCnt++;
 				}
 				return parameterTypes[baseParmCnt];
@@ -473,7 +483,10 @@ public abstract class Advice extends ShadowMunger {
 	public static final int ConstantReference = 0x10;
 	// When the above flag is set, this indicates whether it is true or false
 	public static final int ConstantValue = 0x20;
-	public static final int CanInline = 0x40;
+	// public static final int CanInline = 0x40; // didnt appear to be getting used
+	public static final int ThisAspectInstance = 0x40;
+
+	// cant use 0x80 ! the value is written out as a byte and -1 has special meaning (-1 is 0x80...)
 
 	// for testing only
 	public void setLexicalPosition(int lexicalPosition) {
@@ -88,8 +88,8 @@ public class AjcMemberMaker {
 		if (!UnresolvedType.SERIALIZABLE.resolve(aspectType.getWorld()).isAssignableFrom(aspectType)) {
 			modifiers |= Modifier.TRANSIENT;
 		}
-		return new ResolvedMemberImpl(Member.FIELD, declaringType, modifiers, aspectType, NameMangler
-				.perObjectInterfaceField(aspectType), UnresolvedType.NONE);
+		return new ResolvedMemberImpl(Member.FIELD, declaringType, modifiers, aspectType,
+				NameMangler.perObjectInterfaceField(aspectType), UnresolvedType.NONE);
 	}
 
 	// PTWIMPL ResolvedMember for aspect instance field, declared in matched type
@@ -98,8 +98,8 @@ public class AjcMemberMaker {
 		if (!isSerializableAspect(aspectType)) {
 			modifiers |= Modifier.TRANSIENT;
 		}
-		return new ResolvedMemberImpl(Member.FIELD, declaringType, modifiers, aspectType, NameMangler
-				.perTypeWithinFieldForTarget(aspectType), UnresolvedType.NONE);
+		return new ResolvedMemberImpl(Member.FIELD, declaringType, modifiers, aspectType,
+				NameMangler.perTypeWithinFieldForTarget(aspectType), UnresolvedType.NONE);
 	}
 
 	// PTWIMPL ResolvedMember for type instance field, declared in aspect
@@ -133,8 +133,8 @@ public class AjcMemberMaker {
 	// PTWIMPL ResolvedMember for getWithinTypeName() method
 	public static ResolvedMember perTypeWithinGetWithinTypeNameMethod(UnresolvedType declaringType, boolean inJava5Mode) {
 		// public String getWithinTypeName()
-		ResolvedMemberImpl rm = new ResolvedMemberImpl(Member.METHOD, declaringType, Modifier.PUBLIC,
-				UnresolvedType.JL_STRING, // return value
+		ResolvedMemberImpl rm = new ResolvedMemberImpl(Member.METHOD, declaringType, Modifier.PUBLIC, UnresolvedType.JL_STRING, // return
+																																// value
 				NameMangler.PERTYPEWITHIN_GETWITHINTYPENAME_METHOD, UnresolvedType.NONE);
 		return rm;
 	}
@@ -142,8 +142,8 @@ public class AjcMemberMaker {
 	public static ResolvedMember perTypeWithinCreateAspectInstance(UnresolvedType declaringType) {
 		// public static a.X ajc$createAspectInstance(java.lang.String)
 		ResolvedMemberImpl rm = new ResolvedMemberImpl(Member.METHOD, declaringType, PUBLIC_STATIC, declaringType, // return value
-				NameMangler.PERTYPEWITHIN_CREATEASPECTINSTANCE_METHOD, new UnresolvedType[] { UnresolvedType
-						.forSignature("Ljava/lang/String;") }, new UnresolvedType[] {});
+				NameMangler.PERTYPEWITHIN_CREATEASPECTINSTANCE_METHOD,
+				new UnresolvedType[] { UnresolvedType.forSignature("Ljava/lang/String;") }, new UnresolvedType[] {});
 		return rm;
 	}
 
@@ -224,7 +224,7 @@ public class AjcMemberMaker {
 		} else {
 			parameterType = UnresolvedType.forSignature("Ljava/lang/Class;");
 		}
-		return new ResolvedMemberImpl(Member.METHOD, declaringType, PUBLIC_STATIC, ResolvedType.BOOLEAN, "hasAspect",
+		return new ResolvedMemberImpl(Member.METHOD, declaringType, PUBLIC_STATIC, UnresolvedType.BOOLEAN, "hasAspect",
 				new UnresolvedType[] { parameterType });
 		// return new ResolvedMemberImpl(Member.METHOD,
 		// declaringType, PUBLIC_STATIC, "hasAspect",
@@ -235,9 +235,9 @@ public class AjcMemberMaker {
 
 	public static ResolvedMember privilegedAccessMethodForMethod(UnresolvedType aspectType, ResolvedMember method) {
 		return new ResolvedMemberImpl(Member.METHOD, method.getDeclaringType(), Modifier.PUBLIC
-				| (Modifier.isStatic(method.getModifiers()) ? Modifier.STATIC : 0), method.getReturnType(), NameMangler
-				.privilegedAccessMethodForMethod(method.getName(), method.getDeclaringType(), aspectType), method
-				.getParameterTypes(), method.getExceptions());
+				| (Modifier.isStatic(method.getModifiers()) ? Modifier.STATIC : 0), method.getReturnType(),
+				NameMangler.privilegedAccessMethodForMethod(method.getName(), method.getDeclaringType(), aspectType),
+				method.getParameterTypes(), method.getExceptions());
 	}
 
 	/**
@@ -294,7 +294,7 @@ public class AjcMemberMaker {
 			}
 			StringBuffer name = new StringBuffer("ajc$set$");
 			name.append(field.getName());
-			return new ResolvedMemberImpl(Member.METHOD, fieldDeclaringType, PUBLIC_STATIC, ResolvedType.VOID, name.toString(),
+			return new ResolvedMemberImpl(Member.METHOD, fieldDeclaringType, PUBLIC_STATIC, UnresolvedType.VOID, name.toString(),
 					args);
 		} else {
 			String setterName = NameMangler.privilegedAccessMethodForFieldSet(field.getName(), fieldDeclaringType, aspectType);
@@ -315,8 +315,8 @@ public class AjcMemberMaker {
 		// if (!method.isStatic()) {
 		// paramTypes = UnresolvedType.insert(method.getDeclaringType(), paramTypes);
 		// }
-		return new ResolvedMemberImpl(Member.METHOD, baseType, Modifier.PUBLIC, method.getReturnType(), NameMangler
-				.superDispatchMethod(baseType, method.getName()), paramTypes, method.getExceptions());
+		return new ResolvedMemberImpl(Member.METHOD, baseType, Modifier.PUBLIC, method.getReturnType(),
+				NameMangler.superDispatchMethod(baseType, method.getName()), paramTypes, method.getExceptions());
 	}
 
 	public static ResolvedMember inlineAccessMethodForMethod(UnresolvedType aspectType, ResolvedMember method) {
@@ -387,14 +387,14 @@ public class AjcMemberMaker {
 
 	public static ResolvedMember preIntroducedConstructor(UnresolvedType aspectType, UnresolvedType targetType,
 			UnresolvedType[] paramTypes) {
-		return new ResolvedMemberImpl(Member.METHOD, aspectType, PUBLIC_STATIC_FINAL, UnresolvedType.OBJECTARRAY, NameMangler
-				.preIntroducedConstructor(aspectType, targetType), paramTypes);
+		return new ResolvedMemberImpl(Member.METHOD, aspectType, PUBLIC_STATIC_FINAL, UnresolvedType.OBJECTARRAY,
+				NameMangler.preIntroducedConstructor(aspectType, targetType), paramTypes);
 	}
 
 	public static ResolvedMember postIntroducedConstructor(UnresolvedType aspectType, UnresolvedType targetType,
 			UnresolvedType[] paramTypes) {
-		return new ResolvedMemberImpl(Member.METHOD, aspectType, PUBLIC_STATIC_FINAL, ResolvedType.VOID, NameMangler
-				.postIntroducedConstructor(aspectType, targetType), UnresolvedType.insert(targetType, paramTypes));
+		return new ResolvedMemberImpl(Member.METHOD, aspectType, PUBLIC_STATIC_FINAL, UnresolvedType.VOID,
+				NameMangler.postIntroducedConstructor(aspectType, targetType), UnresolvedType.insert(targetType, paramTypes));
 	}
 
 	public static ResolvedMember itdAtDeclareParentsField(ResolvedType targetType, UnresolvedType itdType, UnresolvedType aspectType) {
@@ -403,12 +403,12 @@ public class AjcMemberMaker {
 	}
 
 	public static ResolvedMember interConstructor(ResolvedType targetType, ResolvedMember constructor, UnresolvedType aspectType) {
-		//		
+		//
 		// ResolvedType targetType,
 		// UnresolvedType[] argTypes,
 		// int modifiers)
 		// {
-		ResolvedMember ret = new ResolvedMemberImpl(Member.CONSTRUCTOR, targetType, Modifier.PUBLIC, ResolvedType.VOID, "<init>",
+		ResolvedMember ret = new ResolvedMemberImpl(Member.CONSTRUCTOR, targetType, Modifier.PUBLIC, UnresolvedType.VOID, "<init>",
 				constructor.getParameterTypes(), constructor.getExceptions());
 		// System.out.println("ret: " + ret + " mods: " + Modifier.toString(modifiers));
 		if (Modifier.isPublic(constructor.getModifiers())) {
@@ -423,8 +423,8 @@ public class AjcMemberMaker {
 	}
 
 	public static ResolvedMember interFieldInitializer(ResolvedMember field, UnresolvedType aspectType) {
-		return new ResolvedMemberImpl(Member.METHOD, aspectType, PUBLIC_STATIC, NameMangler.interFieldInitializer(aspectType, field
-				.getDeclaringType(), field.getName()), Modifier.isStatic(field.getModifiers()) ? "()V" : "("
+		return new ResolvedMemberImpl(Member.METHOD, aspectType, PUBLIC_STATIC, NameMangler.interFieldInitializer(aspectType,
+				field.getDeclaringType(), field.getName()), Modifier.isStatic(field.getModifiers()) ? "()V" : "("
 				+ field.getDeclaringType().getSignature() + ")V");
 	}
 
@@ -440,10 +440,10 @@ public class AjcMemberMaker {
 	 * This static method goes on the aspect that declares the inter-type field
 	 */
 	public static ResolvedMember interFieldSetDispatcher(ResolvedMember field, UnresolvedType aspectType) {
-		ResolvedMember rm = new ResolvedMemberImpl(Member.METHOD, aspectType, PUBLIC_STATIC, ResolvedType.VOID, NameMangler
-				.interFieldSetDispatcher(aspectType, field.getDeclaringType(), field.getName()), Modifier.isStatic(field
-				.getModifiers()) ? new UnresolvedType[] { field.getReturnType() } : new UnresolvedType[] {
-				field.getDeclaringType(), field.getReturnType() });
+		ResolvedMember rm = new ResolvedMemberImpl(Member.METHOD, aspectType, PUBLIC_STATIC, UnresolvedType.VOID,
+				NameMangler.interFieldSetDispatcher(aspectType, field.getDeclaringType(), field.getName()), Modifier.isStatic(field
+						.getModifiers()) ? new UnresolvedType[] { field.getReturnType() } : new UnresolvedType[] {
+						field.getDeclaringType(), field.getReturnType() });
 		rm.setTypeVariables(field.getTypeVariables());
 		return rm;
 	}
@@ -452,9 +452,10 @@ public class AjcMemberMaker {
 	 * This static method goes on the aspect that declares the inter-type field
 	 */
 	public static ResolvedMember interFieldGetDispatcher(ResolvedMember field, UnresolvedType aspectType) {
-		ResolvedMember rm = new ResolvedMemberImpl(Member.METHOD, aspectType, PUBLIC_STATIC, field.getReturnType(), NameMangler
-				.interFieldGetDispatcher(aspectType, field.getDeclaringType(), field.getName()), Modifier.isStatic(field
-				.getModifiers()) ? UnresolvedType.NONE : new UnresolvedType[] { field.getDeclaringType() }, UnresolvedType.NONE);
+		ResolvedMember rm = new ResolvedMemberImpl(Member.METHOD, aspectType, PUBLIC_STATIC, field.getReturnType(),
+				NameMangler.interFieldGetDispatcher(aspectType, field.getDeclaringType(), field.getName()), Modifier.isStatic(field
+						.getModifiers()) ? UnresolvedType.NONE : new UnresolvedType[] { field.getDeclaringType() },
+				UnresolvedType.NONE);
 		rm.setTypeVariables(field.getTypeVariables());
 		return rm;
 	}
@@ -498,9 +499,9 @@ public class AjcMemberMaker {
 		if (onType.isInterface()) {
 			modifiers |= Modifier.ABSTRACT;
 		}
-		ResolvedMember rm = new ResolvedMemberImpl(Member.METHOD, onType, modifiers, ResolvedType.VOID, NameMangler
-				.interFieldInterfaceSetter(aspectType, field.getDeclaringType(), field.getName()), new UnresolvedType[] { field
-				.getReturnType() }, UnresolvedType.NONE);
+		ResolvedMember rm = new ResolvedMemberImpl(Member.METHOD, onType, modifiers, UnresolvedType.VOID,
+				NameMangler.interFieldInterfaceSetter(aspectType, field.getDeclaringType(), field.getName()),
+				new UnresolvedType[] { field.getReturnType() }, UnresolvedType.NONE);
 		rm.setTypeVariables(field.getTypeVariables());
 		return rm;
 	}
@@ -513,8 +514,8 @@ public class AjcMemberMaker {
 		if (onType.isInterface()) {
 			modifiers |= Modifier.ABSTRACT;
 		}
-		ResolvedMember rm = new ResolvedMemberImpl(Member.METHOD, onType, modifiers, field.getReturnType(), NameMangler
-				.interFieldInterfaceGetter(aspectType, field.getDeclaringType(), field.getName()), UnresolvedType.NONE,
+		ResolvedMember rm = new ResolvedMemberImpl(Member.METHOD, onType, modifiers, field.getReturnType(),
+				NameMangler.interFieldInterfaceGetter(aspectType, field.getDeclaringType(), field.getName()), UnresolvedType.NONE,
 				UnresolvedType.NONE);
 		rm.setTypeVariables(field.getTypeVariables());
 		return rm;
@@ -535,8 +536,8 @@ public class AjcMemberMaker {
 		}
 
 		ResolvedMemberImpl rmi = new ResolvedMemberImpl(Member.METHOD, meth.getDeclaringType(), modifiers, meth.getReturnType(),
-				NameMangler.interMethod(meth.getModifiers(), aspectType, meth.getDeclaringType(), meth.getName()), meth
-						.getParameterTypes(), meth.getExceptions());
+				NameMangler.interMethod(meth.getModifiers(), aspectType, meth.getDeclaringType(), meth.getName()),
+				meth.getParameterTypes(), meth.getExceptions());
 		rmi.setParameterNames(meth.getParameterNames());
 		rmi.setTypeVariables(meth.getTypeVariables());
 		return rmi;
@@ -556,8 +557,8 @@ public class AjcMemberMaker {
 		}
 
 		ResolvedMemberImpl rmi = new ResolvedMemberImpl(Member.METHOD, meth.getDeclaringType(), modifiers, meth.getReturnType(),
-				NameMangler.interMethod(meth.getModifiers(), aspectType, meth.getDeclaringType(), meth.getName()), meth
-						.getParameterTypes(), meth.getExceptions());
+				NameMangler.interMethod(meth.getModifiers(), aspectType, meth.getDeclaringType(), meth.getName()),
+				meth.getParameterTypes(), meth.getExceptions());
 		rmi.setTypeVariables(meth.getTypeVariables());
 		return rmi;
 	}
@@ -572,9 +573,9 @@ public class AjcMemberMaker {
 
 		int modifiers = makePublicNonFinal(meth.getModifiers());
 
-		ResolvedMemberImpl rmi = new ResolvedMemberImpl(Member.METHOD, aspectType, modifiers, meth.getReturnType(), NameMangler
-				.interMethod(meth.getModifiers(), aspectType, meth.getDeclaringType(), meth.getName()), meth.getParameterTypes(),
-				meth.getExceptions());
+		ResolvedMemberImpl rmi = new ResolvedMemberImpl(Member.METHOD, aspectType, modifiers, meth.getReturnType(),
+				NameMangler.interMethod(meth.getModifiers(), aspectType, meth.getDeclaringType(), meth.getName()),
+				meth.getParameterTypes(), meth.getExceptions());
 		rmi.setTypeVariables(meth.getTypeVariables());
 		return rmi;
 	}
@@ -589,8 +590,9 @@ public class AjcMemberMaker {
 			paramTypes = UnresolvedType.insert(meth.getDeclaringType(), paramTypes);
 		}
 
-		ResolvedMemberImpl rmi = new ResolvedMemberImpl(Member.METHOD, aspectType, PUBLIC_STATIC, meth.getReturnType(), NameMangler
-				.interMethodDispatcher(aspectType, meth.getDeclaringType(), meth.getName()), paramTypes, meth.getExceptions());
+		ResolvedMemberImpl rmi = new ResolvedMemberImpl(Member.METHOD, aspectType, PUBLIC_STATIC, meth.getReturnType(),
+				NameMangler.interMethodDispatcher(aspectType, meth.getDeclaringType(), meth.getName()), paramTypes,
+				meth.getExceptions());
 		rmi.setParameterNames(meth.getParameterNames());
 		rmi.setTypeVariables(meth.getTypeVariables());
 
@@ -611,8 +613,8 @@ public class AjcMemberMaker {
 			modifiers |= Modifier.STRICT;
 		}
 
-		ResolvedMemberImpl rmi = new ResolvedMemberImpl(Member.METHOD, aspectType, modifiers, meth.getReturnType(), NameMangler
-				.interMethodBody(aspectType, meth.getDeclaringType(), meth.getName()), paramTypes, meth.getExceptions());
+		ResolvedMemberImpl rmi = new ResolvedMemberImpl(Member.METHOD, aspectType, modifiers, meth.getReturnType(),
+				NameMangler.interMethodBody(aspectType, meth.getDeclaringType(), meth.getName()), paramTypes, meth.getExceptions());
 		rmi.setParameterNames(meth.getParameterNames());
 		rmi.setTypeVariables(meth.getTypeVariables());
 		return rmi;
@@ -197,7 +197,7 @@ public class CrosscuttingMembers {
 		}
 		addTypeMunger(world.getWeavingSupport().concreteTypeMunger(new ExposeTypeMunger(typeToExpose), inAspect));
 		// ResolvedMember member = new ResolvedMemberImpl(
-		// Member.STATIC_INITIALIZATION, typeToExpose, 0, ResolvedType.VOID,
+		// Member.STATIC_INITIALIZATION, typeToExpose, 0, UnresolvedType.VOID,
 		// "<clinit>", UnresolvedType.NONE);
 		// addTypeMunger(world.concreteTypeMunger(
 		// new PrivilegedAccessMunger(member), inAspect));
@@ -17,7 +17,7 @@ package org.aspectj.weaver;
 public class ExposeTypeMunger extends PrivilegedAccessMunger {
 
 	public ExposeTypeMunger(UnresolvedType typeToExpose) {
-		super(new ResolvedMemberImpl(Member.STATIC_INITIALIZATION, typeToExpose, 0, ResolvedType.VOID, "<clinit>",
+		super(new ResolvedMemberImpl(Member.STATIC_INITIALIZATION, typeToExpose, 0, UnresolvedType.VOID, "<clinit>",
 				UnresolvedType.NONE), false);
 	}
 
@@ -233,12 +233,12 @@ public class MemberImpl implements Member {
 	}
 
 	public static MemberImpl monitorEnter() {
-		return new MemberImpl(MONITORENTER, UnresolvedType.OBJECT, Modifier.STATIC, ResolvedType.VOID, "<lock>",
+		return new MemberImpl(MONITORENTER, UnresolvedType.OBJECT, Modifier.STATIC, UnresolvedType.VOID, "<lock>",
 				UnresolvedType.ARRAY_WITH_JUST_OBJECT);
 	}
 
 	public static MemberImpl monitorExit() {
-		return new MemberImpl(MONITOREXIT, UnresolvedType.OBJECT, Modifier.STATIC, ResolvedType.VOID, "<unlock>",
+		return new MemberImpl(MONITOREXIT, UnresolvedType.OBJECT, Modifier.STATIC, UnresolvedType.VOID, "<unlock>",
 				UnresolvedType.ARRAY_WITH_JUST_OBJECT);
 	}
 
@@ -23,7 +23,7 @@ public class ResolvedPointcutDefinition extends ResolvedMemberImpl {
 
 	public ResolvedPointcutDefinition(UnresolvedType declaringType, int modifiers, String name, UnresolvedType[] parameterTypes,
 			Pointcut pointcut) {
-		this(declaringType, modifiers, name, parameterTypes, ResolvedType.VOID, pointcut);
+		this(declaringType, modifiers, name, parameterTypes, UnresolvedType.VOID, pointcut);
 	}
 
 	/**
@@ -111,16 +111,16 @@ public class ResolvedPointcutDefinition extends ResolvedMemberImpl {
 				typeMap.put(typeVariables[i].getName(), ut);
 			}
 		}
-		UnresolvedType parameterizedReturnType = parameterize(getGenericReturnType(), typeMap, isParameterized, newDeclaringType
-				.getWorld());
+		UnresolvedType parameterizedReturnType = parameterize(getGenericReturnType(), typeMap, isParameterized,
+				newDeclaringType.getWorld());
 		UnresolvedType[] parameterizedParameterTypes = new UnresolvedType[getGenericParameterTypes().length];
 		for (int i = 0; i < parameterizedParameterTypes.length; i++) {
-			parameterizedParameterTypes[i] = parameterize(getGenericParameterTypes()[i], typeMap, isParameterized, newDeclaringType
-					.getWorld());
+			parameterizedParameterTypes[i] = parameterize(getGenericParameterTypes()[i], typeMap, isParameterized,
+					newDeclaringType.getWorld());
 		}
 		ResolvedPointcutDefinition ret = new ResolvedPointcutDefinition(newDeclaringType, getModifiers(), getName(),
-				parameterizedParameterTypes, parameterizedReturnType, pointcut.parameterizeWith(typeMap, newDeclaringType
-						.getWorld()));
+				parameterizedParameterTypes, parameterizedReturnType, pointcut.parameterizeWith(typeMap,
+						newDeclaringType.getWorld()));
 		ret.setTypeVariables(getTypeVariables());
 		ret.setSourceContext(getSourceContext());
 		ret.setPosition(getStart(), getEnd());
@@ -57,6 +57,8 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 	private static int MungersAnalyzed = 0x0004;
 	private static int HasParentMunger = 0x0008;
 	private static int TypeHierarchyCompleteBit = 0x0010;
+	private static int GroovyObjectInitialized = 0x0020;
+	private static int IsGroovyObject = 0x0040;
 
 	protected ResolvedType(String signature, World world) {
 		super(signature);
@@ -68,6 +70,10 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 		this.world = world;
 	}
 
+	public int getSize() {
+		return 1;
+	}
+
 	/**
 	 * Returns an iterator through ResolvedType objects representing all the direct supertypes of this type. That is, through the
 	 * superclass, if any, and all declared interfaces.
@@ -1014,33 +1020,8 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 	public static final ResolvedType[] NONE = new ResolvedType[0];
 	public static final ResolvedType[] EMPTY_ARRAY = NONE;
 
-	public static final Primitive BYTE = new Primitive("B", 1, 0);
-	public static final Primitive CHAR = new Primitive("C", 1, 1);
-	public static final Primitive DOUBLE = new Primitive("D", 2, 2);
-	public static final Primitive FLOAT = new Primitive("F", 1, 3);
-	public static final Primitive INT = new Primitive("I", 1, 4);
-	public static final Primitive LONG = new Primitive("J", 2, 5);
-	public static final Primitive SHORT = new Primitive("S", 1, 6);
-	public static final Primitive VOID = new Primitive("V", 0, 8);
-	public static final Primitive BOOLEAN = new Primitive("Z", 1, 7);
 	public static final Missing MISSING = new Missing();
 
-	/** Reset the static state in the primitive types */
-	// OPTIMIZE I think we have a bug here because primitives are static and the
-	// world they use may vary (or may even be
-	// null)
-	public static void resetPrimitives() {
-		BYTE.world = null;
-		CHAR.world = null;
-		DOUBLE.world = null;
-		FLOAT.world = null;
-		INT.world = null;
-		LONG.world = null;
-		SHORT.world = null;
-		VOID.world = null;
-		BOOLEAN.world = null;
-	}
-
 	// ---- types
 	public static ResolvedType makeArray(ResolvedType type, int dim) {
 		if (dim == 0) {
@@ -1113,6 +1094,9 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 
 		@Override
 		public ResolvedType resolve(World world) {
+			if (this.world != world) {
+				throw new IllegalStateException();
+			}
 			this.world = world;
 			return super.resolve(world);
 		}
@@ -2136,12 +2120,16 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 	private void interTypeConflictError(ConcreteTypeMunger m1, ConcreteTypeMunger m2) {
 		// XXX this works only if we ignore separate compilation issues
 		// XXX dual errors possible if (this instanceof BcelObjectType) return;
-
+		/*
+		 * if (m1.getMunger().getKind() == ResolvedTypeMunger.Field && m2.getMunger().getKind() == ResolvedTypeMunger.Field) { // if
+		 * *exactly* the same, it's ok return true; }
+		 */
 		// System.err.println("conflict at " + m2.getSourceLocation());
 		getWorld().showMessage(
 				IMessage.ERROR,
 				WeaverMessages.format(WeaverMessages.ITD_CONFLICT, m1.getAspectType().getName(), m2.getSignature(), m2
 						.getAspectType().getName()), m2.getSourceLocation(), getSourceLocation());
+		// return false;
 	}
 
 	public ResolvedMember lookupSyntheticMember(Member member) {
@@ -2159,7 +2147,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 		// Handling members for the new array join point
 		if (world.isJoinpointArrayConstructionEnabled() && this.isArray()) {
 			if (member.getKind() == Member.CONSTRUCTOR) {
-				ResolvedMemberImpl ret = new ResolvedMemberImpl(Member.CONSTRUCTOR, this, Modifier.PUBLIC, ResolvedType.VOID,
+				ResolvedMemberImpl ret = new ResolvedMemberImpl(Member.CONSTRUCTOR, this, Modifier.PUBLIC, UnresolvedType.VOID,
 						"<init>", world.resolve(member.getParameterTypes()));
 				// Give the parameters names - they are going to be the dimensions uses to build the array (dim0 > dimN)
 				int count = ret.getParameterTypes().length;
@@ -2777,4 +2765,31 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 	public boolean isPrimitiveArray() {
 		return false;
 	}
+
+	public boolean isGroovyObject() {
+		if ((bits & GroovyObjectInitialized) == 0) {
+			ResolvedType[] intfaces = getDeclaredInterfaces();
+			boolean done = false;
+			// TODO do we need to walk more of these? (i.e. the interfaces interfaces and supertypes supertype). Check what groovy
+			// does in the case where a hierarchy is involved and there are types in between GroovyObject/GroovyObjectSupport and
+			// the type
+			if (intfaces != null) {
+				for (ResolvedType intface : intfaces) {
+					if (intface.getName().equals("groovy.lang.GroovyObject")) {
+						bits |= IsGroovyObject;
+						done = true;
+						break;
+					}
+				}
+			}
+			if (!done) {
+				// take a look at the supertype
+				if (getSuperclass().getName().equals("groovy.lang.GroovyObjectSupport")) {
+					bits |= IsGroovyObject;
+				}
+			}
+			bits |= GroovyObjectInitialized;
+		}
+		return (bits & IsGroovyObject) != 0;
+	}
 }
@@ -160,12 +160,13 @@ public abstract class Shadow {
 				dims += (s.charAt(pos) == '[' ? 1 : 0);
 			}
 		}
+		ResolvedType intType = UnresolvedType.INT.resolve(this.getIWorld());
 		if (dims == 1) {
-			return new ResolvedType[] { ResolvedType.INT };
+			return new ResolvedType[] { intType };
 		}
 		ResolvedType[] someInts = new ResolvedType[dims];
 		for (int i = 0; i < dims; i++) {
-			someInts[i] = ResolvedType.INT;
+			someInts[i] = intType;
 		}
 		return someInts;
 	}
@@ -220,6 +221,8 @@ public abstract class Shadow {
 
 	public abstract Var getThisEnclosingJoinPointStaticPartVar();
 
+	public abstract Var getThisAspectInstanceVar(ResolvedType aspectType);
+
 	// annotation variables
 	public abstract Var getKindedAnnotationVar(UnresolvedType forAnnotationType);
 
@@ -275,9 +278,9 @@ public abstract class Shadow {
 		if (kind == ConstructorCall) {
 			return getSignature().getDeclaringType();
 		} else if (kind == FieldSet) {
-			return ResolvedType.VOID;
+			return UnresolvedType.VOID;
 		} else if (kind == SynchronizationLock || kind == SynchronizationUnlock) {
-			return ResolvedType.VOID;
+			return UnresolvedType.VOID;
 		}
 		return getResolvedSignature().getGenericReturnType();
 	}
@@ -550,7 +553,7 @@ public abstract class Shadow {
 
 		// Bunch of code to work out whether to report xlints for advice that isn't ordered at this Joinpoint
 		possiblyReportUnorderedAdvice(sorted);
- 
+
 		if (sorted == null) {
 			// this means that we have circular dependencies
 			for (ShadowMunger m : mungers) {
@@ -625,7 +628,7 @@ public abstract class Shadow {
 	/** Actually implement the (non-empty) mungers associated with this shadow */
 	private void implementMungers() {
 		World world = getIWorld();
-		for (ShadowMunger munger: mungers) {
+		for (ShadowMunger munger : mungers) {
 			if (munger.implementOn(this)) {
 				world.reportMatch(munger, this);
 			}
@@ -140,7 +140,7 @@ public class TypeFactory {
 					s.append(typeParameter.getSignature());
 				}
 				s.append(">;");
-				signature = s.toString();//'P' + signature.substring(1);
+				signature = s.toString();// 'P' + signature.substring(1);
 				return new UnresolvedType(signature, signatureErasure, typeParams);
 			}
 			// can't replace above with convertSigToType - leads to stackoverflow
@@ -173,23 +173,23 @@ public class TypeFactory {
 			switch (firstChar) {
 
 			case 'V':
-				return ResolvedType.VOID;
+				return UnresolvedType.VOID;
 			case 'Z':
-				return ResolvedType.BOOLEAN;
+				return UnresolvedType.BOOLEAN;
 			case 'B':
-				return ResolvedType.BYTE;
+				return UnresolvedType.BYTE;
 			case 'C':
-				return ResolvedType.CHAR;
+				return UnresolvedType.CHAR;
 			case 'D':
-				return ResolvedType.DOUBLE;
+				return UnresolvedType.DOUBLE;
 			case 'F':
-				return ResolvedType.FLOAT;
+				return UnresolvedType.FLOAT;
 			case 'I':
-				return ResolvedType.INT;
+				return UnresolvedType.INT;
 			case 'J':
-				return ResolvedType.LONG;
+				return UnresolvedType.LONG;
 			case 'S':
-				return ResolvedType.SHORT;
+				return UnresolvedType.SHORT;
 			}
 		} else if (firstChar == '@') {
 			// missing type
@@ -238,7 +238,7 @@ public class TypeFactory {
 					s.append(typeParameter.getSignature());
 				}
 				s.append(">;");
-				signature = s.toString();//'P' + signature.substring(1);
+				signature = s.toString();// 'P' + signature.substring(1);
 				return new UnresolvedType(signature, signatureErasure, typeParams);
 			}
 
@@ -62,6 +62,16 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 	public static final UnresolvedType JOINPOINT_STATICPART = forSignature("Lorg/aspectj/lang/JoinPoint$StaticPart;");
 	public static final UnresolvedType JOINPOINT_ENCLOSINGSTATICPART = forSignature("Lorg/aspectj/lang/JoinPoint$EnclosingStaticPart;");
 
+	public static final UnresolvedType BOOLEAN = forPrimitiveType("Z");
+	public static final UnresolvedType BYTE = forPrimitiveType("B");
+	public static final UnresolvedType CHAR = forPrimitiveType("C");
+	public static final UnresolvedType DOUBLE = forPrimitiveType("D");
+	public static final UnresolvedType FLOAT = forPrimitiveType("F");
+	public static final UnresolvedType INT = forPrimitiveType("I");
+	public static final UnresolvedType LONG = forPrimitiveType("J");
+	public static final UnresolvedType SHORT = forPrimitiveType("S");
+	public static final UnresolvedType VOID = forPrimitiveType("V");
+
 	// A type is considered missing if we have a signature for it but cannot find the delegate
 	public static final String MISSING_NAME = "@missing@";
 
@@ -196,9 +206,11 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 	 * This is the size of this type as used in JVM.
 	 */
 	public int getSize() {
-		return 1;
+		return size;
 	}
 
+	private int size = 1;
+
 	/**
 	 * NOTE: Use forSignature() if you can, it'll be cheaper ! Constructs a UnresolvedType for a java language type name. For
 	 * example:
@@ -301,6 +313,17 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 		return ret;
 	}
 
+	public static UnresolvedType forPrimitiveType(String signature) {
+		UnresolvedType ret = new UnresolvedType(signature);
+		ret.typeKind = TypeKind.PRIMITIVE;
+		if (signature.equals("J") || signature.equals("D")) {
+			ret.size = 2;
+		} else if (signature.equals("V")) {
+			ret.size = 0;
+		}
+		return ret;
+	}
+
 	/**
 	 * Creates a new type array with a fresh type appended to the end.
 	 * 
@@ -360,27 +383,27 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 		assert !(signature.startsWith("L") && signature.indexOf("<") != -1);
 		switch (signature.charAt(0)) {
 		case 'B':
-			return ResolvedType.BYTE;
+			return UnresolvedType.BYTE;
 		case 'C':
-			return ResolvedType.CHAR;
+			return UnresolvedType.CHAR;
 		case 'D':
-			return ResolvedType.DOUBLE;
+			return UnresolvedType.DOUBLE;
 		case 'F':
-			return ResolvedType.FLOAT;
+			return UnresolvedType.FLOAT;
 		case 'I':
-			return ResolvedType.INT;
+			return UnresolvedType.INT;
 		case 'J':
-			return ResolvedType.LONG;
+			return UnresolvedType.LONG;
 		case 'L':
 			return TypeFactory.createTypeFromSignature(signature);
 		case 'P':
 			return TypeFactory.createTypeFromSignature(signature);
 		case 'S':
-			return ResolvedType.SHORT;
+			return UnresolvedType.SHORT;
 		case 'V':
-			return ResolvedType.VOID;
+			return UnresolvedType.VOID;
 		case 'Z':
-			return ResolvedType.BOOLEAN;
+			return UnresolvedType.BOOLEAN;
 		case '[':
 			return TypeFactory.createTypeFromSignature(signature);
 		case '+':
@@ -37,6 +37,7 @@ import org.aspectj.bridge.Message;
 import org.aspectj.bridge.MessageUtil;
 import org.aspectj.bridge.context.PinpointingMessageHandler;
 import org.aspectj.util.IStructureModel;
+import org.aspectj.weaver.ResolvedType.Primitive;
 import org.aspectj.weaver.UnresolvedType.TypeKind;
 import org.aspectj.weaver.patterns.Declare;
 import org.aspectj.weaver.patterns.DeclareAnnotation;
@@ -177,28 +178,32 @@ public abstract class World implements Dump.INode {
 		}
 	}
 
+	public final Primitive BYTE = new Primitive("B", 1, 0);
+	public final Primitive CHAR = new Primitive("C", 1, 1);
+	public final Primitive DOUBLE = new Primitive("D", 2, 2);
+	public final Primitive FLOAT = new Primitive("F", 1, 3);
+	public final Primitive INT = new Primitive("I", 1, 4);
+	public final Primitive LONG = new Primitive("J", 2, 5);
+	public final Primitive SHORT = new Primitive("S", 1, 6);
+	public final Primitive BOOLEAN = new Primitive("Z", 1, 7);
+	public final Primitive VOID = new Primitive("V", 0, 8);
+
 	/**
-	 * Play God. On the first day, God created the primitive types and put them in the type map.
+	 * Insert the primitives
 	 */
 	protected World() {
 		super();
-		if (trace.isTraceEnabled()) {
-			trace.enter("<init>", this);
-		}
 		// Dump.registerNode(this.getClass(), this);
-		typeMap.put("B", ResolvedType.BYTE);
-		typeMap.put("S", ResolvedType.SHORT);
-		typeMap.put("I", ResolvedType.INT);
-		typeMap.put("J", ResolvedType.LONG);
-		typeMap.put("F", ResolvedType.FLOAT);
-		typeMap.put("D", ResolvedType.DOUBLE);
-		typeMap.put("C", ResolvedType.CHAR);
-		typeMap.put("Z", ResolvedType.BOOLEAN);
-		typeMap.put("V", ResolvedType.VOID);
+		typeMap.put("B", BYTE);
+		typeMap.put("S", SHORT);
+		typeMap.put("I", INT);
+		typeMap.put("J", LONG);
+		typeMap.put("F", FLOAT);
+		typeMap.put("D", DOUBLE);
+		typeMap.put("C", CHAR);
+		typeMap.put("Z", BOOLEAN);
+		typeMap.put("V", VOID);
 		precedenceCalculator = new AspectPrecedenceCalculator(this);
-		if (trace.isTraceEnabled()) {
-			trace.exit("<init>");
-		}
 	}
 
 	/**
@@ -221,10 +226,8 @@ public abstract class World implements Dump.INode {
 	}
 
 	// ==========================================================================
-	// ===
 	// T Y P E R E S O L U T I O N
 	// ==========================================================================
-	// ===
 
 	/**
 	 * Resolve a type that we require to be present in the world
@@ -1975,7 +1978,7 @@ public abstract class World implements Dump.INode {
 	}
 
 	public static void reset() {
-		ResolvedType.resetPrimitives();
+		// ResolvedType.resetPrimitives();
 	}
 
 	/**
@@ -129,8 +129,8 @@ public class ConcreteCflowPointcut extends Pointcut {
 				for (Iterator i = slots.iterator(); i.hasNext();) {
 					Slot slot = (Slot) i.next();
 					// System.out.println("slot: " + slot.formalIndex);
-					state.set(slot.formalIndex, aspect.getWorld().getWeavingSupport().makeCflowAccessVar(slot.formalType,
-							cflowField, slot.arrayIndex));
+					state.set(slot.formalIndex,
+							aspect.getWorld().getWeavingSupport().makeCflowAccessVar(slot.formalType, cflowField, slot.arrayIndex));
 				}
 			}
 			return Test.makeFieldGetCall(cflowField, cflowStackIsValidMethod, Expr.NONE);
@@ -138,10 +138,10 @@ public class ConcreteCflowPointcut extends Pointcut {
 	}
 
 	private static final Member cflowStackIsValidMethod = MemberImpl.method(NameMangler.CFLOW_STACK_UNRESOLVEDTYPE, 0,
-			ResolvedType.BOOLEAN, "isValid", UnresolvedType.NONE);
+			UnresolvedType.BOOLEAN, "isValid", UnresolvedType.NONE);
 
 	private static final Member cflowCounterIsValidMethod = MemberImpl.method(NameMangler.CFLOW_COUNTER_UNRESOLVEDTYPE, 0,
-			ResolvedType.BOOLEAN, "isValid", UnresolvedType.NONE);
+			UnresolvedType.BOOLEAN, "isValid", UnresolvedType.NONE);
 
 	public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, IntMap bindings) {
 		throw new RuntimeException("unimplemented");
@@ -26,6 +26,7 @@ public class ExposedState {
 	private boolean[] erroneousVars;
 	private Expr aspectInstance;
 	private UnresolvedType[] expectedVarTypes; // enables us to check that binding is occurring with the *right* types
+	private ResolvedType concreteAspect;
 
 	public ExposedState(int size) {
 		super();
@@ -105,4 +106,12 @@ public class ExposedState {
 	public boolean isErroneousVar(int formalIndex) {
 		return erroneousVars[formalIndex];
 	}
+
+	public void setConcreteAspect(ResolvedType concreteAspect) {
+		this.concreteAspect = concreteAspect;
+	}
+
+	public ResolvedType getConcreteAspect() {
+		return this.concreteAspect;
+	}
 }
@@ -191,7 +191,7 @@ public class IfPointcut extends Pointcut {
 			}
 
 			Test ret = Literal.TRUE;
-			List args = new ArrayList();
+			List<Var> args = new ArrayList<Var>();
 
 			// code style
 			if (extraParameterFlags >= 0) {
@@ -214,6 +214,7 @@ public class IfPointcut extends Pointcut {
 				// If there are no args to sort out, don't bother with the recursive call
 				if (baseArgsCount > 0) {
 					ExposedState myState = new ExposedState(baseArgsCount);
+					myState.setConcreteAspect(state.getConcreteAspect());
 					// ??? we throw out the test that comes from this walk. All we want here
 					// is bindings for the arguments
 					residueSource.findResidue(shadow, myState);
@@ -251,6 +252,10 @@ public class IfPointcut extends Pointcut {
 				if ((extraParameterFlags & Advice.ThisEnclosingJoinPointStaticPart) != 0) {
 					args.add(shadow.getThisEnclosingJoinPointStaticPartVar());
 				}
+
+				if ((extraParameterFlags & Advice.ThisAspectInstance) != 0) {
+					args.add(shadow.getThisAspectInstanceVar(state.getConcreteAspect()));
+				}
 			} else {
 				// @style is slightly different
 				int currentStateIndex = 0;
@@ -272,16 +277,20 @@ public class IfPointcut extends Pointcut {
 							if (paramNames != null) {
 								errorParameter.append(testMethod.getParameterTypes()[i].getName()).append(" ");
 								errorParameter.append(paramNames[i]);
-								shadow.getIWorld().getMessageHandler().handleMessage(
-										MessageUtil.error("Missing binding for if() pointcut method.  Parameter " + (i + 1) + "("
-												+ errorParameter.toString()
-												+ ") must be bound - even in reference pointcuts  (compiler limitation)",
-												testMethod.getSourceLocation()));
+								shadow.getIWorld()
+										.getMessageHandler()
+										.handleMessage(
+												MessageUtil.error("Missing binding for if() pointcut method.  Parameter " + (i + 1)
+														+ "(" + errorParameter.toString()
+														+ ") must be bound - even in reference pointcuts  (compiler limitation)",
+														testMethod.getSourceLocation()));
 							} else {
-								shadow.getIWorld().getMessageHandler().handleMessage(
-										MessageUtil.error("Missing binding for if() pointcut method.  Parameter " + (i + 1)
-												+ " must be bound - even in reference pointcuts (compiler limitation)", testMethod
-												.getSourceLocation()));
+								shadow.getIWorld()
+										.getMessageHandler()
+										.handleMessage(
+												MessageUtil.error("Missing binding for if() pointcut method.  Parameter " + (i + 1)
+														+ " must be bound - even in reference pointcuts (compiler limitation)",
+														testMethod.getSourceLocation()));
 							}
 							return Literal.TRUE; // exit quickly
 						}
@@ -293,8 +302,8 @@ public class IfPointcut extends Pointcut {
 						}
 						args.add(v);
 
-						ret = Test.makeAnd(ret, Test.makeInstanceof(v, testMethod.getParameterTypes()[i]
-								.resolve(shadow.getIWorld())));
+						ret = Test.makeAnd(ret,
+								Test.makeInstanceof(v, testMethod.getParameterTypes()[i].resolve(shadow.getIWorld())));
 					}
 				}
 			}
@@ -279,14 +279,14 @@ public class KindedPointcut extends Pointcut {
 			return;
 		}
 
-		SignaturePattern nonConfusingPattern = new SignaturePattern(signature.getKind(), signature.getModifiers(), signature
-				.getReturnType(), TypePattern.ANY, signature.getName(), signature.getParameterTypes(),
+		SignaturePattern nonConfusingPattern = new SignaturePattern(signature.getKind(), signature.getModifiers(),
+				signature.getReturnType(), TypePattern.ANY, signature.getName(), signature.getParameterTypes(),
 				signature.getThrowsPattern(), signature.getAnnotationPattern());
 
 		if (nonConfusingPattern.matches(shadow.getSignature(), shadow.getIWorld(), true)) {
 			shadow.getIWorld().getLint().unmatchedSuperTypeInCall.signal(new String[] {
-					shadow.getSignature().getDeclaringType().toString(), signature.getDeclaringType().toString() }, this
-					.getSourceLocation(), new ISourceLocation[] { shadow.getSourceLocation() });
+					shadow.getSignature().getDeclaringType().toString(), signature.getDeclaringType().toString() },
+					this.getSourceLocation(), new ISourceLocation[] { shadow.getSourceLocation() });
 		}
 	}
 
@@ -384,7 +384,7 @@ public class KindedPointcut extends Pointcut {
 
 			// fields can't have a void type!
 			UnresolvedType returnType = signature.getReturnType().getExactType();
-			if (returnType == ResolvedType.VOID) {
+			if (returnType.equals(UnresolvedType.VOID)) {
 				scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.FIELDS_CANT_HAVE_VOID_TYPE),
 						getSourceLocation()));
 			}
@@ -413,8 +413,9 @@ public class KindedPointcut extends Pointcut {
 			HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
 			signature.getDeclaringType().traverse(visitor, null);
 			if (visitor.wellHasItThen/* ? */()) {
-				scope.message(MessageUtil.error(WeaverMessages
-						.format(WeaverMessages.EXECUTION_DOESNT_SUPPORT_PARAMETERIZED_DECLARING_TYPES), getSourceLocation()));
+				scope.message(MessageUtil.error(
+						WeaverMessages.format(WeaverMessages.EXECUTION_DOESNT_SUPPORT_PARAMETERIZED_DECLARING_TYPES),
+						getSourceLocation()));
 			}
 
 			visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
@@ -430,8 +431,9 @@ public class KindedPointcut extends Pointcut {
 			HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
 			signature.getDeclaringType().traverse(visitor, null);
 			if (visitor.wellHasItThen/* ? */()) {
-				scope.message(MessageUtil.error(WeaverMessages
-						.format(WeaverMessages.CALL_DOESNT_SUPPORT_PARAMETERIZED_DECLARING_TYPES), getSourceLocation()));
+				scope.message(MessageUtil.error(
+						WeaverMessages.format(WeaverMessages.CALL_DOESNT_SUPPORT_PARAMETERIZED_DECLARING_TYPES),
+						getSourceLocation()));
 			}
 
 			visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
@@ -55,31 +55,31 @@ public class SimpleScope implements IScope {
 			int len = name.length();
 			if (len == 3) {
 				if (name.equals("int")) {
-					return ResolvedType.INT;
+					return UnresolvedType.INT;
 				}
 			} else if (len == 4) {
 				if (name.equals("void")) {
-					return ResolvedType.VOID;
+					return UnresolvedType.VOID;
 				} else if (name.equals("byte")) {
-					return ResolvedType.BYTE;
+					return UnresolvedType.BYTE;
 				} else if (name.equals("char")) {
-					return ResolvedType.CHAR;
+					return UnresolvedType.CHAR;
 				} else if (name.equals("long")) {
-					return ResolvedType.LONG;
+					return UnresolvedType.LONG;
 				}
 			} else if (len == 5) {
 				if (name.equals("float")) {
-					return ResolvedType.FLOAT;
+					return UnresolvedType.FLOAT;
 				} else if (name.equals("short")) {
-					return ResolvedType.SHORT;
+					return UnresolvedType.SHORT;
 				}
 			} else if (len == 6) {
 				if (name.equals("double")) {
-					return ResolvedType.DOUBLE;
+					return UnresolvedType.DOUBLE;
 				}
 			} else if (len == 7) {
 				if (name.equals("boolean")) {
-					return ResolvedType.BOOLEAN;
+					return UnresolvedType.BOOLEAN;
 				}
 			}
 		}
@@ -127,8 +127,8 @@ public class ReflectionBasedReferenceTypeDelegateFactory {
 	public static ResolvedMember createResolvedMethod(Method aMethod, World inWorld) {
 		ReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.METHOD,
 				toResolvedType(aMethod.getDeclaringClass(), (IReflectionWorld) inWorld), aMethod.getModifiers(), toResolvedType(
-						aMethod.getReturnType(), (IReflectionWorld) inWorld), aMethod.getName(), toResolvedTypeArray(aMethod
-						.getParameterTypes(), inWorld), toResolvedTypeArray(aMethod.getExceptionTypes(), inWorld), aMethod);
+						aMethod.getReturnType(), (IReflectionWorld) inWorld), aMethod.getName(), toResolvedTypeArray(
+						aMethod.getParameterTypes(), inWorld), toResolvedTypeArray(aMethod.getExceptionTypes(), inWorld), aMethod);
 		if (inWorld instanceof IReflectionWorld) {
 			ret.setAnnotationFinder(((IReflectionWorld) inWorld).getAnnotationFinder());
 		}
@@ -139,8 +139,8 @@ public class ReflectionBasedReferenceTypeDelegateFactory {
 	public static ResolvedMember createResolvedAdviceMember(Method aMethod, World inWorld) {
 		ReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.ADVICE,
 				toResolvedType(aMethod.getDeclaringClass(), (IReflectionWorld) inWorld), aMethod.getModifiers(), toResolvedType(
-						aMethod.getReturnType(), (IReflectionWorld) inWorld), aMethod.getName(), toResolvedTypeArray(aMethod
-						.getParameterTypes(), inWorld), toResolvedTypeArray(aMethod.getExceptionTypes(), inWorld), aMethod);
+						aMethod.getReturnType(), (IReflectionWorld) inWorld), aMethod.getName(), toResolvedTypeArray(
+						aMethod.getParameterTypes(), inWorld), toResolvedTypeArray(aMethod.getExceptionTypes(), inWorld), aMethod);
 		if (inWorld instanceof IReflectionWorld) {
 			ret.setAnnotationFinder(((IReflectionWorld) inWorld).getAnnotationFinder());
 		}
@@ -150,7 +150,7 @@ public class ReflectionBasedReferenceTypeDelegateFactory {
 
 	public static ResolvedMember createStaticInitMember(Class forType, World inWorld) {
 		return new ResolvedMemberImpl(org.aspectj.weaver.Member.STATIC_INITIALIZATION, toResolvedType(forType,
-				(IReflectionWorld) inWorld), Modifier.STATIC, ResolvedType.VOID, "<clinit>", new UnresolvedType[0],
+				(IReflectionWorld) inWorld), Modifier.STATIC, UnresolvedType.VOID, "<clinit>", new UnresolvedType[0],
 				new UnresolvedType[0]);
 	}
 
@@ -158,9 +158,9 @@ public class ReflectionBasedReferenceTypeDelegateFactory {
 		ReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.CONSTRUCTOR,
 				toResolvedType(aConstructor.getDeclaringClass(), (IReflectionWorld) inWorld), aConstructor.getModifiers(),
 				// to return what BCEL returns, the return type for ctor is void
-				ResolvedType.VOID,// toResolvedType(aConstructor.getDeclaringClass(),(IReflectionWorld)inWorld),
-				"<init>", toResolvedTypeArray(aConstructor.getParameterTypes(), inWorld), toResolvedTypeArray(aConstructor
-						.getExceptionTypes(), inWorld), aConstructor);
+				UnresolvedType.VOID,// toResolvedType(aConstructor.getDeclaringClass(),(IReflectionWorld)inWorld),
+				"<init>", toResolvedTypeArray(aConstructor.getParameterTypes(), inWorld), toResolvedTypeArray(
+						aConstructor.getExceptionTypes(), inWorld), aConstructor);
 		if (inWorld instanceof IReflectionWorld) {
 			ret.setAnnotationFinder(((IReflectionWorld) inWorld).getAnnotationFinder());
 		}
@@ -29,7 +29,7 @@ import org.aspectj.weaver.tools.MatchingContext;
 
 /**
  * @author colyer
- *
+ * 
  */
 public class ReflectionShadow extends Shadow {
 
@@ -47,94 +47,99 @@ public class ReflectionShadow extends Shadow {
 	private Map withinCodeAnnotationVar = new HashMap();
 	private Map annotationVar = new HashMap();
 	private AnnotationFinder annotationFinder;
-	
+
 	public static Shadow makeExecutionShadow(World inWorld, java.lang.reflect.Member forMethod, MatchingContext withContext) {
 		Kind kind = (forMethod instanceof Method) ? Shadow.MethodExecution : Shadow.ConstructorExecution;
 		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(forMethod, inWorld);
 		ResolvedType enclosingType = signature.getDeclaringType().resolve(inWorld);
-		return new ReflectionShadow(inWorld,kind,signature,null,enclosingType,null,withContext);
+		return new ReflectionShadow(inWorld, kind, signature, null, enclosingType, null, withContext);
 	}
-	
+
 	public static Shadow makeAdviceExecutionShadow(World inWorld, java.lang.reflect.Method forMethod, MatchingContext withContext) {
 		Kind kind = Shadow.AdviceExecution;
 		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createResolvedAdviceMember(forMethod, inWorld);
 		ResolvedType enclosingType = signature.getDeclaringType().resolve(inWorld);
-		return new ReflectionShadow(inWorld,kind,signature,null,enclosingType,null,withContext);
+		return new ReflectionShadow(inWorld, kind, signature, null, enclosingType, null, withContext);
 	}
-	
-	public static Shadow makeCallShadow(World inWorld, java.lang.reflect.Member aMember, java.lang.reflect.Member withinCode, MatchingContext withContext) {
-		Shadow enclosingShadow = makeExecutionShadow(inWorld,withinCode,withContext);
+
+	public static Shadow makeCallShadow(World inWorld, java.lang.reflect.Member aMember, java.lang.reflect.Member withinCode,
+			MatchingContext withContext) {
+		Shadow enclosingShadow = makeExecutionShadow(inWorld, withinCode, withContext);
 		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(aMember, inWorld);
 		ResolvedMember enclosingMember = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(withinCode, inWorld);
 		ResolvedType enclosingType = enclosingMember.getDeclaringType().resolve(inWorld);
 		Kind kind = aMember instanceof Method ? Shadow.MethodCall : Shadow.ConstructorCall;
-		return new ReflectionShadow(inWorld,kind,signature,enclosingShadow,enclosingType,enclosingMember,withContext);
+		return new ReflectionShadow(inWorld, kind, signature, enclosingShadow, enclosingType, enclosingMember, withContext);
 	}
 
-	public static Shadow makeCallShadow(World inWorld, java.lang.reflect.Member aMember, Class thisClass, MatchingContext withContext) {
-		Shadow enclosingShadow = makeStaticInitializationShadow(inWorld, thisClass,withContext);
+	public static Shadow makeCallShadow(World inWorld, java.lang.reflect.Member aMember, Class thisClass,
+			MatchingContext withContext) {
+		Shadow enclosingShadow = makeStaticInitializationShadow(inWorld, thisClass, withContext);
 		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(aMember, inWorld);
 		ResolvedMember enclosingMember = ReflectionBasedReferenceTypeDelegateFactory.createStaticInitMember(thisClass, inWorld);
 		ResolvedType enclosingType = enclosingMember.getDeclaringType().resolve(inWorld);
 		Kind kind = aMember instanceof Method ? Shadow.MethodCall : Shadow.ConstructorCall;
-		return new ReflectionShadow(inWorld,kind,signature,enclosingShadow,enclosingType,enclosingMember,withContext);
+		return new ReflectionShadow(inWorld, kind, signature, enclosingShadow, enclosingType, enclosingMember, withContext);
 	}
 
 	public static Shadow makeStaticInitializationShadow(World inWorld, Class forType, MatchingContext withContext) {
 		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createStaticInitMember(forType, inWorld);
 		ResolvedType enclosingType = signature.getDeclaringType().resolve(inWorld);
 		Kind kind = Shadow.StaticInitialization;
-		return new ReflectionShadow(inWorld,kind,signature,null,enclosingType,null,withContext);
+		return new ReflectionShadow(inWorld, kind, signature, null, enclosingType, null, withContext);
 	}
-	
+
 	public static Shadow makePreInitializationShadow(World inWorld, Constructor forConstructor, MatchingContext withContext) {
-		Kind kind =  Shadow.PreInitialization;
+		Kind kind = Shadow.PreInitialization;
 		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(forConstructor, inWorld);
 		ResolvedType enclosingType = signature.getDeclaringType().resolve(inWorld);
-		return new ReflectionShadow(inWorld,kind,signature,null,enclosingType,null,withContext);
+		return new ReflectionShadow(inWorld, kind, signature, null, enclosingType, null, withContext);
 	}
-	
+
 	public static Shadow makeInitializationShadow(World inWorld, Constructor forConstructor, MatchingContext withContext) {
-		Kind kind =  Shadow.Initialization;
+		Kind kind = Shadow.Initialization;
 		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(forConstructor, inWorld);
 		ResolvedType enclosingType = signature.getDeclaringType().resolve(inWorld);
-		return new ReflectionShadow(inWorld,kind,signature,null,enclosingType,null,withContext);
+		return new ReflectionShadow(inWorld, kind, signature, null, enclosingType, null, withContext);
 	}
-	
+
 	public static Shadow makeHandlerShadow(World inWorld, Class exceptionType, Class withinType, MatchingContext withContext) {
 		Kind kind = Shadow.ExceptionHandler;
-		Shadow enclosingShadow = makeStaticInitializationShadow(inWorld, withinType,withContext);
+		Shadow enclosingShadow = makeStaticInitializationShadow(inWorld, withinType, withContext);
 		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createHandlerMember(exceptionType, withinType, inWorld);
 		ResolvedMember enclosingMember = ReflectionBasedReferenceTypeDelegateFactory.createStaticInitMember(withinType, inWorld);
 		ResolvedType enclosingType = enclosingMember.getDeclaringType().resolve(inWorld);
-		return new ReflectionShadow(inWorld,kind,signature,enclosingShadow,enclosingType,enclosingMember,withContext);	
+		return new ReflectionShadow(inWorld, kind, signature, enclosingShadow, enclosingType, enclosingMember, withContext);
 	}
-	
-	public static Shadow makeHandlerShadow(World inWorld, Class exceptionType, java.lang.reflect.Member withinCode, MatchingContext withContext) {
+
+	public static Shadow makeHandlerShadow(World inWorld, Class exceptionType, java.lang.reflect.Member withinCode,
+			MatchingContext withContext) {
 		Kind kind = Shadow.ExceptionHandler;
-		Shadow enclosingShadow = makeExecutionShadow(inWorld, withinCode,withContext);
-		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createHandlerMember(exceptionType, withinCode.getDeclaringClass(), inWorld);
+		Shadow enclosingShadow = makeExecutionShadow(inWorld, withinCode, withContext);
+		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createHandlerMember(exceptionType,
+				withinCode.getDeclaringClass(), inWorld);
 		ResolvedMember enclosingMember = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(withinCode, inWorld);
 		ResolvedType enclosingType = enclosingMember.getDeclaringType().resolve(inWorld);
-		return new ReflectionShadow(inWorld,kind,signature,enclosingShadow,enclosingType,enclosingMember,withContext);	
+		return new ReflectionShadow(inWorld, kind, signature, enclosingShadow, enclosingType, enclosingMember, withContext);
 	}
-	
+
 	public static Shadow makeFieldGetShadow(World inWorld, Field forField, Class callerType, MatchingContext withContext) {
-		Shadow enclosingShadow = makeStaticInitializationShadow(inWorld, callerType,withContext);
+		Shadow enclosingShadow = makeStaticInitializationShadow(inWorld, callerType, withContext);
 		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createResolvedField(forField, inWorld);
 		ResolvedMember enclosingMember = ReflectionBasedReferenceTypeDelegateFactory.createStaticInitMember(callerType, inWorld);
 		ResolvedType enclosingType = enclosingMember.getDeclaringType().resolve(inWorld);
 		Kind kind = Shadow.FieldGet;
-		return new ReflectionShadow(inWorld,kind,signature,enclosingShadow,enclosingType,enclosingMember,withContext);
+		return new ReflectionShadow(inWorld, kind, signature, enclosingShadow, enclosingType, enclosingMember, withContext);
 	}
-	
-	public static Shadow makeFieldGetShadow(World inWorld, Field forField, java.lang.reflect.Member inMember, MatchingContext withContext) {
-		Shadow enclosingShadow = makeExecutionShadow(inWorld,inMember,withContext);
+
+	public static Shadow makeFieldGetShadow(World inWorld, Field forField, java.lang.reflect.Member inMember,
+			MatchingContext withContext) {
+		Shadow enclosingShadow = makeExecutionShadow(inWorld, inMember, withContext);
 		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createResolvedField(forField, inWorld);
 		ResolvedMember enclosingMember = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(inMember, inWorld);
 		ResolvedType enclosingType = enclosingMember.getDeclaringType().resolve(inWorld);
 		Kind kind = Shadow.FieldGet;
-		return new ReflectionShadow(inWorld,kind,signature,enclosingShadow,enclosingType,enclosingMember,withContext);
+		return new ReflectionShadow(inWorld, kind, signature, enclosingShadow, enclosingType, enclosingMember, withContext);
 	}
 
 	public static Shadow makeFieldSetShadow(World inWorld, Field forField, Class callerType, MatchingContext withContext) {
@@ -143,71 +148,83 @@ public class ReflectionShadow extends Shadow {
 		ResolvedMember enclosingMember = ReflectionBasedReferenceTypeDelegateFactory.createStaticInitMember(callerType, inWorld);
 		ResolvedType enclosingType = enclosingMember.getDeclaringType().resolve(inWorld);
 		Kind kind = Shadow.FieldSet;
-		return new ReflectionShadow(inWorld,kind,signature,enclosingShadow,enclosingType,enclosingMember,withContext);
+		return new ReflectionShadow(inWorld, kind, signature, enclosingShadow, enclosingType, enclosingMember, withContext);
 	}
 
-	public static Shadow makeFieldSetShadow(World inWorld, Field forField, java.lang.reflect.Member inMember, MatchingContext withContext) {
-		Shadow enclosingShadow = makeExecutionShadow(inWorld,inMember,withContext);
+	public static Shadow makeFieldSetShadow(World inWorld, Field forField, java.lang.reflect.Member inMember,
+			MatchingContext withContext) {
+		Shadow enclosingShadow = makeExecutionShadow(inWorld, inMember, withContext);
 		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createResolvedField(forField, inWorld);
 		ResolvedMember enclosingMember = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(inMember, inWorld);
 		ResolvedType enclosingType = enclosingMember.getDeclaringType().resolve(inWorld);
 		Kind kind = Shadow.FieldSet;
-		return new ReflectionShadow(inWorld,kind,signature,enclosingShadow,enclosingType,enclosingMember,withContext);
+		return new ReflectionShadow(inWorld, kind, signature, enclosingShadow, enclosingType, enclosingMember, withContext);
 	}
 
-	public ReflectionShadow(World world, Kind kind, Member signature, Shadow enclosingShadow, ResolvedType enclosingType, ResolvedMember enclosingMember, MatchingContext withContext) {
-		super(kind,signature,enclosingShadow);
+	public ReflectionShadow(World world, Kind kind, Member signature, Shadow enclosingShadow, ResolvedType enclosingType,
+			ResolvedMember enclosingMember, MatchingContext withContext) {
+		super(kind, signature, enclosingShadow);
 		this.world = world;
 		this.enclosingType = enclosingType;
 		this.enclosingMember = enclosingMember;
 		this.matchContext = withContext;
 		if (world instanceof IReflectionWorld) {
-			this.annotationFinder = ((IReflectionWorld)world).getAnnotationFinder();
+			this.annotationFinder = ((IReflectionWorld) world).getAnnotationFinder();
 		}
 	}
-	
-	/* (non-Javadoc)
+
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getIWorld()
 	 */
 	public World getIWorld() {
 		return world;
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getThisVar()
 	 */
 	public Var getThisVar() {
 		if (thisVar == null && hasThis()) {
-			thisVar = ReflectionVar.createThisVar(getThisType().resolve(world),this.annotationFinder);
+			thisVar = ReflectionVar.createThisVar(getThisType().resolve(world), this.annotationFinder);
 		}
 		return thisVar;
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getTargetVar()
 	 */
 	public Var getTargetVar() {
 		if (targetVar == null && hasTarget()) {
-			targetVar = ReflectionVar.createTargetVar(getThisType().resolve(world),this.annotationFinder);
+			targetVar = ReflectionVar.createTargetVar(getThisType().resolve(world), this.annotationFinder);
 		}
 		return targetVar;
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getEnclosingType()
 	 */
 	public UnresolvedType getEnclosingType() {
 		return this.enclosingType;
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getArgVar(int)
 	 */
 	public Var getArgVar(int i) {
 		if (argsVars == null) {
 			this.argsVars = new Var[this.getArgCount()];
 			for (int j = 0; j < this.argsVars.length; j++) {
-				this.argsVars[j] = ReflectionVar.createArgsVar(getArgType(j).resolve(world), j,this.annotationFinder);
+				this.argsVars[j] = ReflectionVar.createArgsVar(getArgType(j).resolve(world), j, this.annotationFinder);
 			}
 		}
 		if (i < argsVars.length) {
@@ -217,122 +234,126 @@ public class ReflectionShadow extends Shadow {
 		}
 	}
 
-	/* (non-Javadoc)
-	 * @see org.aspectj.weaver.Shadow#getThisJoinPointVar()
-	 */
 	public Var getThisJoinPointVar() {
-		// TODO Auto-generated method stub
 		return null;
 	}
 
-	/* (non-Javadoc)
-	 * @see org.aspectj.weaver.Shadow#getThisJoinPointStaticPartVar()
-	 */
 	public Var getThisJoinPointStaticPartVar() {
-		// TODO Auto-generated method stub
 		return null;
 	}
 
-	/* (non-Javadoc)
-	 * @see org.aspectj.weaver.Shadow#getThisEnclosingJoinPointStaticPartVar()
-	 */
 	public Var getThisEnclosingJoinPointStaticPartVar() {
-		// TODO Auto-generated method stub
 		return null;
 	}
 
-	/* (non-Javadoc)
-	 * @see org.aspectj.weaver.Shadow#getKindedAnnotationVar(org.aspectj.weaver.UnresolvedType)
-	 */
+	public Var getThisAspectInstanceVar(ResolvedType aspectType) {
+		return null;
+	}
+
 	public Var getKindedAnnotationVar(UnresolvedType forAnnotationType) {
 		ResolvedType annType = forAnnotationType.resolve(world);
 		if (annotationVar.get(annType) == null) {
-			Var v = ReflectionVar.createAtAnnotationVar(annType,this.annotationFinder);
-			annotationVar.put(annType,v);
+			Var v = ReflectionVar.createAtAnnotationVar(annType, this.annotationFinder);
+			annotationVar.put(annType, v);
 		}
 		return (Var) annotationVar.get(annType);
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getWithinAnnotationVar(org.aspectj.weaver.UnresolvedType)
 	 */
 	public Var getWithinAnnotationVar(UnresolvedType forAnnotationType) {
 		ResolvedType annType = forAnnotationType.resolve(world);
 		if (withinAnnotationVar.get(annType) == null) {
-			Var v = ReflectionVar.createWithinAnnotationVar(annType,this.annotationFinder);
-			withinAnnotationVar.put(annType,v);
+			Var v = ReflectionVar.createWithinAnnotationVar(annType, this.annotationFinder);
+			withinAnnotationVar.put(annType, v);
 		}
 		return (Var) withinAnnotationVar.get(annType);
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getWithinCodeAnnotationVar(org.aspectj.weaver.UnresolvedType)
 	 */
 	public Var getWithinCodeAnnotationVar(UnresolvedType forAnnotationType) {
 		ResolvedType annType = forAnnotationType.resolve(world);
 		if (withinCodeAnnotationVar.get(annType) == null) {
-			Var v = ReflectionVar.createWithinCodeAnnotationVar(annType,this.annotationFinder);
-			withinCodeAnnotationVar.put(annType,v);
+			Var v = ReflectionVar.createWithinCodeAnnotationVar(annType, this.annotationFinder);
+			withinCodeAnnotationVar.put(annType, v);
 		}
 		return (Var) withinCodeAnnotationVar.get(annType);
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getThisAnnotationVar(org.aspectj.weaver.UnresolvedType)
 	 */
 	public Var getThisAnnotationVar(UnresolvedType forAnnotationType) {
 		if (atThisVar == null) {
-			atThisVar = ReflectionVar.createThisAnnotationVar(forAnnotationType.resolve(world),this.annotationFinder);
+			atThisVar = ReflectionVar.createThisAnnotationVar(forAnnotationType.resolve(world), this.annotationFinder);
 		}
 		return atThisVar;
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getTargetAnnotationVar(org.aspectj.weaver.UnresolvedType)
 	 */
 	public Var getTargetAnnotationVar(UnresolvedType forAnnotationType) {
 		if (atTargetVar == null) {
-			atTargetVar = ReflectionVar.createTargetAnnotationVar(forAnnotationType.resolve(world),this.annotationFinder);
+			atTargetVar = ReflectionVar.createTargetAnnotationVar(forAnnotationType.resolve(world), this.annotationFinder);
 		}
 		return atTargetVar;
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getArgAnnotationVar(int, org.aspectj.weaver.UnresolvedType)
 	 */
 	public Var getArgAnnotationVar(int i, UnresolvedType forAnnotationType) {
 		ResolvedType annType = forAnnotationType.resolve(world);
 		if (atArgsVars.get(annType) == null) {
 			Var[] vars = new Var[getArgCount()];
-			atArgsVars.put(annType,vars);
+			atArgsVars.put(annType, vars);
 		}
 		Var[] vars = (Var[]) atArgsVars.get(annType);
-		if (i > (vars.length - 1) ) return null;
+		if (i > (vars.length - 1))
+			return null;
 		if (vars[i] == null) {
-			vars[i] = ReflectionVar.createArgsAnnotationVar(annType, i,this.annotationFinder);
+			vars[i] = ReflectionVar.createArgsAnnotationVar(annType, i, this.annotationFinder);
 		}
 		return vars[i];
 	}
 
-	/* (non-Javadoc)
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getEnclosingCodeSignature()
 	 */
 	public Member getEnclosingCodeSignature() {
 		// XXX this code is copied from BcelShadow with one minor change...
-    	if (getKind().isEnclosingKind()) {
-    		return getSignature();
-    	} else if (getKind() == Shadow.PreInitialization) {
-          // PreInit doesn't enclose code but its signature
-          // is correctly the signature of the ctor.
-    	  return getSignature();
-    	} else if (enclosingShadow == null) {
-    		return this.enclosingMember;
-    	} else {
-    		return enclosingShadow.getSignature();
-    	}
-	}
-
-	/* (non-Javadoc)
+		if (getKind().isEnclosingKind()) {
+			return getSignature();
+		} else if (getKind() == Shadow.PreInitialization) {
+			// PreInit doesn't enclose code but its signature
+			// is correctly the signature of the ctor.
+			return getSignature();
+		} else if (enclosingShadow == null) {
+			return this.enclosingMember;
+		} else {
+			return enclosingShadow.getSignature();
+		}
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.weaver.Shadow#getSourceLocation()
 	 */
 	public ISourceLocation getSourceLocation() {
@@ -111,7 +111,7 @@ public class StandardShadow extends Shadow {
 		Kind kind = Shadow.StaticInitialization;
 		if (clinit == -1) {
 			Member clinitMember = new ResolvedMemberImpl(org.aspectj.weaver.Member.STATIC_INITIALIZATION, forType, Modifier.STATIC,
-					ResolvedType.VOID, "<clinit>", new UnresolvedType[0], new UnresolvedType[0]);
+					UnresolvedType.VOID, "<clinit>", new UnresolvedType[0], new UnresolvedType[0]);
 			return new StandardShadow(inWorld, kind, clinitMember, null, forType, null, withContext);
 		} else {
 			return new StandardShadow(inWorld, kind, members[clinit], null, forType, null, withContext);
@@ -145,8 +145,8 @@ public class StandardShadow extends Shadow {
 			MatchingContext withContext) {
 		Kind kind = Shadow.ExceptionHandler;
 		Shadow enclosingShadow = makeExecutionShadow(inWorld, withinCode, withContext);
-		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createHandlerMember(exceptionType, withinCode
-				.getDeclaringClass(), inWorld);
+		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createHandlerMember(exceptionType,
+				withinCode.getDeclaringClass(), inWorld);
 		ResolvedMember enclosingMember = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(withinCode, inWorld);
 		ResolvedType enclosingType = enclosingMember.getDeclaringType().resolve(inWorld);
 		return new StandardShadow(inWorld, kind, signature, enclosingShadow, enclosingType, enclosingMember, withContext);
@@ -273,31 +273,18 @@ public class StandardShadow extends Shadow {
 		return null;
 	}
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.aspectj.weaver.Shadow#getThisJoinPointStaticPartVar()
-	 */
 	public Var getThisJoinPointStaticPartVar() {
-		// TODO Auto-generated method stub
 		return null;
 	}
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.aspectj.weaver.Shadow#getThisEnclosingJoinPointStaticPartVar()
-	 */
 	public Var getThisEnclosingJoinPointStaticPartVar() {
-		// TODO Auto-generated method stub
 		return null;
 	}
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.aspectj.weaver.Shadow#getKindedAnnotationVar(org.aspectj.weaver.UnresolvedType)
-	 */
+	public Var getThisAspectInstanceVar(ResolvedType aspectType) {
+		return null;
+	}
+
 	public Var getKindedAnnotationVar(UnresolvedType forAnnotationType) {
 		ResolvedType annType = forAnnotationType.resolve(world);
 		if (annotationVar.get(annType) == null) {
@@ -0,0 +1,27 @@
+public class Eight {
+  public static void main(String[] argv) {
+    Eight a = new Eight();
+    a.m();
+  }
+
+  public void m() {
+    System.out.println("Method m() running");
+  }
+}
+
+abstract aspect Y {
+  abstract pointcut p();
+  before(): execution(* m(..))  && p() {
+    System.out.println("In advice()");
+  }
+}
+
+aspect X extends Y {
+  pointcut p(): if(thisAspectInstance.doit());
+
+  boolean doit() {
+    System.out.println("in doit(): class="+this.getClass().getName());
+    return true;
+  }
+
+}
@@ -0,0 +1,22 @@
+public class Eleven {
+  public static void main(String[] argv) {
+    Eleven a = new Eleven();
+    a.m();
+  }
+
+  public void m() {
+    System.out.println("Method m() running");
+  }
+}
+
+aspect X perthis(this(Eleven)) {
+
+  boolean doit() {
+    System.out.println("In instance check method doit()");
+    return true;
+  }
+
+  before():execution(* m(..))  && if(thisAspectInstance.doit()){ 
+    System.out.println("In advice()");
+  }
+}
@@ -0,0 +1,25 @@
+public class Fifteen {
+  public static void main(String[] argv) {
+    Fifteen a = new Fifteen();
+    a.m();
+  }
+
+  public void m() {
+    System.out.println("Method m() running");
+  }
+}
+
+abstract aspect Y {
+  abstract pointcut p();
+  before(): if(thisAspectInstance.doit()) && p() {
+    System.out.println("In advice()");
+  }
+  boolean doit() {
+    System.out.println("in doit(): class="+this.getClass().getName());
+    return true;
+  }
+}
+
+aspect X extends Y {
+  pointcut p(): execution(* m(..));
+}
@@ -0,0 +1,21 @@
+public class Five {
+  public static void main(String[] argv) {
+    Five a = new Five();
+    a.m("abc");
+  }
+
+  public void m(String s) {
+    System.out.println("Method m() running");
+  }
+}
+
+aspect X {
+  boolean doit() {
+    System.out.println("In instance check method doit()");
+    return true;
+  }
+
+  before():execution(* m(..))  && if(thisAspectInstance.doit()){ 
+    System.out.println("In advice() arg0="+thisJoinPoint.getArgs()[0]);
+  }
+}
@@ -0,0 +1,21 @@
+public class Four {
+  public static void main(String[] argv) {
+    Four a = new Four();
+    a.m();
+  }
+
+  public void m() {
+    System.out.println("Method m() running");
+  }
+}
+
+aspect X {
+  boolean doit() {
+    System.out.println("In instance check method doit()");
+    return true;
+  }
+
+  before():execution(* m(..))  && if(thisAspectInstance.doit()){ 
+    System.out.println("In advice() "+thisJoinPointStaticPart);
+  }
+}
@@ -0,0 +1,22 @@
+public class Fourteen {
+  public static void main(String[] argv) {
+    Fourteen a = new Fourteen();
+    a.m("abc");
+  }
+
+  public void m(String s) {
+    System.out.println("Method m() running");
+  }
+}
+
+aspect X {
+
+  static boolean printit(Object o) {
+    System.out.println("instance is "+o.getClass().getName());
+return true;
+  }
+
+  before(String s):args(s) && execution(* m(..))  && if(printit(thisAspectInstance)) && if(thisJoinPointStaticPart.toString().indexOf("Fourteen")!=-1) { 
+    System.out.println("In advice() arg="+s+" tjpsp="+thisJoinPointStaticPart);
+  }
+}
@@ -0,0 +1,25 @@
+public class Nine {
+  public static void main(String[] argv) {
+    Nine a = new Nine();
+    a.m();
+  }
+
+  public void m() {
+    System.out.println("Method m() running");
+  }
+}
+
+abstract aspect Y {
+  abstract pointcut p();
+  before(): execution(* m(..))  && p() {
+    System.out.println("In advice()");
+  }
+  boolean doit() {
+    System.out.println("in doit(): class="+this.getClass().getName());
+    return true;
+  }
+}
+
+aspect X extends Y {
+  pointcut p(): if(thisAspectInstance.doit());
+}
@@ -0,0 +1,21 @@
+public class One {
+  public static void main(String[] argv) {
+    One a = new One();
+    a.m();
+  }
+
+  public void m() {
+    System.out.println("Method m() running");
+  }
+}
+
+aspect X {
+  boolean doit() {
+    System.out.println("In instance check method doit()");
+    return true;
+  }
+
+  before():execution(* m(..))  && if(thisAspectInstance.doit()){ 
+    System.out.println("In advice()");
+  }
+}
@@ -0,0 +1,21 @@
+public class Seven {
+  public static void main(String[] argv) {
+    Seven a = new Seven();
+    a.m();
+  }
+
+  public void m() {
+    System.out.println("Method m() running");
+  }
+}
+
+aspect X {
+  boolean doit() {
+    System.out.println("In instance check method doit()");
+    return true;
+  }
+
+  before(): call(* m(..))  && if(thisAspectInstance.doit()){ 
+    System.out.println("In advice() "+thisJoinPoint+" "+thisEnclosingJoinPointStaticPart);
+  }
+}
@@ -0,0 +1,21 @@
+public class Six {
+  public static void main(String[] argv) {
+    Six a = new Six();
+    a.m();
+  }
+
+  public void m() {
+    System.out.println("Method m() running");
+  }
+}
+
+aspect X {
+  boolean doit() {
+    System.out.println("In instance check method doit()");
+    return true;
+  }
+
+  before():call(* m(..))  && if(thisAspectInstance.doit()){ 
+    System.out.println("In advice() "+thisEnclosingJoinPointStaticPart);
+  }
+}
@@ -0,0 +1,23 @@
+package com.foo.bar;
+
+public class Ten {
+  public static void main(String[] argv) {
+    Ten a = new Ten();
+    a.m();
+  }
+
+  public void m() {
+    System.out.println("Method m() running");
+  }
+}
+
+aspect X {
+  boolean doit() {
+    System.out.println("In instance check method doit() class="+this.getClass().getName());
+    return true;
+  }
+
+  before():execution(* m(..))  && if(thisAspectInstance.doit()){ 
+    System.out.println("In advice()");
+  }
+}
@@ -0,0 +1,22 @@
+public class Thirteen {
+  public static void main(String[] argv) {
+    Thirteen a = new Thirteen();
+    a.m("abc");
+  }
+
+  public void m(String s) {
+    System.out.println("Method m() running");
+  }
+}
+
+aspect X {
+
+  static boolean printit(Object o) {
+    System.out.println("instance is "+o.getClass().getName());
+return true;
+  }
+
+  before(String s):args(s) && execution(* m(..))  && if(printit(thisAspectInstance)){ 
+    System.out.println("In advice() arg="+s+" tjpsp="+thisJoinPointStaticPart);
+  }
+}
@@ -0,0 +1,27 @@
+public class Three {
+  public static void main(String[] argv) {
+    Three a = new Three();
+    a.m();
+    a.m();
+    a.m();
+    a.m();
+  }
+
+  public void m() {
+    System.out.println("Method m() running");
+  }
+}
+
+aspect X {
+  int count = 0;
+
+  boolean doit() {
+    count++;
+    System.out.println("In instance check method, count="+count+" so doit returns "+((count%2)==0));
+    return (count%2)==0;
+  }
+
+  after():call(* m(..))  && if(thisAspectInstance.doit()){ 
+    System.out.println("In advice()");
+  }
+}
@@ -0,0 +1,22 @@
+public class Twelve {
+  public static void main(String[] argv) {
+    Twelve a = new Twelve();
+    a.m("abc");
+  }
+
+  public void m(String s) {
+    System.out.println("Method m() running");
+  }
+}
+
+aspect X {
+
+  boolean doit() {
+    System.out.println("In instance check method doit()");
+    return true;
+  }
+
+  before(String s):execution(* m(..))  && if(thisAspectInstance.doit()) && args(s) { 
+    System.out.println("In advice() arg="+s+" tjpsp="+thisJoinPointStaticPart);
+  }
+}
@@ -0,0 +1,27 @@
+public class Two {
+  public static void main(String[] argv) {
+    Two a = new Two();
+    a.m();
+    a.m();
+    a.m();
+    a.m();
+  }
+
+  public void m() {
+    System.out.println("Method m() running");
+  }
+}
+
+aspect X {
+  int count = 0;
+
+  boolean doit() {
+    count++;
+    System.out.println("In instance check method, count="+count+" so doit returns "+((count%2)==0));
+    return (count%2)==0;
+  }
+
+  before():call(* m(..))  && if(thisAspectInstance.doit()){ 
+    System.out.println("In advice()");
+  }
+}
