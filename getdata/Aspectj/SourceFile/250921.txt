@@ -10,7 +10,6 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.weaver;
 
 import java.io.File;
@@ -31,204 +30,209 @@ import org.aspectj.weaver.tools.Trace;
 import org.aspectj.weaver.tools.TraceFactory;
 
 public class Lint {
-	/* private */ Map kinds = new HashMap();
-	/* private */ World world;
-
-	public final Kind invalidAbsoluteTypeName =
-		new Kind("invalidAbsoluteTypeName", "no match for this type name: {0}");
-
-	public final Kind invalidWildcardTypeName = 
-		new Kind("invalidWildcardTypeName", "no match for this type pattern: {0}");
-	
-	public final Kind unresolvableMember = 
-		new Kind("unresolvableMember", "can not resolve this member: {0}");
-	
-	public final Kind typeNotExposedToWeaver = 
-		new Kind("typeNotExposedToWeaver", "this affected type is not exposed to the weaver: {0}");
-		
-	public final Kind shadowNotInStructure = 
-		new Kind("shadowNotInStructure", "the shadow for this join point is not exposed in the structure model: {0}");
-
-	public final Kind unmatchedSuperTypeInCall = 
-		new Kind("unmatchedSuperTypeInCall", "does not match because declaring type is {0}, if match desired use target({1})");
-
-	public final Kind unmatchedTargetKind = 
-		new Kind("unmatchedTargetKind", "does not match because annotation {0} has @Target{1}");
-	
-	public final Kind canNotImplementLazyTjp = 
-		new Kind("canNotImplementLazyTjp", "can not implement lazyTjp on this joinpoint {0} because around advice is used");
-
-	public final Kind multipleAdviceStoppingLazyTjp = 
-		new Kind("multipleAdviceStoppingLazyTjp", "can not implement lazyTjp at joinpoint {0} because of advice conflicts, see secondary locations to find conflicting advice");
-
-	public final Kind needsSerialVersionUIDField = 
-		new Kind("needsSerialVersionUIDField", "serialVersionUID of type {0} needs to be set because of {1}");
-
-	public final Kind serialVersionUIDBroken = 
-		new Kind("brokeSerialVersionCompatibility", "serialVersionUID of type {0} is broken because of added field {1}");
-		
-	public final Kind noInterfaceCtorJoinpoint = 
-		new Kind("noInterfaceCtorJoinpoint","no interface constructor-execution join point - use {0}+ for implementing classes");
-        
-	public final Kind noJoinpointsForBridgeMethods =
-		new Kind("noJoinpointsForBridgeMethods","pointcut did not match on the method call to a bridge method.  Bridge methods are generated by the compiler and have no join points");
-	
-	public final Kind enumAsTargetForDecpIgnored =
-		new Kind("enumAsTargetForDecpIgnored","enum type {0} matches a declare parents type pattern but is being ignored");
-
-	public final Kind annotationAsTargetForDecpIgnored =
-		new Kind("annotationAsTargetForDecpIgnored","annotation type {0} matches a declare parents type pattern but is being ignored");
-	
-	public final Kind cantMatchArrayTypeOnVarargs =
-		new Kind("cantMatchArrayTypeOnVarargs","an array type as the last parameter in a signature does not match on the varargs declared method: {0}");
-	
-    public final Kind adviceDidNotMatch =
-        new Kind("adviceDidNotMatch","advice defined in {0} has not been applied");
-    
-    public final Kind invalidTargetForAnnotation =
-    	new Kind("invalidTargetForAnnotation","{0} is not a valid target for annotation {1}, this annotation can only be applied to {2}");
-
-    public final Kind elementAlreadyAnnotated =
-    	new Kind("elementAlreadyAnnotated","{0} - already has an annotation of type {1}, cannot add a second instance");
-    	
-	public final Kind runtimeExceptionNotSoftened = 
-		new Kind("runtimeExceptionNotSoftened","{0} will not be softened as it is already a RuntimeException");
-	
-	public final Kind uncheckedArgument =
-		new Kind("uncheckedArgument","unchecked match of {0} with {1} when argument is an instance of {2} at join point {3}");
-	
-	public final Kind uncheckedAdviceConversion =
-		new Kind("uncheckedAdviceConversion","unchecked conversion when advice applied at shadow {0}, expected {1} but advice uses {2}");
- 
-	public final Kind noGuardForLazyTjp =
-		new Kind("noGuardForLazyTjp","can not build thisJoinPoint lazily for this advice since it has no suitable guard");
-	
-	public final Kind noExplicitConstructorCall = 
-		new Kind("noExplicitConstructorCall","inter-type constructor does not contain explicit constructor call: field initializers in the target type will not be executed");
-	
-	public final Kind aspectExcludedByConfiguration = 
-		new Kind("aspectExcludedByConfiguration","aspect {0} exluded for class loader {1}");
-	
-	public final Kind unorderedAdviceAtShadow =
-		new Kind("unorderedAdviceAtShadow","at this shadow {0} no precedence is specified between advice applying from aspect {1} and aspect {2}");
-	
-	public final Kind swallowedExceptionInCatchBlock = 
-		new Kind("swallowedExceptionInCatchBlock","exception swallowed in catch block");
-	
-	public final Kind calculatingSerialVersionUID =
-		new Kind("calculatingSerialVersionUID","calculated SerialVersionUID for type {0} to be {1}");
-	
+	/* private */Map kinds = new HashMap();
+	/* private */World world;
+
+	public final Kind invalidAbsoluteTypeName = new Kind("invalidAbsoluteTypeName", "no match for this type name: {0}");
+
+	public final Kind invalidWildcardTypeName = new Kind("invalidWildcardTypeName", "no match for this type pattern: {0}");
+
+	public final Kind unresolvableMember = new Kind("unresolvableMember", "can not resolve this member: {0}");
+
+	public final Kind typeNotExposedToWeaver = new Kind("typeNotExposedToWeaver",
+			"this affected type is not exposed to the weaver: {0}");
+
+	public final Kind shadowNotInStructure = new Kind("shadowNotInStructure",
+			"the shadow for this join point is not exposed in the structure model: {0}");
+
+	public final Kind unmatchedSuperTypeInCall = new Kind("unmatchedSuperTypeInCall",
+			"does not match because declaring type is {0}, if match desired use target({1})");
+
+	public final Kind unmatchedTargetKind = new Kind("unmatchedTargetKind", "does not match because annotation {0} has @Target{1}");
+
+	public final Kind canNotImplementLazyTjp = new Kind("canNotImplementLazyTjp",
+			"can not implement lazyTjp on this joinpoint {0} because around advice is used");
+
+	public final Kind multipleAdviceStoppingLazyTjp = new Kind("multipleAdviceStoppingLazyTjp",
+			"can not implement lazyTjp at joinpoint {0} because of advice conflicts, see secondary locations to find conflicting advice");
+
+	public final Kind needsSerialVersionUIDField = new Kind("needsSerialVersionUIDField",
+			"serialVersionUID of type {0} needs to be set because of {1}");
+
+	public final Kind serialVersionUIDBroken = new Kind("brokeSerialVersionCompatibility",
+			"serialVersionUID of type {0} is broken because of added field {1}");
+
+	public final Kind noInterfaceCtorJoinpoint = new Kind("noInterfaceCtorJoinpoint",
+			"no interface constructor-execution join point - use {0}+ for implementing classes");
+
+	public final Kind noJoinpointsForBridgeMethods = new Kind(
+			"noJoinpointsForBridgeMethods",
+			"pointcut did not match on the method call to a bridge method.  Bridge methods are generated by the compiler and have no join points");
+
+	public final Kind enumAsTargetForDecpIgnored = new Kind("enumAsTargetForDecpIgnored",
+			"enum type {0} matches a declare parents type pattern but is being ignored");
+
+	public final Kind annotationAsTargetForDecpIgnored = new Kind("annotationAsTargetForDecpIgnored",
+			"annotation type {0} matches a declare parents type pattern but is being ignored");
+
+	public final Kind cantMatchArrayTypeOnVarargs = new Kind("cantMatchArrayTypeOnVarargs",
+			"an array type as the last parameter in a signature does not match on the varargs declared method: {0}");
+
+	public final Kind adviceDidNotMatch = new Kind("adviceDidNotMatch", "advice defined in {0} has not been applied");
+
+	public final Kind invalidTargetForAnnotation = new Kind("invalidTargetForAnnotation",
+			"{0} is not a valid target for annotation {1}, this annotation can only be applied to {2}");
+
+	public final Kind elementAlreadyAnnotated = new Kind("elementAlreadyAnnotated",
+			"{0} - already has an annotation of type {1}, cannot add a second instance");
+
+	public final Kind runtimeExceptionNotSoftened = new Kind("runtimeExceptionNotSoftened",
+			"{0} will not be softened as it is already a RuntimeException");
+
+	public final Kind uncheckedArgument = new Kind("uncheckedArgument",
+			"unchecked match of {0} with {1} when argument is an instance of {2} at join point {3}");
+
+	public final Kind uncheckedAdviceConversion = new Kind("uncheckedAdviceConversion",
+			"unchecked conversion when advice applied at shadow {0}, expected {1} but advice uses {2}");
+
+	public final Kind noGuardForLazyTjp = new Kind("noGuardForLazyTjp",
+			"can not build thisJoinPoint lazily for this advice since it has no suitable guard");
+
+	public final Kind noExplicitConstructorCall = new Kind("noExplicitConstructorCall",
+			"inter-type constructor does not contain explicit constructor call: field initializers in the target type will not be executed");
+
+	public final Kind aspectExcludedByConfiguration = new Kind("aspectExcludedByConfiguration",
+			"aspect {0} exluded for class loader {1}");
+
+	public final Kind unorderedAdviceAtShadow = new Kind("unorderedAdviceAtShadow",
+			"at this shadow {0} no precedence is specified between advice applying from aspect {1} and aspect {2}");
+
+	public final Kind swallowedExceptionInCatchBlock = new Kind("swallowedExceptionInCatchBlock",
+			"exception swallowed in catch block");
+
+	public final Kind calculatingSerialVersionUID = new Kind("calculatingSerialVersionUID",
+			"calculated SerialVersionUID for type {0} to be {1}");
+
 	// there are a lot of messages in the cant find type family - I'm defining an umbrella lint warning that
 	// allows a user to control their severity (for e.g. ltw or binary weaving)
-	public final Kind cantFindType =
-		new Kind("cantFindType","{0}");
-	
-	public final Kind cantFindTypeAffectingJoinPointMatch = new Kind("cantFindTypeAffectingJPMatch","{0}");
-	
+	public final Kind cantFindType = new Kind("cantFindType", "{0}");
+
+	public final Kind cantFindTypeAffectingJoinPointMatch = new Kind("cantFindTypeAffectingJPMatch", "{0}");
+
 	public final Kind advisingSynchronizedMethods = new Kind("advisingSynchronizedMethods",
 			"advice matching the synchronized method shadow ''{0}'' will be executed outside the lock rather than inside (compiler limitation)");
 
-	public final Kind mustWeaveXmlDefinedAspects = new Kind("mustWeaveXmlDefinedAspects",
+	public final Kind mustWeaveXmlDefinedAspects = new Kind(
+			"mustWeaveXmlDefinedAspects",
 			"XML Defined aspects must be woven in cases where cflow pointcuts are involved. Currently the include/exclude patterns exclude ''{0}''");
-	
+
+	/**
+	 * Indicates an aspect could not be found when attempting reweaving.
+	 */
+	public final Kind missingAspectForReweaving = new Kind("missingAspectForReweaving",
+			"aspect {0} cannot be found when reweaving {1}");
+
 	private static Trace trace = TraceFactory.getTraceFactory().getTrace(Lint.class);
-	
-    public Lint(World world) {
-    	if (trace.isTraceEnabled()) trace.enter("<init>",this,world);
+
+	public Lint(World world) {
+		if (trace.isTraceEnabled())
+			trace.enter("<init>", this, world);
 		this.world = world;
-		if (trace.isTraceEnabled()) trace.exit("<init>");
+		if (trace.isTraceEnabled())
+			trace.exit("<init>");
 	}
-	
-	
+
 	public void setAll(String messageKind) {
-		if (trace.isTraceEnabled()) trace.enter("setAll",this,messageKind);
+		if (trace.isTraceEnabled())
+			trace.enter("setAll", this, messageKind);
 		setAll(getMessageKind(messageKind));
-		if (trace.isTraceEnabled()) trace.exit("setAll");
+		if (trace.isTraceEnabled())
+			trace.exit("setAll");
 	}
-	
+
 	private void setAll(IMessage.Kind messageKind) {
-		for (Iterator i = kinds.values().iterator(); i.hasNext(); ) {
-			Kind kind = (Kind)i.next();
+		for (Iterator i = kinds.values().iterator(); i.hasNext();) {
+			Kind kind = (Kind) i.next();
 			kind.setKind(messageKind);
 		}
 	}
-	
+
 	public void setFromProperties(File file) {
-		if (trace.isTraceEnabled()) trace.enter("setFromProperties",this,file);
+		if (trace.isTraceEnabled())
+			trace.enter("setFromProperties", this, file);
 		try {
 			InputStream s = new FileInputStream(file);
 			setFromProperties(s);
 		} catch (IOException ioe) {
-			MessageUtil.error(world.getMessageHandler(),
-					WeaverMessages.format(WeaverMessages.XLINT_LOAD_ERROR,file.getPath(),ioe.getMessage()));
+			MessageUtil.error(world.getMessageHandler(), WeaverMessages.format(WeaverMessages.XLINT_LOAD_ERROR, file.getPath(), ioe
+					.getMessage()));
 		}
-		if (trace.isTraceEnabled()) trace.exit("setFromProperties");
+		if (trace.isTraceEnabled())
+			trace.exit("setFromProperties");
 	}
 
 	public void loadDefaultProperties() {
 		InputStream s = getClass().getResourceAsStream("XlintDefault.properties");
 		if (s == null) {
-			MessageUtil.warn(world.getMessageHandler(), 
-					WeaverMessages.format(WeaverMessages.XLINTDEFAULT_LOAD_ERROR));
+			MessageUtil.warn(world.getMessageHandler(), WeaverMessages.format(WeaverMessages.XLINTDEFAULT_LOAD_ERROR));
 			return;
 		}
 		try {
 			setFromProperties(s);
 		} catch (IOException ioe) {
-			MessageUtil.error(world.getMessageHandler(),
-					WeaverMessages.format(WeaverMessages.XLINTDEFAULT_LOAD_PROBLEM,ioe.getMessage()));
+			MessageUtil.error(world.getMessageHandler(), WeaverMessages.format(WeaverMessages.XLINTDEFAULT_LOAD_PROBLEM, ioe
+					.getMessage()));
 		}
 
 	}
 
-
 	private void setFromProperties(InputStream s) throws IOException {
 		Properties p = new Properties();
 		p.load(s);
 		setFromProperties(p);
 	}
-	
-	
+
 	public void setFromProperties(Properties properties) {
-		for (Iterator i = properties.entrySet().iterator(); i.hasNext(); ) {
-			Map.Entry entry = (Map.Entry)i.next();
-			Kind kind = (Kind)kinds.get(entry.getKey());
+		for (Iterator i = properties.entrySet().iterator(); i.hasNext();) {
+			Map.Entry entry = (Map.Entry) i.next();
+			Kind kind = (Kind) kinds.get(entry.getKey());
 			if (kind == null) {
-				MessageUtil.error(world.getMessageHandler(),
-						WeaverMessages.format(WeaverMessages.XLINT_KEY_ERROR,entry.getKey()));
+				MessageUtil.error(world.getMessageHandler(), WeaverMessages.format(WeaverMessages.XLINT_KEY_ERROR, entry.getKey()));
 			} else {
-				kind.setKind(getMessageKind((String)entry.getValue()));
+				kind.setKind(getMessageKind((String) entry.getValue()));
 			}
 		}
 	}
-	
+
 	public Collection allKinds() {
 		return kinds.values();
 	}
-	
+
 	public Kind getLintKind(String name) {
 		return (Kind) kinds.get(name);
 	}
-	
+
 	// temporarily suppress the given lint messages
 	public void suppressKinds(Collection lintKind) {
-		if (lintKind.isEmpty()) return;
+		if (lintKind.isEmpty())
+			return;
 		for (Iterator iter = lintKind.iterator(); iter.hasNext();) {
 			Kind k = (Kind) iter.next();
 			k.setSuppressed(true);
 		}
 	}
-	
+
 	// remove any suppression of lint warnings in place
 	public void clearAllSuppressions() {
 		for (Iterator iter = kinds.values().iterator(); iter.hasNext();) {
 			Kind k = (Kind) iter.next();
 			k.setSuppressed(false);
-		}		
+		}
 	}
-	
+
 	public void clearSuppressions(Collection lintKind) {
-		if (lintKind.isEmpty()) return;
+		if (lintKind.isEmpty())
+			return;
 		for (Iterator iter = lintKind.iterator(); iter.hasNext();) {
 			Kind k = (Kind) iter.next();
 			k.setSuppressed(false);
@@ -236,47 +240,50 @@ public class Lint {
 	}
 
 	private IMessage.Kind getMessageKind(String v) {
-		if (v.equals("ignore")) return null;
-		else if (v.equals("warning")) return IMessage.WARNING;
-		else if (v.equals("error")) return IMessage.ERROR;
-		
-		MessageUtil.error(world.getMessageHandler(), 
-				WeaverMessages.format(WeaverMessages.XLINT_VALUE_ERROR,v));
+		if (v.equals("ignore"))
+			return null;
+		else if (v.equals("warning"))
+			return IMessage.WARNING;
+		else if (v.equals("error"))
+			return IMessage.ERROR;
+
+		MessageUtil.error(world.getMessageHandler(), WeaverMessages.format(WeaverMessages.XLINT_VALUE_ERROR, v));
 		return null;
 	}
 
 	public Kind fromKey(String lintkey) {
-		return (Lint.Kind)kinds.get(lintkey);
+		return (Lint.Kind) kinds.get(lintkey);
 	}
-	
+
 	public class Kind {
-		private String name;
-		private String message;
+		private final String name;
+		private final String message;
 		private IMessage.Kind kind = IMessage.WARNING;
 		private boolean isSupressed = false; // by SuppressAjWarnings
+
 		public Kind(String name, String message) {
 			this.name = name;
 			this.message = message;
 			kinds.put(this.name, this);
 		}
-		
+
 		public void setSuppressed(boolean shouldBeSuppressed) {
 			this.isSupressed = shouldBeSuppressed;
 		}
-		
+
 		public boolean isEnabled() {
 			return (kind != null) && !isSupressed();
 		}
-		
+
 		private boolean isSupressed() {
 			// can't suppress errors!
 			return isSupressed && (kind != IMessage.ERROR);
 		}
-		
+
 		public String getName() {
 			return name;
 		}
-		
+
 		public IMessage.Kind getKind() {
 			return kind;
 		}
@@ -284,25 +291,25 @@ public class Lint {
 		public void setKind(IMessage.Kind kind) {
 			this.kind = kind;
 		}
-		
+
 		public void signal(String info, ISourceLocation location) {
-			if (kind == null) return;
-			
-			String text = MessageFormat.format(message, new Object[] {info} );
+			if (kind == null)
+				return;
+
+			String text = MessageFormat.format(message, new Object[] { info });
 			text += " [Xlint:" + name + "]";
-			world.getMessageHandler().handleMessage(
-					new LintMessage(text, kind, location,null,getLintKind(name)));
+			world.getMessageHandler().handleMessage(new LintMessage(text, kind, location, null, getLintKind(name)));
 		}
 
 		public void signal(String[] infos, ISourceLocation location, ISourceLocation[] extraLocations) {
-            if (kind == null) return;
-            
-            String text = MessageFormat.format(message, (Object[])infos );
-            text += " [Xlint:" + name + "]";
-            world.getMessageHandler().handleMessage(
-                    new LintMessage(text, kind, location,extraLocations,getLintKind(name)));
+			if (kind == null)
+				return;
+
+			String text = MessageFormat.format(message, (Object[]) infos);
+			text += " [Xlint:" + name + "]";
+			world.getMessageHandler().handleMessage(new LintMessage(text, kind, location, extraLocations, getLintKind(name)));
 		}
 
 	}
-	
+
 }
@@ -42,4 +42,6 @@ unorderedAdviceAtShadow=ignore
 swallowedExceptionInCatchBlock=ignore
 calculatingSerialVersionUID=ignore
 advisingSynchronizedMethods=warning
-mustWeaveXmlDefinedAspects=warning
\ No newline at end of file
+mustWeaveXmlDefinedAspects=warning
+
+missingAspectForReweaving=error
\ No newline at end of file
@@ -1426,8 +1426,10 @@ public class BcelWeaver {
 						ResolvedType rtx = world.resolve(UnresolvedType.forName(requiredTypeName), true);
 						boolean exists = !rtx.isMissing();
 						if (!exists) {
-							world.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.MISSING_REWEAVABLE_TYPE,
-									requiredTypeName, className), classType.getSourceLocation(), null);
+							world.getLint().missingAspectForReweaving.signal(new String[] { requiredTypeName, className },
+									classType.getSourceLocation(), null);
+							// world.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.MISSING_REWEAVABLE_TYPE,
+							// requiredTypeName, className), classType.getSourceLocation(), null);
 						} else {
 							// weaved in aspect that are not declared in aop.xml
 							// trigger an error for now
@@ -41,8 +41,7 @@ public class ReweavableTests extends AjdeCoreTestCase {
 		initialiseProject("ReweavableTest");
 		handler = (TestMessageHandler) getCompiler().getMessageHandler();
 		handler.dontIgnore(IMessage.INFO);
-		compilerConfig = (TestCompilerConfiguration) getCompiler()
-				.getCompilerConfiguration();
+		compilerConfig = (TestCompilerConfiguration) getCompiler().getCompilerConfiguration();
 	}
 
 	protected void tearDown() throws Exception {
@@ -52,34 +51,32 @@ public class ReweavableTests extends AjdeCoreTestCase {
 	}
 
 	/**
-	 * Aim: Check we haven't damaged 'normal compilation' when not supplying
-	 * -Xreweavable. Also determines baseline sizes for the compiled class files
-	 * for later comparison.
+	 * Aim: Check we haven't damaged 'normal compilation' when not supplying -Xreweavable. Also determines baseline sizes for the
+	 * compiled class files for later comparison.
 	 * 
-	 * Inputs to the compiler: NonReweavable1.lst -> CalculatePI.java ->
-	 * Logger.aj -> -verbose -> -noExit
+	 * Inputs to the compiler: NonReweavable1.lst -> CalculatePI.java -> Logger.aj -> -verbose -> -noExit
 	 * 
-	 * Expected result = Compile successful, the types will not be reweavable
-	 * and the weaver should not report it is running in reweavable mode.
+	 * Expected result = Compile successful, the types will not be reweavable and the weaver should not report it is running in
+	 * reweavable mode.
 	 */
 	public void testNonReweavableCompile() {
-		if (debugTests)System.out.println("testNonReweavableCompile: Building with NonReweavable1.lst");
+		if (debugTests)
+			System.out.println("testNonReweavableCompile: Building with NonReweavable1.lst");
 		String[] files = new String[] { "CalculatePI.java", "Logger.aj" };
 		compilerConfig.setProjectSourceFiles(getSourceFileList(files));
 		compilerConfig.setNonStandardOptions("-verbose -noExit -XnotReweavable");
 
 		doBuild(true);
 
-		assertFalse("Did not expect to find a message about the weaver operating " +
-				"in reweavable mode",checkFor("weaver operating in reweavable mode"));
+		assertFalse("Did not expect to find a message about the weaver operating " + "in reweavable mode",
+				checkFor("weaver operating in reweavable mode"));
 
 		File fCalc = openFile("bin/CalculatePI.class");
 		File fLog = openFile("bin/Logger.class");
 		assertTrue("bin/CalculatePI.class should exist?!?", fCalc.exists());
 		assertTrue("bin/Logger.class should exist?!?", fLog.exists());
 		if (debugTests)
-			System.out.println("CalculatePI.class is of size: "
-					+ fCalc.length());
+			System.out.println("CalculatePI.class is of size: " + fCalc.length());
 		if (debugTests)
 			System.out.println("Logger.class is of size: " + fLog.length());
 		if (debugTests)
@@ -89,37 +86,32 @@ public class ReweavableTests extends AjdeCoreTestCase {
 	}
 
 	/**
-	 * Aim: Basic call to -Xreweavable. Weaver should report it is in reweavable
-	 * mode and the classes produced should be much larger than normal classes
-	 * (those produced in the first test).
+	 * Aim: Basic call to -Xreweavable. Weaver should report it is in reweavable mode and the classes produced should be much larger
+	 * than normal classes (those produced in the first test).
 	 * 
-	 * Inputs to the compiler: Reweavable1.lst -> CalculatePI.java -> Logger.aj ->
-	 * -Xreweavable -> -verbose -> -noExit
+	 * Inputs to the compiler: Reweavable1.lst -> CalculatePI.java -> Logger.aj -> -Xreweavable -> -verbose -> -noExit
 	 * 
-	 * Expected result = Compile successful, the types will be reweavable and
-	 * the weaver should report it is running in reweavable mode. The files
-	 * produced should be larger than those created during the last test.
+	 * Expected result = Compile successful, the types will be reweavable and the weaver should report it is running in reweavable
+	 * mode. The files produced should be larger than those created during the last test.
 	 */
 	public void testReweavableCompile() {
 		if (debugTests)
-			System.out
-					.println("testReweavableCompile: Building with Reweavable1.lst");
+			System.out.println("testReweavableCompile: Building with Reweavable1.lst");
 		String[] files = new String[] { "CalculatePI.java", "Logger.aj" };
 		compilerConfig.setProjectSourceFiles(getSourceFileList(files));
 		compilerConfig.setNonStandardOptions("-verbose -noExit");
 
 		doBuild(true);
 
-		assertTrue("Expected a message about operating in reweavable mode, but " +
-				"didn't get one",checkFor("weaver operating in reweavable mode"));
+		assertTrue("Expected a message about operating in reweavable mode, but " + "didn't get one",
+				checkFor("weaver operating in reweavable mode"));
 
 		File fCalc = openFile("bin/CalculatePI.class");
 		File fLog = openFile("bin/Logger.class");
 		assertTrue("bin/CalculatePI.class should exist?!?", fCalc.exists());
 		assertTrue("bin/Logger.class should exist?!?", fLog.exists());
 		if (debugTests)
-			System.out.println("CalculatePI.class is of size: "
-					+ fCalc.length());
+			System.out.println("CalculatePI.class is of size: " + fCalc.length());
 		if (debugTests)
 			System.out.println("Logger.class is of size: " + fLog.length());
 		// Temporarily remove these tests - it seems the order in which the
@@ -140,33 +132,28 @@ public class ReweavableTests extends AjdeCoreTestCase {
 	}
 
 	/**
-	 * Aim: Use the optional ':compress' modifier on -Xreweavable. This causes
-	 * some of the meta-data for use in reweaving to be compressed. It should
-	 * succeed and produce class files smaller than straight -Xreweavable but
-	 * larger than without specifying -Xreweavable.
+	 * Aim: Use the optional ':compress' modifier on -Xreweavable. This causes some of the meta-data for use in reweaving to be
+	 * compressed. It should succeed and produce class files smaller than straight -Xreweavable but larger than without specifying
+	 * -Xreweavable.
 	 * 
-	 * Inputs to the compiler: ReweavableCompress1.lst -> CalculatePI.java ->
-	 * Logger.aj -> -Xreweavable:compress -> -verbose -> -noExit
+	 * Inputs to the compiler: ReweavableCompress1.lst -> CalculatePI.java -> Logger.aj -> -Xreweavable:compress -> -verbose ->
+	 * -noExit
 	 * 
-	 * Expected result = Compile successful, the types will be reweavable and
-	 * the weaver should report it is running in reweavable mode. The files
-	 * created should have a size between the non-reweavable versions and the
-	 * reweavable (without compression) versions.
+	 * Expected result = Compile successful, the types will be reweavable and the weaver should report it is running in reweavable
+	 * mode. The files created should have a size between the non-reweavable versions and the reweavable (without compression)
+	 * versions.
 	 */
 	public void testReweavableCompressCompile() {
 		if (debugTests)
-			System.out
-					.println("testReweavableCompressCompile: Building with ReweavableCompress1.lst");
+			System.out.println("testReweavableCompressCompile: Building with ReweavableCompress1.lst");
 
 		String[] files = new String[] { "CalculatePI.java", "Logger.aj" };
 		compilerConfig.setProjectSourceFiles(getSourceFileList(files));
-		compilerConfig
-				.setNonStandardOptions("-Xreweavable:compress -verbose -noExit");
+		compilerConfig.setNonStandardOptions("-Xreweavable:compress -verbose -noExit");
 
 		doBuild(true);
 
-		assertTrue(
-				"Expected a message about operating in reweavable mode, but didn't get one",
+		assertTrue("Expected a message about operating in reweavable mode, but didn't get one",
 				checkFor("weaver operating in reweavable mode"));
 
 		File fCalc = openFile("bin/CalculatePI.class");
@@ -208,24 +195,19 @@ public class ReweavableTests extends AjdeCoreTestCase {
 	}
 
 	/**
-	 * Aim: The tests above have determined that reweaving appears to be
-	 * behaving in terms of the .class files it is creating. Now lets actually
-	 * attempt a reweave. For this, we build two files as reweavable and then
-	 * build a single file whilst specifying an inpath that contains the .class
-	 * files from the first compile. This should succeed.
+	 * Aim: The tests above have determined that reweaving appears to be behaving in terms of the .class files it is creating. Now
+	 * lets actually attempt a reweave. For this, we build two files as reweavable and then build a single file whilst specifying an
+	 * inpath that contains the .class files from the first compile. This should succeed.
 	 * 
-	 * Inputs to the first compile: Reweavable1.lst -> CalculatePI.java ->
-	 * Logger.aj -> -Xreweavable -> -verbose -> -noExit
+	 * Inputs to the first compile: Reweavable1.lst -> CalculatePI.java -> Logger.aj -> -Xreweavable -> -verbose -> -noExit
 	 * 
-	 * Input to the second compile: Reweavable2.lst -> SecondAspect.aj ->
-	 * -Xreweavable -> -verbose -> -noExit -inpath bin\.
+	 * Input to the second compile: Reweavable2.lst -> SecondAspect.aj -> -Xreweavable -> -verbose -> -noExit -inpath bin\.
 	 * 
 	 * Expected result = Both compiles will succeed.
 	 */
 	public void testReweavableSimpleCompile() {
 		if (debugTests)
-			System.out
-					.println("testReweavableSimpleCompile: Building with Reweavable1.lst");
+			System.out.println("testReweavableSimpleCompile: Building with Reweavable1.lst");
 
 		String[] files = new String[] { "CalculatePI.java", "Logger.aj" };
 		compilerConfig.setProjectSourceFiles(getSourceFileList(files));
@@ -233,13 +215,11 @@ public class ReweavableTests extends AjdeCoreTestCase {
 
 		doBuild(true);
 
-		assertTrue(
-				"Expected a message about operating in reweavable mode, but didn't get one",
+		assertTrue("Expected a message about operating in reweavable mode, but didn't get one",
 				checkFor("weaver operating in reweavable mode"));
 
 		if (debugTests)
-			System.out
-					.println("\ntestReweavableSimpleCompile: Building with Reweavable2.lst");
+			System.out.println("\ntestReweavableSimpleCompile: Building with Reweavable2.lst");
 		Set paths = new HashSet();
 		paths.add(openFile(binDir));
 		compilerConfig.setInpath(paths);
@@ -249,8 +229,7 @@ public class ReweavableTests extends AjdeCoreTestCase {
 		doBuild(true);
 
 		String expMessage = "successfully verified type Logger exists";
-		assertTrue("Expected message '" + expMessage + "' but did not find it",
-				checkFor(expMessage));
+		assertTrue("Expected message '" + expMessage + "' but did not find it", checkFor(expMessage));
 
 		File fCalc = openFile("bin/CalculatePI.class");
 		File fLog = openFile("bin/Logger.class");
@@ -264,23 +243,18 @@ public class ReweavableTests extends AjdeCoreTestCase {
 	}
 
 	/**
-	 * Aim: Based on the test above, if we delete Logger.class between the first
-	 * and second compiles the second compile should fail because there is not
-	 * enough information to reweave CalculatePI
+	 * Aim: Based on the test above, if we delete Logger.class between the first and second compiles the second compile should fail
+	 * because there is not enough information to reweave CalculatePI
 	 * 
-	 * Inputs to the first compile: Reweavable1.lst -> CalculatePI.java ->
-	 * Logger.aj -> -Xreweavable -> -verbose -> -noExit
+	 * Inputs to the first compile: Reweavable1.lst -> CalculatePI.java -> Logger.aj -> -Xreweavable -> -verbose -> -noExit
 	 * 
-	 * Input to the second compile: Reweavable2.lst -> SecondAspect.aj ->
-	 * -Xreweavable -> -verbose -> -noExit -inpath bin\.
+	 * Input to the second compile: Reweavable2.lst -> SecondAspect.aj -> -Xreweavable -> -verbose -> -noExit -inpath bin\.
 	 * 
-	 * Expected result = Second compile will fail - reporting that Logger is
-	 * missing (it 'touched' in the first compile CalculatePI)
+	 * Expected result = Second compile will fail - reporting that Logger is missing (it 'touched' in the first compile CalculatePI)
 	 */
 	public void testForReweavableSimpleErrorCompile() {
 		if (debugTests)
-			System.out
-					.println("testForReweavableSimpleErrorCompile: Building with Reweavable2.lst");
+			System.out.println("testForReweavableSimpleErrorCompile: Building with Reweavable2.lst");
 
 		String[] files = new String[] { "CalculatePI.java", "Logger.aj" };
 		compilerConfig.setProjectSourceFiles(getSourceFileList(files));
@@ -288,16 +262,13 @@ public class ReweavableTests extends AjdeCoreTestCase {
 
 		doBuild(true);
 
-		assertTrue(
-				"Expected a message about operating in reweavable mode, but didn't get one",
+		assertTrue("Expected a message about operating in reweavable mode, but didn't get one",
 				checkFor("weaver operating in reweavable mode"));
 
-		assertTrue("Could not delete bin/Logger.class??", openFile(
-				"bin/Logger.class").delete());
+		assertTrue("Could not delete bin/Logger.class??", openFile("bin/Logger.class").delete());
 
 		if (debugTests)
-			System.out
-					.println("\ntestForReweavableSimpleErrorCompile: Building with Reweavable2.lst");
+			System.out.println("\ntestForReweavableSimpleErrorCompile: Building with Reweavable2.lst");
 		Set paths = new HashSet();
 		paths.add(openFile(binDir));
 		compilerConfig.setInpath(paths);
@@ -306,9 +277,8 @@ public class ReweavableTests extends AjdeCoreTestCase {
 
 		doBuild(true);
 
-		String expMessage = "type Logger is needed by reweavable type CalculatePI";
-		assertTrue("Expected message '" + expMessage + "' but did not find it",
-				checkFor(expMessage));
+		String expMessage = "aspect Logger cannot be found when reweaving CalculatePI";
+		assertTrue("Expected message '" + expMessage + "' but did not find it", checkFor(expMessage));
 
 		File fCalc = openFile("bin/CalculatePI.class");
 		File fLog = openFile("bin/Logger.class");
@@ -322,36 +292,30 @@ public class ReweavableTests extends AjdeCoreTestCase {
 	}
 
 	/**
-	 * Aim: Based on the test above, if we delete Logger.class between the first
-	 * and second compiles the second compile should fail because there is not
-	 * enough information to reweave CalculatePI
+	 * Aim: Based on the test above, if we delete Logger.class between the first and second compiles the second compile should fail
+	 * because there is not enough information to reweave CalculatePI
 	 * 
-	 * Inputs to the first compile: TJP1.lst -> tjp/Demo.java ->
-	 * tjp/GetInfo.java -> -Xreweavable -> -verbose -> -noExit
+	 * Inputs to the first compile: TJP1.lst -> tjp/Demo.java -> tjp/GetInfo.java -> -Xreweavable -> -verbose -> -noExit
 	 * 
-	 * Now, delete bin\tjp\GetInfo.class and do a compile with: TJP2.lst ->
-	 * -Xreweavable -> -verbose -> -noExit -inpath bin\.
+	 * Now, delete bin\tjp\GetInfo.class and do a compile with: TJP2.lst -> -Xreweavable -> -verbose -> -noExit -inpath bin\.
 	 * 
-	 * Expected result = Second compile will fail - reporting that tjp.GetInfo
-	 * is missing (it 'touched' in the first compile tjp.Demo)
+	 * Expected result = Second compile will fail - reporting that tjp.GetInfo is missing (it 'touched' in the first compile
+	 * tjp.Demo)
 	 */
 	public void testErrorScenario2Compile() {
 		if (debugTests)
 			System.out.println("testErrorScenario2: Building with TJP1.lst");
 
-		String[] files = new String[] { "tjp" + File.separator + "Demo.java",
-				"tjp" + File.separator + "GetInfo.java" };
+		String[] files = new String[] { "tjp" + File.separator + "Demo.java", "tjp" + File.separator + "GetInfo.java" };
 		compilerConfig.setProjectSourceFiles(getSourceFileList(files));
 		compilerConfig.setNonStandardOptions("-verbose -noExit");
 
 		doBuild(true);
 
-		assertTrue(
-				"Expected a message about operating in reweavable mode, but didn't get one",
+		assertTrue("Expected a message about operating in reweavable mode, but didn't get one",
 				checkFor("weaver operating in reweavable mode"));
 
-		assertTrue("Could not delete bin/tjp/GetInfo.class??", openFile(
-				"bin/tjp/GetInfo.class").delete());
+		assertTrue("Could not delete bin/tjp/GetInfo.class??", openFile("bin/tjp/GetInfo.class").delete());
 
 		if (debugTests)
 			System.out.println("\ntestErrorScenario2: Building with TJP2.lst");
@@ -361,34 +325,32 @@ public class ReweavableTests extends AjdeCoreTestCase {
 		compilerConfig.setProjectSourceFiles(new ArrayList());
 		doBuild(true);
 
-		String expMessage = "type tjp.GetInfo is needed by reweavable type tjp.Demo";
-		assertTrue("Expected message '" + expMessage + "' but did not find it",
-				checkFor(expMessage));
+		String expMessage = "aspect tjp.GetInfo cannot be found when reweaving tjp.Demo";
+		assertTrue("Expected message '" + expMessage + "' but did not find it", checkFor(expMessage));
 
 		File fDemo = openFile("bin/tjp/Demo.class");
 		File fGetInfo = openFile("bin/tjp/GetInfo.class");
 		assertTrue("bin/tjp/Demo.class should exist!", fDemo.exists());
 		assertTrue("bin/tjp/GetInfo.class should not exist!", !fGetInfo.exists());
 
-		if (debugTests)System.out.println("\n\n\n");
+		if (debugTests)
+			System.out.println("\n\n\n");
 	}
 
 	public void testWorkingScenario2Compile() {
 		if (debugTests)
 			System.out.println("testWorkingScenario2: Building with TJP1.lst");
-		String[] files = new String[] { "tjp" + File.separator + "Demo.java",
-				"tjp" + File.separator + "GetInfo.java" };
+		String[] files = new String[] { "tjp" + File.separator + "Demo.java", "tjp" + File.separator + "GetInfo.java" };
 		compilerConfig.setProjectSourceFiles(getSourceFileList(files));
-		compilerConfig
-				.setNonStandardOptions("-Xreweavable:compress -verbose -noExit");
+		compilerConfig.setNonStandardOptions("-Xreweavable:compress -verbose -noExit");
 
 		doBuild(true);
 
-		assertTrue(
-				"Expected a message about operating in reweavable mode, but didn't get one",
+		assertTrue("Expected a message about operating in reweavable mode, but didn't get one",
 				checkFor("weaver operating in reweavable mode"));
 
-		if (debugTests)System.out.println("\ntestWorkingScenario2: Building with TJP2.lst");
+		if (debugTests)
+			System.out.println("\ntestWorkingScenario2: Building with TJP2.lst");
 		Set paths = new HashSet();
 		paths.add(openFile(binDir));
 		compilerConfig.setInpath(paths);
@@ -396,8 +358,7 @@ public class ReweavableTests extends AjdeCoreTestCase {
 		doBuild(true);
 
 		String expMessage = "successfully verified type tjp.GetInfo exists";
-		assertTrue("Expected message '" + expMessage + "' but did not find it",
-				checkFor(expMessage));
+		assertTrue("Expected message '" + expMessage + "' but did not find it", checkFor(expMessage));
 
 		File fGetInfo = openFile("bin/tjp/GetInfo.class");
 		File fDemo = openFile("bin/tjp/Demo.class");
