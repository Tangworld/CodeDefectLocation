@@ -24,65 +24,73 @@ import org.aspectj.weaver.patterns.DeclareAnnotation;
 
 public class DeclareAnnotationDeclaration extends DeclareDeclaration {
 
-   private Annotation annotation;
-   
-   public DeclareAnnotationDeclaration(CompilationResult result, DeclareAnnotation symbolicDeclare, Annotation annotation)  {
- 	  super(result,symbolicDeclare);
- 	  this.annotation = annotation;
- 	  
- 	  addAnnotation(annotation);
- 	  if (symbolicDeclare==null) return; // there is an error that will already be getting reported (e.g. incorrect pattern on decaf/decac)
- 	  symbolicDeclare.setAnnotationString(annotation.toString());
-	  
-   }
-   
-   public void analyseCode(ClassScope classScope,
-			InitializationFlowContext initializationContext, FlowInfo flowInfo) {
+	private Annotation annotation;
+
+	public DeclareAnnotationDeclaration(CompilationResult result, DeclareAnnotation symbolicDeclare, Annotation annotation) {
+		super(result, symbolicDeclare);
+		this.annotation = annotation;
+
+		addAnnotation(annotation);
+		if (symbolicDeclare == null) {
+			return; // there is an error that will already be getting reported (e.g. incorrect pattern on decaf/decac)
+		}
+		symbolicDeclare.setAnnotationString(annotation.toString());
+
+	}
+
+	public void analyseCode(ClassScope classScope, InitializationFlowContext initializationContext, FlowInfo flowInfo) {
 		super.analyseCode(classScope, initializationContext, flowInfo);
 
 		long bits = annotation.resolvedType.getAnnotationTagBits();
-		
-		if ((bits&TagBits.AnnotationTarget)!=0) {
-			// The annotation is stored against a method.  For declare @type we need to
-			// confirm the annotation targets the right types.  Earlier checking will
+
+		if ((bits & TagBits.AnnotationTarget) != 0) {
+			// The annotation is stored against a method. For declare @type we need to
+			// confirm the annotation targets the right types. Earlier checking will
 			// have not found this problem because an annotation for target METHOD will
 			// not be reported on as we *do* store it against a method in this case
-			DeclareAnnotation.Kind k = ((DeclareAnnotation)declareDecl).getKind();
-			if (k.equals(DeclareAnnotation.AT_TYPE))  
-			  if ((bits&TagBits.AnnotationForMethod)!=0)
-				classScope.problemReporter().disallowedTargetForAnnotation(annotation);
-			if (k.equals(DeclareAnnotation.AT_FIELD))  
-			  if ((bits&TagBits.AnnotationForMethod)!=0)
-				classScope.problemReporter().disallowedTargetForAnnotation(annotation);
+			DeclareAnnotation.Kind k = ((DeclareAnnotation) declareDecl).getKind();
+			if (k.equals(DeclareAnnotation.AT_TYPE)) {
+				if ((bits & TagBits.AnnotationForMethod) != 0) {
+					classScope.problemReporter().disallowedTargetForAnnotation(annotation);
+				}
+			}
+			if (k.equals(DeclareAnnotation.AT_FIELD)) {
+				if ((bits & TagBits.AnnotationForMethod) != 0) {
+					classScope.problemReporter().disallowedTargetForAnnotation(annotation);
+				}
+			}
 		}
-		
-    }
-	
-	
-   public Annotation getDeclaredAnnotation() {
-   		return annotation;
-   }
-   	
+
+	}
+
+	public Annotation getDeclaredAnnotation() {
+		return annotation;
+	}
+
 	protected boolean shouldDelegateCodeGeneration() {
-		return true;  // declare annotation needs a method to be written out.
+		return true; // declare annotation needs a method to be written out.
 	}
-   
-   private void addAnnotation(Annotation ann) {
-   	if (this.annotations == null) {
-   		this.annotations = new Annotation[1];
-   	} else {
-   		Annotation[] old = this.annotations;
-   		this.annotations = new Annotation[old.length + 1];
-   		System.arraycopy(old,0,this.annotations,1,old.length);
-   	}
-	this.annotations[0] = ann;
-   }
-   
+
+	protected boolean shouldBeSynthetic() {
+		return false;
+	}
+
+	private void addAnnotation(Annotation ann) {
+		if (this.annotations == null) {
+			this.annotations = new Annotation[1];
+		} else {
+			Annotation[] old = this.annotations;
+			this.annotations = new Annotation[old.length + 1];
+			System.arraycopy(old, 0, this.annotations, 1, old.length);
+		}
+		this.annotations[0] = ann;
+	}
+
 	public void postParse(TypeDeclaration typeDec) {
 		super.postParse(typeDec);
-		if (declareDecl != null){
-			((DeclareAnnotation)declareDecl).setAnnotationMethod(new String(selector));
+		if (declareDecl != null) {
+			((DeclareAnnotation) declareDecl).setAnnotationMethod(new String(selector));
 		}
 	}
-	
+
 }
@@ -10,7 +10,6 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.ajdt.internal.compiler.ast;
 
 //import java.util.List;
@@ -47,19 +46,18 @@ public class DeclareDeclaration extends AjMethodDeclaration {
 	 */
 	public DeclareDeclaration(CompilationResult result, Declare symbolicDeclare) {
 		super(result);
-		
+
 		this.declareDecl = symbolicDeclare;
 		if (declareDecl != null) {
 			// AMC added init of declarationSourceXXX fields which are used
-			// in AsmBuilder for processing of MethodDeclaration locations. 
+			// in AsmBuilder for processing of MethodDeclaration locations.
 			declarationSourceStart = sourceStart = declareDecl.getStart();
 			declarationSourceEnd = sourceEnd = declareDecl.getEnd();
 		}
-		//??? we might need to set parameters to be empty
-		this.returnType = TypeReference.baseTypeReference(T_void, 0);       
+		// ??? we might need to set parameters to be empty
+		this.returnType = TypeReference.baseTypeReference(T_void, 0);
 	}
 
-	
 	public void addAtAspectJAnnotations() {
 		Annotation annotation = null;
 		if (declareDecl instanceof DeclareAnnotation) {
@@ -67,87 +65,93 @@ public class DeclareDeclaration extends AjMethodDeclaration {
 			String patternString = da.getPatternAsString();
 			String annString = da.getAnnotationString();
 			String kind = da.getKind().toString();
-			annotation = AtAspectJAnnotationFactory.createDeclareAnnAnnotation(
-							patternString,annString,kind,declarationSourceStart);
+			annotation = AtAspectJAnnotationFactory.createDeclareAnnAnnotation(patternString, annString, kind,
+					declarationSourceStart);
 		} else if (declareDecl instanceof DeclareErrorOrWarning) {
 			DeclareErrorOrWarning dd = (DeclareErrorOrWarning) declareDecl;
-			annotation = AtAspectJAnnotationFactory
-									.createDeclareErrorOrWarningAnnotation(dd.getPointcut().toString(),dd.getMessage(),dd.isError(),declarationSourceStart);
+			annotation = AtAspectJAnnotationFactory.createDeclareErrorOrWarningAnnotation(dd.getPointcut().toString(),
+					dd.getMessage(), dd.isError(), declarationSourceStart);
 		} else if (declareDecl instanceof DeclareParents) {
 			DeclareParents dp = (DeclareParents) declareDecl;
 			String childPattern = dp.getChild().toString();
 			Collection parentPatterns = dp.getParents().getExactTypes();
 			StringBuffer parents = new StringBuffer();
 			for (Iterator iter = parentPatterns.iterator(); iter.hasNext();) {
-				UnresolvedType  urt = ((UnresolvedType) iter.next());
+				UnresolvedType urt = ((UnresolvedType) iter.next());
 				parents.append(urt.getName());
-				if (iter.hasNext()) parents.append(", ");
-			}		
-			annotation = AtAspectJAnnotationFactory
-									.createDeclareParentsAnnotation(childPattern,parents.toString(),dp.isExtends(),declarationSourceStart);
+				if (iter.hasNext()) {
+					parents.append(", ");
+				}
+			}
+			annotation = AtAspectJAnnotationFactory.createDeclareParentsAnnotation(childPattern, parents.toString(),
+					dp.isExtends(), declarationSourceStart);
 		} else if (declareDecl instanceof DeclarePrecedence) {
 			DeclarePrecedence dp = (DeclarePrecedence) declareDecl;
 			String precedenceList = dp.getPatterns().toString();
-			annotation = AtAspectJAnnotationFactory.createDeclarePrecedenceAnnotation(precedenceList,declarationSourceStart);
+			annotation = AtAspectJAnnotationFactory.createDeclarePrecedenceAnnotation(precedenceList, declarationSourceStart);
 		} else if (declareDecl instanceof DeclareSoft) {
 			DeclareSoft ds = (DeclareSoft) declareDecl;
-			annotation = AtAspectJAnnotationFactory
-				.createDeclareSoftAnnotation(ds.getPointcut().toString(),ds.getException().getExactType().getName(),declarationSourceStart);			
+			annotation = AtAspectJAnnotationFactory.createDeclareSoftAnnotation(ds.getPointcut().toString(), ds.getException()
+					.getExactType().getName(), declarationSourceStart);
+		}
+		if (annotation != null) {
+			AtAspectJAnnotationFactory.addAnnotation(this, annotation, this.scope);
 		}
-		if (annotation != null) AtAspectJAnnotationFactory.addAnnotation(this,annotation,this.scope);
 	}
 
 	/**
-	 * A declare declaration exists in a classfile only as an attibute on the
-	 * class.  Unlike advice and inter-type declarations, it has no corresponding
-	 * method.
-	 * **AMC** changed the above policy in the case of declare annotation, which uses a 
-	 * corresponding method as the anchor for the declared annotation
+	 * A declare declaration exists in a classfile only as an attibute on the class. Unlike advice and inter-type declarations, it
+	 * has no corresponding method. **AMC** changed the above policy in the case of declare annotation, which uses a corresponding
+	 * method as the anchor for the declared annotation
 	 */
 	public void generateCode(ClassScope classScope, ClassFile classFile) {
-		this.binding.modifiers |= Flags.AccSynthetic;
+		if (shouldBeSynthetic()) {
+			this.binding.modifiers |= Flags.AccSynthetic;
+		}
 		classFile.extraAttributes.add(new EclipseAttributeAdapter(new AjAttribute.DeclareAttribute(declareDecl)));
 		if (shouldDelegateCodeGeneration()) {
-			super.generateCode(classScope,classFile);
+			super.generateCode(classScope, classFile);
 		}
 		return;
 	}
-	
+
 	protected boolean shouldDelegateCodeGeneration() {
 		return true;
 	}
 
-	public void parseStatements(
-		Parser parser,
-		CompilationUnitDeclaration unit) {
-			// do nothing
+	protected boolean shouldBeSynthetic() {
+		return true;
+	}
+
+	public void parseStatements(Parser parser, CompilationUnitDeclaration unit) {
+		// do nothing
 	}
-	
+
 	public void resolveStatements(ClassScope upperScope) {
-		// do nothing 
+		// do nothing
 	}
-	
-//	public boolean finishResolveTypes(SourceTypeBinding sourceTypeBinding) {
-//		// there's nothing for our super to resolve usefully
-//		//if (!super.finishResolveTypes(sourceTypeBinding)) return false;
-////		if (declare == null) return true;
-////        
-////        EclipseScope scope = new EclipseScope(new FormalBinding[0], this.scope);
-////
-////        declare.resolve(scope);
-////        return true;
-//	}
-
-	
+
+	// public boolean finishResolveTypes(SourceTypeBinding sourceTypeBinding) {
+	// // there's nothing for our super to resolve usefully
+	// //if (!super.finishResolveTypes(sourceTypeBinding)) return false;
+	// // if (declare == null) return true;
+	// //
+	// // EclipseScope scope = new EclipseScope(new FormalBinding[0], this.scope);
+	// //
+	// // declare.resolve(scope);
+	// // return true;
+	// }
+
 	public Declare build(ClassScope classScope) {
-		if (declareDecl == null) return null;
-        
-        EclipseScope scope = new EclipseScope(new FormalBinding[0], classScope);
+		if (declareDecl == null) {
+			return null;
+		}
 
-        declareDecl.resolve(scope);
-        return declareDecl;
-	}
+		EclipseScope scope = new EclipseScope(new FormalBinding[0], classScope);
 
+		declareDecl.resolve(scope);
+		return declareDecl;
+	}
 
 	public StringBuffer print(int tab, StringBuffer output) {
 		printIndent(tab, output);
@@ -158,32 +162,31 @@ public class DeclareDeclaration extends AjMethodDeclaration {
 		}
 		return output;
 	}
-	
+
 	/**
-	 * We need the ajc$declare method that is created to represent this declare to
-	 * be marked as synthetic
+	 * We need the ajc$declare method that is created to represent this declare to be marked as synthetic
 	 */
 	protected int generateInfoAttributes(ClassFile classFile) {
-		return super.generateInfoAttributes(classFile,true);
+		return super.generateInfoAttributes(classFile, true);
 	}
 
 	public void postParse(TypeDeclaration typeDec) {
 		super.postParse(typeDec);
-		int declareSequenceNumberInType = ((AspectDeclaration)typeDec).declareCounter++;
-		//FIXME asc the name should perhaps include the hashcode of the pattern (type/sig) for binary compatibility reasons!
+		int declareSequenceNumberInType = ((AspectDeclaration) typeDec).declareCounter++;
+		// FIXME asc the name should perhaps include the hashcode of the pattern (type/sig) for binary compatibility reasons!
 		StringBuffer sb = new StringBuffer();
-	    sb.append("ajc$declare");
-        // Declares can choose to provide a piece of the name - to enable
-        // them to be easily distinguised at weave time (e.g. see declare annotation)
-        if (declareDecl!=null) {
-          String suffix = declareDecl.getNameSuffix();
-          if (suffix.length()!=0) {
-        	sb.append("_");
-        	sb.append(suffix);
-          }
-        }
-        sb.append("_");
-        sb.append(declareSequenceNumberInType);
-        this.selector = sb.toString().toCharArray();
+		sb.append("ajc$declare");
+		// Declares can choose to provide a piece of the name - to enable
+		// them to be easily distinguised at weave time (e.g. see declare annotation)
+		if (declareDecl != null) {
+			String suffix = declareDecl.getNameSuffix();
+			if (suffix.length() != 0) {
+				sb.append("_");
+				sb.append(suffix);
+			}
+		}
+		sb.append("_");
+		sb.append(declareSequenceNumberInType);
+		this.selector = sb.toString().toCharArray();
 	}
 }
@@ -232,7 +232,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		// - weaving that brings new types in for processing (see
 		// pendingTypesToWeave.add() calls) after we thought
 		// we had the full list.
-		// 
+		//
 		// but these aren't common cases (he bravely said...)
 		boolean typeProcessingOrderIsImportant = declareParents.size() > 0 || declareAnnotationOnTypes.size() > 0; // DECAT
 
@@ -588,7 +588,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 			if (!pendingTypesToWeave.contains(sourceType)) {
 				pendingTypesToWeave.add(sourceType);
 
-// inner type ITD support - may need this for some incremental cases...
+				// inner type ITD support - may need this for some incremental cases...
 				// List<ConcreteTypeMunger> ctms = factory.getWorld().getCrosscuttingMembersSet().getTypeMungersOfKind(
 				// ResolvedTypeMunger.InnerClass);
 				// // List<ConcreteTypeMunger> innerTypeMungers = new ArrayList<ConcreteTypeMunger>();
@@ -633,8 +633,8 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 
 			}
 		} else {
-			weaveInterTypeDeclarations(sourceType, factory.getTypeMungers(), factory.getDeclareParents(), factory
-					.getDeclareAnnotationOnTypes(), true);
+			weaveInterTypeDeclarations(sourceType, factory.getTypeMungers(), factory.getDeclareParents(),
+					factory.getDeclareAnnotationOnTypes(), true);
 		}
 	}
 
@@ -775,7 +775,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 					needOldStyleWarning = false;
 				}
 				onType.addInterTypeMunger(munger, true);
-				if (munger.getMunger()!=null && munger.getMunger().getKind() == ResolvedTypeMunger.InnerClass) {
+				if (munger.getMunger() != null && munger.getMunger().getKind() == ResolvedTypeMunger.InnerClass) {
 					// Must do these right now, because if we do an ITD member afterwards it may attempt to reference the
 					// type being applied (the call above 'addInterTypeMunger' will fail for these ITDs if it needed
 					// it to be in place)
@@ -791,7 +791,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		onType.checkInterTypeMungers();
 		for (Iterator i = onType.getInterTypeMungers().iterator(); i.hasNext();) {
 			EclipseTypeMunger munger = (EclipseTypeMunger) i.next();
-			if (munger.getMunger()==null || munger.getMunger().getKind() != ResolvedTypeMunger.InnerClass) {
+			if (munger.getMunger() == null || munger.getMunger().getKind() != ResolvedTypeMunger.InnerClass) {
 				if (munger.munge(sourceType, onType)) {
 					if (factory.pushinCollector != null) {
 						factory.pushinCollector.tagAsMunged(sourceType, munger.getSourceMethod());
@@ -868,8 +868,8 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 							onType.getSourceLocation(), null);
 				}
 				if (Modifier.isFinal(parent.getModifiers())) {
-					factory.showMessage(IMessage.ERROR, "cannot extend final class " + parent.getClassName(), declareParents
-							.getSourceLocation(), null);
+					factory.showMessage(IMessage.ERROR, "cannot extend final class " + parent.getClassName(),
+							declareParents.getSourceLocation(), null);
 				} else {
 					// do not actually do it if the type isn't exposed - this
 					// will correctly reported as a problem elsewhere
@@ -980,44 +980,43 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		// Might have to retrieve the annotation through BCEL and construct an
 		// eclipse one for it.
 		if (stb instanceof BinaryTypeBinding) {
-			ReferenceType rt = (ReferenceType) factory.fromEclipse(stb);
-			ResolvedMember[] methods = rt.getDeclaredMethods();
-			ResolvedMember decaMethod = null;
-			String nameToLookFor = decA.getAnnotationMethod();
-			for (int i = 0; i < methods.length; i++) {
-				if (methods[i].getName().equals(nameToLookFor)) {
-					decaMethod = methods[i];
-					break;
-				}
-			}
-			if (decaMethod != null) { // could assert this ...
-				AnnotationAJ[] axs = decaMethod.getAnnotations();
-				if (axs != null) { // another error has occurred, dont crash here because of it
-					toAdd = new Annotation[1];
-					toAdd[0] = createAnnotationFromBcelAnnotation(axs[0], decaMethod.getSourceLocation().getOffset(), factory);
-					// BUG BUG BUG - We dont test these abits are correct, in fact
-					// we'll be very lucky if they are.
-					// What does that mean? It means on an incremental compile you
-					// might get away with an
-					// annotation that isn't allowed on a type being put on a type.
-					if (toAdd[0].resolvedType != null) {
-						abits = toAdd[0].resolvedType.getAnnotationTagBits();
-					}
-				}
+			toAdd = retrieveAnnotationFromBinaryTypeBinding(decA, stb);
+			if (toAdd != null && toAdd.length > 0 && toAdd[0].resolvedType != null) {
+				abits = toAdd[0].resolvedType.getAnnotationTagBits();
 			}
 		} else if (stb != null) {
 			// much nicer, its a real SourceTypeBinding so we can stay in
 			// eclipse land
 			// if (decA.getAnnotationMethod() != null) {
-			MethodBinding[] mbs = stb.getMethods(decA.getAnnotationMethod().toCharArray());
-			abits = mbs[0].getAnnotationTagBits(); // ensure resolved
-			TypeDeclaration typeDecl = ((SourceTypeBinding) mbs[0].declaringClass).scope.referenceContext;
-			methodDecl = typeDecl.declarationOf(mbs[0]);
-			toAdd = methodDecl.annotations; // this is what to add
-			toAdd[0] = createAnnotationCopy(toAdd[0]);
-			if (toAdd[0].resolvedType != null) {
-				abits = toAdd[0].resolvedType.getAnnotationTagBits();
-				// }
+			char[] declareSelector = decA.getAnnotationMethod().toCharArray();
+
+			ReferenceBinding rb = stb;
+			String declaringAspectName = decA.getDeclaringType().getRawName();
+			while (rb != null && !new String(CharOperation.concatWith(rb.compoundName, '.')).equals(declaringAspectName)) {
+				rb = rb.superclass();
+			}
+			MethodBinding[] mbs = rb.getMethods(declareSelector);
+
+			ReferenceBinding declaringBinding = mbs[0].declaringClass;
+			if (declaringBinding instanceof ParameterizedTypeBinding) {
+				// Unwrap - this means we don't allow the type of the annotation to be parameterized, may need to revisit that
+				declaringBinding = ((ParameterizedTypeBinding) declaringBinding).type;
+			}
+			if (declaringBinding instanceof BinaryTypeBinding) {
+				toAdd = retrieveAnnotationFromBinaryTypeBinding(decA, declaringBinding);
+				if (toAdd != null && toAdd.length > 0 && toAdd[0].resolvedType != null) {
+					abits = toAdd[0].resolvedType.getAnnotationTagBits();
+				}
+			} else {
+				abits = mbs[0].getAnnotationTagBits(); // ensure resolved
+				TypeDeclaration typeDecl = ((SourceTypeBinding) declaringBinding).scope.referenceContext;
+				methodDecl = typeDecl.declarationOf(mbs[0]);
+				toAdd = methodDecl.annotations; // this is what to add
+				toAdd[0] = createAnnotationCopy(toAdd[0]);
+				if (toAdd[0].resolvedType != null) {
+					abits = toAdd[0].resolvedType.getAnnotationTagBits();
+					// }
+				}
 			}
 		}
 
@@ -1163,6 +1162,36 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		return true;
 	}
 
+	private Annotation[] retrieveAnnotationFromBinaryTypeBinding(DeclareAnnotation decA, ReferenceBinding declaringBinding) {
+		ReferenceType rt = (ReferenceType) factory.fromEclipse(declaringBinding);
+		ResolvedMember[] methods = rt.getDeclaredMethods();
+		ResolvedMember decaMethod = null;
+		String nameToLookFor = decA.getAnnotationMethod();
+		for (int i = 0; i < methods.length; i++) {
+			if (methods[i].getName().equals(nameToLookFor)) {
+				decaMethod = methods[i];
+				break;
+			}
+		}
+		if (decaMethod != null) { // could assert this ...
+			AnnotationAJ[] axs = decaMethod.getAnnotations();
+			if (axs != null) { // another error has occurred, dont crash here because of it
+				Annotation[] toAdd = new Annotation[1];
+				toAdd[0] = createAnnotationFromBcelAnnotation(axs[0], decaMethod.getSourceLocation().getOffset(), factory);
+				// BUG BUG BUG - We dont test these abits are correct, in fact
+				// we'll be very lucky if they are.
+				// What does that mean? It means on an incremental compile you
+				// might get away with an
+				// annotation that isn't allowed on a type being put on a type.
+				// if (toAdd[0].resolvedType != null) {
+				// abits = toAdd[0].resolvedType.getAnnotationTagBits();
+				// }
+				return toAdd;
+			}
+		}
+		return null;
+	}
+
 	/**
 	 * Transform an annotation from its AJ form to an eclipse form. We *DONT* care about the values of the annotation. that is
 	 * because it is only being stuck on a type during type completion to allow for other constructs (decps, decas) that might be
@@ -1244,9 +1273,13 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 			}
 			filename = filename.substring(takefrom + 1);
 
-			factory.getWorld().getMessageHandler().handleMessage(
-					WeaveMessage.constructWeavingMessage(wmk, new String[] { CharOperation.toString(sourceType.compoundName),
-							filename, parent.getClassName(), getShortname(parent.getSourceLocation().getSourceFile().getPath()) }));
+			factory.getWorld()
+					.getMessageHandler()
+					.handleMessage(
+							WeaveMessage.constructWeavingMessage(wmk,
+									new String[] { CharOperation.toString(sourceType.compoundName), filename,
+											parent.getClassName(),
+											getShortname(parent.getSourceLocation().getSourceFile().getPath()) }));
 		}
 	}
 
@@ -1389,7 +1422,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 // System.err.println("Looking for anything that might match "+element+" on "+
 // sourceType.debugName()+"  "+getType(sourceType.
 // compoundName).debugName()+"  "+(sourceType instanceof BinaryTypeBinding));
-//		
+//
 // ReferenceBinding rbb = getType(sourceType.compoundName);
 // // fix me if we ever uncomment this code... should iterate the other way
 // round, over the methods then over the decas
@@ -1401,17 +1434,17 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 // ((SourceTypeBinding)rbb).getExactMethod(sourceMb.selector
 // ,sourceMb.parameters);
 // boolean isCtor = sourceMb.selector[0]=='<';
-//			
+//
 // if ((element.isDeclareAtConstuctor() ^ !isCtor)) {
 // System.err.println("Checking "+sourceMb+" ... declaringclass="+sourceMb.
 // declaringClass.debugName()+" rbb="+rbb.debugName()+"  "+
 // sourceMb.declaringClass.equals(rbb));
-//			
+//
 // ResolvedMember rm = null;
 // rm = EclipseFactory.makeResolvedMember(mbbbb);
 // if (element.matches(rm,factory.getWorld())) {
 // System.err.println("MATCH");
-//				
+//
 // // Determine the set of annotations that are currently on the method
 // ReferenceBinding rb = getType(sourceType.compoundName);
 // // TypeBinding tb = factory.makeTypeBinding(decA.getAspect());
@@ -1424,7 +1457,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 // AbstractMethodDeclaration methodDecl = typeDecl.declarationOf(sourceMb);
 // Annotation[] currentlyHas = methodDecl.annotations; // this is what to add
 // //abits = toAdd[0].resolvedType.getAnnotationTagBits();
-//				
+//
 // // Determine the annotations to add to that method
 // TypeBinding tb = factory.makeTypeBinding(element.getAspect());
 // MethodBinding[] aspectMbs =
@@ -1438,7 +1471,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 // Annotation[] toAdd = methodDecl2.annotations; // this is what to add
 // // abits = toAdd[0].resolvedType.getAnnotationTagBits();
 // System.err.println("Has: "+currentlyHas+"    toAdd: "+toAdd);
-//				
+//
 // // fix me? should check if it already has the annotation
 // //Annotation abefore[] = sourceType.scope.referenceContext.annotations;
 // Annotation[] newset = new
@@ -1473,7 +1506,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 // System.err.println("Processing deca "+element+" on "+sourceType.debugName()+
 // "  "+getType(sourceType.compoundName).debugName()+"  "
 // +(sourceType instanceof BinaryTypeBinding));
-//				
+//
 // ReferenceBinding rbb = getType(sourceType.compoundName);
 // // fix me? should iterate the other way round, over the methods then over the
 // decas
@@ -1484,15 +1517,15 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 // //FieldBinding fbbbb =
 // ((SourceTypeBinding)rbb).getgetExactMethod(sourceMb.selector
 // ,sourceMb.parameters);
-//					
+//
 // System.err.println("Checking "+sourceFb+" ... declaringclass="+sourceFb.
 // declaringClass.debugName()+" rbb="+rbb.debugName());
-//					
+//
 // ResolvedMember rm = null;
 // rm = EclipseFactory.makeResolvedMember(sourceFb);
 // if (element.matches(rm,factory.getWorld())) {
 // System.err.println("MATCH");
-//						
+//
 // // Determine the set of annotations that are currently on the field
 // ReferenceBinding rb = getType(sourceType.compoundName);
 // // TypeBinding tb = factory.makeTypeBinding(decA.getAspect());
@@ -1504,7 +1537,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 // //AbstractMethodDeclaration methodDecl = typeDecl.declarationOf(sourceMb);
 // Annotation[] currentlyHas = fd.annotations; // this is what to add
 // //abits = toAdd[0].resolvedType.getAnnotationTagBits();
-//						
+//
 // // Determine the annotations to add to that method
 // TypeBinding tb = factory.makeTypeBinding(element.getAspect());
 // MethodBinding[] aspectMbs =
@@ -1518,7 +1551,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 // Annotation[] toAdd = methodDecl2.annotations; // this is what to add
 // // abits = toAdd[0].resolvedType.getAnnotationTagBits();
 // System.err.println("Has: "+currentlyHas+"    toAdd: "+toAdd);
-//						
+//
 // // fix me? check if it already has the annotation
 //
 //
@@ -1535,6 +1568,6 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 // } else
 // System.err.println("NO MATCH");
 // }
-//			
+//
 // }
 // }
@@ -0,0 +1,9 @@
+import java.lang.annotation.*;
+
+public abstract aspect Base {
+  declare @type: F*: @Anno;
+}
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Anno {
+}
@@ -0,0 +1,9 @@
+import java.lang.annotation.*;
+
+public abstract aspect Base2<B> {
+  declare @type: F*: @Anno;
+}
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Anno {
+}
@@ -0,0 +1,8 @@
+public class F1 {
+  public static void main(String []argv) throws Exception {
+    System.out.println(F1.class.getAnnotations()[0]);
+  }
+}
+
+aspect X extends Base {
+}
@@ -0,0 +1,8 @@
+public class F2 {
+  public static void main(String []argv) throws Exception {
+    System.out.println(F2.class.getAnnotations()[0]);
+  }
+}
+
+aspect X extends Base2<String> {
+}
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008 Contributors 
+ * Copyright (c) 2008 Contributors
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -18,7 +18,14 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc1610Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
-	// Interesting new behaviour on AspectJ 1.6.9 - probably due to initial inner type changes.  
+	public void testAbstractAspectAndDeclares_322272_2() {
+		runTest("abstract aspects and declares - 2");
+	}
+
+	public void testAbstractAspectAndDeclares_322272() {
+		runTest("abstract aspects and declares");
+	}
+	// Interesting new behaviour on AspectJ 1.6.9 - probably due to initial inner type changes.
 	// Looks a real error (creating two annotations the same on a type is a bad thing)
 	//	public void testDuplicateAnnotations() {
 	//		runTest("duplicate annotation");
@@ -12,4 +12,26 @@
     </compile>
   </ajc-test>
 
+  <ajc-test dir="bugs1610/pr322272" title="abstract aspects and declares">
+    <compile files="Base.java" outjar="superaspect.jar" options="-1.5"/>
+    <compile files="F1.java" classpath="superaspect.jar" options="-1.5">
+    </compile>
+    <run class="F1">
+    <stdout>
+    <line text="@Anno()"/>
+    </stdout>
+    </run>
+  </ajc-test>
+  
+  <ajc-test dir="bugs1610/pr322272" title="abstract aspects and declares - 2">
+    <compile files="Base2.java" outjar="superaspect.jar" options="-1.5"/>
+    <compile files="F2.java" classpath="superaspect.jar" options="-1.5">
+    </compile>
+    <run class="F2">
+    <stdout>
+    <line text="@Anno()"/>
+    </stdout>
+    </run>
+  </ajc-test>
+  
 </suite>
\ No newline at end of file
