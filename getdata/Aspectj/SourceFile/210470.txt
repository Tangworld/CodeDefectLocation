@@ -11,8 +11,13 @@
  *******************************************************************************/
 package org.aspectj.weaver.loadtime;
 
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
 import java.util.Map;
-import java.util.WeakHashMap;
+import java.util.Set;
 
 import org.aspectj.bridge.context.CompilationAndWeavingContext;
 import org.aspectj.weaver.Dump;
@@ -29,7 +34,14 @@ import org.aspectj.weaver.tools.WeavingAdaptor;
 public class Aj implements ClassPreProcessor {
 
 	private IWeavingContext weavingContext;
-	
+
+    /**
+     * References are added to this queue when their associated classloader is removed, and once on here that indicates
+     * that we should tidy up the adaptor map and remove the adaptor (weaver) from the map we are maintaining from
+     * adaptorkey > adaptor (weaver)
+     */
+    private static ReferenceQueue adaptorQueue = new ReferenceQueue();
+
 	private static Trace trace = TraceFactory.getTraceFactory().getTrace(Aj.class);
 
 	public Aj(){
@@ -96,19 +108,127 @@ public class Aj implements ClassPreProcessor {
     }
 
     /**
+     * An AdaptorKey is a WeakReference wrapping a classloader reference that will enqueue to a specified queue when the
+     * classloader is GC'd. Since the AdaptorKey is used as a key into a hashmap we need to give it a non-varying
+     * hashcode/equals implementation, and we need that hashcode not to vary even when the internal referent has been
+     * GC'd. The hashcode is calculated on creation of the AdaptorKey based on the loader instance that it is wrapping.
+     * This means even when the referent is gone we can still use the AdaptorKey and it will 'point' to the same place
+     * as it always did.
+     */
+    private static class AdaptorKey extends WeakReference {
+
+        private int hashcode = -1;
+
+        public AdaptorKey(ClassLoader loader) {
+            super(loader, adaptorQueue);
+            hashcode = loader.hashCode() * 37;
+        }
+
+        public ClassLoader getClassLoader() {
+            ClassLoader instance = (ClassLoader) get();
+            // Assert instance!=null - shouldn't be asked for after a GC of the referent has occurred !
+            return instance;
+        }
+
+        public boolean equals(Object obj) {
+            if (!(obj instanceof AdaptorKey)) return false;
+            AdaptorKey other = (AdaptorKey) obj;
+            return other.hashcode == hashcode;
+        }
+            
+        public int hashCode() {
+            return hashcode;
+        }
+
+    }
+
+    /**
+     * The reference queue is only processed when a request is made for a weaver adaptor. This means there can be one or
+     * two stale weavers left around. If the user knows they have finished all their weaving, they might wish to call
+     * removeStaleAdaptors which will process anything left on the reference queue containing adaptorKeys for garbage
+     * collected classloaders.
+     * 
+     * @param displayProgress produce System.err info on the tidying up process
+     * @return number of stale weavers removed
+     */
+    public static int removeStaleAdaptors(boolean displayProgress) {
+        int removed = 0;
+        synchronized (WeaverContainer.weavingAdaptors) {
+            if (displayProgress) {
+                System.err.println("Weaver adaptors before queue processing:");
+                Map m = WeaverContainer.weavingAdaptors;
+                Set keys = m.keySet();
+                for (Iterator iterator = keys.iterator(); iterator.hasNext();) {
+                    Object object = (Object) iterator.next();
+                    System.err.println(object + " = " + WeaverContainer.weavingAdaptors.get(object));
+                }
+            }
+            Object o = adaptorQueue.poll();
+            while (o != null) {
+                if (displayProgress) System.err.println("Processing referencequeue entry " + o);
+                AdaptorKey wo = (AdaptorKey) o;
+                boolean didit = WeaverContainer.weavingAdaptors.remove(wo) != null;
+                if (didit) {
+                    removed++;
+                } else {
+                    throw new RuntimeException("Eh?? key="+wo);
+                }
+                if (displayProgress) System.err.println("Removed? "+didit);
+                o = adaptorQueue.poll();
+            }
+            if (displayProgress) {
+                System.err.println("Weaver adaptors after queue processing:");
+                Map m = WeaverContainer.weavingAdaptors;
+                Set keys = m.keySet();
+                for (Iterator iterator = keys.iterator(); iterator.hasNext();) {
+                    Object object = (Object) iterator.next();
+                    System.err.println(object + " = " + WeaverContainer.weavingAdaptors.get(object));
+                }
+            }
+        }
+        return removed;
+    }
+    
+    /**
+     * @return the number of entries still in the weavingAdaptors map
+     */
+    public static int getActiveAdaptorCount() {
+        return WeaverContainer.weavingAdaptors.size();
+    }
+
+    /**
+     * Process the reference queue that contains stale AdaptorKeys - the keys are put on the queue when their
+     * classloader referent is garbage collected and so the associated adaptor (weaver) should be removed from the map
+     */
+    public static void checkQ() {
+        synchronized (adaptorQueue) {
+            Object o = adaptorQueue.poll();
+            while (o != null) {
+                AdaptorKey wo = (AdaptorKey) o;
+                boolean removed = WeaverContainer.weavingAdaptors.remove(wo) != null;
+                // DBG System.err.println("Evicting key " + wo + " = " + didit);
+                o = adaptorQueue.poll();
+            }
+        }
+    }
+
+    /**
      * Cache of weaver
      * There is one weaver per classloader
      */
     static class WeaverContainer {
 
-        private final static Map weavingAdaptors = new WeakHashMap();
+        final static Map weavingAdaptors = Collections.synchronizedMap(new HashMap());
 
         static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingContext) {
             ExplicitlyInitializedClassLoaderWeavingAdaptor adaptor = null;
-            synchronized(weavingAdaptors) {
-                adaptor = (ExplicitlyInitializedClassLoaderWeavingAdaptor) weavingAdaptors.get(loader);
+            AdaptorKey adaptorKey = new AdaptorKey(loader);
+
+            synchronized (weavingAdaptors) {
+                checkQ();
+                adaptor = (ExplicitlyInitializedClassLoaderWeavingAdaptor) weavingAdaptors.get(adaptorKey);
                 if (adaptor == null) {
-                	String loaderClassName = loader.getClass().getName(); 
+                    String loaderClassName = loader.getClass().getName(); 
                 	if (loaderClassName.equals("sun.reflect.DelegatingClassLoader")) {
                 		// we don't weave reflection generated types at all! 
                 		return null;
@@ -117,25 +237,13 @@ public class Aj implements ClassPreProcessor {
 	                    // within the synchronized block
 	                    ClassLoaderWeavingAdaptor weavingAdaptor = new ClassLoaderWeavingAdaptor();
 	                    adaptor = new ExplicitlyInitializedClassLoaderWeavingAdaptor(weavingAdaptor);
-	                    weavingAdaptors.put(loader, adaptor);
-                	}
+                        weavingAdaptors.put(adaptorKey, adaptor);
+                    }
                 }
             }
             // perform the initialization
             return adaptor.getWeavingAdaptor(loader, weavingContext);
 
-
-            // old version
-//            synchronized(loader) {//FIXME AV - temp fix for #99861
-//                synchronized (weavingAdaptors) {
-//                    WeavingAdaptor weavingAdaptor = (WeavingAdaptor) weavingAdaptors.get(loader);
-//                    if (weavingAdaptor == null) {
-//                        weavingAdaptor = new ClassLoaderWeavingAdaptor(loader, weavingContext);
-//                        weavingAdaptors.put(loader, weavingAdaptor);
-//                    }
-//                    return weavingAdaptor;
-//                }
-//            }
         }
     }
 
@@ -145,6 +145,7 @@ public class WeavingURLClassLoader extends ExtensibleURLClassLoader implements W
 
 			/* Ensures consistent LTW messages for testing */
 			public String getClassLoaderName() {
+				ClassLoader loader = getClassLoader();
 				return loader.getClass().getName();
 			}
 
@@ -37,6 +37,7 @@ import org.aspectj.weaver.ICrossReferenceHandler;
 import org.aspectj.weaver.Lint;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
+import org.aspectj.weaver.WeakClassLoaderReference;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.Lint.Kind;
 import org.aspectj.weaver.bcel.BcelWeaver;
@@ -96,12 +97,35 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
     	if (trace.isTraceEnabled()) trace.enter("<init>",this,new Object[] { deprecatedLoader, deprecatedContext });
     	if (trace.isTraceEnabled()) trace.exit("<init>");
     }
+    
+   class SimpleGeneratedClassHandler implements GeneratedClassHandler {
+    	private WeakClassLoaderReference loaderRef;
+    	SimpleGeneratedClassHandler(ClassLoader loader) {
+    		loaderRef = new WeakClassLoaderReference(loader);
+    	}
+
+        /**
+         * Callback when we need to define a Closure in the JVM
+         *
+         */
+        public void acceptClass(String name, byte[] bytes) {
+            try {
+                if (shouldDump(name.replace('/', '.'), false)) {
+                    dump(name, bytes, false);
+                }
+            } catch (Throwable throwable) {
+                throwable.printStackTrace();
+            }
+
+            defineClass(loaderRef.getClassLoader(), name, bytes); // could be done lazily using the hook
+        }
+    };
 
     protected void initialize (final ClassLoader classLoader, IWeavingContext context) {
     	if (initialized) return;
 
     	boolean success = true;
-    	if (trace.isTraceEnabled()) trace.enter("initialize",this,new Object[] { classLoader, context });
+        //    	if (trace.isTraceEnabled()) trace.enter("initialize",this,new Object[] { classLoader, context });
 
     	this.weavingContext = context;
         if (weavingContext == null) {
@@ -110,25 +134,8 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 
         createMessageHandler();
 
-        this.generatedClassHandler = new GeneratedClassHandler() {
-            /**
-             * Callback when we need to define a Closure in the JVM
-             *
-             * @param name
-             * @param bytes
-             */
-            public void acceptClass(String name, byte[] bytes) {
-                try {
-                    if (shouldDump(name.replace('/', '.'), false)) {
-                        dump(name, bytes, false);
-                    }
-                } catch (Throwable throwable) {
-                    throwable.printStackTrace();
-                }
-
-                defineClass(classLoader, name, bytes);// could be done lazily using the hook
-            }
-        };
+        this.generatedClassHandler = 
+        	new SimpleGeneratedClassHandler(classLoader);
 
         List definitions = weavingContext.getDefinitions(classLoader,this);
         if (definitions.isEmpty()) {
@@ -179,7 +186,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
      * @param loader
      */
     List parseDefinitions(final ClassLoader loader) {
-        if (trace.isTraceEnabled()) trace.enter("parseDefinitions",this,loader);
+        if (trace.isTraceEnabled()) trace.enter("parseDefinitions", this);
 
         List definitions = new ArrayList();
     	try {
@@ -16,6 +16,7 @@ import java.net.URL;
 import java.util.Enumeration;
 import java.util.List;
 
+import org.aspectj.weaver.WeakClassLoaderReference;
 import org.aspectj.weaver.tools.Trace;
 import org.aspectj.weaver.tools.TraceFactory;
 import org.aspectj.weaver.tools.WeavingAdaptor;
@@ -27,26 +28,26 @@ import org.aspectj.weaver.tools.WeavingAdaptor;
  */
 public class DefaultWeavingContext implements IWeavingContext {
 
-	protected ClassLoader loader;
+	protected WeakClassLoaderReference loaderRef;
 	private String shortName;
 
 	private static Trace trace = TraceFactory.getTraceFactory().getTrace(DefaultWeavingContext.class);
 
 	/**
-	 * Construct a new WeavingContext to use the specifed ClassLoader
+	 * Construct a new WeavingContext to use the specified ClassLoader
 	 * This is the constructor which should be used.
 	 * @param loader
 	 */
 	public DefaultWeavingContext(ClassLoader loader) {
 		super();
-		this.loader = loader;
+		this.loaderRef = new WeakClassLoaderReference(loader);
 	}
 
 	/**
 	 * Same as ClassLoader.getResources()
 	 */
 	public Enumeration getResources(String name) throws IOException {
-		return loader.getResources(name);
+		return getClassLoader().getResources(name);
 	}
 
 	/**
@@ -60,8 +61,14 @@ public class DefaultWeavingContext implements IWeavingContext {
 	 * @return classname@hashcode
 	 */
 	public String getClassLoaderName() {
+		ClassLoader loader = getClassLoader();
     	return ((loader!=null)?loader.getClass().getName()+"@"+Integer.toHexString(System.identityHashCode(loader)):"null");
 	}
+	
+
+	public ClassLoader getClassLoader() { 
+		return loaderRef.getClassLoader();
+	}
 
 	/**
 	 * @return filename
@@ -88,11 +95,12 @@ public class DefaultWeavingContext implements IWeavingContext {
 
 	public boolean isLocallyDefined(String classname) {
         String asResource = classname.replace('.', '/').concat(".class");
-
+        ClassLoader loader = getClassLoader();
         URL localURL = loader.getResource(asResource);
         if (localURL == null) return false;
 
 		boolean isLocallyDefined = true;
+		
         ClassLoader parent = loader.getParent();
         if (parent != null) {
             URL parentURL = parent.getResource(asResource);
@@ -108,7 +116,7 @@ public class DefaultWeavingContext implements IWeavingContext {
 	 * @param loader
 	 */
 	public List getDefinitions(final ClassLoader loader, final WeavingAdaptor adaptor) {
-	        if (trace.isTraceEnabled()) trace.enter("getDefinitions",this,new Object[] { loader, adaptor });
+	        if (trace.isTraceEnabled()) trace.enter("getDefinitions", this, new Object[] { "goo", adaptor });
 
 	        List definitions = ((ClassLoaderWeavingAdaptor)adaptor).parseDefinitions(loader);
 
@@ -28,6 +28,7 @@ import org.aspectj.weaver.IntMap;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.Shadow;
 import org.aspectj.weaver.UnresolvedType;
+import org.aspectj.weaver.WeakClassLoaderReference;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.bcel.AtAjAttributes;
 import org.aspectj.weaver.internal.tools.PointcutExpressionImpl;
@@ -56,7 +57,7 @@ import org.aspectj.weaver.reflect.ReflectionWorld;
 public class PointcutParser {
 
 	private ReflectionWorld world;
-	private ClassLoader classLoader;
+	private WeakClassLoaderReference classLoaderReference;
     private Set supportedPrimitives; 
     private Set pointcutDesignators = new HashSet();
 
@@ -224,8 +225,8 @@ public class PointcutParser {
      * @param aLoader
      */
     protected void setClassLoader(ClassLoader aLoader) {
-    	this.classLoader = aLoader;
-    	world = new ReflectionWorld(this.classLoader);
+    	this.classLoaderReference = new WeakClassLoaderReference(aLoader);
+    	world = new ReflectionWorld(this.classLoaderReference.getClassLoader());
     }
 
     /**
@@ -235,7 +236,7 @@ public class PointcutParser {
      * lint properties
      */
     public void setLintProperties(String resourcePath)throws IOException {
-    	URL url = this.classLoader.getResource(resourcePath);
+    	URL url = this.classLoaderReference.getClassLoader().getResource(resourcePath);
     	InputStream is = url.openStream();
     	Properties p = new Properties();
 		p.load(is);
@@ -11,8 +11,6 @@
  * ******************************************************************/
 package org.aspectj.weaver.ltw;
 
-import java.lang.ref.Reference;
-import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -51,26 +49,39 @@ import org.aspectj.weaver.reflect.ReflectionWorld;
 public class LTWWorld extends BcelWorld implements IReflectionWorld {
 
 	private AnnotationFinder annotationFinder;
-    private ClassLoader loader; // weavingContext?
     private IWeavingContext weavingContext;
+    private String classLoaderString;
+
+    private String classLoaderParentString;
 
-    protected final static Class concurrentMapClass = makeConcurrentMapClass();
-    protected static Map/*<String, WeakReference<ReflectionBasedReferenceTypeDelegate>>*/ bootstrapTypes = makeConcurrentMap();
+    protected final static Class concurrentMapClass; 
+
+    private static final boolean ShareBootstrapTypes = false;
+    protected static Map/* <String, WeakReference<ReflectionBasedReferenceTypeDelegate>> */bootstrapTypes;
+
+    static {
+        if (ShareBootstrapTypes) {
+            concurrentMapClass = makeConcurrentMapClass();
+            bootstrapTypes = makeConcurrentMap();
+        } else {
+            concurrentMapClass = null;
+        }
+    }
 
     /**
      * Build a World from a ClassLoader, for LTW support
      */
     public LTWWorld(ClassLoader loader, IWeavingContext weavingContext, IMessageHandler handler, ICrossReferenceHandler xrefHandler) {
         super(loader, handler, xrefHandler);
-        this.loader = loader;
         this.weavingContext = weavingContext;
-        
+        classLoaderString = loader.toString();
+        classLoaderParentString = (loader.getParent() == null ? "<NullParent>" : loader.getParent().toString());
         setBehaveInJava5Way(LangUtil.is15VMOrGreater());
         annotationFinder = ReflectionWorld.makeAnnotationFinderIfAny(loader, this);
     }
 
 	public ClassLoader getClassLoader() {
-        return this.loader;
+        return weavingContext.getClassLoader();
     }
 
     //TEST
@@ -99,33 +110,36 @@ public class LTWWorld extends BcelWorld implements IReflectionWorld {
 
     protected ReferenceTypeDelegate resolveIfBootstrapDelegate(ReferenceType ty) {
         // first check for anything available in the bootstrap loader: these types are just defined from that without allowing nondelegation
-    	String name = ty.getName();
-        Reference bootRef = (Reference)bootstrapTypes.get(name);
-        if (bootRef != null) {        	
-        	ReferenceTypeDelegate rtd = (ReferenceTypeDelegate)bootRef.get();
-        	if (rtd != null) {
-        		return rtd;
-        	}
-        }
-
-        char fc = name.charAt(0);
-        if (fc=='j' || fc=='c' || fc=='o' || fc=='s') { // cheaper than imminent string startsWith tests
-	        if (name.startsWith("java") || name.startsWith("com.sun.") || name.startsWith("org.w3c") || 
-	        	name.startsWith("sun.") || name.startsWith("org.omg")) {
-		        ReferenceTypeDelegate bootstrapLoaderDelegate = resolveReflectionTypeDelegate(ty, null);
-		        if (bootstrapLoaderDelegate != null) {
-		            // it's always fine to load these bytes: there's no weaving into them
-		            // and since the class isn't initialized, all we are doing at this point is loading the bytes
-		            //processedRefTypes.put(ty, this); // has no effect - and probably too aggressive if we did store these in the type map            
-		        	// should we share these, like we do the BCEL delegates?
-		        	bootstrapTypes.put(ty.getName(), new WeakReference(bootstrapLoaderDelegate));
-		        }    	
-		        return bootstrapLoaderDelegate;
-	        }
-        }
+// if (!ShareBootstrapTypes) return null;
+// String name = ty.getName();
+        // Reference bootRef = (Reference) bootstrapTypes.get(name);
+        // if (bootRef != null) {
+        // ReferenceTypeDelegate rtd = (ReferenceTypeDelegate) bootRef.get();
+        // if (rtd != null) {
+        // return rtd;
+        // }
+        // }
+        //
+        // char fc = name.charAt(0);
+        // if (fc == 'j' || fc == 'c' || fc == 'o' || fc == 's') { // cheaper than imminent string startsWith tests
+        // if (name.startsWith("java") || name.startsWith("com.sun.") || name.startsWith("org.w3c") ||
+        // name.startsWith("sun.") || name.startsWith("org.omg")) {
+        // ReferenceTypeDelegate bootstrapLoaderDelegate = resolveReflectionTypeDelegate(ty, null);
+        // if (bootstrapLoaderDelegate != null) {
+        // // it's always fine to load these bytes: there's no weaving into them
+        // // and since the class isn't initialized, all we are doing at this point is loading the bytes
+        // // processedRefTypes.put(ty, this); // has no effect - and probably too aggressive if we did store
+        // // these in the type map
+        //
+        // // should we share these, like we do the BCEL delegates?
+        // bootstrapTypes.put(ty.getName(), new WeakReference(bootstrapLoaderDelegate));
+        // }
+        // return bootstrapLoaderDelegate;
+        // }
+        // }
         return null;
     }
-    
+
     /**
      * Helper method to resolve the delegate from the reflection delegate factory.
      */
@@ -241,7 +255,7 @@ public class LTWWorld extends BcelWorld implements IReflectionWorld {
 		if (ret.isParameterizedType() || ret.isGenericType()) {
 			toResolve = toResolve.getGenericType();
 		}
-		ReferenceTypeDelegate rtd = resolveReflectionTypeDelegate((ReferenceType)toResolve,loader);
+		ReferenceTypeDelegate rtd = resolveReflectionTypeDelegate((ReferenceType)toResolve,getClassLoader());
 		((ReferenceType)ret).setDelegate(rtd);
 		return ret;
 	}
@@ -253,9 +267,9 @@ public class LTWWorld extends BcelWorld implements IReflectionWorld {
 
 	public void accept(IVisitor visitor) {
 		visitor.visitObject("Class loader:");
-		visitor.visitObject(loader);
+		visitor.visitObject(classLoaderString);
 		visitor.visitObject("Class loader parent:");
-		visitor.visitObject(loader.getParent());
+		visitor.visitObject(classLoaderParentString);
 		super.accept(visitor);
 	}
 
@@ -151,6 +151,8 @@ public class WeavingContextTest extends TestCase {
 		public String getClassLoaderName() {
 			return "ClassLoaderName";
 		}
+		
+		public ClassLoader getClassLoader() { return this.loader;}
 
 		public String getFile(URL url) {
 			return "File";
@@ -31,6 +31,7 @@ import org.aspectj.apache.bcel.util.Repository;
 import org.aspectj.weaver.AnnotationX;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
+import org.aspectj.weaver.WeakClassLoaderReference;
 import org.aspectj.weaver.World;
 
 /**
@@ -40,7 +41,7 @@ import org.aspectj.weaver.World;
 public class Java15AnnotationFinder implements AnnotationFinder, ArgNameFinder {
 
 	private Repository bcelRepository;
-	private ClassLoader classLoader;
+	private WeakClassLoaderReference classLoaderRef;
 	private World world;
 
 	// must have no-arg constructor for reflective construction
@@ -50,8 +51,8 @@ public class Java15AnnotationFinder implements AnnotationFinder, ArgNameFinder {
 	public void setClassLoader(ClassLoader aLoader) {
 		// TODO: No easy way to ask the world factory for the right kind of repository so
 		// default to the safe one! (pr160674)
-		this.bcelRepository = new NonCachingClassLoaderRepository(aLoader);
-		this.classLoader = aLoader;		
+        this.classLoaderRef = new WeakClassLoaderReference(aLoader);
+        this.bcelRepository = new NonCachingClassLoaderRepository(classLoaderRef);
 	}
 
 	public void setWorld(World aWorld) {
@@ -63,7 +64,8 @@ public class Java15AnnotationFinder implements AnnotationFinder, ArgNameFinder {
 	 */
 	public Object getAnnotation(ResolvedType annotationType, Object onObject) {
 		try {
-			Class<? extends Annotation> annotationClass = (Class<? extends Annotation>) Class.forName(annotationType.getName(),false,classLoader);
+			Class<? extends Annotation> annotationClass = (Class<? extends Annotation>) Class.forName(annotationType.getName(), false,
+                getClassLoader());
 			if (onObject.getClass().isAnnotationPresent(annotationClass)) {
 				return onObject.getClass().getAnnotation(annotationClass);
 			}
@@ -75,7 +77,7 @@ public class Java15AnnotationFinder implements AnnotationFinder, ArgNameFinder {
 
 	public Object getAnnotationFromClass(ResolvedType annotationType, Class aClass) {
 		try {
-			Class<? extends Annotation> annotationClass = (Class<? extends Annotation>) Class.forName(annotationType.getName(),false,classLoader);
+			Class<? extends Annotation> annotationClass = (Class<? extends Annotation>) Class.forName(annotationType.getName(),false,getClassLoader());
 			if (aClass.isAnnotationPresent(annotationClass)) {
 				return aClass.getAnnotation(annotationClass);
 			}
@@ -89,7 +91,7 @@ public class Java15AnnotationFinder implements AnnotationFinder, ArgNameFinder {
 		if (!(aMember instanceof AccessibleObject)) return null;
 		AccessibleObject ao = (AccessibleObject) aMember;
 		try {
-			Class annotationClass = Class.forName(annotationType.getName(),false,classLoader);
+			Class annotationClass = Class.forName(annotationType.getName(),false,getClassLoader());
 			if (ao.isAnnotationPresent(annotationClass)) {
 				return ao.getAnnotation(annotationClass);
 			}
@@ -99,6 +101,10 @@ public class Java15AnnotationFinder implements AnnotationFinder, ArgNameFinder {
 		return null;
 	}
 
+	private ClassLoader getClassLoader() {
+		return classLoaderRef.getClassLoader();
+	}
+
 	public AnnotationX getAnnotationOfType(UnresolvedType ofType,Member onMember) {
 		if (!(onMember instanceof AccessibleObject)) return null;
 		// here we really want both the runtime visible AND the class visible annotations
@@ -66,7 +66,7 @@ public class Java15ReflectionBasedReferenceTypeDelegate extends
 		myType = AjTypeSystem.getAjType(aClass);
 		annotationFinder = new Java15AnnotationFinder();
 		argNameFinder = annotationFinder;
-		annotationFinder.setClassLoader(this.classLoader);
+		annotationFinder.setClassLoader(this.classLoaderReference.getClassLoader());
 		annotationFinder.setWorld(aWorld);
 		this.typeConverter = new JavaLangTypeToResolvedTypeConverter(aWorld);
 	}
@@ -253,9 +253,9 @@ public class Java15ReflectionBasedReferenceTypeDelegate extends
 			InternalUseOnlyPointcutParser parser = null;
 			World world = getWorld();
 			if (world instanceof ReflectionWorld) {
-				parser = new InternalUseOnlyPointcutParser(classLoader,(ReflectionWorld)getWorld());
+				parser = new InternalUseOnlyPointcutParser(classLoaderReference.getClassLoader(), (ReflectionWorld) getWorld());
 			} else {
-				parser = new InternalUseOnlyPointcutParser(classLoader);
+				parser = new InternalUseOnlyPointcutParser(classLoaderReference.getClassLoader());
 			}
 			Set additionalPointcutHandlers = world.getRegisteredPointcutHandlers();
             for (Iterator handlerIterator = additionalPointcutHandlers.iterator(); handlerIterator.hasNext();) {
@@ -44,7 +44,7 @@ public class ClassLoaderRepositoryTests extends TestCase {
 	}
 
 	public void tearDown() {
-		 new ClassLoaderRepository(null).reset();
+		 new ClassLoaderRepository((ClassLoader) null).reset();
 	}
 
 	private ClassLoaderRepository setupRepository() throws Exception {
@@ -30,6 +30,7 @@ import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.SourceContextImpl;
 import org.aspectj.weaver.TypeVariable;
 import org.aspectj.weaver.UnresolvedType;
+import org.aspectj.weaver.WeakClassLoaderReference;
 import org.aspectj.weaver.WeaverStateInfo;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.patterns.PerClause;
@@ -42,10 +43,10 @@ import org.aspectj.weaver.patterns.PerClause;
  */
 public class ReflectionBasedReferenceTypeDelegate implements ReferenceTypeDelegate {
 
-	private static final ClassLoader BootClassLoader = new URLClassLoader(new URL[0]);
+	private static final ClassLoader BootClassLoader = new URLClassLoader(new URL[0]);// ReflectionBasedReferenceTypeDelegate.class.getClassLoader();
 
 	protected Class myClass = null;
-	protected ClassLoader classLoader = null;
+	protected WeakClassLoaderReference classLoaderReference = null;
 	private World world;
 	private ReferenceType resolvedType;
 	private ResolvedMember[] fields = null;
@@ -63,7 +64,7 @@ public class ReflectionBasedReferenceTypeDelegate implements ReferenceTypeDelega
 		this.myClass = aClass;
 		this.resolvedType = aType;
 		this.world = aWorld;
-		this.classLoader = (aClassLoader != null) ? aClassLoader : BootClassLoader;
+		this.classLoaderReference = new WeakClassLoaderReference((aClassLoader != null) ? aClassLoader : BootClassLoader);
 	}
 
 	protected Class getBaseClass() { 
@@ -25,6 +25,7 @@ import org.aspectj.weaver.ResolvedMember;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.ResolvedTypeMunger;
 import org.aspectj.weaver.UnresolvedType;
+import org.aspectj.weaver.WeakClassLoaderReference;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.AjAttribute.AdviceAttribute;
 import org.aspectj.weaver.patterns.Pointcut;
@@ -38,23 +39,23 @@ import org.aspectj.weaver.patterns.PerClause.Kind;
  */
 public class ReflectionWorld extends World implements IReflectionWorld {
 
-	private ClassLoader classLoader;
+	private WeakClassLoaderReference classLoaderReference;
 	private AnnotationFinder annotationFinder;
 
 	private ReflectionWorld() {
 		super();
 		this.setMessageHandler(new ExceptionBasedMessageHandler());
 		setBehaveInJava5Way(LangUtil.is15VMOrGreater());
-		this.classLoader = ReflectionWorld.class.getClassLoader();
-		this.annotationFinder = makeAnnotationFinderIfAny(classLoader, this);
+		this.classLoaderReference = new WeakClassLoaderReference(ReflectionWorld.class.getClassLoader());
+		this.annotationFinder = makeAnnotationFinderIfAny(classLoaderReference.getClassLoader(), this);
 	}
 
 	public ReflectionWorld(ClassLoader aClassLoader) {
 		super();
 		this.setMessageHandler(new ExceptionBasedMessageHandler());
 		setBehaveInJava5Way(LangUtil.is15VMOrGreater());
-		this.classLoader = aClassLoader;
-		this.annotationFinder = makeAnnotationFinderIfAny(classLoader, this);
+		this.classLoaderReference = new WeakClassLoaderReference(aClassLoader);
+		this.annotationFinder = makeAnnotationFinderIfAny(classLoaderReference.getClassLoader(), this);
 	}
 
 	public static AnnotationFinder makeAnnotationFinderIfAny(ClassLoader loader, World world) {
@@ -78,7 +79,7 @@ public class ReflectionWorld extends World implements IReflectionWorld {
 	}
 
 	public ClassLoader getClassLoader() {
-		return this.classLoader;
+		return this.classLoaderReference.getClassLoader();
 	}
 
 	public AnnotationFinder getAnnotationFinder() {
@@ -107,7 +108,7 @@ public class ReflectionWorld extends World implements IReflectionWorld {
 	 * @see org.aspectj.weaver.World#resolveDelegate(org.aspectj.weaver.ReferenceType)
 	 */
 	protected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) {
-		return ReflectionBasedReferenceTypeDelegateFactory.createDelegate(ty, this, this.classLoader);
+		return ReflectionBasedReferenceTypeDelegateFactory.createDelegate(ty, this, this.classLoaderReference.getClassLoader());
 	}
 
 	/* (non-Javadoc)
@@ -46,6 +46,7 @@ import org.aspectj.apache.bcel.generic.NEWARRAY;
 import org.aspectj.apache.bcel.generic.ObjectType;
 import org.aspectj.apache.bcel.generic.PUTSTATIC;
 import org.aspectj.apache.bcel.generic.Type;
+import org.aspectj.apache.bcel.util.ClassLoaderReference;
 import org.aspectj.apache.bcel.util.ClassLoaderRepository;
 import org.aspectj.apache.bcel.util.ClassPath;
 import org.aspectj.apache.bcel.util.NonCachingClassLoaderRepository;
@@ -69,6 +70,7 @@ import org.aspectj.weaver.ResolvedMemberImpl;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.ResolvedTypeMunger;
 import org.aspectj.weaver.UnresolvedType;
+import org.aspectj.weaver.WeakClassLoaderReference;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.AjAttribute.Aspect;
 import org.aspectj.weaver.patterns.DeclareAnnotation;
@@ -84,7 +86,7 @@ public class BcelWorld extends World implements Repository {
 	private ClassPathManager classPath;
 
     protected Repository delegate;
-    private ClassLoader loader;
+    private WeakClassLoaderReference loaderRef;
 
 
 	//private ClassPathManager aspectPath = null;
@@ -153,7 +155,7 @@ public class BcelWorld extends World implements Repository {
      */
     public BcelWorld(ClassLoader loader, IMessageHandler handler, ICrossReferenceHandler xrefHandler) {
         this.classPath = null;
-        this.loader = loader;
+        this.loaderRef = new WeakClassLoaderReference(loader);
         setMessageHandler(handler);
         setCrossReferenceHandler(xrefHandler);
         // Tell BCEL to use us for resolving any classes
@@ -162,16 +164,20 @@ public class BcelWorld extends World implements Repository {
 
     public void ensureRepositorySetup() {
     	if (delegate==null) {
-    		delegate = getClassLoaderRepositoryFor(loader);
+    		delegate = getClassLoaderRepositoryFor(loaderRef);
     	}
     }
 
-	public Repository getClassLoaderRepositoryFor(ClassLoader loader) {
-    	if (bcelRepositoryCaching) {
-    		return new ClassLoaderRepository(loader);
-    	} else {
-    		return new NonCachingClassLoaderRepository(loader);
-    	}
+    private ClassLoader getClassLoader() {
+        return loaderRef.getClassLoader();
+    } 
+
+    public Repository getClassLoaderRepositoryFor(ClassLoaderReference loader) {
+        if (bcelRepositoryCaching) {
+            return new ClassLoaderRepository(loader);
+        } else {
+            return new NonCachingClassLoaderRepository(loader);
+        }
     }
 
 	public void addPath (String name) {
@@ -11,8 +11,11 @@
  * ******************************************************************/
 package org.aspectj.weaver;
 
+import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
 
+import org.aspectj.apache.bcel.util.ClassLoaderReference;
+
 /**
  * Wraps a reference to a classloader inside a WeakReference. This should be used where we do not want the existence of
  * a classloader reference to prevent garbage collection of that classloader (and possibly an associated weaver instance
@@ -33,12 +36,20 @@ import java.lang.ref.WeakReference;
  * 
  * @author Andy Clement
  */
-public class WeakClassLoaderReference {
+public class WeakClassLoaderReference implements ClassLoaderReference {
 
+    private int hashcode;
+    
     private WeakReference loaderRef;
 
     public WeakClassLoaderReference(ClassLoader loader) {
         loaderRef = new WeakReference(loader);
+        hashcode = loader.hashCode() * 37;
+    }
+
+    public WeakClassLoaderReference(ClassLoader loader, ReferenceQueue q) {
+        loaderRef = new WeakReference(loader, q);
+        hashcode = loader.hashCode() * 37;
     }
 
     public ClassLoader getClassLoader() {
@@ -46,5 +57,15 @@ public class WeakClassLoaderReference {
         // Assert instance!=null
         return instance;
     }
+
+    public boolean equals(Object obj) {
+        if (!(obj instanceof WeakClassLoaderReference)) return false;
+        WeakClassLoaderReference other = (WeakClassLoaderReference) obj;
+        return (other.hashcode == hashcode);
+    }
+
+    public int hashCode() {
+        return hashcode;
+    }
 
 }
@@ -53,6 +53,8 @@ public interface IWeavingContext {
 	 */
 	public String getClassLoaderName ();
 
+    public ClassLoader getClassLoader();
+
 	/**
 	 * Format a URL
 	 * @return filename
Binary files differ
Binary files differ
@@ -136,12 +136,17 @@ public class CompilationAndWeavingContext {
 	private CompilationAndWeavingContext() {
 	}
 
-	// for testing...
 	public static void reset() {
-		contextMap = new HashMap();
-		contextStack = new Stack();
-		formatterMap = new HashMap();
-		nextTokenId = 1;
+        if (!multiThreaded) {
+            contextMap = new HashMap();
+            contextStack = new Stack();
+            formatterMap = new HashMap();
+            nextTokenId = 1;
+        } else {
+            contextMap.remove(Thread.currentThread());
+            // TODO what about formatterMap?
+            // TODO what about nextTokenId?
+        }
 	}
 
 	public static void setMultiThreaded(boolean mt) { multiThreaded = mt; }
@@ -204,13 +209,12 @@ public class CompilationAndWeavingContext {
 			return contextStack;
 		}
 		else {
-			if (contextMap.containsKey(Thread.currentThread())) {
-				return (Stack) contextMap.get(Thread.currentThread());
-			} else {
-				Stack contextStack = new Stack();
+		    Stack contextStack = (Stack) contextMap.get(Thread.currentThread());
+            if (contextStack == null) {
+				contextStack = new Stack();
 				contextMap.put(Thread.currentThread(),contextStack);
-				return contextStack;
 			}
+            return contextStack;
 		}
 	}
 
@@ -0,0 +1,67 @@
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2001 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" and
+ *    "Apache BCEL" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    "Apache BCEL", nor may "Apache" appear in their name, without
+ *    prior written permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ */
+
+package org.aspectj.apache.bcel.util;
+
+/**
+ * Implementors should provide access to a ClassLoader instance.  The reference can be passed around and cached
+ * but will not cause the code that caches it to have a hard reference to the classloader, so it is easier
+ * to manage the classloader instance.  The default implementation will just wrap a classloader object but
+ * more sophisticated implementations could keep a WeakReference to the loader.
+ */
+public interface ClassLoaderReference {
+
+    java.lang.ClassLoader getClassLoader();
+    
+}
@@ -80,13 +80,13 @@ import org.aspectj.apache.bcel.classfile.JavaClass;
  *
  * @see org.aspectj.apache.bcel.Repository
  *
- * @version $Id: ClassLoaderRepository.java,v 1.9 2006/10/12 19:58:18 aclement Exp $
+ * @version $Id: ClassLoaderRepository.java,v 1.10 2008/05/27 18:46:34 aclement Exp $
  * @author <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
  * @author David Dixon-Peugh
  */
 public class ClassLoaderRepository implements Repository {
   private static java.lang.ClassLoader bootClassLoader = null;
-  private java.lang.ClassLoader loader;
+  private ClassLoaderReference loaderRef;
 
   // Choice of cache...
   private         WeakHashMap /*<URL,SoftRef(JavaClass)>*/localCache = new WeakHashMap(); 
@@ -107,9 +107,13 @@ public class ClassLoaderRepository implements Repository {
   private int  cacheHitsLocal     = 0;
   private int  missLocalEvicted   = 0; // Misses in local cache access due to reference GC
 
-  public ClassLoaderRepository( java.lang.ClassLoader loader ) {
-      this.loader = (loader != null) ? loader : getBootClassLoader();
-  }
+    public ClassLoaderRepository(java.lang.ClassLoader loader) {
+        this.loaderRef = new DefaultClassLoaderReference((loader != null) ? loader : getBootClassLoader());
+    }
+
+    public ClassLoaderRepository(ClassLoaderReference loaderRef) {
+        this.loaderRef = loaderRef;
+    }
 
   private static synchronized java.lang.ClassLoader getBootClassLoader() {
 	  if (bootClassLoader == null) {
@@ -246,7 +250,7 @@ public class ClassLoaderRepository implements Repository {
 	  URL url = (URL)nameMap.get(className);
 	  if (url==null) {
 		  String classFile = className.replace('.', '/');
-	      url = loader.getResource( classFile + ".class" );
+	      url = loaderRef.getClassLoader().getResource(classFile + ".class");
 	      nameMap.put(className, url);
 	  }
       return url;
@@ -280,7 +284,7 @@ public class ClassLoaderRepository implements Repository {
     try {    	
     	// Load it
 	    String classFile = className.replace('.', '/');
-		InputStream is = (useSharedCache?url.openStream():loader.getResourceAsStream( classFile + ".class" ));
+		InputStream is = (useSharedCache ? url.openStream() : loaderRef.getClassLoader().getResourceAsStream(classFile + ".class"));
 	    if (is == null) { 
 		  throw new ClassNotFoundException(className + " not found "+(url==null?"":"- using url "+url));
 	    }
@@ -298,10 +302,9 @@ public class ClassLoaderRepository implements Repository {
     }
   }
 
-
   /**
-   * Produce a report on cache usage.
-   */
+     * Produce a report on cache usage.
+     */
   public String report() {
 	  StringBuffer sb = new StringBuffer();
 	  sb.append("BCEL repository report.");
@@ -0,0 +1,75 @@
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2001 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" and
+ *    "Apache BCEL" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    "Apache BCEL", nor may "Apache" appear in their name, without
+ *    prior written permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ */
+
+package org.aspectj.apache.bcel.util;
+
+/**
+ * Simplistic ClassLoaderReference that merely delegates to a classloader. More sophisticated ones could allow for the
+ * loader to be weakly referenced.
+ * 
+ * @author Andy Clement
+ */
+public class DefaultClassLoaderReference implements ClassLoaderReference {
+
+    private java.lang.ClassLoader loader;
+ 
+    public DefaultClassLoaderReference(java.lang.ClassLoader classLoader) {
+        this.loader = classLoader;
+    }
+
+    public java.lang.ClassLoader getClassLoader() {
+        return loader;
+    }
+
+}
@@ -72,7 +72,7 @@ import org.aspectj.apache.bcel.classfile.JavaClass;
  *
  * @see org.aspectj.apache.bcel.Repository
  *
- * @version $Id: NonCachingClassLoaderRepository.java,v 1.1 2006/10/12 19:58:18 aclement Exp $
+ * @version $Id: NonCachingClassLoaderRepository.java,v 1.2 2008/05/27 18:46:34 aclement Exp $
  * @author <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
  * @author David Dixon-Peugh
  * 
@@ -82,13 +82,17 @@ public class NonCachingClassLoaderRepository
 {  
   private static java.lang.ClassLoader bootClassLoader = null;
 
-  private java.lang.ClassLoader loader;
+  private ClassLoaderReference loaderRef;
   private WeakHashMap loadedClasses =
     new WeakHashMap(); // CLASSNAME X JAVACLASS
 
-  public NonCachingClassLoaderRepository( java.lang.ClassLoader loader ) {
-	    this.loader = (loader != null) ? loader : getBootClassLoader();
-  }
+    public NonCachingClassLoaderRepository(java.lang.ClassLoader loader) {
+        this.loaderRef = new DefaultClassLoaderReference((loader != null) ? loader : getBootClassLoader());
+    }
+
+    public NonCachingClassLoaderRepository(ClassLoaderReference loaderRef) {
+        this.loaderRef = loaderRef;
+    }
 
   private static synchronized java.lang.ClassLoader getBootClassLoader() {
 	  if (bootClassLoader == null) {
@@ -137,7 +141,7 @@ public class NonCachingClassLoaderRepository
 
     try {
       InputStream is = 
-	loader.getResourceAsStream( classFile + ".class" );
+          loaderRef.getClassLoader().getResourceAsStream(classFile + ".class");
 
       if(is == null) {
 	throw new ClassNotFoundException(className + " not found.");
@@ -0,0 +1,50 @@
+/* *******************************************************************
+ * Copyright (c) 2008 Contributors
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *     Andy Clement     initial implementation 
+ * ******************************************************************/
+package org.aspectj.weaver;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * Wraps a reference to a classloader inside a WeakReference. This should be used where we do not want the existence of
+ * a classloader reference to prevent garbage collection of that classloader (and possibly an associated weaver instance
+ * in the case of load time weaving).
+ * <p>
+ * In more detail:<br>
+ * When load time weaving, the class Aj maintains a WeakHashMap from the classloader instance to a weaver instance. The
+ * aim is that the weaver is around as long as the classloader is and should the classloader be dereferenced then the
+ * weaver can also be garbage collected. The problem is that if there are many references to the classloader from within
+ * the weaver, these are considered hard references and cause the classloader to be long lived - even if the user of the
+ * classloader has dereferenced it in their code. The solution is that the weaver should use instances of
+ * WeakClassLoaderReference objects - so that when the users hard reference to the classloader goes, nothing in the
+ * weaver will cause it to hang around. There is a big assertion here that the WeakClassLoaderReference instances will
+ * not 'lose' their ClassLoader references until the top level ClassLoader reference is null'd. This means there is no
+ * need to check for the null case on get() in this WeakReference logic below, because we shouldn't be using this weaver
+ * if its associated ClassLoader has been collected. See https://bugs.eclipse.org/bugs/show_bug.cgi?id=210470
+ * 
+ * 
+ * @author Andy Clement
+ */
+public class WeakClassLoaderReference {
+
+    private WeakReference loaderRef;
+    
+    public WeakClassLoaderReference(ClassLoader loader) {
+        loaderRef = new WeakReference(loader);
+    }
+    
+    public ClassLoader getClassLoader() {
+        ClassLoader instance = (ClassLoader) loaderRef.get();
+        // Assert instance!=null
+        return instance;
+    }
+    
+}
@@ -191,6 +191,14 @@ public class CompilationAndWeavingContext {
 		}
 	}
 
+	/**
+	 * Forget about the context for the current thread
+	 */
+	public static void resetForThread() {
+		if (!multiThreaded) return;
+		contextMap.remove(Thread.currentThread());
+	}
+	
 	private static Stack getContextStack() {
 		if (!multiThreaded) {
 			return contextStack;
@@ -14,6 +14,7 @@ package org.aspectj.weaver.loadtime;
 import java.util.Map;
 import java.util.WeakHashMap;
 
+import org.aspectj.bridge.context.CompilationAndWeavingContext;
 import org.aspectj.weaver.Dump;
 import org.aspectj.weaver.tools.Trace;
 import org.aspectj.weaver.tools.TraceFactory;
@@ -89,6 +90,8 @@ public class Aj implements ClassPreProcessor {
             // would make sense at least in test f.e. see TestHelper.handleMessage()
     		if (trace.isTraceEnabled()) trace.exit("preProcess",th);
             return bytes;
+        } finally {
+            CompilationAndWeavingContext.resetForThread(); // recording the thread will anchor the classloader
         }
     }
 
