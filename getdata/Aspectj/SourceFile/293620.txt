@@ -50,7 +50,7 @@ public class ReferenceType extends ResolvedType {
 	ResolvedMember[] parameterizedFields = null;
 	ResolvedMember[] parameterizedPointcuts = null;
 	ResolvedType[] parameterizedInterfaces = null;
-	Collection parameterizedDeclares = null;
+	Collection<Declare> parameterizedDeclares = null;
 	Collection parameterizedTypeMungers = null;
 
 	// During matching it can be necessary to temporary mark types as annotated. For example
@@ -803,11 +803,10 @@ public class ReferenceType extends ResolvedType {
 		}
 		Collection<Declare> declares = null;
 		if (ajMembersNeedParameterization()) {
-			Collection genericDeclares = delegate.getDeclares();
-			parameterizedDeclares = new ArrayList();
-			Map parameterizationMap = getAjMemberParameterizationMap();
-			for (Iterator iter = genericDeclares.iterator(); iter.hasNext();) {
-				Declare declareStatement = (Declare) iter.next();
+			Collection<Declare> genericDeclares = delegate.getDeclares();
+			parameterizedDeclares = new ArrayList<Declare>();
+			Map<String, UnresolvedType> parameterizationMap = getAjMemberParameterizationMap();
+			for (Declare declareStatement : genericDeclares) {
 				parameterizedDeclares.add(declareStatement.parameterizeWith(parameterizationMap, world));
 			}
 			declares = parameterizedDeclares;
@@ -821,7 +820,7 @@ public class ReferenceType extends ResolvedType {
 	}
 
 	@Override
-	public Collection getTypeMungers() {
+	public Collection<ConcreteTypeMunger> getTypeMungers() {
 		return delegate.getTypeMungers();
 	}
 
@@ -26,9 +26,10 @@ import java.util.Set;
  */
 public class JoinPointSignatureIterator implements Iterator<JoinPointSignature> {
 
+	ResolvedType firstDefiningType;
+
 	private Member signaturesOfMember;
 	private ResolvedMember firstDefiningMember;
-	ResolvedType firstDefiningType;
 	private World world;
 	private List<JoinPointSignature> discoveredSignatures = new ArrayList<JoinPointSignature>();
 	private List<JoinPointSignature> additionalSignatures = Collections.emptyList();
@@ -86,9 +87,10 @@ public class JoinPointSignatureIterator implements Iterator<JoinPointSignature>
 		throw new UnsupportedOperationException("can't remove from JoinPointSignatureIterator");
 	}
 
+	/**
+	 * Walk up the hierarchy creating one member for each type up to and including the first defining type.
+	 */
 	private void addSignaturesUpToFirstDefiningMember() {
-		// Walk up hierarchy creating one member for each type up to and including the
-		// first defining type
 		ResolvedType originalDeclaringType = signaturesOfMember.getDeclaringType().resolve(world);
 		ResolvedType superType = originalDeclaringType.getSuperclass();
 		if (superType != null && superType.equals(jlrProxy)) {
@@ -97,9 +99,8 @@ public class JoinPointSignatureIterator implements Iterator<JoinPointSignature>
 			isProxy = true;
 		}
 
-		if (world.isJoinpointArrayConstructionEnabled() && originalDeclaringType.isArray()) { // Aha, this must be the array
-			// constructor call join point - a
-			// 'special'...
+		// is it the array constructor join point?
+		if (world.isJoinpointArrayConstructionEnabled() && originalDeclaringType.isArray()) {
 			Member m = signaturesOfMember;
 			ResolvedMember rm = new ResolvedMemberImpl(m.getKind(), m.getDeclaringType(), m.getModifiers(), m.getReturnType(), m
 					.getName(), m.getParameterTypes());
@@ -140,13 +141,13 @@ public class JoinPointSignatureIterator implements Iterator<JoinPointSignature>
 	/**
 	 * Build a list containing every type between subtype and supertype, inclusively.
 	 */
-	private void accumulateTypesInBetween(ResolvedType subType, ResolvedType superType, List types) {
+	private void accumulateTypesInBetween(ResolvedType subType, ResolvedType superType, List<ResolvedType> types) {
 		types.add(subType);
 		if (subType == superType) {
 			return;
 		} else {
-			for (Iterator iter = subType.getDirectSupertypes(); iter.hasNext();) {
-				ResolvedType parent = (ResolvedType) iter.next();
+			for (Iterator<ResolvedType> iter = subType.getDirectSupertypes(); iter.hasNext();) {
+				ResolvedType parent = iter.next();
 				if (superType.isAssignableFrom(parent, true)) {
 					accumulateTypesInBetween(parent, superType, types);
 				}
@@ -175,7 +176,7 @@ public class JoinPointSignatureIterator implements Iterator<JoinPointSignature>
 		if (superTypeIterator.hasNext()) {
 			ResolvedType superType = superTypeIterator.next();
 			if (isProxy && (superType.isGenericType() || superType.isParameterizedType())) {
-				superType = (ResolvedType) superType.getRawType();
+				superType = superType.getRawType();
 			}
 			if (visitedSuperTypes.contains(superType)) {
 				return findSignaturesFromSupertypes();
@@ -190,24 +191,21 @@ public class JoinPointSignatureIterator implements Iterator<JoinPointSignature>
 				ResolvedMemberImpl foundMember = (ResolvedMemberImpl) superType.lookupResolvedMember(firstDefiningMember, true,
 						isProxy);
 				if (foundMember != null && isVisibleTo(firstDefiningMember, foundMember)) {
-					List declaringTypes = new ArrayList();
+					List<ResolvedType> declaringTypes = new ArrayList<ResolvedType>();
 					// declaring type can be unresolved if the member can from an ITD...
 					ResolvedType resolvedDeclaringType = foundMember.getDeclaringType().resolve(world);
 					accumulateTypesInBetween(superType, resolvedDeclaringType, declaringTypes);
-					for (Iterator iter = declaringTypes.iterator(); iter.hasNext();) {
-						ResolvedType declaringType = (ResolvedType) iter.next();
+					for (ResolvedType declaringType : declaringTypes) {
 						JoinPointSignature member = null;
 						if (isProxy) {
 							if (declaringType.isGenericType() || declaringType.isParameterizedType()) {
-								declaringType = (ResolvedType) declaringType.getRawType();
+								declaringType = declaringType.getRawType();
 							}
-							member = foundMember.withSubstituteDeclaringType(declaringType);
-						} else {
-							member = foundMember.withSubstituteDeclaringType(declaringType);
 						}
+						member = new JoinPointSignature(foundMember, declaringType);
 						discoveredSignatures.add(member); // for next time we are reset
 						if (additionalSignatures == Collections.EMPTY_LIST) {
-							additionalSignatures = new ArrayList();
+							additionalSignatures = new ArrayList<JoinPointSignature>();
 						}
 						additionalSignatures.add(member); // for this time
 					}
@@ -217,12 +215,12 @@ public class JoinPointSignatureIterator implements Iterator<JoinPointSignature>
 								foundMember.declaringType.resolve(world));
 						discoveredSignatures.add(member); // for next time we are reset
 						if (additionalSignatures == Collections.EMPTY_LIST) {
-							additionalSignatures = new ArrayList();
+							additionalSignatures = new ArrayList<JoinPointSignature>();
 						}
 						additionalSignatures.add(member); // for this time
 					}
 					if (yetToBeProcessedSuperMembers == null) {
-						yetToBeProcessedSuperMembers = new ArrayList();
+						yetToBeProcessedSuperMembers = new ArrayList<SearchPair>();
 					}
 					yetToBeProcessedSuperMembers.add(new SearchPair(foundMember, superType));
 					return true;
@@ -30,21 +30,21 @@ public class JoinPointSignatureIterator implements Iterator<JoinPointSignature>
 	private ResolvedMember firstDefiningMember;
 	ResolvedType firstDefiningType;
 	private World world;
-	private List discoveredSignatures = new ArrayList();
+	private List<JoinPointSignature> discoveredSignatures = new ArrayList<JoinPointSignature>();
 	private List<JoinPointSignature> additionalSignatures = Collections.emptyList();
 	private Iterator<JoinPointSignature> discoveredSignaturesIterator = null;
 	private Iterator<ResolvedType> superTypeIterator = null;
 	private boolean isProxy = false;
-	private Set visitedSuperTypes = new HashSet();
-	private List /* SearchPair */yetToBeProcessedSuperMembers = null;
+	private Set<ResolvedType> visitedSuperTypes = new HashSet<ResolvedType>();
+	private List<SearchPair> yetToBeProcessedSuperMembers = null;
 
 	private boolean iteratingOverDiscoveredSignatures = true;
 	private boolean couldBeFurtherAsYetUndiscoveredSignatures = true;
 	private final static UnresolvedType jlrProxy = UnresolvedType.forSignature("Ljava/lang/reflect/Proxy;");
 
-	public JoinPointSignatureIterator(Member joinPointSignature, World inAWorld) {
+	public JoinPointSignatureIterator(Member joinPointSignature, World world) {
 		this.signaturesOfMember = joinPointSignature;
-		this.world = inAWorld;
+		this.world = world;
 		addSignaturesUpToFirstDefiningMember();
 		if (!shouldWalkUpHierarchy()) {
 			couldBeFurtherAsYetUndiscoveredSignatures = false;
@@ -125,12 +125,15 @@ public class JoinPointSignatureIterator implements Iterator<JoinPointSignature>
 			}
 		}
 
-		List declaringTypes = new ArrayList();
-		accumulateTypesInBetween(originalDeclaringType, firstDefiningType, declaringTypes);
-		for (Iterator iter = declaringTypes.iterator(); iter.hasNext();) {
-			ResolvedType declaringType = (ResolvedType) iter.next();
-			ResolvedMember member = ((ResolvedMemberImpl) firstDefiningMember).withSubstituteDeclaringType(declaringType);
-			discoveredSignatures.add(member);
+		if (originalDeclaringType == firstDefiningType) {
+			// a common case
+			discoveredSignatures.add(new JoinPointSignature(firstDefiningMember, originalDeclaringType));
+		} else {
+			List<ResolvedType> declaringTypes = new ArrayList<ResolvedType>();
+			accumulateTypesInBetween(originalDeclaringType, firstDefiningType, declaringTypes);
+			for (ResolvedType declaringType : declaringTypes) {
+				discoveredSignatures.add(new JoinPointSignature(firstDefiningMember, declaringType));
+			}
 		}
 	}
 
@@ -229,7 +232,7 @@ public class JoinPointSignatureIterator implements Iterator<JoinPointSignature>
 			}
 		}
 		if (yetToBeProcessedSuperMembers != null && !yetToBeProcessedSuperMembers.isEmpty()) {
-			SearchPair nextUp = (SearchPair) yetToBeProcessedSuperMembers.remove(0);
+			SearchPair nextUp = yetToBeProcessedSuperMembers.remove(0);
 			firstDefiningType = nextUp.type;
 			firstDefiningMember = nextUp.member;
 			superTypeIterator = null;
@@ -115,8 +115,9 @@ public class ReferenceType extends ResolvedType {
 
 	@Override
 	public String getSignatureForAttribute() {
-		if (genericType == null || typeParameters == null)
+		if (genericType == null || typeParameters == null) {
 			return getSignature();
+		}
 		return makeDeclaredSignature(genericType, typeParameters);
 	}
 
@@ -299,7 +300,7 @@ public class ReferenceType extends ResolvedType {
 		}
 
 		if (this.isRawType() && other.isParameterizedType()) {
-			return this.getGenericType().isCoerceableFrom(((ReferenceType) other.getRawType()));
+			return this.getGenericType().isCoerceableFrom((other.getRawType()));
 		}
 
 		if (!this.isInterface() && !other.isInterface()) {
@@ -314,18 +315,20 @@ public class ReferenceType extends ResolvedType {
 		// always safe
 		for (int ai = 0, alen = a.length; ai < alen; ai++) {
 			for (int bi = 0, blen = b.length; bi < blen; bi++) {
-				if (!b[bi].isCompatibleWith(a[ai]))
+				if (!b[bi].isCompatibleWith(a[ai])) {
 					return false;
+				}
 			}
 		}
 		return true;
 	}
 
 	private final boolean isCoerceableFromParameterizedType(ResolvedType other) {
-		if (!other.isParameterizedType())
+		if (!other.isParameterizedType()) {
 			return false;
-		ResolvedType myRawType = (ResolvedType) getRawType();
-		ResolvedType theirRawType = (ResolvedType) other.getRawType();
+		}
+		ResolvedType myRawType = getRawType();
+		ResolvedType theirRawType = other.getRawType();
 		if (myRawType == theirRawType || myRawType.isCoerceableFrom(theirRawType)) {
 			if (getTypeParameters().length == other.getTypeParameters().length) {
 				// there's a chance it can be done
@@ -337,20 +340,23 @@ public class ReferenceType extends ResolvedType {
 						// coerceable from e.g. List<T>
 						if (myTypeParameters[i].isGenericWildcard()) {
 							BoundedReferenceType wildcard = (BoundedReferenceType) myTypeParameters[i];
-							if (!wildcard.canBeCoercedTo(theirTypeParameters[i]))
+							if (!wildcard.canBeCoercedTo(theirTypeParameters[i])) {
 								return false;
+							}
 						} else if (myTypeParameters[i].isTypeVariableReference()) {
 							TypeVariableReferenceType tvrt = (TypeVariableReferenceType) myTypeParameters[i];
 							TypeVariable tv = tvrt.getTypeVariable();
 							tv.resolve(world);
-							if (!tv.canBeBoundTo(theirTypeParameters[i]))
+							if (!tv.canBeBoundTo(theirTypeParameters[i])) {
 								return false;
+							}
 						} else if (theirTypeParameters[i].isTypeVariableReference()) {
 							TypeVariableReferenceType tvrt = (TypeVariableReferenceType) theirTypeParameters[i];
 							TypeVariable tv = tvrt.getTypeVariable();
 							tv.resolve(world);
-							if (!tv.canBeBoundTo(myTypeParameters[i]))
+							if (!tv.canBeBoundTo(myTypeParameters[i])) {
 								return false;
+							}
 						} else if (theirTypeParameters[i].isGenericWildcard()) {
 							BoundedReferenceType wildcard = (BoundedReferenceType) theirTypeParameters[i];
 							if (!wildcard.canBeCoercedTo(myTypeParameters[i])) {
@@ -387,10 +393,12 @@ public class ReferenceType extends ResolvedType {
 	@Override
 	public boolean isAssignableFrom(ResolvedType other, boolean allowMissing) {
 		if (other.isPrimitiveType()) {
-			if (!world.isInJava5Mode())
+			if (!world.isInJava5Mode()) {
 				return false;
-			if (ResolvedType.validBoxing.contains(this.getSignature() + other.getSignature()))
+			}
+			if (ResolvedType.validBoxing.contains(this.getSignature() + other.getSignature())) {
 				return true;
+			}
 		}
 		if (this == other) {
 			return true;
@@ -400,17 +408,19 @@ public class ReferenceType extends ResolvedType {
 		}
 
 		if ((this.isRawType() || this.isGenericType()) && other.isParameterizedType()) {
-			if (isAssignableFrom((ResolvedType) other.getRawType())) {
+			if (isAssignableFrom(other.getRawType())) {
 				return true;
 			}
 		}
 		if (this.isRawType() && other.isGenericType()) {
-			if (isAssignableFrom((ResolvedType) other.getRawType()))
+			if (isAssignableFrom(other.getRawType())) {
 				return true;
+			}
 		}
 		if (this.isGenericType() && other.isRawType()) {
-			if (isAssignableFrom(other.getGenericType()))
+			if (isAssignableFrom(other.getGenericType())) {
 				return true;
+			}
 		}
 		// if (this.isParameterizedType() && other.isRawType()) {
 		// if (((ReferenceType) this.getRawType()).isAssignableFrom(other.getGenericType())) {
@@ -433,8 +443,9 @@ public class ReferenceType extends ResolvedType {
 						}
 					}
 				}
-				if (wildcardsAllTheWay && !other.isParameterizedType())
+				if (wildcardsAllTheWay && !other.isParameterizedType()) {
 					return true;
+				}
 				// we have to match by parameters one at a time
 				ResolvedType[] theirParameters = other.getResolvedTypeParameters();
 				boolean parametersAssignable = true;
@@ -497,8 +508,9 @@ public class ReferenceType extends ResolvedType {
 				} else {
 					parametersAssignable = false;
 				}
-				if (parametersAssignable)
+				if (parametersAssignable) {
 					return true;
+				}
 			}
 		}
 
@@ -533,12 +545,14 @@ public class ReferenceType extends ResolvedType {
 			}
 		}
 
-		if (allowMissing && other.isMissing())
+		if (allowMissing && other.isMissing()) {
 			return false;
+		}
 
 		for (Iterator i = other.getDirectSupertypes(); i.hasNext();) {
-			if (this.isAssignableFrom((ResolvedType) i.next(), allowMissing))
+			if (this.isAssignableFrom((ResolvedType) i.next(), allowMissing)) {
 				return true;
+			}
 		}
 		return false;
 	}
@@ -568,8 +582,9 @@ public class ReferenceType extends ResolvedType {
 
 	@Override
 	public ResolvedMember[] getDeclaredFields() {
-		if (parameterizedFields != null)
+		if (parameterizedFields != null) {
 			return parameterizedFields;
+		}
 		if (isParameterizedType() || isRawType()) {
 			ResolvedMember[] delegateFields = delegate.getDeclaredFields();
 			parameterizedFields = new ResolvedMember[delegateFields.length];
@@ -589,8 +604,9 @@ public class ReferenceType extends ResolvedType {
 	 */
 	@Override
 	public ResolvedType[] getDeclaredInterfaces() {
-		if (parameterizedInterfaces != null)
+		if (parameterizedInterfaces != null) {
 			return parameterizedInterfaces;
+		}
 		ResolvedType[] delegateInterfaces = delegate.getDeclaredInterfaces();
 		if (newInterfaces != null) {
 			ResolvedType[] extraInterfaces = new ResolvedType[delegateInterfaces.length + newInterfaces.length];
@@ -701,16 +717,18 @@ public class ReferenceType extends ResolvedType {
 		TypeVariable[] thisTypesTVars = getGenericType().getTypeVariables();
 		for (int i = 0; i < thisTypesTVars.length; i++) {
 			TypeVariable tv = thisTypesTVars[i];
-			if (tv.getName().equals(tvname))
+			if (tv.getName().equals(tvname)) {
 				return i;
+			}
 		}
 		return -1;
 	}
 
 	@Override
 	public ResolvedMember[] getDeclaredMethods() {
-		if (parameterizedMethods != null)
+		if (parameterizedMethods != null) {
 			return parameterizedMethods;
+		}
 		if (isParameterizedType() || isRawType()) {
 			ResolvedMember[] delegateMethods = delegate.getDeclaredMethods();
 			UnresolvedType[] parameters = getTypesForMemberParameterization();
@@ -726,8 +744,9 @@ public class ReferenceType extends ResolvedType {
 
 	@Override
 	public ResolvedMember[] getDeclaredPointcuts() {
-		if (parameterizedPointcuts != null)
+		if (parameterizedPointcuts != null) {
 			return parameterizedPointcuts;
+		}
 		if (isParameterizedType()) {
 			ResolvedMember[] delegatePointcuts = delegate.getDeclaredPointcuts();
 			parameterizedPointcuts = new ResolvedMember[delegatePointcuts.length];
@@ -757,11 +776,6 @@ public class ReferenceType extends ResolvedType {
 	}
 
 	@Override
-	public UnresolvedType getRawType() {
-		return super.getRawType().resolve(world);
-	}
-
-	@Override
 	public TypeVariable[] getTypeVariables() {
 		if (this.typeVariables == null) {
 			this.typeVariables = delegate.getTypeVariables();
@@ -784,8 +798,9 @@ public class ReferenceType extends ResolvedType {
 
 	@Override
 	public Collection<Declare> getDeclares() {
-		if (parameterizedDeclares != null)
+		if (parameterizedDeclares != null) {
 			return parameterizedDeclares;
+		}
 		Collection<Declare> declares = null;
 		if (ajMembersNeedParameterization()) {
 			Collection genericDeclares = delegate.getDeclares();
@@ -870,8 +885,9 @@ public class ReferenceType extends ResolvedType {
 		// Don't copy from BcelObjectType to EclipseSourceType - the context may
 		// be tidied (result null'd) after previous weaving
 		if (this.delegate != null && this.delegate.copySourceContext()
-				&& this.delegate.getSourceContext() != SourceContextImpl.UNKNOWN_SOURCE_CONTEXT)
+				&& this.delegate.getSourceContext() != SourceContextImpl.UNKNOWN_SOURCE_CONTEXT) {
 			((AbstractReferenceTypeDelegate) delegate).setSourceContext(this.delegate.getSourceContext());
+		}
 		this.delegate = delegate;
 		for (Iterator it = this.derivativeTypes.iterator(); it.hasNext();) {
 			ReferenceType dependent = (ReferenceType) it.next();
@@ -940,8 +956,9 @@ public class ReferenceType extends ResolvedType {
 
 	@Override
 	public ResolvedType getGenericType() {
-		if (isGenericType())
+		if (isGenericType()) {
 			return this;
+		}
 		return genericType;
 	}
 
@@ -282,7 +282,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 			ResolvedType superType = resolvedType.getSuperclass();
 			if (superType != null && !superType.isMissing()) {
 				if (genericsAware && superType.isParameterizedType()) {
-					superType = (ResolvedType) superType.getRawType();
+					superType = superType.getRawType();
 				}
 				// Recurse if we are not at the top
 				addAndRecurse(knowninterfaces, collector, superType, includeITDs, allowMissing, genericsAware);
@@ -293,7 +293,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 		for (int i = 0; i < interfaces.length; i++) {
 			ResolvedType iface = interfaces[i];
 			if (!genericsAware && iface.isParameterizedType()) {
-				iface = (ResolvedType) iface.getRawType();
+				iface = iface.getRawType();
 			}
 			// we need to know if it is an interface from Parent kind munger
 			// as those are used for @AJ ITD and we precisely want to skip those
@@ -2085,6 +2085,11 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 		return null;
 	}
 
+	@Override
+	public ResolvedType getRawType() {
+		return super.getRawType().resolve(world);
+	}
+
 	public ResolvedType parameterizedWith(UnresolvedType[] typeParameters) {
 		if (!(isGenericType() || isParameterizedType())) {
 			return this;
@@ -31,13 +31,14 @@ import org.aspectj.weaver.World;
 
 public class ExactTypePattern extends TypePattern {
 	protected UnresolvedType type;
+	protected transient ResolvedType resolvedType;
 
-	public static final Map primitiveTypesMap;
-	public static final Map boxedPrimitivesMap;
-	private static final Map boxedTypesMap;
+	public static final Map<String, Class<?>> primitiveTypesMap;
+	public static final Map<String, Class<?>> boxedPrimitivesMap;
+	private static final Map<String, Class<?>> boxedTypesMap;
 
 	static {
-		primitiveTypesMap = new HashMap();
+		primitiveTypesMap = new HashMap<String, Class<?>>();
 		primitiveTypesMap.put("int", int.class);
 		primitiveTypesMap.put("short", short.class);
 		primitiveTypesMap.put("long", long.class);
@@ -46,7 +47,7 @@ public class ExactTypePattern extends TypePattern {
 		primitiveTypesMap.put("float", float.class);
 		primitiveTypesMap.put("double", double.class);
 
-		boxedPrimitivesMap = new HashMap();
+		boxedPrimitivesMap = new HashMap<String, Class<?>>();
 		boxedPrimitivesMap.put("java.lang.Integer", Integer.class);
 		boxedPrimitivesMap.put("java.lang.Short", Short.class);
 		boxedPrimitivesMap.put("java.lang.Long", Long.class);
@@ -55,7 +56,7 @@ public class ExactTypePattern extends TypePattern {
 		boxedPrimitivesMap.put("java.lang.Float", Float.class);
 		boxedPrimitivesMap.put("java.lang.Double", Double.class);
 
-		boxedTypesMap = new HashMap();
+		boxedTypesMap = new HashMap<String, Class<?>>();
 		boxedTypesMap.put("int", Integer.class);
 		boxedTypesMap.put("short", Short.class);
 		boxedTypesMap.put("long", Long.class);
@@ -126,6 +127,9 @@ public class ExactTypePattern extends TypePattern {
 		if (!typeMatch && matchType.isTypeVariableReference()) {
 			typeMatch = matchesTypeVariable((TypeVariableReferenceType) matchType);
 		}
+		if (!typeMatch) {
+			return false;
+		}
 		annotationPattern.resolve(matchType.getWorld());
 		boolean annMatch = false;
 		if (matchType.temporaryAnnotationTypes != null) {
@@ -165,6 +169,13 @@ public class ExactTypePattern extends TypePattern {
 		return type;
 	}
 
+	public ResolvedType getResolvedExactType(World world) {
+		if (resolvedType == null) {
+			resolvedType = world.resolve(type);
+		}
+		return resolvedType;
+	}
+
 	// true if (matchType instanceof this.type)
 	@Override
 	public FuzzyBoolean matchesInstanceof(ResolvedType matchType) {
@@ -14,6 +14,7 @@ package org.aspectj.weaver;
 
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Set;
 
@@ -62,7 +63,8 @@ public final class Iterators {
 							}
 							peek = in.next();
 							if (!seen.contains(peek)) {
-								return fresh = true;
+								fresh = true;
+								return true;
 							} else {
 								peek = null; // garbage collection
 							}
@@ -116,8 +118,89 @@ public final class Iterators {
 		};
 	}
 
+	public static class ArrayIterator implements Iterator<ResolvedType> {
+		private ResolvedType[] array;
+		private int index;
+		private int len;
+		private boolean wantGenerics;
+		private List<String> alreadySeen; // type signatures
+
+		public ArrayIterator(ResolvedType[] array, List<String> alreadySeen, boolean genericsAware) {
+			assert array != null;
+			this.array = array;
+			this.wantGenerics = genericsAware;
+			this.len = array.length;
+			this.index = 0;
+			this.alreadySeen = alreadySeen;
+			moveToNextNewOne();
+		}
+
+		private void moveToNextNewOne() {
+			while (index < len) {
+				ResolvedType interfaceType = array[index];
+				if (!wantGenerics && (interfaceType.isGenericType() || interfaceType.isParameterizedType())) {
+					interfaceType = interfaceType.getRawType();
+				}
+				String signature = interfaceType.getSignature();
+				if (!alreadySeen.contains(signature)) {
+					break;
+				}
+				index++;
+			}
+		}
+
+		public boolean hasNext() {
+			return index < len;
+		}
+
+		public ResolvedType next() {
+			if (index < len) {
+				ResolvedType oo = array[index++];
+				if (!wantGenerics && (oo.isParameterizedType() || oo.isGenericType())) {
+					oo = oo.getRawType();
+				}
+				alreadySeen.add(oo.getSignature());
+				moveToNextNewOne();
+				return oo;
+			} else {
+				throw new NoSuchElementException();
+			}
+		}
+
+		public void remove() {
+			throw new UnsupportedOperationException();
+		}
+	}
+
+	public static Iterator<ResolvedType> array(final ResolvedType[] o, final boolean genericsAware) {
+		return new Iterator<ResolvedType>() {
+			int i = 0;
+			int len = (o == null) ? 0 : o.length;
+
+			public boolean hasNext() {
+				return i < len;
+			}
+
+			public ResolvedType next() {
+				if (i < len) {
+					ResolvedType oo = o[i++];
+					if (!genericsAware && (oo.isParameterizedType() || oo.isGenericType())) {
+						return oo.getRawType();
+					}
+					return oo;
+				} else {
+					throw new NoSuchElementException();
+				}
+			}
+
+			public void remove() {
+				throw new UnsupportedOperationException();
+			}
+		};
+	}
+
 	/**
-	 * creates an iterator I based on a base iterator A and a getter G. I returns, in order, forall (i in I), G(i).
+	 * creates an iterator I based on a base iterator A and a getter G. I returns, in order, forall (i in A), G(i).
 	 */
 	public static <A, B> Iterator<B> mapOver(final Iterator<A> a, final Getter<A, B> g) {
 		return new Iterator<B>() {
