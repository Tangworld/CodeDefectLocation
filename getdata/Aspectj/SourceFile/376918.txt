@@ -710,11 +710,17 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 	private static String nameToSignature(String name) {
 		int len = name.length();
 		if (len < 8) {
-			if (name.equals("byte")) {
-				return "B";
+			if (name.equals("int")) {
+				return "I";
 			}
-			if (name.equals("char")) {
-				return "C";
+			if (name.equals("void")) {
+				return "V";
+			}
+			if (name.equals("long")) {
+				return "J";
+			}
+			if (name.equals("boolean")) {
+				return "Z";
 			}
 			if (name.equals("double")) {
 				return "D";
@@ -722,32 +728,31 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 			if (name.equals("float")) {
 				return "F";
 			}
-			if (name.equals("int")) {
-				return "I";
-			}
-			if (name.equals("long")) {
-				return "J";
+			if (name.equals("byte")) {
+				return "B";
 			}
 			if (name.equals("short")) {
 				return "S";
 			}
-			if (name.equals("boolean")) {
-				return "Z";
-			}
-			if (name.equals("void")) {
-				return "V";
+			if (name.equals("char")) {
+				return "C";
 			}
 			if (name.equals("?")) {
 				return name;
 			}
 		}
+		if (len == 0) {
+			throw new BCException("Bad type name: " + name);
+		}
 		if (name.endsWith("[]")) {
 			return "[" + nameToSignature(name.substring(0, name.length() - 2));
 		}
-		if (len == 0) {
-			throw new BCException("Bad type name: " + name);
+		
+		// Sometimes the 'name' for an array is of the form: [Ljava.lang.String;
+		if (name.charAt(0)=='[') {
+			return name.replace('.','/');
 		}
-			
+
 		if (name.indexOf("<") == -1) {
 			// not parameterized
 			return new StringBuilder("L").append(name.replace('.', '/')).append(';').toString();
@@ -33,6 +33,28 @@ public abstract class CommonReferenceTypeTests extends TestCase {
 		assertEquals("Signatures not equal ", "[Pjava/util/List<Pjava/util/List<Ljava/lang/String;>;>;", ut.getSignature());
 		assertEquals("Names not equal ", "java.util.List<java.util.List<java.lang.String>>[]", ut.getName());
 	}
+	
+	public void testArrays() {
+		world.setBehaveInJava5Way(true);
+		UnresolvedType ut = null;
+		ut = UnresolvedType.forName("[Ljava.lang.String;");
+		assertEquals("[Ljava/lang/String;",ut.getSignature());
+		UnresolvedType reified = UnresolvedType.forSignature(ut.getSignature());
+		ResolvedType rt = world.resolve(reified);
+		assertEquals("[Ljava/lang/String;",rt.getSignature());
+		assertEquals("java.lang.String[]",rt.getName());
+		assertFalse(rt.isMissing());
+		
+		ut = UnresolvedType.forName("[[[[Ljava.lang.String;");
+		assertEquals("[[[[Ljava/lang/String;",ut.getSignature());
+		reified = UnresolvedType.forSignature(ut.getSignature());
+		rt = world.resolve(reified);
+		assertEquals("[[[[Ljava/lang/String;",rt.getSignature());
+		assertEquals("java.lang.String[][][][]",rt.getName());
+		assertTrue(rt.isArray());
+		assertTrue(rt.getComponentType().isArray());
+		assertFalse(rt.isMissing());
+	}
 
 	public void testIsRawTrue() {
 		world.setBehaveInJava5Way(true);
@@ -710,11 +710,17 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 	private static String nameToSignature(String name) {
 		int len = name.length();
 		if (len < 8) {
-			if (name.equals("byte")) {
-				return "B";
+			if (name.equals("int")) {
+				return "I";
 			}
-			if (name.equals("char")) {
-				return "C";
+			if (name.equals("void")) {
+				return "V";
+			}
+			if (name.equals("long")) {
+				return "J";
+			}
+			if (name.equals("boolean")) {
+				return "Z";
 			}
 			if (name.equals("double")) {
 				return "D";
@@ -722,32 +728,31 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 			if (name.equals("float")) {
 				return "F";
 			}
-			if (name.equals("int")) {
-				return "I";
-			}
-			if (name.equals("long")) {
-				return "J";
+			if (name.equals("byte")) {
+				return "B";
 			}
 			if (name.equals("short")) {
 				return "S";
 			}
-			if (name.equals("boolean")) {
-				return "Z";
-			}
-			if (name.equals("void")) {
-				return "V";
+			if (name.equals("char")) {
+				return "C";
 			}
 			if (name.equals("?")) {
 				return name;
 			}
 		}
+		if (len == 0) {
+			throw new BCException("Bad type name: " + name);
+		}
 		if (name.endsWith("[]")) {
 			return "[" + nameToSignature(name.substring(0, name.length() - 2));
 		}
-		if (len == 0) {
-			throw new BCException("Bad type name: " + name);
+		
+		// Sometimes the 'name' for an array is of the form: [Ljava.lang.String;
+		if (name.charAt(0)=='[') {
+			return name.replace('.','/');
 		}
-			
+
 		if (name.indexOf("<") == -1) {
 			// not parameterized
 			return new StringBuilder("L").append(name.replace('.', '/')).append(';').toString();
@@ -33,6 +33,28 @@ public abstract class CommonReferenceTypeTests extends TestCase {
 		assertEquals("Signatures not equal ", "[Pjava/util/List<Pjava/util/List<Ljava/lang/String;>;>;", ut.getSignature());
 		assertEquals("Names not equal ", "java.util.List<java.util.List<java.lang.String>>[]", ut.getName());
 	}
+	
+	public void testArrays() {
+		world.setBehaveInJava5Way(true);
+		UnresolvedType ut = null;
+		ut = UnresolvedType.forName("[Ljava.lang.String;");
+		assertEquals("[Ljava/lang/String;",ut.getSignature());
+		UnresolvedType reified = UnresolvedType.forSignature(ut.getSignature());
+		ResolvedType rt = world.resolve(reified);
+		assertEquals("[Ljava/lang/String;",rt.getSignature());
+		assertEquals("java.lang.String[]",rt.getName());
+		assertFalse(rt.isMissing());
+		
+		ut = UnresolvedType.forName("[[[[Ljava.lang.String;");
+		assertEquals("[[[[Ljava/lang/String;",ut.getSignature());
+		reified = UnresolvedType.forSignature(ut.getSignature());
+		rt = world.resolve(reified);
+		assertEquals("[[[[Ljava/lang/String;",rt.getSignature());
+		assertEquals("java.lang.String[][][][]",rt.getName());
+		assertTrue(rt.isArray());
+		assertTrue(rt.getComponentType().isArray());
+		assertFalse(rt.isMissing());
+	}
 
 	public void testIsRawTrue() {
 		world.setBehaveInJava5Way(true);
