@@ -128,6 +128,9 @@ public class Lint {
 	public final Kind advisingSynchronizedMethods = new Kind("advisingSynchronizedMethods",
 			"advice matching the synchronized method shadow ''{0}'' will be executed outside the lock rather than inside (compiler limitation)");
 
+	public final Kind mustWeaveXmlDefinedAspects = new Kind("mustWeaveXmlDefinedAspects",
+			"XML Defined aspects must be woven in cases where cflow pointcuts are involved. Currently the include/exclude patterns exclude ''{0}''");
+	
 	private static Trace trace = TraceFactory.getTraceFactory().getTrace(Lint.class);
 
     public Lint(World world) {
@@ -41,4 +41,5 @@ cantFindTypeAffectingJPMatch = warning
 unorderedAdviceAtShadow=ignore
 swallowedExceptionInCatchBlock=ignore
 calculatingSerialVersionUID=ignore
-advisingSynchronizedMethods=warning
\ No newline at end of file
+advisingSynchronizedMethods=warning
+mustWeaveXmlDefinedAspects=warning
\ No newline at end of file
@@ -262,7 +262,9 @@ public class WeavingAdaptor implements IMessageContext {
 					bytes = getWovenBytes(name, bytes);
 				} else if (shouldWeaveAnnotationStyleAspect(name, bytes)) {
 					if (mustWeave) {
-						error("XML Defined aspects must be woven in cases where cflow pointcuts are involved. Currently the include/exclude patterns exclude '"+name+"'");
+						if (bcelWorld.getLint().mustWeaveXmlDefinedAspects.isEnabled()) {
+							bcelWorld.getLint().mustWeaveXmlDefinedAspects.signal(name,null);
+						}
 					}
 		            // an @AspectJ aspect needs to be at least munged by the aspectOf munger
 		            debug("weaving '" + name + "'");
@@ -5,7 +5,7 @@
     </concrete-aspect>
   </aspects>
   <!-- weaver options="-verbose -showWeaveInfo -debug"-->
-  <weaver>
+  <weaver options="-verbose -debug">
     <include within="a..*"/>
   </weaver>
 </aspectj>
\ No newline at end of file
@@ -26,6 +26,7 @@ import org.aspectj.weaver.tools.FuzzyBoolean;
 import org.aspectj.weaver.tools.MatchingContext;
 import org.aspectj.weaver.tools.PointcutDesignatorHandler;
 
+import junit.framework.AssertionFailedError;
 import junit.framework.Test;
 
 /**
@@ -45,7 +46,19 @@ public class Ajc154Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	//public void testAfterThrowingAnnotationStyle_pr211674_2() { runTest("after throwing annotation style problem - 2");}
 
 	// crappy solution - see the bug
-//	public void testCflowLtwProblem_pr166647_1() { runTest("ltw and cflow problem"); }
+	public void testCflowLtwProblem_pr166647_1() {
+		try {
+			runTest("ltw and cflow problem"); 
+		} catch (AssertionFailedError afe) {
+			// this is OK.... sadly
+			// at least lets check we warned the user it was going to happen:
+			String stderr = (getLastRunResult()==null?"":getLastRunResult().getStdErr());
+			// Expected line:
+			// [WeavingURLClassLoader] warning XML Defined aspects must be woven in cases where cflow pointcuts are involved. Currently the include/exclude patterns exclude 'x.Aspect2' [Xlint:mustWeaveXmlDefinedAspects]
+			assertTrue("Did not see warning about needing to weave xml defined aspects",stderr.indexOf("warning XML Defined aspects must be woven in cases where cflow pointcuts are involved.")!=-1);
+			assertTrue("Xlint warning was expected '[Xlint:mustWeaveXmlDefinedAspects]'",stderr.indexOf("[Xlint:mustWeaveXmlDefinedAspects]")!=-1);
+		}
+	}
 
 	// Testing some issues with declare at type	
 	public void testDeclareAtTypeProblems_pr211052_1() { runTest("declare atType problems - 1"); }
@@ -636,7 +636,6 @@ public class AjcTestCase extends TestCase {
 			Class toRun = sandboxLoader.loadClass(className);
 			Method mainMethod = toRun.getMethod("main",new Class[] {String[].class});
 			mainMethod.invoke(null,new Object[] {args});
-			lastRunResult = new RunResult(command.toString(),new String(baosOut.toByteArray()),new String(baosErr.toByteArray()));
 		} catch(ClassNotFoundException cnf) {
 			fail("Can't find class: " + className);
 		} catch(NoSuchMethodException nsm) {
@@ -649,6 +648,7 @@ public class AjcTestCase extends TestCase {
 		} finally {
 			Thread.currentThread().setContextClassLoader(contexClassLoader);
 			stopCapture(baosErr,baosOut);
+			lastRunResult = new RunResult(command.toString(),new String(baosOut.toByteArray()),new String(baosErr.toByteArray()));
 		}
 		return lastRunResult;
 	}
@@ -52,6 +52,7 @@ import org.aspectj.weaver.bcel.BcelWorld;
 import org.aspectj.weaver.bcel.UnwovenClassFile;
 import org.aspectj.weaver.bcel.Utility;
 
+// OPTIMIZE add guards for all the debug/info/etc
 /**
  * This adaptor allows the AspectJ compiler to be embedded in an existing
  * system to facilitate load-time weaving. It provides an interface for a
@@ -235,10 +236,11 @@ public class WeavingAdaptor implements IMessageContext {
 	 * Weave a class using aspects previously supplied to the adaptor.
 	 * @param name the name of the class
 	 * @param bytes the class bytes
+	 * @param mustWeave if true then this class *must* get woven (used for concrete aspects generated from XML)
 	 * @return the woven bytes
      * @exception IOException weave failed
 	 */
-	public byte[] weaveClass (String name, byte[] bytes) throws IOException {
+	public byte[] weaveClass (String name, byte[] bytes,boolean mustWeave) throws IOException {
 		if (trace.isTraceEnabled()) trace.enter("weaveClass",this,new Object[] {name, bytes});
 
 		if (!enabled) {
@@ -259,6 +261,9 @@ public class WeavingAdaptor implements IMessageContext {
 					debug("weaving '" + name + "'");
 					bytes = getWovenBytes(name, bytes);
 				} else if (shouldWeaveAnnotationStyleAspect(name, bytes)) {
+					if (mustWeave) {
+						error("XML Defined aspects must be woven in cases where cflow pointcuts are involved. Currently the include/exclude patterns exclude '"+name+"'");
+					}
 		            // an @AspectJ aspect needs to be at least munged by the aspectOf munger
 		            debug("weaving '" + name + "'");
 		            bytes = getAtAspectJAspectBytes(name, bytes);
@@ -75,7 +75,7 @@ public class Aj implements ClassPreProcessor {
             		if (trace.isTraceEnabled()) trace.exit("preProcess");
                 	return bytes;
                 }
-                byte[] newBytes = weavingAdaptor.weaveClass(className, bytes);
+                byte[] newBytes = weavingAdaptor.weaveClass(className, bytes,false);
                 Dump.dumpOnExit(weavingAdaptor.getMessageHolder(), true);
         		if (trace.isTraceEnabled()) trace.exit("preProcess",newBytes);
                 return newBytes;
@@ -468,7 +468,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
         	byte[] bytes = gen.getBytes();
 
         	try {
-        		byte[] newBytes = weaveClass(name, bytes);
+        		byte[] newBytes = weaveClass(name, bytes,true);
                 this.generatedClassHandler.acceptClass(name,newBytes);
         	}
         	catch (IOException ex) {
@@ -125,7 +125,7 @@ public class WeavingURLClassLoader extends ExtensibleURLClassLoader implements W
 			}
 
 			try {
-				b = adaptor.weaveClass(name,b);
+				b = adaptor.weaveClass(name,b,false);
 			}
 			catch (AbortException ex) {
 	    		trace.error("defineClass",ex);
