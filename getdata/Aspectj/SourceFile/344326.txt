@@ -51,7 +51,7 @@ public class CompactTypeStructureRepresentation implements IBinaryType {
 	IBinaryNestedType[] memberTypes;
 	IBinaryAnnotation[] annotations;
 
-	public CompactTypeStructureRepresentation(ClassFileReader cfr) {
+	public CompactTypeStructureRepresentation(ClassFileReader cfr, boolean isAspect) {
 
 		this.enclosingTypeName = cfr.getEnclosingTypeName();
 		this.isLocal = cfr.isLocal();
@@ -69,7 +69,11 @@ public class CompactTypeStructureRepresentation implements IBinaryType {
 		if (binMethods == null) {
 			binMethods = NoMethod;
 		}
-		this.memberTypes = cfr.getMemberTypes(true);
+		// If we are an aspect we (for now) need to grab even the malformed inner type info as it
+		// may be there because it refers to an ITD'd innertype. This needs to be improved - perhaps
+		// using a real attribute against which memberTypes can be compared to see which are just
+		// references and which were real declarations
+		this.memberTypes = cfr.getMemberTypes(isAspect);
 		this.annotations = cfr.getAnnotations();
 		this.sourceName = cfr.getSourceName();
 		this.className = cfr.getName(); // slashes...
@@ -1471,8 +1471,12 @@ public class AjState implements CompilerConfigurationChangeFlags, TypeDelegateRe
 			if (!rType.isMissing()) {
 				try {
 					ClassFileReader reader = new ClassFileReader(thisTime.getBytes(), null);
+					boolean isAspect = false;
+					if (rType instanceof ReferenceType && ((ReferenceType) rType).getDelegate() != null) {
+						isAspect = ((ReferenceType) rType).isAspect();
+					}
 					this.resolvedTypeStructuresFromLastBuild.put(thisTime.getClassName(), new CompactTypeStructureRepresentation(
-							reader));
+							reader, isAspect));
 				} catch (ClassFormatException cfe) {
 					throw new BCException("Unexpected problem processing class", cfe);
 				}
@@ -1486,8 +1490,12 @@ public class AjState implements CompilerConfigurationChangeFlags, TypeDelegateRe
 		if (!newResolvedType.isMissing()) {
 			try {
 				ClassFileReader reader = new ClassFileReader(thisTime.getBytes(), null);
-				this.resolvedTypeStructuresFromLastBuild.put(thisTime.getClassName(),
-						new CompactTypeStructureRepresentation(reader));
+				boolean isAspect = false;
+				if (newResolvedType instanceof ReferenceType && ((ReferenceType) newResolvedType).getDelegate() != null) {
+					isAspect = ((ReferenceType) newResolvedType).isAspect();
+				}
+				this.resolvedTypeStructuresFromLastBuild.put(thisTime.getClassName(), new CompactTypeStructureRepresentation(
+						reader, isAspect));
 			} catch (ClassFormatException cfe) {
 				throw new BCException("Unexpected problem processing class", cfe);
 			}
@@ -0,0 +1,9 @@
+package foo;
+
+public class ClassReferencingTestClass {
+
+    public void test() {
+        new TestClass().callInner();
+    }
+}
+
@@ -0,0 +1,8 @@
+package foo;
+
+public class TestClass { 
+
+    public boolean callInner() {
+        return new TestClassWithInner.InnerTest().getTest();
+    }
+}
@@ -0,0 +1,10 @@
+package foo;
+
+public class TestClassWithInner {
+
+    public static class InnerTest{
+        public boolean getTest() {
+            return true; 
+        }
+    }
+}
@@ -0,0 +1,8 @@
+package foo;
+
+public class TestClass { 
+
+    public boolean callInner() {
+        return new TestClassWithInner.InnerTest().getTest();
+    }
+}
