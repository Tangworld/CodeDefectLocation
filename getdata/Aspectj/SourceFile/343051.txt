@@ -0,0 +1,13 @@
+package q;
+import p.*;
+
+privileged aspect X {
+  public void Code2.Inner.bar() {
+    Runnable r = new Runnable() {
+      public void run() {
+        System.out.println("abc");
+      }
+    };
+    r.run();
+  }
+}
@@ -0,0 +1,7 @@
+package p;
+
+public class Code {
+  public static void main(String []argv) {
+    new Code2().foo();
+  }
+}
@@ -0,0 +1,11 @@
+package p;
+
+public class Code2 {
+
+  public void foo() {
+    new Inner().bar();
+  }
+
+  class Inner {
+  }
+}
@@ -21,6 +21,10 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
  */
 public class Ajc1612Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testIllegalAccessError_343051() {
+		runTest("illegalaccesserror");
+	}
+	
 	public void testItitNpe_339974() {
 		runTest("itit npe");
 	}
@@ -2,6 +2,15 @@
 
 <suite>
 
+<ajc-test dir="bugs1612/pr343051" title="illegalaccesserror">
+<compile files="Code.java Code2.java Azpect.java" options="-1.5"/>
+<run class="p.Code">
+<stdout>
+<line text="abc"/>
+</stdout>
+</run>
+</ajc-test>
+
 <ajc-test dir="bugs1612/pr339974" title="itit npe">
 <compile files="City.java TrafficCalculator.java" options="-1.5">
 <message kind="error" text="The nested type TrafficCalculator cannot hide an enclosing type"/>
@@ -12,12 +12,14 @@
 
 package org.aspectj.ajdt.internal.compiler.ast;
 
+import java.lang.reflect.Modifier;
 import java.util.HashSet;
 import java.util.Set;
 
 import org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment;
 import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.ajdt.internal.compiler.lookup.InterTypeMethodBinding;
+import org.aspectj.asm.internal.CharOperation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend;
@@ -26,6 +28,7 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
+import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ParameterizedMethodBinding;
@@ -51,8 +54,24 @@ public class SuperFixerVisitor extends ASTVisitor {
 		this.method = method;
 		this.targetClass = targetClass;
 	}
+	
+	private static final char[] ctor = "<init>".toCharArray();
 
 	public boolean visit(TypeDeclaration localTypeDeclaration, BlockScope scope) {
+		if (localTypeDeclaration.binding instanceof LocalTypeBinding) {
+			if (((LocalTypeBinding)localTypeDeclaration.binding).isAnonymousType()) {
+				localTypeDeclaration.binding.modifiers |=Modifier.PUBLIC;
+				MethodBinding[] bindings = localTypeDeclaration.binding.methods;
+				if (bindings!=null) {
+					for (int i=0,max=bindings.length;i<max;i++) {
+						if (CharOperation.equals(bindings[i].selector,ctor)) {
+							bindings[i].modifiers|=Modifier.PUBLIC;
+						}
+					}
+				}
+//				localTypeDeclaration.modifiers|=Modifier.PUBLIC;
+			}
+		}
 		depthCounter++;
 		return super.visit(localTypeDeclaration, scope);
 	}
