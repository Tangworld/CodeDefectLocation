@@ -5543,6 +5543,8 @@
        <!-- warning is unchecked match of List<?> from line 28 onto line 15. -->
        <!-- some sets may be lists unless the set is final, so as a cast is allowed, the match is allowed -->
        <message kind="warning" line="28"/>
+       <message kind="warning" line="44"/>
+       <message kind="warning" line="48"/>
      </compile>
      <run class="AfterReturningListOfSomething">
          <stdout>
@@ -0,0 +1,12 @@
+import java.util.*;
+
+public aspect CodeFive {
+
+  void around(): execution(* m1(..)) && args(ArrayList) {}
+  
+}
+
+class C {
+	
+	public void m1(List<Integer> li) {}
+}
@@ -0,0 +1,265 @@
+import java.util.List;
+import java.util.ArrayList;
+
+
+public class C<E extends Number> {
+//      void m1(List<Integer> e){}      
+//      void m2(List<? extends Number> e){}
+//      void m3(List<Number> e){}       
+//      void m4(List<?> e){}
+//      void m5(List<E> e){}
+//      void m6(List<? extends E> e){}
+//      void m7(List<? extends List<? extends E>> e){}
+//      void m8(List e){}
+//      void m9(E e){}
+}
+
+class A1{}
+class B1 extends A1{}
+class C1 extends B1{}
+class D1 extends C1{}
+
+class D2<E2 extends C1>{
+        void m5(List<E2> e){}
+}
+
+aspect AC{
+//void around(): execution(* C.m1(..))  && args(List<Integer>){} //: Should
+match (it does)     
+//void around(): execution(* C.m1(..))  && args(ArrayList<Integer>){}//: Should
+runtime check (it does!)
+//void around(): execution(* C.m1(..))  && args(List<Number>){}//: Should not
+match (it does not!)      
+//void around(): execution(* C.m1(..))  && args(ArrayList<Number>){}//: Should
+not match (it does not)
+//void around(): execution(* C.m1(..))  && args(List<? extends Number>){}//:
+Should match (it does)
+//void around(): execution(* C.m1(..))  && args(ArrayList<? extends
+Number>){}//: Should runtime check (it does!)
+//void around(): execution(* C.m1(..))  && args(List){}//: Should match (it
+does)       
+//void around(): execution(* C.m1(..))  && args(ArrayList){}//: Should runtime
+check (it does not match!)ERROR  
+//void around(): execution(* C.m1(..))  && args(List<?>){}//: Should match (it
+does)    
+//void around(): execution(* C.m1(..))  && args(ArrayList<?>){}//: Should
+runtime check (it does not match!)    
+//void around(): execution(* C.m1(..))  && args(ArrayList<String>){}//: Should
+not match (it does not match!)
+
+//void around(): execution(* C.m2(..))  && args(List<Integer>){} //: Should not
+match (but it does) ERROR 
+//void around(): execution(* C.m2(..))  && args(ArrayList<Integer>){}//: Should
+not match (but it does!) ERROR
+//void around(): execution(* C.m2(..))  && args(List<Number>){} //: Should not
+match (but it does) ERROR
+//void around(): execution(* C.m2(..))  && args(ArrayList<Number>){}//: Should
+not runtime check (but it does!) ERROR
+//void around(): execution(* C.m2(..))  && args(List<? extends Number>){}//:
+Should match (it does)
+//void around(): execution(* C.m2(..))  && args(ArrayList<? extends
+Number>){}//: Should runtime check (it does!)
+//void around(): execution(* C.m2(..))  && args(List){}//: Should match (it
+does)       
+//void around(): execution(* C.m2(..))  && args(ArrayList){}//: Should runtime
+check (it does not match!) ERROR 
+//void around(): execution(* C.m2(..))  && args(List<?>){}//: Should match (it
+does)    
+//void around(): execution(* C.m2(..))  && args(ArrayList<?>){}//: Should
+runtime check (it does!)      
+//void around(): execution(* C.m2(..))  && args(ArrayList<String>){}//: Should
+not match (it does not match!)
+
+//      void around(): execution(* C.m3(..))  && args(List<Integer>){} //:
+Should not match (it does not) 
+//      void around(): execution(* C.m3(..))  && args(ArrayList<Integer>){}//:
+Should not match (it does not)
+//      void around(): execution(* C.m3(..))  && args(List<Number>){}//: Should
+match (it does) 
+//      void around(): execution(* C.m3(..))  && args(ArrayList<Number>){}//:
+Should runtime match (it does)
+//      void around(): execution(* C.m3(..))  && args(List<? extends
+Number>){}//: Should match (it does)
+//      void around(): execution(* C.m3(..))  && args(ArrayList<? extends
+Number>){}//: Should runtime check (it does!)
+//      void around(): execution(* C.m3(..))  && args(List){}//: Should match
+(it does) 
+//      void around(): execution(* C.m3(..))  && args(ArrayList){}//: Should
+runtime check (it does not match!) ERROR   
+//      void around(): execution(* C.m3(..))  && args(List<?>){}//: Should
+match (it does)      
+//      void around(): execution(* C.m3(..))  && args(ArrayList<?>){}//: Should
+runtime check (it does!)        
+//      void around(): execution(* C.m3(..))  && args(ArrayList<String>){}//:
+Should not match (it does not match!)     
+
+//      void around(): execution(* C.m4(..))  && args(List<Integer>){} //:
+Should not match (but it does) ERROR
+//      void around(): execution(* C.m4(..))  && args(ArrayList<Integer>){}//:
+Should not match (but it does) ERROR
+//      void around(): execution(* C.m4(..))  && args(List<Number>){}//: Should
+not match (but it does) ERROR
+//      void around(): execution(* C.m4(..))  && args(ArrayList<Number>){}//:
+Should not match (but it does) ERROR
+//      void around(): execution(* C.m4(..))  && args(List<? extends
+Number>){}//: Should not match (but it does) ERROR
+//      void around(): execution(* C.m4(..))  && args(ArrayList<? extends
+Number>){}//: Should not match (but it does!) ERROR
+//      void around(): execution(* C.m4(..))  && args(List){}//: Should match
+(it does) 
+//      void around(): execution(* C.m4(..))  && args(ArrayList){}//: Should
+runtime check (it does!)   
+//      void around(): execution(* C.m4(..))  && args(List<?>){}//: Should
+match (it does)      
+//      void around(): execution(* C.m4(..))  && args(ArrayList<?>){}//: Should
+runtime check (it does!)        
+//      void around(): execution(* C.m4(..))  && args(ArrayList<String>){}//:
+Should not match (it does not match!)     
+
+//      void around(): execution(* C.m5(..))  && args(List<Integer>){} //:
+Should not match (but it does) ERROR 
+//      void around(): execution(* C.m5(..))  && args(ArrayList<Integer>){}//:
+Should not match (but it does!) ERROR
+//      void around(): execution(* C.m5(..))  && args(List<Number>){}//: Should
+not match (but it does!) ERROR
+//      void around(): execution(* C.m5(..))  && args(ArrayList<Number>){}//:
+Should not match (it does) ERROR
+//      void around(): execution(* C.m5(..))  && args(List<? extends
+Number>){}//: Should match (it does)
+//      void around(): execution(* C.m5(..))  && args(ArrayList<? extends
+Number>){}//: Should runtime check (it does!)
+//      void around(): execution(* C.m5(..))  && args(List){}//: Should match
+(it does) 
+//      void around(): execution(* C.m5(..))  && args(ArrayList){}//: Should
+runtime check (it does not match!) ERROR   
+//      void around(): execution(* C.m5(..))  && args(List<?>){}//: Should
+match (it does)      
+//      void around(): execution(* C.m5(..))  && args(ArrayList<?>){}//: Should
+runtime check (it does not match!)      
+//      void around(): execution(* C.m5(..))  && args(ArrayList<String>){}//:
+Should not match (it does not match!) 
+
+//      void around(): execution(* D2.m5(..))  && args(List<D1>){} //: Should
+not match (but it does) ERROR 
+//      void around(): execution(* D2.m5(..))  && args(ArrayList<D1>){}//:
+Should not match (but it does!) ERROR
+//      void around(): execution(* D2.m5(..))  && args(List<C1>){}//: Should
+not match (but it does!) ERROR
+//      void around(): execution(* D2.m5(..))  && args(ArrayList<C1>){}//:
+Should not match (it does) ERROR
+//      void around(): execution(* D2.m5(..))  && args(List<? extends B1>){}//:
+Should match (it does)
+//      void around(): execution(* D2.m5(..))  && args(ArrayList<? extends
+B1>){}//: Should runtime check (it does!)
+//      void around(): execution(* D2.m5(..))  && args(List<? extends C1>){}//:
+Should match (it does)
+//      void around(): execution(* D2.m5(..))  && args(ArrayList<? extends
+C1>){}//: Should runtime check (it does!)
+//      void around(): execution(* D2.m5(..))  && args(List){}//: Should match
+(it does)        
+//      void around(): execution(* D2.m5(..))  && args(ArrayList){}//: Should
+runtime check (it does not match!) ERROR  
+//      void around(): execution(* D2.m5(..))  && args(List<?>){}//: Should
+match (it does)     
+//      void around(): execution(* D2.m5(..))  && args(ArrayList<?>){}//:
+Should runtime check (it does not match!)     
+//      void around(): execution(* D2.m5(..))  && args(ArrayList<String>){}//:
+Should not match (it does not match!)    
+
+//      void around(): execution(* C.m6(..))  && args(List<Integer>){} //:
+Should not match (but it does) ERROR 
+//      void around(): execution(* C.m6(..))  && args(ArrayList<Integer>){}//:
+Should not match (but it does!) ERROR
+//      void around(): execution(* C.m6(..))  && args(List<Number>){}//: Should
+not match (but it does!) ERROR
+//      void around(): execution(* C.m6(..))  && args(ArrayList<Number>){}//:
+Should not match (it does) ERROR
+//      void around(): execution(* C.m6(..))  && args(List<? extends
+Number>){}//: Should match (it does)
+//      void around(): execution(* C.m6(..))  && args(ArrayList<? extends
+Number>){}//: Should runtime check (it does!)
+//      void around(): execution(* C.m6(..))  && args(List){}//: Should match
+(it does) 
+//      void around(): execution(* C.m6(..))  && args(ArrayList){}//: Should
+runtime check (it does not match!) 
+//      void around(): execution(* C.m6(..))  && args(List<?>){}//: Should
+match (it does)      
+//      void around(): execution(* C.m6(..))  && args(ArrayList<?>){}//: Should
+runtime check (it does not match!)      
+//      void around(): execution(* C.m6(..))  && args(ArrayList<String>){}//:
+Should not match (it does not match!)             
+
+//      void around(): execution(* C.m7(..))  && args(List<List<Integer>>){}
+//: Should not match (but it does) ERROR 
+//      void around(): execution(* C.m7(..))  &&
+args(ArrayList<List<Integer>>){}//: Should not match (but it does!) ERROR
+//      void around(): execution(* C.m7(..))  && args(List<List<Number>>){}//:
+Should not match (but it does!) ERROR
+//      void around(): execution(* C.m7(..))  &&
+args(ArrayList<List<Number>>){}//: Should not match (but it does) ERROR
+//      void around(): execution(* C.m7(..))  && args(List<? extends
+List<Number>>){}//: Should not match (but it does) ERROR
+//      void around(): execution(* C.m7(..))  && args(ArrayList< ? extends
+List<Number>>){}//: Should not match (but it does!) ERROR
+//      void around(): execution(* C.m7(..))  && args(List< ? extends List<?
+extends Number>>){}//: Should match (it does!)     
+//      void around(): execution(* C.m7(..))  && args(ArrayList< ? extends
+List<? extends Number>>){}//: Should match (it does!)
+//      void around(): execution(* C.m7(..))  && args(List){}//: Should match
+(it does) 
+//      void around(): execution(* C.m7(..))  && args(ArrayList){}//: Should
+runtime check (it does not match!) 
+//      void around(): execution(* C.m7(..))  && args(List<?>){}//: Should
+match (it does)      
+//      void around(): execution(* C.m7(..))  && args(ArrayList<?>){}//: Should
+runtime check (it does!)        
+//      void around(): execution(* C.m7(..))  &&
+args(ArrayList<List<String>>){}//: Should not match (it does not match!)       
+
+//      void around(): execution(* C.m8(..))  && args(List<Integer>){} //:
+Should match with unchecked conversion (it does) 
+//      void around(): execution(* C.m8(..))  && args(ArrayList<Integer>){}//:
+Should runtime check with unchecked conversion (it does!)
+//      void around(): execution(* C.m8(..))  && args(List<Number>){}//: Should
+match with unchecked conversion (it does!)      
+//      void around(): execution(* C.m8(..))  && args(ArrayList<Number>){}//:
+Should runtime check with unchecked conversion (it does)
+//      void around(): execution(* C.m8(..))  && args(List<? extends
+Number>){}//: Should match with unchecked conversion (it does!)    
+//      void around(): execution(* C.m8(..))  && args(ArrayList<? extends
+Number>){}//: Should runtime check with unchecked conversion (it does)
+//      void around(): execution(* C.m8(..))  && args(List){}//: Should match
+(it does) 
+//      void around(): execution(* C.m8(..))  && args(ArrayList){}//: Should
+runtime check (it does!)   
+//      void around(): execution(* C.m8(..))  && args(List<?>){}//: Should
+match (it does)      
+//      void around(): execution(* C.m8(..))  && args(ArrayList<?>){}//: Should
+runtime check (it does!)        
+//      void around(): execution(* C.m8(..))  && args(ArrayList<String>){}//:
+Should not match (it does not match!)     
+
+//      void around(): execution(* C.m9(..))  && args(List<Integer>){} //:
+Should not match (but it does) ERROR 
+//      void around(): execution(* C.m9(..))  && args(ArrayList<Integer>){}//:
+Should not match (it does not match!)
+//      void around(): execution(* C.m9(..))  && args(Number){}//: Should match
+(it does!)      
+//      void around(): execution(* C.m9(..))  && args(Integer){}//: Should
+runtime check (it does)
+//      void around(): execution(* C.m9(..))  && args(List<? extends
+Number>){}//: Should not match (but it does) ERROR
+//      void around(): execution(* C.m9(..))  && args(ArrayList<? extends
+Number>){}//: Should not match (it does not match!)
+//      void around(): execution(* C.m9(..))  && args(List){}//: Should not
+match (but it does) ERROR   
+//      void around(): execution(* C.m9(..))  && args(ArrayList){}//: Should
+not match (it does not match!)     
+//      void around(): execution(* C.m9(..))  && args(List<?>){}//: Should not
+match (but it does) ERROR        
+//      void around(): execution(* C.m9(..))  && args(ArrayList<?>){}//: Should
+not match (it does not match!)  
+//      void around(): execution(* C.m9(..))  && args(String){}//: Should not
+match (it does not match!)        
+}
+
@@ -216,6 +216,14 @@ public class ReferenceType extends ResolvedType {
 			return isCoerceableFromParameterizedType(other);
 		}
 
+		if (this.isParameterizedType() && other.isRawType()) {
+			return ((ReferenceType) this.getRawType()).isCoerceableFrom(other.getGenericType());
+		}
+
+		if (this.isRawType() && other.isParameterizedType()) {
+			return this.getGenericType().isCoerceableFrom(((ReferenceType) other.getRawType()));
+		}
+
 		if (!this.isInterface() && !other.isInterface()) {
 			return false;
 		}
@@ -302,14 +310,17 @@ public class ReferenceType extends ResolvedType {
 			if (ResolvedType.validBoxing.contains(this.getSignature() + other.getSignature()))
 				return true;
 		}
-		if (this == other)
+		if (this == other) {
 			return true;
-		if (this.getSignature().equals(ResolvedType.OBJECT.getSignature()))
+		}
+		if (this.getSignature().equals(ResolvedType.OBJECT.getSignature())) {
 			return true;
+		}
 
 		if ((this.isRawType() || this.isGenericType()) && other.isParameterizedType()) {
-			if (isAssignableFrom((ResolvedType) other.getRawType()))
+			if (isAssignableFrom((ResolvedType) other.getRawType())) {
 				return true;
+			}
 		}
 		if (this.isRawType() && other.isGenericType()) {
 			if (isAssignableFrom((ResolvedType) other.getRawType()))
@@ -319,6 +330,11 @@ public class ReferenceType extends ResolvedType {
 			if (isAssignableFrom(other.getGenericType()))
 				return true;
 		}
+		// if (this.isParameterizedType() && other.isRawType()) {
+		// if (((ReferenceType) this.getRawType()).isAssignableFrom(other.getGenericType())) {
+		// return true;
+		// }
+		// }
 
 		if (this.isParameterizedType()) {
 			// look at wildcards...
@@ -11,10 +11,13 @@
  * ******************************************************************/
 package org.aspectj.weaver;
 
-import org.aspectj.weaver.bcel.BcelWorld;
+import java.util.ArrayList;
+import java.util.List;
 
 import junit.framework.TestCase;
 
+import org.aspectj.weaver.bcel.BcelWorld;
+
 // test cases for Adrian's additions to ReferenceType
 // XXX - couldn't find any unit test cases for the rest of the ReferenceType class
 public class ReferenceTypeTestCase extends TestCase {
@@ -24,29 +27,29 @@ public class ReferenceTypeTestCase extends TestCase {
 		world.setBehaveInJava5Way(true);
 		UnresolvedType javaLangClass = UnresolvedType.forName("java.lang.Class");
 		ResolvedType rtx = world.resolve(javaLangClass);
-		assertTrue("Resolves to reference type",(rtx instanceof ReferenceType));
+		assertTrue("Resolves to reference type", (rtx instanceof ReferenceType));
 		ReferenceType rt = (ReferenceType) rtx;
-		assertTrue("java.lang.Class is raw",rt.isRawType());
+		assertTrue("java.lang.Class is raw", rt.isRawType());
 	}
-	
+
 	public void testIsRawFalse() {
 		BcelWorld world = new BcelWorld();
 		world.setBehaveInJava5Way(true);
 		UnresolvedType javaLangObject = UnresolvedType.forName("java.lang.Object");
 		ResolvedType rtx = world.resolve(javaLangObject);
-		assertTrue("Resolves to reference type",(rtx instanceof ReferenceType));
+		assertTrue("Resolves to reference type", (rtx instanceof ReferenceType));
 		ReferenceType rt = (ReferenceType) rtx;
-		assertFalse("java.lang.Object is  not raw",rt.isRawType());		
+		assertFalse("java.lang.Object is  not raw", rt.isRawType());
 	}
-	
+
 	public void testIsGenericTrue() {
 		BcelWorld world = new BcelWorld();
 		world.setBehaveInJava5Way(true);
 		UnresolvedType javaLangClass = UnresolvedType.forName("java.lang.Class");
 		ResolvedType rtx = world.resolve(javaLangClass);
-		assertTrue("java.lang.Class has underpinning generic type",rtx.getGenericType().isGenericType());
+		assertTrue("java.lang.Class has underpinning generic type", rtx.getGenericType().isGenericType());
 	}
-	
+
 	public void testIsGenericFalse() {
 		BcelWorld world = new BcelWorld();
 		world.setBehaveInJava5Way(true);
@@ -54,5 +57,593 @@ public class ReferenceTypeTestCase extends TestCase {
 		ResolvedType rtx = world.resolve(javaLangObject);
 		assertFalse(rtx.isGenericType());
 	}
-	
+
+	BcelWorld world;
+
+	public void setUp() throws Exception {
+		super.setUp();
+		world = new BcelWorld();
+		world.setBehaveInJava5Way(true);
+	}
+
+	public void testCoercion01() {
+		ReferenceType listOfString = (ReferenceType) world.resolve(UnresolvedType
+				.forSignature("Pjava/util/List<Ljava/lang/String;>;"));
+		ReferenceType listOfInteger = (ReferenceType) world.resolve(UnresolvedType
+				.forSignature("Pjava/util/List<Ljava/lang/Integer;>;"));
+		assertFalse(listOfInteger.isAssignableFrom(listOfString));
+		assertFalse(listOfString.isAssignableFrom(listOfInteger));
+		assertFalse(listOfInteger.isCoerceableFrom(listOfString));
+		assertFalse(listOfString.isCoerceableFrom(listOfInteger));
+	}
+
+	public void testAssignable01() {
+		List list = new ArrayList();
+		List<String> listOfString = new ArrayList<String>();
+		List<?> listOfSomething = new ArrayList<Integer>();
+		List<? extends Number> listOfSomethingNumberish = new ArrayList<Integer>();
+		List<? super Double> listOfSomethingSuperDouble = new ArrayList<Number>();
+		// interfaces too List<? extends A,B>
+
+		ReferenceType ajList = resolve("Ljava/util/List;");
+		ReferenceType ajListOfString = resolve("Pjava/util/List<Ljava/lang/String;>;");
+		ReferenceType ajListOfSomething = resolve("Pjava/util/List<*>;");
+		ReferenceType ajListOfSomethingNumberish = resolve("Pjava/util/List<+Ljava/lang/Number;>;");
+		ReferenceType ajListOfSomethingSuperDouble = resolve("Pjava/util/List<-Ljava/lang/Double;>;");
+
+		// try and write the java equivalent, if it succeeds then check isAssignableFrom() is true
+		// if the java is only correct with a cast, check isCoerceableFrom()
+		list = listOfString;
+		assertTrue(ajList.isAssignableFrom(ajListOfString));
+		list = listOfSomething;
+		assertTrue(ajList.isAssignableFrom(ajListOfSomething));
+		list = listOfSomethingNumberish;
+		assertTrue(ajList.isAssignableFrom(ajListOfSomething));
+		list = listOfSomethingSuperDouble;
+		assertTrue(ajList.isAssignableFrom(ajListOfSomethingSuperDouble));
+
+		listOfString = list; // unchecked conversion to List<String>
+		assertFalse(ajListOfString.isAssignableFrom(ajList));
+		assertTrue(ajListOfString.isCoerceableFrom(ajListOfSomething));
+		// error: listOfString = listOfSomething;
+		assertFalse(ajListOfString.isAssignableFrom(ajListOfSomething));
+		// error: listOfString = listOfSomethingNumberish;
+		assertFalse(ajListOfString.isAssignableFrom(ajListOfSomethingNumberish));
+		// error: listOfString = listOfSomethingSuperDouble;
+		assertFalse(ajListOfString.isAssignableFrom(ajListOfSomethingSuperDouble));
+		// error: listOfString = (List<String>) listOfSomethingSuperDouble;
+		assertFalse(ajListOfString.isCoerceableFrom(ajListOfSomethingSuperDouble));
+
+		listOfSomething = list;
+		assertTrue(ajListOfSomething.isAssignableFrom(ajList));
+		listOfSomething = listOfString;
+		assertTrue(ajListOfSomething.isAssignableFrom(ajListOfString));
+		listOfSomething = listOfSomethingNumberish;
+		assertTrue(ajListOfSomething.isAssignableFrom(ajListOfSomething));
+		listOfSomething = listOfSomethingSuperDouble;
+		assertTrue(ajListOfSomething.isAssignableFrom(ajListOfSomethingSuperDouble));
+
+		listOfSomethingNumberish = list; // unchecked conversion
+		assertFalse(ajListOfSomethingNumberish.isAssignableFrom(ajList));
+		assertTrue(ajListOfSomethingNumberish.isCoerceableFrom(ajList));
+		// error: listOfSomethingNumberish = listOfString;
+		assertFalse(ajListOfSomethingNumberish.isAssignableFrom(ajListOfString));
+		assertFalse(ajListOfSomethingNumberish.isCoerceableFrom(ajListOfString));
+		// error: listOfSomethingNumberish = listOfSomething;
+		assertFalse(ajListOfSomethingNumberish.isAssignableFrom(ajListOfSomething));
+		listOfSomethingNumberish = (List<? extends Number>) listOfSomething;
+		assertTrue(ajListOfSomethingNumberish.isCoerceableFrom(ajListOfSomething));
+		// error: listOfSomethingNumberish = listOfSomethingSuperDouble;
+		assertFalse(ajListOfSomethingNumberish.isAssignableFrom(ajListOfSomethingSuperDouble));
+		// listOfSomethingNumberish = (List<? extends Number>) listOfSomethingSuperDouble;
+		// assertTrue(ajListOfSomethingNumberish.isCoerceableFrom(ajListOfSomethingSuperDouble));
+	}
+
+	class C<E extends Number> {
+		void m1(List<Integer> e) {
+		}
+
+		void m2(List<? extends Number> e) {
+		}
+
+		void m3(List<Number> e) {
+		}
+
+		void m4(List<?> e) {
+		}
+
+		void m5(List<E> e) {
+		}
+
+		void m6(List<? extends E> e) {
+		}
+
+		void m7(List<? extends List<? extends E>> e) {
+		}
+
+		void m8(List e) {
+		}
+
+		void m9(E e) {
+		}
+	}
+
+	class A1 {
+	}
+
+	class B1 extends A1 {
+	}
+
+	class C1 extends B1 {
+	}
+
+	class D1 extends C1 {
+	}
+
+	class D2<E2 extends C1> {
+		void m5(List<E2> e) {
+		}
+	}
+
+	public void testAssignable02() {
+		List list = new ArrayList();
+		ArrayList arraylist = null;
+		List<String> listOfString = new ArrayList<String>();
+		List<?> listOfSomething = new ArrayList<Integer>();
+		ArrayList<?> arrayListOfSomething = null;
+		List<Number> listOfNumber = null;
+		ArrayList<Number> arrayListOfNumber = null;
+		ArrayList<? extends Number> arrayListOfSomethingNumberish = null;
+		List<? extends Number> listOfSomethingNumberish = new ArrayList<Integer>();
+		List<? super Double> listOfSomethingSuperDouble = new ArrayList<Number>();
+		List<Integer> listOfInteger = new ArrayList<Integer>();
+		ArrayList<String> arrayListOfString;
+		ArrayList<Integer> arraylistOfInteger;
+		// interfaces too List<? extends A,B>
+
+		ReferenceType ajArrayListOfString = resolve("Pjava/util/ArrayList<Ljava/lang/String;>;");
+		ReferenceType ajArrayListOfInteger = resolve("Pjava/util/ArrayList<Ljava/lang/Integer;>;");
+		ReferenceType ajArrayListOfNumber = resolve("Pjava/util/ArrayList<Ljava/lang/Number;>;");
+		ReferenceType ajArrayListOfSomethingNumberish = resolve("Pjava/util/ArrayList<+Ljava/lang/Number;>;");
+		ReferenceType ajList = resolve("Ljava/util/List;");
+		ReferenceType ajArrayList = resolve("Ljava/util/ArrayList;");
+		ReferenceType ajListOfString = resolve("Pjava/util/List<Ljava/lang/String;>;");
+		ReferenceType ajListOfSomething = resolve("Pjava/util/List<*>;");
+		ReferenceType ajArrayListOfSomething = resolve("Pjava/util/ArrayList<*>;");
+		ReferenceType ajListOfSomethingNumberish = resolve("Pjava/util/List<+Ljava/lang/Number;>;");
+		ReferenceType ajListOfSomethingSuperDouble = resolve("Pjava/util/List<-Ljava/lang/Double;>;");
+		ReferenceType ajListOfInteger = resolve("Pjava/util/List<Ljava/lang/Integer;>;");
+		ReferenceType ajListOfNumber = resolve("Pjava/util/List<Ljava/lang/Number;>;");
+		// Effectively, whether the advice matches is based on whether what we pass at the joinpoint could
+		// be bound to the specification in the args() pointcut
+
+		// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)
+		assertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));
+
+		// void around(): execution(* C.m1(..)) && args(ArrayList<Integer>){}//: Should runtime check (it does!)
+		ArrayList<Integer> x = (ArrayList<Integer>) listOfInteger;
+		assertFalse(ajArrayListOfInteger.isAssignableFrom(ajListOfInteger));
+		assertTrue(ajArrayListOfInteger.isCoerceableFrom(ajListOfInteger));
+
+		// void around(): execution(* C.m1(..)) && args(List<Number>){} // Should not match (it does not!)
+		// error: listOfNumber = listOfInteger;
+		assertFalse(ajListOfNumber.isAssignableFrom(ajListOfInteger));
+		assertFalse(ajListOfNumber.isCoerceableFrom(ajListOfInteger));
+
+		// void around(): execution(* C.m1(..)) && args(ArrayList<Number>){} // Should not match (it does not)
+		// error: arrayListOfNumber = listOfInteger;
+		assertFalse(ajArrayListOfNumber.isAssignableFrom(ajListOfInteger));
+		assertFalse(ajArrayListOfNumber.isCoerceableFrom(ajListOfInteger));
+
+		// void around(): execution(* C.m1(..)) && args(List<? extends Number>){} // Should match (it does)
+		listOfSomethingNumberish = listOfInteger;
+		assertTrue(ajListOfSomethingNumberish.isAssignableFrom(ajListOfInteger));
+
+		// void around(): execution(* C.m1(..)) && args(ArrayList<? extends Number>){}// Should runtime check (it does!)
+		arrayListOfSomethingNumberish = (ArrayList<? extends Number>) listOfInteger;
+		assertFalse(ajArrayListOfSomethingNumberish.isAssignableFrom(ajListOfInteger));
+		assertTrue(ajArrayListOfSomethingNumberish.isCoerceableFrom(ajListOfInteger));
+
+		// void around(): execution(* C.m1(..)) && args(List){}// Should match (it does)
+		list = listOfInteger;
+		assertTrue(ajList.isAssignableFrom(ajListOfInteger));
+
+		// void around(): execution(* C.m1(..)) && args(ArrayList){}//: Should runtime check (it does not match!)
+		arraylist = (ArrayList) listOfInteger;
+		assertFalse(ajArrayList.isAssignableFrom(ajListOfInteger));
+		assertTrue(ajArrayList.isCoerceableFrom(ajListOfInteger));
+
+		// void around(): execution(* C.m1(..)) && args(List<?>){}// Should match (it does)
+		listOfSomething = listOfInteger;
+		assertTrue(ajListOfSomething.isAssignableFrom(ajListOfInteger));
+
+		// void around(): execution(* C.m1(..)) && args(ArrayList<?>){}// Should runtime check (it does not match!)
+		arrayListOfSomething = (ArrayList<?>) listOfInteger;
+		assertFalse(ajArrayListOfSomething.isAssignableFrom(ajListOfInteger));
+		assertTrue(ajArrayListOfSomething.isCoerceableFrom(ajListOfInteger));
+
+		// void around(): execution(* C.m1(..)) && args(ArrayList<String>){}// Should not match (it does not match!)
+		// error: arrayListOfString = listOfInteger;
+		assertFalse(ajArrayListOfString.isAssignableFrom(ajListOfInteger));
+		assertFalse(ajArrayListOfString.isCoerceableFrom(ajListOfInteger));
+	}
+
+	public void testAssignable03_method_m2() {
+		List list = new ArrayList();
+		ArrayList arraylist = null;
+		List<String> listOfString = new ArrayList<String>();
+		List<?> listOfSomething = new ArrayList<Integer>();
+		ArrayList<?> arrayListOfSomething = null;
+		List<Number> listOfNumber = null;
+		ArrayList<Number> arrayListOfNumber = null;
+		ArrayList<Integer> arrayListOfInteger = null;
+		ArrayList<? extends Number> arrayListOfSomethingNumberish = null;
+		List<? extends Number> listOfSomethingNumberish = new ArrayList<Integer>();
+		List<? super Double> listOfSomethingSuperDouble = new ArrayList<Number>();
+		List<Integer> listOfInteger = new ArrayList<Integer>();
+		ArrayList<String> arrayListOfString;
+		ArrayList<Integer> arraylistOfInteger;
+		// interfaces too List<? extends A,B>
+
+		ReferenceType ajArrayListOfString = resolve("Pjava/util/ArrayList<Ljava/lang/String;>;");
+		ReferenceType ajArrayListOfInteger = resolve("Pjava/util/ArrayList<Ljava/lang/Integer;>;");
+		ReferenceType ajArrayListOfNumber = resolve("Pjava/util/ArrayList<Ljava/lang/Number;>;");
+		ReferenceType ajArrayListOfSomethingNumberish = resolve("Pjava/util/ArrayList<+Ljava/lang/Number;>;");
+		ReferenceType ajList = resolve("Ljava/util/List;");
+		ReferenceType ajArrayList = resolve("Ljava/util/ArrayList;");
+		ReferenceType ajListOfString = resolve("Pjava/util/List<Ljava/lang/String;>;");
+		ReferenceType ajListOfSomething = resolve("Pjava/util/List<*>;");
+		ReferenceType ajArrayListOfSomething = resolve("Pjava/util/ArrayList<*>;");
+		ReferenceType ajListOfSomethingNumberish = resolve("Pjava/util/List<+Ljava/lang/Number;>;");
+		ReferenceType ajListOfSomethingSuperDouble = resolve("Pjava/util/List<-Ljava/lang/Double;>;");
+		ReferenceType ajListOfInteger = resolve("Pjava/util/List<Ljava/lang/Integer;>;");
+		ReferenceType ajListOfNumber = resolve("Pjava/util/List<Ljava/lang/Number;>;");
+
+		// void m2(List<? extends Number> e) {}
+
+		// comment 11
+		// void around(): execution(* C.m2(..)) && args(List<Integer>){} //: Should not match (but it does) ERROR
+		listOfInteger = (List<Integer>) listOfSomethingNumberish;
+		assertFalse(ajListOfInteger.isAssignableFrom(ajListOfSomethingNumberish));
+		assertTrue(ajListOfInteger.isCoerceableFrom(ajListOfSomethingNumberish));
+
+		// void around(): execution(* C.m2(..)) && args(ArrayList<Integer>){}//: Should not match (but it does!) ERROR
+		arrayListOfInteger = (ArrayList<Integer>) listOfSomethingNumberish;
+		assertFalse(ajArrayListOfInteger.isAssignableFrom(ajListOfSomethingNumberish));
+		assertTrue(ajArrayListOfInteger.isCoerceableFrom(ajListOfSomethingNumberish));
+
+		// void around(): execution(* C.m2(..)) && args(List<Number>){} //: Should not match (but it does) ERROR
+		listOfNumber = (List<Number>) listOfSomethingNumberish;
+		assertFalse(ajListOfNumber.isAssignableFrom(ajListOfSomethingNumberish));
+		assertTrue(ajListOfNumber.isCoerceableFrom(ajListOfSomethingNumberish));
+
+		// void around(): execution(* C.m2(..)) && args(ArrayList<Number>){}//: Should not runtime check (but it does!) ERROR
+		arrayListOfNumber = (ArrayList<Number>) listOfSomethingNumberish;
+		assertFalse(ajArrayListOfNumber.isAssignableFrom(ajListOfSomethingNumberish));
+		assertTrue(ajArrayListOfNumber.isCoerceableFrom(ajListOfSomethingNumberish));
+
+		// void around(): execution(* C.m2(..)) && args(List<? extends Number>){}//: Should match (it does)
+		listOfSomethingNumberish = listOfSomethingNumberish;
+		assertTrue(ajListOfSomethingNumberish.isAssignableFrom(ajListOfSomethingNumberish));
+
+		// void around(): execution(* C.m2(..)) && args(ArrayList<? extends Number>){}//: Should runtime check (it does!)
+		arrayListOfSomethingNumberish = (ArrayList<? extends Number>) listOfSomethingNumberish;
+		assertFalse(ajArrayListOfSomethingNumberish.isAssignableFrom(ajListOfSomethingNumberish));
+		assertTrue(ajArrayListOfSomethingNumberish.isCoerceableFrom(ajListOfSomethingNumberish));
+
+		// void around(): execution(* C.m2(..)) && args(List){}//: Should match (it does)
+		list = listOfSomethingNumberish;
+		assertTrue(ajList.isAssignableFrom(ajListOfSomethingNumberish));
+
+		// void around(): execution(* C.m2(..)) && args(ArrayList){}//: Should runtime check (it does not match!) ERROR
+		arraylist = (ArrayList) listOfSomethingNumberish;
+		assertFalse(ajArrayList.isAssignableFrom(ajListOfSomethingNumberish));
+		assertTrue(ajArrayList.isCoerceableFrom(ajListOfSomethingNumberish));
+
+		// void around(): execution(* C.m2(..)) && args(List<?>){}//: Should match (it does)
+		listOfSomething = listOfSomethingNumberish;
+		assertTrue(ajListOfSomething.isAssignableFrom(ajListOfSomethingNumberish));
+
+		// void around(): execution(* C.m2(..)) && args(ArrayList<?>){}//: Should runtime check (it does!)
+		arrayListOfSomething = (ArrayList) listOfSomethingNumberish;
+		assertFalse(ajArrayListOfSomething.isAssignableFrom(ajListOfSomethingNumberish));
+		assertTrue(ajArrayListOfSomething.isCoerceableFrom(ajListOfSomethingNumberish));
+
+		// void around(): execution(* C.m2(..)) && args(ArrayList<String>){}//: Should not match (it does not match!)
+		// error: arrayListOfString = listOfSomethingNumberish;
+		assertFalse(ajArrayListOfString.isAssignableFrom(ajListOfSomethingNumberish));
+		assertFalse(ajArrayListOfString.isCoerceableFrom(ajListOfSomethingNumberish));
+	}
+
+	public void testAssignable04_method_m3() {
+		List list = new ArrayList();
+		ArrayList arraylist = null;
+		List<String> listOfString = new ArrayList<String>();
+		List<?> listOfSomething = new ArrayList<Integer>();
+		ArrayList<?> arrayListOfSomething = null;
+		List<Number> listOfNumber = null;
+		ArrayList<Number> arrayListOfNumber = null;
+		ArrayList<Integer> arrayListOfInteger = null;
+		ArrayList<? extends Number> arrayListOfSomethingNumberish = null;
+		List<? extends Number> listOfSomethingNumberish = new ArrayList<Integer>();
+		List<? super Double> listOfSomethingSuperDouble = new ArrayList<Number>();
+		List<Integer> listOfInteger = new ArrayList<Integer>();
+		ArrayList arrayList = null;
+		ArrayList<String> arrayListOfString;
+		ArrayList<Integer> arraylistOfInteger;
+		// interfaces too List<? extends A,B>
+
+		ReferenceType ajArrayListOfString = resolve("Pjava/util/ArrayList<Ljava/lang/String;>;");
+		ReferenceType ajArrayListOfInteger = resolve("Pjava/util/ArrayList<Ljava/lang/Integer;>;");
+		ReferenceType ajArrayListOfNumber = resolve("Pjava/util/ArrayList<Ljava/lang/Number;>;");
+		ReferenceType ajArrayListOfSomethingNumberish = resolve("Pjava/util/ArrayList<+Ljava/lang/Number;>;");
+		ReferenceType ajList = resolve("Ljava/util/List;");
+		ReferenceType ajArrayList = resolve("Ljava/util/ArrayList;");
+		ReferenceType ajListOfString = resolve("Pjava/util/List<Ljava/lang/String;>;");
+		ReferenceType ajListOfSomething = resolve("Pjava/util/List<*>;");
+		ReferenceType ajArrayListOfSomething = resolve("Pjava/util/ArrayList<*>;");
+		ReferenceType ajListOfSomethingNumberish = resolve("Pjava/util/List<+Ljava/lang/Number;>;");
+		ReferenceType ajListOfSomethingSuperDouble = resolve("Pjava/util/List<-Ljava/lang/Double;>;");
+		ReferenceType ajListOfInteger = resolve("Pjava/util/List<Ljava/lang/Integer;>;");
+		ReferenceType ajListOfNumber = resolve("Pjava/util/List<Ljava/lang/Number;>;");
+
+		// void m3(List<Number> e) { }
+
+		// void around(): execution(* C.m3(..)) && args(List<Integer>){} //: Should not match (it does not)
+		// error: listOfInteger = listOfNumber;
+		assertFalse(ajListOfInteger.isAssignableFrom(ajListOfNumber));
+		assertFalse(ajListOfInteger.isCoerceableFrom(ajListOfNumber));
+
+		// void around(): execution(* C.m3(..)) && args(ArrayList<Integer>){}//: Should not match (it does not)
+		// error: arrayListOfInteger = listOfNumber;
+		assertFalse(ajArrayListOfInteger.isAssignableFrom(ajListOfNumber));
+		assertFalse(ajArrayListOfInteger.isCoerceableFrom(ajListOfNumber));
+
+		// void around(): execution(* C.m3(..)) && args(List<Number>){}//: Should match (it does)
+		listOfNumber = listOfNumber;
+		assertTrue(ajListOfNumber.isAssignableFrom(ajListOfNumber));
+
+		// void around(): execution(* C.m3(..)) && args(ArrayList<Number>){}//: Should runtime match (it does)
+		arrayListOfNumber = (ArrayList<Number>) listOfNumber;
+		assertFalse(ajArrayListOfNumber.isAssignableFrom(ajListOfNumber));
+		assertTrue(ajArrayListOfNumber.isCoerceableFrom(ajListOfNumber));
+
+		// void around(): execution(* C.m3(..)) && args(List<? extends Number>){}//: Should match (it does)
+		listOfSomethingNumberish = listOfNumber;
+		assertTrue(ajListOfSomethingNumberish.isAssignableFrom(ajListOfNumber));
+
+		// void around(): execution(* C.m3(..)) && args(ArrayList<? extends Number>){}//: Should runtime check (it does!)
+		arrayListOfSomethingNumberish = (ArrayList<? extends Number>) listOfNumber;
+		assertFalse(ajArrayListOfSomethingNumberish.isAssignableFrom(ajListOfNumber));
+		assertTrue(ajArrayListOfSomethingNumberish.isCoerceableFrom(ajListOfNumber));
+
+		// void around(): execution(* C.m3(..)) && args(List){}//: Should match (it does)
+		list = listOfNumber;
+		assertTrue(ajList.isAssignableFrom(ajListOfNumber));
+
+		// void around(): execution(* C.m3(..)) && args(ArrayList){}//: Should runtime check (it does not match!) ERROR
+		arrayList = (ArrayList) listOfNumber;
+		assertFalse(ajArrayList.isAssignableFrom(ajListOfNumber));
+		assertTrue(ajArrayList.isCoerceableFrom(ajListOfNumber));
+
+		// void around(): execution(* C.m3(..)) && args(List<?>){}//: Should match (it does)
+		listOfSomething = listOfNumber;
+		assertTrue(ajListOfSomething.isAssignableFrom(ajListOfNumber));
+
+		// void around(): execution(* C.m3(..)) && args(ArrayList<?>){}//: Should runtime check (it does!)
+		arrayListOfSomething = (ArrayList<?>) listOfNumber;
+		assertFalse(ajArrayListOfSomething.isAssignableFrom(ajListOfNumber));
+		assertTrue(ajArrayListOfSomething.isCoerceableFrom(ajListOfNumber));
+
+		// void around(): execution(* C.m3(..)) && args(ArrayList<String>){}//: Should not match (it does not match!)
+		// error: arrayListOfString = listOfNumber;
+		assertFalse(ajArrayListOfString.isAssignableFrom(ajListOfNumber));
+		assertFalse(ajArrayListOfString.isCoerceableFrom(ajListOfNumber));
+	}
+
+	public void testAssignable03_method_m4() {
+		List list = new ArrayList();
+		ArrayList arraylist = null;
+		List<String> listOfString = new ArrayList<String>();
+		List<?> listOfSomething = new ArrayList<Integer>();
+		ArrayList<?> arrayListOfSomething = null;
+		List<Number> listOfNumber = null;
+		ArrayList<Number> arrayListOfNumber = null;
+		ArrayList<? extends Number> arrayListOfSomethingNumberish = null;
+		List<? extends Number> listOfSomethingNumberish = new ArrayList<Integer>();
+		List<? super Double> listOfSomethingSuperDouble = new ArrayList<Number>();
+		List<Integer> listOfInteger = new ArrayList<Integer>();
+		ArrayList<String> arrayListOfString;
+		ArrayList<Integer> arraylistOfInteger;
+		// interfaces too List<? extends A,B>
+
+		ReferenceType ajArrayListOfString = resolve("Pjava/util/ArrayList<Ljava/lang/String;>;");
+		ReferenceType ajArrayListOfInteger = resolve("Pjava/util/ArrayList<Ljava/lang/Integer;>;");
+		ReferenceType ajArrayListOfNumber = resolve("Pjava/util/ArrayList<Ljava/lang/Number;>;");
+		ReferenceType ajArrayListOfSomethingNumberish = resolve("Pjava/util/ArrayList<+Ljava/lang/Number;>;");
+		ReferenceType ajList = resolve("Ljava/util/List;");
+		ReferenceType ajArrayList = resolve("Ljava/util/ArrayList;");
+		ReferenceType ajListOfString = resolve("Pjava/util/List<Ljava/lang/String;>;");
+		ReferenceType ajListOfSomething = resolve("Pjava/util/List<*>;");
+		ReferenceType ajArrayListOfSomething = resolve("Pjava/util/ArrayList<*>;");
+		ReferenceType ajListOfSomethingNumberish = resolve("Pjava/util/List<+Ljava/lang/Number;>;");
+		ReferenceType ajListOfSomethingSuperDouble = resolve("Pjava/util/List<-Ljava/lang/Double;>;");
+		ReferenceType ajListOfInteger = resolve("Pjava/util/List<Ljava/lang/Integer;>;");
+		ReferenceType ajListOfNumber = resolve("Pjava/util/List<Ljava/lang/Number;>;");
+
+		//
+		// // void around(): execution(* C.m4(..)) && args(List<Integer>){} //:
+		// Should not match (but it does) ERROR
+		// // void around(): execution(* C.m4(..)) && args(ArrayList<Integer>){}//:
+		// Should not match (but it does) ERROR
+		// // void around(): execution(* C.m4(..)) && args(List<Number>){}//: Should
+		// not match (but it does) ERROR
+		// // void around(): execution(* C.m4(..)) && args(ArrayList<Number>){}//:
+		// Should not match (but it does) ERROR
+		// // void around(): execution(* C.m4(..)) && args(List<? extends
+		// Number>){}//: Should not match (but it does) ERROR
+		// // void around(): execution(* C.m4(..)) && args(ArrayList<? extends
+		// Number>){}//: Should not match (but it does!) ERROR
+		// // void around(): execution(* C.m4(..)) && args(List){}//: Should match
+		// (it does)
+		// // void around(): execution(* C.m4(..)) && args(ArrayList){}//: Should
+		// runtime check (it does!)
+		// // void around(): execution(* C.m4(..)) && args(List<?>){}//: Should
+		// match (it does)
+		// // void around(): execution(* C.m4(..)) && args(ArrayList<?>){}//: Should
+		// runtime check (it does!)
+		// // void around(): execution(* C.m4(..)) && args(ArrayList<String>){}//:
+		// Should not match (it does not match!)
+		//
+		// // void around(): execution(* C.m5(..)) && args(List<Integer>){} //:
+		// Should not match (but it does) ERROR
+		// // void around(): execution(* C.m5(..)) && args(ArrayList<Integer>){}//:
+		// Should not match (but it does!) ERROR
+		// // void around(): execution(* C.m5(..)) && args(List<Number>){}//: Should
+		// not match (but it does!) ERROR
+		// // void around(): execution(* C.m5(..)) && args(ArrayList<Number>){}//:
+		// Should not match (it does) ERROR
+		// // void around(): execution(* C.m5(..)) && args(List<? extends
+		// Number>){}//: Should match (it does)
+		// // void around(): execution(* C.m5(..)) && args(ArrayList<? extends
+		// Number>){}//: Should runtime check (it does!)
+		// // void around(): execution(* C.m5(..)) && args(List){}//: Should match
+		// (it does)
+		// // void around(): execution(* C.m5(..)) && args(ArrayList){}//: Should
+		// runtime check (it does not match!) ERROR
+		// // void around(): execution(* C.m5(..)) && args(List<?>){}//: Should
+		// match (it does)
+		// // void around(): execution(* C.m5(..)) && args(ArrayList<?>){}//: Should
+		// runtime check (it does not match!)
+		// // void around(): execution(* C.m5(..)) && args(ArrayList<String>){}//:
+		// Should not match (it does not match!)
+		//
+		// // void around(): execution(* D2.m5(..)) && args(List<D1>){} //: Should
+		// not match (but it does) ERROR
+		// // void around(): execution(* D2.m5(..)) && args(ArrayList<D1>){}//:
+		// Should not match (but it does!) ERROR
+		// // void around(): execution(* D2.m5(..)) && args(List<C1>){}//: Should
+		// not match (but it does!) ERROR
+		// // void around(): execution(* D2.m5(..)) && args(ArrayList<C1>){}//:
+		// Should not match (it does) ERROR
+		// // void around(): execution(* D2.m5(..)) && args(List<? extends B1>){}//:
+		// Should match (it does)
+		// // void around(): execution(* D2.m5(..)) && args(ArrayList<? extends
+		// B1>){}//: Should runtime check (it does!)
+		// // void around(): execution(* D2.m5(..)) && args(List<? extends C1>){}//:
+		// Should match (it does)
+		// // void around(): execution(* D2.m5(..)) && args(ArrayList<? extends
+		// C1>){}//: Should runtime check (it does!)
+		// // void around(): execution(* D2.m5(..)) && args(List){}//: Should match
+		// (it does)
+		// // void around(): execution(* D2.m5(..)) && args(ArrayList){}//: Should
+		// runtime check (it does not match!) ERROR
+		// // void around(): execution(* D2.m5(..)) && args(List<?>){}//: Should
+		// match (it does)
+		// // void around(): execution(* D2.m5(..)) && args(ArrayList<?>){}//:
+		// Should runtime check (it does not match!)
+		// // void around(): execution(* D2.m5(..)) && args(ArrayList<String>){}//:
+		// Should not match (it does not match!)
+		//
+		// // void around(): execution(* C.m6(..)) && args(List<Integer>){} //:
+		// Should not match (but it does) ERROR
+		// // void around(): execution(* C.m6(..)) && args(ArrayList<Integer>){}//:
+		// Should not match (but it does!) ERROR
+		// // void around(): execution(* C.m6(..)) && args(List<Number>){}//: Should
+		// not match (but it does!) ERROR
+		// // void around(): execution(* C.m6(..)) && args(ArrayList<Number>){}//:
+		// Should not match (it does) ERROR
+		// // void around(): execution(* C.m6(..)) && args(List<? extends
+		// Number>){}//: Should match (it does)
+		// // void around(): execution(* C.m6(..)) && args(ArrayList<? extends
+		// Number>){}//: Should runtime check (it does!)
+		// // void around(): execution(* C.m6(..)) && args(List){}//: Should match
+		// (it does)
+		// // void around(): execution(* C.m6(..)) && args(ArrayList){}//: Should
+		// runtime check (it does not match!)
+		// // void around(): execution(* C.m6(..)) && args(List<?>){}//: Should
+		// match (it does)
+		// // void around(): execution(* C.m6(..)) && args(ArrayList<?>){}//: Should
+		// runtime check (it does not match!)
+		// // void around(): execution(* C.m6(..)) && args(ArrayList<String>){}//:
+		// Should not match (it does not match!)
+		//
+		// // void around(): execution(* C.m7(..)) && args(List<List<Integer>>){}
+		// //: Should not match (but it does) ERROR
+		// // void around(): execution(* C.m7(..)) &&
+		// args(ArrayList<List<Integer>>){}//: Should not match (but it does!) ERROR
+		// // void around(): execution(* C.m7(..)) && args(List<List<Number>>){}//:
+		// Should not match (but it does!) ERROR
+		// // void around(): execution(* C.m7(..)) &&
+		// args(ArrayList<List<Number>>){}//: Should not match (but it does) ERROR
+		// // void around(): execution(* C.m7(..)) && args(List<? extends
+		// List<Number>>){}//: Should not match (but it does) ERROR
+		// // void around(): execution(* C.m7(..)) && args(ArrayList< ? extends
+		// List<Number>>){}//: Should not match (but it does!) ERROR
+		// // void around(): execution(* C.m7(..)) && args(List< ? extends List<?
+		// extends Number>>){}//: Should match (it does!)
+		// // void around(): execution(* C.m7(..)) && args(ArrayList< ? extends
+		// List<? extends Number>>){}//: Should match (it does!)
+		// // void around(): execution(* C.m7(..)) && args(List){}//: Should match
+		// (it does)
+		// // void around(): execution(* C.m7(..)) && args(ArrayList){}//: Should
+		// runtime check (it does not match!)
+		// // void around(): execution(* C.m7(..)) && args(List<?>){}//: Should
+		// match (it does)
+		// // void around(): execution(* C.m7(..)) && args(ArrayList<?>){}//: Should
+		// runtime check (it does!)
+		// // void around(): execution(* C.m7(..)) &&
+		// args(ArrayList<List<String>>){}//: Should not match (it does not match!)
+		//
+		// // void around(): execution(* C.m8(..)) && args(List<Integer>){} //:
+		// Should match with unchecked conversion (it does)
+		// // void around(): execution(* C.m8(..)) && args(ArrayList<Integer>){}//:
+		// Should runtime check with unchecked conversion (it does!)
+		// // void around(): execution(* C.m8(..)) && args(List<Number>){}//: Should
+		// match with unchecked conversion (it does!)
+		// // void around(): execution(* C.m8(..)) && args(ArrayList<Number>){}//:
+		// Should runtime check with unchecked conversion (it does)
+		// // void around(): execution(* C.m8(..)) && args(List<? extends
+		// Number>){}//: Should match with unchecked conversion (it does!)
+		// // void around(): execution(* C.m8(..)) && args(ArrayList<? extends
+		// Number>){}//: Should runtime check with unchecked conversion (it does)
+		// // void around(): execution(* C.m8(..)) && args(List){}//: Should match
+		// (it does)
+		// // void around(): execution(* C.m8(..)) && args(ArrayList){}//: Should
+		// runtime check (it does!)
+		// // void around(): execution(* C.m8(..)) && args(List<?>){}//: Should
+		// match (it does)
+		// // void around(): execution(* C.m8(..)) && args(ArrayList<?>){}//: Should
+		// runtime check (it does!)
+		// // void around(): execution(* C.m8(..)) && args(ArrayList<String>){}//:
+		// Should not match (it does not match!)
+		//
+		// // void around(): execution(* C.m9(..)) && args(List<Integer>){} //:
+		// Should not match (but it does) ERROR
+		// // void around(): execution(* C.m9(..)) && args(ArrayList<Integer>){}//:
+		// Should not match (it does not match!)
+		// // void around(): execution(* C.m9(..)) && args(Number){}//: Should match
+		// (it does!)
+		// // void around(): execution(* C.m9(..)) && args(Integer){}//: Should
+		// runtime check (it does)
+		// // void around(): execution(* C.m9(..)) && args(List<? extends
+		// Number>){}//: Should not match (but it does) ERROR
+		// // void around(): execution(* C.m9(..)) && args(ArrayList<? extends
+		// Number>){}//: Should not match (it does not match!)
+		// // void around(): execution(* C.m9(..)) && args(List){}//: Should not
+		// match (but it does) ERROR
+		// // void around(): execution(* C.m9(..)) && args(ArrayList){}//: Should
+		// not match (it does not match!)
+		// // void around(): execution(* C.m9(..)) && args(List<?>){}//: Should not
+		// match (but it does) ERROR
+		// // void around(): execution(* C.m9(..)) && args(ArrayList<?>){}//: Should
+		// not match (it does not match!)
+		// // void around(): execution(* C.m9(..)) && args(String){}//: Should not
+		// match (it does not match!)
+
+	}
+
+	private ReferenceType resolve(String sig) {
+		return (ReferenceType) world.resolve(UnresolvedType.forSignature(sig));
+	}
 }
@@ -240,7 +240,7 @@ public class ReferenceType extends ResolvedType {
 			return false;
 		ResolvedType myRawType = (ResolvedType) getRawType();
 		ResolvedType theirRawType = (ResolvedType) other.getRawType();
-		if (myRawType == theirRawType) {
+		if (myRawType == theirRawType || myRawType.isCoerceableFrom(theirRawType)) {
 			if (getTypeParameters().length == other.getTypeParameters().length) {
 				// there's a chance it can be done
 				ResolvedType[] myTypeParameters = getResolvedTypeParameters();
@@ -265,6 +265,11 @@ public class ReferenceType extends ResolvedType {
 							tv.resolve(world);
 							if (!tv.canBeBoundTo(myTypeParameters[i]))
 								return false;
+						} else if (theirTypeParameters[i].isGenericWildcard()) {
+							BoundedReferenceType wildcard = (BoundedReferenceType) theirTypeParameters[i];
+							if (!wildcard.canBeCoercedTo(myTypeParameters[i])) {
+								return false;
+							}
 						} else {
 							return false;
 						}
@@ -272,15 +277,15 @@ public class ReferenceType extends ResolvedType {
 				}
 				return true;
 			}
-		} else {
-			// we do this walk for situations like the following:
-			// Base<T>, Sub<S,T> extends Base<S>
-			// is Sub<Y,Z> coerceable from Base<X> ???
-			for (Iterator i = getDirectSupertypes(); i.hasNext();) {
-				ReferenceType parent = (ReferenceType) i.next();
-				if (parent.isCoerceableFromParameterizedType(other))
-					return true;
-			}
+			// } else {
+			// // we do this walk for situations like the following:
+			// // Base<T>, Sub<S,T> extends Base<S>
+			// // is Sub<Y,Z> coerceable from Base<X> ???
+			// for (Iterator i = getDirectSupertypes(); i.hasNext();) {
+			// ReferenceType parent = (ReferenceType) i.next();
+			// if (parent.isCoerceableFromParameterizedType(other))
+			// return true;
+			// }
 		}
 		return false;
 	}
@@ -336,11 +341,23 @@ public class ReferenceType extends ResolvedType {
 				ResolvedType[] theirParameters = other.getResolvedTypeParameters();
 				boolean parametersAssignable = true;
 				if (myParameters.length == theirParameters.length) {
-					for (int i = 0; i < myParameters.length; i++) {
+					for (int i = 0; i < myParameters.length && parametersAssignable; i++) {
 						if (myParameters[i] == theirParameters[i])
 							continue;
-						if (myParameters[i].isAssignableFrom(theirParameters[i], allowMissing)) {
-							continue;
+						// dont do this!
+						// if (myParameters[i].isAssignableFrom(theirParameters[i], allowMissing)) {
+						// continue;
+						// }
+						if (myParameters[i].isTypeVariableReference() && theirParameters[i].isTypeVariableReference()) {
+							TypeVariable myTV = ((TypeVariableReferenceType) myParameters[i]).getTypeVariable();
+							// TypeVariable theirTV = ((TypeVariableReferenceType) theirParameters[i]).getTypeVariable();
+							boolean b = myTV.canBeBoundTo(theirParameters[i]);
+							if (!b) {// TODO incomplete testing here I think
+								parametersAssignable = false;
+								break;
+							} else {
+								continue;
+							}
 						}
 						if (!myParameters[i].isGenericWildcard()) {
 							parametersAssignable = false;
@@ -0,0 +1,13 @@
+import java.util.*;
+
+public aspect CodeFour {
+  
+  static final class FinalSet<T> extends HashSet<T> {}
+
+  before(): execution(* *(..)) && args(List<?>) {}
+  
+  public void m(FinalSet<String> ss) {
+    // List<?> l = (List<?>)ss; // cannot write this (FinalSet is final) so pointcut should not match
+  }
+
+}
@@ -5408,7 +5408,7 @@
    </ajc-test>
 
   <ajc-test dir="java5/generics/pointcuts" title="args with generic wildcard">
-     <compile files="ArgsListOfSomething.aj" options="-1.5">
+     <compile files="ArgsListOfSomething.aj" options="-1.5 -Xlint:ignore">
      </compile>
      <run class="ArgsListOfSomething">
          <stdout>
@@ -5536,6 +5536,9 @@
 
    <ajc-test dir="java5/generics/afterAdvice" title="after returning with generic wildcard">
      <compile files="AfterReturningListOfSomething.aj" options="-1.5">
+       <!-- warning is unchecked match of List<?> from line 28 onto line 15. -->
+       <!-- some sets may be lists unless the set is final, so as a cast is allowed, the match is allowed -->
+       <message kind="warning" line="28"/>
      </compile>
      <run class="AfterReturningListOfSomething">
          <stdout>
@@ -22,7 +22,7 @@ import org.aspectj.testing.Utils;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc163Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
-/*
+
 	public void testGenericPointcuts_1() {
 		runTest("generic pointcuts - 1");
 	}
@@ -34,7 +34,11 @@ public class Ajc163Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	public void testGenericPointcuts_3() {
 		runTest("generic pointcuts - 3");
 	}
-*/
+
+	public void testGenericPointcuts_4() {
+		runTest("generic pointcuts - 4");
+	}
+
 	// public void testBrokenLVT_pr194314_1() throws Exception {
 	// runTest("broken lvt - 1");
 	// JavaClass jc = Utils.getClassFrom(ajc.getSandboxDirectory().getAbsolutePath(), "Service");
@@ -25,6 +25,12 @@
         <message kind="warning" line="9" text="unchecked"/>        
       </compile>
     </ajc-test>
+    
+    <ajc-test dir="bugs163/pr253109" title="generic pointcuts - 4">
+      <compile files="CodeFour.java" options="-1.5">
+        <message kind="warning" text="has not been applied"/>
+      </compile>
+    </ajc-test>
 
     <ajc-test dir="bugs163/pr194314" title="broken lvt - 1">
       <compile files="Service.java IService.java Main.java ServiceInterceptor.java" options="-1.5"/>
@@ -31,6 +31,10 @@ public class Ajc163Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		runTest("generic pointcuts - 2");
 	}
 
+	public void testGenericPointcuts_3() {
+		runTest("generic pointcuts - 3");
+	}
+
 	public void testBrokenLVT_pr194314_1() throws Exception {
 		runTest("broken lvt - 1");
 		JavaClass jc = Utils.getClassFrom(ajc.getSandboxDirectory().getAbsolutePath(), "Service");
@@ -65,28 +69,20 @@ public class Ajc163Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		System.out.println(m.getLocalVariableTable());
 		LocalVariable[] lvt = m.getLocalVariableTable().getLocalVariableTable();
 		assertEquals(8, lvt.length);
-		// assertEquals(2,
-		// m.getLocalVariableTable().getLocalVariableTable().length);
+		// assertEquals(2, m.getLocalVariableTable().getLocalVariableTable().length);
 
 		// Before I've started any work on this:
-		// LocalVariable(start_pc = 0, length = 68, index =
-		// 0:ServiceInterceptorCodeStyle this)
-		// LocalVariable(start_pc = 0, length = 68, index =
-		// 1:org.aspectj.runtime.internal.AroundClosure ajc_aroundClosure)
-		// LocalVariable(start_pc = 0, length = 68, index =
-		// 2:org.aspectj.lang.JoinPoint thisJoinPoint)
+		// LocalVariable(start_pc = 0, length = 68, index = 0:ServiceInterceptorCodeStyle this)
+		// LocalVariable(start_pc = 0, length = 68, index = 1:org.aspectj.runtime.internal.AroundClosure ajc_aroundClosure)
+		// LocalVariable(start_pc = 0, length = 68, index = 2:org.aspectj.lang.JoinPoint thisJoinPoint)
 		// LocalVariable(start_pc = 9, length = 59, index = 3:Object[] args)
 		// LocalVariable(start_pc = 21, length = 47, index = 4:long id)
 
 		// Method signature:
-		// private static final void method_aroundBody1$advice(Service, long,
-		// org.aspectj.lang.JoinPoint,
-		// ServiceInterceptorCodeStyle,
-		// org.aspectj.runtime.internal.AroundClosure,
-		// org.aspectj.lang.JoinPoint);
+		// private static final void method_aroundBody1$advice(Service, long, org.aspectj.lang.JoinPoint,
+		// ServiceInterceptorCodeStyle, org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint);
 		//
-		// Service, JoinPoint, ServiceInterceptorCodeStyle, AroundClosure,
-		// JoinPoint
+		// Service, JoinPoint, ServiceInterceptorCodeStyle, AroundClosure, JoinPoint
 
 		// args should be in slot 7 and the long in position 8
 
@@ -15,6 +15,18 @@
       </compile>
     </ajc-test>
 
+    <ajc-test dir="bugs163/pr253109" title="generic pointcuts - 3">
+      <compile files="CodeThree.java" options="-1.5 -showWeaveInfo">      
+        <message kind="weave" text="advised by before advice from 'CodeThree' (CodeThree.java:4)"/>
+        <message kind="weave" text="advised by before advice from 'CodeThree' (CodeThree.java:5) [with runtime test]"/>
+        <message kind="warning" line="6" text="has not been applied"/>
+        <message kind="warning" line="7" text="has not been applied"/>
+        <message kind="weave" text="advised by before advice from 'CodeThree' (CodeThree.java:8)"/>
+        <message kind="weave" text="advised by before advice from 'CodeThree' (CodeThree.java:9) [with runtime test]"/> 
+        <message kind="warning" line="5" text="unchecked"/>        
+        <message kind="warning" line="9" text="unchecked"/>        
+      </compile>
+    </ajc-test>
 
     <ajc-test dir="bugs163/pr194314" title="broken lvt - 1">
       <compile files="Service.java IService.java Main.java ServiceInterceptor.java" options="-1.5"/>
@@ -0,0 +1,13 @@
+import java.util.*;
+
+public aspect CodeThree {
+  before(): execution(* CodeThree.*(..)) && args(List<Integer>) {} // yes
+  before(): execution(* CodeThree.*(..)) && args(ArrayList<Integer>) {} // yes - runtime check
+  before(): execution(* CodeThree.*(..)) && args(List<Number>) {} // no
+  before(): execution(* CodeThree.*(..)) && args(ArrayList<Number>) {} // no
+  before(): execution(* CodeThree.*(..)) && args(List<? extends Number>) {} // yes
+  before(): execution(* CodeThree.*(..)) && args(ArrayList<? extends Number>) {} // yes - runtime check
+
+  void m(List<Integer> li) {}
+
+}
@@ -0,0 +1,16 @@
+import java.util.*;
+
+public aspect CodeOne {
+  before(): execution(* CodeOne.*(..)) && args(List<Number>) {}
+  before(): execution(* CodeOne.*(..)) && args(List<Integer>) {}
+
+  void m(List<Integer> li) {}
+
+  public void callm() {
+    List<Number> ln = new ArrayList<Number>();
+    List<Integer> li = new ArrayList<Integer>();
+    // m(ln);//not allowed
+    m(li);
+  }
+
+}
@@ -0,0 +1,13 @@
+import java.util.*;
+
+public aspect CodeTwo {
+  before(): execution(* CodeTwo.*(..)) && args(List<? extends Number>) {}
+
+  void m(List<Integer> li) {}
+
+  public void callm() {
+    List<? extends Number> lqn = new ArrayList<Number>();
+    // m(lqn);
+  }
+
+}
@@ -23,7 +23,15 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc163Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
-	public void testBrokenLVT_pr194314_1() {
+	public void testGenericPointcuts_1() {
+		runTest("generic pointcuts - 1");
+	}
+
+	public void testGenericPointcuts_2() {
+		runTest("generic pointcuts - 2");
+	}
+
+	public void testBrokenLVT_pr194314_1() throws Exception {
 		runTest("broken lvt - 1");
 		JavaClass jc = Utils.getClassFrom(ajc.getSandboxDirectory().getAbsolutePath(), "Service");
 		Method[] ms = jc.getMethods();
@@ -57,20 +65,28 @@ public class Ajc163Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		System.out.println(m.getLocalVariableTable());
 		LocalVariable[] lvt = m.getLocalVariableTable().getLocalVariableTable();
 		assertEquals(8, lvt.length);
-		// assertEquals(2, m.getLocalVariableTable().getLocalVariableTable().length);
+		// assertEquals(2,
+		// m.getLocalVariableTable().getLocalVariableTable().length);
 
 		// Before I've started any work on this:
-		// LocalVariable(start_pc = 0, length = 68, index = 0:ServiceInterceptorCodeStyle this)
-		// LocalVariable(start_pc = 0, length = 68, index = 1:org.aspectj.runtime.internal.AroundClosure ajc_aroundClosure)
-		// LocalVariable(start_pc = 0, length = 68, index = 2:org.aspectj.lang.JoinPoint thisJoinPoint)
+		// LocalVariable(start_pc = 0, length = 68, index =
+		// 0:ServiceInterceptorCodeStyle this)
+		// LocalVariable(start_pc = 0, length = 68, index =
+		// 1:org.aspectj.runtime.internal.AroundClosure ajc_aroundClosure)
+		// LocalVariable(start_pc = 0, length = 68, index =
+		// 2:org.aspectj.lang.JoinPoint thisJoinPoint)
 		// LocalVariable(start_pc = 9, length = 59, index = 3:Object[] args)
 		// LocalVariable(start_pc = 21, length = 47, index = 4:long id)
 
 		// Method signature:
-		// private static final void method_aroundBody1$advice(Service, long, org.aspectj.lang.JoinPoint,
-		// ServiceInterceptorCodeStyle, org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint);
+		// private static final void method_aroundBody1$advice(Service, long,
+		// org.aspectj.lang.JoinPoint,
+		// ServiceInterceptorCodeStyle,
+		// org.aspectj.runtime.internal.AroundClosure,
+		// org.aspectj.lang.JoinPoint);
 		//
-		// Service, JoinPoint, ServiceInterceptorCodeStyle, AroundClosure, JoinPoint
+		// Service, JoinPoint, ServiceInterceptorCodeStyle, AroundClosure,
+		// JoinPoint
 
 		// args should be in slot 7 and the long in position 8
 
@@ -3,6 +3,19 @@
 <suite>
 
 
+    <ajc-test dir="bugs163/pr253109" title="generic pointcuts - 1">
+      <compile files="CodeOne.java" options="-1.5">
+        <message kind="warning" line="4" text="has not been applied"/>
+      </compile>
+    </ajc-test>
+    
+    <ajc-test dir="bugs163/pr253109" title="generic pointcuts - 2">
+      <compile files="CodeTwo.java" options="-1.5">
+        <message kind="warning" line="4" text="has not been applied"/>
+      </compile>
+    </ajc-test>
+    
+
     <ajc-test dir="bugs163/pr194314" title="broken lvt - 1">
       <compile files="Service.java IService.java Main.java ServiceInterceptor.java" options="-1.5"/>
     </ajc-test>
