@@ -210,6 +210,7 @@ public class AspectJElementHierarchy implements IHierarchy {
 			return Collections.EMPTY_LIST;
 		}
 		if (((IProgramElement) children.get(0)).getKind() == IProgramElement.Kind.SOURCE_FOLDER) {
+			String searchPackageName = (packagename == null ? "" : packagename); // default package means match on ""
 			// dealing with source folders
 			List matchingPackageNodes = new ArrayList();
 			for (Iterator iterator = children.iterator(); iterator.hasNext();) {
@@ -218,7 +219,7 @@ public class AspectJElementHierarchy implements IHierarchy {
 				for (Iterator iterator2 = possiblePackageNodes.iterator(); iterator2.hasNext();) {
 					IProgramElement possiblePackageNode = (IProgramElement) iterator2.next();
 					if (possiblePackageNode.getKind() == IProgramElement.Kind.PACKAGE) {
-						if (possiblePackageNode.getName().equals(packagename)) {
+						if (possiblePackageNode.getName().equals(searchPackageName)) {
 							matchingPackageNodes.add(possiblePackageNode);
 						}
 					}
@@ -0,0 +1,12 @@
+//
+//public class C {
+//
+////	public C() {System.out.println("a");	}  
+//	
+//	public C(String s) {}
+//	
+//	public static void main(String[] args) {
+//		new C();
+//	}
+//}
+
@@ -0,0 +1,20 @@
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface WebService {}
+
+@WebService 
+class Foo {
+
+        public Foo() {}
+
+}
+aspect X {
+
+        after(): execution(*.new(..)) && @within(WebService) {
+
+        }
+}
+
+
@@ -0,0 +1,20 @@
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface WebService {}
+
+//@WebService 
+class Foo {
+
+        public Foo() {}
+
+}
+aspect X {
+
+        after(): execution(*.new(..)) && @within(WebService) {
+
+        }
+}
+
+
@@ -53,8 +53,42 @@ import org.aspectj.util.FileUtil;
  */
 public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementalAjdeInteractionTestbed {
 
+	public void testIncrementalAnnotationMatched_276399() throws Exception {
+		String p = "pr276399";
+		initialiseProject(p);
+		addSourceFolderForSourceFile(p, getProjectRelativePath(p, "src/X.aj"), "src");
+		addSourceFolderForSourceFile(p, getProjectRelativePath(p, "src/C.java"), "src");
+		build(p);
+		printModel(p);
+		IRelationshipMap irm = getModelFor(p).getRelationshipMap();
+		IRelationship ir = (IRelationship) irm.get("=pr276399/src<*X.aj}X&after").get(0);
+		assertNotNull(ir);
+		alter(p, "inc1");
+		build(p);
+		printModel(p);
+		irm = getModelFor(p).getRelationshipMap();
+		List rels = irm.get("=pr276399/src<*X.aj}X&after"); // should be gone after the inc build
+		assertNull(rels);
+	}
+/*
+	public void testIncrementalItdDefaultCtor() {
+		String p = "pr275032";
+		initialiseProject(p);
+		build(p);
+		assertEquals(0, getErrorMessages(p).size());
+		alter(p, "inc1");
+		build(p);
+		// error is: inter-type declaration from X conflicts with existing member: void A.<init>()
+		List ms = getErrorMessages(p);
+		for (Iterator iterator = ms.iterator(); iterator.hasNext();) {
+			Object object = (Object) iterator.next();
+			System.out.println(object);
+		}
+		assertEquals(1, getErrorMessages(p).size());
+		assertTrue("Was:" + getErrorMessages(p).get(0), getErrorMessages(p).get(0).toString().indexOf("conflicts") != -1);
+	}
+*/
 	public void testOutputLocationCallbacks2() {
-		AjdeInteractionTestbed.VERBOSE = true;
 		String p = "pr268827_ol_res";
 		initialiseProject(p);
 		Map m = new HashMap();
