@@ -11,60 +11,104 @@
  *     Xerox/PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.runtime.reflect;
 
 import java.lang.reflect.Method;
+import java.util.HashSet;
+import java.util.Set;
 
 import org.aspectj.lang.reflect.MethodSignature;
 
 class MethodSignatureImpl extends CodeSignatureImpl implements MethodSignature {
 	private Method method;
-    Class returnType;
-    
-    MethodSignatureImpl(int modifiers, String name, Class declaringType, 
-        Class[] parameterTypes, String[] parameterNames, Class[] exceptionTypes,
-        Class returnType)
-    {
-        super(modifiers, name, declaringType, parameterTypes, parameterNames,
-            exceptionTypes);
-        this.returnType = returnType;
-    }
-    
-    MethodSignatureImpl(String stringRep) {
-        super(stringRep);
-    }
+	Class returnType;
+
+	MethodSignatureImpl(int modifiers, String name, Class declaringType, Class[] parameterTypes, String[] parameterNames,
+			Class[] exceptionTypes, Class returnType) {
+		super(modifiers, name, declaringType, parameterTypes, parameterNames, exceptionTypes);
+		this.returnType = returnType;
+	}
+
+	MethodSignatureImpl(String stringRep) {
+		super(stringRep);
+	}
 
-    /* name is consistent with reflection API */
-    public Class getReturnType() {
-        if (returnType == null) returnType = extractType(6);
-        return returnType;
-    }
-    
-    protected String createToString(StringMaker sm) {
-        StringBuffer buf = new StringBuffer();
-        buf.append(sm.makeModifiersString(getModifiers()));
-        if (sm.includeArgs) buf.append(sm.makeTypeName(getReturnType()));
-        if (sm.includeArgs) buf.append(" ");        
-        buf.append(sm.makePrimaryTypeName(getDeclaringType(),getDeclaringTypeName()));
-        buf.append(".");
-        buf.append(getName());        
-        sm.addSignature(buf, getParameterTypes());
-        sm.addThrows(buf, getExceptionTypes());
-        return buf.toString();
-    }
-    
-    /* (non-Javadoc)
+	/* name is consistent with reflection API */
+	public Class getReturnType() {
+		if (returnType == null)
+			returnType = extractType(6);
+		return returnType;
+	}
+
+	protected String createToString(StringMaker sm) {
+		StringBuffer buf = new StringBuffer();
+		buf.append(sm.makeModifiersString(getModifiers()));
+		if (sm.includeArgs)
+			buf.append(sm.makeTypeName(getReturnType()));
+		if (sm.includeArgs)
+			buf.append(" ");
+		buf.append(sm.makePrimaryTypeName(getDeclaringType(), getDeclaringTypeName()));
+		buf.append(".");
+		buf.append(getName());
+		sm.addSignature(buf, getParameterTypes());
+		sm.addThrows(buf, getExceptionTypes());
+		return buf.toString();
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.lang.reflect.MemberSignature#getAccessibleObject()
 	 */
 	public Method getMethod() {
 		if (method == null) {
+			Class dtype = getDeclaringType();
 			try {
-				method = getDeclaringType().getDeclaredMethod(getName(),getParameterTypes());
+				method = dtype.getDeclaredMethod(getName(), getParameterTypes());
 			} catch (NoSuchMethodException nsmEx) {
-				; // nothing we can do, user will see null return
+				// pr154427 - search
+				Set searched = new HashSet();
+				searched.add(dtype); // avoids another getDeclaredMethod() on dtype
+				method = search(dtype, getName(), getParameterTypes(), searched);
 			}
 		}
 		return method;
 	}
+
+	/**
+	 * Hunt for a method up the hierarchy for a specified type.
+	 * 
+	 * @param type the type on which to look for the method
+	 * @param name the name of the method
+	 * @param params the parameters of the method
+	 * @param searched a set of types already searched to avoid looking at anything twice
+	 * @return the method if found, or null if not found
+	 */
+	private Method search(Class type, String name, Class[] params, Set searched) {
+		if (type == null) {
+			return null;
+		}
+		if (!searched.contains(type)) {
+			searched.add(type);
+			try {
+				return type.getDeclaredMethod(name, params);
+			} catch (NoSuchMethodException nsme) {
+				// drop through and check superclass and interfaces
+			}
+		}
+		Method m = search(type.getSuperclass(), name, params, searched);
+		if (m != null) {
+			return m;
+		}
+		Class[] superinterfaces = type.getInterfaces();
+		if (superinterfaces != null) {
+			for (int i = 0; i < superinterfaces.length; i++) {
+				m = search(superinterfaces[i], name, params, searched);
+				if (m != null) {
+					return m;
+				}
+			}
+		}
+		return null;
+	}
 }
Binary files differ
Binary files differ
@@ -0,0 +1,4 @@
+public interface Authorization {
+  boolean mayPerform(String user, String action);
+}
+
@@ -0,0 +1,4 @@
+public interface AuthorizationAdmin extends Authorization {
+      boolean mayPerform2(String user, String action);
+}
+
@@ -0,0 +1,18 @@
+public class AuthorizationImpl implements AuthorizationAdmin {
+
+      /* ========== interface Authorization ============*/
+
+      public boolean mayPerform(String user, String action) {
+            System.out.println("mayPerform() executing");
+            return true;
+      }
+
+      /* ========== interface AuthorizationAdmin  ============*/
+
+      public boolean mayPerform2(String user, String action) {
+            System.out.println("mayPerform2() executing");
+            return true;
+      }
+
+}
+
@@ -0,0 +1,21 @@
+import org.aspectj.lang.reflect.*;
+import java.lang.reflect.*;
+
+public aspect CallAndMethodSignatureAspect {
+
+      pointcut callAnyPublicMethodInAuthorization() : call(public * Authorization+.*(..) );
+
+      Object around() : callAnyPublicMethodInAuthorization() {
+
+            MethodSignature methodSignature = (MethodSignature) thisJoinPoint.getSignature();
+
+            // returns NULL when calling a method defined in the top interface "Authorization"
+            Method method = methodSignature.getMethod();
+
+            System.out.println(method);
+            System.out.println(methodSignature.toLongString());
+
+            return proceed();
+      }
+}
+
@@ -0,0 +1,36 @@
+public class CallTest {
+
+
+ public static void main(String[]argv) {
+   new CallTest().testMayPerform();
+   new CallTest().testMayPerform2();
+   new CallTest().testMayPerform3();
+ }
+
+      private AuthorizationAdmin admin;
+      private Authorization auth;
+
+      public void testMayPerform() {
+        admin = new AuthorizationImpl();
+        boolean bool = admin.mayPerform("peter", "query");
+        if (!bool) throw new RuntimeException();
+      }
+
+      public void testMayPerform2() {
+            admin = new AuthorizationImpl();
+
+            boolean bool = admin.mayPerform2("peter2", "query2");
+   if (!bool) throw new RuntimeException();
+
+      }
+
+        public void testMayPerform3() {
+                auth = new AuthorizationImpl();
+
+                boolean bool = auth.mayPerform("peter2", "query2");
+
+   if (!bool) throw new RuntimeException();
+        }
+
+}
+
@@ -28,6 +28,10 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc163Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testGetMethodNull_pr154427() {
+		runTest("getMethod returning null");
+	}
+
 	public void testFQType_pr256937() {
 		runTest("fully qualified return type");
 		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
@@ -2,6 +2,23 @@
 
 <suite>
 
+    <ajc-test dir="bugs163/pr154427" title="getMethod returning null">
+   	  <compile files="AuthorizationImpl.java Authorization.java AuthorizationAdmin.java CallAndMethodSignatureAspect.java CallTest.java" options=""/>
+   	  <run class="CallTest">
+   	    <stdout>
+   	      <line text="public abstract boolean Authorization.mayPerform(java.lang.String,java.lang.String)"/>
+   	      <line text="public abstract interface boolean AuthorizationAdmin.mayPerform(java.lang.String, java.lang.String)"/>
+   	      <line text="mayPerform() executing"/>
+   	      <line text="public abstract boolean AuthorizationAdmin.mayPerform2(java.lang.String,java.lang.String)"/>
+   	      <line text="public abstract interface boolean AuthorizationAdmin.mayPerform2(java.lang.String, java.lang.String)"/>
+   	      <line text="mayPerform2() executing"/>
+   	      <line text="public abstract boolean Authorization.mayPerform(java.lang.String,java.lang.String)"/>
+   	      <line text="public abstract interface boolean Authorization.mayPerform(java.lang.String, java.lang.String)"/>
+   	      <line text="mayPerform() executing"/>
+   	    </stdout>
+   	  </run>
+    </ajc-test>
+    
     <ajc-test dir="bugs163/pr256937" title="fully qualified return type">
    	  <compile files="Ship.java ShipAccessor.java" options="-emacssym -1.5"/>
     </ajc-test>
