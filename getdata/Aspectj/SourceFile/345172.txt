@@ -2902,26 +2902,39 @@ class BcelClassWeaver implements IClassWeaver {
 	 * 
 	 * @param type the type to search for the member
 	 * @param methodName the name of the method to find
-	 * @param Class[] the method parameters that the discovered method should have
+	 * @param params the method parameters that the discovered method should have
 	 */
 	private ResolvedMember findResolvedMemberNamed(ResolvedType type, String methodName, UnresolvedType[] params) {
 		ResolvedMember[] allMethods = type.getDeclaredMethods();
+		List<ResolvedMember> candidates = new ArrayList<ResolvedMember>();
 		for (int i = 0; i < allMethods.length; i++) {
 			ResolvedMember candidate = allMethods[i];
 			if (candidate.getName().equals(methodName)) {
+				if (candidate.getArity() == params.length) {
+					candidates.add(candidate);
+				}
+			}
+		}
+
+		if (candidates.size() == 0) {
+			return null;
+		} else if (candidates.size() == 1) {
+			return candidates.get(0);
+		} else {
+			// multiple candidates
+			for (ResolvedMember candidate : candidates) {
+				// These checks will break down with generics... but that would need two ITDs with the same name, same arity and
+				// generics
+				boolean allOK = true;
 				UnresolvedType[] candidateParams = candidate.getParameterTypes();
-				if (candidateParams.length == params.length) {
-					// boolean allOK = true; // this checking all breaks down with generics in the mix, unfortunately, dont have
-					// time to fix it up right now
-					// for (int p = 0; p < candidateParams.length; p++) {
-					// if (!candidateParams[p].getErasureSignature().equals(params[p].getErasureSignature())) {
-					// allOK = false;
-					// break;
-					// }
-					// }
-					// if (allOK) {
+				for (int p = 0; p < candidateParams.length; p++) {
+					if (!candidateParams[p].getErasureSignature().equals(params[p].getErasureSignature())) {
+						allOK = false;
+						break;
+					}
+				}
+				if (allOK) {
 					return candidate;
-					// }
 				}
 			}
 		}
@@ -0,0 +1,44 @@
+import static java.lang.annotation.ElementType.*;
+import java.lang.annotation.*;
+
+public aspect InterType3 {
+
+  @Retention(RetentionPolicy.RUNTIME)
+  @Target({METHOD})
+  public @interface MyAnnotation {
+  }
+
+  public static aspect AroundMethod {
+    Object around() : execution(@MyAnnotation * * (..)) {
+      System.out.println(thisJoinPointStaticPart);
+      return proceed();
+    }   
+  }
+
+  public interface InterTypeIfc {}
+
+  // (1)
+  @MyAnnotation
+  public void InterTypeIfc.m1(int p1, String p2) {}
+
+  // (2)
+  public void InterTypeIfc.m1(int p1, int p2) {}
+
+  // (3)
+//  @MyAnnotation
+//  public void m1(int p1) {}
+
+  // (4)
+//  public void m1(int p1, int p2) {}
+
+
+  public static void main(String []argv) throws Exception {
+    new Foo().m1(1,"a");
+    new Foo().m1(1,2);
+  }
+
+  declare parents: Foo implements InterTypeIfc;
+ 
+  static class Foo {
+  }
+}
@@ -21,6 +21,10 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
  */
 public class Ajc1612Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	// public void testAnnoCopying_345515() {
+	// runTest("anno copying");
+	// }
+
 	public void testIncorrectAnnos_345172() {
 		runTest("incorrect annos");
 	}
@@ -29,6 +33,10 @@ public class Ajc1612Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		runTest("incorrect annos 2");
 	}
 
+	public void testIncorrectAnnos_345172_3() {
+		runTest("incorrect annos 3");
+	}
+
 	public void testSyntheticMethods_327867() {
 		runTest("synthetic methods");
 	}
@@ -2,6 +2,11 @@
 
 <suite>
 
+<ajc-test dir="bugs1612/pr345515" title="anno copying">
+<compile files="Code.java" options="-1.5"/>
+<run class="Code"></run>
+</ajc-test>
+
 <ajc-test dir="bugs1612/pr327867" title="synthetic methods">
 <compile files="Foo.java" options="-1.5 -showWeaveInfo">
 <message kind="weave" text="Join point 'method-execution(void Foo.main(java.lang.String[]))' in Type 'Foo' (Foo.java:3) advised by before advice from 'X' (Foo.java:17)"/>
@@ -32,6 +37,15 @@
 </stdout></run>
 </ajc-test>
 
+<ajc-test dir="bugs1612/pr345172" title="incorrect annos 3">
+<compile files="InterType3.java" options="-1.5">
+</compile>
+<run class="InterType3">
+<stdout>
+<line text="execution(void InterType3.InterTypeIfc.m1(int, String))"/>
+</stdout></run>
+</ajc-test>
+
 
 
 
@@ -2898,6 +2898,37 @@ class BcelClassWeaver implements IClassWeaver {
 	}
 
 	/**
+	 * Find the specified member in the specified type.
+	 * 
+	 * @param type the type to search for the member
+	 * @param methodName the name of the method to find
+	 * @param Class[] the method parameters that the discovered method should have
+	 */
+	private ResolvedMember findResolvedMemberNamed(ResolvedType type, String methodName, UnresolvedType[] params) {
+		ResolvedMember[] allMethods = type.getDeclaredMethods();
+		for (int i = 0; i < allMethods.length; i++) {
+			ResolvedMember candidate = allMethods[i];
+			if (candidate.getName().equals(methodName)) {
+				UnresolvedType[] candidateParams = candidate.getParameterTypes();
+				if (candidateParams.length == params.length) {
+					// boolean allOK = true; // this checking all breaks down with generics in the mix, unfortunately, dont have
+					// time to fix it up right now
+					// for (int p = 0; p < candidateParams.length; p++) {
+					// if (!candidateParams[p].getErasureSignature().equals(params[p].getErasureSignature())) {
+					// allOK = false;
+					// break;
+					// }
+					// }
+					// if (allOK) {
+					return candidate;
+					// }
+				}
+			}
+		}
+		return null;
+	}
+
+	/**
 	 * For a given resolvedmember, this will discover the real annotations for it. <b>Should only be used when the resolvedmember is
 	 * the contents of an effective signature attribute, as thats the only time when the annotations aren't stored directly in the
 	 * resolvedMember</b>
@@ -2963,10 +2994,8 @@ class BcelClassWeaver implements IClassWeaver {
 					} else {
 						ResolvedMember realthing = AjcMemberMaker.interMethodDispatcher(rm.resolve(world), memberHostType).resolve(
 								world);
-						// ResolvedMember resolvedDooberry =
-						// world.resolve(realthing);
-						ResolvedMember theRealMember = findResolvedMemberNamed(memberHostType.resolve(world), realthing.getName());
-						// AMC temp guard for M4
+						ResolvedMember theRealMember = findResolvedMemberNamed(memberHostType.resolve(world), realthing.getName(),
+								realthing.getParameterTypes());
 						if (theRealMember == null) {
 							throw new UnsupportedOperationException(
 									"Known limitation in M4 - can't find ITD members when type variable is used as an argument and has upper bound specified");
@@ -0,0 +1,37 @@
+import static java.lang.annotation.ElementType.*;
+import java.lang.annotation.*;
+
+public aspect InterType {
+
+  @Retention(RetentionPolicy.RUNTIME)
+  @Target({METHOD})
+  public @interface MyAnnotation {
+  }
+
+  public static aspect AroundMethod {
+    Object around() : execution(@MyAnnotation * * (..)) {
+      return proceed();
+    }   
+  }
+
+  public interface InterTypeIfc {}
+
+  // (1)
+  @MyAnnotation
+  public void InterTypeIfc.m1(int p1) {}
+
+  // (2)
+  public void InterTypeIfc.m1(int p1, int p2) {}
+
+  // (3)
+//  @MyAnnotation
+//  public void m1(int p1) {}
+
+  // (4)
+//  public void m1(int p1, int p2) {}
+
+
+  public static void main(String []argv) throws Exception {
+  }
+ 
+}
@@ -0,0 +1,44 @@
+import static java.lang.annotation.ElementType.*;
+import java.lang.annotation.*;
+
+public aspect InterType2 {
+
+  @Retention(RetentionPolicy.RUNTIME)
+  @Target({METHOD})
+  public @interface MyAnnotation {
+  }
+
+  public static aspect AroundMethod {
+    Object around() : execution(@MyAnnotation * * (..)) {
+      System.out.println(thisJoinPointStaticPart);
+      return proceed();
+    }   
+  }
+
+  public interface InterTypeIfc {}
+
+  // (1)
+  @MyAnnotation
+  public void InterTypeIfc.m1(int p1) {}
+
+  // (2)
+  public void InterTypeIfc.m1(int p1, int p2) {}
+
+  // (3)
+//  @MyAnnotation
+//  public void m1(int p1) {}
+
+  // (4)
+//  public void m1(int p1, int p2) {}
+
+
+  public static void main(String []argv) throws Exception {
+    new Foo().m1(1);
+    new Foo().m1(1,2);
+  }
+
+  declare parents: Foo implements InterTypeIfc;
+ 
+  static class Foo {
+  }
+}
@@ -21,6 +21,14 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
  */
 public class Ajc1612Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testIncorrectAnnos_345172() {
+		runTest("incorrect annos");
+	}
+
+	public void testIncorrectAnnos_345172_2() {
+		runTest("incorrect annos 2");
+	}
+
 	public void testSyntheticMethods_327867() {
 		runTest("synthetic methods");
 	}
@@ -10,6 +10,30 @@
 <run class="Foo"/>
 </ajc-test>
 
+<ajc-test dir="bugs1612/pr345172" title="incorrect annos">
+<compile files="InterType.java" options="-1.5 -showWeaveInfo">
+<message kind="weave" text="Join point 'method-execution(void InterType$InterTypeIfc.m1(int))' in Type 'InterType' (InterType.java:21) advised by around advice from 'InterType$AroundMethod' (InterType.java:12)"/>
+<!-- 
+<message kind="weave" text="Join point 'method-execution(void InterType$InterTypeIfc.m1(int, int))' in Type 'InterType' (InterType.java:24) advised by around advice from 'InterType$AroundMethod' (InterType.java:12)"/>
+<message kind="weave" text="Join point 'method-execution(void InterType.m1(int))' in Type 'InterType' (InterType.java:28) advised by around advice from 'InterType$AroundMethod' (InterType.java:12)"/>
+-->
+<message kind="weave" text="Type 'InterType$InterTypeIfc' (InterType.java) has intertyped method from 'InterType' (InterType.java:'void InterType$InterTypeIfc.m1(int)')"/>
+<message kind="weave" text="Type 'InterType$InterTypeIfc' (InterType.java) has intertyped method from 'InterType' (InterType.java:'void InterType$InterTypeIfc.m1(int, int)')"/>
+</compile>
+<run class="InterType"/>
+</ajc-test>
+
+<ajc-test dir="bugs1612/pr345172" title="incorrect annos 2">
+<compile files="InterType2.java" options="-1.5">
+</compile>
+<run class="InterType2">
+<stdout>
+<line text="execution(void InterType2.InterTypeIfc.m1(int))"/>
+</stdout></run>
+</ajc-test>
+
+
+
 
 <ajc-test dir="bugs1612/pr328099" title="signed jar ltw">
 <compile files="X.java" classpath="code.jar"/>
