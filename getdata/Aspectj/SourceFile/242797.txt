@@ -20,19 +20,18 @@ import java.util.Map;
 import org.aspectj.ajde.core.IOutputLocationManager;
 
 /**
- * An IOutputLocationManager which by default sends all output to the 
- * testProjectPath\bin directory. However, there are getter methods which
- * enable sending resources and classes to different output dirs. Doesn't
- * enable sending different classes to different output locations.
+ * An IOutputLocationManager which by default sends all output to the testProjectPath\bin directory. However, there are getter
+ * methods which enable sending resources and classes to different output dirs. Doesn't enable sending different classes to
+ * different output locations.
  */
 public class MultiProjTestOutputLocationManager implements IOutputLocationManager {
 
-	private String testProjectOutputPath;
+	private final String testProjectOutputPath;
 	private File classOutputLoc;
 	private File resourceOutputLoc;
-	private Map sourceFolders = new HashMap();
+	private final Map sourceFolders = new HashMap();
 	private List allOutputLocations;
-	
+
 	public MultiProjTestOutputLocationManager(String testProjectPath) {
 		this.testProjectOutputPath = testProjectPath + File.separator + "bin";
 	}
@@ -48,7 +47,7 @@ public class MultiProjTestOutputLocationManager implements IOutputLocationManage
 	}
 
 	public List getAllOutputLocations() {
-		if(allOutputLocations == null) {
+		if (allOutputLocations == null) {
 			allOutputLocations = new ArrayList();
 			initLocations();
 			allOutputLocations.add(classOutputLoc);
@@ -62,7 +61,7 @@ public class MultiProjTestOutputLocationManager implements IOutputLocationManage
 	public File getDefaultOutputLocation() {
 		return classOutputLoc;
 	}
-	
+
 	private void initLocations() {
 		if (classOutputLoc == null) {
 			classOutputLoc = new File(testProjectOutputPath);
@@ -71,30 +70,28 @@ public class MultiProjTestOutputLocationManager implements IOutputLocationManage
 			resourceOutputLoc = new File(testProjectOutputPath);
 		}
 	}
-	
+
 	// -------------- setter methods useful for testing -------------
 	public void setOutputLocForClass(File f) {
 		classOutputLoc = f;
 	}
-	
-	public void setSourceFolderFor(File sourceFile,String sourceFolder) {
+
+	public void setSourceFolderFor(File sourceFile, String sourceFolder) {
 		try {
-			System.out.println("Stored against "+sourceFile.getCanonicalPath());
-			sourceFolders.put(sourceFile.getCanonicalPath(),sourceFolder);
+			sourceFolders.put(sourceFile.getCanonicalPath(), sourceFolder);
 		} catch (IOException e) {
 			e.printStackTrace();
 			throw new RuntimeException(e);
 		}
 	}
-	
+
 	public void setOutputLocForResource(File f) {
 		resourceOutputLoc = f;
 	}
 
 	public String getSourceFolderForFile(File sourceFile) {
 		try {
-			System.out.println("Looked up against "+sourceFile.getCanonicalPath());
-			String f = (String)sourceFolders.get(sourceFile.getCanonicalPath());
+			String f = (String) sourceFolders.get(sourceFile.getCanonicalPath());
 			return f;
 		} catch (IOException e) {
 			e.printStackTrace();
@@ -291,6 +291,28 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		checkForError("P1", "invalid aspectpath entry");
 	}
 
+	// incorrect use of '?' when it should be '*'
+	public void testAspectPath_pr242797_c46() {
+		String bug = "pr242797_1";
+		String bug2 = "pr242797_2";
+		initialiseProject(bug);
+		initialiseProject(bug2);
+		configureAspectPath(bug2, getProjectRelativePath(bug, "bin"));
+		build(bug);
+		build(bug2);
+	}
+
+	// 
+	public void testAspectPath_pr242797_c41() {
+		String bug = "pr242797_3";
+		String bug2 = "pr242797_4";
+		initialiseProject(bug);
+		initialiseProject(bug2);
+		configureAspectPath(bug2, getProjectRelativePath(bug, "bin"));
+		build(bug);
+		build(bug2);
+	}
+
 	/**
 	 * Build a project containing a resource - then mark the resource readOnly(), then do an inc-compile, it will report an error
 	 * about write access to the resource in the output folder being denied
@@ -695,7 +695,7 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 			return "? extends " + signatureToName(signature.substring(1, signature.length()));
 		case '-':
 			return "? super " + signatureToName(signature.substring(1, signature.length()));
-		case '?':
+		case '*':
 			return "?";
 		default:
 			throw new BCException("Bad type signature: " + signature);
@@ -67,10 +67,10 @@ public abstract class World implements Dump.INode {
 	public static boolean createInjarHierarchy = true;
 
 	/** Calculator for working out aspect precedence */
-	private AspectPrecedenceCalculator precedenceCalculator;
+	private final AspectPrecedenceCalculator precedenceCalculator;
 
 	/** All of the type and shadow mungers known to us */
-	private CrosscuttingMembersSet crosscuttingMembersSet = new CrosscuttingMembersSet(this);
+	private final CrosscuttingMembersSet crosscuttingMembersSet = new CrosscuttingMembersSet(this);
 
 	/** Model holds ASM relationships */
 	private IHierarchy model = null;
@@ -243,7 +243,8 @@ public abstract class World implements Dump.INode {
 			// might be a problem here, not sure '?' should make it to here as a signature, the
 			// proper signature for wildcard '?' is '*'
 			// fault in generic wildcard, can't be done earlier because of init issues
-			ResolvedType something = new BoundedReferenceType("?", "Ljava/lang/Object", this);
+			// TODO ought to be shared single instance representing this
+			ResolvedType something = new BoundedReferenceType("*", "Ljava/lang/Object", this);
 			typeMap.put("?", something);
 			return something;
 		}
@@ -85,7 +85,8 @@ import org.aspectj.weaver.World;
  * 
  */
 public class WildTypePattern extends TypePattern {
-	private static final String GENERIC_WILDCARD_CHARACTER = "?";
+	private static final String GENERIC_WILDCARD_CHARACTER = "?"; // signature of ? is *
+	private static final String GENERIC_WILDCARD_SIGNATURE_CHARACTER = "*"; // signature of ? is *
 	private NamePattern[] namePatterns;
 	int ellipsisCount;
 	String[] importedPrefixes;
@@ -774,7 +775,7 @@ public class WildTypePattern extends TypePattern {
 	}
 
 	private TypePattern resolveGenericWildcard(IScope scope, UnresolvedType aType) {
-		if (!aType.getSignature().equals(GENERIC_WILDCARD_CHARACTER)) throw new IllegalStateException("Can only have bounds for a generic wildcard");
+		if (!aType.getSignature().equals(GENERIC_WILDCARD_SIGNATURE_CHARACTER)) throw new IllegalStateException("Can only have bounds for a generic wildcard");
 		boolean canBeExact = true;
 		if ((upperBound != null) && ResolvedType.isMissing(upperBound.getExactType())) canBeExact = false;
 		if ((lowerBound != null) && ResolvedType.isMissing(lowerBound.getExactType())) canBeExact = false;
@@ -169,12 +169,12 @@ import org.aspectj.weaver.bcel.BcelWorld;
 		 assertTrue("resolves to exact type",rtp instanceof ExactTypePattern);
 		 UnresolvedType exactType = rtp.getExactType();
 		 assertTrue(exactType.isParameterizedType());
-		 assertEquals("Pjava/util/List<?>;",exactType.getSignature());
+		 assertEquals("Pjava/util/List<*>;",exactType.getSignature());
 
 		 ExactTypePattern etp = (ExactTypePattern) writeAndRead(rtp);
 		 exactType = etp.getExactType();
 		 assertTrue(exactType.isParameterizedType());
-		 assertEquals("Pjava/util/List<?>;",exactType.getSignature());
+		 assertEquals("Pjava/util/List<*>;",exactType.getSignature());
 
 		 assertFalse("does not match List",etp.matches(javaUtilList, TypePattern.STATIC).alwaysTrue());
 		 assertFalse("does not match generic List",etp.matches(javaUtilList.getGenericType(),TypePattern.STATIC).alwaysTrue());
@@ -345,7 +345,8 @@ import org.aspectj.weaver.bcel.BcelWorld;
 						new UnresolvedType[] {UnresolvedType.forName("java.lang.Double").resolve(world)}, 
 						world);
 
-		 assertFalse("does not match list of number",wtp.matches(listOfNumber,TypePattern.STATIC).alwaysTrue());
+		 boolean matchesListOfNumber = wtp.matches(listOfNumber,TypePattern.STATIC).alwaysTrue();
+		 assertFalse("does not match list of number",matchesListOfNumber);
 		 assertFalse("does not match list of double",wtp.matches(listOfDouble,TypePattern.STATIC).alwaysTrue());
 
 		 ResolvedType extendsNumber = TypeFactory.createTypeFromSignature("+Ljava/lang/Number;").resolve(world);
@@ -355,7 +356,8 @@ import org.aspectj.weaver.bcel.BcelWorld;
 						new UnresolvedType[] {extendsNumber}, 
 						world);
 
-		 assertTrue("matches list of ? extends number",wtp.matches(listOfExtendsNumber,TypePattern.STATIC).alwaysTrue());		 
+		 boolean matchesListOfQmarkExtendsNumber = wtp.matches(listOfExtendsNumber,TypePattern.STATIC).alwaysTrue();
+		 assertTrue("failed to correctly match list of ? extends number",matchesListOfQmarkExtendsNumber);		 
 
 		 ResolvedType extendsDouble = TypeFactory.createTypeFromSignature("+Ljava/lang/Double;").resolve(world);
 		 ResolvedType listOfExtendsDouble =
@@ -0,0 +1,16 @@
+/*
+ * Created on Mar 7, 2008
+ */
+package test1;
+
+public interface SelectAction<T>{
+
+	public void select(T object);
+
+	public T getSelected();
+
+	public void setSelected(T object);
+
+	public void deselect();
+
+}
\ No newline at end of file
@@ -0,0 +1,26 @@
+/*
+ * Created on Sep 4, 2008
+ */
+package test1;
+
+public aspect SelectActionAspect {
+	
+	private T SelectAction<T>.selected;
+	
+	public void SelectAction<T>.select(T object){
+		this.selected = object;
+	}
+
+	public T SelectAction<T>.getSelected(){
+		return selected;
+	}
+
+	public void SelectAction<T>.setSelected(T object){
+		this.selected = object;
+	}
+
+	public void SelectAction<T>.deselect(){
+		this.selected = null;
+	}
+
+}
@@ -0,0 +1,11 @@
+package test2;
+import test1.SelectAction;
+
+
+/*
+ * Created on Sep 11, 2008
+ */
+
+public class ProfileAction implements SelectAction<Object>{
+
+}
Binary files differ
@@ -0,0 +1,10 @@
+import java.util.*;
+
+interface  A {
+ 
+  List<?> getfoos() ;
+}
+
+aspect X {
+  List<?> A.getFoos() { return null; }
+}
@@ -0,0 +1,12 @@
+/*
+ * Created on Aug 22, 2008
+ */
+package bug;
+
+
+public enum DuplicateStrategy {
+	
+	COMBINE,
+	BEST_MATCH
+
+}
@@ -0,0 +1,23 @@
+/*
+ * Created on Sep 18, 2008
+ */
+package bug;
+
+
+public class EntityManager {
+	
+	public Query createQuery(String query){
+		return new Query();
+	}
+	
+	public Object find(Class<?> type, Object id){
+		return new Object();
+	}
+	
+	public void merge(Object object){}
+	
+	public void persist(Object object){}
+	
+	public void remove(Object object){}
+
+}
@@ -0,0 +1,20 @@
+/*
+ * Created on Aug 8, 2008
+ */
+package bug;
+
+public class EqualityUtils {
+	
+	public static boolean equal(Object obj1, Object obj2){
+		if(obj1 == null){
+			if(obj2 == null)
+				return true;
+			return false;
+		} else if(obj2 == null){
+			return false;
+		} else{
+			return obj1.equals(obj2);
+		}
+	}
+
+}
@@ -0,0 +1,23 @@
+/*
+ * Created on Sep 18, 2008
+ */
+package bug;
+
+import java.util.List;
+
+
+public class FailingManager implements PartitionedManager {
+
+	public Class<Object> getManagedType(){
+		return Object.class;
+	}
+
+    public List<String> getDefaultPartitionOrder() {
+	    return null;
+    }
+
+    public DuplicateStrategy getPartitionedDuplicateStrategy() {
+	    return null;
+    }
+	
+}
@@ -0,0 +1,13 @@
+/*
+ * Created on Sep 18, 2008
+ */
+package bug;
+
+
+public class H2Lookup {
+	
+	public static EntityManager em(){
+		return new EntityManager();
+	}
+
+}
@@ -0,0 +1,10 @@
+/*
+ * Created on Jul 23, 2008
+ */
+package bug;
+
+public interface Localized extends NaturallyComparable{
+	
+	public String getLanguage();
+	
+}
@@ -0,0 +1,31 @@
+/*
+ * Created on Jul 25, 2008
+ */
+package bug;
+
+import java.util.List;
+
+
+public interface LocalizedManager extends Manager{
+	
+	public Class<? extends Localized> getLocalizedType();
+	
+	public List<? extends Localized> getAllInLocale(String language);
+	
+	public List<? extends Localized> getAllInLocales(List<String> languages);
+	
+	public List<? extends Localized> getAllInDefaultLocales();
+	
+	public List<? extends Localized> getBestInLocales(List<String> languages);
+	
+	public List<? extends Localized> getBestInDefaultLocales();
+	
+	public List<? extends Localized> removeWeakLanguageMatches(List<? extends Localized> localized);
+	
+	public List<? extends Localized> removeWeakLanguageMatches(List<? extends Localized> localized, List<String> languageOrder);
+	
+	public DuplicateStrategy getLocalizedDuplicateStrategy();
+	
+	public List<String> getDefaultLanguageOrder();
+
+}
@@ -0,0 +1,28 @@
+/*
+ * Created on Jul 25, 2008
+ */
+package bug;
+
+import java.util.List;
+
+public interface Manager {
+	
+	public Class<?> getManagedType();
+	
+	public <T> T find(Object id);
+	
+	public <T> T update(T object);
+	
+	public <T> T save(T object);
+	
+	public <T> T remove(T object);
+
+	public List<?> getAny();
+
+	public List<?> getAll();
+
+	public Query createQuery(String queryString);
+	
+	public EntityManager getEntityManager();
+	
+}
\ No newline at end of file
@@ -0,0 +1,57 @@
+package bug;
+
+import java.util.List;
+
+public aspect ManagerAspect {
+
+	public List<?> Manager.getAny(){
+		return getEntityManager().createQuery("SELECT obj FROM " + 
+				getManagedType().getName() + " obj ").getResultList();
+	}
+	
+	public List<?> Manager.getAll(){
+		List<?> values = null;
+		if(this instanceof LocalizedManager){
+			LocalizedManager manager = (LocalizedManager)this;
+			values = manager.getAllInDefaultLocales();
+		}
+		else if(this instanceof PartitionedManager){
+			PartitionedManager manager = (PartitionedManager)this;
+			values = manager.getBestInDefaultPartitions();
+		}
+		else{
+			values = getAny();
+		}
+		return values;
+	}
+	
+	public <T> T Manager.find(Object id){
+		return (T) getEntityManager().find(getManagedType(), id);
+	}
+	
+	public <T> T Manager.save(T object){
+		getEntityManager().persist(object);
+		return object;
+	}
+	
+	public <T> T Manager.update(T object){
+		getEntityManager().merge(object);
+		return object;
+	}
+	
+	public <T> T Manager.remove(T object){
+		getEntityManager().remove(object);
+		return object;
+	}
+	
+	public Query Manager.createQuery(String queryString){
+		EntityManager em = getEntityManager();
+		Query query = em.createQuery(queryString);
+		return query;
+	}
+	
+	public EntityManager Manager.getEntityManager() {
+		return H2Lookup.em();
+	}
+	
+}
@@ -0,0 +1,13 @@
+/*
+ * Created on Aug 22, 2008
+ */
+package bug;
+
+
+public interface NaturallyComparable {
+	
+	public Object getNaturalId();
+	
+	public boolean naturallyEqual(NaturallyComparable to);
+
+}
@@ -0,0 +1,49 @@
+/*
+ * Created on Aug 22, 2008
+ */
+package bug;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+
+public abstract class NaturallyComparablePruner<T extends NaturallyComparable, O> {
+	
+	public List<? extends T> prune(List<? extends T> list, List<O> order){
+		Map<Object, List<T>> sep = new HashMap<Object, List<T>>();
+		for(T obj : list){
+			Object id = obj.getNaturalId();
+			List<T> matches = sep.get(id);
+			if(matches == null){
+				matches = new ArrayList<T>();
+				sep.put(id, matches);
+			}
+			if(matches.size() == 0)
+				matches.add(obj);
+			else{
+				T match = matches.get(0);
+				O yours = getOrdering(match);
+				O mine = getOrdering(obj);
+				if(EqualityUtils.equal(mine, yours))
+					matches.add(obj);
+				else{
+					int yourIndex = order.indexOf(yours);
+					int myIndex = order.indexOf(mine);
+					if(myIndex < yourIndex){
+						matches.clear();
+						matches.add(obj);
+					}
+				}
+			}
+		}
+		List<T> result = new ArrayList<T>();
+		for(List<T> values : sep.values())
+			result.addAll(values);
+		return result;
+	}
+	
+	public abstract O getOrdering(T object);
+
+}
@@ -0,0 +1,12 @@
+/*
+ * Created on Jul 23, 2008
+ */
+package bug;
+
+public interface Partitioned extends NaturallyComparable{
+	
+	public String getOwnerId();
+	
+	public String getPartitionId();
+
+}
@@ -0,0 +1,28 @@
+/*
+ * Created on Jul 25, 2008
+ */
+package bug;
+
+import java.util.List;
+
+public interface PartitionedManager extends Manager{
+
+	public Class<? extends Partitioned> getPartitionedType();
+	
+	public List<? extends Partitioned> getAllInPartitions(List<String> partitionOrder);
+	
+	public List<? extends Partitioned> getAllInPartition(String partitionId);
+	
+	public List<? extends Partitioned> getBestInPartitions(List<String> partitionOrder);
+	
+	public List<? extends Partitioned> getBestInDefaultPartitions();
+	
+	public List<? extends Partitioned> removeWeakPartitionMatches(List<? extends Partitioned> partitioned);
+	
+	public List<? extends Partitioned> removeWeakPartitionMatches(List<? extends Partitioned> partitioned, List<String> partitionOrder);
+	
+	public DuplicateStrategy getPartitionedDuplicateStrategy();
+
+	public List<String> getDefaultPartitionOrder();
+
+}
\ No newline at end of file
@@ -0,0 +1,46 @@
+package bug;
+
+import java.util.List;
+
+public aspect PartitionedManagerAspect {
+	
+	public Class<? extends Partitioned> PartitionedManager.getPartitionedType(){
+		return (Class<? extends Partitioned>) getManagedType();
+	}
+	
+	public List<? extends Partitioned> PartitionedManager.removeWeakPartitionMatches(List<? extends Partitioned> partitioned){
+		return removeWeakPartitionMatches(partitioned, getDefaultPartitionOrder());
+	}
+	
+	public List<? extends Partitioned> PartitionedManager.removeWeakPartitionMatches(
+				List<? extends Partitioned> partitioned, List<String> partitionOrder){
+		return new PartitionedPruner().prune(partitioned, partitionOrder);
+	}
+	
+	public List<? extends Partitioned> PartitionedManager.getBestInDefaultPartitions(){
+		return getBestInPartitions(getDefaultPartitionOrder());
+	}
+	
+	public List<? extends Partitioned> PartitionedManager.getBestInPartitions(List<String> partitionOrder){
+		List<? extends Partitioned> results = getAllInPartitions(partitionOrder);
+		results = removeWeakPartitionMatches(results, partitionOrder);
+		return results;
+	}
+	
+	public List<? extends Partitioned> PartitionedManager.getAllInPartition(String partitionId){
+		String queryString = QueryUtils.select(getPartitionedType(), "partitioned") +
+			" WHERE partitioned.partitionId = :partitionId";
+		Query query = createQuery(queryString);
+		query.setParameter("partitionId", partitionId);
+		return query.getResultList();
+	}
+	
+	public List<? extends Partitioned> PartitionedManager.getAllInPartitions(List<String> partitionOrder){
+		String queryString = QueryUtils.select(getPartitionedType(), "partitioned") +
+		" WHERE partitioned.partitionId IN (:partitionOrder)";
+		Query query = createQuery(queryString);
+		query.setParameter("partitionORder", partitionOrder);
+		return query.getResultList();
+	}
+
+}
@@ -0,0 +1,13 @@
+/*
+ * Created on Aug 22, 2008
+ */
+package bug;
+
+public class PartitionedPruner extends NaturallyComparablePruner<Partitioned, String>{
+
+	@Override
+    public String getOrdering(Partitioned object) {
+	    return object.getPartitionId();
+    }
+
+}
@@ -0,0 +1,20 @@
+/*
+ * Created on Sep 18, 2008
+ */
+package bug;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+public class Query {
+	
+	public List getResultList(){
+		return new ArrayList<Object>();
+	}
+	
+	public Query setParameter(String name, Object value){
+		return this;
+	}
+
+}
@@ -0,0 +1,16 @@
+/*
+ * Created on Aug 18, 2008
+ */
+package bug;
+
+public class QueryUtils {
+	
+	public static String select(Class<?> from, String alias){
+		return select(from, alias, alias);
+	}
+	
+	public static String select(Class<?> from, String alias, String target){
+		return "SELECT " + target + " FROM " + from.getName() + " " + alias + " ";
+	}
+
+}
Binary files differ
@@ -0,0 +1,26 @@
+/*
+ * Created on Sep 18, 2008
+ */
+package bug2;
+
+import java.util.List;
+
+import bug.DuplicateStrategy;
+import bug.PartitionedManager;
+
+
+public class FailingManager implements PartitionedManager {
+
+	public Class<Object> getManagedType(){
+		return Object.class;
+	}
+
+    public List<String> getDefaultPartitionOrder() {
+	    return null;
+    }
+
+    public DuplicateStrategy getPartitionedDuplicateStrategy() {
+	    return null;
+    }
+	
+}
Binary files differ
Binary files differ
@@ -186,11 +186,6 @@ public class TypeVariable {
 	public boolean canBeBoundTo(ResolvedType aCandidateType) {
 		if (!isResolved) throw new IllegalStateException("Can't answer binding questions prior to resolving");
 
-		// TODO 2 is this next bit bogus, what is it for?
-		if (aCandidateType.isTypeVariableReference()) {
-			return matchingBounds((TypeVariableReferenceType)aCandidateType);
-		}
-		
 		// wildcard can accept any binding
 		if (aCandidateType.isGenericWildcard()) {  // AMC - need a more robust test!
 			return true;
@@ -214,50 +209,6 @@ public class TypeVariable {
 		return true;
 	}
 
-	// can match any type in the range of the type variable...
-	// XXX what about interfaces?
-	private boolean matchingBounds(TypeVariableReferenceType tvrt) {
-		if (tvrt.getUpperBound() != getUpperBound()) {
-			UnresolvedType unresolvedCandidateUpperBound = tvrt.getUpperBound();
-			UnresolvedType unresolvedThisUpperBound = getUpperBound();
-			if (unresolvedCandidateUpperBound instanceof ResolvedType && unresolvedThisUpperBound instanceof ResolvedType) {
-				ResolvedType candidateUpperBound = (ResolvedType)unresolvedCandidateUpperBound;
-				ResolvedType thisUpperBound = (ResolvedType)unresolvedThisUpperBound;
-				if (!thisUpperBound.isAssignableFrom(candidateUpperBound)) {
-					return false;
-				}
-			} else {
-				// not right, they shouldnt have been unresolved...
-				return false;
-			}
-		}
-		if (tvrt.hasLowerBound() != (getLowerBound() != null)) return false;
-		if (tvrt.hasLowerBound() && tvrt.getLowerBound() != getLowerBound()) return false;
-		// either we both have bounds, or neither of us have bounds
-		ReferenceType[] tvrtBounds = tvrt.getAdditionalBounds();
-		if ((tvrtBounds != null) != (additionalInterfaceBounds != null)) return false;
-		if (additionalInterfaceBounds != null) {
-			// we both have bounds, compare
-			if (tvrtBounds.length != additionalInterfaceBounds.length) return false;
-			Set aAndNotB = new HashSet();
-			Set bAndNotA = new HashSet();
-			for (int i = 0; i < additionalInterfaceBounds.length; i++) {
-				aAndNotB.add(additionalInterfaceBounds[i]);
-			}
-			for (int i = 0; i < tvrtBounds.length; i++) {
-				bAndNotA.add(tvrtBounds[i]);
-			}
-			for (int i = 0; i < additionalInterfaceBounds.length; i++) {
-				bAndNotA.remove(additionalInterfaceBounds[i]);
-			}
-			for (int i = 0; i < tvrtBounds.length; i++) {
-				aAndNotB.remove(tvrtBounds[i]);
-			}
-			if (! (aAndNotB.isEmpty() && bAndNotA.isEmpty()) ) return false;
-		}
-		return true;
-	}
-	
 	private boolean isASubtypeOf(UnresolvedType candidateSuperType, UnresolvedType candidateSubType) {
 		ResolvedType superType = (ResolvedType) candidateSuperType;
 		ResolvedType subType = (ResolvedType) candidateSubType;
@@ -22,6 +22,7 @@ public class Ajc162Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	public void testGenericDecp_pr241047() { runTest("generic decp"); }
 	public void testGenericItds_pr242797_1() { runTest("generic itds - 1"); }
 	public void testGenericItds_pr242797_2() { runTest("generic itds - 2"); }
+	public void testGenericItds_pr242797_3() { runTest("generic itds - 3"); }
 //	public void testParamAnnosPipelining_pr241847() { runTest("param annos pipelining");}
 //	public void testParamAnnoInner_pr241861() { runTest("param annotation inner class"); }
 	public void testAnnotationDecp_pr239441() { runTest("annotation decp"); }
@@ -33,6 +33,11 @@
         <compile files="GenericMethodAspect.aj GenericMethodInterface.java GenericMethodImpl.java" options="-1.5">
         </compile>
     </ajc-test> 
+
+    <ajc-test dir="bugs162/pr242797/case3" title="generic itds - 3">
+        <compile files="GenericMethodAspect.aj GenericMethodInterface.java GenericMethodImpl.java GenericMethodImpl2.java Type1.java Type2.java" options="-1.5">
+        </compile>
+    </ajc-test> 
 
   	<ajc-test dir="bugs162/pr241847" title="param annos pipelining">
     	<compile files="Asp.aj Ann.java CC.java II.java LongLong.java" options="-1.5 -showWeaveInfo">
@@ -0,0 +1,10 @@
+import java.util.ArrayList;
+import java.util.List;
+
+public aspect GenericMethodAspect {
+	
+	public <T> List<T> GenericMethodInterface.getStuff(){
+		return new ArrayList<T>();
+	}
+
+}
@@ -0,0 +1,10 @@
+import java.util.LinkedList;
+import java.util.List;
+
+public class GenericMethodImpl<D extends Type1> implements GenericMethodInterface{
+	
+	public <T extends D> List<T> getStuff(){
+		return new LinkedList<T>();
+	}
+
+}
@@ -0,0 +1,15 @@
+import java.util.List;
+
+
+/*
+ * Created on Aug 19, 2008
+ */
+
+public class GenericMethodImpl2 extends GenericMethodImpl<Type2> {
+
+	@Override
+    public <T extends Type2> List<T> getStuff() {
+	    return super.getStuff();
+    }
+
+}
@@ -0,0 +1,12 @@
+import java.util.List;
+
+
+/*
+ * Created on Aug 19, 2008
+ */
+
+public interface GenericMethodInterface {
+	
+	public <T> List<T> getStuff();
+
+}
@@ -0,0 +1,8 @@
+
+/*
+ * Created on Aug 19, 2008
+ */
+
+public interface Type1 {
+
+}
@@ -0,0 +1,8 @@
+
+/*
+ * Created on Aug 19, 2008
+ */
+
+public class Type2 implements Type1 {
+
+}
@@ -21,6 +21,7 @@ public class Ajc162Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	// AspectJ1.6.2	
 	public void testGenericDecp_pr241047() { runTest("generic decp"); }
 	public void testGenericItds_pr242797_1() { runTest("generic itds - 1"); }
+	public void testGenericItds_pr242797_2() { runTest("generic itds - 2"); }
 //	public void testParamAnnosPipelining_pr241847() { runTest("param annos pipelining");}
 //	public void testParamAnnoInner_pr241861() { runTest("param annotation inner class"); }
 	public void testAnnotationDecp_pr239441() { runTest("annotation decp"); }
@@ -28,6 +28,11 @@
         <compile files="ClassUtils.java CMEFinder.java Finder.java H2Deployment.java Localized.java LocalizedFinder.java OnetElement.java OnetFinder.java Partitioned.java PartitionedFinder.java" options="-1.5">
         </compile>
     </ajc-test> 
+    
+    <ajc-test dir="bugs162/pr242797/case2" title="generic itds - 2">
+        <compile files="GenericMethodAspect.aj GenericMethodInterface.java GenericMethodImpl.java" options="-1.5">
+        </compile>
+    </ajc-test> 
 
   	<ajc-test dir="bugs162/pr241847" title="param annos pipelining">
     	<compile files="Asp.aj Ann.java CC.java II.java LongLong.java" options="-1.5 -showWeaveInfo">
@@ -380,7 +380,7 @@ public class TypeVariable {
 		String name = s.readUTF();
 		UnresolvedType ubound = UnresolvedType.read(s);
 		int iboundcount = s.readInt();
-		UnresolvedType[] ibounds = null;
+		UnresolvedType[] ibounds = UnresolvedType.NONE;
 		if (iboundcount>0) {
 			ibounds = new UnresolvedType[iboundcount];
 			for (int i=0; i<iboundcount; i++) {
@@ -0,0 +1,10 @@
+import java.util.ArrayList;
+import java.util.List;
+
+public aspect GenericMethodAspect {
+	
+	public <T> List<T> GenericMethodInterface.getStuff(){
+		return new ArrayList<T>();
+	}
+
+}
@@ -0,0 +1,10 @@
+import java.util.LinkedList;
+import java.util.List;
+
+public class GenericMethodImpl implements GenericMethodInterface{
+	
+	public <T> List<T> getStuff(){
+		return new LinkedList<T>();
+	}
+
+}
@@ -0,0 +1,12 @@
+import java.util.List;
+
+
+/*
+ * Created on Aug 19, 2008
+ */
+
+public interface GenericMethodInterface {
+	
+	public <T> List<T> getStuff();
+
+}
@@ -0,0 +1,9 @@
+import java.util.List;
+
+public class CMEFinder extends OnetFinder<CMEStub, PartitionedCME, LocalizedCME, ContentModelElement>{
+} 
+
+class CMEStub {}
+class PartitionedCME implements Partitioned{ }
+class LocalizedCME implements Localized {}
+class ContentModelElement extends OnetElement {} 
\ No newline at end of file
@@ -0,0 +1,4 @@
+
+public class ClassUtils {
+	public static Class guessGenericType(Class c) { return c; }
+}
@@ -0,0 +1,2 @@
+public interface Finder {
+}
@@ -0,0 +1,5 @@
+import java.util.List;
+public class H2Deployment {
+	public static H2Deployment instance() { return new H2Deployment(); }
+	List<String> getPartitionOrder(Class c) { return null;}
+}
@@ -0,0 +1 @@
+public interface Localized {}
@@ -0,0 +1,2 @@
+public interface LocalizedFinder<L extends Localized> extends Finder {
+}
@@ -0,0 +1,3 @@
+public class OnetElement<T> implements Partitioned,Localized {
+
+}
@@ -0,0 +1,2 @@
+public abstract class OnetFinder<S,P extends Partitioned<?>, L extends Localized, O extends OnetElement<?>> implements Finder,PartitionedFinder<O>,LocalizedFinder<O> {
+}
@@ -0,0 +1,9 @@
+public interface Partitioned<A> {
+	public String getPartitionId();
+}
+ 
+aspect PartitionedI {
+	public String Partitioned<A>.getPartitionId() {
+		return null;
+	}
+}
\ No newline at end of file
@@ -0,0 +1,34 @@
+import java.util.List;
+
+public interface PartitionedFinder<P extends Partitioned<?>> extends Finder {
+//	public <T extends Localized> List<T> bestLanguageMatch(List<T> list, List<String> languageOrder);
+	public <T extends Partitioned<?>> List<T> bestPartitionMatch(List<T> list, List<String> partitionOrder);
+}
+
+aspect PartitionedFinderAspect {
+
+    public Class<? extends P> PartitionedFinder<P>.getPartitionedType(){
+            return ClassUtils.guessGenericType(getClass());
+    }
+
+    public List<String> PartitionedFinder<P>.getPartitionOrder(){
+            return H2Deployment.instance().getPartitionOrder(getPartitionedType());
+    }
+
+    public <T extends Partitioned<?>> List<T> PartitionedFinder<P>.bestPartitionMatch(List<T> list, List<String> partitionOrder){
+            return new OrderComparator<T, String>(partitionOrder){
+
+                    @Override
+                    public String getOrdering(T partitioned){
+                            return partitioned.getPartitionId();
+                    }
+
+            }.bestMatch(list);
+    }
+}
+
+class OrderComparator<A,B> {
+	OrderComparator(List<String> ls) {}
+	public String getOrdering(A a) {return "";}
+	List bestMatch(List l) {return null;}
+}
@@ -19,6 +19,7 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 public class Ajc162Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
 	// AspectJ1.6.2	
+	public void testGenericItds_pr242797_1() { runTest("generic itds - 1"); }
 //	public void testParamAnnosPipelining_pr241847() { runTest("param annos pipelining");}
 //	public void testParamAnnoInner_pr241861() { runTest("param annotation inner class"); }
 	public void testAnnotationDecp_pr239441() { runTest("annotation decp"); }
@@ -3,13 +3,18 @@
 <!-- AspectJ v1.6.2 Tests -->
 <suite>
 
-	<ajc-test dir="bugs162/pr241847" title="param annos pipelining">
+    <ajc-test dir="bugs162/pr242797/case1" title="generic itds - 1">
+        <compile files="ClassUtils.java CMEFinder.java Finder.java H2Deployment.java Localized.java LocalizedFinder.java OnetElement.java OnetFinder.java Partitioned.java PartitionedFinder.java" options="-1.5">
+        </compile>
+    </ajc-test> 
+ 
+  	<ajc-test dir="bugs162/pr241847" title="param annos pipelining">
     	<compile files="Asp.aj Ann.java CC.java II.java LongLong.java" options="-1.5 -showWeaveInfo">
     		<message kind="weave" text="Join point 'method-execution(void LongLong.m1(java.lang.String))' in Type 'LongLong' (LongLong.java:2) advised by before advice from 'Asp' (Asp.aj:5)"/>
     		<message kind="weave" line="3"/>
     	</compile>
     </ajc-test>    
-
+    
 	<ajc-test dir="bugs162/pr239441" title="annotation decp">
     	<compile files="Test3.java SampleAspect.java" options="-1.5 -showWeaveInfo -XhasMember">
     	</compile>
@@ -1250,7 +1250,7 @@
             <message kind="error" line="12" text="Cannot override the final method from A.TestInterface"></message>
         </compile>
         <compile files="FinalITDMOnInterface2.aj">
-            <message kind="error" line="8" text="Cannot override the final method from A.TestInterface"></message>
+            <!--message kind="error" line="8" text="Cannot override the final method from A.TestInterface"></message-->
             <message kind="error" line="8" text="can't override final void A$TestInterface.m()"></message>
         </compile>
     </ajc-test>
@@ -44,6 +44,7 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.aspectj.org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
+import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ParameterizedMethodBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.TagBits;
@@ -517,9 +518,10 @@ public class AjProblemReporter extends ProblemReporter {
      * (pr115788)
      */
     public void duplicateInheritedMethods(SourceTypeBinding type, MethodBinding inheritedMethod1, MethodBinding inheritedMethod2) {
-    	if (!(inheritedMethod1 instanceof InterTypeMethodBinding && 
-    	      inheritedMethod2 instanceof InterTypeMethodBinding)) 
-    		super.duplicateInheritedMethods(type,inheritedMethod1,inheritedMethod2);
+    	if (inheritedMethod1 instanceof InterTypeMethodBinding || inheritedMethod2 instanceof InterTypeMethodBinding) return;
+    	if ((inheritedMethod1 instanceof ParameterizedMethodBinding) && ((ParameterizedMethodBinding)inheritedMethod1).original() instanceof InterTypeMethodBinding) return;
+    	if ((inheritedMethod2 instanceof ParameterizedMethodBinding) && ((ParameterizedMethodBinding)inheritedMethod2).original() instanceof InterTypeMethodBinding) return;
+   		super.duplicateInheritedMethods(type,inheritedMethod1,inheritedMethod2);
     }
 
     /**
@@ -248,7 +248,7 @@ public class InterTypeMemberFinder implements IMemberFinder {
 	// find all of my methods, including ITDs
 	// PLUS: any public ITDs made on interfaces that I implement
 	public MethodBinding[] methods(SourceTypeBinding sourceTypeBinding) {
-		MethodBinding[] orig = sourceTypeBinding.methods();
+		MethodBinding[] orig = sourceTypeBinding.methodsBase();
 //		if (interTypeMethods.isEmpty()) return orig;
 
 		List ret = new ArrayList(Arrays.asList(orig));
@@ -68,13 +68,7 @@ public class InterTypeMethodBinding extends MethodBinding {
 		// 1st set:
 		// If the typevariable is one declared on the source method, then we know we are the declaring element
 		for (int i = 0; i < typeVariables.length; i++) {
-			TypeVariableBinding tv = typeVariables[i];
-			String name = new String(tv.sourceName);
-			TypeVariableBinding[] tv2 = sourceMethod.binding.typeVariables;
-			for (int j = 0; j < tv2.length; j++) {
-				TypeVariableBinding typeVariable = tv2[j];
-				if (new String(tv2[j].sourceName).equals(name)) typeVariables[i].declaringElement = this;
-			}
+			typeVariables[i].declaringElement = this;
 		}
 		for (int i = 0; i < typeVariables.length; i++) {
 			if (typeVariables[i].declaringElement==null) throw new RuntimeException("Declaring element not set");
@@ -358,7 +358,7 @@ public class ReferenceType extends ResolvedType {
        	if (other.isTypeVariableReference()) {
        		TypeVariableReferenceType otherType = (TypeVariableReferenceType) other;
        		if (this instanceof TypeVariableReference) {
-       			return ((TypeVariableReference)this).getTypeVariable().canBeBoundTo(otherType.getTypeVariable().getFirstBound().resolve(world));// pr171952
+       			return ((TypeVariableReference)this).getTypeVariable().resolve(world).canBeBoundTo(otherType.getTypeVariable().getFirstBound().resolve(world));// pr171952
 //       			return ((TypeVariableReference)this).getTypeVariable()==otherType.getTypeVariable();
        		} else {
        		    // FIXME asc should this say canBeBoundTo??
@@ -1648,8 +1648,8 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 		if (world.isInJava5Mode() && parent.getKind()==Member.METHOD) {
 
 		  // Look at the generic types when doing this comparison
-	      ResolvedType rtParentReturnType = parent.getGenericReturnType().resolve(world);
-		  ResolvedType rtChildReturnType  = child.getGenericReturnType().resolve(world);
+	      ResolvedType rtParentReturnType = parent.resolve(world).getGenericReturnType().resolve(world);
+		  ResolvedType rtChildReturnType  = child.resolve(world).getGenericReturnType().resolve(world);
 		  incompatibleReturnTypes = !rtParentReturnType.isAssignableFrom(rtChildReturnType);
 		  if (incompatibleReturnTypes) {
 			  incompatibleReturnTypes = !rtParentReturnType.isAssignableFrom(rtChildReturnType);
Binary files differ
Binary files differ
