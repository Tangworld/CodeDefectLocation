@@ -0,0 +1,5 @@
+public class Ship {
+	       public void moveTo(int newX, int newY) {
+		                      this.h();
+				       }
+}
@@ -0,0 +1,14 @@
+public privileged aspect ShipAccessor {
+
+
+
+
+
+
+
+
+	       public java.util.List<String> Ship.h() {
+		                      return null;
+				             }
+}
+
@@ -11,6 +11,8 @@
 package org.aspectj.systemtest.ajc163;
 
 import java.io.File;
+import java.util.Iterator;
+import java.util.List;
 
 import junit.framework.Test;
 
@@ -18,11 +20,43 @@ import org.aspectj.apache.bcel.classfile.JavaClass;
 import org.aspectj.apache.bcel.classfile.LocalVariable;
 import org.aspectj.apache.bcel.classfile.LocalVariableTable;
 import org.aspectj.apache.bcel.classfile.Method;
+import org.aspectj.asm.AsmManager;
+import org.aspectj.asm.IHierarchy;
+import org.aspectj.asm.IProgramElement;
 import org.aspectj.testing.Utils;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc163Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testFQType_pr256937() {
+		runTest("fully qualified return type");
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
+		IProgramElement itd = findElementAtLine(top.getRoot(), 10);
+		String type = itd.getCorrespondingType(true);
+		assertEquals("java.util.List<java.lang.String>", type);
+	}
+
+	private IProgramElement findElementAtLine(IProgramElement whereToLook, int line) {
+		if (whereToLook == null) {
+			return null;
+		}
+		if (whereToLook.getSourceLocation() != null && whereToLook.getSourceLocation().getLine() == line) {
+			return whereToLook;
+		}
+		List kids = whereToLook.getChildren();
+		for (Iterator iterator = kids.iterator(); iterator.hasNext();) {
+			IProgramElement object = (IProgramElement) iterator.next();
+			if (object.getSourceLocation() != null && object.getSourceLocation().getLine() == line) {
+				return object;
+			}
+			IProgramElement gotSomething = findElementAtLine(object, line);
+			if (gotSomething != null) {
+				return gotSomething;
+			}
+		}
+		return null;
+	}
+
 	public void testParameterAnnotationsOnITDs_pr256669() { // regular itd
 		runTest("parameter annotations on ITDs");
 	}
@@ -2,6 +2,10 @@
 
 <suite>
 
+    <ajc-test dir="bugs163/pr256937" title="fully qualified return type">
+   	  <compile files="Ship.java ShipAccessor.java" options="-emacssym -1.5"/>
+    </ajc-test>
+    
     <ajc-test dir="bugs163/pr254207" title="ordering issue">
       <compile files="Abstract.java Concrete.java" options="-1.5 -proceedOnError -Xset:pipelineCompilation=false">
         <message kind="error" line="1" text="Bound mismatch"/>
@@ -187,7 +187,7 @@ public class AsmElementFormatter {
 				node.setKind(IProgramElement.Kind.ERROR);
 				node.setName(name);
 			}
-			node.setCorrespondingType(itd.returnType.toString());
+			node.setCorrespondingType(new String(itd.returnType.resolvedType.readableName()));
 			if (node.getKind() != IProgramElement.Kind.INTER_TYPE_FIELD) {
 				setParameters(methodDeclaration, node);
 			}
@@ -508,7 +508,7 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 				peNode.setCorrespondingType(methodDeclaration.returnType.toString());
 			} else {
 				if (methodDeclaration.returnType.resolvedType != null)
-					peNode.setCorrespondingType(methodDeclaration.returnType.resolvedType.debugName());
+					peNode.setCorrespondingType(new String(methodDeclaration.returnType.resolvedType.readableName()));
 				else
 					peNode.setCorrespondingType(null);
 			}
