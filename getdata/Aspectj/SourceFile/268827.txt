@@ -69,8 +69,8 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		build(p);
 		checkCompileWeaveCount(p, 3, 1);
 		assertEquals(1, olm.removeCount); // B.class removed
-	}
-
+	} 
+	
 	public void testOutputLocationCallbacks() {
 		String p = "pr268827_ol";
 		initialiseProject(p);
@@ -84,6 +84,23 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		assertEquals(1, olm.removeCount);
 	}
 
+	public void testOutputLocationCallbacksFileAdd() {
+		AjdeInteractionTestbed.VERBOSE = true;
+		String p = "pr268827_ol2";
+		initialiseProject(p);
+		CustomOLM olm = new CustomOLM(getProjectRelativePath(p, ".").toString());
+		configureOutputLocationManager(p, olm);
+		build(p);
+		assertEquals(3, olm.writeCount);
+		olm.writeCount = 0;
+		checkCompileWeaveCount(p, 2, 3);
+		alter(p, "inc1"); // this contains a new file Boo.java
+		build(p);
+		assertEquals(1, olm.writeCount);
+		checkCompileWeaveCount(p, 1, 1);
+		// assertEquals(1, olm.removeCount);
+	}
+
 	static class CustomOLM extends TestOutputLocationManager {
 
 		public int writeCount = 0;
@@ -96,12 +113,14 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		public void reportFileWrite(String outputfile, int filetype) {
 			super.reportFileWrite(outputfile, filetype);
 			writeCount++;
+			System.out.println("Written " + outputfile);
 			// System.out.println("Written " + outputfile + " " + filetype);
 		}
 
 		public void reportFileRemove(String outputfile, int filetype) {
 			super.reportFileRemove(outputfile, filetype);
 			removeCount++;
+			System.out.println("Removed " + outputfile);
 			// System.out.println("Removed " + outputfile + "  " + filetype);
 		}
 
@@ -106,4 +106,9 @@ public class MultiProjTestOutputLocationManager implements IOutputLocationManage
 	public void reportFileRemove(String outputfile, int filetype) {
 	}
 
+	public int discoverChangesSince(File dir, long buildtime) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
 }
@@ -143,6 +143,11 @@ public class OutputLocationManagerTests extends AbstractMultiProjectIncrementalA
 		public String getSourceFolderForFile(File sourceFile) {
 			return null;
 		}
+
+		public int discoverChangesSince(File dir, long buildtime) {
+			// TODO Auto-generated method stub
+			return 0;
+		}
 	}
 
 	public void reportFileWrite(String outputfile, int filetype) {
@@ -90,6 +90,11 @@ public class IncrementalOutputLocationManagerTests extends AbstractMultiProjectI
 			return null;
 		}
 
+		public int discoverChangesSince(File dir, long buildtime) {
+			// TODO Auto-generated method stub
+			return 0;
+		}
+
 	}
 
 }
@@ -361,6 +361,11 @@ public class MoreOutputLocationManagerTests extends AbstractMultiProjectIncremen
 			// TODO Auto-generated method stub
 			return null;
 		}
+
+		public int discoverChangesSince(File dir, long buildtime) {
+			// TODO Auto-generated method stub
+			return 0;
+		}
 	}
 
 }
@@ -400,4 +400,9 @@ class MyOutputLocationManager implements IOutputLocationManager {
 	public void reportFileRemove(String outputfile, int filetype) {
 	}
 
+	public int discoverChangesSince(File dir, long buildtime) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
 }
@@ -85,4 +85,9 @@ public class TestOutputLocationManager implements IOutputLocationManager {
 	public void reportFileRemove(String outputfile, int filetype) {
 	}
 
+	public int discoverChangesSince(File dir, long buildtime) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
 }
@@ -90,4 +90,9 @@ public class TestOutputLocationManager implements IOutputLocationManager {
 	public void reportFileRemove(String outputfile, int filetype) {
 	}
 
+	public int discoverChangesSince(File dir, long buildtime) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
 }
@@ -64,4 +64,9 @@ public class BrowserOutputLocationManager implements IOutputLocationManager {
 	public void reportFileRemove(String outputfile, int filetype) {
 	}
 
+	public int discoverChangesSince(File dir, long buildtime) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
 }
@@ -77,6 +77,8 @@ public interface IOutputLocationManager {
 	 */
 	void reportFileRemove(String file, int fileType);
 
+	int discoverChangesSince(File dir, long buildtime);
+
 	// match numbers in CompilationResultDestinationManager - ought to factor into super interface
 	int FILETYPE_UNKNOWN = 0;
 	int FILETYPE_CLASS = 1;
@@ -57,4 +57,8 @@ public class OutputLocationAdapter implements CompilationResultDestinationManage
 		this.locationManager.reportFileRemove(outputfile, filetype);
 	}
 
+	public int discoverChangesSince(File dir, long buildtime) {
+		return this.locationManager.discoverChangesSince(dir,buildtime);
+	}
+
 }
@@ -75,9 +75,12 @@ public interface CompilationResultDestinationManager {
 	 */
 	void reportFileRemove(String outputfile, int filetype);
 
+	int discoverChangesSince(File dir, long buildtime);
+
 	// match numbers in IOutputLocationManager - ought to factor into super interface
 	int FILETYPE_UNKNOWN = 0;
 	int FILETYPE_CLASS = 1;
 	int FILETYPE_OUTJAR = 2;
 	int FILETYPE_RESOURCE = 3;
+	
 }
@@ -432,6 +432,7 @@ public class AjState implements CompilerConfigurationChangeFlags {
 				getListener().recordDecision("Failed to find a state instance managing output location : " + dir);
 			}
 		}
+		
 
 		// pr268827 - this guard will cause us to exit quickly if the state says there really is
 		// nothing of interest. This will not catch the case where a user modifies the .class files outside of
@@ -443,6 +444,24 @@ public class AjState implements CompilerConfigurationChangeFlags {
 			}
 			return CLASS_FILE_NO_CHANGES;
 		}
+		
+		if (state == null) {
+			// This may be because the directory is the output path of a Java project upon which we depend
+			// we need to call back into AJDT to ask about that projects state.
+			CompilationResultDestinationManager crdm = buildConfig.getCompilationResultDestinationManager();
+			if (crdm!=null) {
+				int i = crdm.discoverChangesSince(dir,lastSuccessfulBuildTime);
+				// 0 = dontknow if it has changed
+				// 1 = definetly not changed at all
+				// further numbers can determine more granular changes
+				if (i==1) {
+					if (listenerDefined()) {
+						getListener().recordDecision("'"+dir+"' is apparently unchanged so not performing timestamp check");
+					}
+					return CLASS_FILE_NO_CHANGES;
+				}
+			}
+		}
 
 		List classFiles = FileUtil.listClassFiles(dir);
 
@@ -61,4 +61,7 @@ public class BrowserOutputLocationManager implements IOutputLocationManager {
 	public void reportClassFileWrite(String outputfile) {
 	}
 
+	public void reportClassFileRemove(String outputfile) {
+	}
+
 }
@@ -354,6 +354,9 @@ public class MoreOutputLocationManagerTests extends AbstractMultiProjectIncremen
 		public void reportClassFileWrite(String outputfile) {
 		}
 
+		public void reportClassFileRemove(String outputfile) {
+		}
+
 		public String getSourceFolderForFile(File sourceFile) {
 			// TODO Auto-generated method stub
 			return null;
@@ -103,4 +103,7 @@ public class MultiProjTestOutputLocationManager implements IOutputLocationManage
 		// System.err.println(">>>" + outputfile);
 	}
 
+	public void reportClassFileRemove(String outputfile) {
+	}
+
 }
@@ -102,6 +102,9 @@ public class OutputLocationManagerTests extends AbstractMultiProjectIncrementalA
 		public void reportClassFileWrite(String outputfile) {
 		}
 
+		public void reportClassFileRemove(String outputfile) {
+		}
+
 		public File getOutputLocationForClass(File compilationUnit) {
 			String relativePath = "";
 			String compilationUnitName = compilationUnit.getAbsolutePath();
@@ -145,4 +148,7 @@ public class OutputLocationManagerTests extends AbstractMultiProjectIncrementalA
 	public void reportClassFileWrite(String outputfile) {
 	}
 
+	public void reportClassFileRemove(String outputfile) {
+	}
+
 }
@@ -48,6 +48,9 @@ public class IncrementalOutputLocationManagerTests extends AbstractMultiProjectI
 		public void reportClassFileWrite(String outputfile) {
 		}
 
+		public void reportClassFileRemove(String outputfile) {
+		}
+
 		public File getOutputLocationForClass(File compilationUnit) {
 			String path = compilationUnit.getAbsolutePath();
 			int index = path.indexOf("src");
@@ -397,4 +397,7 @@ class MyOutputLocationManager implements IOutputLocationManager {
 	public void reportClassFileWrite(String outputfile) {
 	}
 
+	public void reportClassFileRemove(String outputfile) {
+	}
+
 }
@@ -0,0 +1,5 @@
+public class Foo {
+}
+
+class Extra {
+}
@@ -0,0 +1,2 @@
+public class Goo {
+}
@@ -0,0 +1,3 @@
+public class Foo {
+}
+
@@ -61,4 +61,6 @@ public interface IOutputLocationManager {
 
 	void reportClassFileWrite(String outputfile);
 
+	void reportClassFileRemove(String outputfile);
+
 }
@@ -52,4 +52,8 @@ public class OutputLocationAdapter implements CompilationResultDestinationManage
 	public void reportClassFileWrite(String outputfile) {
 		this.locationManager.reportClassFileWrite(outputfile);
 	}
+
+	public void reportClassFileRemove(String outputfile) {
+		this.locationManager.reportClassFileRemove(outputfile);
+	}
 }
@@ -82,4 +82,7 @@ public class TestOutputLocationManager implements IOutputLocationManager {
 	public void reportClassFileWrite(String outputfile) {
 	}
 
+	public void reportClassFileRemove(String outputfile) {
+	}
+
 }
@@ -23,6 +23,7 @@ import java.util.Map;
 import java.util.Set;
 
 import org.aspectj.ajde.core.ICompilerConfiguration;
+import org.aspectj.ajde.core.TestOutputLocationManager;
 import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.ajdt.internal.core.builder.AjState;
 import org.aspectj.ajdt.internal.core.builder.IncrementalStateManager;
@@ -51,6 +52,42 @@ import org.aspectj.util.FileUtil;
  */
 public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementalAjdeInteractionTestbed {
 
+	public void testOutputLocationCallbacks() {
+		String p = "pr268827_ol";
+		initialiseProject(p);
+		CustomOLM olm = new CustomOLM(getProjectRelativePath(p, ".").toString());
+		configureOutputLocationManager(p, olm);
+		build(p);
+		checkCompileWeaveCount(p, 2, 3);
+		alter(p, "inc1"); // this contains a new Foo.java that no longer has Extra class in it
+		build(p);
+		checkCompileWeaveCount(p, 1, 1);
+		assertEquals(1, olm.removeCount);
+	}
+
+	static class CustomOLM extends TestOutputLocationManager {
+
+		public int writeCount = 0;
+		public int removeCount = 0;
+
+		public CustomOLM(String testProjectPath) {
+			super(testProjectPath);
+		}
+
+		public void reportClassFileWrite(String outputfile) {
+			super.reportClassFileWrite(outputfile);
+			writeCount++;
+			// System.out.println("Written " + outputfile);
+		}
+
+		public void reportClassFileRemove(String outputfile) {
+			super.reportClassFileRemove(outputfile);
+			removeCount++;
+			// System.out.println("Removed " + outputfile);
+		}
+
+	}
+
 	public void testBrokenCodeDeca_268611() {
 		String p = "pr268611";
 		initialiseProject(p);
@@ -68,4 +68,11 @@ public interface CompilationResultDestinationManager {
 	 */
 	void reportClassFileWrite(String outputfile);
 
+	/**
+	 * Report that a class file is being deleted from the specified location.
+	 * 
+	 * @param outputfile the output file (including .class suffix)
+	 */
+	void reportClassFileRemove(String outputfile);
+
 }
@@ -1025,12 +1025,12 @@ public class AjState implements CompilerConfigurationChangeFlags {
 			List cfs = (List) iter.next();
 			for (Iterator iterator = cfs.iterator(); iterator.hasNext();) {
 				ClassFile cf = (ClassFile) iterator.next();
-				cf.deleteFromFileSystem();
+				cf.deleteFromFileSystem(buildConfig);
 			}
 		}
 		for (Iterator iterator = classesFromName.values().iterator(); iterator.hasNext();) {
 			File f = (File) iterator.next();
-			new ClassFile("", f).deleteFromFileSystem();
+			new ClassFile("", f).deleteFromFileSystem(buildConfig);
 		}
 		for (Iterator iter = resources.iterator(); iter.hasNext();) {
 			String resource = (String) iter.next();
@@ -1046,8 +1046,9 @@ public class AjState implements CompilerConfigurationChangeFlags {
 	}
 
 	private void deleteClassFiles() {
-		if (deletedFiles == null)
+		if (deletedFiles == null) {
 			return;
+		}
 		for (Iterator i = deletedFiles.iterator(); i.hasNext();) {
 			File deletedFile = (File) i.next();
 			addDependentsOf(deletedFile);
@@ -1156,7 +1157,7 @@ public class AjState implements CompilerConfigurationChangeFlags {
 	private void deleteClassFile(ClassFile cf) {
 		classesFromName.remove(cf.fullyQualifiedTypeName);
 		weaver.deleteClassFile(cf.fullyQualifiedTypeName);
-		cf.deleteFromFileSystem();
+		cf.deleteFromFileSystem(buildConfig);
 	}
 
 	private UnwovenClassFile createUnwovenClassFile(AjBuildConfig.BinarySourceFile bsf) {
@@ -1834,7 +1835,7 @@ public class AjState implements CompilerConfigurationChangeFlags {
 			this.locationOnDisk = location;
 		}
 
-		public void deleteFromFileSystem() {
+		public void deleteFromFileSystem(AjBuildConfig buildConfig) {
 			String namePrefix = locationOnDisk.getName();
 			namePrefix = namePrefix.substring(0, namePrefix.lastIndexOf('.'));
 			final String targetPrefix = namePrefix + BcelWeaver.CLOSURE_CLASS_PREFIX;
@@ -1847,10 +1848,17 @@ public class AjState implements CompilerConfigurationChangeFlags {
 				});
 				if (weaverGenerated != null) {
 					for (int i = 0; i < weaverGenerated.length; i++) {
+						if (buildConfig != null && buildConfig.getCompilationResultDestinationManager() != null) {
+							buildConfig.getCompilationResultDestinationManager()
+									.reportClassFileRemove(weaverGenerated[i].getPath());
+						}
 						weaverGenerated[i].delete();
 					}
 				}
 			}
+			if (buildConfig != null && buildConfig.getCompilationResultDestinationManager() != null) {
+				buildConfig.getCompilationResultDestinationManager().reportClassFileRemove(locationOnDisk.getPath());
+			}
 			locationOnDisk.delete();
 		}
 	}
@@ -87,4 +87,7 @@ public class TestOutputLocationManager implements IOutputLocationManager {
 		return null;
 	}
 
+	public void reportClassFileRemove(String outputfile) {
+	}
+
 }
@@ -61,7 +61,7 @@ import org.aspectj.weaver.bcel.UnwovenClassFile;
 public class AjState implements CompilerConfigurationChangeFlags {
 
 	// SECRETAPI configures whether we use state instead of lastModTime - see pr245566
-	public static boolean CHECK_STATE_FIRST = false;
+	public static boolean CHECK_STATE_FIRST = true;
 
 	// SECRETAPI static so beware of multi-threading bugs...
 	public static IStateListener stateListener = null;
@@ -432,6 +432,17 @@ public class AjState implements CompilerConfigurationChangeFlags {
 			}
 		}
 
+		// pr268827 - this guard will cause us to exit quickly if the state says there really is
+		// nothing of interest. This will not catch the case where a user modifies the .class files outside of
+		// eclipse because the state will not be aware of it. But that seems an unlikely scenario and
+		// we are paying a heavy price to check it
+		if (state != null && !state.hasAnyStructuralChangesSince(lastSuccessfulBuildTime)) {
+			if (listenerDefined()) {
+				getListener().recordDecision("No reported changes in that state");
+			}
+			return CLASS_FILE_NO_CHANGES;
+		}
+
 		List classFiles = FileUtil.listClassFiles(dir);
 
 		for (Iterator iterator = classFiles.iterator(); iterator.hasNext();) {
@@ -680,7 +691,8 @@ public class AjState implements CompilerConfigurationChangeFlags {
 	 * Determine if a file has changed since a given time, using the local information recorded in the structural changes data
 	 * structure.
 	 * 
-	 * file is the file we are wondering about lastSBT is the last build time for the state asking the question
+	 * @param file the file we are wondering about
+	 * @param lastSuccessfulBuildTime the last build time for the state asking the question
 	 */
 	private boolean hasStructuralChangedSince(File file, long lastSuccessfulBuildTime) {
 		// long lastModTime = file.lastModified();
@@ -696,6 +708,29 @@ public class AjState implements CompilerConfigurationChangeFlags {
 	}
 
 	/**
+	 * Determine if anything has changed since a given time.
+	 */
+	private boolean hasAnyStructuralChangesSince(long lastSuccessfulBuildTime) {
+		Set entries = structuralChangesSinceLastFullBuild.entrySet();
+		for (Iterator iterator = entries.iterator(); iterator.hasNext();) {
+			Map.Entry entry = (Map.Entry) iterator.next();
+			Long l = (Long) entry.getValue();
+			if (l != null) {
+				long lvalue = l.longValue();
+				if (lvalue > lastSuccessfulBuildTime) {
+					if (listenerDefined()) {
+						getListener().recordDecision(
+								"Seems this has changed " + entry.getKey() + "modtime=" + lvalue + " lsbt="
+										+ this.lastSuccessfulFullBuildTime + "   incoming check value=" + lastSuccessfulBuildTime);
+					}
+					return true;
+				}
+			}
+		}
+		return (this.lastSuccessfulFullBuildTime > lastSuccessfulBuildTime);
+	}
+
+	/**
 	 * Determine if something has changed on the classpath/inpath/aspectpath and a full build is required rather than an incremental
 	 * one.
 	 * 
