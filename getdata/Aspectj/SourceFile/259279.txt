@@ -22,58 +22,61 @@ public class TypeVariableReferenceType extends BoundedReferenceType implements T
 
 	private TypeVariable typeVariable;
 	private boolean resolvedIfBounds = false;
-	
+
 	// If 'fixedUp' then the type variable in here is a reference to the real one that may
-	// exist either on a member or a type.  Not fixedUp means that we unpacked a generic
+	// exist either on a member or a type. Not fixedUp means that we unpacked a generic
 	// signature and weren't able to fix it up during resolution (didn't quite know enough
-	// at the right time).  Wonder if we can fix it up late?
+	// at the right time). Wonder if we can fix it up late?
 	boolean fixedUp = false;
-	
-	public TypeVariableReferenceType(
-			TypeVariable aTypeVariable,
-			World aWorld) {
-		super(
-				aTypeVariable.getGenericSignature(),
-				aTypeVariable.getErasureSignature(),
-			  aWorld);
+
+	public TypeVariableReferenceType(TypeVariable aTypeVariable, World aWorld) {
+		super(aTypeVariable.getGenericSignature(), aTypeVariable.getErasureSignature(), aWorld);
 		this.typeVariable = aTypeVariable;
-		this.isExtends    = false;
-		this.isSuper      = false;
+		this.isExtends = false;
+		this.isSuper = false;
 	}
-	
+
 	public ReferenceTypeDelegate getDelegate() {
-		if (delegate==null) 
-		  setDelegate(new ReferenceTypeReferenceTypeDelegate((ReferenceType)typeVariable.getFirstBound()));
+		if (delegate == null)
+			setDelegate(new ReferenceTypeReferenceTypeDelegate((ReferenceType) typeVariable.getFirstBound()));
 		return delegate;
 	}
 
 	public UnresolvedType getUpperBound() {
-		if (typeVariable==null) return super.getUpperBound();
+		if (typeVariable == null)
+			return super.getUpperBound();
 		return typeVariable.getUpperBound();
 	}
-	
+
+	public UnresolvedType getFirstBound() {
+		if (typeVariable == null)
+			return super.getUpperBound();
+		return typeVariable.getFirstBound();
+	}
+
 	public UnresolvedType getLowerBound() {
 		return typeVariable.getLowerBound();
 	}
-	
+
 	private void setAdditionalInterfaceBoundsFromTypeVar() {
 		if (typeVariable.getAdditionalInterfaceBounds() == null) {
 			return;
 		} else {
-			UnresolvedType [] ifBounds = typeVariable.getAdditionalInterfaceBounds();
+			UnresolvedType[] ifBounds = typeVariable.getAdditionalInterfaceBounds();
 			additionalInterfaceBounds = new ReferenceType[ifBounds.length];
 			for (int i = 0; i < ifBounds.length; i++) {
-				additionalInterfaceBounds[i] = (ReferenceType) ifBounds[i].resolve(getWorld()); 
+				additionalInterfaceBounds[i] = (ReferenceType) ifBounds[i].resolve(getWorld());
 			}
 		}
 	}
 
 	public UnresolvedType parameterize(Map typeBindings) {
 		UnresolvedType ut = (UnresolvedType) typeBindings.get(getName());
-		if (ut!=null) return world.resolve(ut);
+		if (ut != null)
+			return world.resolve(ut);
 		return this;
 	}
-	
+
 	public ReferenceType[] getAdditionalBounds() {
 		if (!resolvedIfBounds) {
 			setAdditionalInterfaceBoundsFromTypeVar();
@@ -81,66 +84,68 @@ public class TypeVariableReferenceType extends BoundedReferenceType implements T
 		}
 		return super.getAdditionalBounds();
 	}
-	
+
 	public TypeVariable getTypeVariable() {
 		// if (!fixedUp) throw new BCException("ARGH"); // fix it up now?
 		return typeVariable;
 	}
-	
+
 	public boolean isTypeVariableReference() {
 		return true;
 	}
-	
+
 	public String toString() {
 		return typeVariable.getName();
 	}
-	
+
 	public boolean isGenericWildcard() {
 		return false;
 	}
-	
-	//public ResolvedType resolve(World world) {
-	//	return super.resolve(world);
-	//}
-	
+
+	// public ResolvedType resolve(World world) {
+	// return super.resolve(world);
+	// }
+
 	public boolean isAnnotation() {
-		World world = ((ReferenceType)getUpperBound()).getWorld();
+		World world = ((ReferenceType) getUpperBound()).getWorld();
 		ResolvedType annotationType = ResolvedType.ANNOTATION.resolve(world);
-		if (getUpperBound() != null && ((ReferenceType)getUpperBound()).isAnnotation()) return true;
+		if (getUpperBound() != null && ((ReferenceType) getUpperBound()).isAnnotation())
+			return true;
 		ReferenceType[] ifBounds = getAdditionalBounds();
 		for (int i = 0; i < ifBounds.length; i++) {
-			if (ifBounds[i].isAnnotation()) return true;
-			if (ifBounds[i] == annotationType) return true; // annotation itself does not have the annotation flag set in Java!
+			if (ifBounds[i].isAnnotation())
+				return true;
+			if (ifBounds[i] == annotationType)
+				return true; // annotation itself does not have the annotation flag set in Java!
 		}
 		return false;
 	}
-	
+
 	/**
-     * return the signature for a *REFERENCE* to a type variable, which is simply:
-     *   Tname;
-     * there is no bounds info included, that is in the signature of the type variable itself
-     */
+	 * return the signature for a *REFERENCE* to a type variable, which is simply: Tname; there is no bounds info included, that is
+	 * in the signature of the type variable itself
+	 */
 	public String getSignature() {
-	  StringBuffer sb = new StringBuffer();
-	  sb.append("T");
-	  sb.append(typeVariable.getName());
-	  sb.append(";");
-	  return sb.toString();
+		StringBuffer sb = new StringBuffer();
+		sb.append("T");
+		sb.append(typeVariable.getName());
+		sb.append(";");
+		return sb.toString();
 	}
-	
+
 	public void write(DataOutputStream s) throws IOException {
 		super.write(s);
-//		TypeVariableDeclaringElement tvde = typeVariable.getDeclaringElement();
-//		if (tvde == null) {
-//			s.writeInt(TypeVariable.UNKNOWN);
-//		} else {			
-//			s.writeInt(typeVariable.getDeclaringElementKind());
-//			if (typeVariable.getDeclaringElementKind() == TypeVariable.TYPE) {
-//				((UnresolvedType)tvde).write(s);
-//			} else if (typeVariable.getDeclaringElementKind() == TypeVariable.METHOD){
-//				// it's a method
-//				((ResolvedMember)tvde).write(s);
-//			}
-//		}
+		// TypeVariableDeclaringElement tvde = typeVariable.getDeclaringElement();
+		// if (tvde == null) {
+		// s.writeInt(TypeVariable.UNKNOWN);
+		// } else {
+		// s.writeInt(typeVariable.getDeclaringElementKind());
+		// if (typeVariable.getDeclaringElementKind() == TypeVariable.TYPE) {
+		// ((UnresolvedType)tvde).write(s);
+		// } else if (typeVariable.getDeclaringElementKind() == TypeVariable.METHOD){
+		// // it's a method
+		// ((ResolvedMember)tvde).write(s);
+		// }
+		// }
 	}
 }
@@ -975,7 +975,7 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 			UnresolvedType thisParameter = myParameterTypes[i];
 			if (thisParameter.isTypeVariableReference()) {
 				TypeVariableReferenceType typeVariableRT = (TypeVariableReferenceType) thisParameter;
-				sig.append(typeVariableRT.getUpperBound().getSignature());
+				sig.append(typeVariableRT.getFirstBound().getSignature());
 			} else {
 				sig.append(thisParameter.getErasureSignature());
 			}
@@ -0,0 +1 @@
+public aspect Aspect pertypewithin(*){}
@@ -0,0 +1,4 @@
+public interface GenericService<T extends SomeInterface> {
+       public void doStuff(T t);
+}
+
@@ -0,0 +1,5 @@
+public class GenericServiceImpl<T extends SomeInterface> implements
+GenericService<T> {
+       public void doStuff(T t) {}
+}
+
@@ -0,0 +1,6 @@
+public class Main {
+       public static void main(String[] args) {
+               new SomeServiceImpl();
+       }
+}
+
@@ -0,0 +1,2 @@
+public interface SomeInterface {}
+
@@ -0,0 +1,6 @@
+public class SomeServiceImpl extends GenericServiceImpl<SomeInterface> {
+       @Override
+       public void doStuff(SomeInterface someInterface) {
+       }
+}
+
@@ -31,6 +31,14 @@ public class Ajc163Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	// runTest("itd anonymous inner class in wrong package");
 	// }
 
+	public void testOrderingRepetitive_pr259279() {
+		runTest("ordering repetitive method");
+	}
+
+	public void testOrderingRepetitive_pr259279_2() {
+		runTest("ordering repetitive method - 2");
+	}
+
 	public void testExtendingASI_pr252722() {
 		runTest("extending AbstractSecurityInterceptor");
 	}
@@ -2,6 +2,17 @@
 
 <suite>
 
+    
+    <ajc-test dir="bugs163/pr259279" title="ordering repetitive method">
+   	  <compile files="SomeServiceImpl.java SomeInterface.java Main.java GenericService.java GenericServiceImpl.java Aspect.java" options="-1.5"/>
+   	  <run class="Main"/>
+    </ajc-test>
+    
+    <ajc-test dir="bugs163/pr259279" title="ordering repetitive method - 2">
+   	  <compile files="GenericServiceImpl.java SomeServiceImpl.java SomeInterface.java Main.java GenericService.java Aspect.java" options="-1.5"/>
+   	  <run class="Main"/>
+    </ajc-test>
+    
     <ajc-test dir="bugs163/pr258653" title="getNode">
    	  <compile files="staticinit.java" options="-1.5 -emacssym"/>
     </ajc-test>
