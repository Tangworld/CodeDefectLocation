@@ -0,0 +1,28 @@
+package test;
+
+public class Base {
+	private int id;
+	private String value;
+
+	public Base(int id, String value) {
+		super();
+		this.id = id;
+		this.value = value;
+	}
+
+	public int getId() {
+		return id;
+	}
+
+	public void setId(int id) {
+		this.id = id;
+	}
+
+	public String getValue() {
+		return value;
+	}
+
+	public void setValue(String value) {
+		this.value = value;
+	}
+}
@@ -0,0 +1,5 @@
+package test;
+
+public class Error {
+asdf
+}
@@ -0,0 +1,33 @@
+package test;
+
+public class Sub extends Base {
+	private int numValue;
+
+	private String description;
+
+	public Sub(int id, String value, String description, int numValue) {
+		super(id, value);
+		this.description = description;
+		this.numValue = numValue;
+	}
+	
+	public int getNumValue() {
+		return numValue;
+	}
+
+	public void setNumValue(int numValue) {
+		this.numValue = numValue;
+	}
+
+	public String getDescription() {
+		return description;
+	}
+
+	public void setDescription(String description) {
+		this.description = description;
+	}
+	
+	public void other() {
+//		blah;
+	}
+}
@@ -0,0 +1,10 @@
+package test;
+
+public class TestIt {
+	public static void main(String[] args) {
+		Sub s = new Sub(3, "testValue", "Desc", 17);
+		s.setValue("another value");
+		s.setDescription("blue");
+		System.out.println("done.");
+	}
+}
@@ -0,0 +1,12 @@
+package test.aj;
+
+import test.Base;
+
+
+public aspect ModelAspect {
+	  pointcut setter(Base o, Object v): set(* Base+.*) && target(o) && args(v);
+
+	  void around(Base o, Object v) : setter(o, v) {
+		  System.out.println(o + ": " +thisJoinPoint.getSignature().getName()+", "+v);
+	  }
+}
@@ -0,0 +1,5 @@
+package test;
+
+public class Error {
+asdf
+}
@@ -0,0 +1,13 @@
+package test.aj;
+
+import test.Base;
+
+
+public aspect ModelAspect {
+	  pointcut setter(Base o, Object v): set(* Base+.*) && target(o) && args(v);
+
+	  void around(Base o, Object v) : setter(o, v) {
+System.out.println("Advice changed");
+		  System.out.println(o + ": " +thisJoinPoint.getSignature().getName()+", "+v);
+	  }
+}
@@ -66,14 +66,14 @@
     </ajc-test>
 
 	<ajc-test dir="bugs161/pr102733" title="running broken code">
-    	<compile files="Invoker.java C.java" options="">
+    	<compile files="Invoker.java C.java" options="-proceedOnError">
     	  <message kind="error" line="2" text="Syntax error"/>
     	</compile>
     	<run class="Invoker"/>
     </ajc-test>
 
 	<ajc-test dir="bugs161/pr102733" title="running broken code - 2">
-    	<compile files="Invoker2.java C2.java" options="">
+    	<compile files="Invoker2.java C2.java" options="-proceedOnError">
     	  <message kind="error" line="5"/>
     	</compile>
     	<run class="Invoker2"/>
@@ -251,9 +251,48 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		build("P2");
 		checkWasntFullBuild();
 	}
+
+	public void testBuildingBrokenCode_pr240360() {
+		AjdeInteractionTestbed.VERBOSE=true;
+		initialiseProject("pr240360");
+		//configureNonStandardCompileOptions("pr240360","-proceedOnError");
+		build("pr240360");
+		checkWasFullBuild();
+		checkCompileWeaveCount("pr240360",5,4);
+		assertTrue("There should be an error:\n"
+				+getErrorMessages("pr240360"),!getErrorMessages("pr240360").isEmpty());	
+
+		Set s = AsmManager.getDefault().getRelationshipMap().getEntries();
+		int relmapLength = s.size();
+
+		// Delete the erroneous type
+		String f = getWorkingDir().getAbsolutePath() + File.separatorChar + "pr240360" + File.separatorChar + "src" + File.separatorChar + "test" + File.separatorChar + "Error.java";
+		(new File(f)).delete();
+		build("pr240360");
+		checkWasntFullBuild();
+		checkCompileWeaveCount("pr240360",0,0);		
+		assertEquals(relmapLength,AsmManager.getDefault().getRelationshipMap().getEntries().size());
+		
+		// Readd the erroneous type
+		alter("pr240360","inc1");
+		build("pr240360");
+		checkWasntFullBuild();
+		checkCompileWeaveCount("pr240360",1,0);
+		assertEquals(relmapLength,AsmManager.getDefault().getRelationshipMap().getEntries().size());
+
+		// Change the advice
+		alter("pr240360","inc2");
+		build("pr240360");
+		checkWasFullBuild();
+		checkCompileWeaveCount("pr240360",6,4);
+		assertEquals(relmapLength,AsmManager.getDefault().getRelationshipMap().getEntries().size());
+	
+	}
+	
 
 	public void testBrokenCodeCompilation() {
 		initialiseProject("pr102733_1");
+//		configureNonStandardCompileOptions("pr102733_1","-proceedOnError");
 		build("pr102733_1");
 		checkWasFullBuild();
 		checkCompileWeaveCount("pr102733_1",1,0);
@@ -632,7 +671,7 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 			initialiseProject("pr117209");
 			configureNonStandardCompileOptions("pr117209","-proceedOnError");
 			build("pr117209");
-			checkCompileWeaveCount("pr117209",6,6);
+			checkCompileWeaveCount("pr117209",6,5);
 		} finally {
 			//MyBuildOptionsAdapter.reset();
 		}
@@ -373,7 +373,7 @@ public class AjPipeliningCompilerAdapter extends AbstractCompilerAdapter {
 			intermediateResultsRequestor.acceptResult(intRes);
 		}
 
-		if (isXTerminateAfterCompilation || (reportedErrors && !proceedOnError)) {
+		if (unit.compilationResult.hasErrors() || (isXTerminateAfterCompilation || (reportedErrors && !proceedOnError))) {
 			acceptResult(unit.compilationResult);
 		} else {
 			queueForWeaving(intRes);
@@ -103,9 +103,6 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
     // If runtime version check fails, warn or fail? (unset?)
     static final boolean FAIL_IF_RUNTIME_NOT_FOUND = false;
 
-    // support for producing .class files containing errors and maintaining 'state' even when the
-    // project is broken (meaning all builds after the first are incremental)
-    public static boolean continueWhenErrors = true;
 
     private static final FileFilter binarySourceFilter = 
 		new FileFilter() {
@@ -268,7 +265,7 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
                 binarySourcesForTheNextCompile = state.getBinaryFilesToCompile(true);
                 performCompilation(buildConfig.getFiles());
                 state.clearBinarySourceFiles(); // we don't want these hanging around...
-                if (!continueWhenErrors && handler.hasErrors()) {
+                if (!proceedOnError() && handler.hasErrors()) {
                    	CompilationAndWeavingContext.leavingPhase(ct);
                   	if (AsmManager.isReporting())
     				    AsmManager.getDefault().reportModelInfo("After a batch build");
@@ -296,7 +293,7 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
                     // System.err.println("XXXX inc: " + files);
 
                     performCompilation(files);
-                    if ((!continueWhenErrors && handler.hasErrors()) || (progressListener!=null && progressListener.isCancelledRequested())) {
+                    if ((!proceedOnError() && handler.hasErrors()) || (progressListener!=null && progressListener.isCancelledRequested())) {
                         CompilationAndWeavingContext.leavingPhase(ct);
                         return false;
                     } 
@@ -1030,7 +1027,7 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 			public void acceptResult(CompilationResult unitResult) {
 				// end of compile, must now write the results to the output destination
 				// this is either a jar file or a file in a directory
-				if (!((unitResult.hasErrors() && !continueWhenErrors) && !proceedOnError())) {			
+				if (!unitResult.hasErrors() || proceedOnError()) {			
 					Collection classFiles = unitResult.compiledTypes.values();
 					boolean shouldAddAspectName = (buildConfig.getOutxmlName() != null);
 					for (Iterator iter = classFiles.iterator(); iter.hasNext();) {
@@ -31,8 +31,8 @@ public class ProceedOnErrorTestCase extends CommandTestCase {
 	 * C2.java.
 	 */
 	public void testNoProceedOnError() throws IOException {
-		try {
-			AjBuildManager.continueWhenErrors=false;
+//		try {
+//			AjBuildManager.continueWhenErrors=false;
 			checkCompile("src1/C1.java", NO_ERRORS);
 		    File f =new File(getSandboxName(),"C.class");
 		    long oldmodtime = f.lastModified();
@@ -44,9 +44,9 @@ public class ProceedOnErrorTestCase extends CommandTestCase {
 		    assertTrue("The .class file should not have been modified as '-proceedOnError' was not supplied (old="+
 		    		   new Date(oldmodtime).toString()+")(new="+new Date(newmodtime).toString()+")",
 		    		   oldmodtime==newmodtime);
-		} finally {
-			AjBuildManager.continueWhenErrors=true;
-		}
+//		} finally {
+//			AjBuildManager.continueWhenErrors=true;
+//		}
 	}
 
 	public void testProceedOnError() throws IOException {
@@ -230,6 +230,8 @@ public class AjdeCoreBuildManager {
         config.setGenerateModelMode(true);      
         // always be in incremental mode in AJDE
         config.setIncrementalMode(true);
+        // always force proceedOnError in AJDE
+        config.setProceedOnError(true);
 		return config;
 	}
 
