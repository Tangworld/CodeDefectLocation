@@ -57,9 +57,9 @@ import org.aspectj.weaver.patterns.PerSingleton;
 /**
  * Generates bytecode for concrete-aspect.
  * <p>
- * The concrete aspect is @AspectJ code generated. As it is build during aop.xml definitions registration we perform the type
- * munging for perclause, ie. aspectOf() artifact directly, instead of waiting for it to go thru the weaver (that we are in the
- * middle of configuring).
+ * The concrete aspect is generated annotation style aspect (so traditional Java constructs annotated with our AspectJ annotations).
+ * As it is built during aop.xml definitions registration we perform the type munging for perclause, ie. aspectOf() artifact
+ * directly, instead of waiting for it to go thru the weaver (that we are in the middle of configuring).
  * 
  * @author Alexandre Vasseur
  * @author Andy Clement
@@ -100,10 +100,10 @@ public class ConcreteAspectCodeGen {
 	private byte[] bytes;
 
 	/**
-	 * Create a new compiler for a concrete aspect
+	 * Create a new generator for a concrete aspect
 	 * 
-	 * @param concreteAspect
-	 * @param world
+	 * @param concreteAspect the aspect definition
+	 * @param world the related world (for type resolution, etc)
 	 */
 	ConcreteAspectCodeGen(Definition.ConcreteAspect concreteAspect, World world) {
 		this.concreteAspect = concreteAspect;
@@ -111,7 +111,7 @@ public class ConcreteAspectCodeGen {
 	}
 
 	/**
-	 * Checks that concrete aspect is valid
+	 * Checks that concrete aspect is valid.
 	 * 
 	 * @return true if ok, false otherwise
 	 */
@@ -208,8 +208,6 @@ public class ConcreteAspectCodeGen {
 		List<String> elligibleAbstractions = new ArrayList<String>();
 
 		Collection<ResolvedMember> abstractMethods = getOutstandingAbstractMethods(parent);
-		// for (Iterator iter = abstractMethods.iterator(); iter.hasNext();) {
-		// ResolvedMember method = (ResolvedMember) iter.next();
 		for (ResolvedMember method : abstractMethods) {
 			if ("()V".equals(method.getSignature())) {
 				String n = method.getName();
@@ -229,8 +227,7 @@ public class ConcreteAspectCodeGen {
 				}
 			} else {
 				if (method.getName().startsWith("ajc$pointcut") || hasPointcutAnnotation(method)) {
-					// it may be a pointcut but it doesn't meet the requirements
-					// for XML concretization
+					// it may be a pointcut but it doesn't meet the requirements for XML concretization
 					reportError("Abstract method '"
 							+ method.toString()
 							+ "' cannot be concretized as a pointcut (illegal signature, must have no arguments, must return void): "
@@ -320,6 +317,7 @@ public class ConcreteAspectCodeGen {
 		sb.append("' perclause='");
 		sb.append(concreteAspect.perclause);
 		sb.append("'/> in aop.xml");
+		// TODO needs the extra state from the definition (concretized pointcuts and advice definitions)
 		return sb.toString();
 	}
 
@@ -376,7 +374,6 @@ public class ConcreteAspectCodeGen {
 			}
 		}
 
-		// TODO AV - abstract away from BCEL...
 		// @Aspect //inherit clause from m_parent
 		// @DeclarePrecedence("....") // if any
 		// public class xxxName [extends xxxExtends] {
@@ -392,8 +389,7 @@ public class ConcreteAspectCodeGen {
 			}
 		}
 		// @Aspect public class ...
-		// TODO AV - we could point to the aop.xml that defines it and use
-		// JSR-45
+		// TODO AV - we could point to the aop.xml that defines it and use JSR-45
 		LazyClassGen cg = new LazyClassGen(concreteAspect.name.replace('.', '/'), parentName, null, Modifier.PUBLIC
 				+ Constants.ACC_SUPER, EMPTY_STRINGS, world);
 		if (parent != null && parent.isParameterizedType()) {
@@ -447,13 +443,11 @@ public class ConcreteAspectCodeGen {
 			cg.addMethodGen(mg);
 		}
 
+		// Construct any defined declare error/warnings
 		if (concreteAspect.deows.size() > 0) {
-
 			int counter = 1;
 			for (Definition.DeclareErrorOrWarning deow : concreteAspect.deows) {
-
 				// Building this:
-
 				// @DeclareWarning("call(* javax.sql..*(..)) && !within(org.xyz.daos..*)")
 				// static final String aMessage = "Only DAOs should be calling JDBC.";
 
@@ -467,7 +461,6 @@ public class ConcreteAspectCodeGen {
 
 				field.setValue(deow.message);
 				cg.addField(field, null);
-
 			}
 		}
 
@@ -36,6 +36,69 @@ public class Ajc1612Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	// runTest("itd split compilation");
 	// }
 
+	public void testXmlDefs() {
+		runTest("xml defined advice");
+	}
+
+	public void testXmlDefs2() {
+		runTest("xml defined advice 2");
+	}
+
+	// using a parameter
+	public void testXmlDefs3() {
+		runTest("xml defined advice 3");
+	}
+
+	// using bad parameters
+	public void testXmlDefs4() {
+		runTest("xml defined advice 4");
+	}
+
+	// binding
+	public void testXmlDefs5() {
+		runTest("xml defined advice 5");
+	}
+
+	// before and after advice
+	public void testXmlDefs6() {
+		runTest("xml defined advice 6");
+	}
+
+	// thisJoinPoint
+	public void testXmlDefs7() {
+		runTest("xml defined advice 7");
+	}
+
+	// thisJoinPointStaticPart
+	public void testXmlDefs8() {
+		runTest("xml defined advice 8");
+	}
+
+	// void around advice
+	public void testXmlDefs9() {
+		runTest("xml defined advice 9");
+	}
+
+	// non-void around advice
+	public void testXmlDefs10() {
+		runTest("xml defined advice 10");
+	}
+
+	// non-void around advice with proceed
+	public void testXmlDefs11() {
+		runTest("xml defined advice 11");
+	}
+
+	// non primitive return (that is actually used) and proceed
+	public void testXmlDefs12() {
+		runTest("xml defined advice 12");
+	}
+
+	// delegate type in package
+	public void testXmlDefs13() {
+		runTest("xml defined advice 13");
+	}
+
 	public void testCorrespondingType_357582() {
 		for (int i = 0; i < 100000; i++) {
 			assertEquals("AAA", convert("AAA"));
@@ -2,6 +2,173 @@
 
 <suite>
 
+ <ajc-test dir="bugs1612/xmldefs" title="xml defined advice">
+     <compile files="Hello.java JavaHelper.java"/>
+     <run class="Hello" ltw="aop.xml">
+       <stdout>
+           <line text="Hello"/>
+           <line text="in advice"/>
+           <line text="World"/>
+       </stdout>
+     </run>
+   </ajc-test>
+   
+ <ajc-test dir="bugs1612/xmldefs" title="xml defined advice 2">
+     <compile files="Hello.java JavaHelper.java"/>
+     <run class="Hello" ltw="aop2.xml">
+       <stdout>
+           <line text="Hello"/>
+           <line text="World"/>
+       </stdout>
+       <stderr>
+       <line text="info AspectJ Weaver"/>
+       <line text="info register classloader"/>
+       <line text="info using config"/>
+       <line text="info define aspect"/>
+       <line text="error Class to invoke cannot be found: 'com.DoesNotExist'"/>
+       <line text="info weaver operating"/>
+       </stderr>
+     </run>
+   </ajc-test>
+   
+ <ajc-test dir="bugs1612/xmldefs" title="xml defined advice 3">
+     <compile files="Hello.java JavaHelper.java"/>
+     <run class="Hello" ltw="aop3.xml">
+       <stdout>
+           <line text="Hello"/>
+           <line text="World"/>
+       </stdout>
+       <stderr>
+       <line text="info AspectJ Weaver"/>
+       <line text="info register classloader"/>
+       <line text="info using config"/>
+       <line text="info define aspect"/>
+       <line text="error Cannot find type specified as parameter: 'String' from signature '(String)'"/>
+       <line text="info weaver operating"/>
+       </stderr>
+     </run>
+   </ajc-test>
+   
+ <ajc-test dir="bugs1612/xmldefs" title="xml defined advice 4">
+     <compile files="Hello.java JavaHelper.java"/>
+     <run class="Hello" ltw="aop4.xml">
+       <stdout>
+           <line text="Hello"/>
+           <line text="World"/>
+       </stdout>
+       <stderr>
+       <line text="info AspectJ Weaver"/>
+       <line text="info register classloader"/>
+       <line text="info using config"/>
+       <line text="info define aspect"/>
+       <line text="error Cannot find type specified as parameter: 'java.lang.String:List' from signature '(java.lang.String:List)'"/>
+       <line text="info weaver operating"/>
+       </stderr>
+     </run>
+   </ajc-test>
+   
+   
+ <ajc-test dir="bugs1612/xmldefs" title="xml defined advice 5">
+     <compile files="Hello2.java JavaHelper.java"/>
+     <run class="Hello2" ltw="aop5.xml">
+       <stdout>
+           <line text="hello"/>
+           <line text="in advice: s=world"/>
+           <line text="world"/>
+       </stdout>
+     </run>
+   </ajc-test>
+   
+   
+ <ajc-test dir="bugs1612/xmldefs" title="xml defined advice 6">
+     <compile files="Hello2.java JavaHelper.java"/>
+     <run class="Hello2" ltw="aop6.xml">
+       <stdout>
+           <line text="hello"/>
+           <line text="in advice: s=world"/>
+           <line text="world"/>
+           <line text="in advice3: s=world"/>
+       </stdout>
+     </run>
+   </ajc-test>
+   
+ <ajc-test dir="bugs1612/xmldefs" title="xml defined advice 7">
+     <compile files="Hello2.java JavaHelper.java"/>
+     <run class="Hello2" ltw="aop7.xml">
+       <stdout>
+           <line text="hello"/>
+           <line text="in advice4: s=world at execution(int Hello2.say2(String))"/>
+           <line text="world"/>
+           <line text="in advice5: s=world at execution(int Hello2.say2(String))"/>
+       </stdout>
+     </run>
+   </ajc-test>
+
+ <ajc-test dir="bugs1612/xmldefs" title="xml defined advice 8">
+     <compile files="Hello2.java JavaHelper.java"/>
+     <run class="Hello2" ltw="aop8.xml">
+       <stdout>
+           <line text="hello"/>
+           <line text="in advice6: s=world at execution(int Hello2.say2(String))"/>
+           <line text="world"/>
+           <line text="in advice7: s=world at execution(int Hello2.say2(String))"/>
+       </stdout>
+     </run>
+   </ajc-test>
+   
+ <ajc-test dir="bugs1612/xmldefs" title="xml defined advice 9">
+     <compile files="Hello2.java JavaHelper.java"/>
+     <run class="Hello2" ltw="aop9.xml">
+       <stdout>
+           <line text="in around advice: s=hello at execution(void Hello2.say1(String))"/>
+       </stdout>
+     </run>
+   </ajc-test>
+   
+ <ajc-test dir="bugs1612/xmldefs" title="xml defined advice 10">
+     <compile files="Hello2.java JavaHelper.java"/>
+     <run class="Hello2" ltw="aop10.xml">
+       <stdout>
+           <line text="hello"/>
+           <line text="in around2 advice: s=world at execution(int Hello2.say2(String))"/>
+       </stdout>
+     </run>
+   </ajc-test>
+   
+ <ajc-test dir="bugs1612/xmldefs" title="xml defined advice 11">
+     <compile files="Hello2.java JavaHelper.java"/>
+     <run class="Hello2" ltw="aop11.xml">
+       <stdout>
+           <line text="hello"/>
+           <line text="abcde"/>
+       </stdout>
+     </run>
+   </ajc-test>
+   
+ <ajc-test dir="bugs1612/xmldefs" title="xml defined advice 12">
+     <compile files="Hello3.java JavaHelper.java"/>
+     <run class="Hello3" ltw="aop12.xml">
+       <stdout>
+           <line text="hello"/>
+           <line text="around4 running"/>
+           <line text="abcde"/>
+           <line text="from say2=xyz"/>
+       </stdout>
+     </run>
+   </ajc-test>
+   
+ <ajc-test dir="bugs1612/xmldefs" title="xml defined advice 13">
+     <compile files="Hello2.java JavaHelper2.java"/>
+     <run class="Hello2" ltw="aop13.xml">
+       <stdout>
+           <line text="in advice"/>
+           <line text="hello"/>
+           <line text="in advice"/>
+           <line text="world"/>
+       </stdout>
+     </run>
+   </ajc-test>
+
 <ajc-test dir="bugs1612/pr354470" title="perthis too pervasive">
 <compile files="Code.java" options="-1.5"/>
 <run class="Code">
@@ -51,8 +51,8 @@
 	  	    	<line text="warning aspect ExcludedAspect exluded"/>
 	  	    	<line text="warning aspect ExcludedAspect exluded"/>
 	  	    	<line text="info define aspect IncludedMissingAspect"/>
-	  	    	<line text="error Cannot find m_parent aspect"/>
-	  	    	<line text="error Cannot find m_parent aspect"/>
+	  	    	<line text="error Cannot find parent aspect"/>
+	  	    	<line text="error Cannot find parent aspect"/>
 	  	    	<line text="error Concrete-aspect 'IncludedMissingAspect' could not be registered"/>
 	  	    	<line text="error Concrete-aspect 'IncludedMissingAspect' could not be registered"/>
 	  	    	<line text="warning failure(s) registering aspects. Disabling weaver for class loader"/>
@@ -0,0 +1,16 @@
+import org.aspectj.lang.annotation.*;
+
+ abstract aspect X {
+  void around(): execution(* foo(..)) {}
+}
+
+
+@Aspect class B extends X { }
+
+public class A {
+  public void foo() { } 
+
+public static void main(String []argv) {
+   new A().foo();
+}
+}
@@ -0,0 +1,11 @@
+import org.aspectj.lang.annotation.*;
+import org.aspectj.lang.*;
+
+@Aspect 
+public class C {
+  @Around("execution(* say2(..)) && args(w)") 
+  public int m(ProceedingJoinPoint pjp,String w) {
+    pjp.proceed(new Object[]{"abc"});
+    return 1;
+  }
+}
@@ -0,0 +1,5 @@
+public aspect ConcreteWorld extends World {
+    pointcut greeting() :
+    	execution(* Hello.sayWorld(..))
+    	|| execution(* Hello.sayHello(..));
+}
@@ -0,0 +1,16 @@
+public class Hello {
+
+        public static void main(String[] args) {
+                sayHello();
+        } 
+
+        public static void sayHello() {
+                System.out.println("Hello");
+                sayWorld();
+        } 
+
+        public static int sayWorld() {
+                System.out.println("World");
+                return 0;
+        }
+}
@@ -0,0 +1,16 @@
+public class Hello2 {
+
+        public static void main(String[] args) {
+                say1("hello");
+        } 
+
+        public static void say1(String h) {
+                System.out.println(h);
+                say2("world");
+        } 
+
+        public static int say2(String w) {
+                System.out.println(w);
+                return 0;
+        }
+}
Binary files differ
@@ -0,0 +1,17 @@
+public class Hello3 {
+
+        public static void main(String[] args) {
+                say1("hello");
+        } 
+
+        public static void say1(String h) {
+                System.out.println(h);
+                String s = say2("world");
+		System.out.println("from say2="+s);
+        } 
+
+        public static String say2(String w) {
+                System.out.println(w);
+                return "";
+        }
+}
@@ -0,0 +1,40 @@
+public class JavaHelper {
+  public static void advice1() {
+    System.out.println("in advice");
+  }
+  public static void advice2(String s) {
+    System.out.println("in advice: s="+s);
+  }
+  public static void advice3(String s) {
+    System.out.println("in advice3: s="+s);
+  }
+  public static void advice4(org.aspectj.lang.JoinPoint tjp, String s) {
+    System.out.println("in advice4: s="+s+" at "+tjp);
+  }
+  public static void advice5(org.aspectj.lang.JoinPoint tjp, String s) {
+    System.out.println("in advice5: s="+s+" at "+tjp);
+  }
+  public static void advice6(org.aspectj.lang.JoinPoint.StaticPart tjp, String s) {
+    System.out.println("in advice6: s="+s+" at "+tjp);
+  }
+  public static void advice7(org.aspectj.lang.JoinPoint.StaticPart tjp, String s) {
+    System.out.println("in advice7: s="+s+" at "+tjp);
+  }
+  public static void around1(org.aspectj.lang.JoinPoint.StaticPart tjp, String s) {
+    System.out.println("in around advice: s="+s+" at "+tjp);
+  }
+  public static int around2(org.aspectj.lang.JoinPoint.StaticPart tjp, String s) {
+    System.out.println("in around2 advice: s="+s+" at "+tjp);
+    return 99;
+  }
+  public static int around3(org.aspectj.lang.ProceedingJoinPoint pjp, String s) {
+    pjp.proceed(new Object[]{"abcde"});
+    return 42;
+  }
+  public static String around4(org.aspectj.lang.ProceedingJoinPoint pjp, String s) {
+    System.out.println("around4 running");
+    pjp.proceed(new Object[]{"abcde"});
+    return "xyz";
+  }
+}
+
@@ -0,0 +1,8 @@
+package a.bb.ccc;
+
+public class JavaHelper2 {
+  public static void advice1() {
+    System.out.println("in advice");
+  }
+}
+
@@ -0,0 +1,24 @@
+import org.aspectj.lang.Signature;
+import org.aspectj.lang.JoinPoint;
+public abstract aspect World { 
+    //private Object result;
+        pointcut greeting() : execution(* Hello.sayWorld(..)); 
+
+        Object around(): greeting() {
+        System.out.println("around start!");
+        Object result = proceed();
+        System.out.println("around end!");
+        return result;
+        }
+
+//    before() : greeting() { 
+//      Signature signature = thisJoinPoint.getSignature();
+//        System.out.println("before " + signature.getName()); 
+//    } 
+
+//    after() returning () : greeting() { 
+//      Signature signature = thisJoinPoint.getSignature();
+//        System.out.println("after " + signature.getName()); 
+//    } 
+
+} 
@@ -0,0 +1,10 @@
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.annotation.Pointcut;
+
+@Aspect
+public abstract class WorldAt {
+
+	@Pointcut("execution(* Hello.sayWorld(..))")
+    void greeting() {}
+
+}
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<aspectj>
+  <aspects>
+    <concrete-aspect name="ConjuredUp">
+      <before pointcut="execution(* Hello.sayWorld(..))" invokeClass="JavaHelper" invokeMethod="advice1()"/>
+    </concrete-aspect>
+  </aspects>
+
+  <weaver options="-Xreweavable -verbose -XlazyTjp -showWeaveInfo">
+    <include within="Hello"/>
+  </weaver>
+</aspectj>
+
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<aspectj>
+  <aspects>
+    <concrete-aspect name="ConjuredUp">
+      <around pointcut="execution(* Hello2.say2(..)) AND args(w) " invokeClass="JavaHelper" invokeMethod="around2(JoinPoint.StaticPart pjp, java.lang.String w)"/>
+    </concrete-aspect>
+  </aspects>
+
+  <weaver options="-Xreweavable -verbose -XlazyTjp -showWeaveInfo">
+    <include within="Hello2"/>
+    <dump within="*"/>
+  </weaver>
+</aspectj>
+
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<aspectj>
+  <aspects>
+    <concrete-aspect name="ConjuredUp">
+      <around pointcut="execution(* Hello2.say2(..)) AND args(w) " invokeClass="JavaHelper" invokeMethod="around3(ProceedingJoinPoint pjp, java.lang.String w)"/>
+    </concrete-aspect>
+  </aspects>
+
+  <weaver options="-Xreweavable -verbose -XlazyTjp -showWeaveInfo">
+    <include within="Hello2"/>
+    <dump within="*"/>
+  </weaver>
+</aspectj>
+
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<aspectj>
+  <aspects>
+    <concrete-aspect name="ConjuredUp">
+      <around pointcut="execution(* Hello3.say2(..)) AND args(w) " invokeClass="JavaHelper" invokeMethod="around4(ProceedingJoinPoint pjp, java.lang.String w)"/>
+    </concrete-aspect>
+  </aspects>
+
+  <weaver options="-Xreweavable -verbose -XlazyTjp -showWeaveInfo">
+    <include within="Hello3"/>
+    <dump within="*"/>
+  </weaver>
+</aspectj>
+
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<aspectj>
+  <aspects>
+    <concrete-aspect name="ConjuredUp">
+      <before pointcut="execution(* Hello2.say*(..))" invokeClass="a.bb.ccc.JavaHelper2" invokeMethod="advice1()"/>
+    </concrete-aspect>
+  </aspects>
+
+  <weaver options="-Xreweavable -verbose -XlazyTjp -showWeaveInfo">
+    <include within="Hello2"/>
+  </weaver>
+</aspectj>
+
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<aspectj>
+  <aspects>
+    <concrete-aspect name="ConjuredUp">
+      <before pointcut="execution(* Hello.sayWorld(..))" invokeClass="com.DoesNotExist" invokeMethod="advice1()"/>
+    </concrete-aspect>
+  </aspects>
+
+  <weaver options="-Xreweavable -verbose -XlazyTjp -showWeaveInfo">
+    <include within="Hello"/>
+  </weaver>
+</aspectj>
+
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<aspectj>
+  <aspects>
+    <concrete-aspect name="ConjuredUp">
+      <before pointcut="execution(* Hello.sayWorld(..))" invokeClass="JavaHelper" invokeMethod="advice1(String)"/>
+    </concrete-aspect>
+  </aspects>
+
+  <weaver options="-Xreweavable -verbose -XlazyTjp -showWeaveInfo">
+    <include within="Hello"/>
+  </weaver>
+</aspectj>
+
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<aspectj>
+  <aspects>
+    <concrete-aspect name="ConjuredUp">
+      <before pointcut="execution(* Hello.sayWorld(..))" invokeClass="JavaHelper" invokeMethod="advice1(java.lang.String:List)"/>
+    </concrete-aspect>
+  </aspects>
+
+  <weaver options="-Xreweavable -verbose -XlazyTjp -showWeaveInfo">
+    <include within="Hello"/>
+  </weaver>
+</aspectj>
+
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<aspectj>
+  <aspects>
+    <concrete-aspect name="ConjuredUp">
+      <before pointcut="execution(* Hello2.say2(..)) AND args(w) " invokeClass="JavaHelper" invokeMethod="advice2(java.lang.String w)"/>
+    </concrete-aspect>
+  </aspects>
+
+  <weaver options="-Xreweavable -verbose -XlazyTjp -showWeaveInfo">
+    <include within="Hello2"/>
+    <dump within="*"/>
+  </weaver>
+</aspectj>
+
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<aspectj>
+  <aspects>
+    <concrete-aspect name="ConjuredUp">
+      <before pointcut="execution(* Hello2.say2(..)) AND args(w) " invokeClass="JavaHelper" invokeMethod="advice2(java.lang.String w)"/>
+      <after pointcut="execution(* Hello2.say2(..)) AND args(w) " invokeClass="JavaHelper" invokeMethod="advice3(java.lang.String w)"/>
+    </concrete-aspect>
+  </aspects>
+
+  <weaver options="-Xreweavable -verbose -XlazyTjp -showWeaveInfo">
+    <include within="Hello2"/>
+    <dump within="*"/>
+  </weaver>
+</aspectj>
+
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<aspectj>
+  <aspects>
+    <concrete-aspect name="ConjuredUp">
+      <before pointcut="execution(* Hello2.say2(..)) AND args(w) " invokeClass="JavaHelper" invokeMethod="advice4(JoinPoint tjp, java.lang.String w)"/>
+      <after pointcut="execution(* Hello2.say2(..)) AND args(w) " invokeClass="JavaHelper" invokeMethod="advice5(JoinPoint tjp, java.lang.String w)"/>
+    </concrete-aspect>
+  </aspects>
+
+  <weaver options="-Xreweavable -verbose -XlazyTjp -showWeaveInfo">
+    <include within="Hello2"/>
+    <dump within="*"/>
+  </weaver>
+</aspectj>
+
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<aspectj>
+  <aspects>
+    <concrete-aspect name="ConjuredUp">
+      <before pointcut="execution(* Hello2.say2(..)) AND args(w) " invokeClass="JavaHelper" invokeMethod="advice6(JoinPoint.StaticPart tjpsp, java.lang.String w)"/>
+      <after pointcut="execution(* Hello2.say2(..)) AND args(w) " invokeClass="JavaHelper" invokeMethod="advice7(JoinPoint.StaticPart tjpsp, java.lang.String w)"/>
+    </concrete-aspect>
+  </aspects>
+
+  <weaver options="-Xreweavable -verbose -XlazyTjp -showWeaveInfo">
+    <include within="Hello2"/>
+    <dump within="*"/>
+  </weaver>
+</aspectj>
+
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<aspectj>
+  <aspects>
+    <concrete-aspect name="ConjuredUp">
+      <around pointcut="execution(* Hello2.say1(..)) AND args(w) " invokeClass="JavaHelper" invokeMethod="around1(JoinPoint.StaticPart tjpsp, java.lang.String w)"/>
+    </concrete-aspect>
+  </aspects>
+
+  <weaver options="-Xreweavable -verbose -XlazyTjp -showWeaveInfo">
+    <include within="Hello2"/>
+    <dump within="*"/>
+  </weaver>
+</aspectj>
+
@@ -112,6 +112,7 @@ public class Definition {
 		public final String extend;
 		public final String precedence;
 		public final List<Definition.Pointcut> pointcuts;
+		public final List<Definition.PointcutAndAdvice> pointcutsAndAdvice;
 		public final String perclause;
 		public List<Definition.DeclareErrorOrWarning> deows;
 
@@ -125,13 +126,16 @@ public class Definition {
 			if (extend == null || extend.length() == 0) {
 				this.extend = null;
 				if (precedence == null || precedence.length() == 0) {
-					throw new RuntimeException("Not allowed");
+					// if (pointcutsAndAdvice.size() == 0) {
+					// throw new RuntimeException("Not allowed");
+					// }
 				}
 			} else {
 				this.extend = extend;
 			}
 			this.precedence = precedence;
 			this.pointcuts = new ArrayList<Definition.Pointcut>();
+			this.pointcutsAndAdvice = new ArrayList<Definition.PointcutAndAdvice>();
 			this.deows = new ArrayList<Definition.DeclareErrorOrWarning>();
 			this.perclause = perclause;
 		}
@@ -147,6 +151,24 @@ public class Definition {
 		}
 	}
 
+	public enum AdviceKind {
+		Before, After, AfterReturning, AfterThrowing, Around;
+	}
+
+	public static class PointcutAndAdvice {
+		public final AdviceKind adviceKind;
+		public final String pointcut;
+		public final String adviceClass; // com.foo.Bar
+		public final String adviceMethod; // foo(java.lang.String,org.aspectj.lang.JoinPoint)
+
+		public PointcutAndAdvice(AdviceKind adviceKind, String pointcut, String adviceClass, String adviceMethod) {
+			this.adviceKind = adviceKind;
+			this.pointcut = pointcut;
+			this.adviceClass = adviceClass;
+			this.adviceMethod = adviceMethod;
+		}
+	}
+
 	public static class DeclareErrorOrWarning {
 		public final boolean isError;
 		public final String pointcut;
@@ -21,6 +21,7 @@ import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.parsers.SAXParserFactory;
 
 import org.aspectj.util.LangUtil;
+import org.aspectj.weaver.loadtime.definition.Definition.AdviceKind;
 import org.xml.sax.Attributes;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
@@ -30,7 +31,6 @@ import org.xml.sax.helpers.DefaultHandler;
 import org.xml.sax.helpers.XMLReaderFactory;
 
 /**
- * FIXME AV - doc, concrete aspect
  * 
  * @author Alexandre Vasseur
  * @author A. Nevado
@@ -65,16 +65,21 @@ public class DocumentParser extends DefaultHandler {
 	private final static String PRECEDENCE_ATTRIBUTE = "precedence";
 	private final static String PERCLAUSE_ATTRIBUTE = "perclause";
 	private final static String POINTCUT_ELEMENT = "pointcut";
+	private final static String BEFORE_ELEMENT = "before";
+	private final static String AFTER_ELEMENT = "after";
+	private final static String AFTER_RETURNING_ELEMENT = "after-returning";
+	private final static String AFTER_THROWING_ELEMENT = "after-throwing";
+	private final static String AROUND_ELEMENT = "around";
 	private final static String WITHIN_ATTRIBUTE = "within";
 	private final static String EXPRESSION_ATTRIBUTE = "expression";
 
-	private final Definition m_definition;
+	private final Definition definition;
 
-	private boolean m_inAspectJ;
-	private boolean m_inWeaver;
-	private boolean m_inAspects;
+	private boolean inAspectJ;
+	private boolean inWeaver;
+	private boolean inAspects;
 
-	private Definition.ConcreteAspect m_lastConcreteAspect;
+	private Definition.ConcreteAspect activeConcreteAspectDefinition;
 
 	private static Hashtable<String, Definition> parsedFiles = new Hashtable<String, Definition>();
 	private static final boolean CACHE;
@@ -100,7 +105,7 @@ public class DocumentParser extends DefaultHandler {
 	}
 
 	private DocumentParser() {
-		m_definition = new Definition();
+		definition = new Definition();
 	}
 
 	public static Definition parse(final URL url) throws Exception {
@@ -148,7 +153,7 @@ public class DocumentParser extends DefaultHandler {
 		xmlReader.setEntityResolver(parser);
 		InputStream in = url.openStream();
 		xmlReader.parse(new InputSource(in));
-		return parser.m_definition;
+		return parser.definition;
 	}
 
 	private static XMLReader getXMLReader() throws SAXException, ParserConfigurationException {
@@ -186,80 +191,110 @@ public class DocumentParser extends DefaultHandler {
 			String scopePattern = replaceXmlAnd(attributes.getValue(SCOPE_ATTRIBUTE));
 			String requiredType = attributes.getValue(REQUIRES_ATTRIBUTE);
 			if (!isNull(name)) {
-				m_definition.getAspectClassNames().add(name);
+				definition.getAspectClassNames().add(name);
 				if (scopePattern != null) {
-					m_definition.addScopedAspect(name, scopePattern);
+					definition.addScopedAspect(name, scopePattern);
 				}
 				if (requiredType != null) {
-					m_definition.setAspectRequires(name, requiredType);
+					definition.setAspectRequires(name, requiredType);
 				}
 			}
 		} else if (WEAVER_ELEMENT.equals(qName)) {
 			String options = attributes.getValue(OPTIONS_ATTRIBUTE);
 			if (!isNull(options)) {
-				m_definition.appendWeaverOptions(options);
+				definition.appendWeaverOptions(options);
 			}
-			m_inWeaver = true;
+			inWeaver = true;
 		} else if (CONCRETE_ASPECT_ELEMENT.equals(qName)) {
 			String name = attributes.getValue(NAME_ATTRIBUTE);
 			String extend = attributes.getValue(EXTEND_ATTRIBUTE);
 			String precedence = attributes.getValue(PRECEDENCE_ATTRIBUTE);
 			String perclause = attributes.getValue(PERCLAUSE_ATTRIBUTE);
 			if (!isNull(name)) {
-				m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend, precedence, perclause);
+				activeConcreteAspectDefinition = new Definition.ConcreteAspect(name, extend, precedence, perclause);
 				// if (isNull(precedence) && !isNull(extend)) {// if no precedence, then extends must be there
 				// m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend);
 				// } else if (!isNull(precedence)) {
 				// // wether a pure precedence def, or an extendsANDprecedence def.
 				// m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend, precedence, perclause);
 				// }
-				m_definition.getConcreteAspects().add(m_lastConcreteAspect);
+				definition.getConcreteAspects().add(activeConcreteAspectDefinition);
 			}
-		} else if (POINTCUT_ELEMENT.equals(qName) && m_lastConcreteAspect != null) {
+		} else if (POINTCUT_ELEMENT.equals(qName) && activeConcreteAspectDefinition != null) {
 			String name = attributes.getValue(NAME_ATTRIBUTE);
 			String expression = attributes.getValue(EXPRESSION_ATTRIBUTE);
 			if (!isNull(name) && !isNull(expression)) {
-				m_lastConcreteAspect.pointcuts.add(new Definition.Pointcut(name, replaceXmlAnd(expression)));
+				activeConcreteAspectDefinition.pointcuts.add(new Definition.Pointcut(name, replaceXmlAnd(expression)));
+			}
+		} else if (BEFORE_ELEMENT.equals(qName) && activeConcreteAspectDefinition != null) {
+			String pointcut = attributes.getValue(POINTCUT_ELEMENT);
+			String adviceClass = attributes.getValue("invokeClass");
+			String adviceMethod = attributes.getValue("invokeMethod");
+			if (!isNull(pointcut) && !isNull(adviceClass) && !isNull(adviceMethod)) {
+				activeConcreteAspectDefinition.pointcutsAndAdvice.add(new Definition.PointcutAndAdvice(AdviceKind.Before,
+						replaceXmlAnd(pointcut), adviceClass, adviceMethod));
+			} else {
+				throw new SAXException("Badly formed <before> element");
+			}
+		} else if (AFTER_ELEMENT.equals(qName) && activeConcreteAspectDefinition != null) {
+			String pointcut = attributes.getValue(POINTCUT_ELEMENT);
+			String adviceClass = attributes.getValue("invokeClass");
+			String adviceMethod = attributes.getValue("invokeMethod");
+			if (!isNull(pointcut) && !isNull(adviceClass) && !isNull(adviceMethod)) {
+				activeConcreteAspectDefinition.pointcutsAndAdvice.add(new Definition.PointcutAndAdvice(AdviceKind.After,
+						replaceXmlAnd(pointcut), adviceClass, adviceMethod));
+			} else {
+				throw new SAXException("Badly formed <after> element");
+			}
+		} else if (AROUND_ELEMENT.equals(qName) && activeConcreteAspectDefinition != null) {
+			String pointcut = attributes.getValue(POINTCUT_ELEMENT);
+			String adviceClass = attributes.getValue("invokeClass");
+			String adviceMethod = attributes.getValue("invokeMethod");
+			if (!isNull(pointcut) && !isNull(adviceClass) && !isNull(adviceMethod)) {
+				activeConcreteAspectDefinition.pointcutsAndAdvice.add(new Definition.PointcutAndAdvice(AdviceKind.Around,
+						replaceXmlAnd(pointcut), adviceClass, adviceMethod));
+			} else {
+				throw new SAXException("Badly formed <before> element");
 			}
 		} else if (ASPECTJ_ELEMENT.equals(qName)) {
-			if (m_inAspectJ) {
+			if (inAspectJ) {
 				throw new SAXException("Found nested <aspectj> element");
 			}
-			m_inAspectJ = true;
+			inAspectJ = true;
 		} else if (ASPECTS_ELEMENT.equals(qName)) {
-			m_inAspects = true;
-		} else if (INCLUDE_ELEMENT.equals(qName) && m_inWeaver) {
+			inAspects = true;
+		} else if (INCLUDE_ELEMENT.equals(qName) && inWeaver) {
 			String typePattern = getWithinAttribute(attributes);
 			if (!isNull(typePattern)) {
-				m_definition.getIncludePatterns().add(typePattern);
+				definition.getIncludePatterns().add(typePattern);
 			}
-		} else if (EXCLUDE_ELEMENT.equals(qName) && m_inWeaver) {
+		} else if (EXCLUDE_ELEMENT.equals(qName) && inWeaver) {
 			String typePattern = getWithinAttribute(attributes);
 			if (!isNull(typePattern)) {
-				m_definition.getExcludePatterns().add(typePattern);
+				definition.getExcludePatterns().add(typePattern);
 			}
-		} else if (DUMP_ELEMENT.equals(qName) && m_inWeaver) {
+		} else if (DUMP_ELEMENT.equals(qName) && inWeaver) {
 			String typePattern = getWithinAttribute(attributes);
 			if (!isNull(typePattern)) {
-				m_definition.getDumpPatterns().add(typePattern);
+				definition.getDumpPatterns().add(typePattern);
 			}
 			String beforeAndAfter = attributes.getValue(DUMP_BEFOREANDAFTER_ATTRIBUTE);
 			if (isTrue(beforeAndAfter)) {
-				m_definition.setDumpBefore(true);
+				definition.setDumpBefore(true);
 			}
 			String perWeaverDumpDir = attributes.getValue(DUMP_PERCLASSLOADERDIR_ATTRIBUTE);
 			if (isTrue(perWeaverDumpDir)) {
-				m_definition.setCreateDumpDirPerClassloader(true);
+				definition.setCreateDumpDirPerClassloader(true);
 			}
-		} else if (EXCLUDE_ELEMENT.equals(qName) && m_inAspects) {
+		} else if (EXCLUDE_ELEMENT.equals(qName) && inAspects) {
 			String typePattern = getWithinAttribute(attributes);
 			if (!isNull(typePattern)) {
-				m_definition.getAspectExcludePatterns().add(typePattern);
+				definition.getAspectExcludePatterns().add(typePattern);
 			}
-		} else if (INCLUDE_ELEMENT.equals(qName) && m_inAspects) {
+		} else if (INCLUDE_ELEMENT.equals(qName) && inAspects) {
 			String typePattern = getWithinAttribute(attributes);
 			if (!isNull(typePattern)) {
-				m_definition.getAspectIncludePatterns().add(typePattern);
+				definition.getAspectIncludePatterns().add(typePattern);
 			}
 		} else {
 			throw new SAXException("Unknown element while parsing <aspectj> element: " + qName);
@@ -273,13 +308,13 @@ public class DocumentParser extends DefaultHandler {
 
 	public void endElement(String uri, String localName, String qName) throws SAXException {
 		if (CONCRETE_ASPECT_ELEMENT.equals(qName)) {
-			m_lastConcreteAspect = null;
+			activeConcreteAspectDefinition = null;
 		} else if (ASPECTJ_ELEMENT.equals(qName)) {
-			m_inAspectJ = false;
+			inAspectJ = false;
 		} else if (WEAVER_ELEMENT.equals(qName)) {
-			m_inWeaver = false;
+			inWeaver = false;
 		} else if (ASPECTS_ELEMENT.equals(qName)) {
-			m_inAspects = false;
+			inAspects = false;
 		}
 		super.endElement(uri, localName, qName);
 	}
@@ -11,6 +11,7 @@
  *******************************************************************************/
 package org.aspectj.weaver.loadtime;
 
+import java.io.FileOutputStream;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -28,7 +29,10 @@ import org.aspectj.apache.bcel.classfile.annotation.NameValuePair;
 import org.aspectj.apache.bcel.classfile.annotation.SimpleElementValue;
 import org.aspectj.apache.bcel.generic.FieldGen;
 import org.aspectj.apache.bcel.generic.InstructionConstants;
+import org.aspectj.apache.bcel.generic.InstructionFactory;
+import org.aspectj.apache.bcel.generic.InstructionHandle;
 import org.aspectj.apache.bcel.generic.InstructionList;
+import org.aspectj.apache.bcel.generic.LocalVariableTag;
 import org.aspectj.apache.bcel.generic.ObjectType;
 import org.aspectj.apache.bcel.generic.Type;
 import org.aspectj.bridge.IMessage;
@@ -46,10 +50,11 @@ import org.aspectj.weaver.bcel.BcelWorld;
 import org.aspectj.weaver.bcel.LazyClassGen;
 import org.aspectj.weaver.bcel.LazyMethodGen;
 import org.aspectj.weaver.loadtime.definition.Definition;
+import org.aspectj.weaver.loadtime.definition.Definition.AdviceKind;
+import org.aspectj.weaver.loadtime.definition.Definition.PointcutAndAdvice;
 import org.aspectj.weaver.patterns.PerClause;
 import org.aspectj.weaver.patterns.PerSingleton;
 
-
 /**
  * Generates bytecode for concrete-aspect.
  * <p>
@@ -91,6 +96,11 @@ public class ConcreteAspectCodeGen {
 	private PerClause perclause;
 
 	/**
+	 * Bytecode for the generated class
+	 */
+	private byte[] bytes;
+
+	/**
 	 * Create a new compiler for a concrete aspect
 	 * 
 	 * @param concreteAspect
@@ -113,8 +123,7 @@ public class ConcreteAspectCodeGen {
 		}
 
 		// name must be undefined so far
-		// TODO only convert the name to signature once, probably earlier than
-		// this
+		// TODO only convert the name to signature once, probably earlier than this
 		ResolvedType current = world.lookupBySignature(UnresolvedType.forName(concreteAspect.name).getSignature());
 
 		if (current != null && !current.isMissing()) {
@@ -122,6 +131,11 @@ public class ConcreteAspectCodeGen {
 			return false;
 		}
 
+		if (concreteAspect.pointcutsAndAdvice.size() != 0) {
+			isValid = true;
+			return true;
+		}
+
 		// it can happen that extends is null, for precedence only declaration
 		if (concreteAspect.extend == null && concreteAspect.precedence != null) {
 			if (concreteAspect.pointcuts.isEmpty()) {
@@ -136,6 +150,7 @@ public class ConcreteAspectCodeGen {
 		}
 
 		String parentAspectName = concreteAspect.extend;
+
 		if (parentAspectName.indexOf("<") != -1) {
 			// yikes, generic parent
 			parent = world.resolve(UnresolvedType.forName(parentAspectName), true);
@@ -174,7 +189,7 @@ public class ConcreteAspectCodeGen {
 		}
 
 		if (parent.isMissing()) {
-			reportError("Cannot find m_parent aspect for: " + stringify());
+			reportError("Cannot find parent aspect for: " + stringify());
 			return false;
 		}
 
@@ -191,11 +206,12 @@ public class ConcreteAspectCodeGen {
 		}
 
 		// must have all abstractions defined
-		List elligibleAbstractions = new ArrayList();
+		List<String> elligibleAbstractions = new ArrayList<String>();
 
-		Collection abstractMethods = getOutstandingAbstractMethods(parent);
-		for (Iterator iter = abstractMethods.iterator(); iter.hasNext();) {
-			ResolvedMember method = (ResolvedMember) iter.next();
+		Collection<ResolvedMember> abstractMethods = getOutstandingAbstractMethods(parent);
+		// for (Iterator iter = abstractMethods.iterator(); iter.hasNext();) {
+		// ResolvedMember method = (ResolvedMember) iter.next();
+		for (ResolvedMember method : abstractMethods) {
 			if ("()V".equals(method.getSignature())) {
 				String n = method.getName();
 				// Allow for the abstract pointcut being from a code style
@@ -229,13 +245,11 @@ public class ConcreteAspectCodeGen {
 				}
 			}
 		}
-		List pointcutNames = new ArrayList();
-		for (Iterator it = concreteAspect.pointcuts.iterator(); it.hasNext();) {
-			Definition.Pointcut abstractPc = (Definition.Pointcut) it.next();
+		List<String> pointcutNames = new ArrayList<String>();
+		for (Definition.Pointcut abstractPc : concreteAspect.pointcuts) {
 			pointcutNames.add(abstractPc.name);
 		}
-		for (Iterator it = elligibleAbstractions.iterator(); it.hasNext();) {
-			String elligiblePc = (String) it.next();
+		for (String elligiblePc : elligibleAbstractions) {
 			if (!pointcutNames.contains(elligiblePc)) {
 				reportError("Abstract pointcut '" + elligiblePc + "' not configured: " + stringify());
 				return false;
@@ -259,8 +273,8 @@ public class ConcreteAspectCodeGen {
 		return isValid;
 	}
 
-	private Collection getOutstandingAbstractMethods(ResolvedType type) {
-		Map collector = new HashMap();
+	private Collection<ResolvedMember> getOutstandingAbstractMethods(ResolvedType type) {
+		Map<String, ResolvedMember> collector = new HashMap<String, ResolvedMember>();
 		// let's get to the top of the hierarchy and then walk down ...
 		// recording abstract methods then removing
 		// them if they get defined further down the hierarchy
@@ -269,9 +283,8 @@ public class ConcreteAspectCodeGen {
 	}
 
 	// We are trying to determine abstract methods left over at the bottom of a
-	// hierarchy that have not been
-	// concretized.
-	private void getOutstandingAbstractMethodsHelper(ResolvedType type, Map collector) {
+	// hierarchy that have not been concretized.
+	private void getOutstandingAbstractMethodsHelper(ResolvedType type, Map<String, ResolvedMember> collector) {
 		if (type == null) {
 			return;
 		}
@@ -337,6 +350,9 @@ public class ConcreteAspectCodeGen {
 		if (!isValid) {
 			throw new RuntimeException("Must validate first");
 		}
+		if (bytes != null) {
+			return bytes;
+		}
 		PerClause parentPerClause = (parent != null ? parent.getPerClause() : null);
 		if (parentPerClause == null) {
 			parentPerClause = new PerSingleton();
@@ -385,21 +401,21 @@ public class ConcreteAspectCodeGen {
 			cg.setSuperClass(parent);
 		}
 		if (perclauseString == null) {
-			AnnotationGen ag = new AnnotationGen(new ObjectType("org/aspectj/lang/annotation/Aspect"), Collections.EMPTY_LIST,
-					true, cg.getConstantPool());
+			AnnotationGen ag = new AnnotationGen(new ObjectType("org/aspectj/lang/annotation/Aspect"),
+					Collections.<NameValuePair> emptyList(), true, cg.getConstantPool());
 			cg.addAnnotation(ag);
 		} else {
 			// List elems = new ArrayList();
-			List elems = new ArrayList();
+			List<NameValuePair> elems = new ArrayList<NameValuePair>();
 			elems.add(new NameValuePair("value",
 					new SimpleElementValue(ElementValue.STRING, cg.getConstantPool(), perclauseString), cg.getConstantPool()));
-			AnnotationGen ag = new AnnotationGen(new ObjectType("org/aspectj/lang/annotation/Aspect"), elems, true, cg
-					.getConstantPool());
+			AnnotationGen ag = new AnnotationGen(new ObjectType("org/aspectj/lang/annotation/Aspect"), elems, true,
+					cg.getConstantPool());
 			cg.addAnnotation(ag);
 		}
 		if (concreteAspect.precedence != null) {
 			SimpleElementValue svg = new SimpleElementValue(ElementValue.STRING, cg.getConstantPool(), concreteAspect.precedence);
-			List elems = new ArrayList();
+			List<NameValuePair> elems = new ArrayList<NameValuePair>();
 			elems.add(new NameValuePair("value", svg, cg.getConstantPool()));
 			AnnotationGen agprec = new AnnotationGen(new ObjectType("org/aspectj/lang/annotation/DeclarePrecedence"), elems, true,
 					cg.getConstantPool());
@@ -415,15 +431,15 @@ public class ConcreteAspectCodeGen {
 		cbody.append(InstructionConstants.RETURN);
 		cg.addMethodGen(init);
 
-		for (Iterator it = concreteAspect.pointcuts.iterator(); it.hasNext();) {
+		for (Iterator<Definition.Pointcut> it = concreteAspect.pointcuts.iterator(); it.hasNext();) {
 			Definition.Pointcut abstractPc = (Definition.Pointcut) it.next();
 			// TODO AV - respect visibility instead of opening up as public?
 			LazyMethodGen mg = new LazyMethodGen(Modifier.PUBLIC, Type.VOID, abstractPc.name, EMPTY_TYPES, EMPTY_STRINGS, cg);
 			SimpleElementValue svg = new SimpleElementValue(ElementValue.STRING, cg.getConstantPool(), abstractPc.expression);
-			List elems = new ArrayList();
+			List<NameValuePair> elems = new ArrayList<NameValuePair>();
 			elems.add(new NameValuePair("value", svg, cg.getConstantPool()));
-			AnnotationGen mag = new AnnotationGen(new ObjectType("org/aspectj/lang/annotation/Pointcut"), elems, true, cg
-					.getConstantPool());
+			AnnotationGen mag = new AnnotationGen(new ObjectType("org/aspectj/lang/annotation/Pointcut"), elems, true,
+					cg.getConstantPool());
 			AnnotationAJ max = new BcelAnnotation(mag, world);
 			mg.addAnnotation(max);
 
@@ -444,7 +460,7 @@ public class ConcreteAspectCodeGen {
 
 				FieldGen field = new FieldGen(Modifier.FINAL, ObjectType.STRING, "rule" + (counter++), cg.getConstantPool());
 				SimpleElementValue svg = new SimpleElementValue(ElementValue.STRING, cg.getConstantPool(), deow.pointcut);
-				List elems = new ArrayList();
+				List<NameValuePair> elems = new ArrayList<NameValuePair>();
 				elems.add(new NameValuePair("value", svg, cg.getConstantPool()));
 				AnnotationGen mag = new AnnotationGen(new ObjectType("org/aspectj/lang/annotation/Declare"
 						+ (deow.isError ? "Error" : "Warning")), elems, true, cg.getConstantPool());
@@ -453,7 +469,14 @@ public class ConcreteAspectCodeGen {
 				field.setValue(deow.message);
 				cg.addField(field, null);
 
+			}
+		}
 
+		if (concreteAspect.pointcutsAndAdvice.size() > 0) {
+			int adviceCounter = 1;
+			for (PointcutAndAdvice paa : concreteAspect.pointcutsAndAdvice) {
+				generateAdviceMethod(paa, adviceCounter, cg);
+				adviceCounter++;
 			}
 		}
 
@@ -472,7 +495,208 @@ public class ConcreteAspectCodeGen {
 		JavaClass jc = cg.getJavaClass((BcelWorld) world);
 		((BcelWorld) world).addSourceObjectType(jc, true);
 
-		return jc.getBytes();
+		bytes = jc.getBytes();
+		try {
+			FileOutputStream fos = new FileOutputStream("/Users/aclement/foo.class");
+			fos.write(bytes);
+			fos.flush();
+			fos.close();
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+		return bytes;
+	}
+
+	/**
+	 * The PointcutAndAdvice object encapsulates an advice kind, a pointcut and names a Java method in a particular class. Generate
+	 * an annotation style advice that has that pointcut whose implementation delegates to the Java method.
+	 */
+	private void generateAdviceMethod(PointcutAndAdvice paa, int adviceCounter, LazyClassGen cg) {
+
+		// Check: Verify the class to be called does exist:
+		ResolvedType delegateClass = world.resolve(UnresolvedType.forName(paa.adviceClass));
+		if (delegateClass.isMissing()) {
+			reportError("Class to invoke cannot be found: '" + paa.adviceClass + "'");
+			return;
+		}
+
+		// Generate a name for this advice, includes advice kind plus a counter
+		String adviceName = new StringBuilder("generated$").append(paa.adviceKind.toString().toLowerCase()).append("$advice$")
+				.append(adviceCounter).toString();
+
+		// Build the annotation that encapsulates the pointcut
+		AnnotationAJ aaj = buildAdviceAnnotation(cg, paa);
+
+		// Chop up the supplied advice method string into its pieces.
+		// Example: foo(JoinPoint jp, java.lang.String string)
+		// JoinPoint and friends are recognized (so dont need fq package)
+		String method = paa.adviceMethod;
+
+		int paren = method.indexOf("(");
+		String methodName = method.substring(0, paren);
+		String signature = method.substring(paren);
+
+		// Check: signature looks ok
+		if (signature.charAt(0) != '(' || !signature.endsWith(")")) {
+			reportError("Badly formatted parameter signature: '" + method + "'");
+			return;
+		}
+
+		// Extract parameter types and names
+		List<Type> paramTypes = new ArrayList<Type>();
+		List<String> paramNames = new ArrayList<String>();
+		if (signature.charAt(1) != ')') {
+			// there are parameters to convert into a signature
+			StringBuilder convertedSignature = new StringBuilder("(");
+			boolean paramsBroken = false;
+			int pos = 1;
+			while (pos < signature.length() && signature.charAt(pos) != ')' && !paramsBroken) {
+				int nextChunkEndPos = signature.indexOf(',', pos);
+				if (nextChunkEndPos == -1) {
+					nextChunkEndPos = signature.indexOf(')', pos);
+				}
+				// chunk will be a type plus a space plus a name
+				String nextChunk = signature.substring(pos, nextChunkEndPos).trim();
+				int space = nextChunk.indexOf(" ");
+				ResolvedType resolvedParamType = null;
+				if (space == -1) {
+					// There is no parameter name, hopefully not needed!
+					if (nextChunk.equals("JoinPoint")) {
+						nextChunk = "org.aspectj.lang.JoinPoint";
+					} else if (nextChunk.equals("JoinPoint.StaticPart")) {
+						nextChunk = "org.aspectj.lang.JoinPoint$StaticPart";
+					} else if (nextChunk.equals("ProceedingJoinPoint")) {
+						nextChunk = "org.aspectj.lang.ProceedingJoinPoint";
+					}
+					UnresolvedType unresolvedParamType = UnresolvedType.forName(nextChunk);
+					resolvedParamType = world.resolve(unresolvedParamType);
+				} else {
+					String typename = nextChunk.substring(0, space);
+					if (typename.equals("JoinPoint")) {
+						typename = "org.aspectj.lang.JoinPoint";
+					} else if (typename.equals("JoinPoint.StaticPart")) {
+						typename = "org.aspectj.lang.JoinPoint$StaticPart";
+					} else if (typename.equals("ProceedingJoinPoint")) {
+						typename = "org.aspectj.lang.ProceedingJoinPoint";
+					}
+					UnresolvedType unresolvedParamType = UnresolvedType.forName(typename);
+					resolvedParamType = world.resolve(unresolvedParamType);
+					String paramname = nextChunk.substring(space).trim();
+					paramNames.add(paramname);
+				}
+				if (resolvedParamType.isMissing()) {
+					reportError("Cannot find type specified as parameter: '" + nextChunk + "' from signature '" + signature + "'");
+					paramsBroken = true;
+				}
+				paramTypes.add(Type.getType(resolvedParamType.getSignature()));
+				convertedSignature.append(resolvedParamType.getSignature());
+				pos = nextChunkEndPos + 1;
+			}
+			convertedSignature.append(")");
+			signature = convertedSignature.toString();
+			if (paramsBroken) {
+				return;
+			}
+		}
+
+		Type returnType = Type.VOID;
+
+		// If around advice we must find the actual delegate method and use its return type
+		if (paa.adviceKind == AdviceKind.Around) {
+			ResolvedMember[] methods = delegateClass.getDeclaredMethods();
+			ResolvedMember found = null;
+			for (ResolvedMember candidate : methods) {
+				if (candidate.getName().equals(methodName)) {
+					UnresolvedType[] cparms = candidate.getParameterTypes();
+					if (cparms.length == paramTypes.size()) {
+						boolean paramsMatch = true;
+						for (int i = 0; i < cparms.length; i++) {
+							if (!cparms[i].getSignature().equals(paramTypes.get(i).getSignature())) {
+								paramsMatch = false;
+								break;
+							}
+						}
+						if (paramsMatch) {
+							found = candidate;
+							break;
+						}
+					}
+				}
+			}
+			if (found != null) {
+				returnType = Type.getType(found.getReturnType().getSignature());
+			} else {
+				reportError("Unable to find method to invoke.  In class: " + delegateClass.getName() + " cant find "
+						+ paa.adviceMethod);
+				return;
+			}
+		}
+
+		// Time to construct the method itself:
+		LazyMethodGen advice = new LazyMethodGen(Modifier.PUBLIC, returnType, adviceName, paramTypes.toArray(new Type[paramTypes
+				.size()]), EMPTY_STRINGS, cg);
+
+		InstructionList adviceBody = advice.getBody();
+
+		// Generate code to load the parameters
+		int pos = 1; // first slot after 'this'
+		for (int i = 0; i < paramTypes.size(); i++) {
+			adviceBody.append(InstructionFactory.createLoad(paramTypes.get(i), pos));
+			pos += paramTypes.get(i).getSize();
+		}
+
+		// Generate the delegate call
+		adviceBody.append(cg.getFactory().createInvoke(paa.adviceClass, methodName, signature + returnType.getSignature(),
+				Constants.INVOKESTATIC));
+
+		// Generate the right return
+		if (returnType == Type.VOID) {
+			adviceBody.append(InstructionConstants.RETURN);
+		} else {
+			if (returnType.getSignature().length() < 2) {
+				String sig = returnType.getSignature();
+				if (sig.equals("F")) {
+					adviceBody.append(InstructionConstants.FRETURN);
+				} else if (sig.equals("D")) {
+					adviceBody.append(InstructionConstants.DRETURN);
+				} else if (sig.equals("J")) {
+					adviceBody.append(InstructionConstants.LRETURN);
+				} else {
+					adviceBody.append(InstructionConstants.IRETURN);
+				}
+			} else {
+				adviceBody.append(InstructionConstants.ARETURN);
+			}
+		}
+		// Add the annotation
+		advice.addAnnotation(aaj);
+		InstructionHandle start = adviceBody.getStart();
+
+		// Setup the local variable targeters so that the binding will work
+		String sig = concreteAspect.name.replace('.', '/');
+		start.addTargeter(new LocalVariableTag("L" + sig + ";", "this", 0, start.getPosition()));
+		if (paramNames.size() > 0) {
+			for (int i = 0; i < paramNames.size(); i++) {
+				start.addTargeter(new LocalVariableTag(paramTypes.get(i).getSignature(), paramNames.get(i), i + 1, start
+						.getPosition()));
+			}
+		}
+
+		// Record the new method in the class
+		cg.addMethodGen(advice);
+	}
+
+	/**
+	 * For the given PointcutAndAdvice build the correct advice annotation.
+	 */
+	private AnnotationAJ buildAdviceAnnotation(LazyClassGen cg, PointcutAndAdvice paa) {
+		SimpleElementValue svg = new SimpleElementValue(ElementValue.STRING, cg.getConstantPool(), paa.pointcut);
+		List<NameValuePair> elems = new ArrayList<NameValuePair>();
+		elems.add(new NameValuePair("value", svg, cg.getConstantPool()));
+		AnnotationGen mag = new AnnotationGen(new ObjectType("org/aspectj/lang/annotation/" + paa.adviceKind.toString()), elems,
+				true, cg.getConstantPool());
+		AnnotationAJ aaj = new BcelAnnotation(mag, world);
+		return aaj;
 	}
 
 	/**
@@ -182,8 +182,9 @@ public abstract class Advice extends ShadowMunger {
 					// " from " + shadow.getReturnType());
 					if (getSignature().getReturnType().equals(UnresolvedType.VOID)) {
 						if (!shadow.getReturnType().equals(UnresolvedType.VOID)) {
-							world.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.NON_VOID_RETURN, shadow),
-									getSourceLocation(), shadow.getSourceLocation());
+							String s = shadow.toString();
+							String s2 = WeaverMessages.format(WeaverMessages.NON_VOID_RETURN, s);
+							world.showMessage(IMessage.ERROR, s2, getSourceLocation(), shadow.getSourceLocation());
 							return false;
 						}
 					} else if (getSignature().getReturnType().equals(UnresolvedType.OBJECT)) {
@@ -61,7 +61,7 @@ itdNonExposedImplementor=type {0} must be accessible for weaving interface inter
 itdAbstractMustBePublicOnInterface=abstract intertype method declaration ''{0}'' on interface {1} must be declared public (compiler limitation)
 
 # advice messages...
-nonVoidReturn=applying to join point that doesn't return void: {0}
+nonVoidReturn=applying to join point that doesn''t return void: {0}
 incompatibleReturnType=incompatible return type applying to {0}
 cantThrowChecked=can''t throw checked exception ''{0}'' at this join point ''{1}''
 circularDependency=circular advice precedence: can''t determine precedence between two or more pieces of advice that apply to the same join point: {0}
@@ -59,7 +59,7 @@ import org.aspectj.apache.bcel.generic.Type;
 /**
  * Constants for the project, mostly defined in the JVM specification.
  * 
- * @version $Id: Constants.java,v 1.6 2009/09/14 20:29:10 aclement Exp $
+ * @version $Id: Constants.java,v 1.7 2011/09/28 01:14:54 aclement Exp $
  * @author <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
  */
 public interface Constants {
@@ -472,301 +472,7 @@ public interface Constants {
 
 	public static final Class<Throwable>[][] instExcs = new Class[256][];
 
-	static final Clinit _unused = new Clinit();
-
-	static class Clinit {
-
-		static {
-			types[ILOAD] = Type.INT;
-			types[ISTORE] = Type.INT;
-			types[ILOAD_0] = Type.INT;
-			types[ISTORE_0] = Type.INT;
-			types[ILOAD_1] = Type.INT;
-			types[ISTORE_1] = Type.INT;
-			types[ILOAD_2] = Type.INT;
-			types[ISTORE_2] = Type.INT;
-			types[ILOAD_3] = Type.INT;
-			types[ISTORE_3] = Type.INT;
-			types[LLOAD] = Type.LONG;
-			types[LSTORE] = Type.LONG;
-			types[LLOAD_0] = Type.LONG;
-			types[LSTORE_0] = Type.LONG;
-			types[LLOAD_1] = Type.LONG;
-			types[LSTORE_1] = Type.LONG;
-			types[LLOAD_2] = Type.LONG;
-			types[LSTORE_2] = Type.LONG;
-			types[LLOAD_3] = Type.LONG;
-			types[LSTORE_3] = Type.LONG;
-			types[DLOAD] = Type.DOUBLE;
-			types[DSTORE] = Type.DOUBLE;
-			types[DLOAD_0] = Type.DOUBLE;
-			types[DSTORE_0] = Type.DOUBLE;
-			types[DLOAD_1] = Type.DOUBLE;
-			types[DSTORE_1] = Type.DOUBLE;
-			types[DLOAD_2] = Type.DOUBLE;
-			types[DSTORE_2] = Type.DOUBLE;
-			types[DLOAD_3] = Type.DOUBLE;
-			types[DSTORE_3] = Type.DOUBLE;
-			types[FLOAD] = Type.FLOAT;
-			types[FSTORE] = Type.FLOAT;
-			types[FLOAD_0] = Type.FLOAT;
-			types[FSTORE_0] = Type.FLOAT;
-			types[FLOAD_1] = Type.FLOAT;
-			types[FSTORE_1] = Type.FLOAT;
-			types[FLOAD_2] = Type.FLOAT;
-			types[FSTORE_2] = Type.FLOAT;
-			types[FLOAD_3] = Type.FLOAT;
-			types[FSTORE_3] = Type.FLOAT;
-			types[ALOAD] = Type.OBJECT;
-			types[ASTORE] = Type.OBJECT;
-			types[ALOAD_0] = Type.OBJECT;
-			types[ASTORE_0] = Type.OBJECT;
-			types[ALOAD_1] = Type.OBJECT;
-			types[ASTORE_1] = Type.OBJECT;
-			types[ALOAD_2] = Type.OBJECT;
-			types[ASTORE_2] = Type.OBJECT;
-			types[ALOAD_3] = Type.OBJECT;
-			types[ASTORE_3] = Type.OBJECT;
-
-			// INSTRUCTION_FLAGS - set for all
-			instFlags[NOP] = 0;
-			instFlags[ACONST_NULL] = PUSH_INST;
-			instFlags[ICONST_M1] = PUSH_INST | CONSTANT_INST;
-			instFlags[ICONST_0] = PUSH_INST | CONSTANT_INST;
-			instFlags[ICONST_1] = PUSH_INST | CONSTANT_INST;
-			instFlags[ICONST_2] = PUSH_INST | CONSTANT_INST;
-			instFlags[ICONST_3] = PUSH_INST | CONSTANT_INST;
-			instFlags[ICONST_4] = PUSH_INST | CONSTANT_INST;
-			instFlags[ICONST_5] = PUSH_INST | CONSTANT_INST;
-			instFlags[LCONST_0] = PUSH_INST | CONSTANT_INST;
-			instFlags[LCONST_1] = PUSH_INST | CONSTANT_INST;
-			instFlags[FCONST_0] = PUSH_INST | CONSTANT_INST;
-			instFlags[FCONST_1] = PUSH_INST | CONSTANT_INST;
-			instFlags[FCONST_2] = PUSH_INST | CONSTANT_INST;
-			instFlags[DCONST_0] = PUSH_INST | CONSTANT_INST;
-			instFlags[DCONST_1] = PUSH_INST | CONSTANT_INST;
-
-			instFlags[BIPUSH] = PUSH_INST | CONSTANT_INST;
-			instFlags[SIPUSH] = PUSH_INST | CONSTANT_INST;
-
-			instFlags[LDC] = EXCEPTION_THROWER | PUSH_INST | CP_INST | INDEXED;
-
-			instFlags[LDC_W] = EXCEPTION_THROWER | PUSH_INST | CP_INST | INDEXED;
-
-			instFlags[LDC2_W] = EXCEPTION_THROWER | PUSH_INST | CP_INST | INDEXED;
-
-			// the next five could be 'wide' prefixed and so have longer lengths
-			instFlags[ILOAD] = INDEXED | LOAD_INST | PUSH_INST | LV_INST;
-			instFlags[LLOAD] = INDEXED | LOAD_INST | PUSH_INST | LV_INST;
-			instFlags[FLOAD] = INDEXED | LOAD_INST | PUSH_INST | LV_INST;
-			instFlags[DLOAD] = INDEXED | LOAD_INST | PUSH_INST | LV_INST;
-			instFlags[ALOAD] = INDEXED | LOAD_INST | PUSH_INST | LV_INST;
-			for (int ii = ILOAD_0; ii <= ALOAD_3; ii++) {
-				instFlags[ii] = INDEXED | LOAD_INST | PUSH_INST | LV_INST;
-			}
-
-			// the next five could be 'wide' prefixed and so have longer lengths
-			instFlags[ISTORE] = INDEXED | STORE_INST | POP_INST | LV_INST;
-			instFlags[LSTORE] = INDEXED | STORE_INST | POP_INST | LV_INST;
-			instFlags[FSTORE] = INDEXED | STORE_INST | POP_INST | LV_INST;
-			instFlags[DSTORE] = INDEXED | STORE_INST | POP_INST | LV_INST;
-			instFlags[ASTORE] = INDEXED | STORE_INST | POP_INST | LV_INST;
-			for (int ii = ISTORE_0; ii <= ASTORE_3; ii++) {
-				instFlags[ii] = INDEXED | STORE_INST | POP_INST | LV_INST;
-			}
-
-			instFlags[IDIV] = EXCEPTION_THROWER;
-			instExcs[IDIV] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.ARITHMETIC_EXCEPTION };
-			instFlags[IREM] = EXCEPTION_THROWER;
-			instExcs[IREM] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.ARITHMETIC_EXCEPTION };
-			instFlags[LDIV] = EXCEPTION_THROWER;
-			instExcs[LDIV] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.ARITHMETIC_EXCEPTION };
-			instFlags[LREM] = EXCEPTION_THROWER;
-			instExcs[LREM] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.ARITHMETIC_EXCEPTION };
-
-			instFlags[ARRAYLENGTH] = EXCEPTION_THROWER;
-			instExcs[ARRAYLENGTH] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.NULL_POINTER_EXCEPTION };
-			instFlags[ATHROW] = EXCEPTION_THROWER;
-			instExcs[ATHROW] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.THROWABLE };
-
-			instFlags[AALOAD] = EXCEPTION_THROWER;
-			instExcs[AALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-			instFlags[IALOAD] = EXCEPTION_THROWER;
-			instExcs[IALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-			instFlags[BALOAD] = EXCEPTION_THROWER;
-			instExcs[BALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-			instFlags[FALOAD] = EXCEPTION_THROWER;
-			instExcs[FALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-			instFlags[DALOAD] = EXCEPTION_THROWER;
-			instExcs[DALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-			instFlags[CALOAD] = EXCEPTION_THROWER;
-			instExcs[CALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-			instFlags[LALOAD] = EXCEPTION_THROWER;
-			instExcs[LALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-			instFlags[SALOAD] = EXCEPTION_THROWER;
-			instExcs[SALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-
-			instFlags[AASTORE] = EXCEPTION_THROWER;
-			instExcs[AASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-			instFlags[IASTORE] = EXCEPTION_THROWER;
-			instExcs[IASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-			instFlags[BASTORE] = EXCEPTION_THROWER;
-			instExcs[BASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-			instFlags[FASTORE] = EXCEPTION_THROWER;
-			instExcs[FASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-			instFlags[DASTORE] = EXCEPTION_THROWER;
-			instExcs[DASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-			instFlags[CASTORE] = EXCEPTION_THROWER;
-			instExcs[CASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-			instFlags[LASTORE] = EXCEPTION_THROWER;
-			instExcs[LASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-			instFlags[SASTORE] = EXCEPTION_THROWER;
-			instExcs[SASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
-
-			// stack instructions
-			instFlags[DUP] = PUSH_INST | STACK_INST;
-			instFlags[DUP_X1] = STACK_INST; // TODO fixme - aren't these two push/stack producers? (although peculiar ones...)
-			instFlags[DUP_X2] = STACK_INST;
-			instFlags[DUP2] = PUSH_INST | STACK_INST;
-			instFlags[DUP2_X1] = STACK_INST; // TODO fixme - aren't these two push/stack producers? (although peculiar ones...)
-			instFlags[DUP2_X2] = STACK_INST;
-			instFlags[POP] = STACK_INST | POP_INST;
-			instFlags[POP2] = STACK_INST | POP_INST;
-			instFlags[SWAP] = STACK_INST;
-
-			instFlags[MONITORENTER] = EXCEPTION_THROWER;
-			instExcs[MONITORENTER] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.NULL_POINTER_EXCEPTION };
-			instFlags[MONITOREXIT] = EXCEPTION_THROWER;
-			instExcs[MONITOREXIT] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.NULL_POINTER_EXCEPTION };
-
-			// branching instructions
-			instFlags[GOTO] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION;
-			instFlags[GOTO_W] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION;
-			instFlags[JSR] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | JSR_INSTRUCTION;
-			instFlags[JSR_W] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | JSR_INSTRUCTION;
-
-			instFlags[IFGT] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-			instFlags[IFLE] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-			instFlags[IFNE] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-			instFlags[IFEQ] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-			instFlags[IFGE] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-			instFlags[IFLT] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-			instFlags[IFNULL] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-			instFlags[IFNONNULL] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-			instFlags[IF_ACMPEQ] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-			instFlags[IF_ACMPNE] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-			instFlags[IF_ICMPEQ] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-			instFlags[IF_ICMPGE] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-			instFlags[IF_ICMPGT] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-			instFlags[IF_ICMPLE] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-			instFlags[IF_ICMPLT] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-			instFlags[IF_ICMPNE] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION | NEGATABLE | IF_INST;
-
-			instFlags[LOOKUPSWITCH] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION;
-			instFlags[TABLESWITCH] = BRANCH_INSTRUCTION | TARGETER_INSTRUCTION;
-
-			// fixme these class arrays should be constants
-			instFlags[ARETURN] = RET_INST | EXCEPTION_THROWER;
-			instExcs[ARETURN] = new Class[] { ExceptionConstants.ILLEGAL_MONITOR_STATE };
-			instFlags[DRETURN] = RET_INST | EXCEPTION_THROWER;
-			instExcs[DRETURN] = new Class[] { ExceptionConstants.ILLEGAL_MONITOR_STATE };
-			instFlags[FRETURN] = RET_INST | EXCEPTION_THROWER;
-			instExcs[FRETURN] = new Class[] { ExceptionConstants.ILLEGAL_MONITOR_STATE };
-			instFlags[IRETURN] = RET_INST | EXCEPTION_THROWER;
-			instExcs[IRETURN] = new Class[] { ExceptionConstants.ILLEGAL_MONITOR_STATE };
-			instFlags[LRETURN] = RET_INST | EXCEPTION_THROWER;
-			instExcs[LRETURN] = new Class[] { ExceptionConstants.ILLEGAL_MONITOR_STATE };
-			instFlags[RETURN] = RET_INST | EXCEPTION_THROWER;
-			instExcs[RETURN] = new Class[] { ExceptionConstants.ILLEGAL_MONITOR_STATE };
-
-			instFlags[NEW] = LOADCLASS_INST | EXCEPTION_THROWER | CP_INST | INDEXED;
-			instExcs[NEW] = ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION_FOR_ALLOCATIONS;
-			instFlags[NEWARRAY] = EXCEPTION_THROWER;
-			instExcs[NEWARRAY] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.NEGATIVE_ARRAY_SIZE_EXCEPTION };
-
-			types[IINC] = Type.INT;
-			instFlags[IINC] = LV_INST | INDEXED;
-			instFlags[RET] = INDEXED;
-
-			instFlags[ANEWARRAY] = CP_INST | LOADCLASS_INST | EXCEPTION_THROWER | INDEXED;
-			instExcs[ANEWARRAY] = ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION_ANEWARRAY;
-			instFlags[CHECKCAST] = CP_INST | LOADCLASS_INST | EXCEPTION_THROWER | INDEXED;
-			instExcs[CHECKCAST] = ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION_CHECKCAST;
-			instFlags[INSTANCEOF] = CP_INST | LOADCLASS_INST | EXCEPTION_THROWER | INDEXED;
-			instExcs[INSTANCEOF] = ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION;
-			instFlags[MULTIANEWARRAY] = CP_INST | LOADCLASS_INST | EXCEPTION_THROWER | INDEXED;
-			instExcs[MULTIANEWARRAY] = ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION_ANEWARRAY; // fixme i think this is a
-			// stackproducer, old
-			// bcel says no...
-
-			instFlags[GETFIELD] = EXCEPTION_THROWER | CP_INST | LOADCLASS_INST | INDEXED;
-			instExcs[GETFIELD] = ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION_GETFIELD_PUTFIELD;
-			instFlags[GETSTATIC] = PUSH_INST | EXCEPTION_THROWER | LOADCLASS_INST | CP_INST | INDEXED;
-			instExcs[GETSTATIC] = ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION_GETSTATIC_PUTSTATIC;
-			instFlags[PUTFIELD] = POP_INST | EXCEPTION_THROWER | LOADCLASS_INST | CP_INST | INDEXED;
-			instExcs[PUTFIELD] = ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION_GETFIELD_PUTFIELD;
-			instFlags[PUTSTATIC] = EXCEPTION_THROWER | POP_INST | CP_INST | LOADCLASS_INST | INDEXED;
-			instExcs[PUTSTATIC] = ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION_GETSTATIC_PUTSTATIC;
-
-			instFlags[INVOKEINTERFACE] = EXCEPTION_THROWER | CP_INST | LOADCLASS_INST | INDEXED;
-			instExcs[INVOKEINTERFACE] = ExceptionConstants.EXCS_INTERFACE_METHOD_RESOLUTION_INVOKEINTERFACE;
-			instFlags[INVOKESPECIAL] = EXCEPTION_THROWER | CP_INST | LOADCLASS_INST | INDEXED;
-			instExcs[INVOKESPECIAL] = ExceptionConstants.EXCS_INTERFACE_METHOD_RESOLUTION_INVOKESPECIAL_INVOKEVIRTUAL;
-			instFlags[INVOKESTATIC] = EXCEPTION_THROWER | CP_INST | LOADCLASS_INST | INDEXED;
-			instExcs[INVOKESTATIC] = ExceptionConstants.EXCS_INTERFACE_METHOD_RESOLUTION_INVOKESTATIC;
-			instFlags[INVOKEVIRTUAL] = EXCEPTION_THROWER | CP_INST | LOADCLASS_INST | INDEXED;
-			instExcs[INVOKEVIRTUAL] = ExceptionConstants.EXCS_INTERFACE_METHOD_RESOLUTION_INVOKESPECIAL_INVOKEVIRTUAL;
-
-			char[] lengths = // . = varies in length, / = undefined
-			("1111111111111111" + // nop > dconst_1
-					"2323322222111111" + // bipush > lload_1
-					"1111111111111111" + // lload_2 > laload
-					"1111112222211111" + // faload > lstore_0
-					"1111111111111111" + // lstore_1 > iastore
-					"1111111111111111" + // lastore > swap
-					"1111111111111111" + // iadd > ddiv
-					"1111111111111111" + // irem > land
-					"1111311111111111" + // ior > d2l
-					"1111111113333333" + // d2f > if_icmpeq
-					"3333333332..1111" + // if_icmpne > dreturn
-					"1133333335/32311" + // areturn > athrow
-					"3311.433551/////").toCharArray(); // checkcast >
-			int count = 0;
-			for (; count < lengths.length; count++) {
-				iLen[count] = (byte) (lengths[count] - 48);
-			}
-			while (count < 256) {
-				iLen[count] = UNDEFINED;
-				count++;
-			}
-			iLen[BREAKPOINT] = 1;
-			iLen[IMPDEP1] = 1;
-			iLen[IMPDEP2] = 1;
-
-			char[] producesOnStack = ("0111111112211122" + // nop > dconst_1
-					"1111212121111122" + // bipush > lload_1
-					"2211112222111112" + // lload_2 > laload
-					"1211110000000000" + // faload > lstore_0
-					"0000000000000000" + // lstore_1 > iastore
-					"0000000002344562" + // lastore > swap
-					"1212121212121212" + // iadd > ddiv
-					"1212121212121212" + // irem > land
-					"1212021211212212" + // ior > d2l
-					"1111111110000000" + // d2f > if_icmpeq
-					"0000000010000000" + // if_icmpne > dreturn
-					"00.0.0..../11111" + // areturn > athrow
-					"11000100010/").toCharArray(); // checkcast >
-			count = 0;
-			for (; count < producesOnStack.length; count++) {
-				stackEntriesProduced[count] = (byte) (producesOnStack[count] - 48);
-			}
-			while (count < 256) {
-				iLen[count] = UNDEFINED;
-				count++;
-			}
-
-		}
-	}
+	static final Object _unused = ConstantsInitializer.initialize();
 
 	/**
 	 * How the byte code operands are to be interpreted.
@@ -0,0 +1,389 @@
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2001 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" and
+ *    "Apache BCEL" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    "Apache BCEL", nor may "Apache" appear in their name, without
+ *    prior written permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ */
+package org.aspectj.apache.bcel;
+
+import org.aspectj.apache.bcel.generic.Type;
+
+public class ConstantsInitializer {
+
+	public static Object initialize() {
+		Constants.types[Constants.ILOAD] = Type.INT;
+		Constants.types[Constants.ISTORE] = Type.INT;
+		Constants.types[Constants.ILOAD_0] = Type.INT;
+		Constants.types[Constants.ISTORE_0] = Type.INT;
+		Constants.types[Constants.ILOAD_1] = Type.INT;
+		Constants.types[Constants.ISTORE_1] = Type.INT;
+		Constants.types[Constants.ILOAD_2] = Type.INT;
+		Constants.types[Constants.ISTORE_2] = Type.INT;
+		Constants.types[Constants.ILOAD_3] = Type.INT;
+		Constants.types[Constants.ISTORE_3] = Type.INT;
+		Constants.types[Constants.LLOAD] = Type.LONG;
+		Constants.types[Constants.LSTORE] = Type.LONG;
+		Constants.types[Constants.LLOAD_0] = Type.LONG;
+		Constants.types[Constants.LSTORE_0] = Type.LONG;
+		Constants.types[Constants.LLOAD_1] = Type.LONG;
+		Constants.types[Constants.LSTORE_1] = Type.LONG;
+		Constants.types[Constants.LLOAD_2] = Type.LONG;
+		Constants.types[Constants.LSTORE_2] = Type.LONG;
+		Constants.types[Constants.LLOAD_3] = Type.LONG;
+		Constants.types[Constants.LSTORE_3] = Type.LONG;
+		Constants.types[Constants.DLOAD] = Type.DOUBLE;
+		Constants.types[Constants.DSTORE] = Type.DOUBLE;
+		Constants.types[Constants.DLOAD_0] = Type.DOUBLE;
+		Constants.types[Constants.DSTORE_0] = Type.DOUBLE;
+		Constants.types[Constants.DLOAD_1] = Type.DOUBLE;
+		Constants.types[Constants.DSTORE_1] = Type.DOUBLE;
+		Constants.types[Constants.DLOAD_2] = Type.DOUBLE;
+		Constants.types[Constants.DSTORE_2] = Type.DOUBLE;
+		Constants.types[Constants.DLOAD_3] = Type.DOUBLE;
+		Constants.types[Constants.DSTORE_3] = Type.DOUBLE;
+		Constants.types[Constants.FLOAD] = Type.FLOAT;
+		Constants.types[Constants.FSTORE] = Type.FLOAT;
+		Constants.types[Constants.FLOAD_0] = Type.FLOAT;
+		Constants.types[Constants.FSTORE_0] = Type.FLOAT;
+		Constants.types[Constants.FLOAD_1] = Type.FLOAT;
+		Constants.types[Constants.FSTORE_1] = Type.FLOAT;
+		Constants.types[Constants.FLOAD_2] = Type.FLOAT;
+		Constants.types[Constants.FSTORE_2] = Type.FLOAT;
+		Constants.types[Constants.FLOAD_3] = Type.FLOAT;
+		Constants.types[Constants.FSTORE_3] = Type.FLOAT;
+		Constants.types[Constants.ALOAD] = Type.OBJECT;
+		Constants.types[Constants.ASTORE] = Type.OBJECT;
+		Constants.types[Constants.ALOAD_0] = Type.OBJECT;
+		Constants.types[Constants.ASTORE_0] = Type.OBJECT;
+		Constants.types[Constants.ALOAD_1] = Type.OBJECT;
+		Constants.types[Constants.ASTORE_1] = Type.OBJECT;
+		Constants.types[Constants.ALOAD_2] = Type.OBJECT;
+		Constants.types[Constants.ASTORE_2] = Type.OBJECT;
+		Constants.types[Constants.ALOAD_3] = Type.OBJECT;
+		Constants.types[Constants.ASTORE_3] = Type.OBJECT;
+
+		// INSTRUCTION_FLAGS - set for all
+		Constants.instFlags[Constants.NOP] = 0;
+		Constants.instFlags[Constants.ACONST_NULL] = Constants.PUSH_INST;
+		Constants.instFlags[Constants.ICONST_M1] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+		Constants.instFlags[Constants.ICONST_0] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+		Constants.instFlags[Constants.ICONST_1] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+		Constants.instFlags[Constants.ICONST_2] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+		Constants.instFlags[Constants.ICONST_3] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+		Constants.instFlags[Constants.ICONST_4] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+		Constants.instFlags[Constants.ICONST_5] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+		Constants.instFlags[Constants.LCONST_0] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+		Constants.instFlags[Constants.LCONST_1] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+		Constants.instFlags[Constants.FCONST_0] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+		Constants.instFlags[Constants.FCONST_1] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+		Constants.instFlags[Constants.FCONST_2] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+		Constants.instFlags[Constants.DCONST_0] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+		Constants.instFlags[Constants.DCONST_1] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+
+		Constants.instFlags[Constants.BIPUSH] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+		Constants.instFlags[Constants.SIPUSH] = Constants.PUSH_INST | Constants.CONSTANT_INST;
+
+		Constants.instFlags[Constants.LDC] = Constants.EXCEPTION_THROWER | Constants.PUSH_INST | Constants.CP_INST
+				| Constants.INDEXED;
+
+		Constants.instFlags[Constants.LDC_W] = Constants.EXCEPTION_THROWER | Constants.PUSH_INST | Constants.CP_INST
+				| Constants.INDEXED;
+
+		Constants.instFlags[Constants.LDC2_W] = Constants.EXCEPTION_THROWER | Constants.PUSH_INST | Constants.CP_INST
+				| Constants.INDEXED;
+
+		// the next five could be 'wide' prefixed and so have longer lengths
+		Constants.instFlags[Constants.ILOAD] = Constants.INDEXED | Constants.LOAD_INST | Constants.PUSH_INST | Constants.LV_INST;
+		Constants.instFlags[Constants.LLOAD] = Constants.INDEXED | Constants.LOAD_INST | Constants.PUSH_INST | Constants.LV_INST;
+		Constants.instFlags[Constants.FLOAD] = Constants.INDEXED | Constants.LOAD_INST | Constants.PUSH_INST | Constants.LV_INST;
+		Constants.instFlags[Constants.DLOAD] = Constants.INDEXED | Constants.LOAD_INST | Constants.PUSH_INST | Constants.LV_INST;
+		Constants.instFlags[Constants.ALOAD] = Constants.INDEXED | Constants.LOAD_INST | Constants.PUSH_INST | Constants.LV_INST;
+		for (int ii = Constants.ILOAD_0; ii <= Constants.ALOAD_3; ii++) {
+			Constants.instFlags[ii] = Constants.INDEXED | Constants.LOAD_INST | Constants.PUSH_INST | Constants.LV_INST;
+		}
+
+		// the next five could be 'wide' prefixed and so have longer lengths
+		Constants.instFlags[Constants.ISTORE] = Constants.INDEXED | Constants.STORE_INST | Constants.POP_INST | Constants.LV_INST;
+		Constants.instFlags[Constants.LSTORE] = Constants.INDEXED | Constants.STORE_INST | Constants.POP_INST | Constants.LV_INST;
+		Constants.instFlags[Constants.FSTORE] = Constants.INDEXED | Constants.STORE_INST | Constants.POP_INST | Constants.LV_INST;
+		Constants.instFlags[Constants.DSTORE] = Constants.INDEXED | Constants.STORE_INST | Constants.POP_INST | Constants.LV_INST;
+		Constants.instFlags[Constants.ASTORE] = Constants.INDEXED | Constants.STORE_INST | Constants.POP_INST | Constants.LV_INST;
+		for (int ii = Constants.ISTORE_0; ii <= Constants.ASTORE_3; ii++) {
+			Constants.instFlags[ii] = Constants.INDEXED | Constants.STORE_INST | Constants.POP_INST | Constants.LV_INST;
+		}
+
+		Constants.instFlags[Constants.IDIV] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.IDIV] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.ARITHMETIC_EXCEPTION };
+		Constants.instFlags[Constants.IREM] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.IREM] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.ARITHMETIC_EXCEPTION };
+		Constants.instFlags[Constants.LDIV] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.LDIV] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.ARITHMETIC_EXCEPTION };
+		Constants.instFlags[Constants.LREM] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.LREM] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.ARITHMETIC_EXCEPTION };
+
+		Constants.instFlags[Constants.ARRAYLENGTH] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.ARRAYLENGTH] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.NULL_POINTER_EXCEPTION };
+		Constants.instFlags[Constants.ATHROW] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.ATHROW] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.THROWABLE };
+
+		Constants.instFlags[Constants.AALOAD] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.AALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+		Constants.instFlags[Constants.IALOAD] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.IALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+		Constants.instFlags[Constants.BALOAD] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.BALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+		Constants.instFlags[Constants.FALOAD] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.FALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+		Constants.instFlags[Constants.DALOAD] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.DALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+		Constants.instFlags[Constants.CALOAD] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.CALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+		Constants.instFlags[Constants.LALOAD] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.LALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+		Constants.instFlags[Constants.SALOAD] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.SALOAD] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+
+		Constants.instFlags[Constants.AASTORE] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.AASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+		Constants.instFlags[Constants.IASTORE] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.IASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+		Constants.instFlags[Constants.BASTORE] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.BASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+		Constants.instFlags[Constants.FASTORE] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.FASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+		Constants.instFlags[Constants.DASTORE] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.DASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+		Constants.instFlags[Constants.CASTORE] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.CASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+		Constants.instFlags[Constants.LASTORE] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.LASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+		Constants.instFlags[Constants.SASTORE] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.SASTORE] = org.aspectj.apache.bcel.ExceptionConstants.EXCS_ARRAY_EXCEPTION;
+
+		// stack instructions
+		Constants.instFlags[Constants.DUP] = Constants.PUSH_INST | Constants.STACK_INST;
+		Constants.instFlags[Constants.DUP_X1] = Constants.STACK_INST; // TODO fixme - aren't these two push/stack producers?
+																		// (although peculiar ones...)
+		Constants.instFlags[Constants.DUP_X2] = Constants.STACK_INST;
+		Constants.instFlags[Constants.DUP2] = Constants.PUSH_INST | Constants.STACK_INST;
+		Constants.instFlags[Constants.DUP2_X1] = Constants.STACK_INST; // TODO fixme - aren't these two push/stack producers?
+																		// (although peculiar ones...)
+		Constants.instFlags[Constants.DUP2_X2] = Constants.STACK_INST;
+		Constants.instFlags[Constants.POP] = Constants.STACK_INST | Constants.POP_INST;
+		Constants.instFlags[Constants.POP2] = Constants.STACK_INST | Constants.POP_INST;
+		Constants.instFlags[Constants.SWAP] = Constants.STACK_INST;
+
+		Constants.instFlags[Constants.MONITORENTER] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.MONITORENTER] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.NULL_POINTER_EXCEPTION };
+		Constants.instFlags[Constants.MONITOREXIT] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.MONITOREXIT] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.NULL_POINTER_EXCEPTION };
+
+		// branching instructions
+		Constants.instFlags[Constants.GOTO] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION;
+		Constants.instFlags[Constants.GOTO_W] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION;
+		Constants.instFlags[Constants.JSR] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION
+				| Constants.JSR_INSTRUCTION;
+		Constants.instFlags[Constants.JSR_W] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION
+				| Constants.JSR_INSTRUCTION;
+
+		Constants.instFlags[Constants.IFGT] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION | Constants.NEGATABLE
+				| Constants.IF_INST;
+		Constants.instFlags[Constants.IFLE] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION | Constants.NEGATABLE
+				| Constants.IF_INST;
+		Constants.instFlags[Constants.IFNE] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION | Constants.NEGATABLE
+				| Constants.IF_INST;
+		Constants.instFlags[Constants.IFEQ] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION | Constants.NEGATABLE
+				| Constants.IF_INST;
+		Constants.instFlags[Constants.IFGE] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION | Constants.NEGATABLE
+				| Constants.IF_INST;
+		Constants.instFlags[Constants.IFLT] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION | Constants.NEGATABLE
+				| Constants.IF_INST;
+		Constants.instFlags[Constants.IFNULL] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION | Constants.NEGATABLE
+				| Constants.IF_INST;
+		Constants.instFlags[Constants.IFNONNULL] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION
+				| Constants.NEGATABLE | Constants.IF_INST;
+		Constants.instFlags[Constants.IF_ACMPEQ] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION
+				| Constants.NEGATABLE | Constants.IF_INST;
+		Constants.instFlags[Constants.IF_ACMPNE] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION
+				| Constants.NEGATABLE | Constants.IF_INST;
+		Constants.instFlags[Constants.IF_ICMPEQ] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION
+				| Constants.NEGATABLE | Constants.IF_INST;
+		Constants.instFlags[Constants.IF_ICMPGE] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION
+				| Constants.NEGATABLE | Constants.IF_INST;
+		Constants.instFlags[Constants.IF_ICMPGT] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION
+				| Constants.NEGATABLE | Constants.IF_INST;
+		Constants.instFlags[Constants.IF_ICMPLE] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION
+				| Constants.NEGATABLE | Constants.IF_INST;
+		Constants.instFlags[Constants.IF_ICMPLT] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION
+				| Constants.NEGATABLE | Constants.IF_INST;
+		Constants.instFlags[Constants.IF_ICMPNE] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION
+				| Constants.NEGATABLE | Constants.IF_INST;
+
+		Constants.instFlags[Constants.LOOKUPSWITCH] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION;
+		Constants.instFlags[Constants.TABLESWITCH] = Constants.BRANCH_INSTRUCTION | Constants.TARGETER_INSTRUCTION;
+
+		// fixme these class arrays should be constants
+		Constants.instFlags[Constants.ARETURN] = Constants.RET_INST | Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.ARETURN] = new Class[] { ExceptionConstants.ILLEGAL_MONITOR_STATE };
+		Constants.instFlags[Constants.DRETURN] = Constants.RET_INST | Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.DRETURN] = new Class[] { ExceptionConstants.ILLEGAL_MONITOR_STATE };
+		Constants.instFlags[Constants.FRETURN] = Constants.RET_INST | Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.FRETURN] = new Class[] { ExceptionConstants.ILLEGAL_MONITOR_STATE };
+		Constants.instFlags[Constants.IRETURN] = Constants.RET_INST | Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.IRETURN] = new Class[] { ExceptionConstants.ILLEGAL_MONITOR_STATE };
+		Constants.instFlags[Constants.LRETURN] = Constants.RET_INST | Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.LRETURN] = new Class[] { ExceptionConstants.ILLEGAL_MONITOR_STATE };
+		Constants.instFlags[Constants.RETURN] = Constants.RET_INST | Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.RETURN] = new Class[] { ExceptionConstants.ILLEGAL_MONITOR_STATE };
+
+		Constants.instFlags[Constants.NEW] = Constants.LOADCLASS_INST | Constants.EXCEPTION_THROWER | Constants.CP_INST
+				| Constants.INDEXED;
+		Constants.instExcs[Constants.NEW] = ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION_FOR_ALLOCATIONS;
+		Constants.instFlags[Constants.NEWARRAY] = Constants.EXCEPTION_THROWER;
+		Constants.instExcs[Constants.NEWARRAY] = new Class[] { org.aspectj.apache.bcel.ExceptionConstants.NEGATIVE_ARRAY_SIZE_EXCEPTION };
+
+		Constants.types[Constants.IINC] = Type.INT;
+		Constants.instFlags[Constants.IINC] = Constants.LV_INST | Constants.INDEXED;
+		Constants.instFlags[Constants.RET] = Constants.INDEXED;
+
+		Constants.instFlags[Constants.ANEWARRAY] = Constants.CP_INST | Constants.LOADCLASS_INST | Constants.EXCEPTION_THROWER
+				| Constants.INDEXED;
+		Constants.instExcs[Constants.ANEWARRAY] = ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION_ANEWARRAY;
+		Constants.instFlags[Constants.CHECKCAST] = Constants.CP_INST | Constants.LOADCLASS_INST | Constants.EXCEPTION_THROWER
+				| Constants.INDEXED;
+		Constants.instExcs[Constants.CHECKCAST] = ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION_CHECKCAST;
+		Constants.instFlags[Constants.INSTANCEOF] = Constants.CP_INST | Constants.LOADCLASS_INST | Constants.EXCEPTION_THROWER
+				| Constants.INDEXED;
+		Constants.instExcs[Constants.INSTANCEOF] = ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION;
+		Constants.instFlags[Constants.MULTIANEWARRAY] = Constants.CP_INST | Constants.LOADCLASS_INST | Constants.EXCEPTION_THROWER
+				| Constants.INDEXED;
+		Constants.instExcs[Constants.MULTIANEWARRAY] = ExceptionConstants.EXCS_CLASS_AND_INTERFACE_RESOLUTION_ANEWARRAY; // fixme i
+																															// think
+																															// this
+																															// is a
+		// stackproducer, old
+		// bcel says no...
+
+		Constants.instFlags[Constants.GETFIELD] = Constants.EXCEPTION_THROWER | Constants.CP_INST | Constants.LOADCLASS_INST
+				| Constants.INDEXED;
+		Constants.instExcs[Constants.GETFIELD] = ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION_GETFIELD_PUTFIELD;
+		Constants.instFlags[Constants.GETSTATIC] = Constants.PUSH_INST | Constants.EXCEPTION_THROWER | Constants.LOADCLASS_INST
+				| Constants.CP_INST | Constants.INDEXED;
+		Constants.instExcs[Constants.GETSTATIC] = ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION_GETSTATIC_PUTSTATIC;
+		Constants.instFlags[Constants.PUTFIELD] = Constants.POP_INST | Constants.EXCEPTION_THROWER | Constants.LOADCLASS_INST
+				| Constants.CP_INST | Constants.INDEXED;
+		Constants.instExcs[Constants.PUTFIELD] = ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION_GETFIELD_PUTFIELD;
+		Constants.instFlags[Constants.PUTSTATIC] = Constants.EXCEPTION_THROWER | Constants.POP_INST | Constants.CP_INST
+				| Constants.LOADCLASS_INST | Constants.INDEXED;
+		Constants.instExcs[Constants.PUTSTATIC] = ExceptionConstants.EXCS_FIELD_AND_METHOD_RESOLUTION_GETSTATIC_PUTSTATIC;
+
+		Constants.instFlags[Constants.INVOKEINTERFACE] = Constants.EXCEPTION_THROWER | Constants.CP_INST | Constants.LOADCLASS_INST
+				| Constants.INDEXED;
+		Constants.instExcs[Constants.INVOKEINTERFACE] = ExceptionConstants.EXCS_INTERFACE_METHOD_RESOLUTION_INVOKEINTERFACE;
+		Constants.instFlags[Constants.INVOKESPECIAL] = Constants.EXCEPTION_THROWER | Constants.CP_INST | Constants.LOADCLASS_INST
+				| Constants.INDEXED;
+		Constants.instExcs[Constants.INVOKESPECIAL] = ExceptionConstants.EXCS_INTERFACE_METHOD_RESOLUTION_INVOKESPECIAL_INVOKEVIRTUAL;
+		Constants.instFlags[Constants.INVOKESTATIC] = Constants.EXCEPTION_THROWER | Constants.CP_INST | Constants.LOADCLASS_INST
+				| Constants.INDEXED;
+		Constants.instExcs[Constants.INVOKESTATIC] = ExceptionConstants.EXCS_INTERFACE_METHOD_RESOLUTION_INVOKESTATIC;
+		Constants.instFlags[Constants.INVOKEVIRTUAL] = Constants.EXCEPTION_THROWER | Constants.CP_INST | Constants.LOADCLASS_INST
+				| Constants.INDEXED;
+		Constants.instExcs[Constants.INVOKEVIRTUAL] = ExceptionConstants.EXCS_INTERFACE_METHOD_RESOLUTION_INVOKESPECIAL_INVOKEVIRTUAL;
+
+		char[] lengths = // . = varies in length, / = undefined
+		("1111111111111111" + // nop > dconst_1
+				"2323322222111111" + // bipush > lload_1
+				"1111111111111111" + // lload_2 > laload
+				"1111112222211111" + // faload > lstore_0
+				"1111111111111111" + // lstore_1 > iastore
+				"1111111111111111" + // lastore > swap
+				"1111111111111111" + // iadd > ddiv
+				"1111111111111111" + // irem > land
+				"1111311111111111" + // ior > d2l
+				"1111111113333333" + // d2f > if_icmpeq
+				"3333333332..1111" + // if_icmpne > dreturn
+				"1133333335/32311" + // areturn > athrow
+				"3311.433551/////").toCharArray(); // checkcast >
+		int count = 0;
+		for (; count < lengths.length; count++) {
+			Constants.iLen[count] = (byte) (lengths[count] - 48);
+		}
+		while (count < 256) {
+			Constants.iLen[count] = Constants.UNDEFINED;
+			count++;
+		}
+		Constants.iLen[Constants.BREAKPOINT] = 1;
+		Constants.iLen[Constants.IMPDEP1] = 1;
+		Constants.iLen[Constants.IMPDEP2] = 1;
+
+		char[] producesOnStack = ("0111111112211122" + // nop > dconst_1
+				"1111212121111122" + // bipush > lload_1
+				"2211112222111112" + // lload_2 > laload
+				"1211110000000000" + // faload > lstore_0
+				"0000000000000000" + // lstore_1 > iastore
+				"0000000002344562" + // lastore > swap
+				"1212121212121212" + // iadd > ddiv
+				"1212121212121212" + // irem > land
+				"1212021211212212" + // ior > d2l
+				"1111111110000000" + // d2f > if_icmpeq
+				"0000000010000000" + // if_icmpne > dreturn
+				"00.0.0..../11111" + // areturn > athrow
+				"11000100010/").toCharArray(); // checkcast >
+		count = 0;
+		for (; count < producesOnStack.length; count++) {
+			Constants.stackEntriesProduced[count] = (byte) (producesOnStack[count] - 48);
+		}
+		while (count < 256) {
+			Constants.iLen[count] = Constants.UNDEFINED;
+			count++;
+		}
+		return null;
+	}
+}
\ No newline at end of file
@@ -60,6 +60,7 @@ import java.util.List;
 import java.util.Map;
 
 import org.aspectj.apache.bcel.Constants;
+import org.aspectj.apache.bcel.ConstantsInitializer;
 import org.aspectj.apache.bcel.classfile.ClassFormatException;
 import org.aspectj.apache.bcel.classfile.Utility;
 
@@ -67,7 +68,7 @@ import org.aspectj.apache.bcel.classfile.Utility;
  * Abstract super class for all possible java types, namely basic types such as int, object types like String and array types, e.g.
  * int[]
  * 
- * @version $Id: Type.java,v 1.13 2009/10/05 17:35:36 aclement Exp $
+ * @version $Id: Type.java,v 1.14 2011/09/28 01:14:54 aclement Exp $
  * @author <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
  * 
  *         modified: AndyClement 2-mar-05: Removed unnecessary static and optimized
@@ -135,7 +136,7 @@ public abstract class Type {
 		commonTypes.put(STRINGBUILDER.getSignature(), STRINGBUILDER);
 		commonTypes.put(LIST.getSignature(), LIST);
 		commonTypes.put(ITERATOR.getSignature(), ITERATOR);
-
+		ConstantsInitializer.initialize(); // needs calling because it will not have run properly the first time
 	}
 
 	protected Type(byte t, String s) {
Binary files differ
Binary files differ
Binary files differ
