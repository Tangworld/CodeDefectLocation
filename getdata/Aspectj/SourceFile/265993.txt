@@ -14,5 +14,7 @@ public class A<T> {
   public void m10(List<String>[][] m) {}
   public void m11(java.util.List<T> m) {}
   public void m12(T[] m) {}
+  public <T> void m13(Class<T> c, Object f, String d) {}
+
 
 }
@@ -815,6 +815,24 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 	// , code.getHandleIdentifier());
 	//
 	// }
+	
+	private IProgramElement findFile(IProgramElement whereToLook, String filesubstring) {
+		if (whereToLook.getSourceLocation() != null && whereToLook.getKind().equals(IProgramElement.Kind.FILE_ASPECTJ) && whereToLook.getSourceLocation().getSourceFile().toString().indexOf(filesubstring)!=-1) {
+			return whereToLook;
+		}
+		List kids = whereToLook.getChildren();
+		for (Iterator iterator = kids.iterator(); iterator.hasNext();) {
+			IProgramElement object = (IProgramElement) iterator.next();
+			if (object.getSourceLocation() != null &&  object.getKind().equals(IProgramElement.Kind.FILE_ASPECTJ) && object.getSourceLocation().getSourceFile().toString().indexOf(filesubstring)!=-1) {
+				return whereToLook;
+			}
+			IProgramElement gotSomething = findFile(object, filesubstring);
+			if (gotSomething != null) {
+				return gotSomething;
+			}
+		}
+		return null;
+	}
 
 	private IProgramElement findElementAtLine(IProgramElement whereToLook, int line) {
 		if (whereToLook == null) {
@@ -1029,10 +1047,10 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		initialiseProject(p);
 		build(p);
 		IProgramElement root = getModelFor(p).getHierarchy().getRoot();
-		dumptree(getModelFor(p).getHierarchy().getRoot(), 0);
-		PrintWriter pw = new PrintWriter(System.out);
-		getModelFor(p).dumprels(pw);
-		pw.flush();
+//		dumptree(getModelFor(p).getHierarchy().getRoot(), 0);
+//		PrintWriter pw = new PrintWriter(System.out);
+//		getModelFor(p).dumprels(pw);
+//		pw.flush();
 		assertEquals("=pr265993<{A.java[A~m~QString;~Qjava.lang.String;", findElementAtLine(root, 3).getHandleIdentifier());
 		assertEquals("=pr265993<{A.java[A~m2~QList;", findElementAtLine(root, 5).getHandleIdentifier());
 		assertEquals("=pr265993<{A.java[A~m3~Qjava.util.ArrayList;", findElementAtLine(root, 6).getHandleIdentifier());
@@ -1044,8 +1062,25 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		assertEquals("=pr265993<{A.java[A~m8~\\[Qjava.lang.String;", findElementAtLine(root, 12).getHandleIdentifier());
 		assertEquals("=pr265993<{A.java[A~m9~\\[QString;", findElementAtLine(root, 13).getHandleIdentifier());
 		assertEquals("=pr265993<{A.java[A~m10~\\[\\[QList\\<QString;>;", findElementAtLine(root, 14).getHandleIdentifier());
-		assertEquals("=pr265993<{A.java[A~m11~Qjava.util.List\\<TT;>;", findElementAtLine(root, 15).getHandleIdentifier());
-		assertEquals("=pr265993<{A.java[A~m12~\\[TT;", findElementAtLine(root, 16).getHandleIdentifier());
+		assertEquals("=pr265993<{A.java[A~m11~Qjava.util.List\\<QT;>;", findElementAtLine(root, 15).getHandleIdentifier());
+		assertEquals("=pr265993<{A.java[A~m12~\\[QT;", findElementAtLine(root, 16).getHandleIdentifier());
+		assertEquals("=pr265993<{A.java[A~m13~QClass\\<QT;>;~QObject;~QString;", findElementAtLine(root, 17).getHandleIdentifier());
+	}
+	
+	public void testX() throws IOException {
+		String p = "prx";
+		initialiseProject(p);
+		build(p);
+		IProgramElement root = getModelFor(p).getHierarchy().getRoot();
+		dumptree(getModelFor(p).getHierarchy().getRoot(), 0);
+		PrintWriter pw = new PrintWriter(System.out);
+		getModelFor(p).dumprels(pw);
+		pw.flush();
+		
+		IProgramElement ff = findFile(root,"ProcessAspect.aj");
+
+		assertEquals("=prx<com.kronos.aspects*ProcessAspect.aj}ProcessAspect&after&QMyProcessor;", findElementAtLine(root, 22).getHandleIdentifier());
+		assertEquals("=prx<com.kronos.aspects*ProcessAspect.aj}ProcessAspect&after&QMyProcessor;!2", findElementAtLine(root, 68).getHandleIdentifier());
 	}
 
 	/**
@@ -330,22 +330,14 @@ public class AsmElementFormatter {
 			if (typeB.leafComponentType().isBaseType()) {
 				handleSig.append(tb.leafComponentType().signature());
 			} else {
-				if (typeB.leafComponentType().isTypeVariable()) {
-					handleSig.append('T').append(atr.token).append(';');
-				} else {
-					handleSig.append('Q').append(atr.token).append(';');
-				}
+				handleSig.append('Q').append(atr.token).append(';');
 			}
 		} else if (ref instanceof SingleTypeReference) {
 			SingleTypeReference str = (SingleTypeReference) ref;
 			if (tb.isBaseType()) {
 				handleSig.append(tb.signature());
 			} else {
-				if (tb.isTypeVariable()) {
-					handleSig.append('T').append(str.token).append(';');
-				} else {
-					handleSig.append('Q').append(str.token).append(';');
-				}
+				handleSig.append('Q').append(str.token).append(';');
 			}
 		} else if (ref instanceof ParameterizedQualifiedTypeReference) {
 			ParameterizedQualifiedTypeReference pstr = (ParameterizedQualifiedTypeReference) ref;
@@ -599,11 +599,12 @@ public class AsmRelationshipProvider {
 	}
 
 	private static void setParams(IProgramElement pe, ResolvedMember sig) {
+		// do it for itds too
 		UnresolvedType[] ts = sig.getParameterTypes();
 		pe.setParameterNames(Collections.EMPTY_LIST);
 		String[] pnames = sig.getParameterNames();
 		if (ts == null) {
-			pe.setParameterSignatures(Collections.EMPTY_LIST);
+			pe.setParameterSignatures(Collections.EMPTY_LIST, Collections.EMPTY_LIST);
 		} else {
 			List paramSigs = new ArrayList();
 			List paramNames = new ArrayList();
@@ -611,7 +612,7 @@ public class AsmRelationshipProvider {
 				paramSigs.add(ts[i].getSignature().toCharArray());
 				// paramNames.add(pnames[i]);
 			}
-			pe.setParameterSignatures(paramSigs);
+			pe.setParameterSignatures(paramSigs, Collections.EMPTY_LIST);
 			// pe.setParameterNames(paramNames);
 		}
 		pe.setCorrespondingType(sig.getReturnType().getName());
@@ -13,12 +13,12 @@
       Foo  [class] TEST_SANDBOX\pr131932.aj:19:
 === END OF MODEL REPORT =========
 === RELATIONSHIPS REPORT ========= After a batch build
+(targets=1) <*pr131932.aj}Slide74)Foo.Foo_new)QList\<TT;>; (declared on) <*pr131932.aj[Foo
 (targets=1) <*pr131932.aj}Slide74)Bar.children (declared on) <*pr131932.aj}Slide74[Bar
-(targets=1) <*pr131932.aj}Slide74)Bar.getFirst (declared on) <*pr131932.aj}Slide74[Bar
-(targets=1) <*pr131932.aj[Foo (aspect declarations) <*pr131932.aj}Slide74)Foo.Foo_new)Qjava.util.List\<TT;>;
 (targets=2) <*pr131932.aj}Slide74[Bar (aspect declarations) <*pr131932.aj}Slide74)Bar.getFirst
 (targets=2) <*pr131932.aj}Slide74[Bar (aspect declarations) <*pr131932.aj}Slide74)Bar.children
-(targets=1) <*pr131932.aj}Slide74)Foo.Foo_new)Qjava.util.List\<TT;>; (declared on) <*pr131932.aj[Foo
+(targets=1) <*pr131932.aj}Slide74)Bar.getFirst (declared on) <*pr131932.aj}Slide74[Bar
+(targets=1) <*pr131932.aj[Foo (aspect declarations) <*pr131932.aj}Slide74)Foo.Foo_new)QList\<TT;>;
 === END OF RELATIONSHIPS REPORT ==
 === Properties of the model and relationships map =====
 import reference=2
@@ -19,28 +19,28 @@
       MyClass  [class] TEST_SANDBOX\pr141730.aj:33:
 === END OF MODEL REPORT =========
 === RELATIONSHIPS REPORT ========= After a batch build
-(targets=1) <*pr141730.aj[C~main~\[QString; (advised by) <*pr141730.aj}A&before
+(targets=1) <*pr141730.aj[C~intArray~\[I (advised by) <*pr141730.aj}A&before
+(targets=1) <*pr141730.aj[C~myClassMethod~QMyClass; (advised by) <*pr141730.aj}A&before
 (targets=1) <*pr141730.aj[C~method (advised by) <*pr141730.aj}A&before
-(targets=1) <*pr141730.aj[MyClass (advised by) <*pr141730.aj}A&before
-(targets=1) <*pr141730.aj[C~twoArgsMethod~I~QString; (advised by) <*pr141730.aj}A&before
 (targets=1) <*pr141730.aj[C~intMethod~I (advised by) <*pr141730.aj}A&before
+(targets=1) <*pr141730.aj[C~C (advised by) <*pr141730.aj}A&before
+(targets=1) <*pr141730.aj[C~multiMethod~\[\[QString; (advised by) <*pr141730.aj}A&before
+(targets=1) <*pr141730.aj[C~twoArgsMethod~I~QString; (advised by) <*pr141730.aj}A&before
+(targets=1) <*pr141730.aj[MyClass (advised by) <*pr141730.aj}A&before
 (targets=11) <*pr141730.aj}A&before (advises) <*pr141730.aj}A
 (targets=11) <*pr141730.aj}A&before (advises) <*pr141730.aj[MyClass
 (targets=11) <*pr141730.aj}A&before (advises) <*pr141730.aj[C~C
 (targets=11) <*pr141730.aj}A&before (advises) <*pr141730.aj[C~method
 (targets=11) <*pr141730.aj}A&before (advises) <*pr141730.aj[C~intMethod~I
 (targets=11) <*pr141730.aj}A&before (advises) <*pr141730.aj[C~stringMethod~QString;
-(targets=11) <*pr141730.aj}A&before (advises) <*pr141730.aj[C~myClassMethod~LMyClass;
+(targets=11) <*pr141730.aj}A&before (advises) <*pr141730.aj[C~myClassMethod~QMyClass;
 (targets=11) <*pr141730.aj}A&before (advises) <*pr141730.aj[C~twoArgsMethod~I~QString;
 (targets=11) <*pr141730.aj}A&before (advises) <*pr141730.aj[C~main~\[QString;
 (targets=11) <*pr141730.aj}A&before (advises) <*pr141730.aj[C~multiMethod~\[\[QString;
 (targets=11) <*pr141730.aj}A&before (advises) <*pr141730.aj[C~intArray~\[I
-(targets=1) <*pr141730.aj[C~multiMethod~\[\[QString; (advised by) <*pr141730.aj}A&before
-(targets=1) <*pr141730.aj[C~stringMethod~QString; (advised by) <*pr141730.aj}A&before
-(targets=1) <*pr141730.aj[C~intArray~\[I (advised by) <*pr141730.aj}A&before
-(targets=1) <*pr141730.aj[C~myClassMethod~LMyClass; (advised by) <*pr141730.aj}A&before
-(targets=1) <*pr141730.aj[C~C (advised by) <*pr141730.aj}A&before
 (targets=1) <*pr141730.aj}A (advised by) <*pr141730.aj}A&before
+(targets=1) <*pr141730.aj[C~main~\[QString; (advised by) <*pr141730.aj}A&before
+(targets=1) <*pr141730.aj[C~stringMethod~QString; (advised by) <*pr141730.aj}A&before
 === END OF RELATIONSHIPS REPORT ==
 === Properties of the model and relationships map =====
 method=8
@@ -14,18 +14,18 @@
       MyGenericClass  [class] TEST_SANDBOX\pr141730.aj:22:
 === END OF MODEL REPORT =========
 === RELATIONSHIPS REPORT ========= After a batch build
-(targets=1) <*pr141730.aj[MyGenericClass (advised by) <*pr141730.aj}A&before
+(targets=1) <*pr141730.aj[C~genericMethod2~QMyGenericClass\<QString;QMyClass;>; (advised by) <*pr141730.aj}A&before
 (targets=1) <*pr141730.aj[MyClass (advised by) <*pr141730.aj}A&before
-(targets=1) <*pr141730.aj[C~genericMethod~Qjava.util.List\<QString;>; (advised by) <*pr141730.aj}A&before
+(targets=1) <*pr141730.aj[MyGenericClass (advised by) <*pr141730.aj}A&before
+(targets=1) <*pr141730.aj[C~genericMethod~QList\<QString;>; (advised by) <*pr141730.aj}A&before
 (targets=6) <*pr141730.aj}A&before (advises) <*pr141730.aj}A
 (targets=6) <*pr141730.aj}A&before (advises) <*pr141730.aj[C
-(targets=6) <*pr141730.aj}A&before (advises) <*pr141730.aj[C~genericMethod~Qjava.util.List\<QString;>;
-(targets=6) <*pr141730.aj}A&before (advises) <*pr141730.aj[C~genericMethod2~QMyGenericClass\<QString;LMyClass;>;
-(targets=6) <*pr141730.aj}A&before (advises) <*pr141730.aj[MyClass
+(targets=6) <*pr141730.aj}A&before (advises) <*pr141730.aj[C~genericMethod~QList\<QString;>;
+(targets=6) <*pr141730.aj}A&before (advises) <*pr141730.aj[C~genericMethod2~QMyGenericClass\<QString;QMyClass;>;
 (targets=6) <*pr141730.aj}A&before (advises) <*pr141730.aj[MyGenericClass
-(targets=1) <*pr141730.aj[C (advised by) <*pr141730.aj}A&before
-(targets=1) <*pr141730.aj[C~genericMethod2~QMyGenericClass\<QString;LMyClass;>; (advised by) <*pr141730.aj}A&before
+(targets=6) <*pr141730.aj}A&before (advises) <*pr141730.aj[MyClass
 (targets=1) <*pr141730.aj}A (advised by) <*pr141730.aj}A&before
+(targets=1) <*pr141730.aj[C (advised by) <*pr141730.aj}A&before
 === END OF RELATIONSHIPS REPORT ==
 === Properties of the model and relationships map =====
 method=2
@@ -0,0 +1,18 @@
+import java.util.Map; import java.util.List;
+public class A<T> {
+  public void m(String s1,java.lang.String s2) {
+  }
+  public void m2(List l) {}
+  public void m3(java.util.ArrayList l) {}
+
+  public void m4(Map<java.lang.String,List> m) {}
+  public void m5(java.util.Map<java.lang.String,List> m) {} // parameterized qualified
+  public void m6(Map<int[], List> mm) {} // single parameterized with array
+  public void m7(int[] mm) {} // primitive array
+  public void m8(java.lang.String[] mm) {} 
+  public void m9(String[] mm) {} 
+  public void m10(List<String>[][] m) {}
+  public void m11(java.util.List<T> m) {}
+  public void m12(T[] m) {}
+
+}
@@ -985,6 +985,30 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		assertEquals("=AspectPath4/binaries<(Asp2.class}Asp2&before", findElementAtLine(root, 16).getHandleIdentifier());
 	}
 
+	public void testHandleQualification_pr265993() throws IOException {
+		String p = "pr265993";
+		initialiseProject(p);
+		build(p);
+		IProgramElement root = getModelFor(p).getHierarchy().getRoot();
+		dumptree(getModelFor(p).getHierarchy().getRoot(), 0);
+		PrintWriter pw = new PrintWriter(System.out);
+		getModelFor(p).dumprels(pw);
+		pw.flush();
+		assertEquals("=pr265993<{A.java[A~m~QString;~Qjava.lang.String;", findElementAtLine(root, 3).getHandleIdentifier());
+		assertEquals("=pr265993<{A.java[A~m2~QList;", findElementAtLine(root, 5).getHandleIdentifier());
+		assertEquals("=pr265993<{A.java[A~m3~Qjava.util.ArrayList;", findElementAtLine(root, 6).getHandleIdentifier());
+		assertEquals("=pr265993<{A.java[A~m4~QMap\\<Qjava.lang.String;QList;>;", findElementAtLine(root, 8).getHandleIdentifier());
+		assertEquals("=pr265993<{A.java[A~m5~Qjava.util.Map\\<Qjava.lang.String;QList;>;", findElementAtLine(root, 9)
+				.getHandleIdentifier());
+		assertEquals("=pr265993<{A.java[A~m6~QMap\\<\\[IQList;>;", findElementAtLine(root, 10).getHandleIdentifier());
+		assertEquals("=pr265993<{A.java[A~m7~\\[I", findElementAtLine(root, 11).getHandleIdentifier());
+		assertEquals("=pr265993<{A.java[A~m8~\\[Qjava.lang.String;", findElementAtLine(root, 12).getHandleIdentifier());
+		assertEquals("=pr265993<{A.java[A~m9~\\[QString;", findElementAtLine(root, 13).getHandleIdentifier());
+		assertEquals("=pr265993<{A.java[A~m10~\\[\\[QList\\<QString;>;", findElementAtLine(root, 14).getHandleIdentifier());
+		assertEquals("=pr265993<{A.java[A~m11~Qjava.util.List\\<TT;>;", findElementAtLine(root, 15).getHandleIdentifier());
+		assertEquals("=pr265993<{A.java[A~m12~\\[TT;", findElementAtLine(root, 16).getHandleIdentifier());
+	}
+
 	/**
 	 * A change is made to an aspect on the aspectpath (staticinitialization() advice is added) for another project.
 	 * <p>
@@ -336,9 +336,9 @@ public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	public void testGetParameterSignaturesWithGenerics_pr141730() {
 		runTest("new iprogramelement method getParameterSignatures with generics");
 
-		checkGetParamSigOfMethod("genericMethod(java.util.List<java.lang.String>)", "Pjava/util/List<Ljava/lang/String;>;");
+		checkGetParamSigOfMethod("genericMethod(java.util.List<java.lang.String>)", "Ljava/util/List<Ljava/lang/String;>;");
 		checkGetParamSigOfMethod("genericMethod2(MyGenericClass<java.lang.String,MyClass>)",
-				"PMyGenericClass<Ljava/lang/String;LMyClass;>;");
+				"LMyGenericClass<Ljava/lang/String;LMyClass;>;");
 	}
 
 	// public void testFunkyGenericErrorWithITDs_pr126355_2() {
@@ -499,7 +499,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 		// ~genericMethod1~QList\<QString;>;
 		runTest("method with generic arg same as jdt");
 		compareHandles(IProgramElement.Kind.METHOD, "genericMethod1(java.util.List<java.lang.String>)",
-				"<pkg{Java5Class.java[Java5Class~genericMethod1~Qjava.util.List\\<QString;>;");
+				"<pkg{Java5Class.java[Java5Class~genericMethod1~QList\\<QString;>;");
 	}
 
 	public void testMethodWithTwoGenericArgsSameAsJDT() {
@@ -507,8 +507,8 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 		// ~genericMethod2~QList\<QString;>;~QMyGenericClass\<QInteger;>;
 		runTest("method with two generic args same as jdt");
 		compareHandles(IProgramElement.Kind.METHOD, "genericMethod2(java.util.List<java.lang.String>,"
-				+ "pkg.MyGenericClass<java.lang.Integer>)", "<pkg{Java5Class.java[Java5Class~genericMethod2~Qjava.util.List"
-				+ "\\<QString;>;~Qpkg.MyGenericClass\\<QInteger;>;");
+				+ "pkg.MyGenericClass<java.lang.Integer>)", "<pkg{Java5Class.java[Java5Class~genericMethod2~QList"
+				+ "\\<QString;>;~QMyGenericClass\\<QInteger;>;");
 	}
 
 	public void testMethodWithTwoTypeParametersSameAsJDT() {
@@ -516,7 +516,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 		// ~QMyGenericClass2\<QString;QInteger;>;
 		runTest("method with two type parameters same as jdt");
 		compareHandles(IProgramElement.Kind.METHOD, "genericMethod4(pkg.MyGenericClass2<java.lang.String,java.lang.Integer>)",
-				"<pkg{Java5Class.java[Java5Class~genericMethod4" + "~Qpkg.MyGenericClass2\\<QString;QInteger;>;");
+				"<pkg{Java5Class.java[Java5Class~genericMethod4" + "~QMyGenericClass2\\<QString;QInteger;>;");
 	}
 
 	public void testMethodWithTwoArgsSameAsJDT_2() {
@@ -524,7 +524,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 		// ~genericMethod3~I~QList\<QString;>;
 		runTest("method with two args one of which is generic same as jdt");
 		compareHandles(IProgramElement.Kind.METHOD, "genericMethod3(int,java.util.List<java.lang.String>)",
-				"<pkg{Java5Class.java[Java5Class~genericMethod3~I~Qjava.util.List\\<QString;>;");
+				"<pkg{Java5Class.java[Java5Class~genericMethod3~I~QList\\<QString;>;");
 	}
 
 	/*
@@ -127,10 +127,10 @@ public class Ajc163Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		IProgramElement ipe = null;
 		ipe = findElementAtLine(top.getRoot(), 4);// public java.util.List<String> Ship.i(List<String>[][] u)
-		assertEquals("<{Handles.java}Handles)Ship.i)\\[\\[Qjava.util.List\\<QString;>;", ipe.getHandleIdentifier());
+		assertEquals("<{Handles.java}Handles)Ship.i)\\[\\[QList\\<QString;>;", ipe.getHandleIdentifier());
 
 		ipe = findElementAtLine(top.getRoot(), 7);// public java.util.List<String> Ship.i(Set<String>[][] u)
-		assertEquals("<{Handles.java}Handles)Ship.i)\\[\\[Qjava.util.Set\\<QString;>;", ipe.getHandleIdentifier());
+		assertEquals("<{Handles.java}Handles)Ship.i)\\[\\[QSet\\<QString;>;", ipe.getHandleIdentifier());
 
 		// public java.util.Set<String> i(java.util.Set<String>[][] u)
 		ipe = findElementAtLine(top.getRoot(), 10);
@@ -139,7 +139,8 @@ public class Ajc163Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		ipe = findElementAtLine(top.getRoot(), 13);// public java.util.Set<String> i(java.util.Set<String>[][] u,int i) {
 		assertEquals("<{Handles.java}Handles~i~\\[\\[Qjava.util.Set\\<QString;>;~I", ipe.getHandleIdentifier());
 
-		ipe = findElementAtLine(top.getRoot(), 16);// public java.util.Set<String> i(java.util.Set<String>[][] u,int i) {
+		ipe = findElementAtLine(top.getRoot(), 16);// public java.util.Set<String> i2(java.util.Set<? extends
+													// Collection<String>>[][] u) {
 		assertEquals("<{Handles.java}Handles~i2~\\[\\[Qjava.util.Set\\<+QCollection\\<QString;>;>;", ipe.getHandleIdentifier());
 
 		ipe = findElementAtLine(top.getRoot(), 19);// public java.util.Set<String> i3(java.util.Set<? extends
@@ -25,13 +25,20 @@ import org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration;
 import org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration;
 import org.aspectj.ajdt.internal.compiler.ast.PointcutDeclaration;
 import org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment;
-import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Argument;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Wildcard;
+import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.aspectj.weaver.AdviceKind;
 import org.aspectj.weaver.ResolvedType;
@@ -261,14 +268,160 @@ public class AsmElementFormatter {
 	// return args;
 	// }
 
+	private String handleSigForReference(TypeReference ref, TypeBinding tb, MethodScope scope) {
+		try {
+			StringBuffer sb = new StringBuffer();
+			createHandleSigForReference(ref, tb, scope, sb);
+			return sb.toString();
+		} catch (Throwable t) {
+			System.err.println("Problem creating handle sig for this type reference " + ref);
+			t.printStackTrace(System.err);
+			return null;
+		}
+	}
+
+	/**
+	 * Aim of this method is create the signature for a parameter that can be used in a handle such that JDT can interpret the
+	 * handle. Whether a type is qualified or unqualified in its source reference is actually reflected in the handle and this code
+	 * allows for that.
+	 */
+	private void createHandleSigForReference(TypeReference ref, TypeBinding tb, MethodScope scope, StringBuffer handleSig) {
+		if (ref instanceof Wildcard) {
+			Wildcard w = (Wildcard) ref;
+			if (w.bound == null) {
+				handleSig.append('*');
+			} else {
+				handleSig.append('+');
+				TypeBinding typeB = w.bound.resolvedType;
+				if (typeB == null) {
+					typeB = w.bound.resolveType(scope);
+				}
+				createHandleSigForReference(w.bound, typeB, scope, handleSig);
+			}
+		} else if (ref instanceof ParameterizedSingleTypeReference) {
+			ParameterizedSingleTypeReference pstr = (ParameterizedSingleTypeReference) ref;
+			for (int i = pstr.dimensions(); i > 0; i--) {
+				handleSig.append("\\[");
+			}
+			handleSig.append('Q').append(pstr.token);
+			TypeReference[] typeRefs = pstr.typeArguments;
+			if (typeRefs != null && typeRefs.length > 0) {
+				handleSig.append("\\<");
+				for (int i = 0; i < typeRefs.length; i++) {
+					TypeReference typeR = typeRefs[i];
+					TypeBinding typeB = typeR.resolvedType;
+					if (typeB == null) {
+						typeB = typeR.resolveType(scope);
+					}
+					createHandleSigForReference(typeR, typeB, scope, handleSig);
+				}
+				handleSig.append('>');
+			}
+			handleSig.append(';');
+		} else if (ref instanceof ArrayTypeReference) {
+			ArrayTypeReference atr = (ArrayTypeReference) ref;
+			for (int i = 0; i < atr.dimensions; i++) {
+				handleSig.append("\\[");
+			}
+			TypeBinding typeB = atr.resolvedType;
+			if (typeB == null) {
+				typeB = atr.resolveType(scope);
+			}
+			if (typeB.leafComponentType().isBaseType()) {
+				handleSig.append(tb.leafComponentType().signature());
+			} else {
+				if (typeB.leafComponentType().isTypeVariable()) {
+					handleSig.append('T').append(atr.token).append(';');
+				} else {
+					handleSig.append('Q').append(atr.token).append(';');
+				}
+			}
+		} else if (ref instanceof SingleTypeReference) {
+			SingleTypeReference str = (SingleTypeReference) ref;
+			if (tb.isBaseType()) {
+				handleSig.append(tb.signature());
+			} else {
+				if (tb.isTypeVariable()) {
+					handleSig.append('T').append(str.token).append(';');
+				} else {
+					handleSig.append('Q').append(str.token).append(';');
+				}
+			}
+		} else if (ref instanceof ParameterizedQualifiedTypeReference) {
+			ParameterizedQualifiedTypeReference pstr = (ParameterizedQualifiedTypeReference) ref;
+			char[][] tokens = pstr.tokens;
+			for (int i = pstr.dimensions(); i > 0; i--) {
+				handleSig.append("\\[");
+			}
+			handleSig.append('Q');
+			for (int i = 0; i < tokens.length; i++) {
+				if (i > 0) {
+					handleSig.append('.');
+				}
+				handleSig.append(tokens[i]);
+				TypeReference[] typeRefs = pstr.typeArguments[i];
+				if (typeRefs != null && typeRefs.length > 0) {
+					handleSig.append("\\<");
+					for (int j = 0; j < typeRefs.length; j++) {
+						TypeReference typeR = typeRefs[j];
+						TypeBinding typeB = typeR.resolvedType;
+						if (typeB == null) {
+							typeB = typeR.resolveType(scope);
+						}
+						createHandleSigForReference(typeR, typeB, scope, handleSig);
+					}
+					handleSig.append('>');
+				}
+			}
+			handleSig.append(';');
+		} else if (ref instanceof ArrayQualifiedTypeReference) {
+			ArrayQualifiedTypeReference atr = (ArrayQualifiedTypeReference) ref;
+			for (int i = 0; i < atr.dimensions(); i++) {
+				handleSig.append("\\[");
+			}
+			TypeBinding typeB = atr.resolvedType;
+			if (typeB == null) {
+				typeB = atr.resolveType(scope);
+			}
+			if (typeB.leafComponentType().isBaseType()) {
+				handleSig.append(tb.leafComponentType().signature());
+			} else {
+				char[][] tokens = atr.tokens;
+				handleSig.append('Q');
+				for (int i = 0; i < tokens.length; i++) {
+					if (i > 0) {
+						handleSig.append('.');
+					}
+					handleSig.append(tokens[i]);
+				}
+				handleSig.append(';');
+			}
+		} else if (ref instanceof QualifiedTypeReference) {
+			QualifiedTypeReference qtr = (QualifiedTypeReference) ref;
+			char[][] tokens = qtr.tokens;
+			handleSig.append('Q');
+			for (int i = 0; i < tokens.length; i++) {
+				if (i > 0) {
+					handleSig.append('.');
+				}
+				handleSig.append(tokens[i]);
+			}
+			handleSig.append(';');
+		} else {
+			throw new RuntimeException("Cant handle " + ref.getClass());
+		}
+	}
+
 	public void setParameters(AbstractMethodDeclaration md, IProgramElement pe) {
 		Argument[] argArray = md.arguments;
 		if (argArray == null) {
 			pe.setParameterNames(Collections.EMPTY_LIST);
-			pe.setParameterSignatures(Collections.EMPTY_LIST);
+			pe.setParameterSignatures(Collections.EMPTY_LIST, Collections.EMPTY_LIST);
 		} else {
 			List names = new ArrayList();
 			List paramSigs = new ArrayList();
+			List paramSourceRefs = new ArrayList();
+			boolean problemWithSourceRefs = false;
 			for (int i = 0; i < argArray.length; i++) {
 				String argName = new String(argArray[i].name);
 				// String argType = "<UnknownType>"; // pr135052
@@ -279,16 +432,24 @@ public class AsmElementFormatter {
 						if (typeB == null) {
 							typeB = typeR.resolveType(md.scope);
 						}
-						EclipseFactory factory = EclipseFactory.fromScopeLookupEnvironment(md.scope);
-						UnresolvedType ut = factory.fromBinding(typeB);
-						paramSigs.add(ut.getSignature().toCharArray());
+						// This code will conjure up a 'P' style signature:
+						// EclipseFactory factory = EclipseFactory.fromScopeLookupEnvironment(md.scope);
+						// UnresolvedType ut = factory.fromBinding(typeB);
+						// paramSigs.add(ut.getSignature().toCharArray());
+						paramSigs.add(typeB.genericTypeSignature());
+						String hsig = handleSigForReference(typeR, typeB, md.scope);
+						if (hsig == null) {
+							problemWithSourceRefs = true;
+						} else {
+							paramSourceRefs.add(hsig);
+						}
 					}
 					names.add(argName);
 				}
 			}
 			pe.setParameterNames(names);
 			if (!paramSigs.isEmpty()) {
-				pe.setParameterSignatures(paramSigs);
+				pe.setParameterSignatures(paramSigs, (problemWithSourceRefs ? null : paramSourceRefs));
 			}
 		}
 	}
@@ -10,77 +10,77 @@
  *******************************************************************/
 package org.aspectj.asm;
 
+import junit.framework.TestCase;
+
 import org.aspectj.asm.internal.CharOperation;
 import org.aspectj.asm.internal.NameConvertor;
 
-import junit.framework.TestCase;
-
 public class NameConvertorTest extends TestCase {
 
 	public void testBoolean() {
-		checkConversion("Z","boolean");
+		checkConversion("Z", "boolean");
 	}
-	
+
 	public void testByte() {
-		checkConversion("B","byte");
+		checkConversion("B", "byte");
 	}
-	
+
 	public void testChar() {
-		checkConversion("C","char");
-	}	
-	
+		checkConversion("C", "char");
+	}
+
 	public void testDouble() {
-		checkConversion("D","double");
-	}	
-	
+		checkConversion("D", "double");
+	}
+
 	public void testFloat() {
-		checkConversion("F","float");
+		checkConversion("F", "float");
 	}
-	
+
 	public void testInt() {
-		checkConversion("I","int");
+		checkConversion("I", "int");
 	}
-	
+
 	public void testLong() {
-		checkConversion("J","long");
-	}	
-	
+		checkConversion("J", "long");
+	}
+
 	public void testShort() {
-		checkConversion("S","short");
-	}	
-	
+		checkConversion("S", "short");
+	}
+
 	public void testString() {
-		checkConversion("Ljava/lang/String;","java.lang.String");
+		checkConversion("Ljava/lang/String;", "java.lang.String");
 	}
 
 	public void testType() {
-		checkConversion("LMyClass;","MyClass");
+		checkConversion("LMyClass;", "MyClass");
 	}
 
 	public void testListPameterizedWithString() {
-		checkConversion("Pjava/util/List<Ljava/lang/String;>;",
-				"java.util.List<java.lang.String>");
+		checkConversion("Pjava/util/List<Ljava/lang/String;>;", "java.util.List<java.lang.String>");
 	}
+
 	public void testClassParameterizedWithStringAndType() {
-		checkConversion("PMyGenericClass<Ljava/lang/String;LMyClass;>;",
-				"MyGenericClass<java.lang.String,MyClass>");
+		checkConversion("PMyGenericClass<Ljava/lang/String;LMyClass;>;", "MyGenericClass<java.lang.String,MyClass>");
 	}
+
 	public void testStringArray() {
-		checkConversion("[Ljava/lang/String;","java.lang.String[]");
+		checkConversion("[Ljava/lang/String;", "java.lang.String[]");
 	}
+
 	public void testTwoDimensionalStringArray() {
-		checkConversion("[[Ljava/lang/String;","java.lang.String[][]");
+		checkConversion("[[Ljava/lang/String;", "java.lang.String[][]");
 	}
+
 	public void testIntArray() {
-		checkConversion("[I","int[]");
+		checkConversion("[I", "int[]");
 	}
 
 	private void checkConversion(String signature, String expected) {
 		char[] c = NameConvertor.convertFromSignature(signature.toCharArray());
-		assertTrue("converting " + signature + ", expected " + expected + "," +
-				"but found " + String.valueOf(c),
-				CharOperation.equals(c,expected.toCharArray()));
+		assertTrue("converting " + signature + ", expected " + expected + "," + "but found " + String.valueOf(c), CharOperation
+				.equals(c, expected.toCharArray()));
 	}
 
-	
 }
@@ -158,7 +158,9 @@ public interface IProgramElement extends Serializable {
 
 	public List getParameterSignatures();
 
-	public void setParameterSignatures(List list);
+	public List getParameterSignaturesSourceRefs();
+
+	public void setParameterSignatures(List list, List paramSourceRefs);
 
 	public List getParameterTypes();
 
@@ -320,7 +322,8 @@ public interface IProgramElement extends Serializable {
 				INTERFACE, ASPECT, ENUM, ENUM_VALUE, ANNOTATION, INITIALIZER, INTER_TYPE_FIELD, INTER_TYPE_METHOD,
 				INTER_TYPE_CONSTRUCTOR, INTER_TYPE_PARENT, CONSTRUCTOR, METHOD, FIELD, POINTCUT, ADVICE, DECLARE_PARENTS,
 				DECLARE_WARNING, DECLARE_ERROR, DECLARE_SOFT, DECLARE_PRECEDENCE, CODE, ERROR, DECLARE_ANNOTATION_AT_CONSTRUCTOR,
-				DECLARE_ANNOTATION_AT_FIELD, DECLARE_ANNOTATION_AT_METHOD, DECLARE_ANNOTATION_AT_TYPE, SOURCE_FOLDER, PACKAGE_DECLARATION
+				DECLARE_ANNOTATION_AT_FIELD, DECLARE_ANNOTATION_AT_METHOD, DECLARE_ANNOTATION_AT_TYPE, SOURCE_FOLDER,
+				PACKAGE_DECLARATION
 
 		};
 
@@ -367,6 +370,7 @@ public interface IProgramElement extends Serializable {
 		public boolean isSourceFile() {
 			return this == FILE_ASPECTJ || this == FILE_JAVA;
 		}
+
 		public boolean isFile() {
 			return this == FILE;
 		}
@@ -128,12 +128,21 @@ public class JDTLikeHandleProvider implements IElementHandleProvider {
 		if (ipe.getParameterSignatures() == null || ipe.getParameterSignatures().isEmpty()) {
 			return "";
 		}
-		StringBuffer sb = new StringBuffer();
+		List sourceRefs = ipe.getParameterSignaturesSourceRefs();
 		List parameterTypes = ipe.getParameterSignatures();
-		for (Iterator iter = parameterTypes.iterator(); iter.hasNext();) {
-			char[] element = (char[]) iter.next();
-			sb.append(HandleProviderDelimiter.getDelimiter(ipe));
-			sb.append(NameConvertor.createShortName(element, false, false));
+		StringBuffer sb = new StringBuffer();
+		if (sourceRefs != null) {
+			for (int i = 0; i < sourceRefs.size(); i++) {
+				String sourceRef = (String) sourceRefs.get(i);
+				sb.append(HandleProviderDelimiter.getDelimiter(ipe));
+				sb.append(sourceRef);
+			}
+		} else {
+			for (Iterator iter = parameterTypes.iterator(); iter.hasNext();) {
+				char[] element = (char[]) iter.next();
+				sb.append(HandleProviderDelimiter.getDelimiter(ipe));
+				sb.append(NameConvertor.createShortName(element, false, false));
+			}
 		}
 		return sb.toString();
 	}
@@ -594,13 +594,28 @@ public class ProgramElement implements IProgramElement {
 		return parameters;
 	}
 
-	public void setParameterSignatures(List list) {
-		if (kvpairs == Collections.EMPTY_MAP)
+	public List getParameterSignaturesSourceRefs() {
+		List parameters = (List) kvpairs.get("parameterSigsSourceRefs");
+		return parameters;
+	}
+
+	/**
+	 * Set the parameter signatures for this method/constructor. The bit flags tell us if any were not singletypereferences in the
+	 * the source. A singletypereference would be 'String' - whilst a qualifiedtypereference would be 'java.lang.String' - this has
+	 * an effect on the handles.
+	 */
+	public void setParameterSignatures(List list, List sourceRefs) {
+		if (kvpairs == Collections.EMPTY_MAP) {
 			kvpairs = new HashMap();
-		if (list == null || list.size() == 0)
+		}
+		if (list == null || list.size() == 0) {
 			kvpairs.put("parameterSigs", Collections.EMPTY_LIST);
-		else
+		} else {
 			kvpairs.put("parameterSigs", list);
+		}
+		if (sourceRefs != null && sourceRefs.size() != 0) {
+			kvpairs.put("parameterSigsSourceRefs", sourceRefs);
+		}
 	}
 
 	public String getDetails() {
