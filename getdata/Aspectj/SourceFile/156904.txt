@@ -0,0 +1,12 @@
+package pkg;
+
+import pkg1.*;
+
+public aspect A {
+
+	pointcut innerpointcut() : execution( * Outer.myMethod() );
+
+	before() : innerpointcut() {
+	   System.out.println( "executing!" );
+	}
+}
@@ -0,0 +1,8 @@
+package pkg1;
+
+class Outer {
+
+	private void myMethod(){
+	}
+	
+}
@@ -0,0 +1,10 @@
+package pkg;
+
+public aspect A {
+
+	pointcut innerpointcut() : execution( * Outer.myMethod() );
+
+	before() : innerpointcut() {
+	   System.out.println( "executing!" );
+	}
+}
@@ -0,0 +1,8 @@
+package pkg1;
+
+class Outer {
+
+	private void myMethod(){
+	}
+	
+}
@@ -0,0 +1,19 @@
+package pkg;
+
+public aspect A {
+
+	pointcut innerpointcut() : execution( * Outer.Inner.myMethod() );
+
+	before() : innerpointcut() {
+	   System.out.println( "executing!" );
+	}
+
+}
+
+class Outer {
+	
+    private class Inner{
+    	private void myMethod(){
+    	}
+    }
+}
@@ -0,0 +1,11 @@
+package pkg;
+
+public aspect A {
+
+	pointcut innerpointcut() : execution( * Outer.Inner.myMethod() );
+
+	before() : innerpointcut() {
+	   System.out.println( "executing!" );
+	}
+	
+}
@@ -0,0 +1,10 @@
+package pkg;
+
+class Outer {
+
+    private class Inner{
+    	private void myMethod(){
+    	}
+    }
+	
+}
@@ -134,7 +134,13 @@ public class Ajc153Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	  runTest("NPE with custom agent");
   }
 
-    /////////////////////////////////////////
+  public void testNoInvalidAbsoluteTypeNameWarning_pr156904_1() {runTest("ensure no invalidAbsoluteTypeName when do match - 1");}
+  public void testNoInvalidAbsoluteTypeNameWarning_pr156904_2() {runTest("ensure no invalidAbsoluteTypeName when do match - 2");}
+  public void testNoInvalidAbsoluteTypeNameWarning_pr156904_3() {runTest("ensure no invalidAbsoluteTypeName when do match - 3");}
+  public void testNoInvalidAbsoluteTypeNameWarning_pr156904_4() {runTest("ensure no invalidAbsoluteTypeName when do match - 4");}
+
+  
+  /////////////////////////////////////////
   public static Test suite() {
     return XMLBasedAjcTestCase.loadSuite(Ajc153Tests.class);
   }
@@ -494,6 +494,24 @@
       <compile files="SampleTest.java"/>
     </ajc-test>
 
+    <ajc-test dir="bugs153/pr156904/inSameFile" title="ensure no invalidAbsoluteTypeName when do match - 1">
+      <compile files="A.aj"/>
+    </ajc-test>
+
+    <ajc-test dir="bugs153/pr156904/inDiffPkgAndImport" title="ensure no invalidAbsoluteTypeName when do match - 2">
+      <compile files="A.aj,Outer.java"/>
+    </ajc-test>
+
+    <ajc-test dir="bugs153/pr156904/inSamePkg" title="ensure no invalidAbsoluteTypeName when do match - 3">
+      <compile files="A.aj,Outer.java"/>
+    </ajc-test>
+
+    <ajc-test dir="bugs153/pr156904/inDiffPkgWithoutImport" title="ensure no invalidAbsoluteTypeName when do match - 4">
+      <compile files="A.aj,Outer.java">
+		<message kind="warning" line="5" text="no match for this type name: Outer [Xlint:invalidAbsoluteTypeName]"/>
+	  </compile>
+    </ajc-test>
+
 	<ajc-test dir="ltw" title="NPE with custom agent" keywords="ltw">
         <compile files="java/net/URLClassLoader.java"/>
         <compile files="HelloWorld.java" options="-outjar hello.jar"/>
@@ -687,7 +687,8 @@ public class WildTypePattern extends TypePattern {
 
 		//System.out.println("resolve: " + cleanName);
 		//??? this loop has too many inefficiencies to count
-		resolvedTypeInTheWorld = lookupTypeInWorld(scope.getWorld(), fullyQualifiedName);
+		resolvedTypeInTheWorld = lookupTypeInWorldIncludingPrefixes(scope.getWorld(), fullyQualifiedName, scope.getImportedPrefixes());
+
 		if (resolvedTypeInTheWorld.isGenericWildcard()) {
 			type = resolvedTypeInTheWorld;
 		} else {
@@ -712,6 +713,27 @@ public class WildTypePattern extends TypePattern {
 		return type;
 	}
 
+	/**
+	 * Searches the world for the ResolvedType with the given typeName. If one 
+	 * isn't found then for each of the supplied prefixes, it prepends the typeName
+	 * with the prefix and searches the world for the ResolvedType with this new name.
+	 * If one still isn't found then a MissingResolvedTypeWithKnownSignature is 
+	 * returned with the originally requested typeName (this ensures the typeName
+	 * makes sense).
+	 */
+	private ResolvedType lookupTypeInWorldIncludingPrefixes(World world, String typeName, String[] prefixes) {
+		ResolvedType ret = lookupTypeInWorld(world, typeName);
+		if (!ret.isMissing()) return ret; 
+		ResolvedType retWithPrefix = ret;
+		int counter = 0;
+		while (retWithPrefix.isMissing() && (counter < prefixes.length)) {
+			retWithPrefix = lookupTypeInWorld(world,prefixes[counter] + typeName);
+			counter++;
+		}
+		if (!retWithPrefix.isMissing()) return retWithPrefix;
+		return ret;
+	}
+	
 	private ResolvedType lookupTypeInWorld(World world, String typeName) {
 		ResolvedType ret = world.resolve(UnresolvedType.forName(typeName),true);
 		while (ret.isMissing()) {
