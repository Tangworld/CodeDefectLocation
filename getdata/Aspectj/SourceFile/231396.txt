@@ -20,6 +20,7 @@ import java.util.Map;
 import org.aspectj.util.FuzzyBoolean;
 import org.aspectj.weaver.AjcMemberMaker;
 import org.aspectj.weaver.ISourceContext;
+import org.aspectj.weaver.ResolvedMember;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.Shadow;
 import org.aspectj.weaver.VersionedDataInputStream;
@@ -30,6 +31,9 @@ import org.aspectj.weaver.ast.Test;
 import org.aspectj.weaver.bcel.BcelAccessForInlineMunger;
 
 public class PerSingleton extends PerClause {
+
+    private ResolvedMember perSingletonAspectOfMethod;
+
 	public PerSingleton() {
 	}
 
@@ -57,6 +61,7 @@ public class PerSingleton extends PerClause {
     	return this;
     }
 
+    
     public Test findResidueInternal(Shadow shadow, ExposedState state) {
         // TODO: the commented code is for slow Aspects.aspectOf() style - keep or remove
         //
@@ -71,9 +76,11 @@ public class PerSingleton extends PerClause {
         //    	// aspect before we are bound
         //        return Literal.TRUE;
 //        if (!Ajc5MemberMaker.isSlowAspect(inAspect)) {
-            Expr myInstance =
-                Expr.makeCallExpr(AjcMemberMaker.perSingletonAspectOfMethod(inAspect),
-                                    Expr.NONE, inAspect);
+    	if (perSingletonAspectOfMethod==null) {
+    	    // Build this just once
+    		perSingletonAspectOfMethod = AjcMemberMaker.perSingletonAspectOfMethod(inAspect);
+    	}
+            Expr myInstance = Expr.makeCallExpr(perSingletonAspectOfMethod, Expr.NONE, inAspect);
 
             state.setAspectInstance(myInstance);
 
@@ -2828,17 +2828,20 @@ class BcelClassWeaver implements IClassWeaver {
 	        return isMatched;
     	} else {
 	        boolean isMatched = false;
-	        for (Iterator i = shadowMungers.iterator(); i.hasNext(); ) {
-	            ShadowMunger munger = (ShadowMunger)i.next();
+	        int max = shadowMungers.size();
+	        for (int i=0;i<max;i++) {
+	        	ShadowMunger munger = (ShadowMunger)shadowMungers.get(i);
 	            if (munger.match(shadow, world)) {
 	                shadow.addMunger(munger);
 	                isMatched = true;
-				    if (shadow.getKind() == Shadow.StaticInitialization) {
-					  clazz.warnOnAddedStaticInitializer(shadow,munger.getSourceLocation());
-				    }
+	                if (shadow.getKind() == Shadow.StaticInitialization) {
+	  				  clazz.warnOnAddedStaticInitializer(shadow,munger.getSourceLocation());
+	  	        	}	
 	        	}
 	        }       	
-	        if (isMatched) shadowAccumulator.add(shadow);
+	        if (isMatched) {
+	        	shadowAccumulator.add(shadow);
+	        }
 	        return isMatched;
     	}
     }
@@ -151,52 +151,58 @@ public class MemberImpl implements Member {
      * @return     a pair of UnresolvedType, UnresolvedType[] representing the return types and parameter types. 
      */
     private static Object[] signatureToTypes(String sig,boolean keepParameterizationInfo) {
-        List l = new ArrayList();
-        int i = 1;
-        boolean hasAnyAnglies = sig.indexOf('<')!=-1;
-        while (true) {
-            char c = sig.charAt(i);
-            if (c == ')') break; // break out when the hit the ')'
-            int start = i;
-            while (c == '[') c = sig.charAt(++i);
-            if (c == 'L' || c == 'P') {
-				int nextSemicolon = sig.indexOf(';',start);
-				int firstAngly = (hasAnyAnglies?sig.indexOf('<',start):-1);
-				if (!hasAnyAnglies || firstAngly == -1 || firstAngly>nextSemicolon) {
-                  i = nextSemicolon + 1;
-                  l.add(UnresolvedType.forSignature(sig.substring(start, i)));
-				} else {
-					// generics generics generics
-					// Have to skip to the *correct* ';'
-					boolean endOfSigReached = false;
-					int posn = firstAngly;
-					int genericDepth=0;
-					while (!endOfSigReached) {
-						switch (sig.charAt(posn)) {
-						  case '<': genericDepth++;break;
-						  case '>': genericDepth--;break;
-						  case ';': if (genericDepth==0) endOfSigReached=true;break;
-						  default:
+    	boolean hasParameters = sig.charAt(1)!=')';
+    	if (hasParameters) {
+	        List l = new ArrayList();
+	        int i = 1;
+	        boolean hasAnyAnglies = sig.indexOf('<')!=-1;
+	        while (true) {
+	            char c = sig.charAt(i);
+	            if (c == ')') break; // break out when the hit the ')'
+	            int start = i;
+	            while (c == '[') c = sig.charAt(++i);
+	            if (c == 'L' || c == 'P') {
+					int nextSemicolon = sig.indexOf(';',start);
+					int firstAngly = (hasAnyAnglies?sig.indexOf('<',start):-1);
+					if (!hasAnyAnglies || firstAngly == -1 || firstAngly>nextSemicolon) {
+	                  i = nextSemicolon + 1;
+	                  l.add(UnresolvedType.forSignature(sig.substring(start, i)));
+					} else {
+						// generics generics generics
+						// Have to skip to the *correct* ';'
+						boolean endOfSigReached = false;
+						int posn = firstAngly;
+						int genericDepth=0;
+						while (!endOfSigReached) {
+							switch (sig.charAt(posn)) {
+							  case '<': genericDepth++;break;
+							  case '>': genericDepth--;break;
+							  case ';': if (genericDepth==0) endOfSigReached=true;break;
+							  default:
+							}
+							posn++;
 						}
-						posn++;
+						// posn now points to the correct nextSemicolon :)
+						i=posn;
+						l.add(UnresolvedType.forSignature(sig.substring(start,i)));					
 					}
-					// posn now points to the correct nextSemicolon :)
-					i=posn;
-					l.add(UnresolvedType.forSignature(sig.substring(start,i)));					
-				}
-            } else if (c=='T') { // assumed 'reference' to a type variable, so just "Tname;"
-				int nextSemicolon = sig.indexOf(';',start);
-				String nextbit = sig.substring(start,nextSemicolon);
-				l.add(UnresolvedType.forSignature(nextbit));
-				i=nextSemicolon+1;
-            } else {
-            	i++;
-                l.add(UnresolvedType.forSignature(sig.substring(start, i)));
-            }
-        }
-        UnresolvedType[] paramTypes = (UnresolvedType[]) l.toArray(new UnresolvedType[l.size()]);
-        UnresolvedType returnType = UnresolvedType.forSignature(sig.substring(i+1, sig.length()));
-        return new Object[] { returnType, paramTypes };
+	            } else if (c=='T') { // assumed 'reference' to a type variable, so just "Tname;"
+					int nextSemicolon = sig.indexOf(';',start);
+					String nextbit = sig.substring(start,nextSemicolon);
+					l.add(UnresolvedType.forSignature(nextbit));
+					i=nextSemicolon+1;
+	            } else {
+	            	i++;
+	                l.add(UnresolvedType.forSignature(sig.substring(start, i)));
+	            }
+	        }
+	        UnresolvedType[] paramTypes = (UnresolvedType[]) l.toArray(new UnresolvedType[l.size()]);
+	        UnresolvedType returnType = UnresolvedType.forSignature(sig.substring(i+1, sig.length()));
+	        return new Object[] { returnType, paramTypes };
+    	} else {
+	        UnresolvedType returnType = UnresolvedType.forSignature(sig.substring(2));
+	        return new Object[] { returnType, UnresolvedType.NONE };
+    	}
     }            
 
     // ---- factory methods
Binary files differ
Binary files differ
Binary files differ
Binary files differ
@@ -4,6 +4,9 @@ import  org.aspectj.apache.bcel.Constants;
 import org.aspectj.apache.bcel.generic.*;
 
 import  java.io.*;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
 /**
  * This class represents the constant pool, i.e., a table of constants, of
@@ -15,6 +18,9 @@ public class ConstantPool implements Node {
 	private Constant[] pool;
     private int        poolSize; // number of entries in the pool (could be < pool.length as the array is resized in 'chunks')
 
+    private Map utf8Cache = new HashMap();
+  	private Map methodCache = new HashMap();
+    
     public int getSize() { return poolSize; }
 
 	public ConstantPool() { 
@@ -228,10 +234,15 @@ public class ConstantPool implements Node {
 
 
     public int lookupUtf8(String string) {
+    	Integer pos = (Integer) utf8Cache.get(string);
+    	if (pos!=null) return pos.intValue();
     	for (int i=1;i<poolSize;i++) {
     		Constant c = pool[i];
     		if (c!=null && c.tag==Constants.CONSTANT_Utf8) {
-    			if (((ConstantUtf8)c).getBytes().equals(string)) return i;
+    			if (((ConstantUtf8)c).getBytes().equals(string)) {
+    				utf8Cache.put(string,new Integer(i));
+    				return i;
+    			}
     		}
     	}
     	return -1;
@@ -513,7 +524,7 @@ case Constants.CONSTANT_Fieldref: {
 return addInterfaceMethodref(class_name, name, signature);
 
   case Constants.CONSTANT_Methodref:
-return addMethodref(class_name, name, signature);
+return addMethodref(class_name, name, signature); // OPTIMIZE indicate it should be cached!
 
   case Constants.CONSTANT_Fieldref:
 return addFieldref(class_name, name, signature);
@@ -528,6 +539,7 @@ default: // Never reached
 }
 }
 
+  // OPTIMIZE should put it in the cache now
 	public int addMethodref(String class_name, String method_name, String signature) {
 	  int  ret, class_index, name_and_type_index;
 	  if((ret = lookupMethodref(class_name, method_name, signature)) != -1)
@@ -578,8 +590,12 @@ default: // Never reached
   	  }
 	  return -1;
   }
-	
-	  public int lookupMethodref(String searchClassname, String searchMethodName, String searchSignature) {
+  
+  	  
+	  public int lookupMethodref(String searchClassname, String searchMethodName, String searchSignature) {  
+		  String key = new StringBuffer().append(searchClassname).append(searchMethodName).append(searchSignature).toString();
+		  Integer cached = (Integer)methodCache.get(key);
+		  if (cached!=null) return cached.intValue();
 		  searchClassname = searchClassname.replace('.','/');
 		  for (int i=1;i<poolSize;i++) {
 	  		Constant c = pool[i];
@@ -598,6 +614,7 @@ default: // Never reached
 	  			if (!name.equals(searchMethodName)) continue; // not this one
 	  			String typeSignature = ((ConstantUtf8)pool[cnat.getSignatureIndex()]).getBytes();
 	  			if (!typeSignature.equals(searchSignature)) continue;
+	  			methodCache.put(key,new Integer(i));
 	  			return i;
 	  		}
 	  	  }
@@ -244,10 +244,6 @@ public class JoinPointSignature implements ResolvedMember {
 		return realMember.compareTo(other);
 	}
 
-	public String toLongString() {
-		return realMember.toLongString();
-	}
-
 	public MemberKind getKind() {
 		return realMember.getKind();
 	}
@@ -308,10 +304,6 @@ public class JoinPointSignature implements ResolvedMember {
 		return realMember.canBeParameterized();
 	}
 
-	public String getExtractableName() {
-		return realMember.getExtractableName();
-	}
-
 	public AnnotationX[] getAnnotations() {
 		return realMember.getAnnotations();
 	}
@@ -320,18 +312,6 @@ public class JoinPointSignature implements ResolvedMember {
 		throw new UnsupportedOperationException("Adrian doesn't think you should be calling this...");
 	}
 
-	public String getSignatureMakerName() {
-		return realMember.getSignatureMakerName();
-	}
-
-	public String getSignatureType() {
-		return realMember.getSignatureType();
-	}
-
-	public String getSignatureString(World world) {
-		return realMember.getSignatureString(world);
-	}
-
 	public Iterator getJoinPointSignatures(World world) {
 		return realMember.getJoinPointSignatures(world);
 	}
@@ -41,13 +41,12 @@ public interface Member extends Comparable {
 
     public int compareTo(Object other);
 
-	public String toLongString();
-
 	public UnresolvedType getDeclaringType();
 
 	public UnresolvedType getReturnType();
 
 	public UnresolvedType getGenericReturnType();
+	
 	public UnresolvedType[] getGenericParameterTypes();
 
 	public UnresolvedType getType();
@@ -87,18 +86,9 @@ public interface Member extends Comparable {
 	 */
 	public boolean canBeParameterized();
 
-	public String getExtractableName();
-
     public AnnotationX[] getAnnotations();
-
-	// ---- reflective thisJoinPoint stuff
-	public String getSignatureMakerName();
-
-	public String getSignatureType();
 
     public Collection/* ResolvedType */getDeclaringTypes(World world);
-    
-	public String getSignatureString(World world);
 
 	public String[] getParameterNames(World world);
 
@@ -22,7 +22,6 @@ import java.util.List;
 public class MemberImpl implements Member {
 
     protected MemberKind kind;
-
     protected int modifiers; 
     protected String name;
     protected UnresolvedType returnType;
@@ -34,12 +33,9 @@ public class MemberImpl implements Member {
     // OPTIMIZE move out of the member!
     private boolean reportedCantFindDeclaringType = false;
     private boolean reportedUnresolvableMember = false;
-
 
     /**
      * All the signatures that a join point with this member as its signature has.
-     * The fact that this has to go on MemberImpl and not ResolvedMemberImpl says a lot about
-     * how broken the Member/ResolvedMember distinction currently is.
      */
     private JoinPointSignatureIterator joinPointSignatures = null;
 
@@ -76,7 +72,6 @@ public class MemberImpl implements Member {
         String name, 
         UnresolvedType[] parameterTypes) 
     {
-        super();
         this.kind = kind;
         this.declaringType = declaringType;
         this.modifiers = modifiers;
@@ -211,6 +206,7 @@ public class MemberImpl implements Member {
     public static Member field(UnresolvedType declaring, int mods, String name, UnresolvedType type) {
         return new MemberImpl(FIELD, declaring, mods, type, name, UnresolvedType.NONE);
     }    
+    // OPTIMIZE do we need to call this? unless necessary the signatureToTypes() call smacks of laziness on the behalf of the caller of this method
     public static MemberImpl method(UnresolvedType declaring, int mods, String name, String signature) {
         Object[] pair = signatureToTypes(signature,false);
         return method(declaring, mods, (UnresolvedType) pair[0], name, (UnresolvedType[]) pair[1]);
@@ -250,6 +246,7 @@ public class MemberImpl implements Member {
             name,
             paramTys);
     }
+    
     private static Member pointcut(UnresolvedType declTy, int mods, UnresolvedType rTy, String name, UnresolvedType[] paramTys) {
         return new MemberImpl(
             POINTCUT,
@@ -269,10 +266,6 @@ public class MemberImpl implements Member {
 			"(" + catchType.getSignature() + ")V");
 	}
 
-    // ---- parsing methods
-    
-    // ---- things we know without resolution
-    
     public boolean equals(Object other) {
         if (! (other instanceof Member)) return false;
         Member o = (Member) other;
@@ -303,7 +296,6 @@ public class MemberImpl implements Member {
 
      public int compareTo(Object other) {
         Member o = (Member) other;
-
         int i = getName().compareTo(o.getName());
         if (i != 0) return i;
         return getSignature().compareTo(o.getSignature());
@@ -329,38 +321,13 @@ public class MemberImpl implements Member {
     	}
     	return buf.toString();
     }
-    
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#toLongString()
-	 */
-    public String toLongString() {
-        StringBuffer buf = new StringBuffer();
-        buf.append(kind);
-        buf.append(' ');
-        if (modifiers != 0) {
-            buf.append(Modifier.toString(modifiers));
-            buf.append(' ');
-        }
-        buf.append(toString());
-        buf.append(" <");
-        buf.append(signature);
-        buf.append(" >");
-        return buf.toString();
-    }        
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getKind()
-	 */
     public MemberKind getKind() {
         return kind;
     }
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getDeclaringType()
-	 */
+
     public UnresolvedType getDeclaringType() { return declaringType; }
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getReturnType()
-	 */
+
     public UnresolvedType getReturnType() { return returnType; }
 
     public UnresolvedType getGenericReturnType() { return getReturnType(); }
@@ -412,7 +379,7 @@ public class MemberImpl implements Member {
     }    
 
     public final boolean isInterface() {
-        return Modifier.isInterface(modifiers);  // this is kinda weird
+        return Modifier.isInterface(modifiers);
     }    
 
     public final boolean isPrivate() {
@@ -427,13 +394,6 @@ public class MemberImpl implements Member {
 		return modifiers;
 	}
 
-    public final String getExtractableName() {
-    // OPTIMIZE remove silly string compares for init - use kind==CTOR/STATIC_INITIALIZATION
-    	if (name.equals("<init>")) return "init$";
-    	else if (name.equals("<clinit>")) return "clinit$";
-    	else return name;
-    }
-
 	public AnnotationX[] getAnnotations() {
 		throw new UnsupportedOperationException("You should resolve this member '"+this+"' and call getAnnotations() on the result...");
 	}
@@ -491,247 +451,6 @@ public class MemberImpl implements Member {
 		}
 	}
 
-	// ---- reflective thisJoinPoint stuff
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getSignatureMakerName()
-	 */
-    public String getSignatureMakerName() {
-    	if (getName().equals("<clinit>")) return "makeInitializerSig";
-    	
-    	MemberKind kind = getKind();
-    	if (kind == METHOD) {
-    		return "makeMethodSig";
-    	} else if (kind == CONSTRUCTOR) {
-    		return "makeConstructorSig";
-    	} else if (kind == FIELD) {
-    		return "makeFieldSig";
-    	} else if (kind == HANDLER) {
-    		return "makeCatchClauseSig";
-    	} else if (kind == STATIC_INITIALIZATION) {
-    		return "makeInitializerSig";
-    	} else if (kind == ADVICE) {
-    		return "makeAdviceSig";
-    	} else if (kind == MONITORENTER) {
-    		return "makeLockSig";
-    	} else if (kind == MONITOREXIT) {
-    		return "makeUnlockSig";
-    	} else {
-    		throw new RuntimeException("unimplemented");
-    	}
-    }
-    	
-    
-	public String getSignatureType() {
-    	MemberKind kind = getKind();
-    	if (getName().equals("<clinit>")) return "org.aspectj.lang.reflect.InitializerSignature";
-    	
-    	if (kind == METHOD) {
-    		return "org.aspectj.lang.reflect.MethodSignature";
-    	} else if (kind == CONSTRUCTOR) {
-    		return "org.aspectj.lang.reflect.ConstructorSignature";
-    	} else if (kind == FIELD) {
-    		return "org.aspectj.lang.reflect.FieldSignature";
-    	} else if (kind == HANDLER) {
-    		return "org.aspectj.lang.reflect.CatchClauseSignature";
-    	} else if (kind == STATIC_INITIALIZATION) {
-    		return "org.aspectj.lang.reflect.InitializerSignature";
-    	} else if (kind == ADVICE) {
-    		return "org.aspectj.lang.reflect.AdviceSignature";
-    	} else if (kind == MONITORENTER) {
-    		return "org.aspectj.lang.reflect.LockSignature";
-    	} else if (kind == MONITOREXIT) {
-    		return "org.aspectj.lang.reflect.UnlockSignature";
-    	} else {
-    		throw new RuntimeException("unimplemented");
-    	}
-    }
-
-	/* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getSignatureString(org.aspectj.weaver.World)
-	 */
-	public String getSignatureString(World world) {
-		if (getName().equals("<clinit>")) return getStaticInitializationSignatureString(world);
-		
-    	MemberKind kind = getKind();
-    	if (kind == METHOD) {
-    		return getMethodSignatureString(world);
-    	} else if (kind == CONSTRUCTOR) {
-    		return getConstructorSignatureString(world);
-    	} else if (kind == FIELD) {
-    		return getFieldSignatureString(world);
-    	} else if (kind == HANDLER) {
-    		return getHandlerSignatureString(world);
-    	} else if (kind == STATIC_INITIALIZATION) {
-    		return getStaticInitializationSignatureString(world);
-    	} else if (kind == ADVICE) {
-    		return getAdviceSignatureString(world);
-    	} else if (kind == MONITORENTER || kind == MONITOREXIT) {
-    		return getMonitorSignatureString(world);
-    	} else {
-    		throw new RuntimeException("unimplemented");
-    	}
-    }
-
-	private String getHandlerSignatureString(World world) {
-        StringBuffer buf = new StringBuffer();
-        buf.append(makeString(0));
-        buf.append('-');
-        //buf.append(getName());
-        buf.append('-');
-        buf.append(makeString(getDeclaringType()));
-        buf.append('-');
-        buf.append(makeString(getParameterTypes()[0]));
-        buf.append('-');
-        String pName = "<missing>";
-        String[] names = getParameterNames(world);
-        if (names != null) pName = names[0];
-        buf.append(pName);
-        buf.append('-');
-        return buf.toString();
-	}
-	
-	private String getStaticInitializationSignatureString(World world) {
-        StringBuffer buf = new StringBuffer();
-        buf.append(makeString(getModifiers(world)));
-        buf.append('-');
-        //buf.append(getName());
-        buf.append('-');
-        buf.append(makeString(getDeclaringType()));
-        buf.append('-');
-        return buf.toString();
-	}
-
-
-
-	protected String getAdviceSignatureString(World world) {
-        StringBuffer buf = new StringBuffer();
-        buf.append(makeString(getModifiers(world)));
-        buf.append('-');
-        buf.append(getName());
-        buf.append('-');
-        buf.append(makeString(getDeclaringType()));
-        buf.append('-');
-        buf.append(makeString(getParameterTypes()));
-        buf.append('-');
-        buf.append(makeString(getParameterNames(world)));
-        buf.append('-');
-        buf.append(makeString(getExceptions(world)));
-        buf.append('-');
-        buf.append(makeString(getReturnType()));
-        buf.append('-');
-        return buf.toString();
-	}
-
-
-	protected String getMethodSignatureString(World world) {
-        StringBuffer buf = new StringBuffer();
-        buf.append(makeString(getModifiers(world)));
-        buf.append('-');
-        buf.append(getName());
-        buf.append('-');
-        buf.append(makeString(getDeclaringType()));
-        buf.append('-');
-        buf.append(makeString(getParameterTypes()));
-        buf.append('-');
-        buf.append(makeString(getParameterNames(world)));
-        buf.append('-');
-        buf.append(makeString(getExceptions(world)));
-        buf.append('-');
-        buf.append(makeString(getReturnType()));
-        buf.append('-');
-        return buf.toString();
-	}
-	
-	protected String getMonitorSignatureString(World world) {
-        StringBuffer buf = new StringBuffer();
-        buf.append(makeString(Modifier.STATIC));    // modifiers
-        buf.append('-');
-        buf.append(getName());                      // name
-        buf.append('-');
-        buf.append(makeString(getDeclaringType())); // Declaring Type
-        buf.append('-');
-        buf.append(makeString(getParameterTypes()[0])); // Parameter Types
-        buf.append('-');
-        buf.append("");                                 // Parameter names
-        buf.append('-');
-        return buf.toString();
-	}
-	
-
-
-	protected String getConstructorSignatureString(World world) {
-        StringBuffer buf = new StringBuffer();
-        buf.append(makeString(getModifiers(world)));
-        buf.append('-');
-        buf.append('-');
-        buf.append(makeString(getDeclaringType()));
-        buf.append('-');
-        buf.append(makeString(getParameterTypes()));
-        buf.append('-');
-        buf.append(makeString(getParameterNames(world)));
-        buf.append('-');
-        buf.append(makeString(getExceptions(world)));
-        buf.append('-');
-        return buf.toString();
-    }
-	
-	
-
-
-	protected String getFieldSignatureString(World world) {
-        StringBuffer buf = new StringBuffer();
-        buf.append(makeString(getModifiers(world)));
-        buf.append('-');
-        buf.append(getName());
-        buf.append('-');
-        buf.append(makeString(getDeclaringType()));
-        buf.append('-');
-        buf.append(makeString(getReturnType()));
-        buf.append('-');
-        return buf.toString();
-    }
-
-	protected String makeString(int i) {
-		return Integer.toString(i, 16);
-	}
-
-
-
-
-	protected String makeString(UnresolvedType t) {
-    	// this is the inverse of the odd behavior for Class.forName w/ arrays
-    	if (t.isArray()) {
-    		// this behavior matches the string used by the eclipse compiler for Foo.class literals
-    		return t.getSignature().replace('/', '.');
-    	} else {
-    		return t.getName();
-    	}
-    }
-    
-
-
-	protected String makeString(UnresolvedType[] types) {
-    	if (types == null) return "";
-        StringBuffer buf = new StringBuffer();
-        for (int i = 0, len=types.length; i < len; i++) {
-            buf.append(makeString(types[i]));
-            buf.append(':');
-        }
-        return buf.toString();
-    }
-    
-
-
-	protected String makeString(String[] names) {
-    	if (names == null) return "";
-        StringBuffer buf = new StringBuffer();
-        for (int i = 0, len=names.length; i < len; i++) {
-            buf.append(names[i]);
-            buf.append(':');
-        }
-        return buf.toString();
-    }
-
 	public String[] getParameterNames(World world) {
     	ResolvedMember resolved = resolve(world);
     	if (resolved == null) {
@@ -482,7 +482,7 @@ public class BcelShadow extends Shadow {
 			new BcelShadow(
 				world,
 				ConstructorExecution,
-				world.makeJoinPointSignature(enclosingMethod),
+				world.makeJoinPointSignatureFromMethod(enclosingMethod,Member.CONSTRUCTOR),
 				enclosingMethod,
 				null);
 		ShadowRange r = new ShadowRange(body);
@@ -525,7 +525,7 @@ public class BcelShadow extends Shadow {
             new BcelShadow(
                 world,
                 StaticInitialization,
-                world.makeJoinPointSignature(enclosingMethod),
+                world.makeJoinPointSignatureFromMethod(enclosingMethod,Member.STATIC_INITIALIZATION),
                 enclosingMethod,
                 null);
         ShadowRange r = new ShadowRange(body);
@@ -676,7 +676,7 @@ public class BcelShadow extends Shadow {
 		BcelShadow ret =  new BcelShadow(
 			world,
 			Initialization,
-			world.makeJoinPointSignature(constructor),
+			world.makeJoinPointSignatureFromMethod(constructor,Member.CONSTRUCTOR),
 			constructor,
 			null);
 		if (constructor.getEffectiveSignature() != null) {
@@ -692,10 +692,9 @@ public class BcelShadow extends Shadow {
 		BcelShadow ret =  new BcelShadow(
 			world,
 			PreInitialization,
-			world.makeJoinPointSignature(constructor),
+			world.makeJoinPointSignatureFromMethod(constructor,Member.CONSTRUCTOR),
 			constructor,
 			null);
-//		ret.fallsThrough = true;
 		if (constructor.getEffectiveSignature() != null) {
 			ret.setMatchingSignature(constructor.getEffectiveSignature().getEffectiveSignature());
 		}
@@ -755,7 +754,7 @@ public class BcelShadow extends Shadow {
                 null);
         ShadowRange r = new ShadowRange(body);
         r.associateWithShadow(s);
-        r.associateWithTargets(
+        r.associateWithTargets(// OPTIMIZE this occurs lots of times for all jp kinds...
             Range.genStart(body),
             Range.genEnd(body));                  
         return s;
@@ -1292,14 +1291,13 @@ public class BcelShadow extends Shadow {
     public BcelVar getThisJoinPointStaticPartBcelVar(final boolean isEnclosingJp) {
     	if (thisJoinPointStaticPartVar == null) {
     		Field field = getEnclosingClass().getTjpField(this, isEnclosingJp);
-    		
     			ResolvedType sjpType = null;
     	       	if (world.isTargettingAspectJRuntime12()) { // TAG:SUPPORTING12: We didn't have different jpsp types in 1.2	
-    		    	sjpType = world.getCoreType(UnresolvedType.forName("org.aspectj.lang.JoinPoint$StaticPart"));
+    		    	sjpType = world.getCoreType(UnresolvedType.JOINPOINT_STATICPART);
     		    } else {
     		    	sjpType = isEnclosingJp?
-                              world.getCoreType(UnresolvedType.forName("org.aspectj.lang.JoinPoint$EnclosingStaticPart")):
-                              world.getCoreType(UnresolvedType.forName("org.aspectj.lang.JoinPoint$StaticPart"));
+                              world.getCoreType(UnresolvedType.JOINPOINT_ENCLOSINGSTATICPART):
+                              world.getCoreType(UnresolvedType.JOINPOINT_STATICPART);
     		    }
     		    thisJoinPointStaticPartVar = new BcelFieldRef(
     				sjpType,
@@ -1590,27 +1588,27 @@ public class BcelShadow extends Shadow {
     	}
     	return foundMember.getAnnotationTypes();
     }
-	
+    
+    /**
+     * By determining what "kind" of shadow we are, we can find out the
+	 * annotations on the appropriate element (method, field, constructor, type).
+	 * Then create one BcelVar entry in the map for each annotation, keyed by
+	 * annotation type.
+	 */
     public void initializeKindedAnnotationVars() {
     	if (kindedAnnotationVars != null) return;
     	kindedAnnotationVars = new HashMap();
-    	// by determining what "kind" of shadow we are, we can find out the
-    	// annotations on the appropriate element (method, field, constructor, type).
-    	// Then create one BcelVar entry in the map for each annotation, keyed by
-    	// annotation type.
 
     	// FIXME asc Refactor this code, there is duplication
     	ResolvedType[] annotations = null;
-//    	Member relevantMember = getSignature();
     	Member shadowSignature = getSignature();
     	Member annotationHolder = getSignature();
     	ResolvedType  relevantType   = shadowSignature.getDeclaringType().resolve(world);
 
-	if (relevantType.isRawType() || relevantType.isParameterizedType()) relevantType = relevantType.getGenericType();
+    	if (relevantType.isRawType() || relevantType.isParameterizedType()) relevantType = relevantType.getGenericType();
 
-	if (getKind() == Shadow.StaticInitialization) {
+    	if (getKind() == Shadow.StaticInitialization) {
     		annotations  = relevantType.resolve(world).getAnnotationTypes();
-    		
     	} else if (getKind() == Shadow.MethodCall  || getKind() == Shadow.ConstructorCall) {
             ResolvedMember foundMember = findMethod2(relevantType.resolve(world).getDeclaredMethods(),getSignature());            
             annotations = getAnnotations(foundMember, shadowSignature, relevantType);
@@ -1651,7 +1649,6 @@ public class BcelShadow extends Shadow {
     	} else if (getKind() == Shadow.ExceptionHandler) {
     		relevantType = getSignature().getParameterTypes()[0].resolve(world);
     		annotations  =  relevantType.getAnnotationTypes();
-    		
     	} else if (getKind() == Shadow.PreInitialization || getKind() == Shadow.Initialization) {
     		ResolvedMember found = findMethod2(relevantType.getDeclaredMethods(),getSignature());
     		annotations = found.getAnnotationTypes();
@@ -1659,17 +1656,17 @@ public class BcelShadow extends Shadow {
 
     	if (annotations == null) {
     		// We can't have recognized the shadow - should blow up now to be on the safe side
-    		throw new BCException("Couldn't discover annotations for shadow: "+getKind());
+    		throw new BCException("Could not discover annotations for shadow: "+getKind());
     	}
 
 		for (int i = 0; i < annotations.length; i++) {
-			ResolvedType aTX = annotations[i];
-			AnnotationAccessVar kaav =  new AnnotationAccessVar(getKind(),aTX.resolve(world),relevantType,annotationHolder);
-    		kindedAnnotationVars.put(aTX,kaav);
+			ResolvedType annotationType = annotations[i];
+			AnnotationAccessVar accessVar =  new AnnotationAccessVar(getKind(),annotationType.resolve(world),relevantType,annotationHolder);
+    		kindedAnnotationVars.put(annotationType,accessVar);
 		}
     }
 
-//FIXME asc whats the real diff between this one and the version in findMethod()?
+    //FIXME asc whats the real diff between this one and the version in findMethod()?
 	 ResolvedMember findMethod2(ResolvedMember rm[], Member sig) {
 		ResolvedMember found = null;
 		// String searchString = getSignature().getName()+getSignature().getParameterSignature();
@@ -3577,7 +3574,7 @@ public class BcelShadow extends Shadow {
 	}
 
 	public boolean isFallsThrough() {
-		return !terminatesWithReturn(); //fallsThrough;
+		return !terminatesWithReturn();
 	}
 
 	public void setActualTargetType(String className) {
@@ -381,22 +381,6 @@ public class BcelWorld extends World implements Repository {
             			fi.getName(cpg),
             			fi.getSignature(cpg));
     }
-	
-//    public static Member makeFieldSetSignature(LazyClassGen cg, FieldInstruction fi) {
-//    	ConstantPoolGen cpg = cg.getConstantPoolGen();
-//        return 
-//            MemberImpl.field(
-//                fi.getClassName(cpg),
-//                (fi instanceof GETSTATIC || fi instanceof PUTSTATIC)
-//                ? Modifier.STATIC
-//                : 0, 
-//                fi.getName(cpg),
-//                "(" + fi.getSignature(cpg) + ")" +fi.getSignature(cpg));
-//    }
-
-	public Member makeJoinPointSignature(LazyMethodGen mg) {
-		return makeJoinPointSignatureFromMethod(mg, null);
-	}
 
 
 	public Member makeJoinPointSignatureFromMethod(LazyMethodGen mg, MemberKind kind) {
@@ -406,16 +390,6 @@ public class BcelWorld extends World implements Repository {
 	        if (mg.getEnclosingClass().isInterface()) {
 	            mods |= Modifier.INTERFACE;
 	        }
-	        if (kind == null) {
-	        	//OPTIMIZE surely we can pass the kind in and not resort to string compares?
-		        if (mg.getName().equals("<init>")) {
-		        	kind = Member.CONSTRUCTOR;
-		        } else if (mg.getName().equals("<clinit>")) {
-		        	kind = Member.STATIC_INITIALIZATION;
-		        } else {
-		        	kind = Member.METHOD;
-		        }
-	        }
 	        return new ResolvedMemberImpl(kind,
 	                UnresolvedType.forName(mg.getClassName()), 
 	                mods,
@@ -59,6 +59,7 @@ import org.aspectj.weaver.NameMangler;
 import org.aspectj.weaver.ResolvedMember;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.Shadow;
+import org.aspectj.weaver.SignatureUtils;
 import org.aspectj.weaver.TypeVariable;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.WeaverMessages;
@@ -283,6 +284,9 @@ public final class LazyClassGen {
 			for (int i = 0; i < methods.length; i++) {
 				ResolvedMember method = methods[i];
 				if (method.getName().equals("<clinit>")) {
+					if (method.getKind()!=Member.STATIC_INITIALIZATION) {
+						throw new RuntimeException("qui?");
+					}
 					hasClinit = true;					
 				}
 			}
@@ -649,15 +653,6 @@ public final class LazyClassGen {
 
 	private static boolean hasSourceDebugExtensionAttribute(ClassGen gen) {
 		return gen.hasAttribute("SourceDebugExtension");
-//		ConstantPool pool = gen.getConstantPool();
-//		Attribute[] attrs = gen.getAttributes();
-//		for (int i = 0; i < attrs.length; i++) {
-//			if ("SourceDebugExtension"
-//				.equals(((ConstantUtf8) pool.getConstant(attrs[i].getNameIndex())).getBytes())) {
-//				return true;
-//			}
-//		}
-//		return false;
 	}
 
     public JavaClass getJavaClass(BcelWorld world) {
@@ -809,6 +804,7 @@ public final class LazyClassGen {
     }
 
     private boolean isEmptyClinit(LazyMethodGen gen) {
+    	
     	if (!gen.getName().equals("<clinit>")) return false;
     	//System.err.println("checking clinig: " + gen);
     	InstructionHandle start = gen.getBody().getStart();
@@ -860,6 +856,7 @@ public final class LazyClassGen {
     public LazyMethodGen getStaticInitializer() {
         for (Iterator i = methodGens.iterator(); i.hasNext();) {
             LazyMethodGen gen = (LazyMethodGen) i.next();
+            // OPTIMIZE persist kind of member into the gen object? for clinit
 			if (gen.getName().equals("<clinit>")) return gen;
         } 
         LazyMethodGen clinit = new LazyMethodGen(
@@ -1053,14 +1050,15 @@ public final class LazyClassGen {
     	// create the signature
     	list.append(InstructionFactory.createLoad(factoryType, 0));
 
+    	String signatureMakerName = SignatureUtils.getSignatureMakerName(sig);
+    	ObjectType signatureType = new ObjectType(SignatureUtils.getSignatureType(sig));
+    	
+    	
     	if (world.isTargettingAspectJRuntime12()) { // TAG:SUPPORTING12: We didn't have optimized factory methods in 1.2
-        	list.append(InstructionFactory.PUSH(getConstantPool(), sig.getSignatureString(shadow.getWorld())));
+        	list.append(InstructionFactory.PUSH(getConstantPool(), SignatureUtils.getSignatureString(sig,shadow.getWorld())));
     		list.append(fact.createInvoke(factoryType.getClassName(), 
-    					sig.getSignatureMakerName(),
-    					new ObjectType(sig.getSignatureType()),
-    					new Type[] { Type.STRING },
-    					Constants.INVOKEVIRTUAL));
-    	} else 	if (sig.getKind().equals(Member.METHOD)) {
+    					signatureMakerName,signatureType,Type.STRINGARRAY1, Constants.INVOKEVIRTUAL));
+    	} else if (sig.getKind().equals(Member.METHOD)) {    	
     		BcelWorld w = shadow.getWorld();
     		// For methods, push the parts of the signature on.
     		list.append(InstructionFactory.PUSH(getConstantPool(),makeString(sig.getModifiers(w))));
@@ -1072,23 +1070,18 @@ public final class LazyClassGen {
     		list.append(InstructionFactory.PUSH(getConstantPool(),makeString(sig.getReturnType())));
     		// And generate a call to the variant of makeMethodSig() that takes 7 strings
     		list.append(fact.createInvoke(factoryType.getClassName(), 
-    				sig.getSignatureMakerName(),
-    				new ObjectType(sig.getSignatureType()),
+					signatureMakerName,signatureType,
     				new Type[] { Type.STRING,Type.STRING,Type.STRING,Type.STRING,Type.STRING,Type.STRING,Type.STRING },
     				Constants.INVOKEVIRTUAL));
    	    } else if (sig.getKind().equals(Member.MONITORENTER)) {
     		list.append(InstructionFactory.PUSH(getConstantPool(),makeString(sig.getDeclaringType())));
     		list.append(fact.createInvoke(factoryType.getClassName(), 
-    				sig.getSignatureMakerName(),
-    				new ObjectType(sig.getSignatureType()),
-    				new Type[] { Type.STRING},
+					signatureMakerName,signatureType,Type.STRINGARRAY1,
     				Constants.INVOKEVIRTUAL));
     	} else if (sig.getKind().equals(Member.MONITOREXIT)) {
     		list.append(InstructionFactory.PUSH(getConstantPool(),makeString(sig.getDeclaringType())));
     		list.append(fact.createInvoke(factoryType.getClassName(), 
-    				sig.getSignatureMakerName(),
-    				new ObjectType(sig.getSignatureType()),
-    				new Type[] { Type.STRING},
+					signatureMakerName,signatureType,Type.STRINGARRAY1,
     				Constants.INVOKEVIRTUAL));
      	} else if (sig.getKind().equals(Member.HANDLER)) {
     		BcelWorld w = shadow.getWorld();
@@ -1096,9 +1089,7 @@ public final class LazyClassGen {
     		list.append(InstructionFactory.PUSH(getConstantPool(),makeString(sig.getParameterTypes())));
     		list.append(InstructionFactory.PUSH(getConstantPool(),makeString(sig.getParameterNames(w))));
     		list.append(fact.createInvoke(factoryType.getClassName(),
-    				sig.getSignatureMakerName(),
-    				new ObjectType(sig.getSignatureType()),
-    				new Type[] { Type.STRING, Type.STRING, Type.STRING },
+					signatureMakerName,signatureType,Type.STRINGARRAY3,
     				Constants.INVOKEVIRTUAL));    	
     	} else if(sig.getKind().equals(Member.CONSTRUCTOR)) {
     		BcelWorld w = shadow.getWorld();
@@ -1110,9 +1101,7 @@ public final class LazyClassGen {
 	    		list.append(InstructionFactory.PUSH(getConstantPool(),""));//makeString("")));//sig.getParameterNames(w))));
 	    		list.append(InstructionFactory.PUSH(getConstantPool(),""));//makeString("")));//sig.getExceptions(w))));
 	    		list.append(fact.createInvoke(factoryType.getClassName(),
-	    				sig.getSignatureMakerName(),
-	    				new ObjectType(sig.getSignatureType()),
-	    				new Type[] { Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING },
+    					signatureMakerName,signatureType,Type.STRINGARRAY5,
 	    				Constants.INVOKEVIRTUAL));    	
     		} else {
 	    		list.append(InstructionFactory.PUSH(getConstantPool(),makeString(sig.getModifiers(w))));	
@@ -1121,9 +1110,7 @@ public final class LazyClassGen {
 	    		list.append(InstructionFactory.PUSH(getConstantPool(),makeString(sig.getParameterNames(w))));
 	    		list.append(InstructionFactory.PUSH(getConstantPool(),makeString(sig.getExceptions(w))));
 	    		list.append(fact.createInvoke(factoryType.getClassName(),
-	    				sig.getSignatureMakerName(),
-	    				new ObjectType(sig.getSignatureType()),
-	    				new Type[] { Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING },
+    					signatureMakerName,signatureType,Type.STRINGARRAY5,
 	    				Constants.INVOKEVIRTUAL));    	
     		}
     	} else if(sig.getKind().equals(Member.FIELD)) {
@@ -1139,9 +1126,7 @@ public final class LazyClassGen {
     		list.append(InstructionFactory.PUSH(getConstantPool(),makeString(dType)));    		
     		list.append(InstructionFactory.PUSH(getConstantPool(),makeString(sig.getReturnType())));
     		list.append(fact.createInvoke(factoryType.getClassName(),
-    				sig.getSignatureMakerName(),
-    				new ObjectType(sig.getSignatureType()),
-    				new Type[] { Type.STRING, Type.STRING, Type.STRING, Type.STRING },
+					signatureMakerName,signatureType,Type.STRINGARRAY4,
     				Constants.INVOKEVIRTUAL));    	
     	} else if(sig.getKind().equals(Member.ADVICE)) {
     		BcelWorld w = shadow.getWorld();
@@ -1153,8 +1138,7 @@ public final class LazyClassGen {
     		list.append(InstructionFactory.PUSH(getConstantPool(),makeString(sig.getExceptions(w))));
     		list.append(InstructionFactory.PUSH(getConstantPool(),makeString((sig.getReturnType()))));    		
     		list.append(fact.createInvoke(factoryType.getClassName(),
-    				sig.getSignatureMakerName(),
-    				new ObjectType(sig.getSignatureType()),
+					signatureMakerName,signatureType,
     				new Type[] { Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING },
     				Constants.INVOKEVIRTUAL));    	
     	} else if(sig.getKind().equals(Member.STATIC_INITIALIZATION)) {
@@ -1162,16 +1146,12 @@ public final class LazyClassGen {
     		list.append(InstructionFactory.PUSH(getConstantPool(),makeString(sig.getModifiers(w))));
     		list.append(InstructionFactory.PUSH(getConstantPool(),makeString(sig.getDeclaringType())));
     		list.append(fact.createInvoke(factoryType.getClassName(),
-    				sig.getSignatureMakerName(),
-    				new ObjectType(sig.getSignatureType()),
-    				new Type[] { Type.STRING, Type.STRING },
+					signatureMakerName,signatureType,Type.STRINGARRAY2,
     				Constants.INVOKEVIRTUAL));
     	} else {
-    	  list.append(InstructionFactory.PUSH(getConstantPool(), sig.getSignatureString(shadow.getWorld())));
+    	  list.append(InstructionFactory.PUSH(getConstantPool(), SignatureUtils.getSignatureString(sig,shadow.getWorld())));
     	  list.append(fact.createInvoke(factoryType.getClassName(), 
-			  	   sig.getSignatureMakerName(),
-			  	   new ObjectType(sig.getSignatureType()),
-			  	   new Type[] { Type.STRING },
+					signatureMakerName,signatureType,Type.STRINGARRAY1,
 			  	   Constants.INVOKEVIRTUAL));
     	}   	
 
@@ -117,6 +117,8 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
     public static final UnresolvedType   AT_TARGET = forSignature("Ljava/lang/annotation/Target;");
     public static final UnresolvedType   SOMETHING = new UnresolvedType("?");
     public static final UnresolvedType[] ARRAY_WITH_JUST_OBJECT = new UnresolvedType[]{OBJECT};
+    public static final UnresolvedType JOINPOINT_STATICPART = forSignature("Lorg/aspectj/lang/JoinPoint$StaticPart;");
+    public static final UnresolvedType JOINPOINT_ENCLOSINGSTATICPART = forSignature("Lorg/aspectj/lang/JoinPoint$EnclosingStaticPart;");
 
     // this doesn't belong here and will get moved to ResolvedType later in the refactoring
 	public static final String MISSING_NAME = "@missing@";
@@ -36,7 +36,7 @@ public class MoveInstructionsWeaveTestCase extends WeaveTestCase {
 				BcelShadow shadow = (BcelShadow) s;
 				LazyMethodGen newMethod =
 					shadow.extractMethod(
-						shadow.getSignature().getExtractableName() + "_extracted",
+						NameMangler.getExtractableName(shadow.getSignature()) + "_extracted",
 						0,
 						this);
 				shadow.getRange().append(shadow.makeCallToCallback(newMethod));
@@ -60,7 +60,7 @@ public class MoveInstructionsWeaveTestCase extends WeaveTestCase {
             }
             public void implementOn(Shadow s) {
                 BcelShadow shadow = (BcelShadow) s;
-                LazyMethodGen newMethod = shadow.extractMethod(shadow.getSignature().getExtractableName() + "_extracted" + counter++, 0, this);
+                LazyMethodGen newMethod = shadow.extractMethod(NameMangler.getExtractableName(shadow.getSignature()) + "_extracted" + counter++, 0, this);
                 shadow.getRange().append(shadow.makeCallToCallback(newMethod));
 
                 if (! shadow.isFallsThrough()) {
Binary files differ
Binary files differ
Binary files differ
Binary files differ
@@ -64,14 +64,13 @@ import java.util.List;
 /** 
  * Abstract super class for fields and methods.
  *
- * @version $Id: FieldOrMethod.java,v 1.6 2008/05/28 23:53:01 aclement Exp $
+ * @version $Id: FieldOrMethod.java,v 1.7 2008/06/06 04:24:20 aclement Exp $
  * @author  <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
  */
 public abstract class FieldOrMethod extends Modifiers implements Cloneable, Node {
   protected int           nameIndex;      
   protected int           signatureIndex;
   protected Attribute[] attributes;
-   protected int          attributes_count;// No. of attributes
 
   protected ConstantPool  cpool;
   private String  name; // lazily initialized
@@ -111,7 +110,6 @@ public abstract class FieldOrMethod extends Modifiers implements Cloneable, Node
    */
   public void setAttributes(Attribute[] attributes) {
     this.attributes  = attributes;
-    attributes_count = (attributes == null)? 0 : attributes.length;
   }
 
 
@@ -65,7 +65,7 @@ import org.aspectj.apache.bcel.classfile.Utility;
  * Abstract super class for all possible java types, namely basic types
  * such as int, object types like String and array types, e.g. int[]
  *
- * @version $Id: Type.java,v 1.8 2008/05/28 23:52:56 aclement Exp $
+ * @version $Id: Type.java,v 1.9 2008/06/06 04:24:20 aclement Exp $
  * @author  <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
  * 
  * modified:
@@ -92,7 +92,12 @@ public abstract class Type implements java.io.Serializable {
   public static final Type[]        NO_ARGS      = new Type[0];
   public static final ReferenceType NULL         = new ReferenceType(){};
   public static final Type          UNKNOWN      = new Type(Constants.T_UNKNOWN,"<unknown object>"){};
-
+  public static final Type[]        STRINGARRAY1 = new Type[]{STRING};
+  public static final Type[]        STRINGARRAY2 = new Type[]{STRING,STRING};
+  public static final Type[]        STRINGARRAY3 = new Type[]{STRING,STRING,STRING};
+  public static final Type[]        STRINGARRAY4 = new Type[]{STRING,STRING,STRING,STRING};
+  public static final Type[]        STRINGARRAY5 = new Type[]{STRING,STRING,STRING,STRING,STRING};
+  
   protected Type(byte t, String s) {
     type      = t;
     signature = s;
@@ -363,9 +363,18 @@ public class NameMangler {
 
 	public static String aroundCallbackMethodName(Member shadowSig, LazyClassGen enclosingType) {
 		StringBuffer ret = new StringBuffer();
-		ret.append(shadowSig.getExtractableName()).append("_aroundBody").append(enclosingType.getNewGeneratedNameTag());
+		ret.append(getExtractableName(shadowSig)).append("_aroundBody").append(enclosingType.getNewGeneratedNameTag());
 		return ret.toString();
 	}
+	
+	 public static String getExtractableName(Member shadowSignature) {
+		String name = shadowSignature.getName();
+		MemberKind kind = shadowSignature.getKind();
+    	if (kind==Member.CONSTRUCTOR) return "init$";
+    	else if (kind==Member.STATIC_INITIALIZATION) return "clinit$";
+    	else return name;
+    }
+
 
 	public static String proceedMethodName(String adviceMethodName) {
 		return adviceMethodName + "proceed";
@@ -491,6 +491,7 @@ public abstract class World implements Dump.INode {
      * any other type, but if they are not found it is more serious and we issue an
      * error message immediately.
      */
+    // OPTIMIZE streamline path for core types? They are just simple types, could look straight in the typemap?
     public ResolvedType getCoreType(UnresolvedType tx) {
     	ResolvedType coreTy = resolve(tx,true);
     	if (coreTy.isMissing()) {
@@ -28,6 +28,7 @@ import org.aspectj.weaver.MemberImpl;
 import org.aspectj.weaver.NameMangler;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.Shadow;
+import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.WeaverMessages;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.ast.Expr;
@@ -134,10 +135,10 @@ public class ConcreteCflowPointcut extends Pointcut {
 	}
 
 	private static final Member cflowStackIsValidMethod = 
-		MemberImpl.method(NameMangler.CFLOW_STACK_UNRESOLVEDTYPE, 0, "isValid", "()Z");
+		MemberImpl.method(NameMangler.CFLOW_STACK_UNRESOLVEDTYPE, 0, ResolvedType.BOOLEAN,"isValid", UnresolvedType.NONE);
 
 	private static final Member cflowCounterIsValidMethod = 
-		MemberImpl.method(NameMangler.CFLOW_COUNTER_UNRESOLVEDTYPE, 0, "isValid", "()Z");
+		MemberImpl.method(NameMangler.CFLOW_COUNTER_UNRESOLVEDTYPE, 0,ResolvedType.BOOLEAN, "isValid", UnresolvedType.NONE);
 
 
 	public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, IntMap bindings) {
@@ -23,6 +23,7 @@ import org.aspectj.apache.bcel.generic.Type;
 import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.Member;
 import org.aspectj.weaver.MemberImpl;
+import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.ast.And;
 import org.aspectj.weaver.ast.Call;
@@ -188,15 +189,14 @@ public final class BcelRenderer implements ITestVisitor, IExprVisitor {
         // ldc_w annotationClass
         // invokevirtual java/lang/Class.isAnnotationPresent:(Ljava/lang/Class;)Z
         InstructionList il = new InstructionList();
-        Member getClass = MemberImpl.method(UnresolvedType.OBJECT, 0, "getClass", "()Ljava/lang/Class;");
+        Member getClass = MemberImpl.method(UnresolvedType.OBJECT, 0, UnresolvedType.JAVA_LANG_CLASS,"getClass", UnresolvedType.NONE);
         il.append(Utility.createInvoke(fact, world, getClass));
         // aload annotationClass
         String s = hasAnnotation.getAnnotationType().getName();
         il.append(fact.createConstant(new ObjectType(hasAnnotation.getAnnotationType().getName())));
 //        int annClassIndex = fact.getConstantPool().addClass(hasAnnotation.getAnnotationType().getSignature());
 //        il.append(new LDC_W(annClassIndex));
-        Member isAnnotationPresent = MemberImpl.method(UnresolvedType.forName("java/lang/Class"),0,
-                "isAnnotationPresent","(Ljava/lang/Class;)Z");
+        Member isAnnotationPresent = MemberImpl.method(UnresolvedType.JAVA_LANG_CLASS,0,ResolvedType.BOOLEAN,"isAnnotationPresent",new UnresolvedType[]{UnresolvedType.JAVA_LANG_CLASS});
         il.append(Utility.createInvoke(fact,world,isAnnotationPresent));
         il.append(createJumpBasedOnBooleanOnStack());
         instructions.insert(il);
@@ -0,0 +1,246 @@
+/* *******************************************************************
+ * Copyright (c) 2008 Contributors
+ * 
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *   Andy Clement - refactored out of MemberImpl
+ * ******************************************************************/
+package org.aspectj.weaver;
+
+import java.lang.reflect.Modifier;
+
+public class SignatureUtils {
+
+	public static String getSignatureString(Member m, World world) {		
+    	MemberKind kind = m.getKind();
+    	if (kind == Member.METHOD) {
+    		return getMethodSignatureString(m,world);
+    	} else if (kind == Member.CONSTRUCTOR) {
+    		return getConstructorSignatureString(m,world);
+    	} else if (kind == Member.FIELD) {
+    		return getFieldSignatureString(m,world);
+    	} else if (kind == Member.HANDLER) {
+    		return getHandlerSignatureString(m,world);
+    	} else if (kind == Member.STATIC_INITIALIZATION) {
+    		return getStaticInitializationSignatureString(m,world);
+    	} else if (kind == Member.ADVICE) {
+    		return getAdviceSignatureString(m,world);
+    	} else if (kind == Member.MONITORENTER || kind == Member.MONITOREXIT) {
+    		return getMonitorSignatureString(m,world);
+    	} else {
+    		throw new BCException("Do not know the signature string for MemberKind "+kind);
+    	}
+    }
+
+    public static String getSignatureMakerName(Member m) {
+    	MemberKind kind = m.getKind();
+    	if (kind == Member.METHOD) {
+    		return "makeMethodSig";
+    	} else if (kind == Member.CONSTRUCTOR) {
+    		return "makeConstructorSig";
+    	} else if (kind == Member.FIELD) {
+    		return "makeFieldSig";
+    	} else if (kind == Member.HANDLER) {
+    		return "makeCatchClauseSig";
+    	} else if (kind == Member.STATIC_INITIALIZATION) {
+    		return "makeInitializerSig";
+    	} else if (kind == Member.ADVICE) {
+    		return "makeAdviceSig";
+    	} else if (kind == Member.MONITORENTER) {
+    		return "makeLockSig";
+    	} else if (kind == Member.MONITOREXIT) {
+    		return "makeUnlockSig";
+    	} else {
+    		throw new BCException("Do not know the signature maker name for MemberKind "+kind);
+    	}
+    }
+
+	public static String getSignatureType(Member m) {
+    	MemberKind kind = m.getKind();
+    	if (m.getName().equals("<clinit>") && kind!=Member.STATIC_INITIALIZATION) throw new BCException();
+//    	if (m.getName().equals("<clinit>")) return "org.aspectj.lang.reflect.InitializerSignature";
+    	
+    	if (kind == Member.METHOD) {
+    		return "org.aspectj.lang.reflect.MethodSignature";
+    	} else if (kind == Member.CONSTRUCTOR) {
+    		return "org.aspectj.lang.reflect.ConstructorSignature";
+    	} else if (kind == Member.FIELD) {
+    		return "org.aspectj.lang.reflect.FieldSignature";
+    	} else if (kind == Member.HANDLER) {
+    		return "org.aspectj.lang.reflect.CatchClauseSignature";
+    	} else if (kind == Member.STATIC_INITIALIZATION) {
+    		return "org.aspectj.lang.reflect.InitializerSignature";
+    	} else if (kind == Member.ADVICE) {
+    		return "org.aspectj.lang.reflect.AdviceSignature";
+    	} else if (kind == Member.MONITORENTER) {
+    		return "org.aspectj.lang.reflect.LockSignature";
+    	} else if (kind == Member.MONITOREXIT) {
+    		return "org.aspectj.lang.reflect.UnlockSignature";
+    	} else {
+    		throw new BCException("Do not know the signature type for MemberKind "+kind);
+    	}
+    }
+
+    
+    // ---
+	
+
+	private static String getHandlerSignatureString(Member m, World world) {
+        StringBuffer buf = new StringBuffer();
+        buf.append(makeString(0));
+        buf.append('-');
+        //buf.append(getName());
+        buf.append('-');
+        buf.append(makeString(m.getDeclaringType()));
+        buf.append('-');
+        buf.append(makeString(m.getParameterTypes()[0]));
+        buf.append('-');
+        String pName = "<missing>";
+        String[] names = m.getParameterNames(world);
+        if (names != null) pName = names[0];
+        buf.append(pName);
+        buf.append('-');
+        return buf.toString();
+	}
+	
+	private static String getStaticInitializationSignatureString(Member m, World world) {
+        StringBuffer buf = new StringBuffer();
+        buf.append(makeString(m.getModifiers(world)));
+        buf.append('-');
+        //buf.append(getName());
+        buf.append('-');
+        buf.append(makeString(m.getDeclaringType()));
+        buf.append('-');
+        return buf.toString();
+	}
+
+	protected static String getAdviceSignatureString(Member m, World world) {
+        StringBuffer buf = new StringBuffer();
+        buf.append(makeString(m.getModifiers(world)));
+        buf.append('-');
+        buf.append(m.getName());
+        buf.append('-');
+        buf.append(makeString(m.getDeclaringType()));
+        buf.append('-');
+        buf.append(makeString(m.getParameterTypes()));
+        buf.append('-');
+        buf.append(makeString(m.getParameterNames(world)));
+        buf.append('-');
+        buf.append(makeString(m.getExceptions(world)));
+        buf.append('-');
+        buf.append(makeString(m.getReturnType()));
+        buf.append('-');
+        return buf.toString();
+	}
+
+
+	protected static String getMethodSignatureString(Member m, World world) {
+        StringBuffer buf = new StringBuffer();
+        buf.append(makeString(m.getModifiers(world)));
+        buf.append('-');
+        buf.append(m.getName());
+        buf.append('-');
+        buf.append(makeString(m.getDeclaringType()));
+        buf.append('-');
+        buf.append(makeString(m.getParameterTypes()));
+        buf.append('-');
+        buf.append(makeString(m.getParameterNames(world)));
+        buf.append('-');
+        buf.append(makeString(m.getExceptions(world)));
+        buf.append('-');
+        buf.append(makeString(m.getReturnType()));
+        buf.append('-');
+        return buf.toString();
+	}
+	
+	protected static String getMonitorSignatureString(Member m, World world) {
+        StringBuffer buf = new StringBuffer();
+        buf.append(makeString(Modifier.STATIC));    // modifiers
+        buf.append('-');
+        buf.append(m.getName());                      // name
+        buf.append('-');
+        buf.append(makeString(m.getDeclaringType())); // Declaring Type
+        buf.append('-');
+        buf.append(makeString(m.getParameterTypes()[0])); // Parameter Types
+        buf.append('-');
+        buf.append("");                                 // Parameter names
+        buf.append('-');
+        return buf.toString();
+	}
+
+	protected static String getConstructorSignatureString(Member m, World world) {
+        StringBuffer buf = new StringBuffer();
+        buf.append(makeString(m.getModifiers(world)));
+        buf.append('-');
+        buf.append('-');
+        buf.append(makeString(m.getDeclaringType()));
+        buf.append('-');
+        buf.append(makeString(m.getParameterTypes()));
+        buf.append('-');
+        buf.append(makeString(m.getParameterNames(world)));
+        buf.append('-');
+        buf.append(makeString(m.getExceptions(world)));
+        buf.append('-');
+        return buf.toString();
+    }
+	
+	
+
+
+	protected static String getFieldSignatureString(Member m, World world) {
+        StringBuffer buf = new StringBuffer();
+        buf.append(makeString(m.getModifiers(world)));
+        buf.append('-');
+        buf.append(m.getName());
+        buf.append('-');
+        buf.append(makeString(m.getDeclaringType()));
+        buf.append('-');
+        buf.append(makeString(m.getReturnType()));
+        buf.append('-');
+        return buf.toString();
+    }
+
+	protected static String makeString(int i) {
+		return Integer.toString(i, 16);
+	}
+
+	protected static String makeString(UnresolvedType t) {
+    	// this is the inverse of the odd behavior for Class.forName w/ arrays
+    	if (t.isArray()) {
+    		// this behavior matches the string used by the eclipse compiler for Foo.class literals
+    		return t.getSignature().replace('/', '.');
+    	} else {
+    		return t.getName();
+    	}
+    }
+    
+
+
+	protected static String makeString(UnresolvedType[] types) {
+    	if (types == null) return "";
+        StringBuffer buf = new StringBuffer();
+        for (int i = 0, len=types.length; i < len; i++) {
+            buf.append(makeString(types[i]));
+            buf.append(':');
+        }
+        return buf.toString();
+    }
+    
+
+
+	protected static String makeString(String[] names) {
+    	if (names == null) return "";
+        StringBuffer buf = new StringBuffer();
+        for (int i = 0, len=names.length; i < len; i++) {
+            buf.append(names[i]);
+            buf.append(':');
+        }
+        return buf.toString();
+    }
+
+}
@@ -13,17 +13,12 @@
 package org.aspectj.weaver;
 
 import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Iterator;
 import java.util.List;
 
 import org.aspectj.apache.bcel.classfile.GenericSignatureParser;
 import org.aspectj.apache.bcel.classfile.Signature;
 import org.aspectj.apache.bcel.classfile.Signature.ClassSignature;
 import org.aspectj.bridge.ISourceLocation;
-import org.aspectj.weaver.patterns.Declare;
 
 public abstract class AbstractReferenceTypeDelegate implements ReferenceTypeDelegate {
 
@@ -43,8 +38,6 @@ public abstract class AbstractReferenceTypeDelegate implements ReferenceTypeDele
 	public final boolean isClass() {
     	return !isAspect() && !isInterface();
     }
-	
-	
 
 	/**
 	 * Designed to be overriden by EclipseType to disable collection of shadow mungers
@@ -62,187 +55,7 @@ public abstract class AbstractReferenceTypeDelegate implements ReferenceTypeDele
 		return resolvedTypeX;
 	}
 
-    /**
-     * Create the string representation for a delegate, allowing us to 
-     * more easily compare delegate implementations.
-     */
-    public String stringifyDelegate() {
-    	
-    	StringBuffer result = new StringBuffer();
-    	result.append("=== Delegate for "+getResolvedTypeX().getName()+"\n");
-    	
-    	result.append("isAspect?"+isAspect()+"\n");
-    	result.append("isAnnotationStyleAspect?"+isAnnotationStyleAspect()+"\n");
-    	result.append("isInterface?"+isInterface()+"\n");
-    	result.append("isEnum?"+isEnum()+"\n");
-    	result.append("isClass?"+isClass()+"\n");
-    	result.append("-\n");
-    	result.append("isAnnotation?"+isAnnotation()+"\n");
-    	result.append("retentionPolicy="+getRetentionPolicy()+"\n");
-    	result.append("canAnnotationTargetType?"+canAnnotationTargetType()+"\n");
-    	AnnotationTargetKind[] kinds = getAnnotationTargetKinds();
-    	if (kinds!=null && kinds.length>0) {
-    		result.append("annotationTargetKinds:[");
-    		for (int i = 0; i < kinds.length; i++) {
-				AnnotationTargetKind kind = kinds[i];
-				result.append(kind);
-				if ((i+1)<kinds.length) result.append(" ");
-			}
-    		result.append("]\n");
-    	}
-    	result.append("isAnnotationWithRuntimeRetention?"+isAnnotationWithRuntimeRetention()+"\n");
-    	result.append("-\n");
-    	
-    	result.append("isAnonymous?"+isAnonymous()+"\n");
-    	result.append("isNested?"+isNested()+"\n");
-    	result.append("-\n");
-
-    	result.append("isGeneric?"+isGeneric()+"\n");
-    	result.append("declaredGenericSignature="+getDeclaredGenericSignature()+"\n");
-    	result.append("-\n");
-    	
-    	AnnotationX[] axs = getAnnotations();
-    	if (axs!=null && axs.length>0) {
-    		result.append("getAnnotations() returns: "+axs.length+" annotations\n");
-    		for (int i = 0; i < axs.length; i++) {
-				AnnotationX annotationX = axs[i];
-				result.append("  #"+i+") "+annotationX+"\n");
-    		}
-		} else {
-			result.append("getAnnotations() returns nothing\n");
-		}
-    	ResolvedType[] axtypes = getAnnotationTypes();
-    	if (axtypes!=null && axtypes.length>0) {
-    		result.append("getAnnotationTypes() returns: "+axtypes.length+" annotations\n");
-    		for (int i = 0; i < axtypes.length; i++) {
-				ResolvedType annotation = axtypes[i];
-				result.append("  #"+i+") "+annotation+":"+annotation.getClass()+"\n");
-			}
-    	} else {
-			result.append("getAnnotationTypes() returns nothing\n");
-		}
-    	
-    	result.append("isExposedToWeaver?"+isExposedToWeaver()+"\n");
-    	result.append("getSuperclass?"+getSuperclass()+"\n");
-    	result.append("getResolvedTypeX?"+getResolvedTypeX()+"\n");
-    	result.append("--\n");
-    	
-    	ResolvedMember[] fields = getDeclaredFields();
-    	if (fields!=null && fields.length>0) {
-        	result.append("The fields: "+fields.length+"\n");
-    		for (int i = 0; i < fields.length; i++) {
-				ResolvedMember member = fields[i];
-				result.append("f"+i+") "+member.toDebugString()+"\n");
-			}
-    	}
-    	ResolvedMember[] methods = getDeclaredMethods();
-    	if (methods!=null && methods.length>0) {
-        	result.append("The methods: "+methods.length+"\n");
-    		for (int i = 0; i < methods.length; i++) {
-				ResolvedMember member = methods[i];
-				result.append("m"+i+") "+member.toDebugString()+"\n");
-			}
-    	}
-    	ResolvedType[] interfaces = getDeclaredInterfaces();
-    	if (interfaces!=null && interfaces.length>0) {
-        	result.append("The interfaces: "+interfaces.length+"\n");
-    		for (int i = 0; i < interfaces.length; i++) {
-    			ResolvedType member = interfaces[i];
-				result.append("i"+i+") "+member+"\n");
-			}
-    	}
-
-    	result.append("getModifiers?"+getModifiers()+"\n");
-    	
-    	result.append("perclause="+getPerClause()+"\n");
-    	
-    	result.append("aj:weaverstate="+getWeaverState()+"\n");
-    	
-    	ResolvedMember[] pointcuts = getDeclaredPointcuts();
-    	if (pointcuts!=null && pointcuts.length>0) {
-    		result.append("The pointcuts: "+pointcuts.length+"\n");
-    		
-    		// Sort the damn things
-        	List sortedSetOfPointcuts = new ArrayList();
-        	for (int i = 0; i < pointcuts.length; i++) {sortedSetOfPointcuts.add(pointcuts[i]);}
-        	Collections.sort(sortedSetOfPointcuts);
-        	
-        	int i =0;
-        	for (Iterator iter = sortedSetOfPointcuts.iterator(); iter.hasNext();) {
-				ResolvedMember member = (ResolvedMember) iter.next();
-				result.append("p"+i+") "+member.toDebugString()+"\n");
-				i++;
-			}
-    	}
-    	
-    	Collection declares = getDeclares();
-    	if (declares.size()>0) {
-    		result.append("The declares: "+declares.size()+"\n");
-    		
-//    		// Sort the damn things
-//        	List sortedSetOfPointcuts = new ArrayList();
-//        	for (int i = 0; i < pointcuts.length; i++) {sortedSetOfPointcuts.add(pointcuts[i]);}
-//        	Collections.sort(sortedSetOfPointcuts);
-        	
-        	int i=0;
-        	for (Iterator iter = declares.iterator(); iter.hasNext();) {
-				Declare dec = (Declare) iter.next();
-				result.append("d"+i+") "+dec.toString()+"\n");
-				i++;
-			}
-    	}
-    	
-    	TypeVariable[] tv = getTypeVariables();
-    	if (tv!=null && tv.length>0) {
-        	result.append("The type variables: "+tv.length+"\n");
-    		for (int i = 0; i < tv.length; i++) {
-				result.append("tv"+i+") "+tv[i]+"\n");
-			}
-    	}
-    	
-    	Collection tmungers = getTypeMungers();
-    	if (tmungers.size()>0) {
-    		List sorted = new ArrayList();
-    		sorted.addAll(tmungers);
-    		Collections.sort(sorted,new Comparator() {
-    			public int compare(Object arg0, Object arg1) {
-    				 return arg0.toString().compareTo(arg1.toString());
-    			}
-    		});
-    		result.append("The type mungers: "+tmungers.size()+"\n");
-    		int i=0;
-        	for (Iterator iter = sorted.iterator(); iter.hasNext();) {
-				ConcreteTypeMunger mun = (ConcreteTypeMunger) iter.next();
-				result.append("tm"+i+") "+mun.toString()+"\n");
-				i++;
-			}
-    	}
-
-    	result.append("doesNotExposeShadowMungers?"+doesNotExposeShadowMungers()+"\n");
-    	
-    	Collection pas = getPrivilegedAccesses();
-    	if (pas!=null && pas.size()>0) {
-//    		List sorted = new ArrayList();
-//    		sorted.addAll(tmungers);
-//    		Collections.sort(sorted,new Comparator() {
-//    			public int compare(Object arg0, Object arg1) {
-//    				 return arg0.toString().compareTo(arg1.toString());
-//    			}
-//    		});
-    		result.append("The privileged accesses: "+pas.size()+"\n");
-    		int i=0;
-        	for (Iterator iter = pas.iterator(); iter.hasNext();) {
-				ResolvedMember mun = (ResolvedMember) iter.next();
-				result.append("tm"+i+") "+mun.toDebugString()+"\n");
-				i++;
-			}
-    	}
-
-//    	public Collection getPrivilegedAccesses();
-//      public boolean hasAnnotation(UnresolvedType ofType);	
-    	result.append("===");
-    	return result.toString();
-    }
+  
 
     public final String getSourcefilename() {
     	return sourcefilename;
@@ -72,8 +72,6 @@ public interface Member extends Comparable {
 	 */
 	public String getParameterSignature();
 
-	public boolean isCompatibleWith(Member am);
-
 	public int getModifiers(World world);
 
 	public int getModifiers();
@@ -386,30 +386,9 @@ public class MemberImpl implements Member {
     	return paramSignature;
     }
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#isCompatibleWith(org.aspectj.weaver.Member)
-	 */
-    public boolean isCompatibleWith(Member am) {
-        if (kind != METHOD || am.getKind() != METHOD) return true;
-        if (! name.equals(am.getName())) return true;
-        if (! equalTypes(getParameterTypes(), am.getParameterTypes())) return true;
-        return getReturnType().equals(am.getReturnType());
-    }
-    
-    private static boolean equalTypes(UnresolvedType[] a, UnresolvedType[] b) {
-        int len = a.length;
-        if (len != b.length) return false;
-        for (int i = 0; i < len; i++) {
-            if (!a[i].equals(b[i])) return false;
-        }
-        return true;
-    }
-    
+    // OPTIMIZE see next line. Why the hell are they in here if we only know it once resolution has occurred...
     // ---- things we know only with resolution
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getModifiers(org.aspectj.weaver.World)
-	 */
     public int getModifiers(World world) {
     	ResolvedMember resolved = resolve(world);
     	if (resolved == null) {
@@ -419,9 +398,6 @@ public class MemberImpl implements Member {
 		return resolved.getModifiers();
     }
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getExceptions(org.aspectj.weaver.World)
-	 */
     public UnresolvedType[] getExceptions(World world) {
     	ResolvedMember resolved = resolve(world);
     	if (resolved == null) {
@@ -34,10 +34,10 @@ public interface ResolvedMember extends Member, AnnotatedElement, TypeVariableDe
 
 	public ShadowMunger getAssociatedShadowMunger();
 
-	//OPTIMIZE have param annotation (and anno default value) related stuff here rather than above
-	// ??? true or false?
 	public boolean isAjSynthetic();
 
+	public boolean isCompatibleWith(Member am);
+	
 	public boolean hasAnnotations();
 
 	public boolean hasAnnotation(UnresolvedType ofType);
@@ -1031,7 +1031,22 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
     	return buf.toString();    	
     }
 
+   public boolean isCompatibleWith(Member am) {
+       if (kind != METHOD || am.getKind() != METHOD) return true;
+       if (! name.equals(am.getName())) return true;
+       if (! equalTypes(getParameterTypes(), am.getParameterTypes())) return true;
+       return getReturnType().equals(am.getReturnType());
+   }
 
+   private static boolean equalTypes(UnresolvedType[] a, UnresolvedType[] b) {
+       int len = a.length;
+       if (len != b.length) return false;
+       for (int i = 0; i < len; i++) {
+           if (!a[i].equals(b[i])) return false;
+       }
+       return true;
+   }
+   
 
 	public TypeVariable getTypeVariableNamed(String name) {
 		// Check locally...
@@ -838,6 +838,7 @@ public abstract class World implements Dump.INode {
 		return targetAspectjRuntimeLevel;
 	}
 
+	// OPTIMIZE are users falling foul of not supplying -1.5 and so targetting the old runtime?
 	public boolean isTargettingAspectJRuntime12() {
 		boolean b = false; // pr116679
 		if (!isInJava5Mode()) b=true;
@@ -53,26 +53,24 @@ import org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.GenericSigna
 
 public final class BcelMethod extends ResolvedMemberImpl {
 
-
 	private Method method;
+
+	// these fields are not set for many BcelMethods...
 	private ShadowMunger associatedShadowMunger;
 	private ResolvedPointcutDefinition preResolvedPointcut;  // used when ajc has pre-resolved the pointcut of some @Advice
+	private AjAttribute.EffectiveSignatureAttribute effectiveSignature;
+	
 
-//    private ResolvedType[] annotationTypes = null;
+	private AjAttribute.MethodDeclarationLineNumberAttribute declarationLineNumber;	
     private AnnotationX[] annotations = null;
     private AnnotationX[][] parameterAnnotations = null;
-	
-	private AjAttribute.EffectiveSignatureAttribute effectiveSignature;
-	private AjAttribute.MethodDeclarationLineNumberAttribute declarationLineNumber;
 	private BcelObjectType bcelObjectType;
 
-	private boolean parameterNamesInitialized = false;
-	
 	private int bitflags;
-	private static final int KNOW_IF_SYNTHETIC           = 0x0001;
-	private static final int PARAMETER_NAMES_INITIALIZED = 0x0002;
-	private static final int CAN_BE_PARAMETERIZED        = 0x0004;
-	private static final int UNPACKED_GENERIC_SIGNATURE  = 0x0008;
+	private static final int KNOW_IF_SYNTHETIC           = 0x0001; // used
+	private static final int PARAMETER_NAMES_INITIALIZED = 0x0002; // used
+	private static final int CAN_BE_PARAMETERIZED        = 0x0004; // used
+	private static final int UNPACKED_GENERIC_SIGNATURE  = 0x0008; // used
 	private static final int HAS_EFFECTIVE_SIGNATURE     = 0x0010;
 	private static final int HAS_PRERESOLVED_POINTCUT    = 0x0020;
 	private static final int IS_AJ_SYNTHETIC             = 0x0040;
@@ -80,14 +78,12 @@ public final class BcelMethod extends ResolvedMemberImpl {
 	private static final int IS_SYNTHETIC_INVERSE        = 0x7f7f; // all bits but IS_SYNTHETIC (and topmost bit)
 	private static final int HAS_ASSOCIATED_SHADOWMUNGER = 0x0100;
 	private static final int HAS_GENERIC_RETPARAM_TYPES  = 0x0200;
-	private static final int HAS_ANNOTATIONS             = 0x0400;
-	private static final int HAVE_DETERMINED_ANNOTATIONS = 0x0800;
+	private static final int HAS_ANNOTATIONS             = 0x0400; // used
+	private static final int HAVE_DETERMINED_ANNOTATIONS = 0x0800; // used
 	private static final int HAS_MD_LINE_NUMBER_ATTRIBUTE= 0x1000;
 
 
-	 private boolean canBeParameterized = false;
 	 // genericized version of return and parameter types
-	 private boolean unpackedGenericSignature = false;
 	 private UnresolvedType genericReturnType = null;
 	 private UnresolvedType[] genericParameterTypes = null;
 
@@ -132,8 +128,8 @@ public final class BcelMethod extends ResolvedMemberImpl {
     }
 
 	public void determineParameterNames() {
-		if (parameterNamesInitialized) return;
-		parameterNamesInitialized=true;
+		if ((bitflags&PARAMETER_NAMES_INITIALIZED)!=0) { return; }
+		bitflags|=PARAMETER_NAMES_INITIALIZED;
 		LocalVariableTable varTable = method.getLocalVariableTable();
 		int len = getArity();
 		if (varTable == null) {
@@ -431,7 +427,7 @@ public final class BcelMethod extends ResolvedMemberImpl {
 	  */
 	 public boolean canBeParameterized() {
 		 unpackGenericSignature();
-		return canBeParameterized;
+		return (bitflags & CAN_BE_PARAMETERIZED)!=0;
 	}
 
 
@@ -452,8 +448,8 @@ public final class BcelMethod extends ResolvedMemberImpl {
 	 public Method getMethod() { return method; }
 
 	 private void unpackGenericSignature() {
-		 if (unpackedGenericSignature) return;
-		 unpackedGenericSignature = true;
+		if ((bitflags&UNPACKED_GENERIC_SIGNATURE)!=0) { return; }
+		bitflags|=UNPACKED_GENERIC_SIGNATURE;
  		 if (!bcelObjectType.getWorld().isInJava5Mode()) { 
  			 this.genericReturnType = getReturnType();
  			 this.genericParameterTypes = getParameterTypes();
@@ -464,7 +460,7 @@ public final class BcelMethod extends ResolvedMemberImpl {
 			 Signature.MethodTypeSignature mSig = new GenericSignatureParser().parseAsMethodSignature(gSig);//method.getGenericSignature());
  			 if (mSig.formalTypeParameters.length > 0) {
 				// generic method declaration
-				canBeParameterized = true;
+				bitflags|=CAN_BE_PARAMETERIZED;
 			 }
 
  			typeVariables = new TypeVariable[mSig.formalTypeParameters.length];
@@ -517,7 +513,7 @@ public final class BcelMethod extends ResolvedMemberImpl {
 							+ e.getMessage());
 				}
 				if (paramTypeSigs[i] instanceof TypeVariableSignature) {
-					canBeParameterized = true;
+					bitflags|=CAN_BE_PARAMETERIZED;
 				}
 			 }
 		 } else {
@@ -549,10 +545,8 @@ public final class BcelMethod extends ResolvedMemberImpl {
 	private void workOutIfSynthetic() {
 		if ((bitflags&KNOW_IF_SYNTHETIC)!=0) return;
 		bitflags|=KNOW_IF_SYNTHETIC;
-//		knowIfSynthetic=true;
 		JavaClass jc = bcelObjectType.getJavaClass();
 	    bitflags&=IS_SYNTHETIC_INVERSE; // unset the bit
-//		isSynthetic=false;
 		if (jc==null) return; // what the hell has gone wrong?
 		if (jc.getMajor()<49/*Java5*/) {
 			// synthetic is an attribute
@@ -561,7 +555,6 @@ public final class BcelMethod extends ResolvedMemberImpl {
 				for (int i = 0; i < synthetics.length; i++) {
 					if (synthetics[i].equals("Synthetic")) {
 						bitflags|=IS_SYNTHETIC;
-//						isSynthetic=true;
 						break;}
 				}
 			}
@@ -570,7 +563,6 @@ public final class BcelMethod extends ResolvedMemberImpl {
 			if ((modifiers&4096)!=0) {
 				bitflags|=IS_SYNTHETIC;
 			}
-//			isSynthetic = (modifiers&4096)!=0;
 		}
 	}
 
@@ -24,6 +24,189 @@ import org.aspectj.weaver.patterns.SimpleScope;
 public class TestUtils {
     private static final String[] ZERO_STRINGS = new String[0];
 
+    // For stringifying a delegate - extracted from AbstractReferenceTypeDelegate, not fixed up
+//    /**
+//     * Create the string representation for a delegate, allowing us to 
+//     * more easily compare delegate implementations.
+//     */
+//    public String stringifyDelegate() {
+//    	
+//    	StringBuffer result = new StringBuffer();
+//    	result.append("=== Delegate for "+getResolvedTypeX().getName()+"\n");
+//    	
+//    	result.append("isAspect?"+isAspect()+"\n");
+//    	result.append("isAnnotationStyleAspect?"+isAnnotationStyleAspect()+"\n");
+//    	result.append("isInterface?"+isInterface()+"\n");
+//    	result.append("isEnum?"+isEnum()+"\n");
+//    	result.append("isClass?"+isClass()+"\n");
+//    	result.append("-\n");
+//    	result.append("isAnnotation?"+isAnnotation()+"\n");
+//    	result.append("retentionPolicy="+getRetentionPolicy()+"\n");
+//    	result.append("canAnnotationTargetType?"+canAnnotationTargetType()+"\n");
+//    	AnnotationTargetKind[] kinds = getAnnotationTargetKinds();
+//    	if (kinds!=null && kinds.length>0) {
+//    		result.append("annotationTargetKinds:[");
+//    		for (int i = 0; i < kinds.length; i++) {
+//				AnnotationTargetKind kind = kinds[i];
+//				result.append(kind);
+//				if ((i+1)<kinds.length) result.append(" ");
+//			}
+//    		result.append("]\n");
+//    	}
+//    	result.append("isAnnotationWithRuntimeRetention?"+isAnnotationWithRuntimeRetention()+"\n");
+//    	result.append("-\n");
+//    	
+//    	result.append("isAnonymous?"+isAnonymous()+"\n");
+//    	result.append("isNested?"+isNested()+"\n");
+//    	result.append("-\n");
+//
+//    	result.append("isGeneric?"+isGeneric()+"\n");
+//    	result.append("declaredGenericSignature="+getDeclaredGenericSignature()+"\n");
+//    	result.append("-\n");
+//    	
+//    	AnnotationX[] axs = getAnnotations();
+//    	if (axs!=null && axs.length>0) {
+//    		result.append("getAnnotations() returns: "+axs.length+" annotations\n");
+//    		for (int i = 0; i < axs.length; i++) {
+//				AnnotationX annotationX = axs[i];
+//				result.append("  #"+i+") "+annotationX+"\n");
+//    		}
+//		} else {
+//			result.append("getAnnotations() returns nothing\n");
+//		}
+//    	ResolvedType[] axtypes = getAnnotationTypes();
+//    	if (axtypes!=null && axtypes.length>0) {
+//    		result.append("getAnnotationTypes() returns: "+axtypes.length+" annotations\n");
+//    		for (int i = 0; i < axtypes.length; i++) {
+//				ResolvedType annotation = axtypes[i];
+//				result.append("  #"+i+") "+annotation+":"+annotation.getClass()+"\n");
+//			}
+//    	} else {
+//			result.append("getAnnotationTypes() returns nothing\n");
+//		}
+//    	
+//    	result.append("isExposedToWeaver?"+isExposedToWeaver()+"\n");
+//    	result.append("getSuperclass?"+getSuperclass()+"\n");
+//    	result.append("getResolvedTypeX?"+getResolvedTypeX()+"\n");
+//    	result.append("--\n");
+//    	
+//    	ResolvedMember[] fields = getDeclaredFields();
+//    	if (fields!=null && fields.length>0) {
+//        	result.append("The fields: "+fields.length+"\n");
+//    		for (int i = 0; i < fields.length; i++) {
+//				ResolvedMember member = fields[i];
+//				result.append("f"+i+") "+member.toDebugString()+"\n");
+//			}
+//    	}
+//    	ResolvedMember[] methods = getDeclaredMethods();
+//    	if (methods!=null && methods.length>0) {
+//        	result.append("The methods: "+methods.length+"\n");
+//    		for (int i = 0; i < methods.length; i++) {
+//				ResolvedMember member = methods[i];
+//				result.append("m"+i+") "+member.toDebugString()+"\n");
+//			}
+//    	}
+//    	ResolvedType[] interfaces = getDeclaredInterfaces();
+//    	if (interfaces!=null && interfaces.length>0) {
+//        	result.append("The interfaces: "+interfaces.length+"\n");
+//    		for (int i = 0; i < interfaces.length; i++) {
+//    			ResolvedType member = interfaces[i];
+//				result.append("i"+i+") "+member+"\n");
+//			}
+//    	}
+//
+//    	result.append("getModifiers?"+getModifiers()+"\n");
+//    	
+//    	result.append("perclause="+getPerClause()+"\n");
+//    	
+//    	result.append("aj:weaverstate="+getWeaverState()+"\n");
+//    	
+//    	ResolvedMember[] pointcuts = getDeclaredPointcuts();
+//    	if (pointcuts!=null && pointcuts.length>0) {
+//    		result.append("The pointcuts: "+pointcuts.length+"\n");
+//    		
+//    		// Sort the damn things
+//        	List sortedSetOfPointcuts = new ArrayList();
+//        	for (int i = 0; i < pointcuts.length; i++) {sortedSetOfPointcuts.add(pointcuts[i]);}
+//        	Collections.sort(sortedSetOfPointcuts);
+//        	
+//        	int i =0;
+//        	for (Iterator iter = sortedSetOfPointcuts.iterator(); iter.hasNext();) {
+//				ResolvedMember member = (ResolvedMember) iter.next();
+//				result.append("p"+i+") "+member.toDebugString()+"\n");
+//				i++;
+//			}
+//    	}
+//    	
+//    	Collection declares = getDeclares();
+//    	if (declares.size()>0) {
+//    		result.append("The declares: "+declares.size()+"\n");
+//    		
+////    		// Sort the damn things
+////        	List sortedSetOfPointcuts = new ArrayList();
+////        	for (int i = 0; i < pointcuts.length; i++) {sortedSetOfPointcuts.add(pointcuts[i]);}
+////        	Collections.sort(sortedSetOfPointcuts);
+//        	
+//        	int i=0;
+//        	for (Iterator iter = declares.iterator(); iter.hasNext();) {
+//				Declare dec = (Declare) iter.next();
+//				result.append("d"+i+") "+dec.toString()+"\n");
+//				i++;
+//			}
+//    	}
+//    	
+//    	TypeVariable[] tv = getTypeVariables();
+//    	if (tv!=null && tv.length>0) {
+//        	result.append("The type variables: "+tv.length+"\n");
+//    		for (int i = 0; i < tv.length; i++) {
+//				result.append("tv"+i+") "+tv[i]+"\n");
+//			}
+//    	}
+//    	
+//    	Collection tmungers = getTypeMungers();
+//    	if (tmungers.size()>0) {
+//    		List sorted = new ArrayList();
+//    		sorted.addAll(tmungers);
+//    		Collections.sort(sorted,new Comparator() {
+//    			public int compare(Object arg0, Object arg1) {
+//    				 return arg0.toString().compareTo(arg1.toString());
+//    			}
+//    		});
+//    		result.append("The type mungers: "+tmungers.size()+"\n");
+//    		int i=0;
+//        	for (Iterator iter = sorted.iterator(); iter.hasNext();) {
+//				ConcreteTypeMunger mun = (ConcreteTypeMunger) iter.next();
+//				result.append("tm"+i+") "+mun.toString()+"\n");
+//				i++;
+//			}
+//    	}
+//
+//    	result.append("doesNotExposeShadowMungers?"+doesNotExposeShadowMungers()+"\n");
+//    	
+//    	Collection pas = getPrivilegedAccesses();
+//    	if (pas!=null && pas.size()>0) {
+////    		List sorted = new ArrayList();
+////    		sorted.addAll(tmungers);
+////    		Collections.sort(sorted,new Comparator() {
+////    			public int compare(Object arg0, Object arg1) {
+////    				 return arg0.toString().compareTo(arg1.toString());
+////    			}
+////    		});
+//    		result.append("The privileged accesses: "+pas.size()+"\n");
+//    		int i=0;
+//        	for (Iterator iter = pas.iterator(); iter.hasNext();) {
+//				ResolvedMember mun = (ResolvedMember) iter.next();
+//				result.append("tm"+i+") "+mun.toDebugString()+"\n");
+//				i++;
+//			}
+//    	}
+//
+////    	public Collection getPrivilegedAccesses();
+////      public boolean hasAnnotation(UnresolvedType ofType);	
+//    	result.append("===");
+//    	return result.toString();
+//    }
+    
     /**
      * Build a member from a string representation:
      * <blockquote><pre>
@@ -1,6 +1,6 @@
 public class DynamicHelloWorld extends java.lang.Object implements java.io.Serializable:
   public void <init>():
-                    ALOAD_0     // DynamicHelloWorld this   (line 8)
+                    ALOAD_0     // LDynamicHelloWorld; this   (line 8)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void DynamicHelloWorld.<init>())
     |               RETURN
@@ -27,7 +27,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               DUP
     |               LDC "expected and caught: "
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ALOAD_1     // java.lang.UnsupportedOperationException t
+    |               ALOAD_1     // Ljava/lang/UnsupportedOperationException; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -48,8 +48,8 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
 
   String doit(String, java.util.List):
     method-execution(java.lang.String DynamicHelloWorld.doit(java.lang.String, java.util.List))
-    |               ALOAD_2     // java.util.List l   (line 21)
-    |               ALOAD_1     // java.lang.String s
+    |               ALOAD_2     // Ljava/util/List; l   (line 21)
+    |               ALOAD_1     // Ljava/lang/String; s
     |               ASTORE_3
     |               ASTORE 4
     | method-call(boolean java.util.List.add(java.lang.Object))
@@ -62,7 +62,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     | |             INVOKEINTERFACE java.util.List.add (Ljava/lang/Object;)Z
     | method-call(boolean java.util.List.add(java.lang.Object))
     |               POP
-    |               ALOAD_2     // java.util.List l   (line 22)
+    |               ALOAD_2     // Ljava/util/List; l   (line 22)
     | method-call(java.lang.String java.lang.Object.toString())
     | |             INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String;
     | method-call(java.lang.String java.lang.Object.toString())
@@ -1,6 +1,6 @@
 public class DynamicHelloWorld extends java.lang.Object implements java.io.Serializable:
   public void <init>():
-                    ALOAD_0     // DynamicHelloWorld this   (line 8)
+                    ALOAD_0     // LDynamicHelloWorld; this   (line 8)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void DynamicHelloWorld.<init>())
     |               RETURN
@@ -27,7 +27,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               DUP
     |               LDC "expected and caught: "
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ALOAD_1     // java.lang.UnsupportedOperationException t
+    |               ALOAD_1     // Ljava/lang/UnsupportedOperationException; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -48,8 +48,8 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
 
   String doit(String, java.util.List):
     method-execution(java.lang.String DynamicHelloWorld.doit(java.lang.String, java.util.List))
-    |               ALOAD_2     // java.util.List l   (line 21)
-    |               ALOAD_1     // java.lang.String s
+    |               ALOAD_2     // Ljava/util/List; l   (line 21)
+    |               ALOAD_1     // Ljava/lang/String; s
     |               ASTORE_3
     |               ASTORE 4
     | method-call(boolean java.util.List.add(java.lang.Object))
@@ -62,7 +62,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     | |             INVOKEINTERFACE java.util.List.add (Ljava/lang/Object;)Z
     | method-call(boolean java.util.List.add(java.lang.Object))
     |               POP
-    |               ALOAD_2     // java.util.List l   (line 22)
+    |               ALOAD_2     // Ljava/util/List; l   (line 22)
     | method-call(java.lang.String java.lang.Object.toString())
     | |             INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String;
     | method-call(java.lang.String java.lang.Object.toString())
@@ -1,6 +1,6 @@
 public class DynamicHelloWorld extends java.lang.Object implements java.io.Serializable:
   public void <init>():
-                    ALOAD_0     // DynamicHelloWorld this   (line 8)
+                    ALOAD_0     // LDynamicHelloWorld; this   (line 8)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void DynamicHelloWorld.<init>())
     |               RETURN
@@ -27,7 +27,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               DUP
     |               LDC "expected and caught: "
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ALOAD_1     // java.lang.UnsupportedOperationException t
+    |               ALOAD_1     // Ljava/lang/UnsupportedOperationException; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -48,8 +48,8 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
 
   String doit(String, java.util.List):
     method-execution(java.lang.String DynamicHelloWorld.doit(java.lang.String, java.util.List))
-    |               ALOAD_2     // java.util.List l   (line 21)
-    |               ALOAD_1     // java.lang.String s
+    |               ALOAD_2     // Ljava/util/List; l   (line 21)
+    |               ALOAD_1     // Ljava/lang/String; s
     |               ASTORE_3
     |               ASTORE 4
     | method-call(boolean java.util.List.add(java.lang.Object))
@@ -64,7 +64,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     | |             INVOKEINTERFACE java.util.List.add (Ljava/lang/Object;)Z
     | method-call(boolean java.util.List.add(java.lang.Object))
     |               POP
-    |               ALOAD_2     // java.util.List l   (line 22)
+    |               ALOAD_2     // Ljava/util/List; l   (line 22)
     | method-call(java.lang.String java.lang.Object.toString())
     | |             INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String;
     | method-call(java.lang.String java.lang.Object.toString())
@@ -1,14 +1,14 @@
 public abstract class FancyHelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // FancyHelloWorld this   (line 7)
+                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void FancyHelloWorld.<init>())
     |               INVOKESTATIC Aspect.ajc_before_constructor_execution ()V
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE_2
     |               ALOAD_2
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_0
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure3
@@ -26,11 +26,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     ASTORE 19
     method-execution(void FancyHelloWorld.main(java.lang.String[]))
     |               INVOKESTATIC Aspect.ajc_before_method_execution ()V   (line 9)
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 21
     |               ALOAD 21
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 19
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure23
@@ -46,7 +46,7 @@ public abstract class FancyHelloWorld extends java.lang.Object:
   public static String getName():
     method-execution(java.lang.String FancyHelloWorld.getName())
     |               INVOKESTATIC Aspect.ajc_before_method_execution ()V   (line 20)
-    |               BIPUSH 0
+    |               ICONST_0
     |               ANEWARRAY java.lang.Object
     |               ASTORE 15
     |               NEW FancyHelloWorld$AjcClosure43
@@ -65,11 +65,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void init$_aroundBody2(FancyHelloWorld):
                     INVOKESTATIC Aspect.ajc_before_constructor_execution ()V
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure1
@@ -88,7 +88,7 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final java.io.PrintStream out_aroundBody6():
                     INVOKESTATIC Aspect.ajc_before_field_get ()V
-                    BIPUSH 0
+                    ICONST_0
                     ANEWARRAY java.lang.Object
                     ASTORE_0
                     NEW FancyHelloWorld$AjcClosure5
@@ -109,15 +109,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void println_aroundBody10(java.io.PrintStream, String):
                     INVOKESTATIC Aspect.ajc_before_method_call ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure9
@@ -138,15 +138,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void println_aroundBody14(java.io.PrintStream, Object):
                     INVOKESTATIC Aspect.ajc_before_method_call ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure13
@@ -167,15 +167,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void println_aroundBody18(java.io.PrintStream, String):
                     INVOKESTATIC Aspect.ajc_before_method_call ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure17
@@ -190,7 +190,7 @@ public abstract class FancyHelloWorld extends java.lang.Object:
   static final void main_aroundBody20(String[]):
     field-get(java.io.PrintStream java.lang.System.out)
     |               INVOKESTATIC Aspect.ajc_before_field_get ()V
-    |               BIPUSH 0
+    |               ICONST_0
     |               ANEWARRAY java.lang.Object
     |               ASTORE_1
     |               NEW FancyHelloWorld$AjcClosure7
@@ -203,21 +203,21 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     ASTORE_3   (line 9)
     finally -> E1
     | catch java.lang.Exception -> E0
-    | |             ALOAD_3     // java.io.PrintStream out   (line 11)
+    | |             ALOAD_3     // Ljava/io/PrintStream; out   (line 11)
     | |             LDC "bye"
     | |             ASTORE 5
     | |             ASTORE 7
     | | method-call(void java.io.PrintStream.println(java.lang.String))
     | | |           INVOKESTATIC Aspect.ajc_before_method_call ()V
-    | | |           BIPUSH 2
+    | | |           ICONST_2
     | | |           ANEWARRAY java.lang.Object
     | | |           ASTORE 9
     | | |           ALOAD 9
-    | | |           BIPUSH 0
+    | | |           ICONST_0
     | | |           ALOAD 7
     | | |           AASTORE
     | | |           ALOAD 9
-    | | |           BIPUSH 1
+    | | |           ICONST_1
     | | |           ALOAD 5
     | | |           AASTORE
     | | |           NEW FancyHelloWorld$AjcClosure11
@@ -230,21 +230,21 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     | |             GOTO L0
     | catch java.lang.Exception -> E0
     |           E0: ASTORE 11   (line 12)
-    |               ALOAD_3     // java.io.PrintStream out   (line 13)
-    |               ALOAD 11     // java.lang.Exception e
+    |               ALOAD_3     // Ljava/io/PrintStream; out   (line 13)
+    |               ALOAD 11     // Ljava/lang/Exception; e
     |               ASTORE 13
     |               ASTORE 15
     | method-call(void java.io.PrintStream.println(java.lang.Object))
     | |             INVOKESTATIC Aspect.ajc_before_method_call ()V
-    | |             BIPUSH 2
+    | |             ICONST_2
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE 17
     | |             ALOAD 17
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD 15
     | |             AASTORE
     | |             ALOAD 17
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ALOAD 13
     | |             AASTORE
     | |             NEW FancyHelloWorld$AjcClosure15
@@ -263,21 +263,21 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                 L0: JSR L1
                     GOTO L2
                 L1: ASTORE 21
-                    ALOAD_3     // java.io.PrintStream out   (line 15)
+                    ALOAD_3     // Ljava/io/PrintStream; out   (line 15)
                     LDC "finally"
                     ASTORE 23
                     ASTORE 25
     method-call(void java.io.PrintStream.println(java.lang.String))
     |               INVOKESTATIC Aspect.ajc_before_method_call ()V
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE 27
     |               ALOAD 27
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 25
     |               AASTORE
     |               ALOAD 27
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD 23
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure19
@@ -293,11 +293,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void main_aroundBody22(String[]):
                     INVOKESTATIC Aspect.ajc_before_method_execution ()V   (line 9)
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure21
@@ -317,11 +317,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final int hashCode_aroundBody26(String):
                     INVOKESTATIC Aspect.ajc_before_method_call ()V
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure25
@@ -343,11 +343,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final StringBuffer init$_aroundBody30(String):
                     INVOKESTATIC Aspect.ajc_before_constructor_call ()V
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure29
@@ -368,15 +368,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final StringBuffer append_aroundBody34(StringBuffer, int):
                     INVOKESTATIC Aspect.ajc_before_method_call ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ILOAD_1
                     INVOKESTATIC org.aspectj.runtime.internal.Conversions.intObject (I)Ljava/lang/Object;
                     AASTORE
@@ -397,11 +397,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final String toString_aroundBody38(StringBuffer):
                     INVOKESTATIC Aspect.ajc_before_method_call ()V
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure37
@@ -416,16 +416,16 @@ public abstract class FancyHelloWorld extends java.lang.Object:
   static final String getName_aroundBody40():
                     ICONST_0   (line 20)
                     ISTORE_0
-                    ILOAD_0     // int x   (line 21)
+                    ILOAD_0     // I x   (line 21)
                     LDC "name"
                     ASTORE_2
     method-call(int java.lang.String.hashCode())
     |               INVOKESTATIC Aspect.ajc_before_method_call ()V
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 4
     |               ALOAD 4
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_2
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure27
@@ -436,16 +436,16 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     |               INVOKESTATIC org.aspectj.runtime.internal.Conversions.intValue (Ljava/lang/Object;)I
     method-call(int java.lang.String.hashCode())
                     IADD
-                    ISTORE_0     // int x
+                    ISTORE_0     // I x
                     LDC "name"   (line 22)
                     ASTORE 6
     constructor-call(void java.lang.StringBuffer.<init>(java.lang.String))
     |               INVOKESTATIC Aspect.ajc_before_constructor_call ()V
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 8
     |               ALOAD 8
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 6
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure31
@@ -455,20 +455,20 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     |               INVOKESTATIC Aspect.ajc_around (Lorg/aspectj/runtime/internal/AroundClosure;)Ljava/lang/Object;
     |               CHECKCAST java.lang.StringBuffer
     constructor-call(void java.lang.StringBuffer.<init>(java.lang.String))
-                    ILOAD_0     // int x
+                    ILOAD_0     // I x
                     ISTORE 10
                     ASTORE 12
     method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))
     |               INVOKESTATIC Aspect.ajc_before_method_call ()V
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE 14
     |               ALOAD 14
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 12
     |               AASTORE
     |               ALOAD 14
-    |               BIPUSH 1
+    |               ICONST_1
     |               ILOAD 10
     |               INVOKESTATIC org.aspectj.runtime.internal.Conversions.intObject (I)Ljava/lang/Object;
     |               AASTORE
@@ -482,11 +482,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     ASTORE 16
     method-call(java.lang.String java.lang.StringBuffer.toString())
     |               INVOKESTATIC Aspect.ajc_before_method_call ()V
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 18
     |               ALOAD 18
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 16
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure39
@@ -501,7 +501,7 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final String getName_aroundBody42():
                     INVOKESTATIC Aspect.ajc_before_method_execution ()V   (line 20)
-                    BIPUSH 0
+                    ICONST_0
                     ANEWARRAY java.lang.Object
                     ASTORE_0
                     NEW FancyHelloWorld$AjcClosure41
@@ -527,7 +527,7 @@ public class FancyHelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST FancyHelloWorld
                     INVOKESTATIC FancyHelloWorld.init$_aroundBody0 (LFancyHelloWorld;)V
@@ -549,7 +549,7 @@ public class FancyHelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST FancyHelloWorld
                     INVOKESTATIC FancyHelloWorld.init$_aroundBody2 (LFancyHelloWorld;)V
@@ -605,11 +605,11 @@ public class FancyHelloWorld$AjcClosure9 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody8 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -631,11 +631,11 @@ public class FancyHelloWorld$AjcClosure11 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody10 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -657,11 +657,11 @@ public class FancyHelloWorld$AjcClosure13 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC FancyHelloWorld.println_aroundBody12 (Ljava/io/PrintStream;Ljava/lang/Object;)V
                     ACONST_NULL
@@ -682,11 +682,11 @@ public class FancyHelloWorld$AjcClosure15 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC FancyHelloWorld.println_aroundBody14 (Ljava/io/PrintStream;Ljava/lang/Object;)V
                     ACONST_NULL
@@ -707,11 +707,11 @@ public class FancyHelloWorld$AjcClosure17 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody16 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -733,11 +733,11 @@ public class FancyHelloWorld$AjcClosure19 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody18 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -759,7 +759,7 @@ public class FancyHelloWorld$AjcClosure21 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     INVOKESTATIC FancyHelloWorld.main_aroundBody20 ([Ljava/lang/String;)V
@@ -781,7 +781,7 @@ public class FancyHelloWorld$AjcClosure23 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     INVOKESTATIC FancyHelloWorld.main_aroundBody22 ([Ljava/lang/String;)V
@@ -803,7 +803,7 @@ public class FancyHelloWorld$AjcClosure25 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.hashCode_aroundBody24 (Ljava/lang/String;)I
@@ -825,7 +825,7 @@ public class FancyHelloWorld$AjcClosure27 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.hashCode_aroundBody26 (Ljava/lang/String;)I
@@ -847,7 +847,7 @@ public class FancyHelloWorld$AjcClosure29 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.init$_aroundBody28 (Ljava/lang/String;)Ljava/lang/StringBuffer;
@@ -868,7 +868,7 @@ public class FancyHelloWorld$AjcClosure31 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.init$_aroundBody30 (Ljava/lang/String;)Ljava/lang/StringBuffer;
@@ -889,11 +889,11 @@ public class FancyHelloWorld$AjcClosure33 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.StringBuffer
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC org.aspectj.runtime.internal.Conversions.intValue (Ljava/lang/Object;)I
                     INVOKESTATIC FancyHelloWorld.append_aroundBody32 (Ljava/lang/StringBuffer;I)Ljava/lang/StringBuffer;
@@ -914,11 +914,11 @@ public class FancyHelloWorld$AjcClosure35 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.StringBuffer
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC org.aspectj.runtime.internal.Conversions.intValue (Ljava/lang/Object;)I
                     INVOKESTATIC FancyHelloWorld.append_aroundBody34 (Ljava/lang/StringBuffer;I)Ljava/lang/StringBuffer;
@@ -939,7 +939,7 @@ public class FancyHelloWorld$AjcClosure37 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.StringBuffer
                     INVOKESTATIC FancyHelloWorld.toString_aroundBody36 (Ljava/lang/StringBuffer;)Ljava/lang/String;
@@ -960,7 +960,7 @@ public class FancyHelloWorld$AjcClosure39 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.StringBuffer
                     INVOKESTATIC FancyHelloWorld.toString_aroundBody38 (Ljava/lang/StringBuffer;)Ljava/lang/String;
@@ -1,14 +1,14 @@
 public class HelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // HelloWorld this   (line 5)
+                    ALOAD_0     // LHelloWorld; this   (line 5)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void HelloWorld.<init>())
     |               INVOKESTATIC Aspect.ajc_before_constructor_execution ()V
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE_2
     |               ALOAD_2
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_0
     |               AASTORE
     |               NEW HelloWorld$AjcClosure3
@@ -26,11 +26,11 @@ public class HelloWorld extends java.lang.Object:
                     ASTORE 7
     method-execution(void HelloWorld.main(java.lang.String[]))
     |               INVOKESTATIC Aspect.ajc_before_method_execution ()V   (line 8)
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 9
     |               ALOAD 9
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 7
     |               AASTORE
     |               NEW HelloWorld$AjcClosure15
@@ -49,11 +49,11 @@ public class HelloWorld extends java.lang.Object:
 
   static final void init$_aroundBody2(HelloWorld):
                     INVOKESTATIC Aspect.ajc_before_constructor_execution ()V
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW HelloWorld$AjcClosure1
@@ -72,7 +72,7 @@ public class HelloWorld extends java.lang.Object:
 
   static final java.io.PrintStream out_aroundBody6():
                     INVOKESTATIC Aspect.ajc_before_field_get ()V
-                    BIPUSH 0
+                    ICONST_0
                     ANEWARRAY java.lang.Object
                     ASTORE_0
                     NEW HelloWorld$AjcClosure5
@@ -93,15 +93,15 @@ public class HelloWorld extends java.lang.Object:
 
   static final void println_aroundBody10(java.io.PrintStream, String):
                     INVOKESTATIC Aspect.ajc_before_method_call ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW HelloWorld$AjcClosure9
@@ -116,7 +116,7 @@ public class HelloWorld extends java.lang.Object:
   static final void main_aroundBody12(String[]):
     field-get(java.io.PrintStream java.lang.System.out)
     |               INVOKESTATIC Aspect.ajc_before_field_get ()V
-    |               BIPUSH 0
+    |               ICONST_0
     |               ANEWARRAY java.lang.Object
     |               ASTORE_1
     |               NEW HelloWorld$AjcClosure7
@@ -131,15 +131,15 @@ public class HelloWorld extends java.lang.Object:
                     ASTORE 5
     method-call(void java.io.PrintStream.println(java.lang.String))
     |               INVOKESTATIC Aspect.ajc_before_method_call ()V
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE 7
     |               ALOAD 7
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 5
     |               AASTORE
     |               ALOAD 7
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD_3
     |               AASTORE
     |               NEW HelloWorld$AjcClosure11
@@ -154,11 +154,11 @@ public class HelloWorld extends java.lang.Object:
 
   static final void main_aroundBody14(String[]):
                     INVOKESTATIC Aspect.ajc_before_method_execution ()V   (line 8)
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW HelloWorld$AjcClosure13
@@ -184,7 +184,7 @@ public class HelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST HelloWorld
                     INVOKESTATIC HelloWorld.init$_aroundBody0 (LHelloWorld;)V
@@ -206,7 +206,7 @@ public class HelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST HelloWorld
                     INVOKESTATIC HelloWorld.init$_aroundBody2 (LHelloWorld;)V
@@ -262,11 +262,11 @@ public class HelloWorld$AjcClosure9 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC HelloWorld.println_aroundBody8 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -288,11 +288,11 @@ public class HelloWorld$AjcClosure11 extends org.aspectj.runtime.internal.Around
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC HelloWorld.println_aroundBody10 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -314,7 +314,7 @@ public class HelloWorld$AjcClosure13 extends org.aspectj.runtime.internal.Around
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     INVOKESTATIC HelloWorld.main_aroundBody12 ([Ljava/lang/String;)V
@@ -336,7 +336,7 @@ public class HelloWorld$AjcClosure15 extends org.aspectj.runtime.internal.Around
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     INVOKESTATIC HelloWorld.main_aroundBody14 ([Ljava/lang/String;)V
@@ -3,11 +3,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     ALOAD_0     // LFancyHelloWorld; this   (line 7)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void FancyHelloWorld.<init>())
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE_1
     |               ALOAD_1
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_0
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure1
@@ -24,11 +24,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     ALOAD_0
                     ASTORE 15
     method-execution(void FancyHelloWorld.main(java.lang.String[]))
-    |               BIPUSH 1   (line 9)
+    |               ICONST_1   (line 9)
     |               ANEWARRAY java.lang.Object
     |               ASTORE 16
     |               ALOAD 16
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 15
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure11
@@ -43,7 +43,7 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   public static String getName():
     method-execution(java.lang.String FancyHelloWorld.getName())
-    |               BIPUSH 0   (line 20)
+    |               ICONST_0   (line 20)
     |               ANEWARRAY java.lang.Object
     |               ASTORE 10
     |               NEW FancyHelloWorld$AjcClosure21
@@ -88,7 +88,7 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void main_aroundBody10(String[]):
     field-get(java.io.PrintStream java.lang.System.out)
-    |               BIPUSH 0
+    |               ICONST_0
     |               ANEWARRAY java.lang.Object
     |               ASTORE_1
     |               NEW FancyHelloWorld$AjcClosure3
@@ -106,15 +106,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     | |             ASTORE 5
     | |             ASTORE 7
     | | method-call(void java.io.PrintStream.println(java.lang.String))
-    | | |           BIPUSH 2
+    | | |           ICONST_2
     | | |           ANEWARRAY java.lang.Object
     | | |           ASTORE 9
     | | |           ALOAD 9
-    | | |           BIPUSH 0
+    | | |           ICONST_0
     | | |           ALOAD 7
     | | |           AASTORE
     | | |           ALOAD 9
-    | | |           BIPUSH 1
+    | | |           ICONST_1
     | | |           ALOAD 5
     | | |           AASTORE
     | | |           NEW FancyHelloWorld$AjcClosure5
@@ -132,15 +132,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     |               ASTORE 13
     |               ASTORE 15
     | method-call(void java.io.PrintStream.println(java.lang.Object))
-    | |             BIPUSH 2
+    | |             ICONST_2
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE 17
     | |             ALOAD 17
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD 15
     | |             AASTORE
     | |             ALOAD 17
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ALOAD 13
     | |             AASTORE
     | |             NEW FancyHelloWorld$AjcClosure7
@@ -164,15 +164,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     ASTORE 23
                     ASTORE 25
     method-call(void java.io.PrintStream.println(java.lang.String))
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE 27
     |               ALOAD 27
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 25
     |               AASTORE
     |               ALOAD 27
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD 23
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure9
@@ -220,11 +220,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     LDC "name"
                     ASTORE_2
     method-call(int java.lang.String.hashCode())
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 4
     |               ALOAD 4
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_2
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure13
@@ -239,11 +239,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     LDC "name"   (line 22)
                     ASTORE 6
     constructor-call(void java.lang.StringBuffer.<init>(java.lang.String))
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 8
     |               ALOAD 8
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 6
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure15
@@ -257,15 +257,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     ISTORE 10
                     ASTORE 12
     method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE 14
     |               ALOAD 14
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 12
     |               AASTORE
     |               ALOAD 14
-    |               BIPUSH 1
+    |               ICONST_1
     |               ILOAD 10
     |               INVOKESTATIC org.aspectj.runtime.internal.Conversions.intObject (I)Ljava/lang/Object;
     |               AASTORE
@@ -278,11 +278,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))
                     ASTORE 16
     method-call(java.lang.String java.lang.StringBuffer.toString())
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 18
     |               ALOAD 18
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 16
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure19
@@ -309,7 +309,7 @@ public class FancyHelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST FancyHelloWorld
                     INVOKESTATIC FancyHelloWorld.init$_aroundBody0 (LFancyHelloWorld;)V
@@ -348,11 +348,11 @@ public class FancyHelloWorld$AjcClosure5 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody4 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -374,11 +374,11 @@ public class FancyHelloWorld$AjcClosure7 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC FancyHelloWorld.println_aroundBody6 (Ljava/io/PrintStream;Ljava/lang/Object;)V
                     ACONST_NULL
@@ -399,11 +399,11 @@ public class FancyHelloWorld$AjcClosure9 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody8 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -425,7 +425,7 @@ public class FancyHelloWorld$AjcClosure11 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     INVOKESTATIC FancyHelloWorld.main_aroundBody10 ([Ljava/lang/String;)V
@@ -447,7 +447,7 @@ public class FancyHelloWorld$AjcClosure13 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.hashCode_aroundBody12 (Ljava/lang/String;)I
@@ -469,7 +469,7 @@ public class FancyHelloWorld$AjcClosure15 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.init$_aroundBody14 (Ljava/lang/String;)Ljava/lang/StringBuffer;
@@ -490,11 +490,11 @@ public class FancyHelloWorld$AjcClosure17 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.StringBuffer
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC org.aspectj.runtime.internal.Conversions.intValue (Ljava/lang/Object;)I
                     INVOKESTATIC FancyHelloWorld.append_aroundBody16 (Ljava/lang/StringBuffer;I)Ljava/lang/StringBuffer;
@@ -515,7 +515,7 @@ public class FancyHelloWorld$AjcClosure19 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.StringBuffer
                     INVOKESTATIC FancyHelloWorld.toString_aroundBody18 (Ljava/lang/StringBuffer;)Ljava/lang/String;
@@ -3,11 +3,11 @@ public class HelloWorld extends java.lang.Object:
                     ALOAD_0     // LHelloWorld; this   (line 5)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void HelloWorld.<init>())
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE_1
     |               ALOAD_1
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_0
     |               AASTORE
     |               NEW HelloWorld$AjcClosure1
@@ -24,11 +24,11 @@ public class HelloWorld extends java.lang.Object:
                     ALOAD_0
                     ASTORE 5
     method-execution(void HelloWorld.main(java.lang.String[]))
-    |               BIPUSH 1   (line 8)
+    |               ICONST_1   (line 8)
     |               ANEWARRAY java.lang.Object
     |               ASTORE 6
     |               ALOAD 6
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 5
     |               AASTORE
     |               NEW HelloWorld$AjcClosure7
@@ -59,7 +59,7 @@ public class HelloWorld extends java.lang.Object:
 
   static final void main_aroundBody6(String[]):
     field-get(java.io.PrintStream java.lang.System.out)
-    |               BIPUSH 0
+    |               ICONST_0
     |               ANEWARRAY java.lang.Object
     |               ASTORE_1
     |               NEW HelloWorld$AjcClosure3
@@ -73,15 +73,15 @@ public class HelloWorld extends java.lang.Object:
                     ASTORE_3
                     ASTORE 5
     method-call(void java.io.PrintStream.println(java.lang.String))
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE 7
     |               ALOAD 7
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 5
     |               AASTORE
     |               ALOAD 7
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD_3
     |               AASTORE
     |               NEW HelloWorld$AjcClosure5
@@ -108,7 +108,7 @@ public class HelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST HelloWorld
                     INVOKESTATIC HelloWorld.init$_aroundBody0 (LHelloWorld;)V
@@ -147,11 +147,11 @@ public class HelloWorld$AjcClosure5 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC HelloWorld.println_aroundBody4 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -173,7 +173,7 @@ public class HelloWorld$AjcClosure7 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     INVOKESTATIC HelloWorld.main_aroundBody6 ([Ljava/lang/String;)V
@@ -1,6 +1,6 @@
 public abstract class FancyHelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // FancyHelloWorld this   (line 7)
+                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void FancyHelloWorld.<init>())
     |               RETURN
@@ -13,21 +13,21 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     |               ASTORE_1
     | finally -> E1
     | | catch java.lang.Exception -> E0
-    | | |           ALOAD_1     // java.io.PrintStream out   (line 11)
+    | | |           ALOAD_1     // Ljava/io/PrintStream; out   (line 11)
     | | |           LDC "bye"
     | | |           ASTORE 5
     | | |           ASTORE 6
     | | | method-call(void java.io.PrintStream.println(java.lang.String))
     | | | |         INVOKESTATIC Aspect.ajc_before_method_execution ()V
-    | | | |         BIPUSH 2
+    | | | |         ICONST_2
     | | | |         ANEWARRAY java.lang.Object
     | | | |         ASTORE 8
     | | | |         ALOAD 8
-    | | | |         BIPUSH 0
+    | | | |         ICONST_0
     | | | |         ALOAD 6
     | | | |         AASTORE
     | | | |         ALOAD 8
-    | | | |         BIPUSH 1
+    | | | |         ICONST_1
     | | | |         ALOAD 5
     | | | |         AASTORE
     | | | |         NEW FancyHelloWorld$AjcClosure3
@@ -40,21 +40,21 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     | | |           GOTO L0
     | | catch java.lang.Exception -> E0
     | |         E0: ASTORE_2   (line 12)
-    | |             ALOAD_1     // java.io.PrintStream out   (line 13)
-    | |             ALOAD_2     // java.lang.Exception e
+    | |             ALOAD_1     // Ljava/io/PrintStream; out   (line 13)
+    | |             ALOAD_2     // Ljava/lang/Exception; e
     | |             ASTORE 9
     | |             ASTORE 10
     | | method-call(void java.io.PrintStream.println(java.lang.Object))
     | | |           INVOKESTATIC Aspect.ajc_before_method_execution ()V
-    | | |           BIPUSH 2
+    | | |           ICONST_2
     | | |           ANEWARRAY java.lang.Object
     | | |           ASTORE 12
     | | |           ALOAD 12
-    | | |           BIPUSH 0
+    | | |           ICONST_0
     | | |           ALOAD 10
     | | |           AASTORE
     | | |           ALOAD 12
-    | | |           BIPUSH 1
+    | | |           ICONST_1
     | | |           ALOAD 9
     | | |           AASTORE
     | | |           NEW FancyHelloWorld$AjcClosure7
@@ -73,21 +73,21 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     |           L0: JSR L1
     |               GOTO L2
     |           L1: ASTORE_3
-    |               ALOAD_1     // java.io.PrintStream out   (line 15)
+    |               ALOAD_1     // Ljava/io/PrintStream; out   (line 15)
     |               LDC "finally"
     |               ASTORE 13
     |               ASTORE 14
     | method-call(void java.io.PrintStream.println(java.lang.String))
     | |             INVOKESTATIC Aspect.ajc_before_method_execution ()V
-    | |             BIPUSH 2
+    | |             ICONST_2
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE 16
     | |             ALOAD 16
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD 14
     | |             AASTORE
     | |             ALOAD 16
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ALOAD 13
     | |             AASTORE
     | |             NEW FancyHelloWorld$AjcClosure11
@@ -106,18 +106,18 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     method-execution(java.lang.String FancyHelloWorld.getName())
     |               ICONST_0   (line 20)
     |               ISTORE_0
-    |               ILOAD_0     // int x   (line 21)
+    |               ILOAD_0     // I x   (line 21)
     |               LDC "name"
     | method-call(int java.lang.String.hashCode())
     | |             INVOKEVIRTUAL java.lang.String.hashCode ()I
     | method-call(int java.lang.String.hashCode())
     |               IADD
-    |               ISTORE_0     // int x
+    |               ISTORE_0     // I x
     |               NEW java.lang.StringBuffer   (line 22)
     |               DUP
     |               LDC "name"
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ILOAD_0     // int x
+    |               ILOAD_0     // I x
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (I)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))
@@ -137,15 +137,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void println_aroundBody2(java.io.PrintStream, String):
                     INVOKESTATIC Aspect.ajc_before_method_execution ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure1
@@ -166,15 +166,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void println_aroundBody6(java.io.PrintStream, Object):
                     INVOKESTATIC Aspect.ajc_before_method_execution ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure5
@@ -195,15 +195,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void println_aroundBody10(java.io.PrintStream, String):
                     INVOKESTATIC Aspect.ajc_before_method_execution ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure9
@@ -229,11 +229,11 @@ public class FancyHelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody0 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -255,11 +255,11 @@ public class FancyHelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody2 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -281,11 +281,11 @@ public class FancyHelloWorld$AjcClosure5 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC FancyHelloWorld.println_aroundBody4 (Ljava/io/PrintStream;Ljava/lang/Object;)V
                     ACONST_NULL
@@ -306,11 +306,11 @@ public class FancyHelloWorld$AjcClosure7 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC FancyHelloWorld.println_aroundBody6 (Ljava/io/PrintStream;Ljava/lang/Object;)V
                     ACONST_NULL
@@ -331,11 +331,11 @@ public class FancyHelloWorld$AjcClosure9 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody8 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -357,11 +357,11 @@ public class FancyHelloWorld$AjcClosure11 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody10 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -1,6 +1,6 @@
 public class HelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // HelloWorld this   (line 5)
+                    ALOAD_0     // LHelloWorld; this   (line 5)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void HelloWorld.<init>())
     |               RETURN
@@ -15,15 +15,15 @@ public class HelloWorld extends java.lang.Object:
     |               ASTORE_2
     | method-call(void java.io.PrintStream.println(java.lang.String))
     | |             INVOKESTATIC Aspect.ajc_before_method_execution ()V
-    | |             BIPUSH 2
+    | |             ICONST_2
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE 4
     | |             ALOAD 4
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD_2
     | |             AASTORE
     | |             ALOAD 4
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ALOAD_1
     | |             AASTORE
     | |             NEW HelloWorld$AjcClosure3
@@ -46,15 +46,15 @@ public class HelloWorld extends java.lang.Object:
 
   static final void println_aroundBody2(java.io.PrintStream, String):
                     INVOKESTATIC Aspect.ajc_before_method_execution ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW HelloWorld$AjcClosure1
@@ -80,11 +80,11 @@ public class HelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC HelloWorld.println_aroundBody0 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -106,11 +106,11 @@ public class HelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC HelloWorld.println_aroundBody2 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -1,6 +1,6 @@
 public class DynamicHelloWorld extends java.lang.Object implements java.io.Serializable:
   public void <init>():
-                    ALOAD_0     // DynamicHelloWorld this   (line 8)
+                    ALOAD_0     // LDynamicHelloWorld; this   (line 8)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void DynamicHelloWorld.<init>())
     |               RETURN
@@ -27,7 +27,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               DUP
     |               LDC "expected and caught: "
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ALOAD_1     // java.lang.UnsupportedOperationException t
+    |               ALOAD_1     // Ljava/lang/UnsupportedOperationException; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -48,8 +48,8 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
 
   String doit(String, java.util.List):
     method-execution(java.lang.String DynamicHelloWorld.doit(java.lang.String, java.util.List))
-    |               ALOAD_2     // java.util.List l   (line 21)
-    |               ALOAD_1     // java.lang.String s
+    |               ALOAD_2     // Ljava/util/List; l   (line 21)
+    |               ALOAD_1     // Ljava/lang/String; s
     |               ASTORE_3
     |               ASTORE 4
     | method-call(boolean java.util.List.add(java.lang.Object))
@@ -58,19 +58,19 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     | |             IFEQ L0
     | |             ALOAD 4
     | |             CHECKCAST java.util.ArrayList
-    | |             BIPUSH 3
+    | |             ICONST_3
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE 5
     | |             ALOAD 5
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD_0
     | |             AASTORE
     | |             ALOAD 5
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ALOAD 4
     | |             AASTORE
     | |             ALOAD 5
-    | |             BIPUSH 2
+    | |             ICONST_2
     | |             ALOAD_3
     | |             AASTORE
     | |             NEW DynamicHelloWorld$AjcClosure1
@@ -86,7 +86,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     | |         L1: NOP
     | method-call(boolean java.util.List.add(java.lang.Object))
     |               POP
-    |               ALOAD_2     // java.util.List l   (line 22)
+    |               ALOAD_2     // Ljava/util/List; l   (line 22)
     | method-call(java.lang.String java.lang.Object.toString())
     | |             INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String;
     | method-call(java.lang.String java.lang.Object.toString())
@@ -115,15 +115,15 @@ public class DynamicHelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST DynamicHelloWorld
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.util.List
                     ALOAD_2
-                    BIPUSH 2
+                    ICONST_2
                     AALOAD
                     INVOKESTATIC DynamicHelloWorld.add_aroundBody0 (LDynamicHelloWorld;Ljava/util/List;Ljava/lang/Object;)Z
                     INVOKESTATIC org.aspectj.runtime.internal.Conversions.booleanObject (Z)Ljava/lang/Object;
@@ -1,6 +1,6 @@
 public abstract class FancyHelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // FancyHelloWorld this   (line 7)
+                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void FancyHelloWorld.<init>())
     |               RETURN
@@ -13,20 +13,20 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     |               ASTORE_1
     | finally -> E1
     | | catch java.lang.Exception -> E0
-    | | |           ALOAD_1     // java.io.PrintStream out   (line 11)
+    | | |           ALOAD_1     // Ljava/io/PrintStream; out   (line 11)
     | | |           LDC "bye"
     | | |           ASTORE 5
     | | |           ASTORE 6
     | | | method-call(void java.io.PrintStream.println(java.lang.String))
-    | | | |         BIPUSH 2
+    | | | |         ICONST_2
     | | | |         ANEWARRAY java.lang.Object
     | | | |         ASTORE 7
     | | | |         ALOAD 7
-    | | | |         BIPUSH 0
+    | | | |         ICONST_0
     | | | |         ALOAD 6
     | | | |         AASTORE
     | | | |         ALOAD 7
-    | | | |         BIPUSH 1
+    | | | |         ICONST_1
     | | | |         ALOAD 5
     | | | |         AASTORE
     | | | |         NEW FancyHelloWorld$AjcClosure1
@@ -39,20 +39,20 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     | | |           GOTO L0
     | | catch java.lang.Exception -> E0
     | |         E0: ASTORE_2   (line 12)
-    | |             ALOAD_1     // java.io.PrintStream out   (line 13)
-    | |             ALOAD_2     // java.lang.Exception e
+    | |             ALOAD_1     // Ljava/io/PrintStream; out   (line 13)
+    | |             ALOAD_2     // Ljava/lang/Exception; e
     | |             ASTORE 8
     | |             ASTORE 9
     | | method-call(void java.io.PrintStream.println(java.lang.Object))
-    | | |           BIPUSH 2
+    | | |           ICONST_2
     | | |           ANEWARRAY java.lang.Object
     | | |           ASTORE 10
     | | |           ALOAD 10
-    | | |           BIPUSH 0
+    | | |           ICONST_0
     | | |           ALOAD 9
     | | |           AASTORE
     | | |           ALOAD 10
-    | | |           BIPUSH 1
+    | | |           ICONST_1
     | | |           ALOAD 8
     | | |           AASTORE
     | | |           NEW FancyHelloWorld$AjcClosure3
@@ -71,20 +71,20 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     |           L0: JSR L1
     |               GOTO L2
     |           L1: ASTORE_3
-    |               ALOAD_1     // java.io.PrintStream out   (line 15)
+    |               ALOAD_1     // Ljava/io/PrintStream; out   (line 15)
     |               LDC "finally"
     |               ASTORE 11
     |               ASTORE 12
     | method-call(void java.io.PrintStream.println(java.lang.String))
-    | |             BIPUSH 2
+    | |             ICONST_2
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE 13
     | |             ALOAD 13
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD 12
     | |             AASTORE
     | |             ALOAD 13
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ALOAD 11
     | |             AASTORE
     | |             NEW FancyHelloWorld$AjcClosure5
@@ -103,18 +103,18 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     method-execution(java.lang.String FancyHelloWorld.getName())
     |               ICONST_0   (line 20)
     |               ISTORE_0
-    |               ILOAD_0     // int x   (line 21)
+    |               ILOAD_0     // I x   (line 21)
     |               LDC "name"
     | method-call(int java.lang.String.hashCode())
     | |             INVOKEVIRTUAL java.lang.String.hashCode ()I
     | method-call(int java.lang.String.hashCode())
     |               IADD
-    |               ISTORE_0     // int x
+    |               ISTORE_0     // I x
     |               NEW java.lang.StringBuffer   (line 22)
     |               DUP
     |               LDC "name"
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ILOAD_0     // int x
+    |               ILOAD_0     // I x
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (I)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))
@@ -160,11 +160,11 @@ public class FancyHelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody0 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -186,11 +186,11 @@ public class FancyHelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC FancyHelloWorld.println_aroundBody2 (Ljava/io/PrintStream;Ljava/lang/Object;)V
                     ACONST_NULL
@@ -211,11 +211,11 @@ public class FancyHelloWorld$AjcClosure5 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody4 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -1,6 +1,6 @@
 public class HelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // HelloWorld this   (line 5)
+                    ALOAD_0     // LHelloWorld; this   (line 5)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void HelloWorld.<init>())
     |               RETURN
@@ -14,15 +14,15 @@ public class HelloWorld extends java.lang.Object:
     |               ASTORE_1
     |               ASTORE_2
     | method-call(void java.io.PrintStream.println(java.lang.String))
-    | |             BIPUSH 2
+    | |             ICONST_2
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE_3
     | |             ALOAD_3
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD_2
     | |             AASTORE
     | |             ALOAD_3
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ALOAD_1
     | |             AASTORE
     | |             NEW HelloWorld$AjcClosure1
@@ -57,11 +57,11 @@ public class HelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC HelloWorld.println_aroundBody0 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -1,6 +1,6 @@
 public class DynamicHelloWorld extends java.lang.Object implements java.io.Serializable:
   public void <init>():
-                    ALOAD_0     // DynamicHelloWorld this   (line 8)
+                    ALOAD_0     // LDynamicHelloWorld; this   (line 8)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void DynamicHelloWorld.<init>())
     |               RETURN
@@ -13,7 +13,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               INVOKEVIRTUAL org.aspectj.runtime.internal.CFlowStack.isValid ()Z
     |               IFEQ L0
     |               GETSTATIC Aspect.ajc$cflowStack$0 Lorg/aspectj/runtime/internal/CFlowStack;
-    |               BIPUSH 0
+    |               ICONST_0
     |               INVOKEVIRTUAL org.aspectj.runtime.internal.CFlowStack.get (I)Ljava/lang/Object;
     |               CHECKCAST java.util.ArrayList
     |               INVOKESTATIC Aspect.ajc_before_0 (Ljava/util/ArrayList;)V
@@ -35,7 +35,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               DUP
     |               LDC "expected and caught: "
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ALOAD_1     // java.lang.UnsupportedOperationException t
+    |               ALOAD_1     // Ljava/lang/UnsupportedOperationException; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -56,23 +56,23 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
 
   String doit(String, java.util.List):
     method-execution(java.lang.String DynamicHelloWorld.doit(java.lang.String, java.util.List))
-    |               ALOAD_2     // java.util.List l   (line 21)
-    |               ALOAD_1     // java.lang.String s
+    |               ALOAD_2     // Ljava/util/List; l   (line 21)
+    |               ALOAD_1     // Ljava/lang/String; s
     |               ASTORE_3
     |               ASTORE 4
     | method-call(boolean java.util.List.add(java.lang.Object))
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ISTORE 5
     | |             ALOAD 4
     | |             INSTANCEOF java.util.ArrayList
     | |             IFEQ L0
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ISTORE 5
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE 6
     | |             ALOAD 6
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD 4
     | |             AASTORE
     | |             GETSTATIC Aspect.ajc$cflowStack$0 Lorg/aspectj/runtime/internal/CFlowStack;
@@ -99,7 +99,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     | |         L3: NOP
     | method-call(boolean java.util.List.add(java.lang.Object))
     |               POP
-    |               ALOAD_2     // java.util.List l   (line 22)
+    |               ALOAD_2     // Ljava/util/List; l   (line 22)
     | method-call(java.lang.String java.lang.Object.toString())
     | |             INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String;
     | method-call(java.lang.String java.lang.Object.toString())
@@ -1,6 +1,6 @@
 public class DynamicHelloWorld extends java.lang.Object implements java.io.Serializable:
   public void <init>():
-                    ALOAD_0     // DynamicHelloWorld this   (line 8)
+                    ALOAD_0     // LDynamicHelloWorld; this   (line 8)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void DynamicHelloWorld.<init>())
     |               RETURN
@@ -27,7 +27,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               DUP
     |               LDC "expected and caught: "
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ALOAD_1     // java.lang.UnsupportedOperationException t
+    |               ALOAD_1     // Ljava/lang/UnsupportedOperationException; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -48,14 +48,14 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
 
   String doit(String, java.util.List):
     method-execution(java.lang.String DynamicHelloWorld.doit(java.lang.String, java.util.List))
-    |               ALOAD_2     // java.util.List l   (line 21)
-    |               ALOAD_1     // java.lang.String s
+    |               ALOAD_2     // Ljava/util/List; l   (line 21)
+    |               ALOAD_1     // Ljava/lang/String; s
     | method-call(boolean java.util.List.add(java.lang.Object))
     | |             INVOKESTATIC Aspect.ajc_before_0 ()V
     | |             INVOKEINTERFACE java.util.List.add (Ljava/lang/Object;)Z
     | method-call(boolean java.util.List.add(java.lang.Object))
     |               POP
-    |               ALOAD_2     // java.util.List l   (line 22)
+    |               ALOAD_2     // Ljava/util/List; l   (line 22)
     | method-call(java.lang.String java.lang.Object.toString())
     | |             INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String;
     | method-call(java.lang.String java.lang.Object.toString())
@@ -1,6 +1,6 @@
 public class MultiArgHelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // MultiArgHelloWorld this   (line 3)
+                    ALOAD_0     // LMultiArgHelloWorld; this   (line 3)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void MultiArgHelloWorld.<init>())
     |               RETURN
@@ -34,7 +34,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     |               NEW java.lang.StringBuffer
     |               DUP
     |               INVOKESPECIAL java.lang.StringBuffer.<init> ()V
-    |               ALOAD_0     // java.lang.Object s
+    |               ALOAD_0     // Ljava/lang/Object; s
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -42,7 +42,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/String;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
-    |               ALOAD_1     // java.lang.Object t
+    |               ALOAD_1     // Ljava/lang/Object; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -47,7 +47,7 @@ public class HelloWorld extends java.lang.Object:
                     LDC ""
                     LDC ""
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
-                    BIPUSH 5
+                    ICONST_5
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeESJP (Ljava/lang/String;Lorg/aspectj/lang/Signature;I)Lorg/aspectj/lang/JoinPoint$EnclosingStaticPart;
                     PUTSTATIC HelloWorld.ajc$tjp_0 Lorg/aspectj/lang/JoinPoint$EnclosingStaticPart;
                     ALOAD_0
@@ -49,7 +49,7 @@ public class HelloWorld extends java.lang.Object:
                     LDC ""
                     LDC ""
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
-                    BIPUSH 5
+                    ICONST_5
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeSJP (Ljava/lang/String;Lorg/aspectj/lang/Signature;I)Lorg/aspectj/lang/JoinPoint$StaticPart;
                     PUTSTATIC HelloWorld.ajc$tjp_0 Lorg/aspectj/lang/JoinPoint$StaticPart;
                     ALOAD_0
@@ -1,6 +1,6 @@
 public class MultiArgHelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // MultiArgHelloWorld this   (line 3)
+                    ALOAD_0     // LMultiArgHelloWorld; this   (line 3)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void MultiArgHelloWorld.<init>())
     |               RETURN
@@ -35,7 +35,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     |               NEW java.lang.StringBuffer
     |               DUP
     |               INVOKESPECIAL java.lang.StringBuffer.<init> ()V
-    |               ALOAD_0     // java.lang.Object s
+    |               ALOAD_0     // Ljava/lang/Object; s
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -43,7 +43,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/String;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
-    |               ALOAD_1     // java.lang.Object t
+    |               ALOAD_1     // Ljava/lang/Object; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -1,6 +1,6 @@
 public class MultiArgHelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // MultiArgHelloWorld this   (line 3)
+                    ALOAD_0     // LMultiArgHelloWorld; this   (line 3)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void MultiArgHelloWorld.<init>())
     |               RETURN
@@ -32,7 +32,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     |               NEW java.lang.StringBuffer
     |               DUP
     |               INVOKESPECIAL java.lang.StringBuffer.<init> ()V
-    |               ALOAD_0     // java.lang.Object s
+    |               ALOAD_0     // Ljava/lang/Object; s
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -40,7 +40,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/String;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
-    |               ALOAD_1     // java.lang.Object t
+    |               ALOAD_1     // Ljava/lang/Object; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -1,6 +1,6 @@
 public class MultiArgHelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // MultiArgHelloWorld this   (line 3)
+                    ALOAD_0     // LMultiArgHelloWorld; this   (line 3)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void MultiArgHelloWorld.<init>())
     |               RETURN
@@ -32,7 +32,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     |               NEW java.lang.StringBuffer
     |               DUP
     |               INVOKESPECIAL java.lang.StringBuffer.<init> ()V
-    |               ALOAD_0     // java.lang.Object s
+    |               ALOAD_0     // Ljava/lang/Object; s
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -40,7 +40,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/String;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
-    |               ALOAD_1     // java.lang.Object t
+    |               ALOAD_1     // Ljava/lang/Object; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -12,15 +12,15 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE_1
     constructor-execution(void HelloWorld.<init>())
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE_3
     |               ALOAD_3
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_0
     |               AASTORE
     |               ALOAD_3
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD_1
     |               AASTORE
     |               NEW HelloWorld$AjcClosure3
@@ -44,15 +44,15 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE 10
     method-execution(void HelloWorld.main(java.lang.String[]))
-    |               BIPUSH 2   (line 8)
+    |               ICONST_2   (line 8)
     |               ANEWARRAY java.lang.Object
     |               ASTORE 12
     |               ALOAD 12
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 9
     |               AASTORE
     |               ALOAD 12
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD 10
     |               AASTORE
     |               NEW HelloWorld$AjcClosure15
@@ -83,7 +83,7 @@ public class HelloWorld extends java.lang.Object:
                     LDC ""
                     LDC ""
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
-                    BIPUSH 5
+                    ICONST_5
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeSJP (Ljava/lang/String;Lorg/aspectj/lang/Signature;I)Lorg/aspectj/lang/JoinPoint$StaticPart;
                     PUTSTATIC HelloWorld.ajc$tjp_0 Lorg/aspectj/lang/JoinPoint$StaticPart;
                     ALOAD_0
@@ -135,15 +135,15 @@ public class HelloWorld extends java.lang.Object:
   end static final void init$_aroundBody0(HelloWorld, org.aspectj.lang.JoinPoint)
 
   static final void init$_aroundBody2(HelloWorld, org.aspectj.lang.JoinPoint):
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW HelloWorld$AjcClosure1
@@ -162,11 +162,11 @@ public class HelloWorld extends java.lang.Object:
   end static final java.io.PrintStream out_aroundBody4(org.aspectj.lang.JoinPoint)
 
   static final java.io.PrintStream out_aroundBody6(org.aspectj.lang.JoinPoint):
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW HelloWorld$AjcClosure5
@@ -187,19 +187,19 @@ public class HelloWorld extends java.lang.Object:
   end static final void println_aroundBody8(java.io.PrintStream, String, org.aspectj.lang.JoinPoint)
 
   static final void println_aroundBody10(java.io.PrintStream, String, org.aspectj.lang.JoinPoint):
-                    BIPUSH 3
+                    ICONST_3
                     ANEWARRAY java.lang.Object
                     ASTORE_3
                     ALOAD_3
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_3
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     ALOAD_3
-                    BIPUSH 2
+                    ICONST_2
                     ALOAD_2
                     AASTORE
                     NEW HelloWorld$AjcClosure9
@@ -219,11 +219,11 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE_2
     field-get(java.io.PrintStream java.lang.System.out)
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 4
     |               ALOAD 4
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_2
     |               AASTORE
     |               NEW HelloWorld$AjcClosure7
@@ -244,19 +244,19 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE 10
     method-call(void java.io.PrintStream.println(java.lang.String))
-    |               BIPUSH 3
+    |               ICONST_3
     |               ANEWARRAY java.lang.Object
     |               ASTORE 12
     |               ALOAD 12
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 8
     |               AASTORE
     |               ALOAD 12
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD 6
     |               AASTORE
     |               ALOAD 12
-    |               BIPUSH 2
+    |               ICONST_2
     |               ALOAD 10
     |               AASTORE
     |               NEW HelloWorld$AjcClosure11
@@ -271,15 +271,15 @@ public class HelloWorld extends java.lang.Object:
   end static final void main_aroundBody12(String[], org.aspectj.lang.JoinPoint)
 
   static final void main_aroundBody14(String[], org.aspectj.lang.JoinPoint):
-                    BIPUSH 2   (line 8)
+                    ICONST_2   (line 8)
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW HelloWorld$AjcClosure13
@@ -306,11 +306,11 @@ public class HelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST HelloWorld
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.init$_aroundBody0 (LHelloWorld;Lorg/aspectj/lang/JoinPoint;)V
@@ -332,11 +332,11 @@ public class HelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST HelloWorld
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.init$_aroundBody2 (LHelloWorld;Lorg/aspectj/lang/JoinPoint;)V
@@ -358,7 +358,7 @@ public class HelloWorld$AjcClosure5 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.out_aroundBody4 (Lorg/aspectj/lang/JoinPoint;)Ljava/io/PrintStream;
@@ -379,7 +379,7 @@ public class HelloWorld$AjcClosure7 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.out_aroundBody6 (Lorg/aspectj/lang/JoinPoint;)Ljava/io/PrintStream;
@@ -400,15 +400,15 @@ public class HelloWorld$AjcClosure9 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     ALOAD_2
-                    BIPUSH 2
+                    ICONST_2
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.println_aroundBody8 (Ljava/io/PrintStream;Ljava/lang/String;Lorg/aspectj/lang/JoinPoint;)V
@@ -430,15 +430,15 @@ public class HelloWorld$AjcClosure11 extends org.aspectj.runtime.internal.Around
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     ALOAD_2
-                    BIPUSH 2
+                    ICONST_2
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.println_aroundBody10 (Ljava/io/PrintStream;Ljava/lang/String;Lorg/aspectj/lang/JoinPoint;)V
@@ -460,11 +460,11 @@ public class HelloWorld$AjcClosure13 extends org.aspectj.runtime.internal.Around
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.main_aroundBody12 ([Ljava/lang/String;Lorg/aspectj/lang/JoinPoint;)V
@@ -486,11 +486,11 @@ public class HelloWorld$AjcClosure15 extends org.aspectj.runtime.internal.Around
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.main_aroundBody14 ([Ljava/lang/String;Lorg/aspectj/lang/JoinPoint;)V
@@ -12,15 +12,15 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE_1
     constructor-execution(void HelloWorld.<init>())
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE_2
     |               ALOAD_2
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_0
     |               AASTORE
     |               ALOAD_2
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD_1
     |               AASTORE
     |               NEW HelloWorld$AjcClosure1
@@ -44,15 +44,15 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE 8
     method-execution(void HelloWorld.main(java.lang.String[]))
-    |               BIPUSH 2   (line 8)
+    |               ICONST_2   (line 8)
     |               ANEWARRAY java.lang.Object
     |               ASTORE 9
     |               ALOAD 9
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 7
     |               AASTORE
     |               ALOAD 9
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD 8
     |               AASTORE
     |               NEW HelloWorld$AjcClosure7
@@ -83,7 +83,7 @@ public class HelloWorld extends java.lang.Object:
                     LDC ""
                     LDC ""
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
-                    BIPUSH 5
+                    ICONST_5
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeSJP (Ljava/lang/String;Lorg/aspectj/lang/Signature;I)Lorg/aspectj/lang/JoinPoint$StaticPart;
                     PUTSTATIC HelloWorld.ajc$tjp_0 Lorg/aspectj/lang/JoinPoint$StaticPart;
                     ALOAD_0
@@ -153,11 +153,11 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE_2
     field-get(java.io.PrintStream java.lang.System.out)
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 4
     |               ALOAD 4
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_2
     |               AASTORE
     |               NEW HelloWorld$AjcClosure3
@@ -178,19 +178,19 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE 10
     method-call(void java.io.PrintStream.println(java.lang.String))
-    |               BIPUSH 3
+    |               ICONST_3
     |               ANEWARRAY java.lang.Object
     |               ASTORE 12
     |               ALOAD 12
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 8
     |               AASTORE
     |               ALOAD 12
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD 6
     |               AASTORE
     |               ALOAD 12
-    |               BIPUSH 2
+    |               ICONST_2
     |               ALOAD 10
     |               AASTORE
     |               NEW HelloWorld$AjcClosure5
@@ -218,11 +218,11 @@ public class HelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST HelloWorld
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.init$_aroundBody0 (LHelloWorld;Lorg/aspectj/lang/JoinPoint;)V
@@ -244,7 +244,7 @@ public class HelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.out_aroundBody2 (Lorg/aspectj/lang/JoinPoint;)Ljava/io/PrintStream;
@@ -265,15 +265,15 @@ public class HelloWorld$AjcClosure5 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     ALOAD_2
-                    BIPUSH 2
+                    ICONST_2
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.println_aroundBody4 (Ljava/io/PrintStream;Ljava/lang/String;Lorg/aspectj/lang/JoinPoint;)V
@@ -295,11 +295,11 @@ public class HelloWorld$AjcClosure7 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.main_aroundBody6 ([Ljava/lang/String;Lorg/aspectj/lang/JoinPoint;)V
@@ -77,7 +77,7 @@ public class HelloWorld extends java.lang.Object:
                     LDC ""
                     LDC ""
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
-                    BIPUSH 5
+                    ICONST_5
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeSJP (Ljava/lang/String;Lorg/aspectj/lang/Signature;I)Lorg/aspectj/lang/JoinPoint$StaticPart;
                     PUTSTATIC HelloWorld.ajc$tjp_0 Lorg/aspectj/lang/JoinPoint$StaticPart;
                     ALOAD_0
@@ -46,19 +46,19 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               ALOAD_0
     |               INVOKEVIRTUAL Trace.ajc$before$Trace$1$26352be2 (Ljava/lang/Object;)V
     |               INVOKESTATIC MyTrace.aspectOf ()LMyTrace;
-    |               BIPUSH 3
+    |               ICONST_3
     |               ANEWARRAY java.lang.Object
     |               ASTORE 6
     |               ALOAD 6
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_0
     |               AASTORE
     |               ALOAD 6
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD_3
     |               AASTORE
     |               ALOAD 6
-    |               BIPUSH 2
+    |               ICONST_2
     |               ALOAD 4
     |               AASTORE
     |               NEW DynamicHelloWorld$AjcClosure3
@@ -93,19 +93,19 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
   static final String doit_aroundBody2(DynamicHelloWorld, String, java.util.List):
                     INVOKESTATIC MyTrace.aspectOf ()LMyTrace;   (line 21)
                     ALOAD_0
-                    BIPUSH 3
+                    ICONST_3
                     ANEWARRAY java.lang.Object
                     ASTORE_3
                     ALOAD_3
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_3
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     ALOAD_3
-                    BIPUSH 2
+                    ICONST_2
                     ALOAD_2
                     AASTORE
                     NEW DynamicHelloWorld$AjcClosure1
@@ -131,15 +131,15 @@ public class DynamicHelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST DynamicHelloWorld
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     ALOAD_2
-                    BIPUSH 2
+                    ICONST_2
                     AALOAD
                     CHECKCAST java.util.List
                     INVOKESTATIC DynamicHelloWorld.doit_aroundBody0 (LDynamicHelloWorld;Ljava/lang/String;Ljava/util/List;)Ljava/lang/String;
@@ -160,15 +160,15 @@ public class DynamicHelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST DynamicHelloWorld
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     ALOAD_2
-                    BIPUSH 2
+                    ICONST_2
                     AALOAD
                     CHECKCAST java.util.List
                     INVOKESTATIC DynamicHelloWorld.doit_aroundBody2 (LDynamicHelloWorld;Ljava/lang/String;Ljava/util/List;)Ljava/lang/String;
@@ -1181,11 +1181,11 @@ public final class LazyMethodGen implements Traceable {
 	       	if (slots == null) {
 	       		slots = new HashSet();
 	       		duplicatedLocalMap.put(start, slots);	
-	       	} else if (slots.contains(new Integer(tag.getSlot()))) {
+	       	} else if (slots.contains(Integer.valueOf(tag.getSlot()))) {
 	       		// we already have a var starting at this tag with this slot
 	       		continue;
 	       	}
-	       	slots.add(new Integer(tag.getSlot()));
+	       	slots.add(Integer.valueOf(tag.getSlot()));
 	       	Type t = tag.getRealType();
 	       	if (t==null) {
 	       		t = BcelWorld.makeBcelType(UnresolvedType.forSignature(tag.getType()));
@@ -62,10 +62,6 @@ import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
 
 public class Utility {
-
-    private Utility() {
-        super();
-    }
 
 	/*
 	 * Ensure we report a nice source location - particular in the case
@@ -507,26 +503,26 @@ public class Utility {
         return il;
     }
 
-	public static Instruction createConstant(
-    		InstructionFactory fact,
-    		int i) {
+	public static Instruction createConstant(InstructionFactory fact,int value) {
 		Instruction inst;
-		switch(i) {
+		switch (value) {
 			case -1: inst =  InstructionConstants.ICONST_M1; break;
 			case 0: inst =  InstructionConstants.ICONST_0;	break;			
 			case 1: inst =  InstructionConstants.ICONST_1; break;
 			case 2: inst =  InstructionConstants.ICONST_2; break;				
 			case 3: inst =  InstructionConstants.ICONST_3; break;
 			case 4: inst =  InstructionConstants.ICONST_4;	break;			
-			case 5: inst =  InstructionConstants.ICONST_5;	break;	
-		}
-		if (i <= Byte.MAX_VALUE && i >= Byte.MIN_VALUE) {
-	     	inst =  new InstructionByte(Constants.BIPUSH,(byte)i);
-		} else if (i <= Short.MAX_VALUE && i >= Short.MIN_VALUE) {
-			inst =  new InstructionShort(Constants.SIPUSH,(short)i);
-		} else {
-		      int ii = fact.getClassGen().getConstantPool().addInteger(i);
-		      inst = new InstructionCP(i<=Constants.MAX_BYTE?Constants.LDC:Constants.LDC_W,ii);
+			case 5: inst =  InstructionConstants.ICONST_5;	break;
+			default: 
+				if (value <= Byte.MAX_VALUE && value >= Byte.MIN_VALUE) {
+			     	inst =  new InstructionByte(Constants.BIPUSH,(byte)value);
+				} else if (value <= Short.MAX_VALUE && value >= Short.MIN_VALUE) {
+					inst =  new InstructionShort(Constants.SIPUSH,(short)value);
+				} else {
+				      int ii = fact.getClassGen().getConstantPool().addInteger(value);
+				      inst = new InstructionCP(value<=Constants.MAX_BYTE?Constants.LDC:Constants.LDC_W,ii);
+				}
+				break;
 		}
 		return inst;
 	}
@@ -748,7 +744,7 @@ public class Utility {
             // 1. there are no values specified (i.e. @SuppressAjWarnings)
             // 2. there are values specified (i.e. @SuppressAjWarnings("A") or @SuppressAjWarnings({"A","B"})
             List vals = anns[i].getBcelAnnotation().getValues();
-            if (vals == null || vals.size()==0) { // (1)
+            if (vals == null || vals.isEmpty()) { // (1)
                 suppressed = true;
             } else { // (2)
             	// We know the value is an array value
@@ -780,7 +776,7 @@ public class Utility {
             // 1. there are no values specified (i.e. @SuppressAjWarnings)
             // 2. there are values specified (i.e. @SuppressAjWarnings("A") or @SuppressAjWarnings({"A","B"})
             List vals = anns[i].getBcelAnnotation().getValues();
-            if (vals == null || vals.size()==0) { // (1)
+            if (vals == null || vals.isEmpty()) { // (1)
                suppressedWarnings.addAll(lint.allKinds());
             } else { // (2)
             	// We know the value is an array value
@@ -16,7 +16,7 @@ import org.aspectj.util.TypeSafeEnum;
  * An enumeration of the different kinds of pointcut primitives
  * supported by AspectJ.
  */
-public class PointcutPrimitive extends TypeSafeEnum {
+public final class PointcutPrimitive extends TypeSafeEnum {
 
 	public static final PointcutPrimitive CALL = new PointcutPrimitive("call",1);
 	public static final PointcutPrimitive EXECUTION = new PointcutPrimitive("execution",2);
@@ -49,7 +49,6 @@ import org.aspectj.org.eclipse.jdt.internal.core.builder.ReferenceCollection;
 import org.aspectj.org.eclipse.jdt.internal.core.builder.StringSet;
 import org.aspectj.util.FileUtil;
 import org.aspectj.weaver.BCException;
-import org.aspectj.weaver.IWeaver;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.bcel.BcelWeaver;
 import org.aspectj.weaver.bcel.BcelWorld;
@@ -1065,7 +1064,7 @@ public class AjState {
 				for (Iterator iterator = compiledTypes.keySet().iterator(); iterator.hasNext();) {
 					char[] className = (char[])iterator.next();
 					String typeName = new String(className).replace('/','.');
-					if (typeName.indexOf(IWeaver.SYNTHETIC_CLASS_POSTFIX) == -1) {
+					if (typeName.indexOf(BcelWeaver.SYNTHETIC_CLASS_POSTFIX) == -1) {
 						ResolvedType rt = world.resolve(typeName);
 						if (rt.isMissing()) {
 							throw new IllegalStateException("Type '" + rt.getSignature() + "' not found in world!");
@@ -1555,7 +1554,7 @@ public class AjState {
 		public void deleteFromFileSystem() {
 			String namePrefix = locationOnDisk.getName();
 			namePrefix = namePrefix.substring(0,namePrefix.lastIndexOf('.'));
-			final String targetPrefix = namePrefix + IWeaver.CLOSURE_CLASS_PREFIX;
+			final String targetPrefix = namePrefix + BcelWeaver.CLOSURE_CLASS_PREFIX;
 			File dir = locationOnDisk.getParentFile();
 			if (dir != null) {
 				File[] weaverGenerated = dir.listFiles(new FilenameFilter() {
@@ -1,28 +0,0 @@
-/* *******************************************************************
- * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
- * All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://www.eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: 
- *     PARC     initial implementation 
- * ******************************************************************/
-
-
-package org.aspectj.weaver;
-
-/**
- * A weaver is given all the aspects it will weave.  It should create an appropriate kind of 
- * IWorld.  It then should be given a bunch of classes (types with implementation), creates an
- * appropriate IClassWeaver for each such class, and weaves.  The IWeaver is responsible for 
- * IO.
- */
-public interface IWeaver {
-
-	public static final String CLOSURE_CLASS_PREFIX = "$Ajc";
-	
-	public static final String SYNTHETIC_CLASS_POSTFIX = "$ajc";
-	
-}
@@ -67,7 +67,6 @@ import org.aspectj.weaver.CrosscuttingMembersSet;
 import org.aspectj.weaver.CustomMungerFactory;
 import org.aspectj.weaver.IClassFileProvider;
 import org.aspectj.weaver.IWeaveRequestor;
-import org.aspectj.weaver.IWeaver;
 import org.aspectj.weaver.NewParentTypeMunger;
 import org.aspectj.weaver.ReferenceType;
 import org.aspectj.weaver.ReferenceTypeDelegate;
@@ -98,7 +97,12 @@ import org.aspectj.weaver.tools.Trace;
 import org.aspectj.weaver.tools.TraceFactory;
 
 
-public class BcelWeaver implements IWeaver {
+public class BcelWeaver {
+
+	public static final String CLOSURE_CLASS_PREFIX = "$Ajc";
+	
+	public static final String SYNTHETIC_CLASS_POSTFIX = "$ajc";
+	
     private BcelWorld world;
     private CrosscuttingMembersSet xcutSet;
     private IProgressListener progressListener = null;
@@ -45,7 +45,7 @@ import org.aspectj.weaver.ast.Var;
 import org.aspectj.weaver.internal.tools.MatchingContextBasedTest;
 
 // we generate right to left, btw.
-public class BcelRenderer implements ITestVisitor, IExprVisitor {
+public final class BcelRenderer implements ITestVisitor, IExprVisitor {
 
     private InstructionList instructions;
     private InstructionFactory fact;
@@ -868,7 +868,7 @@ class BcelClassWeaver implements IClassWeaver {
 			for (int i = 0; i < paramTypes.length; i++) {
 				UnresolvedType type = paramTypes[i];
 				String s = org.aspectj.apache.bcel.classfile.Utility.signatureToString(type.getSignature());
-				if (s.lastIndexOf(".")!=-1) s =s.substring(s.lastIndexOf(".")+1);
+				if (s.lastIndexOf('.')!=-1) s =s.substring(s.lastIndexOf('.')+1);
 				parmString.append(s);
 				if ((i+1)<paramTypes.length) parmString.append(",");
 			}
@@ -970,7 +970,7 @@ class BcelClassWeaver implements IClassWeaver {
 			}
 			return null;
 		} else {
-			throw new RuntimeException("Not sure what this is: "+methodCtorMunger);
+			throw new BCException("Not sure what this is: "+methodCtorMunger);
 		}
 	}
 
@@ -1519,7 +1519,7 @@ class BcelClassWeaver implements IClassWeaver {
 					}
 					walker = walker.getNext();
 				}
-				if (rets.size()>0) {
+				if (!rets.isEmpty()) {
 					// need to ensure targeters for 'return' now instead target the load instruction
 					// (so we never jump over the monitorexit logic)
 
@@ -1550,7 +1550,7 @@ class BcelClassWeaver implements IClassWeaver {
 									// move it
 									targeter.updateTarget(element, monitorExitBlockStart);
 								} else {
-									throw new RuntimeException("Unexpected targeter encountered during transform: "+targeter);
+									throw new BCException("Unexpected targeter encountered during transform: "+targeter);
 								}
 							}		
 						}
@@ -1730,7 +1730,7 @@ class BcelClassWeaver implements IClassWeaver {
 								// move it
 								targeter.updateTarget(element, monitorExitBlockStart);
 							} else {
-								throw new RuntimeException("Unexpected targeter encountered during transform: "+targeter);
+								throw new BCException("Unexpected targeter encountered during transform: "+targeter);
 							}
 						}		
 					}
@@ -1806,7 +1806,7 @@ class BcelClassWeaver implements IClassWeaver {
 				}
 				walker = walker.getNext();
 			}
-			if (rets.size()>0) {
+			if (!rets.isEmpty()) {
 				// need to ensure targeters for 'return' now instead target the load instruction
 				// (so we never jump over the monitorexit logic)
 
@@ -1838,7 +1838,7 @@ class BcelClassWeaver implements IClassWeaver {
 								// move it
 								targeter.updateTarget(element, monitorExitBlockStart);
 							} else {
-								throw new RuntimeException("Unexpected targeter encountered during transform: "+targeter);
+								throw new BCException("Unexpected targeter encountered during transform: "+targeter);
 							}
 						}		
 					}
@@ -129,7 +129,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
     // This set contains pairs of types whose signatures are concatenated
     // together, this means with a fast lookup we can tell if two types
     // are equivalent.
-    static Set validBoxing = new HashSet();
+    protected static Set validBoxing = new HashSet();
 
     static {
       validBoxing.add("Ljava/lang/Byte;B");
@@ -2185,7 +2185,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 
 	protected Map getAjMemberParameterizationMap() {
 		Map myMap = getMemberParameterizationMap();
-		if (myMap.size() == 0) {
+		if (myMap.isEmpty()) {
 			// might extend a parameterized aspect that we also need to consider...
 			if (getSuperclass() != null) return getSuperclass().getAjMemberParameterizationMap();
 		}
@@ -14,7 +14,7 @@
 package org.aspectj.weaver.ast;
 
 
-public class Literal extends Test {
+public final class Literal extends Test {
 
 	boolean noTest;
 	boolean val;
@@ -1,21 +0,0 @@
-/* *******************************************************************
- * Copyright (c) 2008 Contributors
- * All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://www.eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: 
- *     Andy Clement     initial implementation 
- * ******************************************************************/
-package org.aspectj.weaver;
-
-/**
- * Marker interface for entities that are not resolved.
- * 
- * @author Andy Clement
- */
-public interface Unresolved {
-
-}
@@ -94,7 +94,7 @@ import org.aspectj.weaver.tools.Traceable;
  * The wildcard ? extends Foo has signature +LFoo;
  * The wildcard ? super Foo has signature -LFoo;
  */
-public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclaringElement {
+public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 
 	// common types referred to by the weaver
     public static final UnresolvedType[] NONE         = new UnresolvedType[0];
@@ -18,7 +18,7 @@ package org.aspectj.weaver;
  * 
  * @author Andy Clement
  */
-public class WildcardedUnresolvedType extends UnresolvedType implements Unresolved {
+public class WildcardedUnresolvedType extends UnresolvedType {
 
     // TODO does not cope with extra bounds '? extends A & B & C'
 
@@ -15,7 +15,7 @@ package org.aspectj.weaver.tools;
 /** 
  * This class implements a boolean that includes a "maybe"
  */
-public class FuzzyBoolean {
+public final class FuzzyBoolean {
 
 	// Note :- this implementation is not safe under serialization / deserialization
 	private String name;
@@ -19,7 +19,7 @@ import org.aspectj.weaver.ast.Var;
 /**
  * A variable at a reflection shadow, used by the residual tests.
  */
-public class ReflectionVar extends Var {
+public final class ReflectionVar extends Var {
 
 	static final int THIS_VAR = 0;
 	static final int TARGET_VAR = 1;
@@ -14,7 +14,7 @@
 package org.aspectj.weaver.patterns;
 
 
-public class BasicToken implements IToken {
+public final class BasicToken implements IToken {
 	private String value;
 	private boolean isIdentifier;
 	private String literalKind;
@@ -1,95 +0,0 @@
-/* *******************************************************************
- * Copyright (c) 2006 Contributors
- * All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://www.eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: 
- *     Andy Clement IBM     initial implementation 
- * ******************************************************************/
-package org.aspectj.weaver;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * Can store annotations for any member and ensures they are resolved/unpacked as lazily as possible.
- * The set of annotations is unpacked *once* then discarded, so ensure all annotations have been
- * added via 'addAnnotation()' before calling the public accessor
- * methods 'hasAnnotation/getAnnotations/getAnnotationTypes'
- * 
- * @author AndyClement
- */
-public class AnnotationsForMemberHolder {
-
-	private boolean annotationTypesCorrect = false; // guard for lazy initialization of annotationTypes
-	private ResolvedType[] annotationTypes;
-	private boolean annotationXsCorrect = false;
-	private AnnotationX[] annotationXs;
-	public List /*AnnotationAJ*/ annotations   = null;
-	private World world;
-	
-	public AnnotationsForMemberHolder(World w) {
-		this.world = w;
-	}
-	
-	public AnnotationX[] getAnnotations() {
-		ensureAnnotationXsUnpacked();
-		return annotationXs;
-	}
-
-	public ResolvedType[] getAnnotationTypes() {
-		ensureAnnotationsUnpacked();
-		return annotationTypes;
-	}
-	
-	public boolean hasAnnotation(UnresolvedType ofType) {
-		ensureAnnotationsUnpacked();
-		for (int i = 0; i < annotationTypes.length; i++) {
-			if (annotationTypes[i].equals(ofType)) return true;
-		}
-		return false;
-	}
-	
-	private void ensureAnnotationXsUnpacked() {
-		if (annotationTypesCorrect && annotationXsCorrect) return;
-		ensureAnnotationsUnpacked();
-		if (annotations==null) {
-			annotationXs = AnnotationX.NONE;
-		} else {
-			annotationXs = new AnnotationX[annotations.size()];
-			int pos = 0;
-			for (Iterator iter = annotations.iterator(); iter.hasNext();) {
-				AnnotationAJ element = (AnnotationAJ) iter.next();
-				annotationXs[pos++] = new AnnotationX(element,world);
-			}
-			annotations=null; // finished with
-		}
-		annotationXsCorrect = true;
-	}
-	
-	
-  private void ensureAnnotationsUnpacked() {
-	if (annotationTypesCorrect) return;
-	if (annotations==null) {
-		annotationTypes = ResolvedType.NONE;
-	} else {
-		annotationTypes = new ResolvedType[annotations.size()];
-		int pos = 0;
-		for (Iterator iter = annotations.iterator(); iter.hasNext();) {
-			AnnotationAJ element = (AnnotationAJ) iter.next();
-			annotationTypes[pos++] = world.resolve(UnresolvedType.forSignature(element.getTypeSignature()));
-		}
-	}
-	annotationTypesCorrect = true;
-  }
-
-	public void addAnnotation(AnnotationAJ oneAnnotation) {
-		if (annotations==null) annotations = new ArrayList();
-		annotations.add(oneAnnotation);
-	}
-
-}
@@ -18,9 +18,7 @@ import java.lang.reflect.Modifier;
 import org.aspectj.weaver.bcel.LazyClassGen;
 
 public class NameMangler {
-	private NameMangler() {
-		throw new RuntimeException("static");
-	}
+	
 	public static final char[] AJC_DOLLAR_PREFIX = {'a', 'j', 'c','$'};
 	public static final char[] CLINIT={'<','c','l','i','n','i','t','>'};
 	public static final String PREFIX = "ajc$";
@@ -28,9 +28,9 @@ import org.aspectj.weaver.patterns.PerClause;
  */
 public class BoundedReferenceType extends ReferenceType {
 
-    private UnresolvedType lowerBound;
+    private ResolvedType lowerBound;
 
-    private UnresolvedType upperBound;
+    private ResolvedType upperBound;
 
     protected ReferenceType[] additionalInterfaceBounds = new ReferenceType[0];
 
@@ -2147,7 +2147,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 						boolean b = false;
 						UnresolvedType upperBound = boundedRT.getUpperBound();
 						if (upperBound.isParameterizedType()) {
-							b = upperBound.isParameterizedWithAMemberTypeVariable();
+							b = ((ResolvedType)upperBound).isParameterizedWithAMemberTypeVariable();
 						} else if (upperBound.isTypeVariableReference() && ((TypeVariableReference)upperBound).getTypeVariable().getDeclaringElementKind()==TypeVariable.METHOD) {
 							b = true;
 						}
@@ -2161,7 +2161,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 						boolean b = false;
 						UnresolvedType lowerBound = boundedRT.getLowerBound();
 						if (lowerBound.isParameterizedType()) {
-							b = lowerBound.isParameterizedWithAMemberTypeVariable();
+							b = ((ResolvedType)lowerBound).isParameterizedWithAMemberTypeVariable();
 						} else if (lowerBound.isTypeVariableReference() && ((TypeVariableReference)lowerBound).getTypeVariable().getDeclaringElementKind()==TypeVariable.METHOD) {
 							b = true;
 						}
@@ -147,25 +147,10 @@ public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclar
 	 * Iff isParameterized(), then these are the type variables bound as parameters
 	 * in the type 
 	 */
+	// OPTIMIZE should be no state in here that will damage whether equals() is correct...
 	protected TypeVariable[] typeVariables;
 
 
-   /**
-     * Determines if this represents a primitive type.  A primitive type
-     * is one of nine predefined resolved types.
-     *
-     * @return true iff this type represents a primitive type
-     *
-     * @see     ResolvedType#Boolean
-     * @see     ResolvedType#Character
-     * @see     ResolvedType#Byte
-     * @see     ResolvedType#Short
-     * @see     ResolvedType#Integer
-     * @see     ResolvedType#Long
-     * @see     ResolvedType#Float
-     * @see     ResolvedType#Double
-     * @see     ResolvedType#Void
-     */   
     public boolean isPrimitiveType()          { return typeKind == TypeKind.PRIMITIVE; }
     public boolean isSimpleType()             { return typeKind == TypeKind.SIMPLE; }
     public boolean isRawType()                { return typeKind == TypeKind.RAW; }
@@ -197,18 +182,8 @@ public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclar
         return signature.hashCode();
     }
 
-    /**
-     * Return a version of this parameterized type in which any type parameters
-     * that are type variable references are replaced by their matching type variable
-     * binding.
-     */
-    // OPTIMIZE methods like this just allow callers to be lazy and not ensure they are working with the right (resolved) subtype
-    public UnresolvedType parameterize(Map typeBindings) {
-    	throw new UnsupportedOperationException("unable to parameterize unresolved type: " + signature);
-    }
 
     protected UnresolvedType(String signature) {
-        super();
         this.signature = signature;
         this.signatureErasure = signature;
     }
@@ -506,10 +481,6 @@ public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclar
     }
 
 
-//	public String getParameterizedSignature() {
-//		return signature;
-//	}
-	
 	/**
 	 * For parameterized types, return the signature for the raw type
 	 */
@@ -822,16 +793,6 @@ public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclar
 		private final String type;
 	}
 
-	/**
-	 * Will return true if the type being represented is parameterized with a type variable
-	 * from a generic method/ctor rather than a type variable from a generic type.  
-	 * Only subclasses know the answer...
-	 */
-	// OPTIMIZE don't allow this to be called, the caller must have a resolved entity
-	public boolean isParameterizedWithAMemberTypeVariable() {
-		throw new RuntimeException("I dont know - you should ask a resolved version of me: "+this);
-	}
-	
 	public TypeVariable getTypeVariableNamed(String name) {
 		TypeVariable[] vars = getTypeVariables();
 		if (vars==null || vars.length==0) return null;
@@ -846,5 +807,14 @@ public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclar
 		return getClass().getName() + "[" + getName() + "]";
 	}
 
+    /**
+     * Return a version of this parameterized type in which any type parameters
+     * that are type variable references are replaced by their matching type variable
+     * binding.
+     */
+    // OPTIMIZE methods like this just allow callers to be lazy and not ensure they are working with the right (resolved) subtype
+    public UnresolvedType parameterize(Map typeBindings) {
+    	throw new UnsupportedOperationException("unable to parameterize unresolved type: " + signature);
+    }
 }
 
@@ -15,6 +15,7 @@
 
 package org.aspectj.ajdt.internal.compiler.lookup;
 
+import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -977,7 +978,7 @@ public class EclipseFactory {
 	}
 
 	public MethodBinding makeMethodBindingForCall(Member member) {
-		return new MethodBinding(member.getCallsiteModifiers(),
+		return new MethodBinding(member.getModifiers() & ~ Modifier.INTERFACE,
 				member.getName().toCharArray(),
 				makeTypeBinding(member.getReturnType()),
 				makeTypeBindings(member.getParameterTypes()),
@@ -308,10 +308,6 @@ public class JoinPointSignature implements ResolvedMember {
 		return realMember.canBeParameterized();
 	}
 
-	public int getCallsiteModifiers() {
-		return realMember.getCallsiteModifiers();
-	}
-
 	public String getExtractableName() {
 		return realMember.getExtractableName();
 	}
@@ -16,6 +16,9 @@ package org.aspectj.weaver;
 import java.util.Collection;
 import java.util.Iterator;
 
+/**
+ * Abstract representation of a member within a type.
+ */
 public interface Member extends Comparable {
 
 	public static final Member[] NONE = new Member[0];
@@ -53,16 +56,12 @@ public interface Member extends Comparable {
 
 	public UnresolvedType[] getParameterTypes();
 
-	
 	/**
-	 * Return full signature, including return type, e.g. "()LFastCar;" for a signature without the return type,
-	 * use getParameterSignature() - it is importnant to choose the right one in the face of covariance.
+	 * Return full signature, including return type, e.g. "()LFastCar;". For a signature without the return type,
+	 * use getParameterSignature() - it is important to choose the right one in the face of covariance.
 	 */
 	public String getSignature();
 
-    /**
-     * All the signatures that a join point with this member as its signature has.
-     */
     public Iterator getJoinPointSignatures(World world);
 
 	public int getArity();
@@ -79,7 +78,6 @@ public interface Member extends Comparable {
 
 	public int getModifiers();
 
-
     public boolean isStatic();
 
     public boolean isInterface();
@@ -88,12 +86,9 @@ public interface Member extends Comparable {
 
 	/**
 	 * Returns true iff the member is generic (NOT parameterized)
-	 * For example, a method declared in a generic type
 	 */
 	public boolean canBeParameterized();
 
-	public int getCallsiteModifiers();
-
 	public String getExtractableName();
 
     public AnnotationX[] getAnnotations();
@@ -102,7 +97,6 @@ public interface Member extends Comparable {
 	public String getSignatureMakerName();
 
 	public String getSignatureType();
-
 
     public Collection/* ResolvedType */getDeclaringTypes(World world);
 
@@ -10,7 +10,6 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.weaver;
 
 import java.lang.reflect.Modifier;
@@ -20,14 +19,14 @@ import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 
-
 public class MemberImpl implements Member {
 
     protected MemberKind kind;
-    protected String name;
-    protected UnresolvedType declaringType;
+
     protected int modifiers; 
+    protected String name;
     protected UnresolvedType returnType;
+    protected UnresolvedType declaringType;
     protected UnresolvedType[] parameterTypes;
     private final String signature;
     private String paramSignature;
@@ -111,6 +110,7 @@ public class MemberImpl implements Member {
      * @param      signature the JVM bytecode method signature string we want to break apart
      * @return     a pair of UnresolvedType, UnresolvedType[] representing the return types and parameter types. 
      */
+    // OPTIMIZE move static util methods out into a memberutils class
     public static String typesToSignature(UnresolvedType returnType, UnresolvedType[] paramTypes, boolean useRawTypes) {
         StringBuffer buf = new StringBuffer();
         buf.append("(");
@@ -365,27 +365,14 @@ public class MemberImpl implements Member {
 
     public UnresolvedType getGenericReturnType() { return getReturnType(); }
     public UnresolvedType[] getGenericParameterTypes() { return getParameterTypes(); }
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getType()
-	 */
-    public UnresolvedType getType() { return returnType; }
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getName()
-	 */
+    public final UnresolvedType getType() { return returnType; }
     public String getName() { return name; }
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getParameterTypes()
-	 */
     public UnresolvedType[]  getParameterTypes() { return parameterTypes; }
-    
-    
+        
     public String getSignature() { return signature; }
 
     public int getArity() { return parameterTypes.length; }
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getParameterSignature()
-	 */
     public String getParameterSignature() {
     	if (paramSignature != null) return paramSignature;
     	StringBuffer sb = new StringBuffer();
@@ -460,17 +447,10 @@ public class MemberImpl implements Member {
     	return false;
     }
 
-	public final int getCallsiteModifiers() {
-		return modifiers & ~ Modifier.INTERFACE;
-	}
-	
 	public int getModifiers() {
 		return modifiers;
 	}
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getExtractableName()
-	 */
     public final String getExtractableName() {
     // OPTIMIZE remove silly string compares for init - use kind==CTOR/STATIC_INITIALIZATION
     	if (name.equals("<init>")) return "init$";
@@ -478,21 +458,12 @@ public class MemberImpl implements Member {
     	else return name;
     }
 
-    
-	/* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getAnnotations()
-	 */
 	public AnnotationX[] getAnnotations() {
 		throw new UnsupportedOperationException("You should resolve this member '"+this+"' and call getAnnotations() on the result...");
 	}
 
 	// ---- fields 'n' stuff
 
-
-    
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getDeclaringTypes(org.aspectj.weaver.World)
-	 */
 	public Collection/*ResolvedType*/ getDeclaringTypes(World world) {
 		ResolvedType myType = getDeclaringType().resolve(world);
 		Collection ret = new HashSet();
@@ -574,11 +545,6 @@ public class MemberImpl implements Member {
     }
 
 
-
-
-	/* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getSignatureType()
-	 */
 	public String getSignatureType() {
     	MemberKind kind = getKind();
     	if (getName().equals("<clinit>")) return "org.aspectj.lang.reflect.InitializerSignature";
@@ -790,9 +756,6 @@ public class MemberImpl implements Member {
         return buf.toString();
     }
 
-	/* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getParameterNames(org.aspectj.weaver.World)
-	 */
 	public String[] getParameterNames(World world) {
     	ResolvedMember resolved = resolve(world);
     	if (resolved == null) {
@@ -33,7 +33,8 @@ public interface ResolvedMember extends Member, AnnotatedElement, TypeVariableDe
 	public UnresolvedType[] getExceptions();
 
 	public ShadowMunger getAssociatedShadowMunger();
-//OPTIMIZE have param annotation (and anno default value) related stuff here rather than above
+	
+	//OPTIMIZE have param annotation (and anno default value) related stuff here rather than above
 	// ??? true or false?
 	public boolean isAjSynthetic();
 
@@ -41,6 +42,8 @@ public interface ResolvedMember extends Member, AnnotatedElement, TypeVariableDe
 
 	public boolean hasAnnotation(UnresolvedType ofType);
 
+	public AnnotationX[] getAnnotations();
+	
 	public ResolvedType[] getAnnotationTypes();
 
 	public void setAnnotationTypes(UnresolvedType[] annotationtypes);
@@ -981,7 +981,7 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 	   }
 
 	   // 'declaring' type
-	   r.append(getGenericReturnType().toDebugString());
+	   r.append(getGenericReturnType().toString());
    	   r.append(' ');
 
    	   // name
@@ -997,7 +997,7 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
          if (params.length != 0) {
        	   for (int i=0, len = params.length; i < len; i++) {
              if (i>0) r.append(", ");
-       		 r.append(params[i].toDebugString());
+       		 r.append(params[i].toString());
        		 if (parameterNamesExist) r.append(" ").append(parameterNames[i]);
        	   }
          }
@@ -28,7 +28,7 @@ import org.aspectj.weaver.tools.Traceable;
  * A UnresolvedType represents a type to the weaver. It has a basic signature that knows 
  * nothing about type variables, type parameters, etc.. UnresolvedTypes are resolved in some World
  * (a repository of types). When a UnresolvedType is resolved it turns into a 
- * ResolvedType which may be a primitive type, an array type or a ReferenceType. 
+ * ResolvedType which may be a primitive type, or a ReferenceType. 
  * ReferenceTypes may refer to simple, generic, parameterized or type-variable
  * based reference types. A ReferenceType is backed by a delegate that provides 
  * information about the type based on some repository (currently either BCEL
@@ -207,34 +207,6 @@ public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclar
     	throw new UnsupportedOperationException("unable to parameterize unresolved type: " + signature);
     }
 
-    /**
-     * protected constructor for use only within UnresolvedType hierarchy. Use
-     * one of the UnresolvedType.forXXX static methods for normal creation of
-     * TypeXs.
-     * Picks apart the signature string to set the type kind and calculates the
-     * corresponding signatureErasure. A SIMPLE type created from a plain
-     * Java signature may turn into a GENERIC type when it is resolved.
-     * 
-     * This method should never be called for a primitive type. (UnresolvedType. forSignature
-     * deals with those).
-     * 
-     * @param signature in the form described in the class comment at the
-     * top of this file. 
-     */
-//    protected UnresolvedType(String aSignature) {
-//    	this.signature = aSignature;
-//
-//
-//    }
-    
-    // -----------------------------
-    // old stuff...
-    
-
-	
-	/**
-	 * @param      signature   the bytecode string representation of this Type
-	 */
     protected UnresolvedType(String signature) {
         super();
         this.signature = signature;
@@ -599,10 +571,6 @@ public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclar
     public String toString() {
         return getName(); // + " - " + getKind();
     }
-    
-    public String toDebugString() {
-    	return getName();
-    }
 
     // ---- requires worlds
 
@@ -94,7 +94,9 @@ public class BcelAdvice extends Advice {
 		}
 		return m;
 	}
-	// !!! must only be used for testing
+	/**
+	 * For testing only
+	 */
 	public BcelAdvice(AdviceKind kind, Pointcut pointcut, Member signature,
 		int extraArgumentFlags,
         int start, int end, ISourceContext sourceContext, ResolvedType concreteAspect)
@@ -444,57 +444,22 @@ public class MemberImpl implements Member {
 		return resolved.getExceptions();
     }
 
-    // OPTIMIZE remove world related isMethods()
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#isProtected(org.aspectj.weaver.World)
-	 */
-    public final boolean isProtected(World world) {
-        return Modifier.isProtected(resolve(world).getModifiers());
-    }
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#isStatic(org.aspectj.weaver.World)
-	 */
-    public final boolean isStatic(World world) {
-        return Modifier.isStatic(resolve(world).getModifiers());
-    }
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#isStrict(org.aspectj.weaver.World)
-	 */
-    public final boolean isStrict(World world) {
-        return Modifier.isStrict(resolve(world).getModifiers());
-    }
-    
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#isStatic()
-	 */
     public final boolean isStatic() {
         return Modifier.isStatic(modifiers);
     }    
-    
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#isInterface()
-	 */
+
     public final boolean isInterface() {
         return Modifier.isInterface(modifiers);  // this is kinda weird
     }    
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#isPrivate()
-	 */
     public final boolean isPrivate() {
         return Modifier.isPrivate(modifiers);
     }    
-    
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#canBeParameterized()
-	 */
+
     public boolean canBeParameterized() {
     	return false;
     }
 
-	/* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getCallsiteModifiers()
-	 */
 	public final int getCallsiteModifiers() {
 		return modifiers & ~ Modifier.INTERFACE;
 	}
@@ -117,6 +117,7 @@ public abstract class World implements Dump.INode {
 	private boolean runMinimalMemory = false;
 	private boolean shouldPipelineCompilation = true;
 	protected boolean bcelRepositoryCaching = xsetBCEL_REPOSITORY_CACHING_DEFAULT.equalsIgnoreCase("true");
+	private boolean fastMethodPacking = false; 
 	private boolean completeBinaryTypes = false;
 	public boolean forDEBUG_structuralChangesCode = false;
 	public boolean forDEBUG_bridgingCode = false;
@@ -810,6 +811,7 @@ public abstract class World implements Dump.INode {
 	public final static String xsetCOMPLETE_BINARY_TYPES = "completeBinaryTypes";
 	public final static String xsetCOMPLETE_BINARY_TYPES_DEFAULT = "false"; 
 	public final static String xsetBCEL_REPOSITORY_CACHING_DEFAULT = "true"; 
+	public final static String xsetFAST_PACK_METHODS = "fastPackMethods";  // default TRUE
 
 	public boolean isInJava5Mode() {
 		return behaveInJava5Way;
@@ -1218,6 +1220,9 @@ public abstract class World implements Dump.INode {
 				if (!bcelRepositoryCaching) {
 					getMessageHandler().handleMessage(MessageUtil.info("[bcelRepositoryCaching=false] AspectJ will not use a bcel cache for class information"));
 				}
+
+				s = p.getProperty(xsetFAST_PACK_METHODS,"true");
+				fastMethodPacking = s.equalsIgnoreCase("true");
 
 				s = p.getProperty(xsetPIPELINE_COMPILATION,xsetPIPELINE_COMPILATION_DEFAULT);
 				shouldPipelineCompilation = s.equalsIgnoreCase("true");
@@ -1249,6 +1254,11 @@ public abstract class World implements Dump.INode {
 	      ensureAdvancedConfigurationProcessed();
 	    	  return runMinimalMemory;
 	    }
+
+    public boolean shouldFastPackMethods() {
+        ensureAdvancedConfigurationProcessed();
+        return fastMethodPacking;
+    }
 
 	    public boolean shouldPipelineCompilation() {
 	    	ensureAdvancedConfigurationProcessed();
@@ -47,6 +47,7 @@ import org.aspectj.apache.bcel.generic.LocalVariableTag;
 import org.aspectj.apache.bcel.generic.MethodGen;
 import org.aspectj.apache.bcel.generic.ObjectType;
 import org.aspectj.apache.bcel.generic.Tag;
+import org.aspectj.apache.bcel.generic.TargetLostException;
 import org.aspectj.apache.bcel.generic.Type;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
@@ -96,8 +97,8 @@ public final class LazyMethodGen implements Traceable {
     private BcelMethod memberView;
     private AjAttribute.EffectiveSignatureAttribute effectiveSignature;
     int highestLineNumber = 0;
+    boolean wasPackedOptimally = false;
 
-
     /*
      * We use LineNumberTags and not Gens.
      * 
@@ -433,7 +434,8 @@ public final class LazyMethodGen implements Traceable {
 
     	try {
 			MethodGen gen = pack();
-			return gen.getMethod();
+			savedMethod = gen.getMethod();
+			return savedMethod;
     	} catch (ClassGenException e) {
     		enclosingClass.getBcelObjectType().getResolvedTypeX().getWorld().showMessage(
     			IMessage.ERROR, 
@@ -450,6 +452,9 @@ public final class LazyMethodGen implements Traceable {
     }
 
     public void markAsChanged() {
+    	if (wasPackedOptimally) {
+    		throw new RuntimeException("Already packed method is being re-modified: "+getClassName()+" "+toShortString());
+    	}
     	initialize();
     	savedMethod = null;
     }
@@ -933,7 +938,15 @@ public final class LazyMethodGen implements Traceable {
         }
 
         if (hasBody()) {
-            packBody(gen);
+        	if (this.enclosingClass.getWorld().shouldFastPackMethods()) {
+	            if (isAdviceMethod() || getName().equals("<clinit>")) {
+	        		packBody(gen);
+	        	} else {
+	        		optimizedPackBody(gen); 
+	        	}
+        	} else {
+        		packBody(gen);
+        	}
             gen.setMaxLocals();
             gen.setMaxStack();
         } else {
@@ -1046,6 +1059,108 @@ public final class LazyMethodGen implements Traceable {
         }
     }
 
+
+    /*
+     * Optimized packing that does a 'local packing' of the code rather than building a brand new method
+     * and packing into it.  Only usable when the packing is going to be done just once.
+     */
+    public void optimizedPackBody(MethodGen gen) {
+    	InstructionList theBody = getBody();
+        InstructionHandle iHandle = theBody.getStart();
+
+        int currLine = -1;
+		int lineNumberOffset = (fromFilename == null) ? 0: getEnclosingClass().getSourceDebugExtensionOffset(fromFilename);
+        Map localVariables = new HashMap();
+        LinkedList exceptionList = new LinkedList();   
+        Set forDeletion = new HashSet();
+        Set branchInstructions = new HashSet();
+        // OPTIMIZE sort out in here: getRange()/insertHandler() and type of exceptionList
+        while (iHandle != null) {
+        	Instruction inst = iHandle.getInstruction();
+        	InstructionHandle nextInst = iHandle.getNext();
+        	// OPTIMIZE remove this instructionhandle as it now points to nowhere?
+        	if (inst == Range.RANGEINSTRUCTION) {
+        		Range r = Range.getRange(iHandle);
+	    		if (r instanceof ExceptionRange) {
+	    		    ExceptionRange er = (ExceptionRange) r;
+	    		    if (er.getStart() == iHandle) {
+	    		    	if (!er.isEmpty()){
+	    		        	// order is important, insert handlers in order of start
+	    		        	insertHandler(er, exceptionList);	    	      
+	    		    	}
+	    		    }
+	    		} 
+    			forDeletion.add(iHandle);
+    		} else {
+    			if (inst instanceof InstructionBranch) {
+    				branchInstructions.add(iHandle);
+    			}
+
+              InstructionTargeter[] targeters = iHandle.getTargeters();
+              if (targeters != null) {
+                  for (int k = targeters.length - 1; k >= 0; k--) {
+                      InstructionTargeter targeter = targeters[k];
+                      if (targeter instanceof LineNumberTag) {
+                          int line = ((LineNumberTag)targeter).getLineNumber();
+                          if (line != currLine) {
+                              gen.addLineNumber(iHandle, line + lineNumberOffset);
+                              currLine = line;
+                          }
+                      } else if (targeter instanceof LocalVariableTag) {
+                          LocalVariableTag lvt = (LocalVariableTag) targeter;
+                          LVPosition p = (LVPosition)localVariables.get(lvt);
+                          // If we don't know about it, create a new position and store
+                          // If we do know about it - update its end position
+                          if (p==null) {
+                          	LVPosition newp = new LVPosition();
+                          	newp.start=newp.end=iHandle;
+                          	localVariables.put(lvt,newp);
+                          } else {
+                          	p.end = iHandle;
+                          }
+                      }
+                  }
+              }
+    		}
+        	iHandle = iHandle.getNext();
+        }
+        for (Iterator iterator = branchInstructions.iterator(); iterator.hasNext();) {
+			BranchHandle iBranch = (BranchHandle) iterator.next();
+			handleBranchInstruction(iBranch,forDeletion);
+		}
+    	// now add exception handlers
+        for (Iterator iter = exceptionList.iterator(); iter.hasNext();) {
+            ExceptionRange r = (ExceptionRange) iter.next();
+            if (r.isEmpty()) continue;
+            gen.addExceptionHandler(
+                jumpForward(r.getRealStart(),forDeletion), 
+                jumpForward(r.getRealEnd(),forDeletion),
+                jumpForward(r.getHandler(),forDeletion),
+                (r.getCatchType() == null)
+                ? null 
+                : (ObjectType) BcelWorld.makeBcelType(r.getCatchType()));
+        }
+        
+        for (Iterator iterator = forDeletion.iterator(); iterator.hasNext();) {
+        	try {
+				theBody.delete((InstructionHandle)iterator.next());
+			} catch (TargetLostException e) {
+				e.printStackTrace();
+			}
+        }
+        gen.setInstructionList(theBody);
+        addLocalVariables(gen,localVariables);
+        
+        // JAVAC adds line number tables (with just one entry) to generated accessor methods - this
+        // keeps some tools that rely on finding at least some form of linenumbertable happy.
+        // Let's check if we have one - if we don't then let's add one.
+        // TODO Could be made conditional on whether line debug info is being produced
+        if (gen.getLineNumbers().length==0) { 
+        	gen.addLineNumber(gen.getInstructionList().getStart(),1);
+        }
+        wasPackedOptimally = true;
+    }
+    
     private void addLocalVariables(MethodGen gen, Map localVariables) {
 		// now add local variables
         gen.removeLocalVariables();
@@ -1118,6 +1233,44 @@ public final class LazyMethodGen implements Traceable {
 	        }
 	    }
 	}
+	
+	private InstructionHandle jumpForward(InstructionHandle t,Set handlesForDeletion) {
+		
+		InstructionHandle target = t;
+		  if (handlesForDeletion.contains(target)) {
+		    	do {
+		    		target = target.getNext();
+		    	} while (handlesForDeletion.contains(target));
+		    }
+		  return target;
+	}
+	
+	private void handleBranchInstruction(BranchHandle branchHandle, Set handlesForDeletion) {
+		InstructionBranch branchInstruction = (InstructionBranch) branchHandle.getInstruction();
+	    InstructionHandle target = branchInstruction.getTarget(); // old target
+   
+	    if (handlesForDeletion.contains(target)) {
+	    	do {
+	    		target = target.getNext();
+	    	} while (handlesForDeletion.contains(target));
+	    	branchInstruction.setTarget(target);
+	    }
+   
+	    if (branchInstruction instanceof InstructionSelect) { 
+	        // Either LOOKUPSWITCH or TABLESWITCH
+	        InstructionHandle[] targets = ((InstructionSelect)branchInstruction).getTargets();
+	        for (int k = targets.length - 1; k >= 0; k--) { 
+	        	InstructionHandle oneTarget = targets[k];
+	        	if (handlesForDeletion.contains(oneTarget)) {
+	    	    	do {
+	    	    		oneTarget = oneTarget.getNext();
+	    	    	} while (handlesForDeletion.contains(oneTarget));
+	    	    	branchInstruction.setTarget(oneTarget);
+	    	    	oneTarget.addTargeter(branchInstruction);
+	    	    }
+	        }
+	    }
+	}
 
 	private void handleRangeInstruction(InstructionHandle ih, LinkedList exnList) {
 		// we're a range instruction
@@ -1181,6 +1334,13 @@ public final class LazyMethodGen implements Traceable {
 //			curr = next;
 //    	}
 //	}
+   
+   private static InstructionHandle fNext(InstructionHandle ih) {
+	   while (true) {
+		   if (ih.getInstruction()==Range.RANGEINSTRUCTION) ih = ih.getNext();
+		   else return ih;
+	   }
+   }
 
     private static InstructionHandle remap(InstructionHandle ih, Map map) {
         while (true) {
@@ -16,7 +16,7 @@ package org.aspectj.weaver;
 import java.util.Collection;
 import java.util.Iterator;
 
-public interface Member {
+public interface Member extends Comparable {
 
 	public static final Member[] NONE = new Member[0];
 	public static final MemberKind METHOD = new MemberKind("METHOD", 1);
@@ -36,7 +36,7 @@ public interface Member {
 
 	public ResolvedMember resolve(World world);
 
-	public int compareTo(Object other);
+    public int compareTo(Object other);
 
 	public String toLongString();
 
@@ -53,10 +53,6 @@ public interface Member {
 
 	public UnresolvedType[] getParameterTypes();
 
-	public AnnotationX[][] getParameterAnnotations();
-	public ResolvedType[][] getParameterAnnotationTypes();
-	
-	public String getAnnotationDefaultValue();
 
 	/**
 	 * Return full signature, including return type, e.g. "()LFastCar;" for a signature without the return type,
@@ -83,7 +79,6 @@ public interface Member {
 
 	public int getModifiers();
 
-	public UnresolvedType[] getExceptions(World world);
 
     public boolean isStatic();
 
@@ -101,28 +96,19 @@ public interface Member {
 
 	public String getExtractableName();
 
-	/**
-	 * If you want a sensible answer, resolve the member and call
-	 * hasAnnotation() on the ResolvedMember.
-	 */
-	public boolean hasAnnotation(UnresolvedType ofType);
-
-	/* (non-Javadoc)
-	 * @see org.aspectj.weaver.AnnotatedElement#getAnnotationTypes()
-	 */
-	public ResolvedType[] getAnnotationTypes();
-
-	public AnnotationX[] getAnnotations();
-
-	public Collection/*ResolvedType*/getDeclaringTypes(World world);
+    public AnnotationX[] getAnnotations();
 
 	// ---- reflective thisJoinPoint stuff
 	public String getSignatureMakerName();
 
 	public String getSignatureType();
 
+	
+    public Collection/* ResolvedType */getDeclaringTypes(World world);
+    
 	public String getSignatureString(World world);
 
 	public String[] getParameterNames(World world);
 
+    public UnresolvedType[] getExceptions(World world);
 }
\ No newline at end of file
@@ -21,7 +21,7 @@ import java.util.Iterator;
 import java.util.List;
 
 
-public class MemberImpl implements Comparable, AnnotatedElement,Member {
+public class MemberImpl implements Member {
 
     protected MemberKind kind;
     protected String name;
@@ -91,13 +91,10 @@ public class MemberImpl implements Comparable, AnnotatedElement,Member {
         }
     }
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#resolve(org.aspectj.weaver.World)
-	 */
     public ResolvedMember resolve(World world) {
     	return world.resolve(this);
     }
-
+     
     // ---- utility methods
 
     /** returns an Object[] pair of UnresolvedType, UnresolvedType[] representing return type, 
@@ -303,17 +300,15 @@ public class MemberImpl implements Comparable, AnnotatedElement,Member {
         return hashCode;
     }
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#compareTo(java.lang.Object)
-	 */
-    public int compareTo(Object other) {
-    	Member o = (Member) other;
-    	
-    	int i = getName().compareTo(o.getName());
-    	if (i != 0) return i;
-    	return getSignature().compareTo(o.getSignature());
+
+     public int compareTo(Object other) {
+        Member o = (Member) other;
+
+        int i = getName().compareTo(o.getName());
+        if (i != 0) return i;
+        return getSignature().compareTo(o.getSignature());
     }
-    
+
     public String toString() {
     	StringBuffer buf = new StringBuffer();
     	buf.append(returnType.getName());
@@ -383,19 +378,7 @@ public class MemberImpl implements Comparable, AnnotatedElement,Member {
 	 */
     public UnresolvedType[]  getParameterTypes() { return parameterTypes; }
 
-    public AnnotationX[][] getParameterAnnotations() {
-		throw new UnsupportedOperationException("You should resolve this member and call getParameterAnnotations() on the result...");
-    }
-    public ResolvedType[][] getParameterAnnotationTypes() { 
-		throw new UnsupportedOperationException("You should resolve this member and call getParameterAnnotationTypes() on the result...");
-    }
-    public String getAnnotationDefaultValue() { 
-		throw new UnsupportedOperationException("You should resolve this member and call getAnnotationDefaultValue() on the result...");
-    }
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getSignature()
-	 */
     public String getSignature() { return signature; }
 
     public int getArity() { return parameterTypes.length; }
@@ -530,21 +513,6 @@ public class MemberImpl implements Comparable, AnnotatedElement,Member {
     	else return name;
     }
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#hasAnnotation(org.aspectj.weaver.UnresolvedType)
-	 */
-	 // OPTIMIZE dont have these here, move them down to ResolvedMember
-	public boolean hasAnnotation(UnresolvedType ofType) {
-		throw new UnsupportedOperationException("You should resolve this member and call hasAnnotation() on the result...");
-	}
-	
-	public ResolvedType[] getAnnotationTypes() {
-		throw new UnsupportedOperationException("You should resolve this member and call hasAnnotation() on the result...");
-	}
-
-    public AnnotationX getAnnotationOfType(UnresolvedType ofType) { 
-		throw new UnsupportedOperationException("You should resolve this member and call getAnnotationOfType() on the result...");
-    }
 
 	/* (non-Javadoc)
 	 * @see org.aspectj.weaver.Member#getAnnotations()
@@ -60,6 +60,10 @@ public interface ResolvedMember extends Member, AnnotatedElement, TypeVariableDe
 	public String[] getParameterNames();
 	public void setParameterNames(String[] names);
 
+	public AnnotationX[][] getParameterAnnotations();
+	public ResolvedType[][] getParameterAnnotationTypes();
+	public String getAnnotationDefaultValue();
+	
 	public String[] getParameterNames(World world);
 
 	public AjAttribute.EffectiveSignatureAttribute getEffectiveSignature();
@@ -308,7 +308,11 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
     	if (annotationTypes == null) return null;
 		return (ResolvedType[])annotationTypes.toArray(new ResolvedType[]{});
     }
-    
+
+     public String getAnnotationDefaultValue() {
+         throw new UnsupportedOperationException("You should resolve this member and call getAnnotationDefaultValue() on the result...");
+     }
+     
     public AnnotationX[] getAnnotations() {
     	if (backingGenericMember != null) return backingGenericMember.getAnnotations();
     	return super.getAnnotations();
@@ -327,12 +331,14 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 		return parameterAnnotationTypes;
     }
 
-    public AnnotationX[][] getParameterAnnotations() {
-    	if (backingGenericMember != null) return backingGenericMember.getParameterAnnotations();
-    	return super.getParameterAnnotations();
+
+     public AnnotationX[][] getParameterAnnotations() {
+        if (backingGenericMember != null) return backingGenericMember.getParameterAnnotations();
+        throw new BCException("Cannot return parameter annotations for a " + this.getClass().getName() + " member");
+//        return super.getParameterAnnotations();
     }
-	
-	public void addAnnotation(AnnotationX annotation) {
+
+    public void addAnnotation(AnnotationX annotation) {
    	    // FIXME asc only allows for annotation types, not instances - should it?
 		if (annotationTypes == null) annotationTypes = new HashSet();
 		annotationTypes.add(annotation.getSignature());
@@ -472,6 +478,7 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 
 
 
+    // OPTIMIZE dont like how resolve(world) on ResolvedMemberImpl does something different to world.resolve(member)
 	public ResolvedMember resolve(World world) {
         // make sure all the pieces of a resolvedmember really are resolved
 		try {
@@ -1040,5 +1047,9 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 	}
 
 	public void evictWeavingState() { }
+	
+	 public AnnotationX getAnnotationOfType(UnresolvedType ofType) {
+	     throw new UnsupportedOperationException("You should resolve this member and call getAnnotationOfType() on the result...");
+     }
 }
 
@@ -29,10 +29,10 @@ public class MemberTestCase extends TestCase {
     }
 
     public void testMethodConstruction() {
-        Member s = MemberImpl.methodFromString("void Foo.goo(int)");
+        Member s = TestUtils.methodFromString("void Foo.goo(int)");
         Member t = MemberImpl.method(UnresolvedType.forName("Foo"), 0, "goo", "(I)V");
-        Member u = MemberImpl.methodFromString("void Foo1.goo(int)");
-        Member v = MemberImpl.methodFromString("int Foo.goo(int)");
+        Member u = TestUtils.methodFromString("void Foo1.goo(int)");
+        Member v = TestUtils.methodFromString("int Foo.goo(int)");
 
         TestUtil.assertCommutativeEquals(s, s, true);
         TestUtil.assertCommutativeEquals(t, t, true);
@@ -45,10 +45,10 @@ public class MemberTestCase extends TestCase {
         TestUtil.assertCommutativeEquals(t, v, false);
         TestUtil.assertCommutativeEquals(u, v, false);
 
-        s = MemberImpl.fieldFromString("int Foo.goo");
+        s = TestUtils.fieldFromString("int Foo.goo");
         t = MemberImpl.field("Foo", 0, "goo", "I");
-        u = MemberImpl.fieldFromString("int Foo.goo1");
-        v = MemberImpl.fieldFromString("long Foo.goo");
+        u = TestUtils.fieldFromString("int Foo.goo1");
+        v = TestUtils.fieldFromString("long Foo.goo");
 
         TestUtil.assertCommutativeEquals(s, s, true);
         TestUtil.assertCommutativeEquals(t, t, true);
@@ -64,7 +64,7 @@ public class MemberTestCase extends TestCase {
 
 
     public void testMethodContents() {
-        Member m = MemberImpl.methodFromString("void Foo.goo(int)");
+        Member m = TestUtils.methodFromString("void Foo.goo(int)");
         kindTest(m, Member.METHOD);
         declaringTypeTest(m, "Foo");
         nameTest(m, "goo");
@@ -75,7 +75,7 @@ public class MemberTestCase extends TestCase {
         isConstructorTest(m, false);
         isStaticTest(m, false);
 
-        m = MemberImpl.methodFromString("interface java.lang.Object java.util.Iterator.next()");
+        m = TestUtils.methodFromString("interface java.lang.Object java.util.Iterator.next()");
         kindTest(m, Member.METHOD);
         declaringTypeTest(m, "java.util.Iterator");
         nameTest(m, "next");
@@ -86,7 +86,7 @@ public class MemberTestCase extends TestCase {
         isConstructorTest(m, false);
         isStaticTest(m, false);
 
-        m = MemberImpl.methodFromString("void Foo.<init>(int, java.lang.Object)");
+        m = TestUtils.methodFromString("void Foo.<init>(int, java.lang.Object)");
         kindTest(m, Member.CONSTRUCTOR);
         declaringTypeTest(m, "Foo");
         nameTest(m, "<init>");
@@ -97,7 +97,7 @@ public class MemberTestCase extends TestCase {
         isConstructorTest(m, true);
         isStaticTest(m, false);
 
-        m = MemberImpl.methodFromString("private double Foo.sqrt(double)");
+        m = TestUtils.methodFromString("private double Foo.sqrt(double)");
         kindTest(m, Member.METHOD);
         declaringTypeTest(m, "Foo");
         nameTest(m, "sqrt");
@@ -108,7 +108,7 @@ public class MemberTestCase extends TestCase {
         isConstructorTest(m, false);
         isStaticTest(m, false);
 
-        m = MemberImpl.methodFromString("static int java.lang.Math.max(int, int)");
+        m = TestUtils.methodFromString("static int java.lang.Math.max(int, int)");
         kindTest(m, Member.METHOD);
         declaringTypeTest(m, "java.lang.Math");
         nameTest(m, "max");
@@ -121,7 +121,7 @@ public class MemberTestCase extends TestCase {
     }
 
     public void testFieldContents() {
-        Member m = MemberImpl.fieldFromString("int Foo.goo");
+        Member m = TestUtils.fieldFromString("int Foo.goo");
         kindTest(m, Member.FIELD);
         declaringTypeTest(m, "Foo");
         nameTest(m, "goo");
@@ -132,7 +132,7 @@ public class MemberTestCase extends TestCase {
         isConstructorTest(m, false);
         isStaticTest(m, false);
 
-        m = MemberImpl.fieldFromString("static java.util.Iterator goo.Bar.i");
+        m = TestUtils.fieldFromString("static java.util.Iterator goo.Bar.i");
         kindTest(m, Member.FIELD);
         declaringTypeTest(m, "goo.Bar");
         nameTest(m, "i");
@@ -9,17 +9,17 @@
  * ******************************************************************/
 package org.aspectj.weaver.patterns;
 
+import junit.framework.TestCase;
+
 import org.aspectj.bridge.AbortException;
 import org.aspectj.util.LangUtil;
 import org.aspectj.weaver.AnnotatedElement;
 import org.aspectj.weaver.AnnotationX;
-import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.BcweaverTests;
+import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.bcel.BcelWorld;
 
-import junit.framework.TestCase;
-
 public class AnnotationPatternTestCase extends TestCase {
 
 
@@ -29,7 +29,7 @@ public class AnnotationPatternTestCase extends TestCase {
 		AnnotationTypePattern foo = p.maybeParseAnnotationPattern();
 		foo = foo.resolveBindings(makeSimpleScope(),new Bindings(3),true);
 		assertTrue("ExactAnnotationTypePattern",foo instanceof ExactAnnotationTypePattern);
-		assertEquals("Foo",UnresolvedType.forName("Foo"),((ExactAnnotationTypePattern)foo).annotationType);
+		assertEquals("Foo", UnresolvedType.forSignature("LFoo;"), ((ExactAnnotationTypePattern) foo).annotationType);
 	}
 
 	public void testParseAndAnnotationPattern() {
@@ -41,8 +41,8 @@ public class AnnotationPatternTestCase extends TestCase {
 		assertEquals("@Foo @Goo",fooAndGoo.toString());
 		AnnotationTypePattern left = ((AndAnnotationTypePattern)fooAndGoo).getLeft();
 		AnnotationTypePattern right = ((AndAnnotationTypePattern)fooAndGoo).getRight();
-		assertEquals("Foo",UnresolvedType.forName("Foo"),((ExactAnnotationTypePattern)left).annotationType);
-		assertEquals("Goo",UnresolvedType.forName("Goo"),((ExactAnnotationTypePattern)right).annotationType);		
+		assertEquals("Foo", UnresolvedType.forSignature("LFoo;"), ((ExactAnnotationTypePattern) left).annotationType);
+        assertEquals("Goo", UnresolvedType.forSignature("LGoo;"), ((ExactAnnotationTypePattern) right).annotationType);		
 	}
 //
 //	public void testParseOrAnnotationPattern() {
@@ -33,7 +33,7 @@ public class AfterThrowingWeaveTestCase extends WeaveTestCase {
         BcelWorld world = new BcelWorld();
 
         ShadowMunger myMunger = 
-            world.shadowMunger("afterThrowing(): get(* *.out) -> static void Aspect.ajc_afterThrowing_field_get(java.lang.Throwable)",
+            TestUtils.shadowMunger(world,"afterThrowing(): get(* *.out) -> static void Aspect.ajc_afterThrowing_field_get(java.lang.Throwable)",
                         Advice.ExtraArgument);
         ShadowMunger cm = myMunger.concretize(ResolvedType.MISSING, world, null);
 
@@ -19,6 +19,7 @@ import java.util.Arrays;
 import org.aspectj.weaver.Advice;
 import org.aspectj.weaver.AdviceKind;
 import org.aspectj.weaver.MemberImpl;
+import org.aspectj.weaver.TestUtils;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
 
@@ -46,7 +47,7 @@ public class TjpWeaveTestCase extends WeaveTestCase {
     	BcelAdvice munger = new BcelAdvice(
     		AdviceKind.stringToKind("before"),
     		makePointcutAll(), 
-      		MemberImpl.methodFromString("static void Aspect.ajc_before(org.aspectj.lang.JoinPoint$StaticPart)"),
+    		TestUtils.methodFromString("static void Aspect.ajc_before(org.aspectj.lang.JoinPoint$StaticPart)"),
     		Advice.ThisJoinPointStaticPart, -1, -1, null, null);
 
         weaveTest("HelloWorld", "StaticTjpBeforeHelloWorld", munger);
@@ -57,7 +58,7 @@ public class TjpWeaveTestCase extends WeaveTestCase {
     	BcelAdvice munger = new BcelAdvice(
     		AdviceKind.stringToKind("before"),
     		makePointcutAll(), 
-      		MemberImpl.methodFromString("static void Aspect.ajc_before(org.aspectj.lang.JoinPoint$StaticPart)"),
+    		TestUtils.methodFromString("static void Aspect.ajc_before(org.aspectj.lang.JoinPoint$StaticPart)"),
     		Advice.ThisEnclosingJoinPointStaticPart, -1, -1, null, null);
 
         weaveTest("HelloWorld", "StaticEnclosingTjpBeforeHelloWorld", munger);
@@ -68,7 +69,7 @@ public class TjpWeaveTestCase extends WeaveTestCase {
     	BcelAdvice munger = new BcelAdvice(
     		AdviceKind.stringToKind("before"),
     		makePointcutAll(), 
-      		MemberImpl.methodFromString("static void Aspect.ajc_before(org.aspectj.lang.JoinPoint)"),
+    		TestUtils.methodFromString("static void Aspect.ajc_before(org.aspectj.lang.JoinPoint)"),
     		Advice.ThisJoinPoint, -1, -1, null, null);
 
         weaveTest("HelloWorld", "TjpBeforeHelloWorld", munger);
@@ -78,7 +79,7 @@ public class TjpWeaveTestCase extends WeaveTestCase {
     	BcelAdvice munger = new BcelAdvice(
     		AdviceKind.stringToKind("around"),
     		makePointcutAll(), 
-      		MemberImpl.methodFromString("static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)"),
+    		TestUtils.methodFromString("static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)"),
     		Advice.ThisJoinPoint | Advice.ExtraArgument, -1, -1, null, null);
 
         weaveTest("HelloWorld", "TjpAroundHelloWorld", munger);
@@ -90,14 +91,14 @@ public class TjpWeaveTestCase extends WeaveTestCase {
     	BcelAdvice munger1 = new BcelAdvice(
     		AdviceKind.stringToKind("around"),
     		makePointcutAll(), 
-      		MemberImpl.methodFromString("static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)"),
+    		TestUtils.methodFromString("static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)"),
     		Advice.ThisJoinPoint | Advice.ExtraArgument, -1, -1, null, 
     		rtx);
 
     	BcelAdvice munger2 = new BcelAdvice(
     		AdviceKind.stringToKind("around"),
     		makePointcutAll(), 
-      		MemberImpl.methodFromString("static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)"),
+    		TestUtils.methodFromString("static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)"),
     		Advice.ThisJoinPoint | Advice.ExtraArgument, -1, -1, null, 
     		rtx);
 
@@ -189,7 +189,7 @@ public abstract class WeaveTestCase extends TestCase {
 
     protected ShadowMunger makeConcreteAdvice(String mungerString, int extraArgFlag, PerClause perClause) {
         Advice myMunger = 
-            world.shadowMunger(mungerString, extraArgFlag);
+        	TestUtils.shadowMunger(world,mungerString, extraArgFlag);
 
 //        PerSingleton s = new PerSingleton();
 //        s.concretize(world.resolve("Aspect"));
@@ -38,7 +38,7 @@ public class WorldTestCase extends AbstractWorldTestCase {
         ResolvedType trace = world.resolve(UnresolvedType.forName("Trace"),true);
         assertTrue("Couldnt find type Trace",!trace.isMissing());
         fieldsTest(trace, Member.NONE);
-        /*Member constr = */MemberImpl.methodFromString("void Trace.<init>()"); 
+        /*Member constr = */TestUtils.methodFromString("void Trace.<init>()"); 
         //XXX need attribute fix - 
         //methodsTest(trace, new Member[] { constr });
 
@@ -58,13 +58,13 @@ public class WorldTestCase extends AbstractWorldTestCase {
 
         mungersTest(trace, 
             new ShadowMunger[] {
-				world.shadowMunger("before(foo): traced(foo) -> void Trace.ajc_before_4(java.lang.Object))",
+        		TestUtils.shadowMunger(world,"before(foo): traced(foo) -> void Trace.ajc_before_4(java.lang.Object))",
             					0),
-				world.shadowMunger("afterReturning(foo): traced(foo) -> void Trace.ajc_afterreturning_3(java.lang.Object, java.lang.Object))",
+            					TestUtils.shadowMunger(world,"afterReturning(foo): traced(foo) -> void Trace.ajc_afterreturning_3(java.lang.Object, java.lang.Object))",
             					Advice.ExtraArgument),
-				world.shadowMunger("around(): execution(* doit(..)) -> java.lang.Object Trace.ajc_around_2(org.aspectj.runtime.internal.AroundClosure))",
+            					TestUtils.shadowMunger(world,"around(): execution(* doit(..)) -> java.lang.Object Trace.ajc_around_2(org.aspectj.runtime.internal.AroundClosure))",
             					Advice.ExtraArgument),
-				world.shadowMunger("around(foo): traced(foo) -> java.lang.Object Trace.ajc_around_1(java.lang.Object, org.aspectj.runtime.internal.AroundClosure))",
+            					TestUtils.shadowMunger(world,"around(foo): traced(foo) -> java.lang.Object Trace.ajc_around_1(java.lang.Object, org.aspectj.runtime.internal.AroundClosure))",
             					Advice.ExtraArgument),
             });
 
@@ -0,0 +1,39 @@
+/* *******************************************************************
+ * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *     PARC     initial implementation 
+ * ******************************************************************/
+
+
+package org.aspectj.weaver.bcel;
+
+import java.io.File;
+import java.io.IOException;
+
+
+//XXX delete very soon
+public class ZipFileWeaver {
+	File inFile;
+	public ZipFileWeaver(File inFile) {
+		super();
+		this.inFile = inFile;
+	}
+
+	public void weave(BcelWeaver weaver, File outFile) throws IOException {
+		int count = 0;
+		long startTime = System.currentTimeMillis();
+		weaver.addJarFile(inFile, new File("."),false);
+		weaver.weave(outFile);
+		long stopTime = System.currentTimeMillis();
+		
+		
+		System.out.println("handled " + count + " entries, in " + 
+				(stopTime-startTime)/1000. + " seconds");
+	}
+}
@@ -11,7 +11,7 @@
 package org.aspectj.weaver.tools;
 
 import org.apache.commons.logging.LogFactory;
-
+//OPTIMIZE move out of main weaver for now?
 public class CommonsTraceFactory extends TraceFactory {
 
 	private LogFactory logFactory = LogFactory.getFactory();
@@ -255,23 +255,25 @@ public class WildTypePattern extends TypePattern {
 	// we've matched against the base (or raw) type, but if this type pattern specifies bounds because
 	// it is a ? extends or ? super deal then we have to match them too.
 	private boolean matchesBounds(ResolvedType aType, MatchKind staticOrDynamic) {
-		if (upperBound == null && aType.getUpperBound() != null) {
+	    if (!(aType instanceof BoundedReferenceType)) return true;
+	    BoundedReferenceType boundedRT = (BoundedReferenceType) aType;
+		if (upperBound == null && boundedRT.getUpperBound() != null) {
 			// for upper bound, null can also match against Object - but anything else and we're out.
-			if (!aType.getUpperBound().getName().equals(UnresolvedType.OBJECT.getName())) {
+			if (!boundedRT.getUpperBound().getName().equals(UnresolvedType.OBJECT.getName())) {
 				return false;
 			}
 		}
-		if (lowerBound == null && aType.getLowerBound() != null) return false;
+		if (lowerBound == null && boundedRT.getLowerBound() != null) return false;
 		if (upperBound != null) {
 			// match ? extends
-			if (aType.isGenericWildcard() && aType.isSuper()) return false;
-			if (aType.getUpperBound() == null) return false;
-			return upperBound.matches((ResolvedType)aType.getUpperBound(),staticOrDynamic).alwaysTrue();
+			if (aType.isGenericWildcard() && boundedRT.isSuper()) return false;
+            if (boundedRT.getUpperBound() == null) return false;
+            return upperBound.matches((ResolvedType) boundedRT.getUpperBound(), staticOrDynamic).alwaysTrue();
 		}
 		if (lowerBound != null) {
 			// match ? super
-			if (!(aType.isGenericWildcard() && aType.isSuper())) return false;
-			return lowerBound.matches((ResolvedType)aType.getLowerBound(),staticOrDynamic).alwaysTrue();
+			if (!(boundedRT.isGenericWildcard() && boundedRT.isSuper())) return false;
+            return lowerBound.matches((ResolvedType) boundedRT.getLowerBound(), staticOrDynamic).alwaysTrue();
 		}
 		return true;
 	}
@@ -44,10 +44,7 @@ public class ExactAnnotationTypePattern extends AnnotationTypePattern {
 	private boolean bindingPattern = false;
 	private Map annotationValues;
 
-	/**
-	 * @param annotationValues 
-	 * 
-	 */
+	 // OPTIMIZE is annotationtype really unresolved???? surely it is resolved by now...
 	public ExactAnnotationTypePattern(UnresolvedType annotationType, Map annotationValues) {
 		this.annotationType = annotationType;
 		this.annotationValues = annotationValues;
@@ -20,6 +20,7 @@ import java.util.Map;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.weaver.ISourceContext;
 import org.aspectj.weaver.ResolvedType;
+import org.aspectj.weaver.TypeVariableReferenceType;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.VersionedDataInputStream;
 import org.aspectj.weaver.WeaverMessages;
@@ -102,8 +103,9 @@ public class DeclareSoft extends Declare {
     	ResolvedType excType = exception.getExactType().resolve(scope.getWorld());
     	if (!excType.isMissing()) {
     		if (excType.isTypeVariableReference()) {
+    		    TypeVariableReferenceType typeVariableRT = (TypeVariableReferenceType) excType;
     			// a declare soft in a generic abstract aspect, we need to check the upper bound
-    			excType = excType.getUpperBound().resolve(scope.getWorld());
+    			excType = typeVariableRT.getUpperBound().resolve(scope.getWorld());
     		}
     		if (!scope.getWorld().getCoreType(UnresolvedType.THROWABLE).isAssignableFrom(excType)) {
     			scope.getWorld().showMessage(IMessage.ERROR,
@@ -28,7 +28,6 @@ import org.aspectj.weaver.MemberImpl;
 import org.aspectj.weaver.NameMangler;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.Shadow;
-import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.WeaverMessages;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.ast.Expr;
@@ -135,10 +134,10 @@ public class ConcreteCflowPointcut extends Pointcut {
 	}
 
 	private static final Member cflowStackIsValidMethod = 
-		MemberImpl.method(UnresolvedType.forName(NameMangler.CFLOW_STACK_TYPE), 0, "isValid", "()Z");
+		MemberImpl.method(NameMangler.CFLOW_STACK_UNRESOLVEDTYPE, 0, "isValid", "()Z");
 
 	private static final Member cflowCounterIsValidMethod = 
-		MemberImpl.method(UnresolvedType.forName(NameMangler.CFLOW_COUNTER_TYPE), 0, "isValid", "()Z");
+		MemberImpl.method(NameMangler.CFLOW_COUNTER_UNRESOLVEDTYPE, 0, "isValid", "()Z");
 
 
 	public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, IntMap bindings) {
@@ -29,9 +29,10 @@ public class UnwovenClassFileWithThirdPartyManagedBytecode
 		byte[] getBytes();
 	}
 
-	public UnwovenClassFileWithThirdPartyManagedBytecode(String filename,
+	// OPTIMIZE make classname an input char[]
+	public UnwovenClassFileWithThirdPartyManagedBytecode(String filename,String classname,
 			IByteCodeProvider provider) {
-		super(filename,null);
+		super(filename,classname,null);
 		this.provider = provider;
 	}
 
@@ -27,8 +27,8 @@ import java.util.StringTokenizer;
 import org.aspectj.apache.bcel.Constants;
 import org.aspectj.apache.bcel.classfile.Attribute;
 import org.aspectj.apache.bcel.classfile.ClassParser;
-import org.aspectj.apache.bcel.classfile.JavaClass;
 import org.aspectj.apache.bcel.classfile.ConstantPool;
+import org.aspectj.apache.bcel.classfile.JavaClass;
 import org.aspectj.apache.bcel.classfile.Method;
 import org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;
 import org.aspectj.apache.bcel.generic.FieldInstruction;
@@ -46,16 +46,15 @@ import org.aspectj.apache.bcel.util.NonCachingClassLoaderRepository;
 import org.aspectj.apache.bcel.util.Repository;
 import org.aspectj.bridge.IMessageHandler;
 import org.aspectj.weaver.Advice;
-import org.aspectj.weaver.AdviceKind;
 import org.aspectj.weaver.AjAttribute;
 import org.aspectj.weaver.AnnotationOnTypeMunger;
 import org.aspectj.weaver.AnnotationX;
 import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.ConcreteTypeMunger;
 import org.aspectj.weaver.ICrossReferenceHandler;
-import org.aspectj.weaver.MemberKind;
 import org.aspectj.weaver.Member;
 import org.aspectj.weaver.MemberImpl;
+import org.aspectj.weaver.MemberKind;
 import org.aspectj.weaver.NewParentTypeMunger;
 import org.aspectj.weaver.ReferenceType;
 import org.aspectj.weaver.ReferenceTypeDelegate;
@@ -69,10 +68,8 @@ import org.aspectj.weaver.World;
 import org.aspectj.weaver.AjAttribute.Aspect;
 import org.aspectj.weaver.patterns.DeclareAnnotation;
 import org.aspectj.weaver.patterns.DeclareParents;
-import org.aspectj.weaver.patterns.FormalBinding;
 import org.aspectj.weaver.patterns.PerClause;
 import org.aspectj.weaver.patterns.Pointcut;
-import org.aspectj.weaver.patterns.SimpleScope;
 import org.aspectj.weaver.tools.Trace;
 import org.aspectj.weaver.tools.TraceFactory;
 
@@ -175,61 +172,6 @@ public class BcelWorld extends World implements Repository {
 		classPath.addPath(name, this.getMessageHandler());
 	}
 
-    /**
-     * Parse a string into advice.
-     * 
-     * <blockquote><pre>
-     * Kind ( Id , ... ) : Pointcut -> MethodSignature
-     * </pre></blockquote>
-     */
-    public Advice shadowMunger(String str, int extraFlag) {
-        str = str.trim();
-        int start = 0;
-        int i = str.indexOf('(');
-        AdviceKind kind = 
-            AdviceKind.stringToKind(str.substring(start, i));
-        start = ++i;
-        i = str.indexOf(')', i);
-        String[] ids = parseIds(str.substring(start, i).trim());
-        //start = ++i;
-        
-        
-        
-        i = str.indexOf(':', i);        
-        start = ++i;        
-        i = str.indexOf("->", i);
-        Pointcut pointcut = Pointcut.fromString(str.substring(start, i).trim());
-        Member m = MemberImpl.methodFromString(str.substring(i+2, str.length()).trim());
-
-        // now, we resolve
-        UnresolvedType[] types = m.getParameterTypes();
-        FormalBinding[] bindings = new FormalBinding[ids.length];
-        for (int j = 0, len = ids.length; j < len; j++) {
-            bindings[j] = new FormalBinding(types[j], ids[j], j, 0, 0, "fromString");
-        }
-
-        Pointcut p =
-        	pointcut.resolve(new SimpleScope(this, bindings));
-
-        return new BcelAdvice(kind, p, m, extraFlag, 0, 0, null, null);
-    }
-    
-    private String[] parseIds(String str) {
-        if (str.length() == 0) return ZERO_STRINGS;
-        List l = new ArrayList();
-        int start = 0;
-        while (true) {
-            int i = str.indexOf(',', start);
-            if (i == -1) {
-                l.add(str.substring(start).trim());
-                break;
-            }
-            l.add(str.substring(start, i).trim());
-            start = i+1;
-        }
-        return (String[]) l.toArray(new String[l.size()]);
-    }
-    
     // ---- various interactions with bcel
 
     public static Type makeBcelType(UnresolvedType type) {
@@ -674,7 +616,8 @@ public class BcelWorld extends World implements Repository {
 	}
 
 	public void clear() {
-		throw new RuntimeException("Not implemented");
+		delegate.clear();
+//		throw new RuntimeException("Not implemented");
 	}
 
     // @Override
@@ -35,6 +35,7 @@ import org.aspectj.weaver.IEclipseSourceContext;
 import org.aspectj.weaver.ISourceContext;
 import org.aspectj.weaver.Member;
 import org.aspectj.weaver.ResolvedMember;
+import org.aspectj.weaver.ResolvedMemberImpl;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.Shadow;
 import org.aspectj.weaver.ShadowMunger;
@@ -66,10 +67,33 @@ public class BcelAdvice extends Advice {
 		Member signature,
 		ResolvedType concreteAspect) 
 	{
-		super(attribute, pointcut, signature);
+		super(attribute, pointcut,shrink(attribute.getKind(),concreteAspect,signature));// (signature==null?null:signature.slimline()));
 		this.concreteAspect = concreteAspect;
 	}
-
+	/**
+	 * We don't always need to represent the signature with a heavyweight BcelMethod object - only if its around advice
+	 * and inlining is active
+	 * @param concreteAspect 
+	 * @param attribute 
+	 */
+	private static Member shrink(AdviceKind kind, ResolvedType concreteAspect, Member m) {
+		if (m==null) return null;
+		UnresolvedType dType = m.getDeclaringType();
+		// if it isnt around advice or it is but inlining is turned off then shrink it to a ResolvedMemberImpl
+		if (kind != AdviceKind.Around ||
+			((dType instanceof ResolvedType) && ((ResolvedType)dType).getWorld().isXnoInline())) {
+			if (m instanceof BcelMethod) {
+				BcelMethod bm = (BcelMethod)m;
+				if (bm.getMethod()!=null && bm.getMethod().getAnnotations()!=null) return m;
+				ResolvedMemberImpl simplermember = new ResolvedMemberImpl(bm.getKind(),bm.getDeclaringType(),
+						                                       bm.getModifiers(),bm.getReturnType(),bm.getName(),
+						                                       bm.getParameterTypes());//,bm.getExceptions(),bm.getBackingGenericMember());
+				simplermember.setParameterNames(bm.getParameterNames());
+				return simplermember;
+			}
+		}
+		return m;
+	}
 	// !!! must only be used for testing
 	public BcelAdvice(AdviceKind kind, Pointcut pointcut, Member signature,
 		int extraArgumentFlags,
@@ -13,12 +13,9 @@
  * ******************************************************************/
 package org.aspectj.weaver;
 
-import java.io.DataInputStream;
-import java.io.IOException;
 import java.util.Collection;
 import java.util.Iterator;
 
-
 public interface Member {
 
 	public static final Member[] NONE = new Member[0];
@@ -88,15 +85,9 @@ public interface Member {
 
 	public UnresolvedType[] getExceptions(World world);
 
-	public boolean isProtected(World world);
-
-	public boolean isStatic(World world);
-
-	public boolean isStrict(World world);
-
-	public boolean isStatic();
+    public boolean isStatic();
 
-	public boolean isInterface();
+    public boolean isInterface();
 
 	public boolean isPrivate();
 
@@ -907,7 +907,8 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 		for (int i = 0; i < myParameterTypes.length; i++) {
 			UnresolvedType thisParameter = myParameterTypes[i];
 			if (thisParameter.isTypeVariableReference()) {
-				sig.append(thisParameter.getUpperBound().getSignature());
+                TypeVariableReferenceType typeVariableRT = (TypeVariableReferenceType) thisParameter;
+                sig.append(typeVariableRT.getUpperBound().getSignature());
 			} else {
 				sig.append(thisParameter.getSignature());
 			}
@@ -920,12 +921,13 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 	// comparison.
 	public static void appendSigWithTypeVarBoundsRemoved(UnresolvedType aType, StringBuffer toBuffer, Set alreadyUsedTypeVars) {
 		if (aType.isTypeVariableReference()) {
+            TypeVariableReferenceType typeVariableRT = (TypeVariableReferenceType) aType;
 			// pr204505
 		    if (alreadyUsedTypeVars.contains(aType)) {
                 toBuffer.append("...");
             } else {
                 alreadyUsedTypeVars.add(aType);
-                appendSigWithTypeVarBoundsRemoved(aType.getUpperBound(), toBuffer, alreadyUsedTypeVars);
+                appendSigWithTypeVarBoundsRemoved(typeVariableRT.getUpperBound(), toBuffer, alreadyUsedTypeVars);
             }
 //			toBuffer.append("T;");
 		} else if (aType.isParameterizedType()) {
@@ -94,7 +94,7 @@ import org.aspectj.weaver.tools.Traceable;
  * The wildcard ? extends Foo has signature +LFoo;
  * The wildcard ? super Foo has signature -LFoo;
  */
-public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
+public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclaringElement {
 
 	// common types referred to by the weaver
     public static final UnresolvedType[] NONE         = new UnresolvedType[0];
@@ -149,21 +149,6 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 	 */
 	protected TypeVariable[] typeVariables;
 
-	/**
-	 * Iff isGenericWildcard, then this is the upper bound type for ? extends Foo
-	 */
-	private UnresolvedType upperBound;
-	
-	/**
-	 * Iff isGenericWildcard, then this is the lower bound type for ? super Foo
-	 */
-	private UnresolvedType lowerBound;
-	
-	/**
-	 * for wildcards '? extends' or for type variables 'T extends'
-	 */
-	private boolean isSuper   = false;
-	private boolean isExtends = false;
 
    /**
      * Determines if this represents a primitive type.  A primitive type
@@ -188,12 +173,12 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
     public boolean isParameterizedType()      { return typeKind == TypeKind.PARAMETERIZED; }
     public boolean isTypeVariableReference()  { return typeKind == TypeKind.TYPE_VARIABLE; }
     public boolean isGenericWildcard()        { return typeKind == TypeKind.WILDCARD; }
-    public boolean isExtends() { return isExtends;}
-    public boolean isSuper()   { return isSuper;  }
     public TypeKind getTypekind() { return typeKind;}
 
     // for any reference type, we can get some extra information...
-    public final boolean isArray() {  return signature.startsWith("["); } 
+    public final boolean isArray() {
+        return signature.length() > 0 && signature.charAt(0) == '[';
+    } 
 
     /** 
      * Equality is checked based on the underlying signature.
@@ -254,15 +239,11 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
         super();
         this.signature = signature;
         this.signatureErasure = signature;
-        if (signature.charAt(0)=='-') isSuper   = true;
-        if (signature.charAt(0)=='+') isExtends = true;
     }
 
     protected UnresolvedType(String signature, String signatureErasure) {
     	this.signature = signature;
     	this.signatureErasure = signatureErasure;
-        if (signature.charAt(0)=='-') isSuper   = true;
-        if (signature.charAt(0)=='+') isExtends = true;
     }
 
     // called from TypeFactory
@@ -313,7 +294,6 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
     public static UnresolvedType forName(String name) {
         return forSignature(nameToSignature(name));
     }
-	
 
     /** Constructs a UnresolvedType for each java language type name in an incoming array.
      * 
@@ -579,35 +559,7 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 		return UnresolvedType.forSignature(getErasureSignature());
 	}
 
-	/**
-	 * Get the upper bound for a generic wildcard
-	 */
-	public UnresolvedType getUpperBound() {
-		return upperBound;
-	}
 
-	/**
-	 * Get the lower bound for a generic wildcard
-	 */
-	public UnresolvedType getLowerBound() {
-		return lowerBound;
-	}
-	
-	/**
-	 * Set the upper bound for a generic wildcard
-	 */
-	public void setUpperBound(UnresolvedType aBound) {
-		this.upperBound = aBound;
-	}
-	
-	/**
-	 * Set the lower bound for a generic wildcard
-	 */
-	public void setLowerBound(UnresolvedType aBound) {
-		this.lowerBound = aBound;
-	}
-
- 	
     /**
      * Returns a UnresolvedType object representing the effective outermost enclosing type
      * for a name type.  For all other types, this will return the type itself.
@@ -14,8 +14,6 @@ package org.aspectj.weaver;
 import java.util.ArrayList;
 import java.util.List;
 
-import org.aspectj.weaver.UnresolvedType.TypeKind;
-
 /**
  * @author colyer
  *
@@ -135,27 +133,18 @@ public class TypeFactory {
 				return new UnresolvedType(signature,signatureErasure,typeParams);
 			}
 			// can't replace above with convertSigToType - leads to stackoverflow
-		} else if (signature.equals("?")){
-			UnresolvedType ret = UnresolvedType.SOMETHING;
-			ret.typeKind = TypeKind.WILDCARD;
-			return ret;
+		} else if (signature.equals("?") || signature.equals("*")) {
+		    return WildcardedUnresolvedType.QUESTIONMARK;
 		} else if(firstChar=='+') { 
 			// ? extends ...
-			UnresolvedType ret = new UnresolvedType(signature);
-			ret.typeKind = TypeKind.WILDCARD;
-			
-//			UnresolvedType bound1 = UnresolvedType.forSignature(signature.substring(1));
-//			UnresolvedType bound2 = convertSigToType(signature.substring(1));
-			ret.setUpperBound(convertSigToType(signature.substring(1)));
-			return ret;
+		    UnresolvedType upperBound = convertSigToType(signature.substring(1));
+            WildcardedUnresolvedType wildcardedUT = new WildcardedUnresolvedType(signature, upperBound, null);
+			return wildcardedUT;
 		} else if (firstChar=='-') { 
 			// ? super ...
-//			UnresolvedType bound = UnresolvedType.forSignature(signature.substring(1));
-//			UnresolvedType bound2 = convertSigToType(signature.substring(1));
-			UnresolvedType ret = new UnresolvedType(signature);
-			ret.typeKind = TypeKind.WILDCARD;
-			ret.setLowerBound(convertSigToType(signature.substring(1)));
-			return ret;
+		    UnresolvedType lowerBound = convertSigToType(signature.substring(1));
+            WildcardedUnresolvedType wildcardedUT = new WildcardedUnresolvedType(signature, null, lowerBound);
+            return wildcardedUT;
 		} else if (firstChar=='T') {
 			String typeVariableName = signature.substring(1);
 			if (typeVariableName.endsWith(";")) {
@@ -44,7 +44,7 @@ import org.aspectj.weaver.bcel.BcelAdvice;
 public abstract class Shadow {
 
 	// every Shadow has a unique id, doesn't matter if it wraps...
-	private static int nextShadowID = 100;  // easier to spot than zero.
+	private static int nextShadowID = 100;  // easier to spot than zero. // OPTIMIZE is this a bug? static?
 
 	private final Kind kind; 
     private final Member signature;
@@ -117,6 +117,8 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
     public static final UnresolvedType   AT_TARGET = forSignature("Ljava/lang/annotation/Target;");
     public static final UnresolvedType   SOMETHING = new UnresolvedType("?");
     public static final UnresolvedType[] ARRAY_WITH_JUST_OBJECT = new UnresolvedType[]{OBJECT};
+    public static final UnresolvedType JOINPOINT_STATICPART = forSignature("Lorg/aspectj/lang/JoinPoint$StaticPart;");
+    public static final UnresolvedType JOINPOINT_ENCLOSINGSTATICPART = forSignature("Lorg/aspectj/lang/JoinPoint$EnclosingStaticPart;");
 
     // this doesn't belong here and will get moved to ResolvedType later in the refactoring
 	public static final String MISSING_NAME = "@missing@";
@@ -36,7 +36,7 @@ public class MoveInstructionsWeaveTestCase extends WeaveTestCase {
 				BcelShadow shadow = (BcelShadow) s;
 				LazyMethodGen newMethod =
 					shadow.extractMethod(
-						shadow.getSignature().getExtractableName() + "_extracted",
+						NameMangler.getExtractableName(shadow.getSignature()) + "_extracted",
 						0,
 						this);
 				shadow.getRange().append(shadow.makeCallToCallback(newMethod));
@@ -60,7 +60,7 @@ public class MoveInstructionsWeaveTestCase extends WeaveTestCase {
             }
             public void implementOn(Shadow s) {
                 BcelShadow shadow = (BcelShadow) s;
-                LazyMethodGen newMethod = shadow.extractMethod(shadow.getSignature().getExtractableName() + "_extracted" + counter++, 0, this);
+                LazyMethodGen newMethod = shadow.extractMethod(NameMangler.getExtractableName(shadow.getSignature()) + "_extracted" + counter++, 0, this);
                 shadow.getRange().append(shadow.makeCallToCallback(newMethod));
 
                 if (! shadow.isFallsThrough()) {
Binary files differ
Binary files differ
Binary files differ
Binary files differ
@@ -64,14 +64,13 @@ import java.util.List;
 /** 
  * Abstract super class for fields and methods.
  *
- * @version $Id: FieldOrMethod.java,v 1.6 2008/05/28 23:53:01 aclement Exp $
+ * @version $Id: FieldOrMethod.java,v 1.7 2008/06/06 04:24:20 aclement Exp $
  * @author  <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
  */
 public abstract class FieldOrMethod extends Modifiers implements Cloneable, Node {
   protected int           nameIndex;      
   protected int           signatureIndex;
   protected Attribute[] attributes;
-   protected int          attributes_count;// No. of attributes
 
   protected ConstantPool  cpool;
   private String  name; // lazily initialized
@@ -111,7 +110,6 @@ public abstract class FieldOrMethod extends Modifiers implements Cloneable, Node
    */
   public void setAttributes(Attribute[] attributes) {
     this.attributes  = attributes;
-    attributes_count = (attributes == null)? 0 : attributes.length;
   }
 
 
@@ -65,7 +65,7 @@ import org.aspectj.apache.bcel.classfile.Utility;
  * Abstract super class for all possible java types, namely basic types
  * such as int, object types like String and array types, e.g. int[]
  *
- * @version $Id: Type.java,v 1.8 2008/05/28 23:52:56 aclement Exp $
+ * @version $Id: Type.java,v 1.9 2008/06/06 04:24:20 aclement Exp $
  * @author  <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
  * 
  * modified:
@@ -92,7 +92,12 @@ public abstract class Type implements java.io.Serializable {
   public static final Type[]        NO_ARGS      = new Type[0];
   public static final ReferenceType NULL         = new ReferenceType(){};
   public static final Type          UNKNOWN      = new Type(Constants.T_UNKNOWN,"<unknown object>"){};
-
+  public static final Type[]        STRINGARRAY1 = new Type[]{STRING};
+  public static final Type[]        STRINGARRAY2 = new Type[]{STRING,STRING};
+  public static final Type[]        STRINGARRAY3 = new Type[]{STRING,STRING,STRING};
+  public static final Type[]        STRINGARRAY4 = new Type[]{STRING,STRING,STRING,STRING};
+  public static final Type[]        STRINGARRAY5 = new Type[]{STRING,STRING,STRING,STRING,STRING};
+  
   protected Type(byte t, String s) {
     type      = t;
     signature = s;
@@ -363,9 +363,18 @@ public class NameMangler {
 
 	public static String aroundCallbackMethodName(Member shadowSig, LazyClassGen enclosingType) {
 		StringBuffer ret = new StringBuffer();
-		ret.append(shadowSig.getExtractableName()).append("_aroundBody").append(enclosingType.getNewGeneratedNameTag());
+		ret.append(getExtractableName(shadowSig)).append("_aroundBody").append(enclosingType.getNewGeneratedNameTag());
 		return ret.toString();
 	}
+	
+	 public static String getExtractableName(Member shadowSignature) {
+		String name = shadowSignature.getName();
+		MemberKind kind = shadowSignature.getKind();
+    	if (kind==Member.CONSTRUCTOR) return "init$";
+    	else if (kind==Member.STATIC_INITIALIZATION) return "clinit$";
+    	else return name;
+    }
+
 
 	public static String proceedMethodName(String adviceMethodName) {
 		return adviceMethodName + "proceed";
@@ -491,6 +491,7 @@ public abstract class World implements Dump.INode {
      * any other type, but if they are not found it is more serious and we issue an
      * error message immediately.
      */
+    // OPTIMIZE streamline path for core types? They are just simple types, could look straight in the typemap?
     public ResolvedType getCoreType(UnresolvedType tx) {
     	ResolvedType coreTy = resolve(tx,true);
     	if (coreTy.isMissing()) {
@@ -28,6 +28,7 @@ import org.aspectj.weaver.MemberImpl;
 import org.aspectj.weaver.NameMangler;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.Shadow;
+import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.WeaverMessages;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.ast.Expr;
@@ -134,10 +135,10 @@ public class ConcreteCflowPointcut extends Pointcut {
 	}
 
 	private static final Member cflowStackIsValidMethod = 
-		MemberImpl.method(NameMangler.CFLOW_STACK_UNRESOLVEDTYPE, 0, "isValid", "()Z");
+		MemberImpl.method(NameMangler.CFLOW_STACK_UNRESOLVEDTYPE, 0, ResolvedType.BOOLEAN,"isValid", UnresolvedType.NONE);
 
 	private static final Member cflowCounterIsValidMethod = 
-		MemberImpl.method(NameMangler.CFLOW_COUNTER_UNRESOLVEDTYPE, 0, "isValid", "()Z");
+		MemberImpl.method(NameMangler.CFLOW_COUNTER_UNRESOLVEDTYPE, 0,ResolvedType.BOOLEAN, "isValid", UnresolvedType.NONE);
 
 
 	public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, IntMap bindings) {
@@ -23,6 +23,7 @@ import org.aspectj.apache.bcel.generic.Type;
 import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.Member;
 import org.aspectj.weaver.MemberImpl;
+import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.ast.And;
 import org.aspectj.weaver.ast.Call;
@@ -188,15 +189,14 @@ public final class BcelRenderer implements ITestVisitor, IExprVisitor {
         // ldc_w annotationClass
         // invokevirtual java/lang/Class.isAnnotationPresent:(Ljava/lang/Class;)Z
         InstructionList il = new InstructionList();
-        Member getClass = MemberImpl.method(UnresolvedType.OBJECT, 0, "getClass", "()Ljava/lang/Class;");
+        Member getClass = MemberImpl.method(UnresolvedType.OBJECT, 0, UnresolvedType.JAVA_LANG_CLASS,"getClass", UnresolvedType.NONE);
         il.append(Utility.createInvoke(fact, world, getClass));
         // aload annotationClass
         String s = hasAnnotation.getAnnotationType().getName();
         il.append(fact.createConstant(new ObjectType(hasAnnotation.getAnnotationType().getName())));
 //        int annClassIndex = fact.getConstantPool().addClass(hasAnnotation.getAnnotationType().getSignature());
 //        il.append(new LDC_W(annClassIndex));
-        Member isAnnotationPresent = MemberImpl.method(UnresolvedType.forName("java/lang/Class"),0,
-                "isAnnotationPresent","(Ljava/lang/Class;)Z");
+        Member isAnnotationPresent = MemberImpl.method(UnresolvedType.JAVA_LANG_CLASS,0,ResolvedType.BOOLEAN,"isAnnotationPresent",new UnresolvedType[]{UnresolvedType.JAVA_LANG_CLASS});
         il.append(Utility.createInvoke(fact,world,isAnnotationPresent));
         il.append(createJumpBasedOnBooleanOnStack());
         instructions.insert(il);
@@ -0,0 +1,246 @@
+/* *******************************************************************
+ * Copyright (c) 2008 Contributors
+ * 
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *   Andy Clement - refactored out of MemberImpl
+ * ******************************************************************/
+package org.aspectj.weaver;
+
+import java.lang.reflect.Modifier;
+
+public class SignatureUtils {
+
+	public static String getSignatureString(Member m, World world) {		
+    	MemberKind kind = m.getKind();
+    	if (kind == Member.METHOD) {
+    		return getMethodSignatureString(m,world);
+    	} else if (kind == Member.CONSTRUCTOR) {
+    		return getConstructorSignatureString(m,world);
+    	} else if (kind == Member.FIELD) {
+    		return getFieldSignatureString(m,world);
+    	} else if (kind == Member.HANDLER) {
+    		return getHandlerSignatureString(m,world);
+    	} else if (kind == Member.STATIC_INITIALIZATION) {
+    		return getStaticInitializationSignatureString(m,world);
+    	} else if (kind == Member.ADVICE) {
+    		return getAdviceSignatureString(m,world);
+    	} else if (kind == Member.MONITORENTER || kind == Member.MONITOREXIT) {
+    		return getMonitorSignatureString(m,world);
+    	} else {
+    		throw new BCException("Do not know the signature string for MemberKind "+kind);
+    	}
+    }
+
+    public static String getSignatureMakerName(Member m) {
+    	MemberKind kind = m.getKind();
+    	if (kind == Member.METHOD) {
+    		return "makeMethodSig";
+    	} else if (kind == Member.CONSTRUCTOR) {
+    		return "makeConstructorSig";
+    	} else if (kind == Member.FIELD) {
+    		return "makeFieldSig";
+    	} else if (kind == Member.HANDLER) {
+    		return "makeCatchClauseSig";
+    	} else if (kind == Member.STATIC_INITIALIZATION) {
+    		return "makeInitializerSig";
+    	} else if (kind == Member.ADVICE) {
+    		return "makeAdviceSig";
+    	} else if (kind == Member.MONITORENTER) {
+    		return "makeLockSig";
+    	} else if (kind == Member.MONITOREXIT) {
+    		return "makeUnlockSig";
+    	} else {
+    		throw new BCException("Do not know the signature maker name for MemberKind "+kind);
+    	}
+    }
+
+	public static String getSignatureType(Member m) {
+    	MemberKind kind = m.getKind();
+    	if (m.getName().equals("<clinit>") && kind!=Member.STATIC_INITIALIZATION) throw new BCException();
+//    	if (m.getName().equals("<clinit>")) return "org.aspectj.lang.reflect.InitializerSignature";
+    	
+    	if (kind == Member.METHOD) {
+    		return "org.aspectj.lang.reflect.MethodSignature";
+    	} else if (kind == Member.CONSTRUCTOR) {
+    		return "org.aspectj.lang.reflect.ConstructorSignature";
+    	} else if (kind == Member.FIELD) {
+    		return "org.aspectj.lang.reflect.FieldSignature";
+    	} else if (kind == Member.HANDLER) {
+    		return "org.aspectj.lang.reflect.CatchClauseSignature";
+    	} else if (kind == Member.STATIC_INITIALIZATION) {
+    		return "org.aspectj.lang.reflect.InitializerSignature";
+    	} else if (kind == Member.ADVICE) {
+    		return "org.aspectj.lang.reflect.AdviceSignature";
+    	} else if (kind == Member.MONITORENTER) {
+    		return "org.aspectj.lang.reflect.LockSignature";
+    	} else if (kind == Member.MONITOREXIT) {
+    		return "org.aspectj.lang.reflect.UnlockSignature";
+    	} else {
+    		throw new BCException("Do not know the signature type for MemberKind "+kind);
+    	}
+    }
+
+    
+    // ---
+	
+
+	private static String getHandlerSignatureString(Member m, World world) {
+        StringBuffer buf = new StringBuffer();
+        buf.append(makeString(0));
+        buf.append('-');
+        //buf.append(getName());
+        buf.append('-');
+        buf.append(makeString(m.getDeclaringType()));
+        buf.append('-');
+        buf.append(makeString(m.getParameterTypes()[0]));
+        buf.append('-');
+        String pName = "<missing>";
+        String[] names = m.getParameterNames(world);
+        if (names != null) pName = names[0];
+        buf.append(pName);
+        buf.append('-');
+        return buf.toString();
+	}
+	
+	private static String getStaticInitializationSignatureString(Member m, World world) {
+        StringBuffer buf = new StringBuffer();
+        buf.append(makeString(m.getModifiers(world)));
+        buf.append('-');
+        //buf.append(getName());
+        buf.append('-');
+        buf.append(makeString(m.getDeclaringType()));
+        buf.append('-');
+        return buf.toString();
+	}
+
+	protected static String getAdviceSignatureString(Member m, World world) {
+        StringBuffer buf = new StringBuffer();
+        buf.append(makeString(m.getModifiers(world)));
+        buf.append('-');
+        buf.append(m.getName());
+        buf.append('-');
+        buf.append(makeString(m.getDeclaringType()));
+        buf.append('-');
+        buf.append(makeString(m.getParameterTypes()));
+        buf.append('-');
+        buf.append(makeString(m.getParameterNames(world)));
+        buf.append('-');
+        buf.append(makeString(m.getExceptions(world)));
+        buf.append('-');
+        buf.append(makeString(m.getReturnType()));
+        buf.append('-');
+        return buf.toString();
+	}
+
+
+	protected static String getMethodSignatureString(Member m, World world) {
+        StringBuffer buf = new StringBuffer();
+        buf.append(makeString(m.getModifiers(world)));
+        buf.append('-');
+        buf.append(m.getName());
+        buf.append('-');
+        buf.append(makeString(m.getDeclaringType()));
+        buf.append('-');
+        buf.append(makeString(m.getParameterTypes()));
+        buf.append('-');
+        buf.append(makeString(m.getParameterNames(world)));
+        buf.append('-');
+        buf.append(makeString(m.getExceptions(world)));
+        buf.append('-');
+        buf.append(makeString(m.getReturnType()));
+        buf.append('-');
+        return buf.toString();
+	}
+	
+	protected static String getMonitorSignatureString(Member m, World world) {
+        StringBuffer buf = new StringBuffer();
+        buf.append(makeString(Modifier.STATIC));    // modifiers
+        buf.append('-');
+        buf.append(m.getName());                      // name
+        buf.append('-');
+        buf.append(makeString(m.getDeclaringType())); // Declaring Type
+        buf.append('-');
+        buf.append(makeString(m.getParameterTypes()[0])); // Parameter Types
+        buf.append('-');
+        buf.append("");                                 // Parameter names
+        buf.append('-');
+        return buf.toString();
+	}
+
+	protected static String getConstructorSignatureString(Member m, World world) {
+        StringBuffer buf = new StringBuffer();
+        buf.append(makeString(m.getModifiers(world)));
+        buf.append('-');
+        buf.append('-');
+        buf.append(makeString(m.getDeclaringType()));
+        buf.append('-');
+        buf.append(makeString(m.getParameterTypes()));
+        buf.append('-');
+        buf.append(makeString(m.getParameterNames(world)));
+        buf.append('-');
+        buf.append(makeString(m.getExceptions(world)));
+        buf.append('-');
+        return buf.toString();
+    }
+	
+	
+
+
+	protected static String getFieldSignatureString(Member m, World world) {
+        StringBuffer buf = new StringBuffer();
+        buf.append(makeString(m.getModifiers(world)));
+        buf.append('-');
+        buf.append(m.getName());
+        buf.append('-');
+        buf.append(makeString(m.getDeclaringType()));
+        buf.append('-');
+        buf.append(makeString(m.getReturnType()));
+        buf.append('-');
+        return buf.toString();
+    }
+
+	protected static String makeString(int i) {
+		return Integer.toString(i, 16);
+	}
+
+	protected static String makeString(UnresolvedType t) {
+    	// this is the inverse of the odd behavior for Class.forName w/ arrays
+    	if (t.isArray()) {
+    		// this behavior matches the string used by the eclipse compiler for Foo.class literals
+    		return t.getSignature().replace('/', '.');
+    	} else {
+    		return t.getName();
+    	}
+    }
+    
+
+
+	protected static String makeString(UnresolvedType[] types) {
+    	if (types == null) return "";
+        StringBuffer buf = new StringBuffer();
+        for (int i = 0, len=types.length; i < len; i++) {
+            buf.append(makeString(types[i]));
+            buf.append(':');
+        }
+        return buf.toString();
+    }
+    
+
+
+	protected static String makeString(String[] names) {
+    	if (names == null) return "";
+        StringBuffer buf = new StringBuffer();
+        for (int i = 0, len=names.length; i < len; i++) {
+            buf.append(names[i]);
+            buf.append(':');
+        }
+        return buf.toString();
+    }
+
+}
@@ -13,17 +13,12 @@
 package org.aspectj.weaver;
 
 import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Iterator;
 import java.util.List;
 
 import org.aspectj.apache.bcel.classfile.GenericSignatureParser;
 import org.aspectj.apache.bcel.classfile.Signature;
 import org.aspectj.apache.bcel.classfile.Signature.ClassSignature;
 import org.aspectj.bridge.ISourceLocation;
-import org.aspectj.weaver.patterns.Declare;
 
 public abstract class AbstractReferenceTypeDelegate implements ReferenceTypeDelegate {
 
@@ -43,8 +38,6 @@ public abstract class AbstractReferenceTypeDelegate implements ReferenceTypeDele
 	public final boolean isClass() {
     	return !isAspect() && !isInterface();
     }
-	
-	
 
 	/**
 	 * Designed to be overriden by EclipseType to disable collection of shadow mungers
@@ -62,187 +55,7 @@ public abstract class AbstractReferenceTypeDelegate implements ReferenceTypeDele
 		return resolvedTypeX;
 	}
 
-    /**
-     * Create the string representation for a delegate, allowing us to 
-     * more easily compare delegate implementations.
-     */
-    public String stringifyDelegate() {
-    	
-    	StringBuffer result = new StringBuffer();
-    	result.append("=== Delegate for "+getResolvedTypeX().getName()+"\n");
-    	
-    	result.append("isAspect?"+isAspect()+"\n");
-    	result.append("isAnnotationStyleAspect?"+isAnnotationStyleAspect()+"\n");
-    	result.append("isInterface?"+isInterface()+"\n");
-    	result.append("isEnum?"+isEnum()+"\n");
-    	result.append("isClass?"+isClass()+"\n");
-    	result.append("-\n");
-    	result.append("isAnnotation?"+isAnnotation()+"\n");
-    	result.append("retentionPolicy="+getRetentionPolicy()+"\n");
-    	result.append("canAnnotationTargetType?"+canAnnotationTargetType()+"\n");
-    	AnnotationTargetKind[] kinds = getAnnotationTargetKinds();
-    	if (kinds!=null && kinds.length>0) {
-    		result.append("annotationTargetKinds:[");
-    		for (int i = 0; i < kinds.length; i++) {
-				AnnotationTargetKind kind = kinds[i];
-				result.append(kind);
-				if ((i+1)<kinds.length) result.append(" ");
-			}
-    		result.append("]\n");
-    	}
-    	result.append("isAnnotationWithRuntimeRetention?"+isAnnotationWithRuntimeRetention()+"\n");
-    	result.append("-\n");
-    	
-    	result.append("isAnonymous?"+isAnonymous()+"\n");
-    	result.append("isNested?"+isNested()+"\n");
-    	result.append("-\n");
-
-    	result.append("isGeneric?"+isGeneric()+"\n");
-    	result.append("declaredGenericSignature="+getDeclaredGenericSignature()+"\n");
-    	result.append("-\n");
-    	
-    	AnnotationX[] axs = getAnnotations();
-    	if (axs!=null && axs.length>0) {
-    		result.append("getAnnotations() returns: "+axs.length+" annotations\n");
-    		for (int i = 0; i < axs.length; i++) {
-				AnnotationX annotationX = axs[i];
-				result.append("  #"+i+") "+annotationX+"\n");
-    		}
-		} else {
-			result.append("getAnnotations() returns nothing\n");
-		}
-    	ResolvedType[] axtypes = getAnnotationTypes();
-    	if (axtypes!=null && axtypes.length>0) {
-    		result.append("getAnnotationTypes() returns: "+axtypes.length+" annotations\n");
-    		for (int i = 0; i < axtypes.length; i++) {
-				ResolvedType annotation = axtypes[i];
-				result.append("  #"+i+") "+annotation+":"+annotation.getClass()+"\n");
-			}
-    	} else {
-			result.append("getAnnotationTypes() returns nothing\n");
-		}
-    	
-    	result.append("isExposedToWeaver?"+isExposedToWeaver()+"\n");
-    	result.append("getSuperclass?"+getSuperclass()+"\n");
-    	result.append("getResolvedTypeX?"+getResolvedTypeX()+"\n");
-    	result.append("--\n");
-    	
-    	ResolvedMember[] fields = getDeclaredFields();
-    	if (fields!=null && fields.length>0) {
-        	result.append("The fields: "+fields.length+"\n");
-    		for (int i = 0; i < fields.length; i++) {
-				ResolvedMember member = fields[i];
-				result.append("f"+i+") "+member.toDebugString()+"\n");
-			}
-    	}
-    	ResolvedMember[] methods = getDeclaredMethods();
-    	if (methods!=null && methods.length>0) {
-        	result.append("The methods: "+methods.length+"\n");
-    		for (int i = 0; i < methods.length; i++) {
-				ResolvedMember member = methods[i];
-				result.append("m"+i+") "+member.toDebugString()+"\n");
-			}
-    	}
-    	ResolvedType[] interfaces = getDeclaredInterfaces();
-    	if (interfaces!=null && interfaces.length>0) {
-        	result.append("The interfaces: "+interfaces.length+"\n");
-    		for (int i = 0; i < interfaces.length; i++) {
-    			ResolvedType member = interfaces[i];
-				result.append("i"+i+") "+member+"\n");
-			}
-    	}
-
-    	result.append("getModifiers?"+getModifiers()+"\n");
-    	
-    	result.append("perclause="+getPerClause()+"\n");
-    	
-    	result.append("aj:weaverstate="+getWeaverState()+"\n");
-    	
-    	ResolvedMember[] pointcuts = getDeclaredPointcuts();
-    	if (pointcuts!=null && pointcuts.length>0) {
-    		result.append("The pointcuts: "+pointcuts.length+"\n");
-    		
-    		// Sort the damn things
-        	List sortedSetOfPointcuts = new ArrayList();
-        	for (int i = 0; i < pointcuts.length; i++) {sortedSetOfPointcuts.add(pointcuts[i]);}
-        	Collections.sort(sortedSetOfPointcuts);
-        	
-        	int i =0;
-        	for (Iterator iter = sortedSetOfPointcuts.iterator(); iter.hasNext();) {
-				ResolvedMember member = (ResolvedMember) iter.next();
-				result.append("p"+i+") "+member.toDebugString()+"\n");
-				i++;
-			}
-    	}
-    	
-    	Collection declares = getDeclares();
-    	if (declares.size()>0) {
-    		result.append("The declares: "+declares.size()+"\n");
-    		
-//    		// Sort the damn things
-//        	List sortedSetOfPointcuts = new ArrayList();
-//        	for (int i = 0; i < pointcuts.length; i++) {sortedSetOfPointcuts.add(pointcuts[i]);}
-//        	Collections.sort(sortedSetOfPointcuts);
-        	
-        	int i=0;
-        	for (Iterator iter = declares.iterator(); iter.hasNext();) {
-				Declare dec = (Declare) iter.next();
-				result.append("d"+i+") "+dec.toString()+"\n");
-				i++;
-			}
-    	}
-    	
-    	TypeVariable[] tv = getTypeVariables();
-    	if (tv!=null && tv.length>0) {
-        	result.append("The type variables: "+tv.length+"\n");
-    		for (int i = 0; i < tv.length; i++) {
-				result.append("tv"+i+") "+tv[i]+"\n");
-			}
-    	}
-    	
-    	Collection tmungers = getTypeMungers();
-    	if (tmungers.size()>0) {
-    		List sorted = new ArrayList();
-    		sorted.addAll(tmungers);
-    		Collections.sort(sorted,new Comparator() {
-    			public int compare(Object arg0, Object arg1) {
-    				 return arg0.toString().compareTo(arg1.toString());
-    			}
-    		});
-    		result.append("The type mungers: "+tmungers.size()+"\n");
-    		int i=0;
-        	for (Iterator iter = sorted.iterator(); iter.hasNext();) {
-				ConcreteTypeMunger mun = (ConcreteTypeMunger) iter.next();
-				result.append("tm"+i+") "+mun.toString()+"\n");
-				i++;
-			}
-    	}
-
-    	result.append("doesNotExposeShadowMungers?"+doesNotExposeShadowMungers()+"\n");
-    	
-    	Collection pas = getPrivilegedAccesses();
-    	if (pas!=null && pas.size()>0) {
-//    		List sorted = new ArrayList();
-//    		sorted.addAll(tmungers);
-//    		Collections.sort(sorted,new Comparator() {
-//    			public int compare(Object arg0, Object arg1) {
-//    				 return arg0.toString().compareTo(arg1.toString());
-//    			}
-//    		});
-    		result.append("The privileged accesses: "+pas.size()+"\n");
-    		int i=0;
-        	for (Iterator iter = pas.iterator(); iter.hasNext();) {
-				ResolvedMember mun = (ResolvedMember) iter.next();
-				result.append("tm"+i+") "+mun.toDebugString()+"\n");
-				i++;
-			}
-    	}
-
-//    	public Collection getPrivilegedAccesses();
-//      public boolean hasAnnotation(UnresolvedType ofType);	
-    	result.append("===");
-    	return result.toString();
-    }
+  
 
     public final String getSourcefilename() {
     	return sourcefilename;
@@ -72,8 +72,6 @@ public interface Member extends Comparable {
 	 */
 	public String getParameterSignature();
 
-	public boolean isCompatibleWith(Member am);
-
 	public int getModifiers(World world);
 
 	public int getModifiers();
@@ -386,30 +386,9 @@ public class MemberImpl implements Member {
     	return paramSignature;
     }
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#isCompatibleWith(org.aspectj.weaver.Member)
-	 */
-    public boolean isCompatibleWith(Member am) {
-        if (kind != METHOD || am.getKind() != METHOD) return true;
-        if (! name.equals(am.getName())) return true;
-        if (! equalTypes(getParameterTypes(), am.getParameterTypes())) return true;
-        return getReturnType().equals(am.getReturnType());
-    }
-    
-    private static boolean equalTypes(UnresolvedType[] a, UnresolvedType[] b) {
-        int len = a.length;
-        if (len != b.length) return false;
-        for (int i = 0; i < len; i++) {
-            if (!a[i].equals(b[i])) return false;
-        }
-        return true;
-    }
-    
+    // OPTIMIZE see next line. Why the hell are they in here if we only know it once resolution has occurred...
     // ---- things we know only with resolution
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getModifiers(org.aspectj.weaver.World)
-	 */
     public int getModifiers(World world) {
     	ResolvedMember resolved = resolve(world);
     	if (resolved == null) {
@@ -419,9 +398,6 @@ public class MemberImpl implements Member {
 		return resolved.getModifiers();
     }
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getExceptions(org.aspectj.weaver.World)
-	 */
     public UnresolvedType[] getExceptions(World world) {
     	ResolvedMember resolved = resolve(world);
     	if (resolved == null) {
@@ -34,10 +34,10 @@ public interface ResolvedMember extends Member, AnnotatedElement, TypeVariableDe
 
 	public ShadowMunger getAssociatedShadowMunger();
 
-	//OPTIMIZE have param annotation (and anno default value) related stuff here rather than above
-	// ??? true or false?
 	public boolean isAjSynthetic();
 
+	public boolean isCompatibleWith(Member am);
+	
 	public boolean hasAnnotations();
 
 	public boolean hasAnnotation(UnresolvedType ofType);
@@ -1031,7 +1031,22 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
     	return buf.toString();    	
     }
 
+   public boolean isCompatibleWith(Member am) {
+       if (kind != METHOD || am.getKind() != METHOD) return true;
+       if (! name.equals(am.getName())) return true;
+       if (! equalTypes(getParameterTypes(), am.getParameterTypes())) return true;
+       return getReturnType().equals(am.getReturnType());
+   }
 
+   private static boolean equalTypes(UnresolvedType[] a, UnresolvedType[] b) {
+       int len = a.length;
+       if (len != b.length) return false;
+       for (int i = 0; i < len; i++) {
+           if (!a[i].equals(b[i])) return false;
+       }
+       return true;
+   }
+   
 
 	public TypeVariable getTypeVariableNamed(String name) {
 		// Check locally...
@@ -838,6 +838,7 @@ public abstract class World implements Dump.INode {
 		return targetAspectjRuntimeLevel;
 	}
 
+	// OPTIMIZE are users falling foul of not supplying -1.5 and so targetting the old runtime?
 	public boolean isTargettingAspectJRuntime12() {
 		boolean b = false; // pr116679
 		if (!isInJava5Mode()) b=true;
@@ -53,26 +53,24 @@ import org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.GenericSigna
 
 public final class BcelMethod extends ResolvedMemberImpl {
 
-
 	private Method method;
+
+	// these fields are not set for many BcelMethods...
 	private ShadowMunger associatedShadowMunger;
 	private ResolvedPointcutDefinition preResolvedPointcut;  // used when ajc has pre-resolved the pointcut of some @Advice
+	private AjAttribute.EffectiveSignatureAttribute effectiveSignature;
+	
 
-//    private ResolvedType[] annotationTypes = null;
+	private AjAttribute.MethodDeclarationLineNumberAttribute declarationLineNumber;	
     private AnnotationX[] annotations = null;
     private AnnotationX[][] parameterAnnotations = null;
-	
-	private AjAttribute.EffectiveSignatureAttribute effectiveSignature;
-	private AjAttribute.MethodDeclarationLineNumberAttribute declarationLineNumber;
 	private BcelObjectType bcelObjectType;
 
-	private boolean parameterNamesInitialized = false;
-	
 	private int bitflags;
-	private static final int KNOW_IF_SYNTHETIC           = 0x0001;
-	private static final int PARAMETER_NAMES_INITIALIZED = 0x0002;
-	private static final int CAN_BE_PARAMETERIZED        = 0x0004;
-	private static final int UNPACKED_GENERIC_SIGNATURE  = 0x0008;
+	private static final int KNOW_IF_SYNTHETIC           = 0x0001; // used
+	private static final int PARAMETER_NAMES_INITIALIZED = 0x0002; // used
+	private static final int CAN_BE_PARAMETERIZED        = 0x0004; // used
+	private static final int UNPACKED_GENERIC_SIGNATURE  = 0x0008; // used
 	private static final int HAS_EFFECTIVE_SIGNATURE     = 0x0010;
 	private static final int HAS_PRERESOLVED_POINTCUT    = 0x0020;
 	private static final int IS_AJ_SYNTHETIC             = 0x0040;
@@ -80,14 +78,12 @@ public final class BcelMethod extends ResolvedMemberImpl {
 	private static final int IS_SYNTHETIC_INVERSE        = 0x7f7f; // all bits but IS_SYNTHETIC (and topmost bit)
 	private static final int HAS_ASSOCIATED_SHADOWMUNGER = 0x0100;
 	private static final int HAS_GENERIC_RETPARAM_TYPES  = 0x0200;
-	private static final int HAS_ANNOTATIONS             = 0x0400;
-	private static final int HAVE_DETERMINED_ANNOTATIONS = 0x0800;
+	private static final int HAS_ANNOTATIONS             = 0x0400; // used
+	private static final int HAVE_DETERMINED_ANNOTATIONS = 0x0800; // used
 	private static final int HAS_MD_LINE_NUMBER_ATTRIBUTE= 0x1000;
 
 
-	 private boolean canBeParameterized = false;
 	 // genericized version of return and parameter types
-	 private boolean unpackedGenericSignature = false;
 	 private UnresolvedType genericReturnType = null;
 	 private UnresolvedType[] genericParameterTypes = null;
 
@@ -132,8 +128,8 @@ public final class BcelMethod extends ResolvedMemberImpl {
     }
 
 	public void determineParameterNames() {
-		if (parameterNamesInitialized) return;
-		parameterNamesInitialized=true;
+		if ((bitflags&PARAMETER_NAMES_INITIALIZED)!=0) { return; }
+		bitflags|=PARAMETER_NAMES_INITIALIZED;
 		LocalVariableTable varTable = method.getLocalVariableTable();
 		int len = getArity();
 		if (varTable == null) {
@@ -431,7 +427,7 @@ public final class BcelMethod extends ResolvedMemberImpl {
 	  */
 	 public boolean canBeParameterized() {
 		 unpackGenericSignature();
-		return canBeParameterized;
+		return (bitflags & CAN_BE_PARAMETERIZED)!=0;
 	}
 
 
@@ -452,8 +448,8 @@ public final class BcelMethod extends ResolvedMemberImpl {
 	 public Method getMethod() { return method; }
 
 	 private void unpackGenericSignature() {
-		 if (unpackedGenericSignature) return;
-		 unpackedGenericSignature = true;
+		if ((bitflags&UNPACKED_GENERIC_SIGNATURE)!=0) { return; }
+		bitflags|=UNPACKED_GENERIC_SIGNATURE;
  		 if (!bcelObjectType.getWorld().isInJava5Mode()) { 
  			 this.genericReturnType = getReturnType();
  			 this.genericParameterTypes = getParameterTypes();
@@ -464,7 +460,7 @@ public final class BcelMethod extends ResolvedMemberImpl {
 			 Signature.MethodTypeSignature mSig = new GenericSignatureParser().parseAsMethodSignature(gSig);//method.getGenericSignature());
  			 if (mSig.formalTypeParameters.length > 0) {
 				// generic method declaration
-				canBeParameterized = true;
+				bitflags|=CAN_BE_PARAMETERIZED;
 			 }
 
  			typeVariables = new TypeVariable[mSig.formalTypeParameters.length];
@@ -517,7 +513,7 @@ public final class BcelMethod extends ResolvedMemberImpl {
 							+ e.getMessage());
 				}
 				if (paramTypeSigs[i] instanceof TypeVariableSignature) {
-					canBeParameterized = true;
+					bitflags|=CAN_BE_PARAMETERIZED;
 				}
 			 }
 		 } else {
@@ -549,10 +545,8 @@ public final class BcelMethod extends ResolvedMemberImpl {
 	private void workOutIfSynthetic() {
 		if ((bitflags&KNOW_IF_SYNTHETIC)!=0) return;
 		bitflags|=KNOW_IF_SYNTHETIC;
-//		knowIfSynthetic=true;
 		JavaClass jc = bcelObjectType.getJavaClass();
 	    bitflags&=IS_SYNTHETIC_INVERSE; // unset the bit
-//		isSynthetic=false;
 		if (jc==null) return; // what the hell has gone wrong?
 		if (jc.getMajor()<49/*Java5*/) {
 			// synthetic is an attribute
@@ -561,7 +555,6 @@ public final class BcelMethod extends ResolvedMemberImpl {
 				for (int i = 0; i < synthetics.length; i++) {
 					if (synthetics[i].equals("Synthetic")) {
 						bitflags|=IS_SYNTHETIC;
-//						isSynthetic=true;
 						break;}
 				}
 			}
@@ -570,7 +563,6 @@ public final class BcelMethod extends ResolvedMemberImpl {
 			if ((modifiers&4096)!=0) {
 				bitflags|=IS_SYNTHETIC;
 			}
-//			isSynthetic = (modifiers&4096)!=0;
 		}
 	}
 
@@ -24,6 +24,189 @@ import org.aspectj.weaver.patterns.SimpleScope;
 public class TestUtils {
     private static final String[] ZERO_STRINGS = new String[0];
 
+    // For stringifying a delegate - extracted from AbstractReferenceTypeDelegate, not fixed up
+//    /**
+//     * Create the string representation for a delegate, allowing us to 
+//     * more easily compare delegate implementations.
+//     */
+//    public String stringifyDelegate() {
+//    	
+//    	StringBuffer result = new StringBuffer();
+//    	result.append("=== Delegate for "+getResolvedTypeX().getName()+"\n");
+//    	
+//    	result.append("isAspect?"+isAspect()+"\n");
+//    	result.append("isAnnotationStyleAspect?"+isAnnotationStyleAspect()+"\n");
+//    	result.append("isInterface?"+isInterface()+"\n");
+//    	result.append("isEnum?"+isEnum()+"\n");
+//    	result.append("isClass?"+isClass()+"\n");
+//    	result.append("-\n");
+//    	result.append("isAnnotation?"+isAnnotation()+"\n");
+//    	result.append("retentionPolicy="+getRetentionPolicy()+"\n");
+//    	result.append("canAnnotationTargetType?"+canAnnotationTargetType()+"\n");
+//    	AnnotationTargetKind[] kinds = getAnnotationTargetKinds();
+//    	if (kinds!=null && kinds.length>0) {
+//    		result.append("annotationTargetKinds:[");
+//    		for (int i = 0; i < kinds.length; i++) {
+//				AnnotationTargetKind kind = kinds[i];
+//				result.append(kind);
+//				if ((i+1)<kinds.length) result.append(" ");
+//			}
+//    		result.append("]\n");
+//    	}
+//    	result.append("isAnnotationWithRuntimeRetention?"+isAnnotationWithRuntimeRetention()+"\n");
+//    	result.append("-\n");
+//    	
+//    	result.append("isAnonymous?"+isAnonymous()+"\n");
+//    	result.append("isNested?"+isNested()+"\n");
+//    	result.append("-\n");
+//
+//    	result.append("isGeneric?"+isGeneric()+"\n");
+//    	result.append("declaredGenericSignature="+getDeclaredGenericSignature()+"\n");
+//    	result.append("-\n");
+//    	
+//    	AnnotationX[] axs = getAnnotations();
+//    	if (axs!=null && axs.length>0) {
+//    		result.append("getAnnotations() returns: "+axs.length+" annotations\n");
+//    		for (int i = 0; i < axs.length; i++) {
+//				AnnotationX annotationX = axs[i];
+//				result.append("  #"+i+") "+annotationX+"\n");
+//    		}
+//		} else {
+//			result.append("getAnnotations() returns nothing\n");
+//		}
+//    	ResolvedType[] axtypes = getAnnotationTypes();
+//    	if (axtypes!=null && axtypes.length>0) {
+//    		result.append("getAnnotationTypes() returns: "+axtypes.length+" annotations\n");
+//    		for (int i = 0; i < axtypes.length; i++) {
+//				ResolvedType annotation = axtypes[i];
+//				result.append("  #"+i+") "+annotation+":"+annotation.getClass()+"\n");
+//			}
+//    	} else {
+//			result.append("getAnnotationTypes() returns nothing\n");
+//		}
+//    	
+//    	result.append("isExposedToWeaver?"+isExposedToWeaver()+"\n");
+//    	result.append("getSuperclass?"+getSuperclass()+"\n");
+//    	result.append("getResolvedTypeX?"+getResolvedTypeX()+"\n");
+//    	result.append("--\n");
+//    	
+//    	ResolvedMember[] fields = getDeclaredFields();
+//    	if (fields!=null && fields.length>0) {
+//        	result.append("The fields: "+fields.length+"\n");
+//    		for (int i = 0; i < fields.length; i++) {
+//				ResolvedMember member = fields[i];
+//				result.append("f"+i+") "+member.toDebugString()+"\n");
+//			}
+//    	}
+//    	ResolvedMember[] methods = getDeclaredMethods();
+//    	if (methods!=null && methods.length>0) {
+//        	result.append("The methods: "+methods.length+"\n");
+//    		for (int i = 0; i < methods.length; i++) {
+//				ResolvedMember member = methods[i];
+//				result.append("m"+i+") "+member.toDebugString()+"\n");
+//			}
+//    	}
+//    	ResolvedType[] interfaces = getDeclaredInterfaces();
+//    	if (interfaces!=null && interfaces.length>0) {
+//        	result.append("The interfaces: "+interfaces.length+"\n");
+//    		for (int i = 0; i < interfaces.length; i++) {
+//    			ResolvedType member = interfaces[i];
+//				result.append("i"+i+") "+member+"\n");
+//			}
+//    	}
+//
+//    	result.append("getModifiers?"+getModifiers()+"\n");
+//    	
+//    	result.append("perclause="+getPerClause()+"\n");
+//    	
+//    	result.append("aj:weaverstate="+getWeaverState()+"\n");
+//    	
+//    	ResolvedMember[] pointcuts = getDeclaredPointcuts();
+//    	if (pointcuts!=null && pointcuts.length>0) {
+//    		result.append("The pointcuts: "+pointcuts.length+"\n");
+//    		
+//    		// Sort the damn things
+//        	List sortedSetOfPointcuts = new ArrayList();
+//        	for (int i = 0; i < pointcuts.length; i++) {sortedSetOfPointcuts.add(pointcuts[i]);}
+//        	Collections.sort(sortedSetOfPointcuts);
+//        	
+//        	int i =0;
+//        	for (Iterator iter = sortedSetOfPointcuts.iterator(); iter.hasNext();) {
+//				ResolvedMember member = (ResolvedMember) iter.next();
+//				result.append("p"+i+") "+member.toDebugString()+"\n");
+//				i++;
+//			}
+//    	}
+//    	
+//    	Collection declares = getDeclares();
+//    	if (declares.size()>0) {
+//    		result.append("The declares: "+declares.size()+"\n");
+//    		
+////    		// Sort the damn things
+////        	List sortedSetOfPointcuts = new ArrayList();
+////        	for (int i = 0; i < pointcuts.length; i++) {sortedSetOfPointcuts.add(pointcuts[i]);}
+////        	Collections.sort(sortedSetOfPointcuts);
+//        	
+//        	int i=0;
+//        	for (Iterator iter = declares.iterator(); iter.hasNext();) {
+//				Declare dec = (Declare) iter.next();
+//				result.append("d"+i+") "+dec.toString()+"\n");
+//				i++;
+//			}
+//    	}
+//    	
+//    	TypeVariable[] tv = getTypeVariables();
+//    	if (tv!=null && tv.length>0) {
+//        	result.append("The type variables: "+tv.length+"\n");
+//    		for (int i = 0; i < tv.length; i++) {
+//				result.append("tv"+i+") "+tv[i]+"\n");
+//			}
+//    	}
+//    	
+//    	Collection tmungers = getTypeMungers();
+//    	if (tmungers.size()>0) {
+//    		List sorted = new ArrayList();
+//    		sorted.addAll(tmungers);
+//    		Collections.sort(sorted,new Comparator() {
+//    			public int compare(Object arg0, Object arg1) {
+//    				 return arg0.toString().compareTo(arg1.toString());
+//    			}
+//    		});
+//    		result.append("The type mungers: "+tmungers.size()+"\n");
+//    		int i=0;
+//        	for (Iterator iter = sorted.iterator(); iter.hasNext();) {
+//				ConcreteTypeMunger mun = (ConcreteTypeMunger) iter.next();
+//				result.append("tm"+i+") "+mun.toString()+"\n");
+//				i++;
+//			}
+//    	}
+//
+//    	result.append("doesNotExposeShadowMungers?"+doesNotExposeShadowMungers()+"\n");
+//    	
+//    	Collection pas = getPrivilegedAccesses();
+//    	if (pas!=null && pas.size()>0) {
+////    		List sorted = new ArrayList();
+////    		sorted.addAll(tmungers);
+////    		Collections.sort(sorted,new Comparator() {
+////    			public int compare(Object arg0, Object arg1) {
+////    				 return arg0.toString().compareTo(arg1.toString());
+////    			}
+////    		});
+//    		result.append("The privileged accesses: "+pas.size()+"\n");
+//    		int i=0;
+//        	for (Iterator iter = pas.iterator(); iter.hasNext();) {
+//				ResolvedMember mun = (ResolvedMember) iter.next();
+//				result.append("tm"+i+") "+mun.toDebugString()+"\n");
+//				i++;
+//			}
+//    	}
+//
+////    	public Collection getPrivilegedAccesses();
+////      public boolean hasAnnotation(UnresolvedType ofType);	
+//    	result.append("===");
+//    	return result.toString();
+//    }
+    
     /**
      * Build a member from a string representation:
      * <blockquote><pre>
@@ -1,6 +1,6 @@
 public class DynamicHelloWorld extends java.lang.Object implements java.io.Serializable:
   public void <init>():
-                    ALOAD_0     // DynamicHelloWorld this   (line 8)
+                    ALOAD_0     // LDynamicHelloWorld; this   (line 8)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void DynamicHelloWorld.<init>())
     |               RETURN
@@ -27,7 +27,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               DUP
     |               LDC "expected and caught: "
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ALOAD_1     // java.lang.UnsupportedOperationException t
+    |               ALOAD_1     // Ljava/lang/UnsupportedOperationException; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -48,8 +48,8 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
 
   String doit(String, java.util.List):
     method-execution(java.lang.String DynamicHelloWorld.doit(java.lang.String, java.util.List))
-    |               ALOAD_2     // java.util.List l   (line 21)
-    |               ALOAD_1     // java.lang.String s
+    |               ALOAD_2     // Ljava/util/List; l   (line 21)
+    |               ALOAD_1     // Ljava/lang/String; s
     |               ASTORE_3
     |               ASTORE 4
     | method-call(boolean java.util.List.add(java.lang.Object))
@@ -62,7 +62,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     | |             INVOKEINTERFACE java.util.List.add (Ljava/lang/Object;)Z
     | method-call(boolean java.util.List.add(java.lang.Object))
     |               POP
-    |               ALOAD_2     // java.util.List l   (line 22)
+    |               ALOAD_2     // Ljava/util/List; l   (line 22)
     | method-call(java.lang.String java.lang.Object.toString())
     | |             INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String;
     | method-call(java.lang.String java.lang.Object.toString())
@@ -1,6 +1,6 @@
 public class DynamicHelloWorld extends java.lang.Object implements java.io.Serializable:
   public void <init>():
-                    ALOAD_0     // DynamicHelloWorld this   (line 8)
+                    ALOAD_0     // LDynamicHelloWorld; this   (line 8)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void DynamicHelloWorld.<init>())
     |               RETURN
@@ -27,7 +27,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               DUP
     |               LDC "expected and caught: "
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ALOAD_1     // java.lang.UnsupportedOperationException t
+    |               ALOAD_1     // Ljava/lang/UnsupportedOperationException; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -48,8 +48,8 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
 
   String doit(String, java.util.List):
     method-execution(java.lang.String DynamicHelloWorld.doit(java.lang.String, java.util.List))
-    |               ALOAD_2     // java.util.List l   (line 21)
-    |               ALOAD_1     // java.lang.String s
+    |               ALOAD_2     // Ljava/util/List; l   (line 21)
+    |               ALOAD_1     // Ljava/lang/String; s
     |               ASTORE_3
     |               ASTORE 4
     | method-call(boolean java.util.List.add(java.lang.Object))
@@ -62,7 +62,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     | |             INVOKEINTERFACE java.util.List.add (Ljava/lang/Object;)Z
     | method-call(boolean java.util.List.add(java.lang.Object))
     |               POP
-    |               ALOAD_2     // java.util.List l   (line 22)
+    |               ALOAD_2     // Ljava/util/List; l   (line 22)
     | method-call(java.lang.String java.lang.Object.toString())
     | |             INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String;
     | method-call(java.lang.String java.lang.Object.toString())
@@ -1,6 +1,6 @@
 public class DynamicHelloWorld extends java.lang.Object implements java.io.Serializable:
   public void <init>():
-                    ALOAD_0     // DynamicHelloWorld this   (line 8)
+                    ALOAD_0     // LDynamicHelloWorld; this   (line 8)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void DynamicHelloWorld.<init>())
     |               RETURN
@@ -27,7 +27,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               DUP
     |               LDC "expected and caught: "
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ALOAD_1     // java.lang.UnsupportedOperationException t
+    |               ALOAD_1     // Ljava/lang/UnsupportedOperationException; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -48,8 +48,8 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
 
   String doit(String, java.util.List):
     method-execution(java.lang.String DynamicHelloWorld.doit(java.lang.String, java.util.List))
-    |               ALOAD_2     // java.util.List l   (line 21)
-    |               ALOAD_1     // java.lang.String s
+    |               ALOAD_2     // Ljava/util/List; l   (line 21)
+    |               ALOAD_1     // Ljava/lang/String; s
     |               ASTORE_3
     |               ASTORE 4
     | method-call(boolean java.util.List.add(java.lang.Object))
@@ -64,7 +64,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     | |             INVOKEINTERFACE java.util.List.add (Ljava/lang/Object;)Z
     | method-call(boolean java.util.List.add(java.lang.Object))
     |               POP
-    |               ALOAD_2     // java.util.List l   (line 22)
+    |               ALOAD_2     // Ljava/util/List; l   (line 22)
     | method-call(java.lang.String java.lang.Object.toString())
     | |             INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String;
     | method-call(java.lang.String java.lang.Object.toString())
@@ -1,14 +1,14 @@
 public abstract class FancyHelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // FancyHelloWorld this   (line 7)
+                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void FancyHelloWorld.<init>())
     |               INVOKESTATIC Aspect.ajc_before_constructor_execution ()V
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE_2
     |               ALOAD_2
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_0
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure3
@@ -26,11 +26,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     ASTORE 19
     method-execution(void FancyHelloWorld.main(java.lang.String[]))
     |               INVOKESTATIC Aspect.ajc_before_method_execution ()V   (line 9)
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 21
     |               ALOAD 21
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 19
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure23
@@ -46,7 +46,7 @@ public abstract class FancyHelloWorld extends java.lang.Object:
   public static String getName():
     method-execution(java.lang.String FancyHelloWorld.getName())
     |               INVOKESTATIC Aspect.ajc_before_method_execution ()V   (line 20)
-    |               BIPUSH 0
+    |               ICONST_0
     |               ANEWARRAY java.lang.Object
     |               ASTORE 15
     |               NEW FancyHelloWorld$AjcClosure43
@@ -65,11 +65,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void init$_aroundBody2(FancyHelloWorld):
                     INVOKESTATIC Aspect.ajc_before_constructor_execution ()V
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure1
@@ -88,7 +88,7 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final java.io.PrintStream out_aroundBody6():
                     INVOKESTATIC Aspect.ajc_before_field_get ()V
-                    BIPUSH 0
+                    ICONST_0
                     ANEWARRAY java.lang.Object
                     ASTORE_0
                     NEW FancyHelloWorld$AjcClosure5
@@ -109,15 +109,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void println_aroundBody10(java.io.PrintStream, String):
                     INVOKESTATIC Aspect.ajc_before_method_call ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure9
@@ -138,15 +138,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void println_aroundBody14(java.io.PrintStream, Object):
                     INVOKESTATIC Aspect.ajc_before_method_call ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure13
@@ -167,15 +167,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void println_aroundBody18(java.io.PrintStream, String):
                     INVOKESTATIC Aspect.ajc_before_method_call ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure17
@@ -190,7 +190,7 @@ public abstract class FancyHelloWorld extends java.lang.Object:
   static final void main_aroundBody20(String[]):
     field-get(java.io.PrintStream java.lang.System.out)
     |               INVOKESTATIC Aspect.ajc_before_field_get ()V
-    |               BIPUSH 0
+    |               ICONST_0
     |               ANEWARRAY java.lang.Object
     |               ASTORE_1
     |               NEW FancyHelloWorld$AjcClosure7
@@ -203,21 +203,21 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     ASTORE_3   (line 9)
     finally -> E1
     | catch java.lang.Exception -> E0
-    | |             ALOAD_3     // java.io.PrintStream out   (line 11)
+    | |             ALOAD_3     // Ljava/io/PrintStream; out   (line 11)
     | |             LDC "bye"
     | |             ASTORE 5
     | |             ASTORE 7
     | | method-call(void java.io.PrintStream.println(java.lang.String))
     | | |           INVOKESTATIC Aspect.ajc_before_method_call ()V
-    | | |           BIPUSH 2
+    | | |           ICONST_2
     | | |           ANEWARRAY java.lang.Object
     | | |           ASTORE 9
     | | |           ALOAD 9
-    | | |           BIPUSH 0
+    | | |           ICONST_0
     | | |           ALOAD 7
     | | |           AASTORE
     | | |           ALOAD 9
-    | | |           BIPUSH 1
+    | | |           ICONST_1
     | | |           ALOAD 5
     | | |           AASTORE
     | | |           NEW FancyHelloWorld$AjcClosure11
@@ -230,21 +230,21 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     | |             GOTO L0
     | catch java.lang.Exception -> E0
     |           E0: ASTORE 11   (line 12)
-    |               ALOAD_3     // java.io.PrintStream out   (line 13)
-    |               ALOAD 11     // java.lang.Exception e
+    |               ALOAD_3     // Ljava/io/PrintStream; out   (line 13)
+    |               ALOAD 11     // Ljava/lang/Exception; e
     |               ASTORE 13
     |               ASTORE 15
     | method-call(void java.io.PrintStream.println(java.lang.Object))
     | |             INVOKESTATIC Aspect.ajc_before_method_call ()V
-    | |             BIPUSH 2
+    | |             ICONST_2
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE 17
     | |             ALOAD 17
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD 15
     | |             AASTORE
     | |             ALOAD 17
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ALOAD 13
     | |             AASTORE
     | |             NEW FancyHelloWorld$AjcClosure15
@@ -263,21 +263,21 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                 L0: JSR L1
                     GOTO L2
                 L1: ASTORE 21
-                    ALOAD_3     // java.io.PrintStream out   (line 15)
+                    ALOAD_3     // Ljava/io/PrintStream; out   (line 15)
                     LDC "finally"
                     ASTORE 23
                     ASTORE 25
     method-call(void java.io.PrintStream.println(java.lang.String))
     |               INVOKESTATIC Aspect.ajc_before_method_call ()V
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE 27
     |               ALOAD 27
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 25
     |               AASTORE
     |               ALOAD 27
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD 23
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure19
@@ -293,11 +293,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void main_aroundBody22(String[]):
                     INVOKESTATIC Aspect.ajc_before_method_execution ()V   (line 9)
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure21
@@ -317,11 +317,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final int hashCode_aroundBody26(String):
                     INVOKESTATIC Aspect.ajc_before_method_call ()V
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure25
@@ -343,11 +343,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final StringBuffer init$_aroundBody30(String):
                     INVOKESTATIC Aspect.ajc_before_constructor_call ()V
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure29
@@ -368,15 +368,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final StringBuffer append_aroundBody34(StringBuffer, int):
                     INVOKESTATIC Aspect.ajc_before_method_call ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ILOAD_1
                     INVOKESTATIC org.aspectj.runtime.internal.Conversions.intObject (I)Ljava/lang/Object;
                     AASTORE
@@ -397,11 +397,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final String toString_aroundBody38(StringBuffer):
                     INVOKESTATIC Aspect.ajc_before_method_call ()V
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure37
@@ -416,16 +416,16 @@ public abstract class FancyHelloWorld extends java.lang.Object:
   static final String getName_aroundBody40():
                     ICONST_0   (line 20)
                     ISTORE_0
-                    ILOAD_0     // int x   (line 21)
+                    ILOAD_0     // I x   (line 21)
                     LDC "name"
                     ASTORE_2
     method-call(int java.lang.String.hashCode())
     |               INVOKESTATIC Aspect.ajc_before_method_call ()V
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 4
     |               ALOAD 4
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_2
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure27
@@ -436,16 +436,16 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     |               INVOKESTATIC org.aspectj.runtime.internal.Conversions.intValue (Ljava/lang/Object;)I
     method-call(int java.lang.String.hashCode())
                     IADD
-                    ISTORE_0     // int x
+                    ISTORE_0     // I x
                     LDC "name"   (line 22)
                     ASTORE 6
     constructor-call(void java.lang.StringBuffer.<init>(java.lang.String))
     |               INVOKESTATIC Aspect.ajc_before_constructor_call ()V
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 8
     |               ALOAD 8
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 6
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure31
@@ -455,20 +455,20 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     |               INVOKESTATIC Aspect.ajc_around (Lorg/aspectj/runtime/internal/AroundClosure;)Ljava/lang/Object;
     |               CHECKCAST java.lang.StringBuffer
     constructor-call(void java.lang.StringBuffer.<init>(java.lang.String))
-                    ILOAD_0     // int x
+                    ILOAD_0     // I x
                     ISTORE 10
                     ASTORE 12
     method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))
     |               INVOKESTATIC Aspect.ajc_before_method_call ()V
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE 14
     |               ALOAD 14
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 12
     |               AASTORE
     |               ALOAD 14
-    |               BIPUSH 1
+    |               ICONST_1
     |               ILOAD 10
     |               INVOKESTATIC org.aspectj.runtime.internal.Conversions.intObject (I)Ljava/lang/Object;
     |               AASTORE
@@ -482,11 +482,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     ASTORE 16
     method-call(java.lang.String java.lang.StringBuffer.toString())
     |               INVOKESTATIC Aspect.ajc_before_method_call ()V
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 18
     |               ALOAD 18
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 16
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure39
@@ -501,7 +501,7 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final String getName_aroundBody42():
                     INVOKESTATIC Aspect.ajc_before_method_execution ()V   (line 20)
-                    BIPUSH 0
+                    ICONST_0
                     ANEWARRAY java.lang.Object
                     ASTORE_0
                     NEW FancyHelloWorld$AjcClosure41
@@ -527,7 +527,7 @@ public class FancyHelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST FancyHelloWorld
                     INVOKESTATIC FancyHelloWorld.init$_aroundBody0 (LFancyHelloWorld;)V
@@ -549,7 +549,7 @@ public class FancyHelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST FancyHelloWorld
                     INVOKESTATIC FancyHelloWorld.init$_aroundBody2 (LFancyHelloWorld;)V
@@ -605,11 +605,11 @@ public class FancyHelloWorld$AjcClosure9 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody8 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -631,11 +631,11 @@ public class FancyHelloWorld$AjcClosure11 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody10 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -657,11 +657,11 @@ public class FancyHelloWorld$AjcClosure13 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC FancyHelloWorld.println_aroundBody12 (Ljava/io/PrintStream;Ljava/lang/Object;)V
                     ACONST_NULL
@@ -682,11 +682,11 @@ public class FancyHelloWorld$AjcClosure15 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC FancyHelloWorld.println_aroundBody14 (Ljava/io/PrintStream;Ljava/lang/Object;)V
                     ACONST_NULL
@@ -707,11 +707,11 @@ public class FancyHelloWorld$AjcClosure17 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody16 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -733,11 +733,11 @@ public class FancyHelloWorld$AjcClosure19 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody18 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -759,7 +759,7 @@ public class FancyHelloWorld$AjcClosure21 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     INVOKESTATIC FancyHelloWorld.main_aroundBody20 ([Ljava/lang/String;)V
@@ -781,7 +781,7 @@ public class FancyHelloWorld$AjcClosure23 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     INVOKESTATIC FancyHelloWorld.main_aroundBody22 ([Ljava/lang/String;)V
@@ -803,7 +803,7 @@ public class FancyHelloWorld$AjcClosure25 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.hashCode_aroundBody24 (Ljava/lang/String;)I
@@ -825,7 +825,7 @@ public class FancyHelloWorld$AjcClosure27 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.hashCode_aroundBody26 (Ljava/lang/String;)I
@@ -847,7 +847,7 @@ public class FancyHelloWorld$AjcClosure29 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.init$_aroundBody28 (Ljava/lang/String;)Ljava/lang/StringBuffer;
@@ -868,7 +868,7 @@ public class FancyHelloWorld$AjcClosure31 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.init$_aroundBody30 (Ljava/lang/String;)Ljava/lang/StringBuffer;
@@ -889,11 +889,11 @@ public class FancyHelloWorld$AjcClosure33 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.StringBuffer
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC org.aspectj.runtime.internal.Conversions.intValue (Ljava/lang/Object;)I
                     INVOKESTATIC FancyHelloWorld.append_aroundBody32 (Ljava/lang/StringBuffer;I)Ljava/lang/StringBuffer;
@@ -914,11 +914,11 @@ public class FancyHelloWorld$AjcClosure35 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.StringBuffer
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC org.aspectj.runtime.internal.Conversions.intValue (Ljava/lang/Object;)I
                     INVOKESTATIC FancyHelloWorld.append_aroundBody34 (Ljava/lang/StringBuffer;I)Ljava/lang/StringBuffer;
@@ -939,7 +939,7 @@ public class FancyHelloWorld$AjcClosure37 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.StringBuffer
                     INVOKESTATIC FancyHelloWorld.toString_aroundBody36 (Ljava/lang/StringBuffer;)Ljava/lang/String;
@@ -960,7 +960,7 @@ public class FancyHelloWorld$AjcClosure39 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.StringBuffer
                     INVOKESTATIC FancyHelloWorld.toString_aroundBody38 (Ljava/lang/StringBuffer;)Ljava/lang/String;
@@ -1,14 +1,14 @@
 public class HelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // HelloWorld this   (line 5)
+                    ALOAD_0     // LHelloWorld; this   (line 5)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void HelloWorld.<init>())
     |               INVOKESTATIC Aspect.ajc_before_constructor_execution ()V
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE_2
     |               ALOAD_2
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_0
     |               AASTORE
     |               NEW HelloWorld$AjcClosure3
@@ -26,11 +26,11 @@ public class HelloWorld extends java.lang.Object:
                     ASTORE 7
     method-execution(void HelloWorld.main(java.lang.String[]))
     |               INVOKESTATIC Aspect.ajc_before_method_execution ()V   (line 8)
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 9
     |               ALOAD 9
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 7
     |               AASTORE
     |               NEW HelloWorld$AjcClosure15
@@ -49,11 +49,11 @@ public class HelloWorld extends java.lang.Object:
 
   static final void init$_aroundBody2(HelloWorld):
                     INVOKESTATIC Aspect.ajc_before_constructor_execution ()V
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW HelloWorld$AjcClosure1
@@ -72,7 +72,7 @@ public class HelloWorld extends java.lang.Object:
 
   static final java.io.PrintStream out_aroundBody6():
                     INVOKESTATIC Aspect.ajc_before_field_get ()V
-                    BIPUSH 0
+                    ICONST_0
                     ANEWARRAY java.lang.Object
                     ASTORE_0
                     NEW HelloWorld$AjcClosure5
@@ -93,15 +93,15 @@ public class HelloWorld extends java.lang.Object:
 
   static final void println_aroundBody10(java.io.PrintStream, String):
                     INVOKESTATIC Aspect.ajc_before_method_call ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW HelloWorld$AjcClosure9
@@ -116,7 +116,7 @@ public class HelloWorld extends java.lang.Object:
   static final void main_aroundBody12(String[]):
     field-get(java.io.PrintStream java.lang.System.out)
     |               INVOKESTATIC Aspect.ajc_before_field_get ()V
-    |               BIPUSH 0
+    |               ICONST_0
     |               ANEWARRAY java.lang.Object
     |               ASTORE_1
     |               NEW HelloWorld$AjcClosure7
@@ -131,15 +131,15 @@ public class HelloWorld extends java.lang.Object:
                     ASTORE 5
     method-call(void java.io.PrintStream.println(java.lang.String))
     |               INVOKESTATIC Aspect.ajc_before_method_call ()V
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE 7
     |               ALOAD 7
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 5
     |               AASTORE
     |               ALOAD 7
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD_3
     |               AASTORE
     |               NEW HelloWorld$AjcClosure11
@@ -154,11 +154,11 @@ public class HelloWorld extends java.lang.Object:
 
   static final void main_aroundBody14(String[]):
                     INVOKESTATIC Aspect.ajc_before_method_execution ()V   (line 8)
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW HelloWorld$AjcClosure13
@@ -184,7 +184,7 @@ public class HelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST HelloWorld
                     INVOKESTATIC HelloWorld.init$_aroundBody0 (LHelloWorld;)V
@@ -206,7 +206,7 @@ public class HelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST HelloWorld
                     INVOKESTATIC HelloWorld.init$_aroundBody2 (LHelloWorld;)V
@@ -262,11 +262,11 @@ public class HelloWorld$AjcClosure9 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC HelloWorld.println_aroundBody8 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -288,11 +288,11 @@ public class HelloWorld$AjcClosure11 extends org.aspectj.runtime.internal.Around
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC HelloWorld.println_aroundBody10 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -314,7 +314,7 @@ public class HelloWorld$AjcClosure13 extends org.aspectj.runtime.internal.Around
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     INVOKESTATIC HelloWorld.main_aroundBody12 ([Ljava/lang/String;)V
@@ -336,7 +336,7 @@ public class HelloWorld$AjcClosure15 extends org.aspectj.runtime.internal.Around
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     INVOKESTATIC HelloWorld.main_aroundBody14 ([Ljava/lang/String;)V
@@ -3,11 +3,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     ALOAD_0     // LFancyHelloWorld; this   (line 7)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void FancyHelloWorld.<init>())
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE_1
     |               ALOAD_1
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_0
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure1
@@ -24,11 +24,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     ALOAD_0
                     ASTORE 15
     method-execution(void FancyHelloWorld.main(java.lang.String[]))
-    |               BIPUSH 1   (line 9)
+    |               ICONST_1   (line 9)
     |               ANEWARRAY java.lang.Object
     |               ASTORE 16
     |               ALOAD 16
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 15
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure11
@@ -43,7 +43,7 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   public static String getName():
     method-execution(java.lang.String FancyHelloWorld.getName())
-    |               BIPUSH 0   (line 20)
+    |               ICONST_0   (line 20)
     |               ANEWARRAY java.lang.Object
     |               ASTORE 10
     |               NEW FancyHelloWorld$AjcClosure21
@@ -88,7 +88,7 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void main_aroundBody10(String[]):
     field-get(java.io.PrintStream java.lang.System.out)
-    |               BIPUSH 0
+    |               ICONST_0
     |               ANEWARRAY java.lang.Object
     |               ASTORE_1
     |               NEW FancyHelloWorld$AjcClosure3
@@ -106,15 +106,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     | |             ASTORE 5
     | |             ASTORE 7
     | | method-call(void java.io.PrintStream.println(java.lang.String))
-    | | |           BIPUSH 2
+    | | |           ICONST_2
     | | |           ANEWARRAY java.lang.Object
     | | |           ASTORE 9
     | | |           ALOAD 9
-    | | |           BIPUSH 0
+    | | |           ICONST_0
     | | |           ALOAD 7
     | | |           AASTORE
     | | |           ALOAD 9
-    | | |           BIPUSH 1
+    | | |           ICONST_1
     | | |           ALOAD 5
     | | |           AASTORE
     | | |           NEW FancyHelloWorld$AjcClosure5
@@ -132,15 +132,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     |               ASTORE 13
     |               ASTORE 15
     | method-call(void java.io.PrintStream.println(java.lang.Object))
-    | |             BIPUSH 2
+    | |             ICONST_2
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE 17
     | |             ALOAD 17
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD 15
     | |             AASTORE
     | |             ALOAD 17
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ALOAD 13
     | |             AASTORE
     | |             NEW FancyHelloWorld$AjcClosure7
@@ -164,15 +164,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     ASTORE 23
                     ASTORE 25
     method-call(void java.io.PrintStream.println(java.lang.String))
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE 27
     |               ALOAD 27
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 25
     |               AASTORE
     |               ALOAD 27
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD 23
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure9
@@ -220,11 +220,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     LDC "name"
                     ASTORE_2
     method-call(int java.lang.String.hashCode())
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 4
     |               ALOAD 4
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_2
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure13
@@ -239,11 +239,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     LDC "name"   (line 22)
                     ASTORE 6
     constructor-call(void java.lang.StringBuffer.<init>(java.lang.String))
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 8
     |               ALOAD 8
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 6
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure15
@@ -257,15 +257,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
                     ISTORE 10
                     ASTORE 12
     method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE 14
     |               ALOAD 14
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 12
     |               AASTORE
     |               ALOAD 14
-    |               BIPUSH 1
+    |               ICONST_1
     |               ILOAD 10
     |               INVOKESTATIC org.aspectj.runtime.internal.Conversions.intObject (I)Ljava/lang/Object;
     |               AASTORE
@@ -278,11 +278,11 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))
                     ASTORE 16
     method-call(java.lang.String java.lang.StringBuffer.toString())
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 18
     |               ALOAD 18
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 16
     |               AASTORE
     |               NEW FancyHelloWorld$AjcClosure19
@@ -309,7 +309,7 @@ public class FancyHelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST FancyHelloWorld
                     INVOKESTATIC FancyHelloWorld.init$_aroundBody0 (LFancyHelloWorld;)V
@@ -348,11 +348,11 @@ public class FancyHelloWorld$AjcClosure5 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody4 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -374,11 +374,11 @@ public class FancyHelloWorld$AjcClosure7 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC FancyHelloWorld.println_aroundBody6 (Ljava/io/PrintStream;Ljava/lang/Object;)V
                     ACONST_NULL
@@ -399,11 +399,11 @@ public class FancyHelloWorld$AjcClosure9 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody8 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -425,7 +425,7 @@ public class FancyHelloWorld$AjcClosure11 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     INVOKESTATIC FancyHelloWorld.main_aroundBody10 ([Ljava/lang/String;)V
@@ -447,7 +447,7 @@ public class FancyHelloWorld$AjcClosure13 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.hashCode_aroundBody12 (Ljava/lang/String;)I
@@ -469,7 +469,7 @@ public class FancyHelloWorld$AjcClosure15 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.init$_aroundBody14 (Ljava/lang/String;)Ljava/lang/StringBuffer;
@@ -490,11 +490,11 @@ public class FancyHelloWorld$AjcClosure17 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.StringBuffer
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC org.aspectj.runtime.internal.Conversions.intValue (Ljava/lang/Object;)I
                     INVOKESTATIC FancyHelloWorld.append_aroundBody16 (Ljava/lang/StringBuffer;I)Ljava/lang/StringBuffer;
@@ -515,7 +515,7 @@ public class FancyHelloWorld$AjcClosure19 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.lang.StringBuffer
                     INVOKESTATIC FancyHelloWorld.toString_aroundBody18 (Ljava/lang/StringBuffer;)Ljava/lang/String;
@@ -3,11 +3,11 @@ public class HelloWorld extends java.lang.Object:
                     ALOAD_0     // LHelloWorld; this   (line 5)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void HelloWorld.<init>())
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE_1
     |               ALOAD_1
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_0
     |               AASTORE
     |               NEW HelloWorld$AjcClosure1
@@ -24,11 +24,11 @@ public class HelloWorld extends java.lang.Object:
                     ALOAD_0
                     ASTORE 5
     method-execution(void HelloWorld.main(java.lang.String[]))
-    |               BIPUSH 1   (line 8)
+    |               ICONST_1   (line 8)
     |               ANEWARRAY java.lang.Object
     |               ASTORE 6
     |               ALOAD 6
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 5
     |               AASTORE
     |               NEW HelloWorld$AjcClosure7
@@ -59,7 +59,7 @@ public class HelloWorld extends java.lang.Object:
 
   static final void main_aroundBody6(String[]):
     field-get(java.io.PrintStream java.lang.System.out)
-    |               BIPUSH 0
+    |               ICONST_0
     |               ANEWARRAY java.lang.Object
     |               ASTORE_1
     |               NEW HelloWorld$AjcClosure3
@@ -73,15 +73,15 @@ public class HelloWorld extends java.lang.Object:
                     ASTORE_3
                     ASTORE 5
     method-call(void java.io.PrintStream.println(java.lang.String))
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE 7
     |               ALOAD 7
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 5
     |               AASTORE
     |               ALOAD 7
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD_3
     |               AASTORE
     |               NEW HelloWorld$AjcClosure5
@@ -108,7 +108,7 @@ public class HelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST HelloWorld
                     INVOKESTATIC HelloWorld.init$_aroundBody0 (LHelloWorld;)V
@@ -147,11 +147,11 @@ public class HelloWorld$AjcClosure5 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC HelloWorld.println_aroundBody4 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -173,7 +173,7 @@ public class HelloWorld$AjcClosure7 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     INVOKESTATIC HelloWorld.main_aroundBody6 ([Ljava/lang/String;)V
@@ -1,6 +1,6 @@
 public abstract class FancyHelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // FancyHelloWorld this   (line 7)
+                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void FancyHelloWorld.<init>())
     |               RETURN
@@ -13,21 +13,21 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     |               ASTORE_1
     | finally -> E1
     | | catch java.lang.Exception -> E0
-    | | |           ALOAD_1     // java.io.PrintStream out   (line 11)
+    | | |           ALOAD_1     // Ljava/io/PrintStream; out   (line 11)
     | | |           LDC "bye"
     | | |           ASTORE 5
     | | |           ASTORE 6
     | | | method-call(void java.io.PrintStream.println(java.lang.String))
     | | | |         INVOKESTATIC Aspect.ajc_before_method_execution ()V
-    | | | |         BIPUSH 2
+    | | | |         ICONST_2
     | | | |         ANEWARRAY java.lang.Object
     | | | |         ASTORE 8
     | | | |         ALOAD 8
-    | | | |         BIPUSH 0
+    | | | |         ICONST_0
     | | | |         ALOAD 6
     | | | |         AASTORE
     | | | |         ALOAD 8
-    | | | |         BIPUSH 1
+    | | | |         ICONST_1
     | | | |         ALOAD 5
     | | | |         AASTORE
     | | | |         NEW FancyHelloWorld$AjcClosure3
@@ -40,21 +40,21 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     | | |           GOTO L0
     | | catch java.lang.Exception -> E0
     | |         E0: ASTORE_2   (line 12)
-    | |             ALOAD_1     // java.io.PrintStream out   (line 13)
-    | |             ALOAD_2     // java.lang.Exception e
+    | |             ALOAD_1     // Ljava/io/PrintStream; out   (line 13)
+    | |             ALOAD_2     // Ljava/lang/Exception; e
     | |             ASTORE 9
     | |             ASTORE 10
     | | method-call(void java.io.PrintStream.println(java.lang.Object))
     | | |           INVOKESTATIC Aspect.ajc_before_method_execution ()V
-    | | |           BIPUSH 2
+    | | |           ICONST_2
     | | |           ANEWARRAY java.lang.Object
     | | |           ASTORE 12
     | | |           ALOAD 12
-    | | |           BIPUSH 0
+    | | |           ICONST_0
     | | |           ALOAD 10
     | | |           AASTORE
     | | |           ALOAD 12
-    | | |           BIPUSH 1
+    | | |           ICONST_1
     | | |           ALOAD 9
     | | |           AASTORE
     | | |           NEW FancyHelloWorld$AjcClosure7
@@ -73,21 +73,21 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     |           L0: JSR L1
     |               GOTO L2
     |           L1: ASTORE_3
-    |               ALOAD_1     // java.io.PrintStream out   (line 15)
+    |               ALOAD_1     // Ljava/io/PrintStream; out   (line 15)
     |               LDC "finally"
     |               ASTORE 13
     |               ASTORE 14
     | method-call(void java.io.PrintStream.println(java.lang.String))
     | |             INVOKESTATIC Aspect.ajc_before_method_execution ()V
-    | |             BIPUSH 2
+    | |             ICONST_2
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE 16
     | |             ALOAD 16
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD 14
     | |             AASTORE
     | |             ALOAD 16
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ALOAD 13
     | |             AASTORE
     | |             NEW FancyHelloWorld$AjcClosure11
@@ -106,18 +106,18 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     method-execution(java.lang.String FancyHelloWorld.getName())
     |               ICONST_0   (line 20)
     |               ISTORE_0
-    |               ILOAD_0     // int x   (line 21)
+    |               ILOAD_0     // I x   (line 21)
     |               LDC "name"
     | method-call(int java.lang.String.hashCode())
     | |             INVOKEVIRTUAL java.lang.String.hashCode ()I
     | method-call(int java.lang.String.hashCode())
     |               IADD
-    |               ISTORE_0     // int x
+    |               ISTORE_0     // I x
     |               NEW java.lang.StringBuffer   (line 22)
     |               DUP
     |               LDC "name"
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ILOAD_0     // int x
+    |               ILOAD_0     // I x
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (I)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))
@@ -137,15 +137,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void println_aroundBody2(java.io.PrintStream, String):
                     INVOKESTATIC Aspect.ajc_before_method_execution ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure1
@@ -166,15 +166,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void println_aroundBody6(java.io.PrintStream, Object):
                     INVOKESTATIC Aspect.ajc_before_method_execution ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure5
@@ -195,15 +195,15 @@ public abstract class FancyHelloWorld extends java.lang.Object:
 
   static final void println_aroundBody10(java.io.PrintStream, String):
                     INVOKESTATIC Aspect.ajc_before_method_execution ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW FancyHelloWorld$AjcClosure9
@@ -229,11 +229,11 @@ public class FancyHelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody0 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -255,11 +255,11 @@ public class FancyHelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody2 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -281,11 +281,11 @@ public class FancyHelloWorld$AjcClosure5 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC FancyHelloWorld.println_aroundBody4 (Ljava/io/PrintStream;Ljava/lang/Object;)V
                     ACONST_NULL
@@ -306,11 +306,11 @@ public class FancyHelloWorld$AjcClosure7 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC FancyHelloWorld.println_aroundBody6 (Ljava/io/PrintStream;Ljava/lang/Object;)V
                     ACONST_NULL
@@ -331,11 +331,11 @@ public class FancyHelloWorld$AjcClosure9 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody8 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -357,11 +357,11 @@ public class FancyHelloWorld$AjcClosure11 extends org.aspectj.runtime.internal.A
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody10 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -1,6 +1,6 @@
 public class HelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // HelloWorld this   (line 5)
+                    ALOAD_0     // LHelloWorld; this   (line 5)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void HelloWorld.<init>())
     |               RETURN
@@ -15,15 +15,15 @@ public class HelloWorld extends java.lang.Object:
     |               ASTORE_2
     | method-call(void java.io.PrintStream.println(java.lang.String))
     | |             INVOKESTATIC Aspect.ajc_before_method_execution ()V
-    | |             BIPUSH 2
+    | |             ICONST_2
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE 4
     | |             ALOAD 4
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD_2
     | |             AASTORE
     | |             ALOAD 4
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ALOAD_1
     | |             AASTORE
     | |             NEW HelloWorld$AjcClosure3
@@ -46,15 +46,15 @@ public class HelloWorld extends java.lang.Object:
 
   static final void println_aroundBody2(java.io.PrintStream, String):
                     INVOKESTATIC Aspect.ajc_before_method_execution ()V
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW HelloWorld$AjcClosure1
@@ -80,11 +80,11 @@ public class HelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC HelloWorld.println_aroundBody0 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -106,11 +106,11 @@ public class HelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC HelloWorld.println_aroundBody2 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -1,6 +1,6 @@
 public class DynamicHelloWorld extends java.lang.Object implements java.io.Serializable:
   public void <init>():
-                    ALOAD_0     // DynamicHelloWorld this   (line 8)
+                    ALOAD_0     // LDynamicHelloWorld; this   (line 8)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void DynamicHelloWorld.<init>())
     |               RETURN
@@ -27,7 +27,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               DUP
     |               LDC "expected and caught: "
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ALOAD_1     // java.lang.UnsupportedOperationException t
+    |               ALOAD_1     // Ljava/lang/UnsupportedOperationException; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -48,8 +48,8 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
 
   String doit(String, java.util.List):
     method-execution(java.lang.String DynamicHelloWorld.doit(java.lang.String, java.util.List))
-    |               ALOAD_2     // java.util.List l   (line 21)
-    |               ALOAD_1     // java.lang.String s
+    |               ALOAD_2     // Ljava/util/List; l   (line 21)
+    |               ALOAD_1     // Ljava/lang/String; s
     |               ASTORE_3
     |               ASTORE 4
     | method-call(boolean java.util.List.add(java.lang.Object))
@@ -58,19 +58,19 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     | |             IFEQ L0
     | |             ALOAD 4
     | |             CHECKCAST java.util.ArrayList
-    | |             BIPUSH 3
+    | |             ICONST_3
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE 5
     | |             ALOAD 5
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD_0
     | |             AASTORE
     | |             ALOAD 5
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ALOAD 4
     | |             AASTORE
     | |             ALOAD 5
-    | |             BIPUSH 2
+    | |             ICONST_2
     | |             ALOAD_3
     | |             AASTORE
     | |             NEW DynamicHelloWorld$AjcClosure1
@@ -86,7 +86,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     | |         L1: NOP
     | method-call(boolean java.util.List.add(java.lang.Object))
     |               POP
-    |               ALOAD_2     // java.util.List l   (line 22)
+    |               ALOAD_2     // Ljava/util/List; l   (line 22)
     | method-call(java.lang.String java.lang.Object.toString())
     | |             INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String;
     | method-call(java.lang.String java.lang.Object.toString())
@@ -115,15 +115,15 @@ public class DynamicHelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST DynamicHelloWorld
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.util.List
                     ALOAD_2
-                    BIPUSH 2
+                    ICONST_2
                     AALOAD
                     INVOKESTATIC DynamicHelloWorld.add_aroundBody0 (LDynamicHelloWorld;Ljava/util/List;Ljava/lang/Object;)Z
                     INVOKESTATIC org.aspectj.runtime.internal.Conversions.booleanObject (Z)Ljava/lang/Object;
@@ -1,6 +1,6 @@
 public abstract class FancyHelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // FancyHelloWorld this   (line 7)
+                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void FancyHelloWorld.<init>())
     |               RETURN
@@ -13,20 +13,20 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     |               ASTORE_1
     | finally -> E1
     | | catch java.lang.Exception -> E0
-    | | |           ALOAD_1     // java.io.PrintStream out   (line 11)
+    | | |           ALOAD_1     // Ljava/io/PrintStream; out   (line 11)
     | | |           LDC "bye"
     | | |           ASTORE 5
     | | |           ASTORE 6
     | | | method-call(void java.io.PrintStream.println(java.lang.String))
-    | | | |         BIPUSH 2
+    | | | |         ICONST_2
     | | | |         ANEWARRAY java.lang.Object
     | | | |         ASTORE 7
     | | | |         ALOAD 7
-    | | | |         BIPUSH 0
+    | | | |         ICONST_0
     | | | |         ALOAD 6
     | | | |         AASTORE
     | | | |         ALOAD 7
-    | | | |         BIPUSH 1
+    | | | |         ICONST_1
     | | | |         ALOAD 5
     | | | |         AASTORE
     | | | |         NEW FancyHelloWorld$AjcClosure1
@@ -39,20 +39,20 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     | | |           GOTO L0
     | | catch java.lang.Exception -> E0
     | |         E0: ASTORE_2   (line 12)
-    | |             ALOAD_1     // java.io.PrintStream out   (line 13)
-    | |             ALOAD_2     // java.lang.Exception e
+    | |             ALOAD_1     // Ljava/io/PrintStream; out   (line 13)
+    | |             ALOAD_2     // Ljava/lang/Exception; e
     | |             ASTORE 8
     | |             ASTORE 9
     | | method-call(void java.io.PrintStream.println(java.lang.Object))
-    | | |           BIPUSH 2
+    | | |           ICONST_2
     | | |           ANEWARRAY java.lang.Object
     | | |           ASTORE 10
     | | |           ALOAD 10
-    | | |           BIPUSH 0
+    | | |           ICONST_0
     | | |           ALOAD 9
     | | |           AASTORE
     | | |           ALOAD 10
-    | | |           BIPUSH 1
+    | | |           ICONST_1
     | | |           ALOAD 8
     | | |           AASTORE
     | | |           NEW FancyHelloWorld$AjcClosure3
@@ -71,20 +71,20 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     |           L0: JSR L1
     |               GOTO L2
     |           L1: ASTORE_3
-    |               ALOAD_1     // java.io.PrintStream out   (line 15)
+    |               ALOAD_1     // Ljava/io/PrintStream; out   (line 15)
     |               LDC "finally"
     |               ASTORE 11
     |               ASTORE 12
     | method-call(void java.io.PrintStream.println(java.lang.String))
-    | |             BIPUSH 2
+    | |             ICONST_2
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE 13
     | |             ALOAD 13
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD 12
     | |             AASTORE
     | |             ALOAD 13
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ALOAD 11
     | |             AASTORE
     | |             NEW FancyHelloWorld$AjcClosure5
@@ -103,18 +103,18 @@ public abstract class FancyHelloWorld extends java.lang.Object:
     method-execution(java.lang.String FancyHelloWorld.getName())
     |               ICONST_0   (line 20)
     |               ISTORE_0
-    |               ILOAD_0     // int x   (line 21)
+    |               ILOAD_0     // I x   (line 21)
     |               LDC "name"
     | method-call(int java.lang.String.hashCode())
     | |             INVOKEVIRTUAL java.lang.String.hashCode ()I
     | method-call(int java.lang.String.hashCode())
     |               IADD
-    |               ISTORE_0     // int x
+    |               ISTORE_0     // I x
     |               NEW java.lang.StringBuffer   (line 22)
     |               DUP
     |               LDC "name"
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ILOAD_0     // int x
+    |               ILOAD_0     // I x
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (I)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))
@@ -160,11 +160,11 @@ public class FancyHelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody0 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -186,11 +186,11 @@ public class FancyHelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     INVOKESTATIC FancyHelloWorld.println_aroundBody2 (Ljava/io/PrintStream;Ljava/lang/Object;)V
                     ACONST_NULL
@@ -211,11 +211,11 @@ public class FancyHelloWorld$AjcClosure5 extends org.aspectj.runtime.internal.Ar
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC FancyHelloWorld.println_aroundBody4 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -1,6 +1,6 @@
 public class HelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // HelloWorld this   (line 5)
+                    ALOAD_0     // LHelloWorld; this   (line 5)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void HelloWorld.<init>())
     |               RETURN
@@ -14,15 +14,15 @@ public class HelloWorld extends java.lang.Object:
     |               ASTORE_1
     |               ASTORE_2
     | method-call(void java.io.PrintStream.println(java.lang.String))
-    | |             BIPUSH 2
+    | |             ICONST_2
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE_3
     | |             ALOAD_3
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD_2
     | |             AASTORE
     | |             ALOAD_3
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ALOAD_1
     | |             AASTORE
     | |             NEW HelloWorld$AjcClosure1
@@ -57,11 +57,11 @@ public class HelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     INVOKESTATIC HelloWorld.println_aroundBody0 (Ljava/io/PrintStream;Ljava/lang/String;)V
@@ -1,6 +1,6 @@
 public class DynamicHelloWorld extends java.lang.Object implements java.io.Serializable:
   public void <init>():
-                    ALOAD_0     // DynamicHelloWorld this   (line 8)
+                    ALOAD_0     // LDynamicHelloWorld; this   (line 8)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void DynamicHelloWorld.<init>())
     |               RETURN
@@ -13,7 +13,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               INVOKEVIRTUAL org.aspectj.runtime.internal.CFlowStack.isValid ()Z
     |               IFEQ L0
     |               GETSTATIC Aspect.ajc$cflowStack$0 Lorg/aspectj/runtime/internal/CFlowStack;
-    |               BIPUSH 0
+    |               ICONST_0
     |               INVOKEVIRTUAL org.aspectj.runtime.internal.CFlowStack.get (I)Ljava/lang/Object;
     |               CHECKCAST java.util.ArrayList
     |               INVOKESTATIC Aspect.ajc_before_0 (Ljava/util/ArrayList;)V
@@ -35,7 +35,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               DUP
     |               LDC "expected and caught: "
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ALOAD_1     // java.lang.UnsupportedOperationException t
+    |               ALOAD_1     // Ljava/lang/UnsupportedOperationException; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -56,23 +56,23 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
 
   String doit(String, java.util.List):
     method-execution(java.lang.String DynamicHelloWorld.doit(java.lang.String, java.util.List))
-    |               ALOAD_2     // java.util.List l   (line 21)
-    |               ALOAD_1     // java.lang.String s
+    |               ALOAD_2     // Ljava/util/List; l   (line 21)
+    |               ALOAD_1     // Ljava/lang/String; s
     |               ASTORE_3
     |               ASTORE 4
     | method-call(boolean java.util.List.add(java.lang.Object))
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ISTORE 5
     | |             ALOAD 4
     | |             INSTANCEOF java.util.ArrayList
     | |             IFEQ L0
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ISTORE 5
-    | |             BIPUSH 1
+    | |             ICONST_1
     | |             ANEWARRAY java.lang.Object
     | |             ASTORE 6
     | |             ALOAD 6
-    | |             BIPUSH 0
+    | |             ICONST_0
     | |             ALOAD 4
     | |             AASTORE
     | |             GETSTATIC Aspect.ajc$cflowStack$0 Lorg/aspectj/runtime/internal/CFlowStack;
@@ -99,7 +99,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     | |         L3: NOP
     | method-call(boolean java.util.List.add(java.lang.Object))
     |               POP
-    |               ALOAD_2     // java.util.List l   (line 22)
+    |               ALOAD_2     // Ljava/util/List; l   (line 22)
     | method-call(java.lang.String java.lang.Object.toString())
     | |             INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String;
     | method-call(java.lang.String java.lang.Object.toString())
@@ -1,6 +1,6 @@
 public class DynamicHelloWorld extends java.lang.Object implements java.io.Serializable:
   public void <init>():
-                    ALOAD_0     // DynamicHelloWorld this   (line 8)
+                    ALOAD_0     // LDynamicHelloWorld; this   (line 8)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void DynamicHelloWorld.<init>())
     |               RETURN
@@ -27,7 +27,7 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               DUP
     |               LDC "expected and caught: "
     |               INVOKESPECIAL java.lang.StringBuffer.<init> (Ljava/lang/String;)V
-    |               ALOAD_1     // java.lang.UnsupportedOperationException t
+    |               ALOAD_1     // Ljava/lang/UnsupportedOperationException; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -48,14 +48,14 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
 
   String doit(String, java.util.List):
     method-execution(java.lang.String DynamicHelloWorld.doit(java.lang.String, java.util.List))
-    |               ALOAD_2     // java.util.List l   (line 21)
-    |               ALOAD_1     // java.lang.String s
+    |               ALOAD_2     // Ljava/util/List; l   (line 21)
+    |               ALOAD_1     // Ljava/lang/String; s
     | method-call(boolean java.util.List.add(java.lang.Object))
     | |             INVOKESTATIC Aspect.ajc_before_0 ()V
     | |             INVOKEINTERFACE java.util.List.add (Ljava/lang/Object;)Z
     | method-call(boolean java.util.List.add(java.lang.Object))
     |               POP
-    |               ALOAD_2     // java.util.List l   (line 22)
+    |               ALOAD_2     // Ljava/util/List; l   (line 22)
     | method-call(java.lang.String java.lang.Object.toString())
     | |             INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String;
     | method-call(java.lang.String java.lang.Object.toString())
@@ -1,6 +1,6 @@
 public class MultiArgHelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // MultiArgHelloWorld this   (line 3)
+                    ALOAD_0     // LMultiArgHelloWorld; this   (line 3)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void MultiArgHelloWorld.<init>())
     |               RETURN
@@ -34,7 +34,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     |               NEW java.lang.StringBuffer
     |               DUP
     |               INVOKESPECIAL java.lang.StringBuffer.<init> ()V
-    |               ALOAD_0     // java.lang.Object s
+    |               ALOAD_0     // Ljava/lang/Object; s
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -42,7 +42,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/String;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
-    |               ALOAD_1     // java.lang.Object t
+    |               ALOAD_1     // Ljava/lang/Object; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -47,7 +47,7 @@ public class HelloWorld extends java.lang.Object:
                     LDC ""
                     LDC ""
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
-                    BIPUSH 5
+                    ICONST_5
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeESJP (Ljava/lang/String;Lorg/aspectj/lang/Signature;I)Lorg/aspectj/lang/JoinPoint$EnclosingStaticPart;
                     PUTSTATIC HelloWorld.ajc$tjp_0 Lorg/aspectj/lang/JoinPoint$EnclosingStaticPart;
                     ALOAD_0
@@ -49,7 +49,7 @@ public class HelloWorld extends java.lang.Object:
                     LDC ""
                     LDC ""
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
-                    BIPUSH 5
+                    ICONST_5
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeSJP (Ljava/lang/String;Lorg/aspectj/lang/Signature;I)Lorg/aspectj/lang/JoinPoint$StaticPart;
                     PUTSTATIC HelloWorld.ajc$tjp_0 Lorg/aspectj/lang/JoinPoint$StaticPart;
                     ALOAD_0
@@ -1,6 +1,6 @@
 public class MultiArgHelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // MultiArgHelloWorld this   (line 3)
+                    ALOAD_0     // LMultiArgHelloWorld; this   (line 3)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void MultiArgHelloWorld.<init>())
     |               RETURN
@@ -35,7 +35,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     |               NEW java.lang.StringBuffer
     |               DUP
     |               INVOKESPECIAL java.lang.StringBuffer.<init> ()V
-    |               ALOAD_0     // java.lang.Object s
+    |               ALOAD_0     // Ljava/lang/Object; s
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -43,7 +43,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/String;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
-    |               ALOAD_1     // java.lang.Object t
+    |               ALOAD_1     // Ljava/lang/Object; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -1,6 +1,6 @@
 public class MultiArgHelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // MultiArgHelloWorld this   (line 3)
+                    ALOAD_0     // LMultiArgHelloWorld; this   (line 3)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void MultiArgHelloWorld.<init>())
     |               RETURN
@@ -32,7 +32,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     |               NEW java.lang.StringBuffer
     |               DUP
     |               INVOKESPECIAL java.lang.StringBuffer.<init> ()V
-    |               ALOAD_0     // java.lang.Object s
+    |               ALOAD_0     // Ljava/lang/Object; s
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -40,7 +40,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/String;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
-    |               ALOAD_1     // java.lang.Object t
+    |               ALOAD_1     // Ljava/lang/Object; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -1,6 +1,6 @@
 public class MultiArgHelloWorld extends java.lang.Object:
   public void <init>():
-                    ALOAD_0     // MultiArgHelloWorld this   (line 3)
+                    ALOAD_0     // LMultiArgHelloWorld; this   (line 3)
                     INVOKESPECIAL java.lang.Object.<init> ()V
     constructor-execution(void MultiArgHelloWorld.<init>())
     |               RETURN
@@ -32,7 +32,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     |               NEW java.lang.StringBuffer
     |               DUP
     |               INVOKESPECIAL java.lang.StringBuffer.<init> ()V
-    |               ALOAD_0     // java.lang.Object s
+    |               ALOAD_0     // Ljava/lang/Object; s
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -40,7 +40,7 @@ public class MultiArgHelloWorld extends java.lang.Object:
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/String;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
-    |               ALOAD_1     // java.lang.Object t
+    |               ALOAD_1     // Ljava/lang/Object; t
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
     | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
     | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
@@ -12,15 +12,15 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE_1
     constructor-execution(void HelloWorld.<init>())
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE_3
     |               ALOAD_3
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_0
     |               AASTORE
     |               ALOAD_3
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD_1
     |               AASTORE
     |               NEW HelloWorld$AjcClosure3
@@ -44,15 +44,15 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE 10
     method-execution(void HelloWorld.main(java.lang.String[]))
-    |               BIPUSH 2   (line 8)
+    |               ICONST_2   (line 8)
     |               ANEWARRAY java.lang.Object
     |               ASTORE 12
     |               ALOAD 12
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 9
     |               AASTORE
     |               ALOAD 12
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD 10
     |               AASTORE
     |               NEW HelloWorld$AjcClosure15
@@ -83,7 +83,7 @@ public class HelloWorld extends java.lang.Object:
                     LDC ""
                     LDC ""
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
-                    BIPUSH 5
+                    ICONST_5
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeSJP (Ljava/lang/String;Lorg/aspectj/lang/Signature;I)Lorg/aspectj/lang/JoinPoint$StaticPart;
                     PUTSTATIC HelloWorld.ajc$tjp_0 Lorg/aspectj/lang/JoinPoint$StaticPart;
                     ALOAD_0
@@ -135,15 +135,15 @@ public class HelloWorld extends java.lang.Object:
   end static final void init$_aroundBody0(HelloWorld, org.aspectj.lang.JoinPoint)
 
   static final void init$_aroundBody2(HelloWorld, org.aspectj.lang.JoinPoint):
-                    BIPUSH 2
+                    ICONST_2
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW HelloWorld$AjcClosure1
@@ -162,11 +162,11 @@ public class HelloWorld extends java.lang.Object:
   end static final java.io.PrintStream out_aroundBody4(org.aspectj.lang.JoinPoint)
 
   static final java.io.PrintStream out_aroundBody6(org.aspectj.lang.JoinPoint):
-                    BIPUSH 1
+                    ICONST_1
                     ANEWARRAY java.lang.Object
                     ASTORE_1
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     NEW HelloWorld$AjcClosure5
@@ -187,19 +187,19 @@ public class HelloWorld extends java.lang.Object:
   end static final void println_aroundBody8(java.io.PrintStream, String, org.aspectj.lang.JoinPoint)
 
   static final void println_aroundBody10(java.io.PrintStream, String, org.aspectj.lang.JoinPoint):
-                    BIPUSH 3
+                    ICONST_3
                     ANEWARRAY java.lang.Object
                     ASTORE_3
                     ALOAD_3
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_3
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     ALOAD_3
-                    BIPUSH 2
+                    ICONST_2
                     ALOAD_2
                     AASTORE
                     NEW HelloWorld$AjcClosure9
@@ -219,11 +219,11 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE_2
     field-get(java.io.PrintStream java.lang.System.out)
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 4
     |               ALOAD 4
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_2
     |               AASTORE
     |               NEW HelloWorld$AjcClosure7
@@ -244,19 +244,19 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE 10
     method-call(void java.io.PrintStream.println(java.lang.String))
-    |               BIPUSH 3
+    |               ICONST_3
     |               ANEWARRAY java.lang.Object
     |               ASTORE 12
     |               ALOAD 12
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 8
     |               AASTORE
     |               ALOAD 12
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD 6
     |               AASTORE
     |               ALOAD 12
-    |               BIPUSH 2
+    |               ICONST_2
     |               ALOAD 10
     |               AASTORE
     |               NEW HelloWorld$AjcClosure11
@@ -271,15 +271,15 @@ public class HelloWorld extends java.lang.Object:
   end static final void main_aroundBody12(String[], org.aspectj.lang.JoinPoint)
 
   static final void main_aroundBody14(String[], org.aspectj.lang.JoinPoint):
-                    BIPUSH 2   (line 8)
+                    ICONST_2   (line 8)
                     ANEWARRAY java.lang.Object
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     NEW HelloWorld$AjcClosure13
@@ -306,11 +306,11 @@ public class HelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST HelloWorld
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.init$_aroundBody0 (LHelloWorld;Lorg/aspectj/lang/JoinPoint;)V
@@ -332,11 +332,11 @@ public class HelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST HelloWorld
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.init$_aroundBody2 (LHelloWorld;Lorg/aspectj/lang/JoinPoint;)V
@@ -358,7 +358,7 @@ public class HelloWorld$AjcClosure5 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.out_aroundBody4 (Lorg/aspectj/lang/JoinPoint;)Ljava/io/PrintStream;
@@ -379,7 +379,7 @@ public class HelloWorld$AjcClosure7 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.out_aroundBody6 (Lorg/aspectj/lang/JoinPoint;)Ljava/io/PrintStream;
@@ -400,15 +400,15 @@ public class HelloWorld$AjcClosure9 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     ALOAD_2
-                    BIPUSH 2
+                    ICONST_2
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.println_aroundBody8 (Ljava/io/PrintStream;Ljava/lang/String;Lorg/aspectj/lang/JoinPoint;)V
@@ -430,15 +430,15 @@ public class HelloWorld$AjcClosure11 extends org.aspectj.runtime.internal.Around
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     ALOAD_2
-                    BIPUSH 2
+                    ICONST_2
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.println_aroundBody10 (Ljava/io/PrintStream;Ljava/lang/String;Lorg/aspectj/lang/JoinPoint;)V
@@ -460,11 +460,11 @@ public class HelloWorld$AjcClosure13 extends org.aspectj.runtime.internal.Around
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.main_aroundBody12 ([Ljava/lang/String;Lorg/aspectj/lang/JoinPoint;)V
@@ -486,11 +486,11 @@ public class HelloWorld$AjcClosure15 extends org.aspectj.runtime.internal.Around
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.main_aroundBody14 ([Ljava/lang/String;Lorg/aspectj/lang/JoinPoint;)V
@@ -12,15 +12,15 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE_1
     constructor-execution(void HelloWorld.<init>())
-    |               BIPUSH 2
+    |               ICONST_2
     |               ANEWARRAY java.lang.Object
     |               ASTORE_2
     |               ALOAD_2
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_0
     |               AASTORE
     |               ALOAD_2
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD_1
     |               AASTORE
     |               NEW HelloWorld$AjcClosure1
@@ -44,15 +44,15 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE 8
     method-execution(void HelloWorld.main(java.lang.String[]))
-    |               BIPUSH 2   (line 8)
+    |               ICONST_2   (line 8)
     |               ANEWARRAY java.lang.Object
     |               ASTORE 9
     |               ALOAD 9
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 7
     |               AASTORE
     |               ALOAD 9
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD 8
     |               AASTORE
     |               NEW HelloWorld$AjcClosure7
@@ -83,7 +83,7 @@ public class HelloWorld extends java.lang.Object:
                     LDC ""
                     LDC ""
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
-                    BIPUSH 5
+                    ICONST_5
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeSJP (Ljava/lang/String;Lorg/aspectj/lang/Signature;I)Lorg/aspectj/lang/JoinPoint$StaticPart;
                     PUTSTATIC HelloWorld.ajc$tjp_0 Lorg/aspectj/lang/JoinPoint$StaticPart;
                     ALOAD_0
@@ -153,11 +153,11 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE_2
     field-get(java.io.PrintStream java.lang.System.out)
-    |               BIPUSH 1
+    |               ICONST_1
     |               ANEWARRAY java.lang.Object
     |               ASTORE 4
     |               ALOAD 4
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_2
     |               AASTORE
     |               NEW HelloWorld$AjcClosure3
@@ -178,19 +178,19 @@ public class HelloWorld extends java.lang.Object:
                     INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                     ASTORE 10
     method-call(void java.io.PrintStream.println(java.lang.String))
-    |               BIPUSH 3
+    |               ICONST_3
     |               ANEWARRAY java.lang.Object
     |               ASTORE 12
     |               ALOAD 12
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD 8
     |               AASTORE
     |               ALOAD 12
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD 6
     |               AASTORE
     |               ALOAD 12
-    |               BIPUSH 2
+    |               ICONST_2
     |               ALOAD 10
     |               AASTORE
     |               NEW HelloWorld$AjcClosure5
@@ -218,11 +218,11 @@ public class HelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST HelloWorld
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.init$_aroundBody0 (LHelloWorld;Lorg/aspectj/lang/JoinPoint;)V
@@ -244,7 +244,7 @@ public class HelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.out_aroundBody2 (Lorg/aspectj/lang/JoinPoint;)Ljava/io/PrintStream;
@@ -265,15 +265,15 @@ public class HelloWorld$AjcClosure5 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST java.io.PrintStream
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     ALOAD_2
-                    BIPUSH 2
+                    ICONST_2
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.println_aroundBody4 (Ljava/io/PrintStream;Ljava/lang/String;Lorg/aspectj/lang/JoinPoint;)V
@@ -295,11 +295,11 @@ public class HelloWorld$AjcClosure7 extends org.aspectj.runtime.internal.AroundC
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST [Ljava.lang.String;
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST org.aspectj.lang.JoinPoint
                     INVOKESTATIC HelloWorld.main_aroundBody6 ([Ljava/lang/String;Lorg/aspectj/lang/JoinPoint;)V
@@ -77,7 +77,7 @@ public class HelloWorld extends java.lang.Object:
                     LDC ""
                     LDC ""
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
-                    BIPUSH 5
+                    ICONST_5
                     INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeSJP (Ljava/lang/String;Lorg/aspectj/lang/Signature;I)Lorg/aspectj/lang/JoinPoint$StaticPart;
                     PUTSTATIC HelloWorld.ajc$tjp_0 Lorg/aspectj/lang/JoinPoint$StaticPart;
                     ALOAD_0
@@ -46,19 +46,19 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
     |               ALOAD_0
     |               INVOKEVIRTUAL Trace.ajc$before$Trace$1$26352be2 (Ljava/lang/Object;)V
     |               INVOKESTATIC MyTrace.aspectOf ()LMyTrace;
-    |               BIPUSH 3
+    |               ICONST_3
     |               ANEWARRAY java.lang.Object
     |               ASTORE 6
     |               ALOAD 6
-    |               BIPUSH 0
+    |               ICONST_0
     |               ALOAD_0
     |               AASTORE
     |               ALOAD 6
-    |               BIPUSH 1
+    |               ICONST_1
     |               ALOAD_3
     |               AASTORE
     |               ALOAD 6
-    |               BIPUSH 2
+    |               ICONST_2
     |               ALOAD 4
     |               AASTORE
     |               NEW DynamicHelloWorld$AjcClosure3
@@ -93,19 +93,19 @@ public class DynamicHelloWorld extends java.lang.Object implements java.io.Seria
   static final String doit_aroundBody2(DynamicHelloWorld, String, java.util.List):
                     INVOKESTATIC MyTrace.aspectOf ()LMyTrace;   (line 21)
                     ALOAD_0
-                    BIPUSH 3
+                    ICONST_3
                     ANEWARRAY java.lang.Object
                     ASTORE_3
                     ALOAD_3
-                    BIPUSH 0
+                    ICONST_0
                     ALOAD_0
                     AASTORE
                     ALOAD_3
-                    BIPUSH 1
+                    ICONST_1
                     ALOAD_1
                     AASTORE
                     ALOAD_3
-                    BIPUSH 2
+                    ICONST_2
                     ALOAD_2
                     AASTORE
                     NEW DynamicHelloWorld$AjcClosure1
@@ -131,15 +131,15 @@ public class DynamicHelloWorld$AjcClosure1 extends org.aspectj.runtime.internal.
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_1
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST DynamicHelloWorld
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     ALOAD_2
-                    BIPUSH 2
+                    ICONST_2
                     AALOAD
                     CHECKCAST java.util.List
                     INVOKESTATIC DynamicHelloWorld.doit_aroundBody0 (LDynamicHelloWorld;Ljava/lang/String;Ljava/util/List;)Ljava/lang/String;
@@ -160,15 +160,15 @@ public class DynamicHelloWorld$AjcClosure3 extends org.aspectj.runtime.internal.
                     GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                     ASTORE_2
                     ALOAD_2
-                    BIPUSH 0
+                    ICONST_0
                     AALOAD
                     CHECKCAST DynamicHelloWorld
                     ALOAD_2
-                    BIPUSH 1
+                    ICONST_1
                     AALOAD
                     CHECKCAST java.lang.String
                     ALOAD_2
-                    BIPUSH 2
+                    ICONST_2
                     AALOAD
                     CHECKCAST java.util.List
                     INVOKESTATIC DynamicHelloWorld.doit_aroundBody2 (LDynamicHelloWorld;Ljava/lang/String;Ljava/util/List;)Ljava/lang/String;
@@ -1181,11 +1181,11 @@ public final class LazyMethodGen implements Traceable {
 	       	if (slots == null) {
 	       		slots = new HashSet();
 	       		duplicatedLocalMap.put(start, slots);	
-	       	} else if (slots.contains(new Integer(tag.getSlot()))) {
+	       	} else if (slots.contains(Integer.valueOf(tag.getSlot()))) {
 	       		// we already have a var starting at this tag with this slot
 	       		continue;
 	       	}
-	       	slots.add(new Integer(tag.getSlot()));
+	       	slots.add(Integer.valueOf(tag.getSlot()));
 	       	Type t = tag.getRealType();
 	       	if (t==null) {
 	       		t = BcelWorld.makeBcelType(UnresolvedType.forSignature(tag.getType()));
@@ -62,10 +62,6 @@ import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
 
 public class Utility {
-
-    private Utility() {
-        super();
-    }
 
 	/*
 	 * Ensure we report a nice source location - particular in the case
@@ -507,26 +503,26 @@ public class Utility {
         return il;
     }
 
-	public static Instruction createConstant(
-    		InstructionFactory fact,
-    		int i) {
+	public static Instruction createConstant(InstructionFactory fact,int value) {
 		Instruction inst;
-		switch(i) {
+		switch (value) {
 			case -1: inst =  InstructionConstants.ICONST_M1; break;
 			case 0: inst =  InstructionConstants.ICONST_0;	break;			
 			case 1: inst =  InstructionConstants.ICONST_1; break;
 			case 2: inst =  InstructionConstants.ICONST_2; break;				
 			case 3: inst =  InstructionConstants.ICONST_3; break;
 			case 4: inst =  InstructionConstants.ICONST_4;	break;			
-			case 5: inst =  InstructionConstants.ICONST_5;	break;	
-		}
-		if (i <= Byte.MAX_VALUE && i >= Byte.MIN_VALUE) {
-	     	inst =  new InstructionByte(Constants.BIPUSH,(byte)i);
-		} else if (i <= Short.MAX_VALUE && i >= Short.MIN_VALUE) {
-			inst =  new InstructionShort(Constants.SIPUSH,(short)i);
-		} else {
-		      int ii = fact.getClassGen().getConstantPool().addInteger(i);
-		      inst = new InstructionCP(i<=Constants.MAX_BYTE?Constants.LDC:Constants.LDC_W,ii);
+			case 5: inst =  InstructionConstants.ICONST_5;	break;
+			default: 
+				if (value <= Byte.MAX_VALUE && value >= Byte.MIN_VALUE) {
+			     	inst =  new InstructionByte(Constants.BIPUSH,(byte)value);
+				} else if (value <= Short.MAX_VALUE && value >= Short.MIN_VALUE) {
+					inst =  new InstructionShort(Constants.SIPUSH,(short)value);
+				} else {
+				      int ii = fact.getClassGen().getConstantPool().addInteger(value);
+				      inst = new InstructionCP(value<=Constants.MAX_BYTE?Constants.LDC:Constants.LDC_W,ii);
+				}
+				break;
 		}
 		return inst;
 	}
@@ -748,7 +744,7 @@ public class Utility {
             // 1. there are no values specified (i.e. @SuppressAjWarnings)
             // 2. there are values specified (i.e. @SuppressAjWarnings("A") or @SuppressAjWarnings({"A","B"})
             List vals = anns[i].getBcelAnnotation().getValues();
-            if (vals == null || vals.size()==0) { // (1)
+            if (vals == null || vals.isEmpty()) { // (1)
                 suppressed = true;
             } else { // (2)
             	// We know the value is an array value
@@ -780,7 +776,7 @@ public class Utility {
             // 1. there are no values specified (i.e. @SuppressAjWarnings)
             // 2. there are values specified (i.e. @SuppressAjWarnings("A") or @SuppressAjWarnings({"A","B"})
             List vals = anns[i].getBcelAnnotation().getValues();
-            if (vals == null || vals.size()==0) { // (1)
+            if (vals == null || vals.isEmpty()) { // (1)
                suppressedWarnings.addAll(lint.allKinds());
             } else { // (2)
             	// We know the value is an array value
@@ -16,7 +16,7 @@ import org.aspectj.util.TypeSafeEnum;
  * An enumeration of the different kinds of pointcut primitives
  * supported by AspectJ.
  */
-public class PointcutPrimitive extends TypeSafeEnum {
+public final class PointcutPrimitive extends TypeSafeEnum {
 
 	public static final PointcutPrimitive CALL = new PointcutPrimitive("call",1);
 	public static final PointcutPrimitive EXECUTION = new PointcutPrimitive("execution",2);
@@ -49,7 +49,6 @@ import org.aspectj.org.eclipse.jdt.internal.core.builder.ReferenceCollection;
 import org.aspectj.org.eclipse.jdt.internal.core.builder.StringSet;
 import org.aspectj.util.FileUtil;
 import org.aspectj.weaver.BCException;
-import org.aspectj.weaver.IWeaver;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.bcel.BcelWeaver;
 import org.aspectj.weaver.bcel.BcelWorld;
@@ -1065,7 +1064,7 @@ public class AjState {
 				for (Iterator iterator = compiledTypes.keySet().iterator(); iterator.hasNext();) {
 					char[] className = (char[])iterator.next();
 					String typeName = new String(className).replace('/','.');
-					if (typeName.indexOf(IWeaver.SYNTHETIC_CLASS_POSTFIX) == -1) {
+					if (typeName.indexOf(BcelWeaver.SYNTHETIC_CLASS_POSTFIX) == -1) {
 						ResolvedType rt = world.resolve(typeName);
 						if (rt.isMissing()) {
 							throw new IllegalStateException("Type '" + rt.getSignature() + "' not found in world!");
@@ -1555,7 +1554,7 @@ public class AjState {
 		public void deleteFromFileSystem() {
 			String namePrefix = locationOnDisk.getName();
 			namePrefix = namePrefix.substring(0,namePrefix.lastIndexOf('.'));
-			final String targetPrefix = namePrefix + IWeaver.CLOSURE_CLASS_PREFIX;
+			final String targetPrefix = namePrefix + BcelWeaver.CLOSURE_CLASS_PREFIX;
 			File dir = locationOnDisk.getParentFile();
 			if (dir != null) {
 				File[] weaverGenerated = dir.listFiles(new FilenameFilter() {
@@ -1,28 +0,0 @@
-/* *******************************************************************
- * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
- * All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://www.eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: 
- *     PARC     initial implementation 
- * ******************************************************************/
-
-
-package org.aspectj.weaver;
-
-/**
- * A weaver is given all the aspects it will weave.  It should create an appropriate kind of 
- * IWorld.  It then should be given a bunch of classes (types with implementation), creates an
- * appropriate IClassWeaver for each such class, and weaves.  The IWeaver is responsible for 
- * IO.
- */
-public interface IWeaver {
-
-	public static final String CLOSURE_CLASS_PREFIX = "$Ajc";
-	
-	public static final String SYNTHETIC_CLASS_POSTFIX = "$ajc";
-	
-}
@@ -67,7 +67,6 @@ import org.aspectj.weaver.CrosscuttingMembersSet;
 import org.aspectj.weaver.CustomMungerFactory;
 import org.aspectj.weaver.IClassFileProvider;
 import org.aspectj.weaver.IWeaveRequestor;
-import org.aspectj.weaver.IWeaver;
 import org.aspectj.weaver.NewParentTypeMunger;
 import org.aspectj.weaver.ReferenceType;
 import org.aspectj.weaver.ReferenceTypeDelegate;
@@ -98,7 +97,12 @@ import org.aspectj.weaver.tools.Trace;
 import org.aspectj.weaver.tools.TraceFactory;
 
 
-public class BcelWeaver implements IWeaver {
+public class BcelWeaver {
+
+	public static final String CLOSURE_CLASS_PREFIX = "$Ajc";
+	
+	public static final String SYNTHETIC_CLASS_POSTFIX = "$ajc";
+	
     private BcelWorld world;
     private CrosscuttingMembersSet xcutSet;
     private IProgressListener progressListener = null;
@@ -45,7 +45,7 @@ import org.aspectj.weaver.ast.Var;
 import org.aspectj.weaver.internal.tools.MatchingContextBasedTest;
 
 // we generate right to left, btw.
-public class BcelRenderer implements ITestVisitor, IExprVisitor {
+public final class BcelRenderer implements ITestVisitor, IExprVisitor {
 
     private InstructionList instructions;
     private InstructionFactory fact;
@@ -868,7 +868,7 @@ class BcelClassWeaver implements IClassWeaver {
 			for (int i = 0; i < paramTypes.length; i++) {
 				UnresolvedType type = paramTypes[i];
 				String s = org.aspectj.apache.bcel.classfile.Utility.signatureToString(type.getSignature());
-				if (s.lastIndexOf(".")!=-1) s =s.substring(s.lastIndexOf(".")+1);
+				if (s.lastIndexOf('.')!=-1) s =s.substring(s.lastIndexOf('.')+1);
 				parmString.append(s);
 				if ((i+1)<paramTypes.length) parmString.append(",");
 			}
@@ -970,7 +970,7 @@ class BcelClassWeaver implements IClassWeaver {
 			}
 			return null;
 		} else {
-			throw new RuntimeException("Not sure what this is: "+methodCtorMunger);
+			throw new BCException("Not sure what this is: "+methodCtorMunger);
 		}
 	}
 
@@ -1519,7 +1519,7 @@ class BcelClassWeaver implements IClassWeaver {
 					}
 					walker = walker.getNext();
 				}
-				if (rets.size()>0) {
+				if (!rets.isEmpty()) {
 					// need to ensure targeters for 'return' now instead target the load instruction
 					// (so we never jump over the monitorexit logic)
 
@@ -1550,7 +1550,7 @@ class BcelClassWeaver implements IClassWeaver {
 									// move it
 									targeter.updateTarget(element, monitorExitBlockStart);
 								} else {
-									throw new RuntimeException("Unexpected targeter encountered during transform: "+targeter);
+									throw new BCException("Unexpected targeter encountered during transform: "+targeter);
 								}
 							}		
 						}
@@ -1730,7 +1730,7 @@ class BcelClassWeaver implements IClassWeaver {
 								// move it
 								targeter.updateTarget(element, monitorExitBlockStart);
 							} else {
-								throw new RuntimeException("Unexpected targeter encountered during transform: "+targeter);
+								throw new BCException("Unexpected targeter encountered during transform: "+targeter);
 							}
 						}		
 					}
@@ -1806,7 +1806,7 @@ class BcelClassWeaver implements IClassWeaver {
 				}
 				walker = walker.getNext();
 			}
-			if (rets.size()>0) {
+			if (!rets.isEmpty()) {
 				// need to ensure targeters for 'return' now instead target the load instruction
 				// (so we never jump over the monitorexit logic)
 
@@ -1838,7 +1838,7 @@ class BcelClassWeaver implements IClassWeaver {
 								// move it
 								targeter.updateTarget(element, monitorExitBlockStart);
 							} else {
-								throw new RuntimeException("Unexpected targeter encountered during transform: "+targeter);
+								throw new BCException("Unexpected targeter encountered during transform: "+targeter);
 							}
 						}		
 					}
@@ -129,7 +129,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
     // This set contains pairs of types whose signatures are concatenated
     // together, this means with a fast lookup we can tell if two types
     // are equivalent.
-    static Set validBoxing = new HashSet();
+    protected static Set validBoxing = new HashSet();
 
     static {
       validBoxing.add("Ljava/lang/Byte;B");
@@ -2185,7 +2185,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 
 	protected Map getAjMemberParameterizationMap() {
 		Map myMap = getMemberParameterizationMap();
-		if (myMap.size() == 0) {
+		if (myMap.isEmpty()) {
 			// might extend a parameterized aspect that we also need to consider...
 			if (getSuperclass() != null) return getSuperclass().getAjMemberParameterizationMap();
 		}
@@ -14,7 +14,7 @@
 package org.aspectj.weaver.ast;
 
 
-public class Literal extends Test {
+public final class Literal extends Test {
 
 	boolean noTest;
 	boolean val;
@@ -1,21 +0,0 @@
-/* *******************************************************************
- * Copyright (c) 2008 Contributors
- * All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://www.eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: 
- *     Andy Clement     initial implementation 
- * ******************************************************************/
-package org.aspectj.weaver;
-
-/**
- * Marker interface for entities that are not resolved.
- * 
- * @author Andy Clement
- */
-public interface Unresolved {
-
-}
@@ -94,7 +94,7 @@ import org.aspectj.weaver.tools.Traceable;
  * The wildcard ? extends Foo has signature +LFoo;
  * The wildcard ? super Foo has signature -LFoo;
  */
-public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclaringElement {
+public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 
 	// common types referred to by the weaver
     public static final UnresolvedType[] NONE         = new UnresolvedType[0];
@@ -18,7 +18,7 @@ package org.aspectj.weaver;
  * 
  * @author Andy Clement
  */
-public class WildcardedUnresolvedType extends UnresolvedType implements Unresolved {
+public class WildcardedUnresolvedType extends UnresolvedType {
 
     // TODO does not cope with extra bounds '? extends A & B & C'
 
@@ -15,7 +15,7 @@ package org.aspectj.weaver.tools;
 /** 
  * This class implements a boolean that includes a "maybe"
  */
-public class FuzzyBoolean {
+public final class FuzzyBoolean {
 
 	// Note :- this implementation is not safe under serialization / deserialization
 	private String name;
@@ -19,7 +19,7 @@ import org.aspectj.weaver.ast.Var;
 /**
  * A variable at a reflection shadow, used by the residual tests.
  */
-public class ReflectionVar extends Var {
+public final class ReflectionVar extends Var {
 
 	static final int THIS_VAR = 0;
 	static final int TARGET_VAR = 1;
@@ -14,7 +14,7 @@
 package org.aspectj.weaver.patterns;
 
 
-public class BasicToken implements IToken {
+public final class BasicToken implements IToken {
 	private String value;
 	private boolean isIdentifier;
 	private String literalKind;
@@ -1,95 +0,0 @@
-/* *******************************************************************
- * Copyright (c) 2006 Contributors
- * All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://www.eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: 
- *     Andy Clement IBM     initial implementation 
- * ******************************************************************/
-package org.aspectj.weaver;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * Can store annotations for any member and ensures they are resolved/unpacked as lazily as possible.
- * The set of annotations is unpacked *once* then discarded, so ensure all annotations have been
- * added via 'addAnnotation()' before calling the public accessor
- * methods 'hasAnnotation/getAnnotations/getAnnotationTypes'
- * 
- * @author AndyClement
- */
-public class AnnotationsForMemberHolder {
-
-	private boolean annotationTypesCorrect = false; // guard for lazy initialization of annotationTypes
-	private ResolvedType[] annotationTypes;
-	private boolean annotationXsCorrect = false;
-	private AnnotationX[] annotationXs;
-	public List /*AnnotationAJ*/ annotations   = null;
-	private World world;
-	
-	public AnnotationsForMemberHolder(World w) {
-		this.world = w;
-	}
-	
-	public AnnotationX[] getAnnotations() {
-		ensureAnnotationXsUnpacked();
-		return annotationXs;
-	}
-
-	public ResolvedType[] getAnnotationTypes() {
-		ensureAnnotationsUnpacked();
-		return annotationTypes;
-	}
-	
-	public boolean hasAnnotation(UnresolvedType ofType) {
-		ensureAnnotationsUnpacked();
-		for (int i = 0; i < annotationTypes.length; i++) {
-			if (annotationTypes[i].equals(ofType)) return true;
-		}
-		return false;
-	}
-	
-	private void ensureAnnotationXsUnpacked() {
-		if (annotationTypesCorrect && annotationXsCorrect) return;
-		ensureAnnotationsUnpacked();
-		if (annotations==null) {
-			annotationXs = AnnotationX.NONE;
-		} else {
-			annotationXs = new AnnotationX[annotations.size()];
-			int pos = 0;
-			for (Iterator iter = annotations.iterator(); iter.hasNext();) {
-				AnnotationAJ element = (AnnotationAJ) iter.next();
-				annotationXs[pos++] = new AnnotationX(element,world);
-			}
-			annotations=null; // finished with
-		}
-		annotationXsCorrect = true;
-	}
-	
-	
-  private void ensureAnnotationsUnpacked() {
-	if (annotationTypesCorrect) return;
-	if (annotations==null) {
-		annotationTypes = ResolvedType.NONE;
-	} else {
-		annotationTypes = new ResolvedType[annotations.size()];
-		int pos = 0;
-		for (Iterator iter = annotations.iterator(); iter.hasNext();) {
-			AnnotationAJ element = (AnnotationAJ) iter.next();
-			annotationTypes[pos++] = world.resolve(UnresolvedType.forSignature(element.getTypeSignature()));
-		}
-	}
-	annotationTypesCorrect = true;
-  }
-
-	public void addAnnotation(AnnotationAJ oneAnnotation) {
-		if (annotations==null) annotations = new ArrayList();
-		annotations.add(oneAnnotation);
-	}
-
-}
@@ -18,9 +18,7 @@ import java.lang.reflect.Modifier;
 import org.aspectj.weaver.bcel.LazyClassGen;
 
 public class NameMangler {
-	private NameMangler() {
-		throw new RuntimeException("static");
-	}
+	
 	public static final char[] AJC_DOLLAR_PREFIX = {'a', 'j', 'c','$'};
 	public static final char[] CLINIT={'<','c','l','i','n','i','t','>'};
 	public static final String PREFIX = "ajc$";
@@ -28,9 +28,9 @@ import org.aspectj.weaver.patterns.PerClause;
  */
 public class BoundedReferenceType extends ReferenceType {
 
-    private UnresolvedType lowerBound;
+    private ResolvedType lowerBound;
 
-    private UnresolvedType upperBound;
+    private ResolvedType upperBound;
 
     protected ReferenceType[] additionalInterfaceBounds = new ReferenceType[0];
 
@@ -2147,7 +2147,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 						boolean b = false;
 						UnresolvedType upperBound = boundedRT.getUpperBound();
 						if (upperBound.isParameterizedType()) {
-							b = upperBound.isParameterizedWithAMemberTypeVariable();
+							b = ((ResolvedType)upperBound).isParameterizedWithAMemberTypeVariable();
 						} else if (upperBound.isTypeVariableReference() && ((TypeVariableReference)upperBound).getTypeVariable().getDeclaringElementKind()==TypeVariable.METHOD) {
 							b = true;
 						}
@@ -2161,7 +2161,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 						boolean b = false;
 						UnresolvedType lowerBound = boundedRT.getLowerBound();
 						if (lowerBound.isParameterizedType()) {
-							b = lowerBound.isParameterizedWithAMemberTypeVariable();
+							b = ((ResolvedType)lowerBound).isParameterizedWithAMemberTypeVariable();
 						} else if (lowerBound.isTypeVariableReference() && ((TypeVariableReference)lowerBound).getTypeVariable().getDeclaringElementKind()==TypeVariable.METHOD) {
 							b = true;
 						}
@@ -147,25 +147,10 @@ public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclar
 	 * Iff isParameterized(), then these are the type variables bound as parameters
 	 * in the type 
 	 */
+	// OPTIMIZE should be no state in here that will damage whether equals() is correct...
 	protected TypeVariable[] typeVariables;
 
 
-   /**
-     * Determines if this represents a primitive type.  A primitive type
-     * is one of nine predefined resolved types.
-     *
-     * @return true iff this type represents a primitive type
-     *
-     * @see     ResolvedType#Boolean
-     * @see     ResolvedType#Character
-     * @see     ResolvedType#Byte
-     * @see     ResolvedType#Short
-     * @see     ResolvedType#Integer
-     * @see     ResolvedType#Long
-     * @see     ResolvedType#Float
-     * @see     ResolvedType#Double
-     * @see     ResolvedType#Void
-     */   
     public boolean isPrimitiveType()          { return typeKind == TypeKind.PRIMITIVE; }
     public boolean isSimpleType()             { return typeKind == TypeKind.SIMPLE; }
     public boolean isRawType()                { return typeKind == TypeKind.RAW; }
@@ -197,18 +182,8 @@ public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclar
         return signature.hashCode();
     }
 
-    /**
-     * Return a version of this parameterized type in which any type parameters
-     * that are type variable references are replaced by their matching type variable
-     * binding.
-     */
-    // OPTIMIZE methods like this just allow callers to be lazy and not ensure they are working with the right (resolved) subtype
-    public UnresolvedType parameterize(Map typeBindings) {
-    	throw new UnsupportedOperationException("unable to parameterize unresolved type: " + signature);
-    }
 
     protected UnresolvedType(String signature) {
-        super();
         this.signature = signature;
         this.signatureErasure = signature;
     }
@@ -506,10 +481,6 @@ public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclar
     }
 
 
-//	public String getParameterizedSignature() {
-//		return signature;
-//	}
-	
 	/**
 	 * For parameterized types, return the signature for the raw type
 	 */
@@ -822,16 +793,6 @@ public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclar
 		private final String type;
 	}
 
-	/**
-	 * Will return true if the type being represented is parameterized with a type variable
-	 * from a generic method/ctor rather than a type variable from a generic type.  
-	 * Only subclasses know the answer...
-	 */
-	// OPTIMIZE don't allow this to be called, the caller must have a resolved entity
-	public boolean isParameterizedWithAMemberTypeVariable() {
-		throw new RuntimeException("I dont know - you should ask a resolved version of me: "+this);
-	}
-	
 	public TypeVariable getTypeVariableNamed(String name) {
 		TypeVariable[] vars = getTypeVariables();
 		if (vars==null || vars.length==0) return null;
@@ -846,5 +807,14 @@ public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclar
 		return getClass().getName() + "[" + getName() + "]";
 	}
 
+    /**
+     * Return a version of this parameterized type in which any type parameters
+     * that are type variable references are replaced by their matching type variable
+     * binding.
+     */
+    // OPTIMIZE methods like this just allow callers to be lazy and not ensure they are working with the right (resolved) subtype
+    public UnresolvedType parameterize(Map typeBindings) {
+    	throw new UnsupportedOperationException("unable to parameterize unresolved type: " + signature);
+    }
 }
 
@@ -15,6 +15,7 @@
 
 package org.aspectj.ajdt.internal.compiler.lookup;
 
+import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -977,7 +978,7 @@ public class EclipseFactory {
 	}
 
 	public MethodBinding makeMethodBindingForCall(Member member) {
-		return new MethodBinding(member.getCallsiteModifiers(),
+		return new MethodBinding(member.getModifiers() & ~ Modifier.INTERFACE,
 				member.getName().toCharArray(),
 				makeTypeBinding(member.getReturnType()),
 				makeTypeBindings(member.getParameterTypes()),
@@ -308,10 +308,6 @@ public class JoinPointSignature implements ResolvedMember {
 		return realMember.canBeParameterized();
 	}
 
-	public int getCallsiteModifiers() {
-		return realMember.getCallsiteModifiers();
-	}
-
 	public String getExtractableName() {
 		return realMember.getExtractableName();
 	}
@@ -16,6 +16,9 @@ package org.aspectj.weaver;
 import java.util.Collection;
 import java.util.Iterator;
 
+/**
+ * Abstract representation of a member within a type.
+ */
 public interface Member extends Comparable {
 
 	public static final Member[] NONE = new Member[0];
@@ -53,16 +56,12 @@ public interface Member extends Comparable {
 
 	public UnresolvedType[] getParameterTypes();
 
-	
 	/**
-	 * Return full signature, including return type, e.g. "()LFastCar;" for a signature without the return type,
-	 * use getParameterSignature() - it is importnant to choose the right one in the face of covariance.
+	 * Return full signature, including return type, e.g. "()LFastCar;". For a signature without the return type,
+	 * use getParameterSignature() - it is important to choose the right one in the face of covariance.
 	 */
 	public String getSignature();
 
-    /**
-     * All the signatures that a join point with this member as its signature has.
-     */
     public Iterator getJoinPointSignatures(World world);
 
 	public int getArity();
@@ -79,7 +78,6 @@ public interface Member extends Comparable {
 
 	public int getModifiers();
 
-
     public boolean isStatic();
 
     public boolean isInterface();
@@ -88,12 +86,9 @@ public interface Member extends Comparable {
 
 	/**
 	 * Returns true iff the member is generic (NOT parameterized)
-	 * For example, a method declared in a generic type
 	 */
 	public boolean canBeParameterized();
 
-	public int getCallsiteModifiers();
-
 	public String getExtractableName();
 
     public AnnotationX[] getAnnotations();
@@ -102,7 +97,6 @@ public interface Member extends Comparable {
 	public String getSignatureMakerName();
 
 	public String getSignatureType();
-
 
     public Collection/* ResolvedType */getDeclaringTypes(World world);
 
@@ -10,7 +10,6 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.weaver;
 
 import java.lang.reflect.Modifier;
@@ -20,14 +19,14 @@ import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 
-
 public class MemberImpl implements Member {
 
     protected MemberKind kind;
-    protected String name;
-    protected UnresolvedType declaringType;
+
     protected int modifiers; 
+    protected String name;
     protected UnresolvedType returnType;
+    protected UnresolvedType declaringType;
     protected UnresolvedType[] parameterTypes;
     private final String signature;
     private String paramSignature;
@@ -111,6 +110,7 @@ public class MemberImpl implements Member {
      * @param      signature the JVM bytecode method signature string we want to break apart
      * @return     a pair of UnresolvedType, UnresolvedType[] representing the return types and parameter types. 
      */
+    // OPTIMIZE move static util methods out into a memberutils class
     public static String typesToSignature(UnresolvedType returnType, UnresolvedType[] paramTypes, boolean useRawTypes) {
         StringBuffer buf = new StringBuffer();
         buf.append("(");
@@ -365,27 +365,14 @@ public class MemberImpl implements Member {
 
     public UnresolvedType getGenericReturnType() { return getReturnType(); }
     public UnresolvedType[] getGenericParameterTypes() { return getParameterTypes(); }
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getType()
-	 */
-    public UnresolvedType getType() { return returnType; }
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getName()
-	 */
+    public final UnresolvedType getType() { return returnType; }
     public String getName() { return name; }
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getParameterTypes()
-	 */
     public UnresolvedType[]  getParameterTypes() { return parameterTypes; }
-    
-    
+        
     public String getSignature() { return signature; }
 
     public int getArity() { return parameterTypes.length; }
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getParameterSignature()
-	 */
     public String getParameterSignature() {
     	if (paramSignature != null) return paramSignature;
     	StringBuffer sb = new StringBuffer();
@@ -460,17 +447,10 @@ public class MemberImpl implements Member {
     	return false;
     }
 
-	public final int getCallsiteModifiers() {
-		return modifiers & ~ Modifier.INTERFACE;
-	}
-	
 	public int getModifiers() {
 		return modifiers;
 	}
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getExtractableName()
-	 */
     public final String getExtractableName() {
     // OPTIMIZE remove silly string compares for init - use kind==CTOR/STATIC_INITIALIZATION
     	if (name.equals("<init>")) return "init$";
@@ -478,21 +458,12 @@ public class MemberImpl implements Member {
     	else return name;
     }
 
-    
-	/* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getAnnotations()
-	 */
 	public AnnotationX[] getAnnotations() {
 		throw new UnsupportedOperationException("You should resolve this member '"+this+"' and call getAnnotations() on the result...");
 	}
 
 	// ---- fields 'n' stuff
 
-
-    
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getDeclaringTypes(org.aspectj.weaver.World)
-	 */
 	public Collection/*ResolvedType*/ getDeclaringTypes(World world) {
 		ResolvedType myType = getDeclaringType().resolve(world);
 		Collection ret = new HashSet();
@@ -574,11 +545,6 @@ public class MemberImpl implements Member {
     }
 
 
-
-
-	/* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getSignatureType()
-	 */
 	public String getSignatureType() {
     	MemberKind kind = getKind();
     	if (getName().equals("<clinit>")) return "org.aspectj.lang.reflect.InitializerSignature";
@@ -790,9 +756,6 @@ public class MemberImpl implements Member {
         return buf.toString();
     }
 
-	/* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getParameterNames(org.aspectj.weaver.World)
-	 */
 	public String[] getParameterNames(World world) {
     	ResolvedMember resolved = resolve(world);
     	if (resolved == null) {
@@ -33,7 +33,8 @@ public interface ResolvedMember extends Member, AnnotatedElement, TypeVariableDe
 	public UnresolvedType[] getExceptions();
 
 	public ShadowMunger getAssociatedShadowMunger();
-//OPTIMIZE have param annotation (and anno default value) related stuff here rather than above
+	
+	//OPTIMIZE have param annotation (and anno default value) related stuff here rather than above
 	// ??? true or false?
 	public boolean isAjSynthetic();
 
@@ -41,6 +42,8 @@ public interface ResolvedMember extends Member, AnnotatedElement, TypeVariableDe
 
 	public boolean hasAnnotation(UnresolvedType ofType);
 
+	public AnnotationX[] getAnnotations();
+	
 	public ResolvedType[] getAnnotationTypes();
 
 	public void setAnnotationTypes(UnresolvedType[] annotationtypes);
@@ -981,7 +981,7 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 	   }
 
 	   // 'declaring' type
-	   r.append(getGenericReturnType().toDebugString());
+	   r.append(getGenericReturnType().toString());
    	   r.append(' ');
 
    	   // name
@@ -997,7 +997,7 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
          if (params.length != 0) {
        	   for (int i=0, len = params.length; i < len; i++) {
              if (i>0) r.append(", ");
-       		 r.append(params[i].toDebugString());
+       		 r.append(params[i].toString());
        		 if (parameterNamesExist) r.append(" ").append(parameterNames[i]);
        	   }
          }
@@ -28,7 +28,7 @@ import org.aspectj.weaver.tools.Traceable;
  * A UnresolvedType represents a type to the weaver. It has a basic signature that knows 
  * nothing about type variables, type parameters, etc.. UnresolvedTypes are resolved in some World
  * (a repository of types). When a UnresolvedType is resolved it turns into a 
- * ResolvedType which may be a primitive type, an array type or a ReferenceType. 
+ * ResolvedType which may be a primitive type, or a ReferenceType. 
  * ReferenceTypes may refer to simple, generic, parameterized or type-variable
  * based reference types. A ReferenceType is backed by a delegate that provides 
  * information about the type based on some repository (currently either BCEL
@@ -207,34 +207,6 @@ public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclar
     	throw new UnsupportedOperationException("unable to parameterize unresolved type: " + signature);
     }
 
-    /**
-     * protected constructor for use only within UnresolvedType hierarchy. Use
-     * one of the UnresolvedType.forXXX static methods for normal creation of
-     * TypeXs.
-     * Picks apart the signature string to set the type kind and calculates the
-     * corresponding signatureErasure. A SIMPLE type created from a plain
-     * Java signature may turn into a GENERIC type when it is resolved.
-     * 
-     * This method should never be called for a primitive type. (UnresolvedType. forSignature
-     * deals with those).
-     * 
-     * @param signature in the form described in the class comment at the
-     * top of this file. 
-     */
-//    protected UnresolvedType(String aSignature) {
-//    	this.signature = aSignature;
-//
-//
-//    }
-    
-    // -----------------------------
-    // old stuff...
-    
-
-	
-	/**
-	 * @param      signature   the bytecode string representation of this Type
-	 */
     protected UnresolvedType(String signature) {
         super();
         this.signature = signature;
@@ -599,10 +571,6 @@ public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclar
     public String toString() {
         return getName(); // + " - " + getKind();
     }
-    
-    public String toDebugString() {
-    	return getName();
-    }
 
     // ---- requires worlds
 
@@ -94,7 +94,9 @@ public class BcelAdvice extends Advice {
 		}
 		return m;
 	}
-	// !!! must only be used for testing
+	/**
+	 * For testing only
+	 */
 	public BcelAdvice(AdviceKind kind, Pointcut pointcut, Member signature,
 		int extraArgumentFlags,
         int start, int end, ISourceContext sourceContext, ResolvedType concreteAspect)
@@ -444,57 +444,22 @@ public class MemberImpl implements Member {
 		return resolved.getExceptions();
     }
 
-    // OPTIMIZE remove world related isMethods()
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#isProtected(org.aspectj.weaver.World)
-	 */
-    public final boolean isProtected(World world) {
-        return Modifier.isProtected(resolve(world).getModifiers());
-    }
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#isStatic(org.aspectj.weaver.World)
-	 */
-    public final boolean isStatic(World world) {
-        return Modifier.isStatic(resolve(world).getModifiers());
-    }
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#isStrict(org.aspectj.weaver.World)
-	 */
-    public final boolean isStrict(World world) {
-        return Modifier.isStrict(resolve(world).getModifiers());
-    }
-    
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#isStatic()
-	 */
     public final boolean isStatic() {
         return Modifier.isStatic(modifiers);
     }    
-    
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#isInterface()
-	 */
+
     public final boolean isInterface() {
         return Modifier.isInterface(modifiers);  // this is kinda weird
     }    
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#isPrivate()
-	 */
     public final boolean isPrivate() {
         return Modifier.isPrivate(modifiers);
     }    
-    
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#canBeParameterized()
-	 */
+
     public boolean canBeParameterized() {
     	return false;
     }
 
-	/* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getCallsiteModifiers()
-	 */
 	public final int getCallsiteModifiers() {
 		return modifiers & ~ Modifier.INTERFACE;
 	}
@@ -117,6 +117,7 @@ public abstract class World implements Dump.INode {
 	private boolean runMinimalMemory = false;
 	private boolean shouldPipelineCompilation = true;
 	protected boolean bcelRepositoryCaching = xsetBCEL_REPOSITORY_CACHING_DEFAULT.equalsIgnoreCase("true");
+	private boolean fastMethodPacking = false; 
 	private boolean completeBinaryTypes = false;
 	public boolean forDEBUG_structuralChangesCode = false;
 	public boolean forDEBUG_bridgingCode = false;
@@ -810,6 +811,7 @@ public abstract class World implements Dump.INode {
 	public final static String xsetCOMPLETE_BINARY_TYPES = "completeBinaryTypes";
 	public final static String xsetCOMPLETE_BINARY_TYPES_DEFAULT = "false"; 
 	public final static String xsetBCEL_REPOSITORY_CACHING_DEFAULT = "true"; 
+	public final static String xsetFAST_PACK_METHODS = "fastPackMethods";  // default TRUE
 
 	public boolean isInJava5Mode() {
 		return behaveInJava5Way;
@@ -1218,6 +1220,9 @@ public abstract class World implements Dump.INode {
 				if (!bcelRepositoryCaching) {
 					getMessageHandler().handleMessage(MessageUtil.info("[bcelRepositoryCaching=false] AspectJ will not use a bcel cache for class information"));
 				}
+
+				s = p.getProperty(xsetFAST_PACK_METHODS,"true");
+				fastMethodPacking = s.equalsIgnoreCase("true");
 
 				s = p.getProperty(xsetPIPELINE_COMPILATION,xsetPIPELINE_COMPILATION_DEFAULT);
 				shouldPipelineCompilation = s.equalsIgnoreCase("true");
@@ -1249,6 +1254,11 @@ public abstract class World implements Dump.INode {
 	      ensureAdvancedConfigurationProcessed();
 	    	  return runMinimalMemory;
 	    }
+
+    public boolean shouldFastPackMethods() {
+        ensureAdvancedConfigurationProcessed();
+        return fastMethodPacking;
+    }
 
 	    public boolean shouldPipelineCompilation() {
 	    	ensureAdvancedConfigurationProcessed();
@@ -47,6 +47,7 @@ import org.aspectj.apache.bcel.generic.LocalVariableTag;
 import org.aspectj.apache.bcel.generic.MethodGen;
 import org.aspectj.apache.bcel.generic.ObjectType;
 import org.aspectj.apache.bcel.generic.Tag;
+import org.aspectj.apache.bcel.generic.TargetLostException;
 import org.aspectj.apache.bcel.generic.Type;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
@@ -96,8 +97,8 @@ public final class LazyMethodGen implements Traceable {
     private BcelMethod memberView;
     private AjAttribute.EffectiveSignatureAttribute effectiveSignature;
     int highestLineNumber = 0;
+    boolean wasPackedOptimally = false;
 
-
     /*
      * We use LineNumberTags and not Gens.
      * 
@@ -433,7 +434,8 @@ public final class LazyMethodGen implements Traceable {
 
     	try {
 			MethodGen gen = pack();
-			return gen.getMethod();
+			savedMethod = gen.getMethod();
+			return savedMethod;
     	} catch (ClassGenException e) {
     		enclosingClass.getBcelObjectType().getResolvedTypeX().getWorld().showMessage(
     			IMessage.ERROR, 
@@ -450,6 +452,9 @@ public final class LazyMethodGen implements Traceable {
     }
 
     public void markAsChanged() {
+    	if (wasPackedOptimally) {
+    		throw new RuntimeException("Already packed method is being re-modified: "+getClassName()+" "+toShortString());
+    	}
     	initialize();
     	savedMethod = null;
     }
@@ -933,7 +938,15 @@ public final class LazyMethodGen implements Traceable {
         }
 
         if (hasBody()) {
-            packBody(gen);
+        	if (this.enclosingClass.getWorld().shouldFastPackMethods()) {
+	            if (isAdviceMethod() || getName().equals("<clinit>")) {
+	        		packBody(gen);
+	        	} else {
+	        		optimizedPackBody(gen); 
+	        	}
+        	} else {
+        		packBody(gen);
+        	}
             gen.setMaxLocals();
             gen.setMaxStack();
         } else {
@@ -1046,6 +1059,108 @@ public final class LazyMethodGen implements Traceable {
         }
     }
 
+
+    /*
+     * Optimized packing that does a 'local packing' of the code rather than building a brand new method
+     * and packing into it.  Only usable when the packing is going to be done just once.
+     */
+    public void optimizedPackBody(MethodGen gen) {
+    	InstructionList theBody = getBody();
+        InstructionHandle iHandle = theBody.getStart();
+
+        int currLine = -1;
+		int lineNumberOffset = (fromFilename == null) ? 0: getEnclosingClass().getSourceDebugExtensionOffset(fromFilename);
+        Map localVariables = new HashMap();
+        LinkedList exceptionList = new LinkedList();   
+        Set forDeletion = new HashSet();
+        Set branchInstructions = new HashSet();
+        // OPTIMIZE sort out in here: getRange()/insertHandler() and type of exceptionList
+        while (iHandle != null) {
+        	Instruction inst = iHandle.getInstruction();
+        	InstructionHandle nextInst = iHandle.getNext();
+        	// OPTIMIZE remove this instructionhandle as it now points to nowhere?
+        	if (inst == Range.RANGEINSTRUCTION) {
+        		Range r = Range.getRange(iHandle);
+	    		if (r instanceof ExceptionRange) {
+	    		    ExceptionRange er = (ExceptionRange) r;
+	    		    if (er.getStart() == iHandle) {
+	    		    	if (!er.isEmpty()){
+	    		        	// order is important, insert handlers in order of start
+	    		        	insertHandler(er, exceptionList);	    	      
+	    		    	}
+	    		    }
+	    		} 
+    			forDeletion.add(iHandle);
+    		} else {
+    			if (inst instanceof InstructionBranch) {
+    				branchInstructions.add(iHandle);
+    			}
+
+              InstructionTargeter[] targeters = iHandle.getTargeters();
+              if (targeters != null) {
+                  for (int k = targeters.length - 1; k >= 0; k--) {
+                      InstructionTargeter targeter = targeters[k];
+                      if (targeter instanceof LineNumberTag) {
+                          int line = ((LineNumberTag)targeter).getLineNumber();
+                          if (line != currLine) {
+                              gen.addLineNumber(iHandle, line + lineNumberOffset);
+                              currLine = line;
+                          }
+                      } else if (targeter instanceof LocalVariableTag) {
+                          LocalVariableTag lvt = (LocalVariableTag) targeter;
+                          LVPosition p = (LVPosition)localVariables.get(lvt);
+                          // If we don't know about it, create a new position and store
+                          // If we do know about it - update its end position
+                          if (p==null) {
+                          	LVPosition newp = new LVPosition();
+                          	newp.start=newp.end=iHandle;
+                          	localVariables.put(lvt,newp);
+                          } else {
+                          	p.end = iHandle;
+                          }
+                      }
+                  }
+              }
+    		}
+        	iHandle = iHandle.getNext();
+        }
+        for (Iterator iterator = branchInstructions.iterator(); iterator.hasNext();) {
+			BranchHandle iBranch = (BranchHandle) iterator.next();
+			handleBranchInstruction(iBranch,forDeletion);
+		}
+    	// now add exception handlers
+        for (Iterator iter = exceptionList.iterator(); iter.hasNext();) {
+            ExceptionRange r = (ExceptionRange) iter.next();
+            if (r.isEmpty()) continue;
+            gen.addExceptionHandler(
+                jumpForward(r.getRealStart(),forDeletion), 
+                jumpForward(r.getRealEnd(),forDeletion),
+                jumpForward(r.getHandler(),forDeletion),
+                (r.getCatchType() == null)
+                ? null 
+                : (ObjectType) BcelWorld.makeBcelType(r.getCatchType()));
+        }
+        
+        for (Iterator iterator = forDeletion.iterator(); iterator.hasNext();) {
+        	try {
+				theBody.delete((InstructionHandle)iterator.next());
+			} catch (TargetLostException e) {
+				e.printStackTrace();
+			}
+        }
+        gen.setInstructionList(theBody);
+        addLocalVariables(gen,localVariables);
+        
+        // JAVAC adds line number tables (with just one entry) to generated accessor methods - this
+        // keeps some tools that rely on finding at least some form of linenumbertable happy.
+        // Let's check if we have one - if we don't then let's add one.
+        // TODO Could be made conditional on whether line debug info is being produced
+        if (gen.getLineNumbers().length==0) { 
+        	gen.addLineNumber(gen.getInstructionList().getStart(),1);
+        }
+        wasPackedOptimally = true;
+    }
+    
     private void addLocalVariables(MethodGen gen, Map localVariables) {
 		// now add local variables
         gen.removeLocalVariables();
@@ -1118,6 +1233,44 @@ public final class LazyMethodGen implements Traceable {
 	        }
 	    }
 	}
+	
+	private InstructionHandle jumpForward(InstructionHandle t,Set handlesForDeletion) {
+		
+		InstructionHandle target = t;
+		  if (handlesForDeletion.contains(target)) {
+		    	do {
+		    		target = target.getNext();
+		    	} while (handlesForDeletion.contains(target));
+		    }
+		  return target;
+	}
+	
+	private void handleBranchInstruction(BranchHandle branchHandle, Set handlesForDeletion) {
+		InstructionBranch branchInstruction = (InstructionBranch) branchHandle.getInstruction();
+	    InstructionHandle target = branchInstruction.getTarget(); // old target
+   
+	    if (handlesForDeletion.contains(target)) {
+	    	do {
+	    		target = target.getNext();
+	    	} while (handlesForDeletion.contains(target));
+	    	branchInstruction.setTarget(target);
+	    }
+   
+	    if (branchInstruction instanceof InstructionSelect) { 
+	        // Either LOOKUPSWITCH or TABLESWITCH
+	        InstructionHandle[] targets = ((InstructionSelect)branchInstruction).getTargets();
+	        for (int k = targets.length - 1; k >= 0; k--) { 
+	        	InstructionHandle oneTarget = targets[k];
+	        	if (handlesForDeletion.contains(oneTarget)) {
+	    	    	do {
+	    	    		oneTarget = oneTarget.getNext();
+	    	    	} while (handlesForDeletion.contains(oneTarget));
+	    	    	branchInstruction.setTarget(oneTarget);
+	    	    	oneTarget.addTargeter(branchInstruction);
+	    	    }
+	        }
+	    }
+	}
 
 	private void handleRangeInstruction(InstructionHandle ih, LinkedList exnList) {
 		// we're a range instruction
@@ -1181,6 +1334,13 @@ public final class LazyMethodGen implements Traceable {
 //			curr = next;
 //    	}
 //	}
+   
+   private static InstructionHandle fNext(InstructionHandle ih) {
+	   while (true) {
+		   if (ih.getInstruction()==Range.RANGEINSTRUCTION) ih = ih.getNext();
+		   else return ih;
+	   }
+   }
 
     private static InstructionHandle remap(InstructionHandle ih, Map map) {
         while (true) {
@@ -16,7 +16,7 @@ package org.aspectj.weaver;
 import java.util.Collection;
 import java.util.Iterator;
 
-public interface Member {
+public interface Member extends Comparable {
 
 	public static final Member[] NONE = new Member[0];
 	public static final MemberKind METHOD = new MemberKind("METHOD", 1);
@@ -36,7 +36,7 @@ public interface Member {
 
 	public ResolvedMember resolve(World world);
 
-	public int compareTo(Object other);
+    public int compareTo(Object other);
 
 	public String toLongString();
 
@@ -53,10 +53,6 @@ public interface Member {
 
 	public UnresolvedType[] getParameterTypes();
 
-	public AnnotationX[][] getParameterAnnotations();
-	public ResolvedType[][] getParameterAnnotationTypes();
-	
-	public String getAnnotationDefaultValue();
 
 	/**
 	 * Return full signature, including return type, e.g. "()LFastCar;" for a signature without the return type,
@@ -83,7 +79,6 @@ public interface Member {
 
 	public int getModifiers();
 
-	public UnresolvedType[] getExceptions(World world);
 
     public boolean isStatic();
 
@@ -101,28 +96,19 @@ public interface Member {
 
 	public String getExtractableName();
 
-	/**
-	 * If you want a sensible answer, resolve the member and call
-	 * hasAnnotation() on the ResolvedMember.
-	 */
-	public boolean hasAnnotation(UnresolvedType ofType);
-
-	/* (non-Javadoc)
-	 * @see org.aspectj.weaver.AnnotatedElement#getAnnotationTypes()
-	 */
-	public ResolvedType[] getAnnotationTypes();
-
-	public AnnotationX[] getAnnotations();
-
-	public Collection/*ResolvedType*/getDeclaringTypes(World world);
+    public AnnotationX[] getAnnotations();
 
 	// ---- reflective thisJoinPoint stuff
 	public String getSignatureMakerName();
 
 	public String getSignatureType();
 
+	
+    public Collection/* ResolvedType */getDeclaringTypes(World world);
+    
 	public String getSignatureString(World world);
 
 	public String[] getParameterNames(World world);
 
+    public UnresolvedType[] getExceptions(World world);
 }
\ No newline at end of file
@@ -21,7 +21,7 @@ import java.util.Iterator;
 import java.util.List;
 
 
-public class MemberImpl implements Comparable, AnnotatedElement,Member {
+public class MemberImpl implements Member {
 
     protected MemberKind kind;
     protected String name;
@@ -91,13 +91,10 @@ public class MemberImpl implements Comparable, AnnotatedElement,Member {
         }
     }
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#resolve(org.aspectj.weaver.World)
-	 */
     public ResolvedMember resolve(World world) {
     	return world.resolve(this);
     }
-
+     
     // ---- utility methods
 
     /** returns an Object[] pair of UnresolvedType, UnresolvedType[] representing return type, 
@@ -303,17 +300,15 @@ public class MemberImpl implements Comparable, AnnotatedElement,Member {
         return hashCode;
     }
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#compareTo(java.lang.Object)
-	 */
-    public int compareTo(Object other) {
-    	Member o = (Member) other;
-    	
-    	int i = getName().compareTo(o.getName());
-    	if (i != 0) return i;
-    	return getSignature().compareTo(o.getSignature());
+
+     public int compareTo(Object other) {
+        Member o = (Member) other;
+
+        int i = getName().compareTo(o.getName());
+        if (i != 0) return i;
+        return getSignature().compareTo(o.getSignature());
     }
-    
+
     public String toString() {
     	StringBuffer buf = new StringBuffer();
     	buf.append(returnType.getName());
@@ -383,19 +378,7 @@ public class MemberImpl implements Comparable, AnnotatedElement,Member {
 	 */
     public UnresolvedType[]  getParameterTypes() { return parameterTypes; }
 
-    public AnnotationX[][] getParameterAnnotations() {
-		throw new UnsupportedOperationException("You should resolve this member and call getParameterAnnotations() on the result...");
-    }
-    public ResolvedType[][] getParameterAnnotationTypes() { 
-		throw new UnsupportedOperationException("You should resolve this member and call getParameterAnnotationTypes() on the result...");
-    }
-    public String getAnnotationDefaultValue() { 
-		throw new UnsupportedOperationException("You should resolve this member and call getAnnotationDefaultValue() on the result...");
-    }
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#getSignature()
-	 */
     public String getSignature() { return signature; }
 
     public int getArity() { return parameterTypes.length; }
@@ -530,21 +513,6 @@ public class MemberImpl implements Comparable, AnnotatedElement,Member {
     	else return name;
     }
 
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#hasAnnotation(org.aspectj.weaver.UnresolvedType)
-	 */
-	 // OPTIMIZE dont have these here, move them down to ResolvedMember
-	public boolean hasAnnotation(UnresolvedType ofType) {
-		throw new UnsupportedOperationException("You should resolve this member and call hasAnnotation() on the result...");
-	}
-	
-	public ResolvedType[] getAnnotationTypes() {
-		throw new UnsupportedOperationException("You should resolve this member and call hasAnnotation() on the result...");
-	}
-
-    public AnnotationX getAnnotationOfType(UnresolvedType ofType) { 
-		throw new UnsupportedOperationException("You should resolve this member and call getAnnotationOfType() on the result...");
-    }
 
 	/* (non-Javadoc)
 	 * @see org.aspectj.weaver.Member#getAnnotations()
@@ -60,6 +60,10 @@ public interface ResolvedMember extends Member, AnnotatedElement, TypeVariableDe
 	public String[] getParameterNames();
 	public void setParameterNames(String[] names);
 
+	public AnnotationX[][] getParameterAnnotations();
+	public ResolvedType[][] getParameterAnnotationTypes();
+	public String getAnnotationDefaultValue();
+	
 	public String[] getParameterNames(World world);
 
 	public AjAttribute.EffectiveSignatureAttribute getEffectiveSignature();
@@ -308,7 +308,11 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
     	if (annotationTypes == null) return null;
 		return (ResolvedType[])annotationTypes.toArray(new ResolvedType[]{});
     }
-    
+
+     public String getAnnotationDefaultValue() {
+         throw new UnsupportedOperationException("You should resolve this member and call getAnnotationDefaultValue() on the result...");
+     }
+     
     public AnnotationX[] getAnnotations() {
     	if (backingGenericMember != null) return backingGenericMember.getAnnotations();
     	return super.getAnnotations();
@@ -327,12 +331,14 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 		return parameterAnnotationTypes;
     }
 
-    public AnnotationX[][] getParameterAnnotations() {
-    	if (backingGenericMember != null) return backingGenericMember.getParameterAnnotations();
-    	return super.getParameterAnnotations();
+
+     public AnnotationX[][] getParameterAnnotations() {
+        if (backingGenericMember != null) return backingGenericMember.getParameterAnnotations();
+        throw new BCException("Cannot return parameter annotations for a " + this.getClass().getName() + " member");
+//        return super.getParameterAnnotations();
     }
-	
-	public void addAnnotation(AnnotationX annotation) {
+
+    public void addAnnotation(AnnotationX annotation) {
    	    // FIXME asc only allows for annotation types, not instances - should it?
 		if (annotationTypes == null) annotationTypes = new HashSet();
 		annotationTypes.add(annotation.getSignature());
@@ -472,6 +478,7 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 
 
 
+    // OPTIMIZE dont like how resolve(world) on ResolvedMemberImpl does something different to world.resolve(member)
 	public ResolvedMember resolve(World world) {
         // make sure all the pieces of a resolvedmember really are resolved
 		try {
@@ -1040,5 +1047,9 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 	}
 
 	public void evictWeavingState() { }
+	
+	 public AnnotationX getAnnotationOfType(UnresolvedType ofType) {
+	     throw new UnsupportedOperationException("You should resolve this member and call getAnnotationOfType() on the result...");
+     }
 }
 
@@ -29,10 +29,10 @@ public class MemberTestCase extends TestCase {
     }
 
     public void testMethodConstruction() {
-        Member s = MemberImpl.methodFromString("void Foo.goo(int)");
+        Member s = TestUtils.methodFromString("void Foo.goo(int)");
         Member t = MemberImpl.method(UnresolvedType.forName("Foo"), 0, "goo", "(I)V");
-        Member u = MemberImpl.methodFromString("void Foo1.goo(int)");
-        Member v = MemberImpl.methodFromString("int Foo.goo(int)");
+        Member u = TestUtils.methodFromString("void Foo1.goo(int)");
+        Member v = TestUtils.methodFromString("int Foo.goo(int)");
 
         TestUtil.assertCommutativeEquals(s, s, true);
         TestUtil.assertCommutativeEquals(t, t, true);
@@ -45,10 +45,10 @@ public class MemberTestCase extends TestCase {
         TestUtil.assertCommutativeEquals(t, v, false);
         TestUtil.assertCommutativeEquals(u, v, false);
 
-        s = MemberImpl.fieldFromString("int Foo.goo");
+        s = TestUtils.fieldFromString("int Foo.goo");
         t = MemberImpl.field("Foo", 0, "goo", "I");
-        u = MemberImpl.fieldFromString("int Foo.goo1");
-        v = MemberImpl.fieldFromString("long Foo.goo");
+        u = TestUtils.fieldFromString("int Foo.goo1");
+        v = TestUtils.fieldFromString("long Foo.goo");
 
         TestUtil.assertCommutativeEquals(s, s, true);
         TestUtil.assertCommutativeEquals(t, t, true);
@@ -64,7 +64,7 @@ public class MemberTestCase extends TestCase {
 
 
     public void testMethodContents() {
-        Member m = MemberImpl.methodFromString("void Foo.goo(int)");
+        Member m = TestUtils.methodFromString("void Foo.goo(int)");
         kindTest(m, Member.METHOD);
         declaringTypeTest(m, "Foo");
         nameTest(m, "goo");
@@ -75,7 +75,7 @@ public class MemberTestCase extends TestCase {
         isConstructorTest(m, false);
         isStaticTest(m, false);
 
-        m = MemberImpl.methodFromString("interface java.lang.Object java.util.Iterator.next()");
+        m = TestUtils.methodFromString("interface java.lang.Object java.util.Iterator.next()");
         kindTest(m, Member.METHOD);
         declaringTypeTest(m, "java.util.Iterator");
         nameTest(m, "next");
@@ -86,7 +86,7 @@ public class MemberTestCase extends TestCase {
         isConstructorTest(m, false);
         isStaticTest(m, false);
 
-        m = MemberImpl.methodFromString("void Foo.<init>(int, java.lang.Object)");
+        m = TestUtils.methodFromString("void Foo.<init>(int, java.lang.Object)");
         kindTest(m, Member.CONSTRUCTOR);
         declaringTypeTest(m, "Foo");
         nameTest(m, "<init>");
@@ -97,7 +97,7 @@ public class MemberTestCase extends TestCase {
         isConstructorTest(m, true);
         isStaticTest(m, false);
 
-        m = MemberImpl.methodFromString("private double Foo.sqrt(double)");
+        m = TestUtils.methodFromString("private double Foo.sqrt(double)");
         kindTest(m, Member.METHOD);
         declaringTypeTest(m, "Foo");
         nameTest(m, "sqrt");
@@ -108,7 +108,7 @@ public class MemberTestCase extends TestCase {
         isConstructorTest(m, false);
         isStaticTest(m, false);
 
-        m = MemberImpl.methodFromString("static int java.lang.Math.max(int, int)");
+        m = TestUtils.methodFromString("static int java.lang.Math.max(int, int)");
         kindTest(m, Member.METHOD);
         declaringTypeTest(m, "java.lang.Math");
         nameTest(m, "max");
@@ -121,7 +121,7 @@ public class MemberTestCase extends TestCase {
     }
 
     public void testFieldContents() {
-        Member m = MemberImpl.fieldFromString("int Foo.goo");
+        Member m = TestUtils.fieldFromString("int Foo.goo");
         kindTest(m, Member.FIELD);
         declaringTypeTest(m, "Foo");
         nameTest(m, "goo");
@@ -132,7 +132,7 @@ public class MemberTestCase extends TestCase {
         isConstructorTest(m, false);
         isStaticTest(m, false);
 
-        m = MemberImpl.fieldFromString("static java.util.Iterator goo.Bar.i");
+        m = TestUtils.fieldFromString("static java.util.Iterator goo.Bar.i");
         kindTest(m, Member.FIELD);
         declaringTypeTest(m, "goo.Bar");
         nameTest(m, "i");
@@ -9,17 +9,17 @@
  * ******************************************************************/
 package org.aspectj.weaver.patterns;
 
+import junit.framework.TestCase;
+
 import org.aspectj.bridge.AbortException;
 import org.aspectj.util.LangUtil;
 import org.aspectj.weaver.AnnotatedElement;
 import org.aspectj.weaver.AnnotationX;
-import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.BcweaverTests;
+import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.bcel.BcelWorld;
 
-import junit.framework.TestCase;
-
 public class AnnotationPatternTestCase extends TestCase {
 
 
@@ -29,7 +29,7 @@ public class AnnotationPatternTestCase extends TestCase {
 		AnnotationTypePattern foo = p.maybeParseAnnotationPattern();
 		foo = foo.resolveBindings(makeSimpleScope(),new Bindings(3),true);
 		assertTrue("ExactAnnotationTypePattern",foo instanceof ExactAnnotationTypePattern);
-		assertEquals("Foo",UnresolvedType.forName("Foo"),((ExactAnnotationTypePattern)foo).annotationType);
+		assertEquals("Foo", UnresolvedType.forSignature("LFoo;"), ((ExactAnnotationTypePattern) foo).annotationType);
 	}
 
 	public void testParseAndAnnotationPattern() {
@@ -41,8 +41,8 @@ public class AnnotationPatternTestCase extends TestCase {
 		assertEquals("@Foo @Goo",fooAndGoo.toString());
 		AnnotationTypePattern left = ((AndAnnotationTypePattern)fooAndGoo).getLeft();
 		AnnotationTypePattern right = ((AndAnnotationTypePattern)fooAndGoo).getRight();
-		assertEquals("Foo",UnresolvedType.forName("Foo"),((ExactAnnotationTypePattern)left).annotationType);
-		assertEquals("Goo",UnresolvedType.forName("Goo"),((ExactAnnotationTypePattern)right).annotationType);		
+		assertEquals("Foo", UnresolvedType.forSignature("LFoo;"), ((ExactAnnotationTypePattern) left).annotationType);
+        assertEquals("Goo", UnresolvedType.forSignature("LGoo;"), ((ExactAnnotationTypePattern) right).annotationType);		
 	}
 //
 //	public void testParseOrAnnotationPattern() {
@@ -33,7 +33,7 @@ public class AfterThrowingWeaveTestCase extends WeaveTestCase {
         BcelWorld world = new BcelWorld();
 
         ShadowMunger myMunger = 
-            world.shadowMunger("afterThrowing(): get(* *.out) -> static void Aspect.ajc_afterThrowing_field_get(java.lang.Throwable)",
+            TestUtils.shadowMunger(world,"afterThrowing(): get(* *.out) -> static void Aspect.ajc_afterThrowing_field_get(java.lang.Throwable)",
                         Advice.ExtraArgument);
         ShadowMunger cm = myMunger.concretize(ResolvedType.MISSING, world, null);
 
@@ -19,6 +19,7 @@ import java.util.Arrays;
 import org.aspectj.weaver.Advice;
 import org.aspectj.weaver.AdviceKind;
 import org.aspectj.weaver.MemberImpl;
+import org.aspectj.weaver.TestUtils;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
 
@@ -46,7 +47,7 @@ public class TjpWeaveTestCase extends WeaveTestCase {
     	BcelAdvice munger = new BcelAdvice(
     		AdviceKind.stringToKind("before"),
     		makePointcutAll(), 
-      		MemberImpl.methodFromString("static void Aspect.ajc_before(org.aspectj.lang.JoinPoint$StaticPart)"),
+    		TestUtils.methodFromString("static void Aspect.ajc_before(org.aspectj.lang.JoinPoint$StaticPart)"),
     		Advice.ThisJoinPointStaticPart, -1, -1, null, null);
 
         weaveTest("HelloWorld", "StaticTjpBeforeHelloWorld", munger);
@@ -57,7 +58,7 @@ public class TjpWeaveTestCase extends WeaveTestCase {
     	BcelAdvice munger = new BcelAdvice(
     		AdviceKind.stringToKind("before"),
     		makePointcutAll(), 
-      		MemberImpl.methodFromString("static void Aspect.ajc_before(org.aspectj.lang.JoinPoint$StaticPart)"),
+    		TestUtils.methodFromString("static void Aspect.ajc_before(org.aspectj.lang.JoinPoint$StaticPart)"),
     		Advice.ThisEnclosingJoinPointStaticPart, -1, -1, null, null);
 
         weaveTest("HelloWorld", "StaticEnclosingTjpBeforeHelloWorld", munger);
@@ -68,7 +69,7 @@ public class TjpWeaveTestCase extends WeaveTestCase {
     	BcelAdvice munger = new BcelAdvice(
     		AdviceKind.stringToKind("before"),
     		makePointcutAll(), 
-      		MemberImpl.methodFromString("static void Aspect.ajc_before(org.aspectj.lang.JoinPoint)"),
+    		TestUtils.methodFromString("static void Aspect.ajc_before(org.aspectj.lang.JoinPoint)"),
     		Advice.ThisJoinPoint, -1, -1, null, null);
 
         weaveTest("HelloWorld", "TjpBeforeHelloWorld", munger);
@@ -78,7 +79,7 @@ public class TjpWeaveTestCase extends WeaveTestCase {
     	BcelAdvice munger = new BcelAdvice(
     		AdviceKind.stringToKind("around"),
     		makePointcutAll(), 
-      		MemberImpl.methodFromString("static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)"),
+    		TestUtils.methodFromString("static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)"),
     		Advice.ThisJoinPoint | Advice.ExtraArgument, -1, -1, null, null);
 
         weaveTest("HelloWorld", "TjpAroundHelloWorld", munger);
@@ -90,14 +91,14 @@ public class TjpWeaveTestCase extends WeaveTestCase {
     	BcelAdvice munger1 = new BcelAdvice(
     		AdviceKind.stringToKind("around"),
     		makePointcutAll(), 
-      		MemberImpl.methodFromString("static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)"),
+    		TestUtils.methodFromString("static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)"),
     		Advice.ThisJoinPoint | Advice.ExtraArgument, -1, -1, null, 
     		rtx);
 
     	BcelAdvice munger2 = new BcelAdvice(
     		AdviceKind.stringToKind("around"),
     		makePointcutAll(), 
-      		MemberImpl.methodFromString("static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)"),
+    		TestUtils.methodFromString("static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)"),
     		Advice.ThisJoinPoint | Advice.ExtraArgument, -1, -1, null, 
     		rtx);
 
@@ -189,7 +189,7 @@ public abstract class WeaveTestCase extends TestCase {
 
     protected ShadowMunger makeConcreteAdvice(String mungerString, int extraArgFlag, PerClause perClause) {
         Advice myMunger = 
-            world.shadowMunger(mungerString, extraArgFlag);
+        	TestUtils.shadowMunger(world,mungerString, extraArgFlag);
 
 //        PerSingleton s = new PerSingleton();
 //        s.concretize(world.resolve("Aspect"));
@@ -38,7 +38,7 @@ public class WorldTestCase extends AbstractWorldTestCase {
         ResolvedType trace = world.resolve(UnresolvedType.forName("Trace"),true);
         assertTrue("Couldnt find type Trace",!trace.isMissing());
         fieldsTest(trace, Member.NONE);
-        /*Member constr = */MemberImpl.methodFromString("void Trace.<init>()"); 
+        /*Member constr = */TestUtils.methodFromString("void Trace.<init>()"); 
         //XXX need attribute fix - 
         //methodsTest(trace, new Member[] { constr });
 
@@ -58,13 +58,13 @@ public class WorldTestCase extends AbstractWorldTestCase {
 
         mungersTest(trace, 
             new ShadowMunger[] {
-				world.shadowMunger("before(foo): traced(foo) -> void Trace.ajc_before_4(java.lang.Object))",
+        		TestUtils.shadowMunger(world,"before(foo): traced(foo) -> void Trace.ajc_before_4(java.lang.Object))",
             					0),
-				world.shadowMunger("afterReturning(foo): traced(foo) -> void Trace.ajc_afterreturning_3(java.lang.Object, java.lang.Object))",
+            					TestUtils.shadowMunger(world,"afterReturning(foo): traced(foo) -> void Trace.ajc_afterreturning_3(java.lang.Object, java.lang.Object))",
             					Advice.ExtraArgument),
-				world.shadowMunger("around(): execution(* doit(..)) -> java.lang.Object Trace.ajc_around_2(org.aspectj.runtime.internal.AroundClosure))",
+            					TestUtils.shadowMunger(world,"around(): execution(* doit(..)) -> java.lang.Object Trace.ajc_around_2(org.aspectj.runtime.internal.AroundClosure))",
             					Advice.ExtraArgument),
-				world.shadowMunger("around(foo): traced(foo) -> java.lang.Object Trace.ajc_around_1(java.lang.Object, org.aspectj.runtime.internal.AroundClosure))",
+            					TestUtils.shadowMunger(world,"around(foo): traced(foo) -> java.lang.Object Trace.ajc_around_1(java.lang.Object, org.aspectj.runtime.internal.AroundClosure))",
             					Advice.ExtraArgument),
             });
 
@@ -0,0 +1,39 @@
+/* *******************************************************************
+ * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *     PARC     initial implementation 
+ * ******************************************************************/
+
+
+package org.aspectj.weaver.bcel;
+
+import java.io.File;
+import java.io.IOException;
+
+
+//XXX delete very soon
+public class ZipFileWeaver {
+	File inFile;
+	public ZipFileWeaver(File inFile) {
+		super();
+		this.inFile = inFile;
+	}
+
+	public void weave(BcelWeaver weaver, File outFile) throws IOException {
+		int count = 0;
+		long startTime = System.currentTimeMillis();
+		weaver.addJarFile(inFile, new File("."),false);
+		weaver.weave(outFile);
+		long stopTime = System.currentTimeMillis();
+		
+		
+		System.out.println("handled " + count + " entries, in " + 
+				(stopTime-startTime)/1000. + " seconds");
+	}
+}
@@ -11,7 +11,7 @@
 package org.aspectj.weaver.tools;
 
 import org.apache.commons.logging.LogFactory;
-
+//OPTIMIZE move out of main weaver for now?
 public class CommonsTraceFactory extends TraceFactory {
 
 	private LogFactory logFactory = LogFactory.getFactory();
@@ -255,23 +255,25 @@ public class WildTypePattern extends TypePattern {
 	// we've matched against the base (or raw) type, but if this type pattern specifies bounds because
 	// it is a ? extends or ? super deal then we have to match them too.
 	private boolean matchesBounds(ResolvedType aType, MatchKind staticOrDynamic) {
-		if (upperBound == null && aType.getUpperBound() != null) {
+	    if (!(aType instanceof BoundedReferenceType)) return true;
+	    BoundedReferenceType boundedRT = (BoundedReferenceType) aType;
+		if (upperBound == null && boundedRT.getUpperBound() != null) {
 			// for upper bound, null can also match against Object - but anything else and we're out.
-			if (!aType.getUpperBound().getName().equals(UnresolvedType.OBJECT.getName())) {
+			if (!boundedRT.getUpperBound().getName().equals(UnresolvedType.OBJECT.getName())) {
 				return false;
 			}
 		}
-		if (lowerBound == null && aType.getLowerBound() != null) return false;
+		if (lowerBound == null && boundedRT.getLowerBound() != null) return false;
 		if (upperBound != null) {
 			// match ? extends
-			if (aType.isGenericWildcard() && aType.isSuper()) return false;
-			if (aType.getUpperBound() == null) return false;
-			return upperBound.matches((ResolvedType)aType.getUpperBound(),staticOrDynamic).alwaysTrue();
+			if (aType.isGenericWildcard() && boundedRT.isSuper()) return false;
+            if (boundedRT.getUpperBound() == null) return false;
+            return upperBound.matches((ResolvedType) boundedRT.getUpperBound(), staticOrDynamic).alwaysTrue();
 		}
 		if (lowerBound != null) {
 			// match ? super
-			if (!(aType.isGenericWildcard() && aType.isSuper())) return false;
-			return lowerBound.matches((ResolvedType)aType.getLowerBound(),staticOrDynamic).alwaysTrue();
+			if (!(boundedRT.isGenericWildcard() && boundedRT.isSuper())) return false;
+            return lowerBound.matches((ResolvedType) boundedRT.getLowerBound(), staticOrDynamic).alwaysTrue();
 		}
 		return true;
 	}
@@ -44,10 +44,7 @@ public class ExactAnnotationTypePattern extends AnnotationTypePattern {
 	private boolean bindingPattern = false;
 	private Map annotationValues;
 
-	/**
-	 * @param annotationValues 
-	 * 
-	 */
+	 // OPTIMIZE is annotationtype really unresolved???? surely it is resolved by now...
 	public ExactAnnotationTypePattern(UnresolvedType annotationType, Map annotationValues) {
 		this.annotationType = annotationType;
 		this.annotationValues = annotationValues;
@@ -20,6 +20,7 @@ import java.util.Map;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.weaver.ISourceContext;
 import org.aspectj.weaver.ResolvedType;
+import org.aspectj.weaver.TypeVariableReferenceType;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.VersionedDataInputStream;
 import org.aspectj.weaver.WeaverMessages;
@@ -102,8 +103,9 @@ public class DeclareSoft extends Declare {
     	ResolvedType excType = exception.getExactType().resolve(scope.getWorld());
     	if (!excType.isMissing()) {
     		if (excType.isTypeVariableReference()) {
+    		    TypeVariableReferenceType typeVariableRT = (TypeVariableReferenceType) excType;
     			// a declare soft in a generic abstract aspect, we need to check the upper bound
-    			excType = excType.getUpperBound().resolve(scope.getWorld());
+    			excType = typeVariableRT.getUpperBound().resolve(scope.getWorld());
     		}
     		if (!scope.getWorld().getCoreType(UnresolvedType.THROWABLE).isAssignableFrom(excType)) {
     			scope.getWorld().showMessage(IMessage.ERROR,
@@ -28,7 +28,6 @@ import org.aspectj.weaver.MemberImpl;
 import org.aspectj.weaver.NameMangler;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.Shadow;
-import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.WeaverMessages;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.ast.Expr;
@@ -135,10 +134,10 @@ public class ConcreteCflowPointcut extends Pointcut {
 	}
 
 	private static final Member cflowStackIsValidMethod = 
-		MemberImpl.method(UnresolvedType.forName(NameMangler.CFLOW_STACK_TYPE), 0, "isValid", "()Z");
+		MemberImpl.method(NameMangler.CFLOW_STACK_UNRESOLVEDTYPE, 0, "isValid", "()Z");
 
 	private static final Member cflowCounterIsValidMethod = 
-		MemberImpl.method(UnresolvedType.forName(NameMangler.CFLOW_COUNTER_TYPE), 0, "isValid", "()Z");
+		MemberImpl.method(NameMangler.CFLOW_COUNTER_UNRESOLVEDTYPE, 0, "isValid", "()Z");
 
 
 	public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, IntMap bindings) {
@@ -29,9 +29,10 @@ public class UnwovenClassFileWithThirdPartyManagedBytecode
 		byte[] getBytes();
 	}
 
-	public UnwovenClassFileWithThirdPartyManagedBytecode(String filename,
+	// OPTIMIZE make classname an input char[]
+	public UnwovenClassFileWithThirdPartyManagedBytecode(String filename,String classname,
 			IByteCodeProvider provider) {
-		super(filename,null);
+		super(filename,classname,null);
 		this.provider = provider;
 	}
 
@@ -27,8 +27,8 @@ import java.util.StringTokenizer;
 import org.aspectj.apache.bcel.Constants;
 import org.aspectj.apache.bcel.classfile.Attribute;
 import org.aspectj.apache.bcel.classfile.ClassParser;
-import org.aspectj.apache.bcel.classfile.JavaClass;
 import org.aspectj.apache.bcel.classfile.ConstantPool;
+import org.aspectj.apache.bcel.classfile.JavaClass;
 import org.aspectj.apache.bcel.classfile.Method;
 import org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;
 import org.aspectj.apache.bcel.generic.FieldInstruction;
@@ -46,16 +46,15 @@ import org.aspectj.apache.bcel.util.NonCachingClassLoaderRepository;
 import org.aspectj.apache.bcel.util.Repository;
 import org.aspectj.bridge.IMessageHandler;
 import org.aspectj.weaver.Advice;
-import org.aspectj.weaver.AdviceKind;
 import org.aspectj.weaver.AjAttribute;
 import org.aspectj.weaver.AnnotationOnTypeMunger;
 import org.aspectj.weaver.AnnotationX;
 import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.ConcreteTypeMunger;
 import org.aspectj.weaver.ICrossReferenceHandler;
-import org.aspectj.weaver.MemberKind;
 import org.aspectj.weaver.Member;
 import org.aspectj.weaver.MemberImpl;
+import org.aspectj.weaver.MemberKind;
 import org.aspectj.weaver.NewParentTypeMunger;
 import org.aspectj.weaver.ReferenceType;
 import org.aspectj.weaver.ReferenceTypeDelegate;
@@ -69,10 +68,8 @@ import org.aspectj.weaver.World;
 import org.aspectj.weaver.AjAttribute.Aspect;
 import org.aspectj.weaver.patterns.DeclareAnnotation;
 import org.aspectj.weaver.patterns.DeclareParents;
-import org.aspectj.weaver.patterns.FormalBinding;
 import org.aspectj.weaver.patterns.PerClause;
 import org.aspectj.weaver.patterns.Pointcut;
-import org.aspectj.weaver.patterns.SimpleScope;
 import org.aspectj.weaver.tools.Trace;
 import org.aspectj.weaver.tools.TraceFactory;
 
@@ -175,61 +172,6 @@ public class BcelWorld extends World implements Repository {
 		classPath.addPath(name, this.getMessageHandler());
 	}
 
-    /**
-     * Parse a string into advice.
-     * 
-     * <blockquote><pre>
-     * Kind ( Id , ... ) : Pointcut -> MethodSignature
-     * </pre></blockquote>
-     */
-    public Advice shadowMunger(String str, int extraFlag) {
-        str = str.trim();
-        int start = 0;
-        int i = str.indexOf('(');
-        AdviceKind kind = 
-            AdviceKind.stringToKind(str.substring(start, i));
-        start = ++i;
-        i = str.indexOf(')', i);
-        String[] ids = parseIds(str.substring(start, i).trim());
-        //start = ++i;
-        
-        
-        
-        i = str.indexOf(':', i);        
-        start = ++i;        
-        i = str.indexOf("->", i);
-        Pointcut pointcut = Pointcut.fromString(str.substring(start, i).trim());
-        Member m = MemberImpl.methodFromString(str.substring(i+2, str.length()).trim());
-
-        // now, we resolve
-        UnresolvedType[] types = m.getParameterTypes();
-        FormalBinding[] bindings = new FormalBinding[ids.length];
-        for (int j = 0, len = ids.length; j < len; j++) {
-            bindings[j] = new FormalBinding(types[j], ids[j], j, 0, 0, "fromString");
-        }
-
-        Pointcut p =
-        	pointcut.resolve(new SimpleScope(this, bindings));
-
-        return new BcelAdvice(kind, p, m, extraFlag, 0, 0, null, null);
-    }
-    
-    private String[] parseIds(String str) {
-        if (str.length() == 0) return ZERO_STRINGS;
-        List l = new ArrayList();
-        int start = 0;
-        while (true) {
-            int i = str.indexOf(',', start);
-            if (i == -1) {
-                l.add(str.substring(start).trim());
-                break;
-            }
-            l.add(str.substring(start, i).trim());
-            start = i+1;
-        }
-        return (String[]) l.toArray(new String[l.size()]);
-    }
-    
     // ---- various interactions with bcel
 
     public static Type makeBcelType(UnresolvedType type) {
@@ -674,7 +616,8 @@ public class BcelWorld extends World implements Repository {
 	}
 
 	public void clear() {
-		throw new RuntimeException("Not implemented");
+		delegate.clear();
+//		throw new RuntimeException("Not implemented");
 	}
 
     // @Override
@@ -35,6 +35,7 @@ import org.aspectj.weaver.IEclipseSourceContext;
 import org.aspectj.weaver.ISourceContext;
 import org.aspectj.weaver.Member;
 import org.aspectj.weaver.ResolvedMember;
+import org.aspectj.weaver.ResolvedMemberImpl;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.Shadow;
 import org.aspectj.weaver.ShadowMunger;
@@ -66,10 +67,33 @@ public class BcelAdvice extends Advice {
 		Member signature,
 		ResolvedType concreteAspect) 
 	{
-		super(attribute, pointcut, signature);
+		super(attribute, pointcut,shrink(attribute.getKind(),concreteAspect,signature));// (signature==null?null:signature.slimline()));
 		this.concreteAspect = concreteAspect;
 	}
-
+	/**
+	 * We don't always need to represent the signature with a heavyweight BcelMethod object - only if its around advice
+	 * and inlining is active
+	 * @param concreteAspect 
+	 * @param attribute 
+	 */
+	private static Member shrink(AdviceKind kind, ResolvedType concreteAspect, Member m) {
+		if (m==null) return null;
+		UnresolvedType dType = m.getDeclaringType();
+		// if it isnt around advice or it is but inlining is turned off then shrink it to a ResolvedMemberImpl
+		if (kind != AdviceKind.Around ||
+			((dType instanceof ResolvedType) && ((ResolvedType)dType).getWorld().isXnoInline())) {
+			if (m instanceof BcelMethod) {
+				BcelMethod bm = (BcelMethod)m;
+				if (bm.getMethod()!=null && bm.getMethod().getAnnotations()!=null) return m;
+				ResolvedMemberImpl simplermember = new ResolvedMemberImpl(bm.getKind(),bm.getDeclaringType(),
+						                                       bm.getModifiers(),bm.getReturnType(),bm.getName(),
+						                                       bm.getParameterTypes());//,bm.getExceptions(),bm.getBackingGenericMember());
+				simplermember.setParameterNames(bm.getParameterNames());
+				return simplermember;
+			}
+		}
+		return m;
+	}
 	// !!! must only be used for testing
 	public BcelAdvice(AdviceKind kind, Pointcut pointcut, Member signature,
 		int extraArgumentFlags,
@@ -13,12 +13,9 @@
  * ******************************************************************/
 package org.aspectj.weaver;
 
-import java.io.DataInputStream;
-import java.io.IOException;
 import java.util.Collection;
 import java.util.Iterator;
 
-
 public interface Member {
 
 	public static final Member[] NONE = new Member[0];
@@ -88,15 +85,9 @@ public interface Member {
 
 	public UnresolvedType[] getExceptions(World world);
 
-	public boolean isProtected(World world);
-
-	public boolean isStatic(World world);
-
-	public boolean isStrict(World world);
-
-	public boolean isStatic();
+    public boolean isStatic();
 
-	public boolean isInterface();
+    public boolean isInterface();
 
 	public boolean isPrivate();
 
@@ -907,7 +907,8 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 		for (int i = 0; i < myParameterTypes.length; i++) {
 			UnresolvedType thisParameter = myParameterTypes[i];
 			if (thisParameter.isTypeVariableReference()) {
-				sig.append(thisParameter.getUpperBound().getSignature());
+                TypeVariableReferenceType typeVariableRT = (TypeVariableReferenceType) thisParameter;
+                sig.append(typeVariableRT.getUpperBound().getSignature());
 			} else {
 				sig.append(thisParameter.getSignature());
 			}
@@ -920,12 +921,13 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 	// comparison.
 	public static void appendSigWithTypeVarBoundsRemoved(UnresolvedType aType, StringBuffer toBuffer, Set alreadyUsedTypeVars) {
 		if (aType.isTypeVariableReference()) {
+            TypeVariableReferenceType typeVariableRT = (TypeVariableReferenceType) aType;
 			// pr204505
 		    if (alreadyUsedTypeVars.contains(aType)) {
                 toBuffer.append("...");
             } else {
                 alreadyUsedTypeVars.add(aType);
-                appendSigWithTypeVarBoundsRemoved(aType.getUpperBound(), toBuffer, alreadyUsedTypeVars);
+                appendSigWithTypeVarBoundsRemoved(typeVariableRT.getUpperBound(), toBuffer, alreadyUsedTypeVars);
             }
 //			toBuffer.append("T;");
 		} else if (aType.isParameterizedType()) {
@@ -94,7 +94,7 @@ import org.aspectj.weaver.tools.Traceable;
  * The wildcard ? extends Foo has signature +LFoo;
  * The wildcard ? super Foo has signature -LFoo;
  */
-public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
+public class UnresolvedType implements Unresolved, Traceable, TypeVariableDeclaringElement {
 
 	// common types referred to by the weaver
     public static final UnresolvedType[] NONE         = new UnresolvedType[0];
@@ -149,21 +149,6 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 	 */
 	protected TypeVariable[] typeVariables;
 
-	/**
-	 * Iff isGenericWildcard, then this is the upper bound type for ? extends Foo
-	 */
-	private UnresolvedType upperBound;
-	
-	/**
-	 * Iff isGenericWildcard, then this is the lower bound type for ? super Foo
-	 */
-	private UnresolvedType lowerBound;
-	
-	/**
-	 * for wildcards '? extends' or for type variables 'T extends'
-	 */
-	private boolean isSuper   = false;
-	private boolean isExtends = false;
 
    /**
      * Determines if this represents a primitive type.  A primitive type
@@ -188,12 +173,12 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
     public boolean isParameterizedType()      { return typeKind == TypeKind.PARAMETERIZED; }
     public boolean isTypeVariableReference()  { return typeKind == TypeKind.TYPE_VARIABLE; }
     public boolean isGenericWildcard()        { return typeKind == TypeKind.WILDCARD; }
-    public boolean isExtends() { return isExtends;}
-    public boolean isSuper()   { return isSuper;  }
     public TypeKind getTypekind() { return typeKind;}
 
     // for any reference type, we can get some extra information...
-    public final boolean isArray() {  return signature.startsWith("["); } 
+    public final boolean isArray() {
+        return signature.length() > 0 && signature.charAt(0) == '[';
+    } 
 
     /** 
      * Equality is checked based on the underlying signature.
@@ -254,15 +239,11 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
         super();
         this.signature = signature;
         this.signatureErasure = signature;
-        if (signature.charAt(0)=='-') isSuper   = true;
-        if (signature.charAt(0)=='+') isExtends = true;
     }
 
     protected UnresolvedType(String signature, String signatureErasure) {
     	this.signature = signature;
     	this.signatureErasure = signatureErasure;
-        if (signature.charAt(0)=='-') isSuper   = true;
-        if (signature.charAt(0)=='+') isExtends = true;
     }
 
     // called from TypeFactory
@@ -313,7 +294,6 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
     public static UnresolvedType forName(String name) {
         return forSignature(nameToSignature(name));
     }
-	
 
     /** Constructs a UnresolvedType for each java language type name in an incoming array.
      * 
@@ -579,35 +559,7 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 		return UnresolvedType.forSignature(getErasureSignature());
 	}
 
-	/**
-	 * Get the upper bound for a generic wildcard
-	 */
-	public UnresolvedType getUpperBound() {
-		return upperBound;
-	}
 
-	/**
-	 * Get the lower bound for a generic wildcard
-	 */
-	public UnresolvedType getLowerBound() {
-		return lowerBound;
-	}
-	
-	/**
-	 * Set the upper bound for a generic wildcard
-	 */
-	public void setUpperBound(UnresolvedType aBound) {
-		this.upperBound = aBound;
-	}
-	
-	/**
-	 * Set the lower bound for a generic wildcard
-	 */
-	public void setLowerBound(UnresolvedType aBound) {
-		this.lowerBound = aBound;
-	}
-
- 	
     /**
      * Returns a UnresolvedType object representing the effective outermost enclosing type
      * for a name type.  For all other types, this will return the type itself.
@@ -14,8 +14,6 @@ package org.aspectj.weaver;
 import java.util.ArrayList;
 import java.util.List;
 
-import org.aspectj.weaver.UnresolvedType.TypeKind;
-
 /**
  * @author colyer
  *
@@ -135,27 +133,18 @@ public class TypeFactory {
 				return new UnresolvedType(signature,signatureErasure,typeParams);
 			}
 			// can't replace above with convertSigToType - leads to stackoverflow
-		} else if (signature.equals("?")){
-			UnresolvedType ret = UnresolvedType.SOMETHING;
-			ret.typeKind = TypeKind.WILDCARD;
-			return ret;
+		} else if (signature.equals("?") || signature.equals("*")) {
+		    return WildcardedUnresolvedType.QUESTIONMARK;
 		} else if(firstChar=='+') { 
 			// ? extends ...
-			UnresolvedType ret = new UnresolvedType(signature);
-			ret.typeKind = TypeKind.WILDCARD;
-			
-//			UnresolvedType bound1 = UnresolvedType.forSignature(signature.substring(1));
-//			UnresolvedType bound2 = convertSigToType(signature.substring(1));
-			ret.setUpperBound(convertSigToType(signature.substring(1)));
-			return ret;
+		    UnresolvedType upperBound = convertSigToType(signature.substring(1));
+            WildcardedUnresolvedType wildcardedUT = new WildcardedUnresolvedType(signature, upperBound, null);
+			return wildcardedUT;
 		} else if (firstChar=='-') { 
 			// ? super ...
-//			UnresolvedType bound = UnresolvedType.forSignature(signature.substring(1));
-//			UnresolvedType bound2 = convertSigToType(signature.substring(1));
-			UnresolvedType ret = new UnresolvedType(signature);
-			ret.typeKind = TypeKind.WILDCARD;
-			ret.setLowerBound(convertSigToType(signature.substring(1)));
-			return ret;
+		    UnresolvedType lowerBound = convertSigToType(signature.substring(1));
+            WildcardedUnresolvedType wildcardedUT = new WildcardedUnresolvedType(signature, null, lowerBound);
+            return wildcardedUT;
 		} else if (firstChar=='T') {
 			String typeVariableName = signature.substring(1);
 			if (typeVariableName.endsWith(";")) {
@@ -44,7 +44,7 @@ import org.aspectj.weaver.bcel.BcelAdvice;
 public abstract class Shadow {
 
 	// every Shadow has a unique id, doesn't matter if it wraps...
-	private static int nextShadowID = 100;  // easier to spot than zero.
+	private static int nextShadowID = 100;  // easier to spot than zero. // OPTIMIZE is this a bug? static?
 
 	private final Kind kind; 
     private final Member signature;
@@ -304,8 +304,11 @@ public class ReferenceType extends ResolvedType {
        			for (int i = 0; i < myParameters.length; i++) {
 					if (!myParameters[i].isGenericWildcard()) {
 						wildcardsAllTheWay = false;
-					} else if (myParameters[i].isExtends() || myParameters[i].isSuper()) {
-						wildcardsAllTheWay = false;
+					} else {
+                        BoundedReferenceType boundedRT = (BoundedReferenceType) myParameters[i];
+                        if (boundedRT.isExtends() || boundedRT.isSuper()) {
+                            wildcardsAllTheWay = false;
+                        }
 					}
 				}
        			if (wildcardsAllTheWay && !other.isParameterizedType()) return true;
@@ -38,7 +38,8 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 
 	public static final ResolvedType[] EMPTY_RESOLVED_TYPE_ARRAY  = new ResolvedType[0];
 	public static final String PARAMETERIZED_TYPE_IDENTIFIER = "P";
-	
+
+    
 	// Set during a type pattern match call - this currently used to hold the annotations
 	// that may be attached to a type when it used as a parameter
 	public ResolvedType[] temporaryAnnotationTypes;
@@ -693,16 +694,11 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
     		return false;
     }
 
-    /**
-     * Note: Only overridden by Name subtype
-     */
-	public void addAnnotation(AnnotationX annotationX) {
-		throw new RuntimeException("ResolvedType.addAnnotation() should never be called");
-	}
+
+     public void addAnnotation(AnnotationX annotationX) {
+        throw new RuntimeException("ResolvedType.addAnnotation() should never be called");
+    }
 
-	/**
-	 * Note: Only overridden by Name subtype
-	 */
 	public AnnotationX[] getAnnotations() {
 		throw new RuntimeException("ResolvedType.getAnnotations() should never be called");
 	}
@@ -2129,7 +2125,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 			}
 
 			for (int i = 0; i < typeParameters.length; i++) {
-				UnresolvedType aType = (ResolvedType)typeParameters[i];
+				ResolvedType aType = (ResolvedType)typeParameters[i];
 				if (aType.isTypeVariableReference()  && 
 				// assume the worst - if its definetly not a type declared one, it could be anything
 						((TypeVariableReference)aType).getTypeVariable().getDeclaringElementKind()!=TypeVariable.TYPE) {
@@ -2144,9 +2140,10 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 					}
 				}
 				if (aType.isGenericWildcard()) {
-					if (aType.isExtends()) {
+				    BoundedReferenceType boundedRT = (BoundedReferenceType) aType;
+					if (boundedRT.isExtends()) {
 						boolean b = false;
-						UnresolvedType upperBound = aType.getUpperBound();
+						UnresolvedType upperBound = boundedRT.getUpperBound();
 						if (upperBound.isParameterizedType()) {
 							b = upperBound.isParameterizedWithAMemberTypeVariable();
 						} else if (upperBound.isTypeVariableReference() && ((TypeVariableReference)upperBound).getTypeVariable().getDeclaringElementKind()==TypeVariable.METHOD) {
@@ -2158,9 +2155,9 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 						}
 						// FIXME asc need to check additional interface bounds
 					}
-					if (aType.isSuper()) {
+					if (boundedRT.isSuper()) {
 						boolean b = false;
-						UnresolvedType lowerBound = aType.getLowerBound();
+						UnresolvedType lowerBound = boundedRT.getLowerBound();
 						if (lowerBound.isParameterizedType()) {
 							b = lowerBound.isParameterizedWithAMemberTypeVariable();
 						} else if (lowerBound.isTypeVariableReference() && ((TypeVariableReference)lowerBound).getTypeVariable().getDeclaringElementKind()==TypeVariable.METHOD) {
@@ -2204,5 +2201,6 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 	public String getBinaryPath() {
 		return binaryPath;
 	}
+
 
 }
@@ -33,7 +33,7 @@ public interface ResolvedMember extends Member, AnnotatedElement, TypeVariableDe
 	public UnresolvedType[] getExceptions();
 
 	public ShadowMunger getAssociatedShadowMunger();
-
+//OPTIMIZE have param annotation (and anno default value) related stuff here rather than above
 	// ??? true or false?
 	public boolean isAjSynthetic();
 
@@ -14,6 +14,7 @@
 package org.aspectj.weaver;
 
 import java.lang.reflect.Modifier;
+
 import org.aspectj.weaver.bcel.LazyClassGen;
 
 public class NameMangler {
@@ -32,6 +33,10 @@ public class NameMangler {
 	public static final String CFLOW_STACK_TYPE = "org.aspectj.runtime.internal.CFlowStack";
 	public static final String CFLOW_COUNTER_TYPE="org.aspectj.runtime.internal.CFlowCounter";
 
+	public static final UnresolvedType CFLOW_STACK_UNRESOLVEDTYPE = UnresolvedType.forSignature("Lorg/aspectj/runtime/internal/CFlowStack;");
+
+    public static final UnresolvedType CFLOW_COUNTER_UNRESOLVEDTYPE = UnresolvedType.forSignature("Lorg/aspectj/runtime/internal/CFlowCounter;");
+	
 	public static final String SOFT_EXCEPTION_TYPE = "org.aspectj.lang.SoftException";
 
 	public static final String PERSINGLETON_FIELD_NAME =  PREFIX + "perSingletonInstance";
@@ -0,0 +1,69 @@
+/* *******************************************************************
+ * Copyright (c) 2008 Contributors
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *     Andy Clement     initial implementation 
+ * ******************************************************************/
+package org.aspectj.weaver;
+
+/**
+ * Represents a wildcarded bound for a generic type, this can be unbounded '?' or bounded via extends '? extends Foo' or
+ * super '? super Foo'. The signature for a ? is in fact "*" and the erasure signature is the upper bound which defaults
+ * to java.lang.Object if nothing is specified. On resolution, this becomes a BoundedReferenceType
+ * 
+ * @author Andy Clement
+ */
+public class WildcardedUnresolvedType extends UnresolvedType implements Unresolved {
+
+    // TODO does not cope with extra bounds '? extends A & B & C'
+    
+    public static final int UNBOUND = 0;
+
+    public static final int EXTENDS = 1;
+
+    public static final int SUPER = 2;
+    
+    public static final WildcardedUnresolvedType QUESTIONMARK = new WildcardedUnresolvedType("*", UnresolvedType.OBJECT, null);
+
+    private int boundKind = UNBOUND; // UNBOUND, EXTENDS, SUPER
+
+    private UnresolvedType lowerBound;
+
+    private UnresolvedType upperBound;
+
+    public WildcardedUnresolvedType(String signature, UnresolvedType upperBound, UnresolvedType lowerBound) {
+        super(signature, (upperBound == null ? UnresolvedType.OBJECT.signature : upperBound.signatureErasure));
+        this.typeKind = TypeKind.WILDCARD;
+        this.upperBound = upperBound;
+        this.lowerBound = lowerBound;
+        if (signature.charAt(0) == '-') boundKind = SUPER;
+        if (signature.charAt(0) == '+') boundKind = EXTENDS;
+    }
+
+    public UnresolvedType getUpperBound() {
+        return upperBound;
+    }
+
+    public UnresolvedType getLowerBound() {
+        return lowerBound;
+    }
+
+    public boolean isExtends() {
+        return boundKind == EXTENDS;
+    }
+
+    public boolean isSuper() {
+        return boundKind == SUPER;
+    }
+
+    public boolean isUnbound() {
+        return boundKind == UNBOUND;
+    }
+
+
+}
@@ -0,0 +1,21 @@
+/* *******************************************************************
+ * Copyright (c) 2008 Contributors
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *     Andy Clement     initial implementation 
+ * ******************************************************************/
+package org.aspectj.weaver;
+
+/**
+ * Marker interface for entities that are not resolved.
+ * 
+ * @author Andy Clement
+ */
+public interface Unresolved {
+
+}
@@ -378,7 +378,7 @@ public abstract class World implements Dump.INode {
 
 		} else if (ty.isGenericWildcard()) {
 			// ======= generic wildcard types =============
-			return resolveGenericWildcardFor(ty);
+			return resolveGenericWildcardFor((WildcardedUnresolvedType) ty);
     	} else {
 			// ======= simple and raw types ===============
 			String erasedSignature = ty.getErasureSignature();
@@ -463,7 +463,7 @@ public abstract class World implements Dump.INode {
     /**
      * Go from an unresolved generic wildcard (represented by UnresolvedType) to a resolved version (BoundedReferenceType).
      */
-    private ReferenceType resolveGenericWildcardFor(UnresolvedType aType) {
+    private ReferenceType resolveGenericWildcardFor(WildcardedUnresolvedType aType) {
     	BoundedReferenceType ret = null;
     	// FIXME asc doesnt take account of additional interface bounds (e.g. ? super R & Serializable - can you do that?)
     	if (aType.isExtends()) {
@@ -473,7 +473,8 @@ public abstract class World implements Dump.INode {
     		ReferenceType lowerBound = (ReferenceType) resolve(aType.getLowerBound());
     		ret = new BoundedReferenceType(lowerBound,false,this);
     	} else {
-    		// must be ? on its own!
+            // must be ? on its own!
+    	    ret = new BoundedReferenceType("*", "Ljava/lang/Object", this);
     	}
     	return ret;
     }
@@ -1425,7 +1425,7 @@ public class BcelWeaver implements IWeaver {
     public UnwovenClassFile[] getClassFilesFor(LazyClassGen clazz) {
     	List childClasses = clazz.getChildClasses(world);
     	UnwovenClassFile[] ret = new UnwovenClassFile[1 + childClasses.size()];    	
-    	ret[0] = new UnwovenClassFile(clazz.getFileName(),clazz.getJavaClassBytesIncludingReweavable(world));
+    	ret[0] = new UnwovenClassFile(clazz.getFileName(),clazz.getClassName(),clazz.getJavaClassBytesIncludingReweavable(world));
     	int index = 1;
     	for (Iterator iter = childClasses.iterator(); iter.hasNext();) {
 			UnwovenClassFile.ChildClass element = (UnwovenClassFile.ChildClass) iter.next();
@@ -24,7 +24,6 @@ import java.util.LinkedList;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Map;
-import java.util.Properties;
 import java.util.Set;
 import java.util.Stack;
 
@@ -39,23 +38,18 @@ import org.aspectj.apache.bcel.generic.ClassGenException;
 import org.aspectj.apache.bcel.generic.CodeExceptionGen;
 import org.aspectj.apache.bcel.generic.Instruction;
 import org.aspectj.apache.bcel.generic.InstructionBranch;
-import org.aspectj.apache.bcel.generic.InstructionComparator;
 import org.aspectj.apache.bcel.generic.InstructionHandle;
 import org.aspectj.apache.bcel.generic.InstructionList;
 import org.aspectj.apache.bcel.generic.InstructionSelect;
 import org.aspectj.apache.bcel.generic.InstructionTargeter;
-import org.aspectj.apache.bcel.generic.LineNumberGen;
 import org.aspectj.apache.bcel.generic.LineNumberTag;
-import org.aspectj.apache.bcel.generic.LocalVariableGen;
 import org.aspectj.apache.bcel.generic.LocalVariableTag;
 import org.aspectj.apache.bcel.generic.MethodGen;
 import org.aspectj.apache.bcel.generic.ObjectType;
 import org.aspectj.apache.bcel.generic.Tag;
-import org.aspectj.apache.bcel.generic.TargetLostException;
 import org.aspectj.apache.bcel.generic.Type;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
-import org.aspectj.bridge.MessageUtil;
 import org.aspectj.weaver.AjAttribute;
 import org.aspectj.weaver.AnnotationX;
 import org.aspectj.weaver.BCException;
@@ -1,39 +0,0 @@
-/* *******************************************************************
- * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
- * All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://www.eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: 
- *     PARC     initial implementation 
- * ******************************************************************/
-
-
-package org.aspectj.weaver.bcel;
-
-import java.io.File;
-import java.io.IOException;
-
-
-//XXX delete very soon
-public class ZipFileWeaver {
-	File inFile;
-	public ZipFileWeaver(File inFile) {
-		super();
-		this.inFile = inFile;
-	}
-
-	public void weave(BcelWeaver weaver, File outFile) throws IOException {
-		int count = 0;
-		long startTime = System.currentTimeMillis();
-		weaver.addJarFile(inFile, new File("."),false);
-		weaver.weave(outFile);
-		long stopTime = System.currentTimeMillis();
-		
-		
-		System.out.println("handled " + count + " entries, in " + 
-				(stopTime-startTime)/1000. + " seconds");
-	}
-}
@@ -42,8 +42,8 @@ import org.aspectj.weaver.patterns.Pointcut;
  *     which may modify state.  
  * Then implement is called. 
  */
-
 public abstract class ShadowMunger implements PartialOrder.PartialComparable, IHasPosition {
+
 	protected Pointcut pointcut;
 
 	// these three fields hold the source location of this munger
@@ -274,106 +274,6 @@ public class MemberImpl implements Comparable, AnnotatedElement,Member {
 
     // ---- parsing methods
 
-    /** Takes a string in this form:
-     * 
-     * <blockquote><pre>
-     * static? TypeName TypeName.Id
-     * </pre></blockquote>
-     * Pretty much just for testing, and as such should perhaps be moved.
-     */
-    
-    public static MemberImpl fieldFromString(String str) {
-        str = str.trim();
-        final int len = str.length();
-        int i = 0;
-        int mods = 0;
-        if (str.startsWith("static", i)) {
-            mods = Modifier.STATIC;
-            i += 6;
-            while (Character.isWhitespace(str.charAt(i))) i++;
-        }
-        int start = i;
-        while (! Character.isWhitespace(str.charAt(i))) i++;
-        UnresolvedType retTy = UnresolvedType.forName(str.substring(start, i));
-
-        start = i;
-        i = str.lastIndexOf('.');
-        UnresolvedType declaringTy = UnresolvedType.forName(str.substring(start, i).trim());
-        start = ++i;
-        String name = str.substring(start, len).trim();
-        return new MemberImpl(
-            FIELD,
-            declaringTy,
-            mods,
-            retTy,
-            name,
-            UnresolvedType.NONE);
-    }
-
-    /** Takes a string in this form:
-     * 
-     * <blockquote><pre>
-     * (static|interface|private)? TypeName TypeName . Id ( TypeName , ...)
-     * </pre></blockquote>
-     * Pretty much just for testing, and as such should perhaps be moved.
-     */
-    
-    public static Member methodFromString(String str) {
-        str = str.trim();
-        // final int len = str.length();
-        int i = 0;
-
-        int mods = 0;
-        if (str.startsWith("static", i)) {
-            mods = Modifier.STATIC;
-            i += 6;
-        } else if (str.startsWith("interface", i)) {
-            mods = Modifier.INTERFACE;
-            i += 9;
-        } else if (str.startsWith("private", i)) {
-            mods = Modifier.PRIVATE;
-            i += 7;
-        }            
-        while (Character.isWhitespace(str.charAt(i))) i++;
-        
-        int start = i;
-        while (! Character.isWhitespace(str.charAt(i))) i++;
-        UnresolvedType returnTy = UnresolvedType.forName(str.substring(start, i));
-
-        start = i;
-        i = str.indexOf('(', i);
-        i = str.lastIndexOf('.', i);
-        UnresolvedType declaringTy = UnresolvedType.forName(str.substring(start, i).trim());
-        
-        start = ++i;
-        i = str.indexOf('(', i);
-        String name = str.substring(start, i).trim();
-        start = ++i;
-        i = str.indexOf(')', i);
-    
-        String[] paramTypeNames = parseIds(str.substring(start, i).trim());
-
-        return method(declaringTy, mods, returnTy, name, UnresolvedType.forNames(paramTypeNames));
-    }
-
-    private static String[] parseIds(String str) {
-        if (str.length() == 0) return ZERO_STRINGS;
-        List l = new ArrayList();
-        int start = 0;
-        while (true) {
-            int i = str.indexOf(',', start);
-            if (i == -1) {
-                l.add(str.substring(start).trim());
-                break;
-            }
-            l.add(str.substring(start, i).trim());
-            start = i+1;
-        }
-        return (String[]) l.toArray(new String[l.size()]);
-    }
-
-    private static final String[] ZERO_STRINGS = new String[0];
-
     // ---- things we know without resolution
 
     public boolean equals(Object other) {
@@ -561,6 +461,7 @@ public class MemberImpl implements Comparable, AnnotatedElement,Member {
 		return resolved.getExceptions();
     }
 
+    // OPTIMIZE remove world related isMethods()
     /* (non-Javadoc)
 	 * @see org.aspectj.weaver.Member#isProtected(org.aspectj.weaver.World)
 	 */
@@ -623,6 +524,7 @@ public class MemberImpl implements Comparable, AnnotatedElement,Member {
 	 * @see org.aspectj.weaver.Member#getExtractableName()
 	 */
     public final String getExtractableName() {
+    // OPTIMIZE remove silly string compares for init - use kind==CTOR/STATIC_INITIALIZATION
     	if (name.equals("<init>")) return "init$";
     	else if (name.equals("<clinit>")) return "clinit$";
     	else return name;
@@ -631,6 +533,7 @@ public class MemberImpl implements Comparable, AnnotatedElement,Member {
     /* (non-Javadoc)
 	 * @see org.aspectj.weaver.Member#hasAnnotation(org.aspectj.weaver.UnresolvedType)
 	 */
+	 // OPTIMIZE dont have these here, move them down to ResolvedMember
 	public boolean hasAnnotation(UnresolvedType ofType) {
 		throw new UnsupportedOperationException("You should resolve this member and call hasAnnotation() on the result...");
 	}
@@ -292,18 +292,6 @@ public class JoinPointSignature implements ResolvedMember {
 		return realMember.isCompatibleWith(am);
 	}
 
-	public boolean isProtected(World world) {
-		return realMember.isProtected(world);
-	}
-
-	public boolean isStatic(World world) {
-		return realMember.isStatic(world);
-	}
-
-	public boolean isStrict(World world) {
-		return realMember.isStrict(world);
-	}
-
 	public boolean isStatic() {
 		return realMember.isStatic();
 	}
@@ -28,20 +28,33 @@ import org.aspectj.weaver.patterns.PerClause;
  */
 public class BoundedReferenceType extends ReferenceType {
 
-	protected ReferenceType[] additionalInterfaceBounds = new ReferenceType[0];
-	
-	protected boolean isExtends = true;
-	protected boolean isSuper   = false;
+    private UnresolvedType lowerBound;
+
+    private UnresolvedType upperBound;
+
+    protected ReferenceType[] additionalInterfaceBounds = new ReferenceType[0];
+
+    protected boolean isExtends = true;
+
+    protected boolean isSuper = false;
+
+    public UnresolvedType getUpperBound() {
+        return upperBound;
+    }
+
+    public UnresolvedType getLowerBound() {
+        return lowerBound;
+    }
 
 	public BoundedReferenceType(ReferenceType aBound, boolean isExtends, World world) {
 		super((isExtends ? "+" : "-") + aBound.signature,aBound.signatureErasure,world);
 		this.isExtends = isExtends; 
 		this.isSuper   = !isExtends;
 		if (isExtends) { 
-			setUpperBound(aBound);
+			upperBound = aBound;
 		} else {
-			setLowerBound(aBound);
-			setUpperBound(world.resolve(UnresolvedType.OBJECT));
+			lowerBound = aBound;
+            upperBound = world.resolve(UnresolvedType.OBJECT);
 		}
 		setDelegate(new ReferenceTypeReferenceTypeDelegate((ReferenceType)getUpperBound()));
 	}
@@ -72,7 +85,7 @@ public class BoundedReferenceType extends ReferenceType {
 	 */
 	protected BoundedReferenceType(String sig, String sigErasure, World world) {
 		super(sig, sigErasure, world);
-		setUpperBound(world.resolve(UnresolvedType.OBJECT));
+		upperBound = world.resolve(UnresolvedType.OBJECT);
 		setDelegate(new ReferenceTypeReferenceTypeDelegate((ReferenceType)getUpperBound()));
 	}
 
@@ -103,21 +116,22 @@ public class BoundedReferenceType extends ReferenceType {
 	public boolean canBeCoercedTo(ResolvedType aCandidateType) {
 		if (alwaysMatches(aCandidateType)) return true;
 		if (aCandidateType.isGenericWildcard()) {
+		    BoundedReferenceType boundedRT = (BoundedReferenceType) aCandidateType;
 			ResolvedType myUpperBound = (ResolvedType) getUpperBound();
 			ResolvedType myLowerBound = (ResolvedType) getLowerBound();
 			if (isExtends()) {
-				if (aCandidateType.isExtends()) {
-					return myUpperBound.isAssignableFrom((ResolvedType)aCandidateType.getUpperBound()); 
-				} else if (aCandidateType.isSuper()) {
-					return myUpperBound == aCandidateType.getLowerBound();
+				if (boundedRT.isExtends()) {
+                    return myUpperBound.isAssignableFrom((ResolvedType) boundedRT.getUpperBound());
+                } else if (boundedRT.isSuper()) {
+                    return myUpperBound == boundedRT.getLowerBound();
 				} else {
 					return true;  // it's '?'
 				}
 			} else if (isSuper()) {
-				if (aCandidateType.isSuper()) {
-					return ((ResolvedType)aCandidateType.getLowerBound()).isAssignableFrom(myLowerBound);
-				} else if (aCandidateType.isExtends()) {
-					return myLowerBound == aCandidateType.getUpperBound();
+				if (boundedRT.isSuper()) {
+                    return ((ResolvedType) boundedRT.getLowerBound()).isAssignableFrom(myLowerBound);
+                } else if (boundedRT.isExtends()) {
+                    return myLowerBound == boundedRT.getUpperBound();
 				} else {
 					return true;
 				}
@@ -13,11 +13,10 @@
 
 package org.aspectj.weaver;
 
-import org.aspectj.lang.JoinPoint;
-import org.aspectj.lang.ProceedingJoinPoint;
-
 import java.lang.reflect.Modifier;
 
+import org.aspectj.lang.JoinPoint;
+
 //import org.aspectj.weaver.ResolvedType.Name;
 
 
@@ -37,13 +36,13 @@ public class AjcMemberMaker {
 	public static final UnresolvedType CFLOW_STACK_TYPE = 
 		UnresolvedType.forName(NameMangler.CFLOW_STACK_TYPE);
 	public static final UnresolvedType AROUND_CLOSURE_TYPE = 
-		UnresolvedType.forName("org.aspectj.runtime.internal.AroundClosure");
+		UnresolvedType.forSignature("Lorg/aspectj/runtime/internal/AroundClosure;");
 
 	public static final UnresolvedType CONVERSIONS_TYPE =
-		UnresolvedType.forName("org.aspectj.runtime.internal.Conversions");
+		UnresolvedType.forSignature("Lorg/aspectj/runtime/internal/Conversions;");
 
 	public static final UnresolvedType NO_ASPECT_BOUND_EXCEPTION =
-		UnresolvedType.forName("org.aspectj.lang.NoAspectBoundException");
+		UnresolvedType.forSignature("Lorg/aspectj/lang/NoAspectBoundException;");
 
 	public static ResolvedMember ajcPreClinitMethod(UnresolvedType declaringType) {
 		return new ResolvedMemberImpl(
@@ -800,21 +799,34 @@ public class AjcMemberMaker {
 	}
 
     //-- common types we use. Note: Java 5 dependand types are refered to as String
-    public final static UnresolvedType ASPECT_ANNOTATION = UnresolvedType.forName("org.aspectj.lang.annotation.Aspect");
-    public final static UnresolvedType BEFORE_ANNOTATION = UnresolvedType.forName("org.aspectj.lang.annotation.Before");
-    public final static UnresolvedType AROUND_ANNOTATION = UnresolvedType.forName("org.aspectj.lang.annotation.Around");
-    public final static UnresolvedType AFTERRETURNING_ANNOTATION = UnresolvedType.forName("org.aspectj.lang.annotation.AfterReturning");
-    public final static UnresolvedType AFTERTHROWING_ANNOTATION = UnresolvedType.forName("org.aspectj.lang.annotation.AfterThrowing");
-    public final static UnresolvedType AFTER_ANNOTATION = UnresolvedType.forName("org.aspectj.lang.annotation.After");
-    public final static UnresolvedType POINTCUT_ANNOTATION = UnresolvedType.forName("org.aspectj.lang.annotation.Pointcut");
-    public final static UnresolvedType DECLAREERROR_ANNOTATION = UnresolvedType.forName("org.aspectj.lang.annotation.DeclareError");
-    public final static UnresolvedType DECLAREWARNING_ANNOTATION = UnresolvedType.forName("org.aspectj.lang.annotation.DeclareWarning");
-    public final static UnresolvedType DECLAREPRECEDENCE_ANNOTATION = UnresolvedType.forName("org.aspectj.lang.annotation.DeclarePrecedence");
-    public final static UnresolvedType DECLAREIMPLEMENTS_ANNOTATION = UnresolvedType.forName("org.aspectj.lang.annotation.DeclareImplements");
-    public final static UnresolvedType DECLAREPARENTS_ANNOTATION = UnresolvedType.forName("org.aspectj.lang.annotation.DeclareParents");
-
-    public final static UnresolvedType TYPEX_JOINPOINT = UnresolvedType.forName(JoinPoint.class.getName().replace('/','.'));
-    public final static UnresolvedType TYPEX_PROCEEDINGJOINPOINT = UnresolvedType.forName(ProceedingJoinPoint.class.getName().replace('/','.'));
+	public final static UnresolvedType ASPECT_ANNOTATION = UnresolvedType.forSignature("Lorg/aspectj/lang/annotation/Aspect;");
+
+    public final static UnresolvedType BEFORE_ANNOTATION = UnresolvedType.forSignature("Lorg/aspectj/lang/annotation/Before;");
+
+    public final static UnresolvedType AROUND_ANNOTATION = UnresolvedType.forSignature("Lorg/aspectj/lang/annotation/Around;");
+
+    public final static UnresolvedType AFTERRETURNING_ANNOTATION = UnresolvedType.forSignature("Lorg/aspectj/lang/annotation/AfterReturning;");
+
+    public final static UnresolvedType AFTERTHROWING_ANNOTATION = UnresolvedType.forSignature("Lorg/aspectj/lang/annotation/AfterThrowing;");
+
+    public final static UnresolvedType AFTER_ANNOTATION = UnresolvedType.forSignature("Lorg/aspectj/lang/annotation/After;");
+
+    public final static UnresolvedType POINTCUT_ANNOTATION = UnresolvedType.forSignature("Lorg/aspectj/lang/annotation/Pointcut;");
+
+    public final static UnresolvedType DECLAREERROR_ANNOTATION = UnresolvedType.forSignature("Lorg/aspectj/lang/annotation/DeclareError;");
+
+    public final static UnresolvedType DECLAREWARNING_ANNOTATION = UnresolvedType.forSignature("Lorg/aspectj/lang/annotation/DeclareWarning;");
+
+    public final static UnresolvedType DECLAREPRECEDENCE_ANNOTATION = UnresolvedType.forSignature("Lorg/aspectj/lang/annotation/DeclarePrecedence;");
+
+    public final static UnresolvedType DECLAREIMPLEMENTS_ANNOTATION = UnresolvedType.forSignature("Lorg/aspectj/lang/annotation/DeclareImplements;");
+
+    public final static UnresolvedType DECLAREPARENTS_ANNOTATION = UnresolvedType.forSignature("Lorg/aspectj/lang/annotation/DeclareParents;");
+
+    public final static UnresolvedType TYPEX_JOINPOINT = UnresolvedType.forSignature("Lorg/aspectj/lang/JoinPoint;");// UnresolvedType.forName(JoinPoint.class.getName().replace('/','.'));
+
+    public final static UnresolvedType TYPEX_PROCEEDINGJOINPOINT = UnresolvedType.forSignature("Lorg/aspectj/lang/ProceedingJoinPoint;");// UnresolvedType.forName(ProceedingJoinPoint.class.getName().replace('/','.'));
+    
     public final static UnresolvedType TYPEX_STATICJOINPOINT = UnresolvedType.forName(JoinPoint.StaticPart.class.getName().replace('/','.'));
     public final static UnresolvedType TYPEX_ENCLOSINGSTATICJOINPOINT = UnresolvedType.forName(JoinPoint.EnclosingStaticPart.class.getName().replace('/','.'));
 
@@ -91,8 +91,8 @@ public class Ajc153Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testParsingBytecodeLess_pr152871() { 
 	  Utility.testingParseCounter=0;
 	  runTest("parsing bytecode less"); 
-	  assertTrue("Should have called parse 5 times, not "+Utility.testingParseCounter+" times",Utility.testingParseCounter==5);
-	  // 5 means:   
+	  assertTrue("Should have called parse 2 times, not " + Utility.testingParseCounter + " times", Utility.testingParseCounter == 2);
+        // 5 means: // 3 of these are gone with change to UnwovenClassFileWTPMB to take a classname in ctor
 	  // (1)=registerAspect   
 	  // (2,3)=checkingIfShouldWeave,AcceptingResult for class
 	  // (4,5)=checkingIfShouldWeave,AcceptingResult for aspect
@@ -71,6 +71,7 @@ import org.aspectj.weaver.TypeVariableDeclaringElement;
 import org.aspectj.weaver.TypeVariableReference;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.UnresolvedTypeVariableReferenceType;
+import org.aspectj.weaver.WildcardedUnresolvedType;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.UnresolvedType.TypeKind;
 
@@ -223,9 +224,6 @@ public class EclipseFactory {
 
 		if (binding instanceof WildcardBinding) {
 			WildcardBinding eWB = (WildcardBinding) binding;
-			UnresolvedType theType = TypeFactory.createTypeFromSignature(CharOperation.charToString(eWB.genericTypeSignature()));
-		    
-			
 			// Repair the bound
 			// e.g. If the bound for the wildcard is a typevariable, e.g. '? extends E' then
 			// the type variable in the unresolvedtype will be correct only in name.  In that
@@ -236,8 +234,12 @@ public class EclipseFactory {
 			} else {
 				theBound = fromBinding(eWB.bound);
 			}
-			if (theType.isGenericWildcard() && theType.isSuper()) theType.setLowerBound(theBound);
-			if (theType.isGenericWildcard() && theType.isExtends()) theType.setUpperBound(theBound);
+            // if (eWB.boundKind == WildCard.SUPER) {
+            //
+            // }
+            WildcardedUnresolvedType theType = (WildcardedUnresolvedType) TypeFactory.createTypeFromSignature(CharOperation.charToString(eWB.genericTypeSignature()));
+            // if (theType.isGenericWildcard() && theType.isSuper()) theType.setLowerBound(theBound);
+            // if (theType.isGenericWildcard() && theType.isExtends()) theType.setUpperBound(theBound);
 			return theType;
 		}
 
@@ -10,8 +10,11 @@
  *******************************************************************************/
 package org.aspectj.ajdt.internal.compiler;
 
+import java.util.Iterator;
+
 import org.aspectj.weaver.bcel.UnwovenClassFile;
 import org.aspectj.weaver.bcel.UnwovenClassFileWithThirdPartyManagedBytecode;
+import org.aspectj.org.eclipse.jdt.core.compiler.CharOperation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ClassFile;
 import org.aspectj.org.eclipse.jdt.internal.compiler.CompilationResult;
 
@@ -38,11 +41,15 @@ public class ClassFileBasedByteCodeProvider
 	public static UnwovenClassFile[] unwovenClassFilesFor(CompilationResult result, 
 										            IOutputClassFileNameProvider nameProvider) {
 		ClassFile[] cfs = result.getClassFiles();
-		UnwovenClassFile[] ret = new UnwovenClassFile[cfs.length];
-		for (int i = 0; i < ret.length; i++) {
-			ClassFileBasedByteCodeProvider p = new ClassFileBasedByteCodeProvider(cfs[i]);
-			String fileName = nameProvider.getOutputClassFileName(cfs[i].fileName(), result);
-			ret[i] = new UnwovenClassFileWithThirdPartyManagedBytecode(fileName,p);
+		UnwovenClassFile[] ret = new UnwovenClassFile[result.compiledTypes.size()];
+		int i=0;
+		for (Iterator iterator = result.compiledTypes.keySet().iterator(); iterator.hasNext();) {
+			char[] className = (char[])iterator.next();
+			ClassFile cf = (ClassFile)result.compiledTypes.get(className);
+			// OPTIMIZE use char[] for classname
+			ClassFileBasedByteCodeProvider p = new ClassFileBasedByteCodeProvider(cf);
+			String fileName = nameProvider.getOutputClassFileName(cf.fileName(), result);
+			ret[i++] = new UnwovenClassFileWithThirdPartyManagedBytecode(fileName,new String(className).replace('/','.'),p);
 		}
 		return ret;
 	}
@@ -33,9 +33,9 @@ public class SignaturePatternTestCase extends TestCase {
 	BcelWorld world = new BcelWorld();
 
 	public void testThrowsMatch() throws IOException {
-		Member onlyDerivedOnDerived = MemberImpl.methodFromString("static void fluffy.Derived.onlyDerived()");
-		Member mOnBase = MemberImpl.methodFromString("void fluffy.Base.m()");
-		Member mOnDerived = MemberImpl.methodFromString("void fluffy.Derived.m()");
+		Member onlyDerivedOnDerived = TestUtils.methodFromString("static void fluffy.Derived.onlyDerived()");
+		Member mOnBase = TestUtils.methodFromString("void fluffy.Base.m()");
+		Member mOnDerived = TestUtils.methodFromString("void fluffy.Derived.m()");
 
 		checkMatch(makeMethodPat("* fluffy.Base.*(..) throws java.lang.CloneNotSupportedException"),
 					new Member[] { mOnBase },
@@ -66,9 +66,9 @@ public class SignaturePatternTestCase extends TestCase {
 	}
 
 	public void testInstanceMethodMatch() throws IOException {
-		Member objectToString = MemberImpl.methodFromString("java.lang.String java.lang.Object.toString()");
-		Member integerToString = MemberImpl.methodFromString("java.lang.String java.lang.Integer.toString()");
-		Member integerIntValue = MemberImpl.methodFromString("int java.lang.Integer.intValue()");
+		Member objectToString = TestUtils.methodFromString("java.lang.String java.lang.Object.toString()");
+		Member integerToString = TestUtils.methodFromString("java.lang.String java.lang.Integer.toString()");
+		Member integerIntValue = TestUtils.methodFromString("int java.lang.Integer.intValue()");
 		//Member objectToString = Member.methodFromString("java.lang.String java.lang.Object.toString()");
 
 		checkMatch(makeMethodPat("* java.lang.Object.*(..)"),
@@ -82,11 +82,11 @@ public class SignaturePatternTestCase extends TestCase {
 
 
 	public void testStaticMethodMatch() throws IOException {
-		Member onlyBaseOnBase = MemberImpl.methodFromString("static void fluffy.Base.onlyBase()");
-		Member onlyBaseOnDerived = MemberImpl.methodFromString("static void fluffy.Derived.onlyBase()");
-		Member onlyDerivedOnDerived = MemberImpl.methodFromString("static void fluffy.Derived.onlyDerived()");
-		Member bothOnBase = MemberImpl.methodFromString("static void fluffy.Base.both()");
-		Member bothOnDerived = MemberImpl.methodFromString("static void fluffy.Derived.both()");
+		Member onlyBaseOnBase = TestUtils.methodFromString("static void fluffy.Base.onlyBase()");
+		Member onlyBaseOnDerived = TestUtils.methodFromString("static void fluffy.Derived.onlyBase()");
+		Member onlyDerivedOnDerived = TestUtils.methodFromString("static void fluffy.Derived.onlyDerived()");
+		Member bothOnBase = TestUtils.methodFromString("static void fluffy.Base.both()");
+		Member bothOnDerived = TestUtils.methodFromString("static void fluffy.Derived.both()");
 
 		checkMatch(makeMethodPat("* fluffy.Base.*(..)"),
 					new Member[] { onlyBaseOnBase, onlyBaseOnDerived, bothOnBase },
@@ -98,11 +98,11 @@ public class SignaturePatternTestCase extends TestCase {
 	}
 
 	public void testFieldMatch() throws IOException {
-		Member onlyBaseOnBase = MemberImpl.fieldFromString("int fluffy.Base.onlyBase");
-		Member onlyBaseOnDerived = MemberImpl.fieldFromString("int fluffy.Derived.onlyBase");
-		Member onlyDerivedOnDerived = MemberImpl.fieldFromString("int fluffy.Derived.onlyDerived");
-		Member bothOnBase = MemberImpl.fieldFromString("int fluffy.Base.both");
-		Member bothOnDerived = MemberImpl.fieldFromString("int fluffy.Derived.both");
+		Member onlyBaseOnBase = TestUtils.fieldFromString("int fluffy.Base.onlyBase");
+		Member onlyBaseOnDerived = TestUtils.fieldFromString("int fluffy.Derived.onlyBase");
+		Member onlyDerivedOnDerived = TestUtils.fieldFromString("int fluffy.Derived.onlyDerived");
+		Member bothOnBase = TestUtils.fieldFromString("int fluffy.Base.both");
+		Member bothOnDerived = TestUtils.fieldFromString("int fluffy.Derived.both");
 
 		checkMatch(makeFieldPat("* fluffy.Base.*"),
 					new Member[] { onlyBaseOnBase, onlyBaseOnDerived, bothOnBase },
@@ -114,9 +114,9 @@ public class SignaturePatternTestCase extends TestCase {
 	}
 
 	public void testConstructorMatch() throws IOException {
-		Member onBase = MemberImpl.methodFromString("void fluffy.Base.<init>()");
-		Member onDerived = MemberImpl.methodFromString("void fluffy.Derived.<init>()");
-		Member onBaseWithInt = MemberImpl.methodFromString("void fluffy.Base.<init>(int)");
+		Member onBase = TestUtils.methodFromString("void fluffy.Base.<init>()");
+		Member onDerived = TestUtils.methodFromString("void fluffy.Derived.<init>()");
+		Member onBaseWithInt = TestUtils.methodFromString("void fluffy.Base.<init>(int)");
 
 
 		checkMatch(makeMethodPat("fluffy.Base.new(..)"),
@@ -50,7 +50,7 @@ public class VisitorTestCase extends TestCase {
         for (Iterator iterator = pointcuts.iterator(); iterator.hasNext();) {
             String pointcut = (String) iterator.next();
             try  {
-                PatternNodeVisitor.DumpPointcutVisitor.check(pointcut);
+                DumpPointcutVisitor.check(pointcut);
             } catch (Throwable t) {
                 t.printStackTrace();
                 fail("Failed on '"+pointcut+"': " +t.toString());
@@ -66,7 +66,7 @@ public class VisitorTestCase extends TestCase {
             String tp = (String) iterator.next();
             try  {
                 TypePattern p = new PatternParser(tp).parseTypePattern();
-                PatternNodeVisitor.DumpPointcutVisitor.check(p, true);
+                DumpPointcutVisitor.check(p, true);
             } catch (Throwable t) {
                 fail("Failed on '"+tp+"': " +t.toString());
             }
@@ -23,6 +23,7 @@ import junit.framework.TestCase;
 import org.aspectj.util.FuzzyBoolean;
 import org.aspectj.weaver.IntMap;
 import org.aspectj.weaver.MemberImpl;
+import org.aspectj.weaver.TestUtils;
 import org.aspectj.weaver.Shadow;
 import org.aspectj.weaver.TestShadow;
 import org.aspectj.weaver.UnresolvedType;
@@ -41,7 +42,7 @@ public class WithinTestCase extends TestCase {
 	public void testMatch() throws IOException {
 		Shadow getOutFromArrayList = new TestShadow(
 			Shadow.FieldGet, 
-			MemberImpl.fieldFromString("java.io.PrintStream java.lang.System.out"),
+			TestUtils.fieldFromString("java.io.PrintStream java.lang.System.out"),
 			UnresolvedType.forName("java.util.ArrayList"),
 			world);
 
@@ -57,7 +58,7 @@ public class WithinTestCase extends TestCase {
 
 		Shadow getOutFromEntry = new TestShadow(
 			Shadow.FieldGet, 
-			MemberImpl.fieldFromString("java.io.PrintStream java.lang.System.out"),
+			TestUtils.fieldFromString("java.io.PrintStream java.lang.System.out"),
 			UnresolvedType.forName("java.util.Map$Entry"),
 			world);
 
@@ -12,7 +12,6 @@
  *******************************************************************************/
 package org.aspectj.weaver.patterns;
 
-import org.aspectj.weaver.Member;
 
 /**
  * A Pointcut or TypePattern visitor
@@ -93,515 +92,4 @@ public interface PatternNodeVisitor {
 	// Catch-all
     Object visit(PatternNode node, Object data);
 
-    /**
-     * A sample toString like visitor that helps understanding the AST tree structure organization
-     *
-     * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
-     */
-    static class DumpPointcutVisitor implements PatternNodeVisitor {
-
-        private StringBuffer sb = new StringBuffer();
-        public String get() {
-            return sb.toString();
-        }
-
-        private void append(Object o) {
-            sb.append(o.toString());
-        }
-		
-		private void append(char c) {
-			sb.append(c);
-		}
-
-        /**
-         * This method helps maintaining the API and raises warning when PatternNode subclasses do not
-         * implement the visitor pattern
-         *
-         * @param node
-         * @param data
-         * @return
-         */
-        public Object visit(PatternNode node, Object data) {
-            System.err.println("Should implement: "  + node.getClass());
-            return null;
-        }
-
-        public Object visit(AnyTypePattern node, Object data) {
-            append('*');
-            return null;
-        }
-
-        public Object visit(NoTypePattern node, Object data) {
-            append(node.toString());//TODO no idea when this one is used
-            return null;
-        }
-
-        public Object visit(EllipsisTypePattern node, Object data) {
-            append(node.toString());
-            return null;
-        }
-
-        public Object visit(AnyWithAnnotationTypePattern node, Object data) {
-            node.annotationPattern.accept(this, data);
-            append(" *");
-            return null;
-        }
-
-        public Object visit(AnyAnnotationTypePattern node, Object data) {
-            //@ANY : ignore
-            append('*');
-            return null;
-        }
-
-        public Object visit(EllipsisAnnotationTypePattern node, Object data) {
-            append("..");
-            return null;
-        }
-
-        public Object visit(AndAnnotationTypePattern node, Object data) {
-            node.getLeft().accept(this, data);
-            append(' ');
-            node.getRight().accept(this, data);
-            return null;
-        }
-
-        public Object visit(AndPointcut node, Object data) {
-            append('(');
-            node.getLeft().accept(this, data);
-            append(" && ");
-            node.getRight().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(AndTypePattern node, Object data) {
-            append('(');
-            node.getLeft().accept(this, data);
-            append(" && ");
-            node.getRight().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(AnnotationPatternList node, Object data) {
-            AnnotationTypePattern[] annotations = node.getAnnotationPatterns();
-            for (int i = 0; i < annotations.length; i++) {
-                if (i>0) append(", ");//Note: list is ",", and is " " separated for annotations
-                annotations[i].accept(this, data);
-            }
-            return null;
-        }
-
-        public Object visit(AnnotationPointcut node, Object data) {
-            append("@annotation(");
-            node.getAnnotationTypePattern().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(ArgsAnnotationPointcut node, Object data) {
-            append("@args(");
-            node.getArguments().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(ArgsPointcut node, Object data) {
-            append("args(");
-            node.getArguments().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(BindingAnnotationTypePattern node, Object data) {
-            append(node);
-            return null;
-        }
-
-        public Object visit(BindingTypePattern node, Object data) {
-            append(node);
-            return null;
-        }
-
-        public Object visit(CflowPointcut node, Object data) {
-            append(node.isCflowBelow()?"cflowbelow(":"cflow(");
-            node.getEntry().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(ExactAnnotationTypePattern node, Object data) {
-            //append('@'); // since @annotation(@someAnno) cannot be parsed anymore
-            append(node.getAnnotationType().getName());
-            return null;
-        }
-
-        public Object visit(ExactTypePattern node, Object data) {
-            if (node.getAnnotationPattern() != AnnotationTypePattern.ANY) {
-                append('(');
-                node.getAnnotationPattern().accept(this, data);
-                append(' ');
-            }
-
-            String typeString = node.getType().toString();
-            if (node.isVarArgs()) typeString = typeString.substring(0, typeString.lastIndexOf('['));//TODO AV - ugly
-            append(typeString);
-            if (node.isIncludeSubtypes()) append('+');
-            if (node.isVarArgs()) append("...");
-            if (node.getAnnotationPattern() != AnnotationTypePattern.ANY) {
-                append(')');
-            }
-            return null;
-        }
-
-        public Object visit(KindedPointcut node, Object data) {
-            append(node.getKind().getSimpleName());
-            append('(');
-            node.getSignature().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(ModifiersPattern node, Object data) {
-            append(node.toString());//note: node takes care of forbidden mods
-            return null;
-        }
-
-        public Object visit(NamePattern node, Object data) {
-            append(node.toString());
-            return null;
-        }
-
-        public Object visit(NotAnnotationTypePattern node, Object data) {
-            append("!");
-            node.getNegatedPattern().accept(this, data);
-            return null;
-        }
-
-        public Object visit(NotPointcut node, Object data) {
-            append("!(");
-            node.getNegatedPointcut().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(NotTypePattern node, Object data) {
-            append("!(");
-            node.getNegatedPattern().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(OrAnnotationTypePattern node, Object data) {
-            append('(');
-            node.getLeft().accept(this, data);
-            append(" || ");
-            node.getRight().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(OrPointcut node, Object data) {
-            append('(');
-            node.getLeft().accept(this, data);
-            append(" || ");
-            node.getRight().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(OrTypePattern node, Object data) {
-            append('(');
-            node.getLeft().accept(this, data);
-            append(" || ");
-            node.getRight().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(ReferencePointcut node, Object data) {
-            append(node.toString());
-            return null;
-        }
-
-        public Object visit(SignaturePattern node, Object data) {
-            if (node.getAnnotationPattern() != AnnotationTypePattern.ANY) {
-                node.getAnnotationPattern().accept(this, data);
-                append(' ');
-            }
-
-            if (node.getModifiers() != ModifiersPattern.ANY) {
-                node.getModifiers().accept(this, data);
-                append(' ');
-            }
-
-            if (node.getKind() == Member.STATIC_INITIALIZATION) {
-                node.getDeclaringType().accept(this, data);
-            } else if (node.getKind() == Member.HANDLER) {
-                append("handler(");
-                node.getParameterTypes().get(0).accept(this, data);//Note: we know we have 1 child
-                append(')');
-            } else {
-                if (!(node.getKind() == Member.CONSTRUCTOR)) {
-                    node.getReturnType().accept(this, data);
-                    append(' ');
-                }
-                if (node.getDeclaringType() != TypePattern.ANY) {
-                    node.getDeclaringType().accept(this, data);
-                    append('.');
-                }
-                if (node.getKind() == Member.CONSTRUCTOR) {
-                    append("new");
-                } else {
-                    node.getName().accept(this, data);
-                }
-                if (node.getKind() == Member.METHOD || node.getKind() == Member.CONSTRUCTOR) {
-                    append('(');
-                    node.getParameterTypes().accept(this, data);
-                    append(')');
-                }
-                if (node.getThrowsPattern() != null) {
-                    append(' ');
-                    node.getThrowsPattern().accept(this, data);
-                }
-            }
-            return null;
-        }
-
-        public Object visit(ThisOrTargetAnnotationPointcut node, Object data) {
-            append(node.isThis() ? "@this(" : "@target(");
-            node.getAnnotationTypePattern().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(ThisOrTargetPointcut node, Object data) {
-            append(node.isThis() ? "this(" : "target(");
-            node.getType().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        // Note: a visitor instance is not thread safe so should not be shared
-        private boolean inThrowsForbidden = false;
-
-        public Object visit(ThrowsPattern node, Object data) {
-            if (node == ThrowsPattern.ANY) return null;
-
-            append("throws ");
-            node.getRequired().accept(this, data);
-            if (node.getForbidden().size() > 0) {
-                // a hack since throws !(A, B) cannot be parsed
-                try {
-                    inThrowsForbidden = true;
-                    node.getForbidden().accept(this, data);
-                } finally {
-                    inThrowsForbidden = false;
-                }
-            }
-            return null;
-        }
-
-        public Object visit(TypePatternList node, Object data) {
-            if (node.getTypePatterns().length == 0) return null;
-
-            TypePattern[] typePatterns = node.getTypePatterns();
-            for (int i = 0; i < typePatterns.length; i++) {
-                TypePattern typePattern = typePatterns[i];
-                if (i > 0) append(", ");
-                if (inThrowsForbidden) append('!');
-                typePattern.accept(this, data);
-            }
-            return null;
-        }
-
-        public Object visit(WildAnnotationTypePattern node, Object data) {
-            append("@(");
-            node.getTypePattern().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(WildTypePattern node, Object data) {
-            if (node.getAnnotationPattern() != AnnotationTypePattern.ANY) {
-                append('(');
-                node.getAnnotationPattern().accept(this, data);
-                append(' ');
-            }
-            NamePattern[] namePatterns = node.getNamePatterns();
-            for (int i=0; i < namePatterns.length; i++) {
-                if (namePatterns[i] == null) {
-                    append('.');//FIXME mh, error prone, can't we have a nullNamePattern ?
-                } else {
-                    if (i > 0) append('.');
-                    namePatterns[i].accept(this, data);
-                }
-            }
-            if (node.isIncludeSubtypes()) append('+');
-            if (node.isVarArgs()) append("...");
-            if (node.getAnnotationPattern() != AnnotationTypePattern.ANY) {
-                append(')');
-            }
-            return null;
-        }
-
-        public Object visit(WithinAnnotationPointcut node, Object data) {
-            append("@within(");
-            node.getAnnotationTypePattern().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(WithinCodeAnnotationPointcut node, Object data) {
-            append("@withincode(");
-            node.getAnnotationTypePattern().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(WithinPointcut node, Object data) {
-            append("within(");
-            node.getTypePattern().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(WithincodePointcut node, Object data) {
-            append("withincode(");
-            node.getSignature().accept(this, data);
-            append(')');
-            return null;
-        }
-
-        public Object visit(Pointcut.MatchesNothingPointcut node, Object data) {
-            append("");//TODO shouldn't that be a "false" ?
-            return null;
-        }
-
-
-        //-------------- perX
-
-        public Object visit(PerCflow node, Object data) {
-            append(node);
-            return null;
-        }
-
-        public Object visit(PerFromSuper node, Object data) {
-            append(node);
-            return null;
-        }
-
-        public Object visit(PerObject node, Object data) {
-            append(node);
-            return null;
-        }
-
-        public Object visit(PerSingleton node, Object data) {
-            append(node);
-            return null;
-        }
-
-        public Object visit(PerTypeWithin node, Object data) {
-            append(node);
-            return null;
-        }
-
-        // ------------- declare X
-
-        public Object visit(DeclareAnnotation node, Object data) {
-            append(node);
-            return null;
-        }
-
-        public Object visit(DeclareErrorOrWarning node, Object data) {
-            append(node);
-            return null;
-        }
-
-        public Object visit(DeclareParents node, Object data) {
-            append(node);
-            return null;
-        }
-
-        public Object visit(DeclarePrecedence node, Object data) {
-            append(node);
-            return null;
-        }
-
-        public Object visit(DeclareSoft node, Object data) {
-            append(node);
-            return null;
-        }
-
-        // ----------- misc
-
-        public Object visit(ConcreteCflowPointcut node, Object data) {
-            append(node);
-            return null;
-        }
-
-        public Object visit(HandlerPointcut node, Object data) {
-            append(node);
-            return null;
-        }
-
-        public Object visit(IfPointcut node, Object data) {
-            append(node);
-            return null;
-        }
-		
-		public Object visit(TypeVariablePattern node, Object data) {
-			append(node);
-			return null;
-		}
-		
-		public Object visit(TypeVariablePatternList node, Object data) {
-			append(node);
-			return null;
-		}
-
-		public Object visit(HasMemberTypePattern node, Object data) {
-			append(node);
-			return null;
-		}
-
-        public static void check(String s) {
-            check(Pointcut.fromString(s), false);
-        }
-
-        public static void check(PatternNode pc, boolean isTypePattern) {
-            DumpPointcutVisitor v1 = new DumpPointcutVisitor();
-            pc.accept(v1, null);
-
-            DumpPointcutVisitor v2 = new DumpPointcutVisitor();
-            final PatternNode pc2;
-            if (isTypePattern) {
-                pc2 = new PatternParser(v1.get()).parseTypePattern();
-            } else {
-                pc2 = Pointcut.fromString(v1.get());
-            }
-            pc2.accept(v2, null);
-
-            // at second parsing, the String form stay stable when parsed and parsed again
-            if (! v1.get().equals(v2.get())) {
-                throw new ParserException("Unstable back parsing for '"+pc+"', got '" + v1.get() + "' and '" + v2.get() + "'", null);
-            }
-        }
-
-        public static void main(String args[]) throws Throwable {
-            String[] s = new String[]{
-                //"@args(Foo, Goo, *, .., Moo)",
-                //"execution(* *())",
-                //"call(* *(int, Integer...))",
-                //"staticinitialization(@(Foo) @(Boo) @(Goo) Moo)",
-                   "(if(true) && set(int BaseApp.i))"
-
-            };
-            for (int i = 0; i < s.length; i++) {
-                check(s[i]);
-            }
-        }
-
-    }
-
 }
@@ -0,0 +1,525 @@
+/* *******************************************************************
+ * Copyright (c) 2007-2008 Contributors
+ * All rights reserved.
+ * This program and the accompanying materials are made available
+ * under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Alexandre Vasseur    
+ * ******************************************************************/
+package org.aspectj.weaver.patterns;
+
+import org.aspectj.weaver.Member;
+
+/**
+ * A sample toString like visitor that helps understanding the AST tree structure organization
+ *
+ * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
+ */
+public class DumpPointcutVisitor implements PatternNodeVisitor {
+
+    private StringBuffer sb = new StringBuffer();
+    public String get() {
+        return sb.toString();
+    }
+
+    private void append(Object o) {
+        sb.append(o.toString());
+    }
+	
+	private void append(char c) {
+		sb.append(c);
+	}
+
+    /**
+     * This method helps maintaining the API and raises warning when PatternNode subclasses do not
+     * implement the visitor pattern
+     *
+     * @param node
+     * @param data
+     * @return
+     */
+    public Object visit(PatternNode node, Object data) {
+        System.err.println("Should implement: "  + node.getClass());
+        return null;
+    }
+
+    public Object visit(AnyTypePattern node, Object data) {
+        append('*');
+        return null;
+    }
+
+    public Object visit(NoTypePattern node, Object data) {
+        append(node.toString());//TODO no idea when this one is used
+        return null;
+    }
+
+    public Object visit(EllipsisTypePattern node, Object data) {
+        append(node.toString());
+        return null;
+    }
+
+    public Object visit(AnyWithAnnotationTypePattern node, Object data) {
+        node.annotationPattern.accept(this, data);
+        append(" *");
+        return null;
+    }
+
+    public Object visit(AnyAnnotationTypePattern node, Object data) {
+        //@ANY : ignore
+        append('*');
+        return null;
+    }
+
+    public Object visit(EllipsisAnnotationTypePattern node, Object data) {
+        append("..");
+        return null;
+    }
+
+    public Object visit(AndAnnotationTypePattern node, Object data) {
+        node.getLeft().accept(this, data);
+        append(' ');
+        node.getRight().accept(this, data);
+        return null;
+    }
+
+    public Object visit(AndPointcut node, Object data) {
+        append('(');
+        node.getLeft().accept(this, data);
+        append(" && ");
+        node.getRight().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(AndTypePattern node, Object data) {
+        append('(');
+        node.getLeft().accept(this, data);
+        append(" && ");
+        node.getRight().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(AnnotationPatternList node, Object data) {
+        AnnotationTypePattern[] annotations = node.getAnnotationPatterns();
+        for (int i = 0; i < annotations.length; i++) {
+            if (i>0) append(", ");//Note: list is ",", and is " " separated for annotations
+            annotations[i].accept(this, data);
+        }
+        return null;
+    }
+
+    public Object visit(AnnotationPointcut node, Object data) {
+        append("@annotation(");
+        node.getAnnotationTypePattern().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(ArgsAnnotationPointcut node, Object data) {
+        append("@args(");
+        node.getArguments().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(ArgsPointcut node, Object data) {
+        append("args(");
+        node.getArguments().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(BindingAnnotationTypePattern node, Object data) {
+        append(node);
+        return null;
+    }
+
+    public Object visit(BindingTypePattern node, Object data) {
+        append(node);
+        return null;
+    }
+
+    public Object visit(CflowPointcut node, Object data) {
+        append(node.isCflowBelow()?"cflowbelow(":"cflow(");
+        node.getEntry().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(ExactAnnotationTypePattern node, Object data) {
+        //append('@'); // since @annotation(@someAnno) cannot be parsed anymore
+        append(node.getAnnotationType().getName());
+        return null;
+    }
+
+    public Object visit(ExactTypePattern node, Object data) {
+        if (node.getAnnotationPattern() != AnnotationTypePattern.ANY) {
+            append('(');
+            node.getAnnotationPattern().accept(this, data);
+            append(' ');
+        }
+
+        String typeString = node.getType().toString();
+        if (node.isVarArgs()) typeString = typeString.substring(0, typeString.lastIndexOf('['));//TODO AV - ugly
+        append(typeString);
+        if (node.isIncludeSubtypes()) append('+');
+        if (node.isVarArgs()) append("...");
+        if (node.getAnnotationPattern() != AnnotationTypePattern.ANY) {
+            append(')');
+        }
+        return null;
+    }
+
+    public Object visit(KindedPointcut node, Object data) {
+        append(node.getKind().getSimpleName());
+        append('(');
+        node.getSignature().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(ModifiersPattern node, Object data) {
+        append(node.toString());//note: node takes care of forbidden mods
+        return null;
+    }
+
+    public Object visit(NamePattern node, Object data) {
+        append(node.toString());
+        return null;
+    }
+
+    public Object visit(NotAnnotationTypePattern node, Object data) {
+        append("!");
+        node.getNegatedPattern().accept(this, data);
+        return null;
+    }
+
+    public Object visit(NotPointcut node, Object data) {
+        append("!(");
+        node.getNegatedPointcut().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(NotTypePattern node, Object data) {
+        append("!(");
+        node.getNegatedPattern().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(OrAnnotationTypePattern node, Object data) {
+        append('(');
+        node.getLeft().accept(this, data);
+        append(" || ");
+        node.getRight().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(OrPointcut node, Object data) {
+        append('(');
+        node.getLeft().accept(this, data);
+        append(" || ");
+        node.getRight().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(OrTypePattern node, Object data) {
+        append('(');
+        node.getLeft().accept(this, data);
+        append(" || ");
+        node.getRight().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(ReferencePointcut node, Object data) {
+        append(node.toString());
+        return null;
+    }
+
+    public Object visit(SignaturePattern node, Object data) {
+        if (node.getAnnotationPattern() != AnnotationTypePattern.ANY) {
+            node.getAnnotationPattern().accept(this, data);
+            append(' ');
+        }
+
+        if (node.getModifiers() != ModifiersPattern.ANY) {
+            node.getModifiers().accept(this, data);
+            append(' ');
+        }
+
+        if (node.getKind() == Member.STATIC_INITIALIZATION) {
+            node.getDeclaringType().accept(this, data);
+        } else if (node.getKind() == Member.HANDLER) {
+            append("handler(");
+            node.getParameterTypes().get(0).accept(this, data);//Note: we know we have 1 child
+            append(')');
+        } else {
+            if (!(node.getKind() == Member.CONSTRUCTOR)) {
+                node.getReturnType().accept(this, data);
+                append(' ');
+            }
+            if (node.getDeclaringType() != TypePattern.ANY) {
+                node.getDeclaringType().accept(this, data);
+                append('.');
+            }
+            if (node.getKind() == Member.CONSTRUCTOR) {
+                append("new");
+            } else {
+                node.getName().accept(this, data);
+            }
+            if (node.getKind() == Member.METHOD || node.getKind() == Member.CONSTRUCTOR) {
+                append('(');
+                node.getParameterTypes().accept(this, data);
+                append(')');
+            }
+            if (node.getThrowsPattern() != null) {
+                append(' ');
+                node.getThrowsPattern().accept(this, data);
+            }
+        }
+        return null;
+    }
+
+    public Object visit(ThisOrTargetAnnotationPointcut node, Object data) {
+        append(node.isThis() ? "@this(" : "@target(");
+        node.getAnnotationTypePattern().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(ThisOrTargetPointcut node, Object data) {
+        append(node.isThis() ? "this(" : "target(");
+        node.getType().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    // Note: a visitor instance is not thread safe so should not be shared
+    private boolean inThrowsForbidden = false;
+
+    public Object visit(ThrowsPattern node, Object data) {
+        if (node == ThrowsPattern.ANY) return null;
+
+        append("throws ");
+        node.getRequired().accept(this, data);
+        if (node.getForbidden().size() > 0) {
+            // a hack since throws !(A, B) cannot be parsed
+            try {
+                inThrowsForbidden = true;
+                node.getForbidden().accept(this, data);
+            } finally {
+                inThrowsForbidden = false;
+            }
+        }
+        return null;
+    }
+
+    public Object visit(TypePatternList node, Object data) {
+        if (node.getTypePatterns().length == 0) return null;
+
+        TypePattern[] typePatterns = node.getTypePatterns();
+        for (int i = 0; i < typePatterns.length; i++) {
+            TypePattern typePattern = typePatterns[i];
+            if (i > 0) append(", ");
+            if (inThrowsForbidden) append('!');
+            typePattern.accept(this, data);
+        }
+        return null;
+    }
+
+    public Object visit(WildAnnotationTypePattern node, Object data) {
+        append("@(");
+        node.getTypePattern().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(WildTypePattern node, Object data) {
+        if (node.getAnnotationPattern() != AnnotationTypePattern.ANY) {
+            append('(');
+            node.getAnnotationPattern().accept(this, data);
+            append(' ');
+        }
+        NamePattern[] namePatterns = node.getNamePatterns();
+        for (int i=0; i < namePatterns.length; i++) {
+            if (namePatterns[i] == null) {
+                append('.');//FIXME mh, error prone, can't we have a nullNamePattern ?
+            } else {
+                if (i > 0) append('.');
+                namePatterns[i].accept(this, data);
+            }
+        }
+        if (node.isIncludeSubtypes()) append('+');
+        if (node.isVarArgs()) append("...");
+        if (node.getAnnotationPattern() != AnnotationTypePattern.ANY) {
+            append(')');
+        }
+        return null;
+    }
+
+    public Object visit(WithinAnnotationPointcut node, Object data) {
+        append("@within(");
+        node.getAnnotationTypePattern().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(WithinCodeAnnotationPointcut node, Object data) {
+        append("@withincode(");
+        node.getAnnotationTypePattern().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(WithinPointcut node, Object data) {
+        append("within(");
+        node.getTypePattern().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(WithincodePointcut node, Object data) {
+        append("withincode(");
+        node.getSignature().accept(this, data);
+        append(')');
+        return null;
+    }
+
+    public Object visit(Pointcut.MatchesNothingPointcut node, Object data) {
+        append("");//TODO shouldn't that be a "false" ?
+        return null;
+    }
+
+
+    //-------------- perX
+
+    public Object visit(PerCflow node, Object data) {
+        append(node);
+        return null;
+    }
+
+    public Object visit(PerFromSuper node, Object data) {
+        append(node);
+        return null;
+    }
+
+    public Object visit(PerObject node, Object data) {
+        append(node);
+        return null;
+    }
+
+    public Object visit(PerSingleton node, Object data) {
+        append(node);
+        return null;
+    }
+
+    public Object visit(PerTypeWithin node, Object data) {
+        append(node);
+        return null;
+    }
+
+    // ------------- declare X
+
+    public Object visit(DeclareAnnotation node, Object data) {
+        append(node);
+        return null;
+    }
+
+    public Object visit(DeclareErrorOrWarning node, Object data) {
+        append(node);
+        return null;
+    }
+
+    public Object visit(DeclareParents node, Object data) {
+        append(node);
+        return null;
+    }
+
+    public Object visit(DeclarePrecedence node, Object data) {
+        append(node);
+        return null;
+    }
+
+    public Object visit(DeclareSoft node, Object data) {
+        append(node);
+        return null;
+    }
+
+    // ----------- misc
+
+    public Object visit(ConcreteCflowPointcut node, Object data) {
+        append(node);
+        return null;
+    }
+
+    public Object visit(HandlerPointcut node, Object data) {
+        append(node);
+        return null;
+    }
+
+    public Object visit(IfPointcut node, Object data) {
+        append(node);
+        return null;
+    }
+	
+	public Object visit(TypeVariablePattern node, Object data) {
+		append(node);
+		return null;
+	}
+	
+	public Object visit(TypeVariablePatternList node, Object data) {
+		append(node);
+		return null;
+	}
+
+	public Object visit(HasMemberTypePattern node, Object data) {
+		append(node);
+		return null;
+	}
+
+    public static void check(String s) {
+        check(Pointcut.fromString(s), false);
+    }
+
+    public static void check(PatternNode pc, boolean isTypePattern) {
+        DumpPointcutVisitor v1 = new DumpPointcutVisitor();
+        pc.accept(v1, null);
+
+        DumpPointcutVisitor v2 = new DumpPointcutVisitor();
+        final PatternNode pc2;
+        if (isTypePattern) {
+            pc2 = new PatternParser(v1.get()).parseTypePattern();
+        } else {
+            pc2 = Pointcut.fromString(v1.get());
+        }
+        pc2.accept(v2, null);
+
+        // at second parsing, the String form stay stable when parsed and parsed again
+        if (! v1.get().equals(v2.get())) {
+            throw new ParserException("Unstable back parsing for '"+pc+"', got '" + v1.get() + "' and '" + v2.get() + "'", null);
+        }
+    }
+
+    public static void main(String args[]) throws Throwable {
+        String[] s = new String[]{
+            //"@args(Foo, Goo, *, .., Moo)",
+            //"execution(* *())",
+            //"call(* *(int, Integer...))",
+            //"staticinitialization(@(Foo) @(Boo) @(Goo) Moo)",
+               "(if(true) && set(int BaseApp.i))"
+
+        };
+        for (int i = 0; i < s.length; i++) {
+            check(s[i]);
+        }
+    }
+
+}
\ No newline at end of file
@@ -0,0 +1,162 @@
+/* *******************************************************************
+ * Copyright (c) 2008 Contributors
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *     Andy Clement     initial implementation 
+ * ******************************************************************/
+package org.aspectj.weaver;
+
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.aspectj.weaver.bcel.BcelAdvice;
+import org.aspectj.weaver.patterns.FormalBinding;
+import org.aspectj.weaver.patterns.Pointcut;
+import org.aspectj.weaver.patterns.SimpleScope;
+
+
+public class TestUtils {
+    private static final String[] ZERO_STRINGS = new String[0];
+
+    /**
+     * Build a member from a string representation:
+     * <blockquote><pre>
+     * static? TypeName TypeName.Id
+     * </pre></blockquote>
+     */
+    public static MemberImpl fieldFromString(String str) {
+        str = str.trim();
+        final int len = str.length();
+        int i = 0;
+        int mods = 0;
+        if (str.startsWith("static", i)) {
+            mods = Modifier.STATIC;
+            i += 6;
+            while (Character.isWhitespace(str.charAt(i))) i++;
+        }
+        int start = i;
+        while (! Character.isWhitespace(str.charAt(i))) i++;
+        UnresolvedType retTy = UnresolvedType.forName(str.substring(start, i));
+
+        start = i;
+        i = str.lastIndexOf('.');
+        UnresolvedType declaringTy = UnresolvedType.forName(str.substring(start, i).trim());
+        start = ++i;
+        String name = str.substring(start, len).trim();
+        return new MemberImpl(
+            Member.FIELD,
+            declaringTy,
+            mods,
+            retTy,
+            name,
+            UnresolvedType.NONE);
+    }
+
+    /**
+     * Build a member from a string representation:
+     * <blockquote><pre>
+     * (static|interface|private)? TypeName TypeName . Id ( TypeName , ...)
+     * </pre></blockquote>
+     */
+    
+    public static Member methodFromString(String str) {
+        str = str.trim();
+        // final int len = str.length();
+        int i = 0;
+
+        int mods = 0;
+        if (str.startsWith("static", i)) {
+            mods = Modifier.STATIC;
+            i += 6;
+        } else if (str.startsWith("interface", i)) {
+            mods = Modifier.INTERFACE;
+            i += 9;
+        } else if (str.startsWith("private", i)) {
+            mods = Modifier.PRIVATE;
+            i += 7;
+        }            
+        while (Character.isWhitespace(str.charAt(i))) i++;
+        
+        int start = i;
+        while (! Character.isWhitespace(str.charAt(i))) i++;
+        UnresolvedType returnTy = UnresolvedType.forName(str.substring(start, i));
+
+        start = i;
+        i = str.indexOf('(', i);
+        i = str.lastIndexOf('.', i);
+        UnresolvedType declaringTy = UnresolvedType.forName(str.substring(start, i).trim());
+        
+        start = ++i;
+        i = str.indexOf('(', i);
+        String name = str.substring(start, i).trim();
+        start = ++i;
+        i = str.indexOf(')', i);
+    
+        String[] paramTypeNames = parseIds(str.substring(start, i).trim());
+
+        return MemberImpl.method(declaringTy, mods, returnTy, name, UnresolvedType.forNames(paramTypeNames));
+    }
+
+    private static String[] parseIds(String str) {
+        if (str.length() == 0) return ZERO_STRINGS;
+        List l = new ArrayList();
+        int start = 0;
+        while (true) {
+            int i = str.indexOf(',', start);
+            if (i == -1) {
+                l.add(str.substring(start).trim());
+                break;
+            }
+            l.add(str.substring(start, i).trim());
+            start = i+1;
+        }
+        return (String[]) l.toArray(new String[l.size()]);
+    }
+
+    /**
+     * Moved from BcelWorld to here
+     * 
+     * Parse a string into advice.
+     * 
+     * <blockquote><pre>
+     * Kind ( Id , ... ) : Pointcut -> MethodSignature
+     * </pre></blockquote>
+     */
+    public static Advice shadowMunger(World w,String str, int extraFlag) {
+        str = str.trim();
+        int start = 0;
+        int i = str.indexOf('(');
+        AdviceKind kind = 
+            AdviceKind.stringToKind(str.substring(start, i));
+        start = ++i;
+        i = str.indexOf(')', i);
+        String[] ids = parseIds(str.substring(start, i).trim());
+        //start = ++i;
+        
+        
+        
+        i = str.indexOf(':', i);        
+        start = ++i;        
+        i = str.indexOf("->", i);
+        Pointcut pointcut = Pointcut.fromString(str.substring(start, i).trim());
+        Member m = TestUtils.methodFromString(str.substring(i+2, str.length()).trim());
+
+        // now, we resolve
+        UnresolvedType[] types = m.getParameterTypes();
+        FormalBinding[] bindings = new FormalBinding[ids.length];
+        for (int j = 0, len = ids.length; j < len; j++) {
+            bindings[j] = new FormalBinding(types[j], ids[j], j, 0, 0, "fromString");
+        }
+
+        Pointcut p =
+        	pointcut.resolve(new SimpleScope(w, bindings));
+
+        return new BcelAdvice(kind, p, m, extraFlag, 0, 0, null, null);
+    }
+}
@@ -0,0 +1,101 @@
+/* *******************************************************************
+ * Copyright (c) 1999-2001 Xerox Corporation, 
+ *               2002 Palo Alto Research Center, Incorporated (PARC).
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *     Xerox/PARC     initial implementation 
+ * ******************************************************************/
+
+ 
+package org.aspectj.ajdt;
+
+import java.io.*;
+
+/**
+ * Used for writing converting text written to an output stream into
+ * a string.  Deprecated - use StringWriter:
+ * <pre>
+ * StringWriter sw = new StringWriter();
+ * PrintWriter pw = new PrintWriter(sw, true);
+ * ... write to pw
+ * String result = sw.getBuffer().toString();
+ * </pre>
+ * @deprecated use StringWriter to construct PrintWriter
+ * @author Mik Kersten
+ */
+public class StreamPrintWriter extends PrintWriter {
+    private String contents = "";
+
+    public StreamPrintWriter(Writer out) {
+        super(out);
+    }
+
+    public String getContents() {
+        return contents;
+    }
+
+    public void flushBuffer() {
+        contents = "";
+        super.flush();
+    }
+
+    public void print(char x) {
+        contents += x + "\n";
+    }
+
+    public void print(char[] x) {
+        contents += new String( x );
+    }
+
+    public void print(int x) {
+        contents += x;
+    }
+
+    public void print(String x) {
+        contents += x;
+    }
+
+    public void println(char x) {
+        contents += x + "\n";
+    }
+
+    public void println(char[] x) {
+        contents += new String( x ) + "\n";
+    }
+
+    public void println(int x) {
+        contents += x + "\n";
+    }
+
+    public void println(String x) {
+        contents += x + "\n";
+    }
+
+    public void write( byte[] x ) {
+        contents += new String( x );
+    }
+
+    public void write( byte[] x, int i1, int i2 ) {
+        StringWriter writer = new StringWriter();
+        String s = new String( x );
+        writer.write( s.toCharArray(), i1, i2 );
+        contents += writer.getBuffer().toString();
+    }
+
+    public void write( int c ) {
+        contents += c;
+    }
+
+    public void write( String s ) {
+        contents += s;
+    }
+
+    public void write( String s, int i1, int i2 ) {
+        contents += s;
+    }
+}
@@ -14,6 +14,7 @@
 package org.aspectj.ajdt.ajc;
 
 //import org.aspectj.ajdt.internal.core.builder.AjBuildConfig;
+import org.aspectj.ajdt.StreamPrintWriter;
 import org.aspectj.bridge.*;
 import org.aspectj.util.*;
 import org.aspectj.org.eclipse.jdt.core.compiler.InvalidInputException;
@@ -19,14 +19,13 @@ import java.io.PrintWriter;
 
 import junit.framework.TestCase;
 
+import org.aspectj.ajdt.StreamPrintWriter;
 import org.aspectj.ajdt.ajc.*;
 import org.aspectj.asm.AsmManager;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.MessageHandler;
 import org.aspectj.bridge.MessageWriter;
 import org.aspectj.tools.ajc.Ajc;
-import org.aspectj.util.StreamPrintWriter;
-//import org.eclipse.core.runtime.CoreException;
 
 public class AjBuildManagerTest extends TestCase {
 
@@ -1,39 +0,0 @@
-/* *******************************************************************
- * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
- * All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://www.eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: 
- *     Xerox/PARC     initial implementation 
- * ******************************************************************/
-
-
-package org.aspectj.util;
-
-/**
- * Throw this when a non-local exit is required (suggested for tests only).
- */
-public class NonLocalExit extends RuntimeException {
-
-	public static final int SUCCEESS = 0;
-	public static final int FAULURE = 1;
-
-	private int exitCode;
-
-	public NonLocalExit(int exitCode) {
-		this();
-		this.exitCode = exitCode;		
-	}
-
-	public NonLocalExit() {
-		super();
-	}
-
-	public int getExitCode() {
-		return exitCode;
-	}
-
-}
@@ -1,101 +0,0 @@
-/* *******************************************************************
- * Copyright (c) 1999-2001 Xerox Corporation, 
- *               2002 Palo Alto Research Center, Incorporated (PARC).
- * All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://www.eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: 
- *     Xerox/PARC     initial implementation 
- * ******************************************************************/
-
- 
-package org.aspectj.util;
-
-import java.io.*;
-
-/**
- * Used for writing converting text written to an output stream into
- * a string.  Deprecated - use StringWriter:
- * <pre>
- * StringWriter sw = new StringWriter();
- * PrintWriter pw = new PrintWriter(sw, true);
- * ... write to pw
- * String result = sw.getBuffer().toString();
- * </pre>
- * @deprecated use StringWriter to construct PrintWriter
- * @author Mik Kersten
- */
-public class StreamPrintWriter extends PrintWriter {
-    private String contents = "";
-
-    public StreamPrintWriter(Writer out) {
-        super(out);
-    }
-
-    public String getContents() {
-        return contents;
-    }
-
-    public void flushBuffer() {
-        contents = "";
-        super.flush();
-    }
-
-    public void print(char x) {
-        contents += x + "\n";
-    }
-
-    public void print(char[] x) {
-        contents += new String( x );
-    }
-
-    public void print(int x) {
-        contents += x;
-    }
-
-    public void print(String x) {
-        contents += x;
-    }
-
-    public void println(char x) {
-        contents += x + "\n";
-    }
-
-    public void println(char[] x) {
-        contents += new String( x ) + "\n";
-    }
-
-    public void println(int x) {
-        contents += x + "\n";
-    }
-
-    public void println(String x) {
-        contents += x + "\n";
-    }
-
-    public void write( byte[] x ) {
-        contents += new String( x );
-    }
-
-    public void write( byte[] x, int i1, int i2 ) {
-        StringWriter writer = new StringWriter();
-        String s = new String( x );
-        writer.write( s.toCharArray(), i1, i2 );
-        contents += writer.getBuffer().toString();
-    }
-
-    public void write( int c ) {
-        contents += c;
-    }
-
-    public void write( String s ) {
-        contents += s;
-    }
-
-    public void write( String s, int i1, int i2 ) {
-        contents += s;
-    }
-}
@@ -40,7 +40,7 @@ public class InterimCompilationResult {
 		for (int i=0; i < ucfList.size(); i++) {
 			UnwovenClassFile element = (UnwovenClassFile) ucfList.get(i);
 			unwovenClassFiles[i] = element;
-			AjClassFile ajcf = new AjClassFile(element.getClassName().replace('.', '/').toCharArray(),
+			AjClassFile ajcf = new AjClassFile(element.getClassNameAsChars(),
 											   element.getBytes());
 			result.record(ajcf.fileName(),ajcf); 
 		}	  	
@@ -13,6 +13,8 @@ package org.aspectj.ajdt.internal.compiler;
 import java.util.Iterator;
 import java.util.Map;
 
+import org.aspectj.asm.internal.CharOperation;
+import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.IProgressListener;
 import org.aspectj.bridge.MessageUtil;
 import org.aspectj.org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
@@ -170,6 +172,7 @@ public class WeaverAdapter implements IClassFileProvider, IWeaveRequestor, Itera
 		if ((lastReturnedResult != null) && (!lastReturnedResult.result().hasBeenAccepted)) {
 			finishedWith(lastReturnedResult);
 		}
+		lastReturnedResult=null;
 	}
 
 
@@ -178,30 +181,29 @@ public class WeaverAdapter implements IClassFileProvider, IWeaveRequestor, Itera
 	 * @see org.aspectj.weaver.IWeaveRequestor#acceptResult(org.aspectj.weaver.bcel.UnwovenClassFile)
 	 */
 	public void acceptResult(UnwovenClassFile result) {
-		char[] key = result.getClassName().replace('.','/').toCharArray();
-		removeFromMap(lastReturnedResult.result().compiledTypes,key);
-		String className = result.getClassName().replace('.', '/');
-		AjClassFile ajcf = new AjClassFile(className.toCharArray(),
-										   result.getBytes());
+		char[] key = result.getClassNameAsChars();
+		removeFromMap(lastReturnedResult.result().compiledTypes, key);
+		AjClassFile ajcf = new AjClassFile(key, result.getBytes());
 		lastReturnedResult.result().record(ajcf.fileName(),ajcf);
-		//System.err.println(progressPhasePrefix+result.getClassName()+" (from "+nowProcessing.fileName()+")");
-        StringBuffer msg = new StringBuffer();
-        msg.append(progressPhasePrefix).append(result.getClassName()).append(" (from ").append(nowProcessing.fileName()).append(")");
-        weaverMessageHandler.handleMessage(MessageUtil.info(msg.toString()));
-		if (progressListener != null) {
-			progressCompletionCount++;
-			
-			// Smoothly take progress from 'fromPercent' to 'toPercent'
-			recordProgress(
-			  fromPercent
-			  +((progressCompletionCount/(double)progressMaxTypes)*(toPercent-fromPercent)),
-			  msg.toString());
-            // progressPhasePrefix+result.getClassName()+" (from "+nowProcessing.fileName()+")");
-
-			if (progressListener.isCancelledRequested()) {
-		      throw new AbortCompilation(true,new OperationCanceledException("Weaving cancelled as requested"));
+        if (!weaverMessageHandler.isIgnoring(IMessage.INFO) || progressListener!=null) {
+        	StringBuffer msg = new StringBuffer();
+        	msg.append(progressPhasePrefix).append(result.getClassName()).append(" (from ").append(nowProcessing.fileName()).append(")");
+	        weaverMessageHandler.handleMessage(MessageUtil.info(msg.toString()));
+			if (progressListener != null) {
+				progressCompletionCount++;
+				
+				// Smoothly take progress from 'fromPercent' to 'toPercent'
+				recordProgress(
+				  fromPercent
+				  +((progressCompletionCount/(double)progressMaxTypes)*(toPercent-fromPercent)),
+				  msg.toString());
+	            // progressPhasePrefix+result.getClassName()+" (from "+nowProcessing.fileName()+")");
+	
+				if (progressListener.isCancelledRequested()) {
+			      throw new AbortCompilation(true,new OperationCanceledException("Weaving cancelled as requested"));
+				}
 			}
-		}
+        }
 	}
 
 	// helpers...
@@ -211,21 +213,28 @@ public class WeaverAdapter implements IClassFileProvider, IWeaveRequestor, Itera
 		compilerAdapter.acceptResult(result.result());
 	}
 
-	private void removeFromMap(Map aMap, char[] key) {
+	private boolean removeFromMap(Map aMap, char[] key) {
 		// jdt uses char[] as a key in the hashtable, which is not very useful as equality is based on being
 		// the same array, not having the same content.
-		String skey = new String(key);
+//		String skey = new String(key);
+		// OPTIMIZE what is this code for?
+		if (aMap.remove(key)!=null) {
+			return true;
+		}
 		char[] victim = null;
 		for (Iterator iter = aMap.keySet().iterator(); iter.hasNext();) {
 			char[] thisKey = (char[]) iter.next();
-			if (skey.equals(new String(thisKey))) {
+			if (CharOperation.equals(thisKey,key)) {
+//			if (skey.equals(new String(thisKey))) {
 				victim = thisKey;
 				break;
 			}
 		}
 		if (victim != null) {
 			aMap.remove(victim);
+			return true;
 		}
+		return false;
 	}
 
 	private void recordProgress(String message) {
@@ -252,9 +252,7 @@ public class AjcMemberMaker {
 
 
 	public static ResolvedMember perSingletonAspectOfMethod(UnresolvedType declaringType) {
-		return new ResolvedMemberImpl(Member.METHOD,
-			declaringType, PUBLIC_STATIC, "aspectOf", 
-			"()" + declaringType.getSignature());		
+		return new ResolvedMemberImpl(Member.METHOD, declaringType, PUBLIC_STATIC, "aspectOf", "()" + declaringType.getSignature());
 	}
 
 	public static ResolvedMember perSingletonHasAspectMethod(UnresolvedType declaringType) {
@@ -1,84 +0,0 @@
-/* *******************************************************************
- * Copyright (c) 2004 IBM Corporation and others.
- * All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://www.eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: 
- *     Andy Clement         initial implementation
- * ******************************************************************/
-package org.aspectj.weaver;
-
-import org.aspectj.util.FuzzyBoolean;
-
-
-/**
- * Records stats about the weaver.  Information like 'how many types are dismissed during fast match' that
- * may be useful for trying to tune pointcuts.  Not publicised.
- */
-public class WeaverMetrics {
-    
-	// Level 1 of matching is at the type level, which types can be dismissed?
-	public static int fastMatchOnTypeAttempted = 0;
-	public static int fastMatchOnTypeTrue = 0;
-	public static int fastMatchOnTypeFalse = 0;
-
-	// Level 2 of matching is fast matching on the shadows in the remaining types
-	public static int fastMatchOnShadowsAttempted = 0;
-	public static int fastMatchOnShadowsTrue = 0;
-	public static int fastMatchOnShadowsFalse = 0;
-	
-    // Level 3 of matching is slow matching on the shadows (more shadows than were fast matched on!)
-	public static int matchTrue = 0;
-	public static int matchAttempted = 0;
-
-
-	
-	public static void reset() {
-
-		fastMatchOnShadowsAttempted = 0;
-		fastMatchOnShadowsTrue = 0;
-		fastMatchOnShadowsFalse = 0;
-
-		fastMatchOnTypeAttempted = 0;
-		fastMatchOnTypeTrue = 0;
-		fastMatchOnTypeFalse = 0;
-	
-		matchTrue = 0;
-		matchAttempted = 0;
-	}	
-
-	
-	public static void dumpInfo() {
-		System.err.println("Match summary:");
-		int fastMatchOnTypeMaybe = (fastMatchOnTypeAttempted-fastMatchOnTypeTrue-fastMatchOnTypeFalse);
-		System.err.print("At the type level, we attempted #"+fastMatchOnTypeAttempted+" fast matches:");
-		System.err.println("   YES/NO/MAYBE = "+fastMatchOnTypeTrue+"/"+fastMatchOnTypeFalse+"/"+fastMatchOnTypeMaybe);
-		int fastMatchMaybe = (fastMatchOnShadowsAttempted-fastMatchOnShadowsFalse-fastMatchOnShadowsTrue);
-		System.err.print("Within those #"+(fastMatchOnTypeTrue+fastMatchOnTypeMaybe)+" possible types, ");
-		System.err.print("we fast matched on #"+fastMatchOnShadowsAttempted+" shadows:");
-		System.err.println("   YES/NO/MAYBE = "+fastMatchOnShadowsTrue+"/"+fastMatchOnShadowsFalse+"/"+fastMatchMaybe);
-		System.err.println("Shadow (non-fast) matches attempted #"+matchAttempted+" of which "+matchTrue+" successful");
-	}
-	
-
-	public static void recordFastMatchTypeResult(FuzzyBoolean fb) {
-		fastMatchOnTypeAttempted++;
-		if (fb.alwaysTrue()) fastMatchOnTypeTrue++;
-		if (fb.alwaysFalse()) fastMatchOnTypeFalse++;
-	}
-	
-	public static void recordFastMatchResult(FuzzyBoolean fb) {
-		fastMatchOnShadowsAttempted++;
-		if (fb.alwaysTrue())  fastMatchOnShadowsTrue++;
-		if (fb.alwaysFalse()) fastMatchOnShadowsFalse++;
-	}
-	
-	public static void recordMatchResult(boolean b) {
-		matchAttempted++;
-		if (b) matchTrue++;
-	}
-
-}
@@ -95,7 +95,6 @@ import org.aspectj.weaver.Shadow;
 import org.aspectj.weaver.ShadowMunger;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.WeaverMessages;
-import org.aspectj.weaver.WeaverMetrics;
 import org.aspectj.weaver.WeaverStateInfo;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.patterns.DeclareAnnotation;
@@ -2814,15 +2813,12 @@ class BcelClassWeaver implements IClassWeaver {
 	            ShadowMunger munger = (ShadowMunger)i.next();
 	            ContextToken mungerMatchToken = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.MATCHING_POINTCUT, munger.getPointcut());
 	            if (munger.match(shadow, world)) {
-					WeaverMetrics.recordMatchResult(true);// Could pass: munger
 	                shadow.addMunger(munger);
 	                isMatched = true;
 				    if (shadow.getKind() == Shadow.StaticInitialization) {
 					  clazz.warnOnAddedStaticInitializer(shadow,munger.getSourceLocation());
 				    }
-	            } else {
-	            	WeaverMetrics.recordMatchResult(false); // Could pass: munger
-	        	}
+	            }
 	            CompilationAndWeavingContext.leavingPhase(mungerMatchToken);
 	        }       
 
@@ -77,7 +77,6 @@ import org.aspectj.weaver.Shadow;
 import org.aspectj.weaver.ShadowMunger;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.WeaverMessages;
-import org.aspectj.weaver.WeaverMetrics;
 import org.aspectj.weaver.WeaverStateInfo;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.patterns.AndPointcut;
@@ -114,7 +113,6 @@ public class BcelWeaver implements IWeaver {
     public BcelWeaver(BcelWorld world) {
         super();
         if (trace.isTraceEnabled()) trace.enter("<init>",this,world);
-        WeaverMetrics.reset();
         this.world = world;
         this.xcutSet = world.getCrosscuttingMembersSet();
         if (trace.isTraceEnabled()) trace.exit("<init>");
@@ -1386,6 +1384,11 @@ public class BcelWeaver implements IWeaver {
 		//clazz is null if the classfile was unchanged by weaving...
 		if (clazz != null) {
 			UnwovenClassFile[] newClasses = getClassFilesFor(clazz);
+			// OPTIMIZE can we avoid using the string name at all in UnwovenClassFile instances?
+			// Copy the char[] across as it means the WeaverAdapter.removeFromMap() can be fast!
+			if (newClasses[0].getClassName().equals(classFile.getClassName())) {
+				newClasses[0].setClassNameAsChars(classFile.getClassNameAsChars());
+			}
 			for (int i = 0; i < newClasses.length; i++) {
 				requestor.acceptResult(newClasses[i]);
 			}
@@ -1759,7 +1762,6 @@ public class BcelWeaver implements IWeaver {
 		while (iter.hasNext()) {
 			ShadowMunger munger = (ShadowMunger)iter.next();
 			FuzzyBoolean fb = munger.getPointcut().fastMatch(info);
-			WeaverMetrics.recordFastMatchTypeResult(fb); // Could pass: munger.getPointcut().toString(),info
 			if (fb.maybeTrue()) {
 				result.add(munger);
 			}
@@ -27,6 +27,7 @@ import org.aspectj.util.FileUtil;
 
 public class UnwovenClassFile {
 	protected String filename;
+	protected char[] charfilename;
 	protected byte[] bytes;
 //	protected JavaClass javaClass = null;
 	//protected byte[] writtenBytes = null;
@@ -149,9 +150,15 @@ public class UnwovenClassFile {
 		return true;
 	}
 
+	public char[] getClassNameAsChars() {
+		if (charfilename==null) {
+			charfilename = getClassName().replace('.', '/').toCharArray();
+		}
+		return charfilename;
+	}
 
 	public String getClassName() {
-		if (className == null) className = getJavaClass().getClassName();
+		if (className == null) className = getJavaClass().getClassName(); // OPTIMIZE quicker way to determine name??? surely?
 		return className;
 	}
 
@@ -184,6 +191,7 @@ public class UnwovenClassFile {
 	}
 
 	// record
+	// OPTIMIZE why is the 'short name' used here (the bit after the dollar) - seems we mess about a lot trimming it off only to put it back on!
 	public static class ChildClass {
 		public final String name;
 		public final byte[] bytes;
@@ -206,6 +214,10 @@ public class UnwovenClassFile {
 			return "(ChildClass " + name + ")";
 		}
 	}
+
+	public void setClassNameAsChars(char[] classNameAsChars) {
+		this.charfilename = classNameAsChars;
+	}
 }
 
 
@@ -1,22 +0,0 @@
-/* *******************************************************************
- * Copyright (c) 2005 Contributors.
- * All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: 
- *   Adrian Colyer			Initial implementation
- * ******************************************************************/
-package org.aspectj.weaver.ltw;
-
-import org.aspectj.weaver.IWeaver;
-
-/**
- * @author adrian
- *
- */
-public class LTWeaver implements IWeaver {
-
-}
@@ -12,7 +12,8 @@
 
 package org.aspectj.weaver.tools;
 
-/** This class implements a boolean that includes a "maybe"
+/** 
+ * This class implements a boolean that includes a "maybe"
  */
 public class FuzzyBoolean {
 
@@ -1,6 +0,0 @@
-<html>
-<body>
-Provides a set of interfaces for third-parties wishing to integrate
-AspectJ weaving capabilities into their environments.
-</body>
-</html>
@@ -23,6 +23,7 @@ import org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration;
 import org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor;
 import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.ajdt.internal.core.builder.AjState;
+import org.aspectj.asm.internal.CharOperation;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.IMessageHandler;
 import org.aspectj.bridge.IProgressListener;
@@ -36,7 +37,6 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.aspectj.org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
-import org.aspectj.util.CharOperation;
 import org.aspectj.weaver.bcel.BcelWeaver;
 import org.aspectj.weaver.bcel.BcelWorld;
 import org.aspectj.weaver.patterns.CflowPointcut;
@@ -443,7 +443,7 @@ public class AjPipeliningCompilerAdapter extends AbstractCompilerAdapter {
 
 	/** Return true if we've decided to drop back to a full build (too much has changed) */
 	private boolean weaveQueuedEntries() throws IOException {
-		if (debugPipeline)System.err.println(">.weaveQueuedEntries()");
+		if (debugPipeline) System.err.println(">.weaveQueuedEntries()");
 		for (Iterator iter = resultsPendingWeave.iterator(); iter.hasNext();) {
 			InterimCompilationResult iresult = (InterimCompilationResult) iter.next();
 			for (int i = 0; i < iresult.unwovenClassFiles().length; i++) {
@@ -999,27 +999,6 @@ public class AjState {
 	}
 
 	/**
-	 * Currently unused, if we ditch classesFromName, we might need this.... (in noteResult)
-	 * @param file
-	 * @return
-	 */
-	private UnwovenClassFile maybeGetExistingClassFileFor(UnwovenClassFile classFile) {
-		File existing = new File(classFile.getFilename());
-		if (!existing.exists()) {
-			return null;
-		} 
-		else {
-			try {
-				return new UnwovenClassFile(classFile.getFilename(),FileUtil.readAsByteArray(existing));
-			} 
-			catch (IOException ex) {
-				throw new IllegalStateException("Unable to read contents of '" + classFile.getFilename() + "' " +
-						"from last compile cycle");
-			}
-		}
-	}
-
-	/**
 	 * @param sourceFile
 	 * @param unwovenClassFiles
 	 */
@@ -35,6 +35,7 @@ import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IHierarchy;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.asm.IRelationship;
+import org.aspectj.asm.internal.CharOperation;
 import org.aspectj.asm.internal.ProgramElement;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.bridge.SourceLocation;
@@ -58,7 +59,6 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ClassScope;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.aspectj.org.eclipse.jdt.internal.compiler.util.Util;
-import org.aspectj.util.CharOperation;
 import org.aspectj.util.LangUtil;
 import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.Member;
@@ -285,12 +285,12 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 	public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope scope) {
 		String name = new String(memberTypeDeclaration.name);
 
-        // OPTIMIZE dont call kind 3 times
 		IProgramElement.Kind kind = IProgramElement.Kind.CLASS;
+		int typeDeclarationKind = TypeDeclaration.kind(memberTypeDeclaration.modifiers);
 		if (memberTypeDeclaration instanceof AspectDeclaration) kind = IProgramElement.Kind.ASPECT;
-		else if (TypeDeclaration.kind(memberTypeDeclaration.modifiers) == TypeDeclaration.INTERFACE_DECL) kind = IProgramElement.Kind.INTERFACE;
-		else if (TypeDeclaration.kind(memberTypeDeclaration.modifiers)  == TypeDeclaration.ENUM_DECL) kind = IProgramElement.Kind.ENUM;
-		else if (TypeDeclaration.kind(memberTypeDeclaration.modifiers)  == TypeDeclaration.ANNOTATION_TYPE_DECL) kind = IProgramElement.Kind.ANNOTATION;
+		else if (typeDeclarationKind == TypeDeclaration.INTERFACE_DECL) kind = IProgramElement.Kind.INTERFACE;
+		else if (typeDeclarationKind == TypeDeclaration.ENUM_DECL) kind = IProgramElement.Kind.ENUM;
+		else if (typeDeclarationKind == TypeDeclaration.ANNOTATION_TYPE_DECL) kind = IProgramElement.Kind.ANNOTATION;
 
         //@AJ support
         if (memberTypeDeclaration.annotations != null) {
@@ -0,0 +1,116 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.asm.internal;
+
+
+/**
+ * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+ *
+ */
+public class CharOperation {
+	
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final char[] subarray(char[] array, int start, int end) {
+		if (end == -1)
+			end = array.length;
+		if (start > end)
+			return null;
+		if (start < 0)
+			return null;
+		if (end > array.length)
+			return null;
+
+		char[] result = new char[end - start];
+		System.arraycopy(array, start, result, 0, end - start);
+		return result;
+	}
+	
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final int lastIndexOf(char toBeFound, char[] array) {
+		for (int i = array.length; --i >= 0;)
+			if (toBeFound == array[i])
+				return i;
+		return -1;
+	}
+	
+//	/**
+//	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+//	 */	
+//	public static final boolean contains(char character, char[] array) {
+//		for (int i = array.length; --i >= 0;)
+//			if (array[i] == character)
+//				return true;
+//		return false;
+//	}
+
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final int indexOf(char toBeFound, char[] array) {
+		for (int i = 0; i < array.length; i++)
+			if (toBeFound == array[i])
+				return i;
+		return -1;
+	}
+	
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final char[] concat(char[] first, char[] second) {
+		if (first == null)
+			return second;
+		if (second == null)
+			return first;
+
+		int length1 = first.length;
+		int length2 = second.length;
+		char[] result = new char[length1 + length2];
+		System.arraycopy(first, 0, result, 0, length1);
+		System.arraycopy(second, 0, result, length1, length2);
+		return result;
+	}
+	
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final boolean equals(char[] first, char[] second) {
+		if (first == second)
+			return true;
+		if (first == null || second == null)
+			return false;
+		if (first.length != second.length)
+			return false;
+
+		for (int i = first.length; --i >= 0;)
+			if (first[i] != second[i])
+				return false;
+		return true;
+	}
+	
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final void replace(
+		char[] array,
+		char toBeReplaced,
+		char replacementChar) {
+		if (toBeReplaced != replacementChar) {
+			for (int i = 0, max = array.length; i < max; i++) {
+				if (array[i] == toBeReplaced)
+					array[i] = replacementChar;
+			}
+		}
+	}
+}
@@ -18,8 +18,6 @@ import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IElementHandleProvider;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.bridge.ISourceLocation;
-import org.aspectj.util.CharOperation;
-import org.aspectj.util.NameConvertor;
 
 /**
  * Creates JDT-like handles, for example
@@ -0,0 +1,214 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.asm.internal;
+
+
+public class NameConvertor {
+
+	private static final char BOOLEAN 	= 'Z';
+	private static final char BYTE 		= 'B';
+	private static final char CHAR 		= 'C';
+	private static final char DOUBLE 	= 'D';
+	private static final char FLOAT 	= 'F';
+	private static final char INT 		= 'I';
+	private static final char LONG		= 'J';
+	private static final char SHORT		= 'S';
+	private static final char ARRAY		= '[';
+	private static final char RESOLVED = 'L';
+	private static final char UNRESOLVED = 'Q';
+	
+	public static final char PARAMETERIZED = 'P';
+	
+	private static final char[] BOOLEAN_NAME = new char[]{'b','o','o','l','e','a','n'};
+	private static final char[] BYTE_NAME = new char[]{'b','y','t','e'};
+	private static final char[] CHAR_NAME = new char[]{'c','h','a','r'};
+	private static final char[] DOUBLE_NAME = new char[]{'d','o','u','b','l','e'};
+	private static final char[] FLOAT_NAME = new char[]{'f','l','o','a','t'};
+	private static final char[] INT_NAME = new char[]{'i','n','t'};
+	private static final char[] LONG_NAME = new char[]{'l','o','n','g'};
+	private static final char[] SHORT_NAME = new char[]{'s','h','o','r','t'};
+
+	private static final char[] SQUARE_BRACKETS = new char[]{'[',']'};
+	private static final char[] GREATER_THAN = new char[]{'>'};
+	private static final char[] LESS_THAN = new char[]{'<'};
+	private static final char[] COMMA = new char[]{','};
+	private static final char[] BACKSLASH_LESSTHAN = new char[]{'\\','<'};
+	private static final char[] SEMICOLON = new char[]{';'};
+	
+	
+	/**
+	 * Creates a readable name from the given char array, for example, 
+	 * given 'I' returns 'int'. Moreover, given 
+	 * 'Ljava/lang/String;<Ljava/lang/String;>' returns
+	 * 'java.lang.String<java.lang.String>'
+	 */
+	public static char[] convertFromSignature(char[] c) {
+		int lt = CharOperation.indexOf('<',c);
+		int sc = CharOperation.indexOf(';',c);
+		int gt = CharOperation.indexOf('>',c);
+		
+		int smallest = 0;
+		if (lt  == -1 && sc == -1 && gt == -1) {
+			// we have something like 'Ljava/lang/String' or 'I'
+			return getFullyQualifiedTypeName(c);
+		} else if (lt != -1 && (sc == -1 || lt <= sc) && (gt == -1 || lt <= gt)) {
+			// we have something like 'Ljava/lang/String<I'
+			smallest = lt;
+		} else if (sc != -1 && (lt == -1 || sc <= lt) && (gt == -1 || sc <= gt)) {
+			// we have something like 'Ljava/lang/String;I'
+			smallest = sc;
+		} else {
+			// we have something like '>;'
+			smallest = gt;
+		}
+		char[] first = CharOperation.subarray(c,0,smallest);
+		char[] second = CharOperation.subarray(c,smallest+1,c.length);
+		if (smallest == 0 && first.length == 0 && c[0] == '>') {
+			// c = {'>',';'} therefore we just want to return '>' to
+			// close the generic signature
+			return GREATER_THAN;
+		} else if (first.length == 1 && second.length == 0) {
+			return first;
+		} else if (second.length == 0 || (second.length == 1 && second[0] == ';')){
+			// we've reached the end of the array, therefore only care about
+			// the first part
+			return convertFromSignature(first);
+		} else if (smallest == lt) {
+			// if c = 'Ljava/lang/String;<I' then first = 'Ljava/Lang/String;' and
+			// second = 'I'. Want to end up with 'Ljava.lang.String<I' and so add
+			// the '<' back.
+			char[] inclLT = CharOperation.concat(convertFromSignature(first),LESS_THAN);
+			return CharOperation.concat(inclLT,convertFromSignature(second));
+		} else if (smallest == gt) {
+			char[] inclLT = CharOperation.concat(convertFromSignature(first),GREATER_THAN);
+			return CharOperation.concat(inclLT,convertFromSignature(second));			
+		} else if (second.length != 2) {
+			// if c = 'Ljava/lang/Sting;LMyClass' then first = 'Ljava/lang/String'
+			// and second = 'LMyClass'. Want to end up with 'java.lang.String,MyClass
+			// so want to add a ','. However, only want to do this if we're in the 
+			// middle of a '<...>'
+			char[] inclComma = CharOperation.concat(convertFromSignature(first),COMMA);
+			return CharOperation.concat(inclComma,convertFromSignature(second));
+		}
+		return CharOperation.concat(convertFromSignature(first),convertFromSignature(second));
+	}
+	
+	
+	/**
+	 * Given a char array, returns the type name for this. For example
+	 * 'I' returns 'int', 'Ljava/lang/String' returns 'java.lang.String' and
+	 * '[Ljava/lang/String' returns 'java.lang.String[]'
+	 * 
+	 * NOTE: Doesn't go any deaper so given 'Ljava/lang/String;<Ljava/lang/String;>' 
+	 * it would return 'java.lang.String;<Ljava.lang.String;>', however, only called
+	 * with something like 'Ljava/lang/String'
+	 */
+	private static char[] getFullyQualifiedTypeName(char[] c) {
+		if (c.length == 0) {
+			return c;
+		} 
+		if (c[0] == BOOLEAN) {
+			return BOOLEAN_NAME;
+		} else if (c[0] == BYTE) {
+			return BYTE_NAME;
+		} else if (c[0] == CHAR) {
+			return CHAR_NAME;
+		} else if (c[0] == DOUBLE) {
+			return DOUBLE_NAME;
+		} else if (c[0] == FLOAT) {
+			return FLOAT_NAME;
+		} else if (c[0] == INT) {
+			return INT_NAME;
+		} else if (c[0] == LONG) {
+			return LONG_NAME;
+		} else if (c[0] == SHORT) {
+			return SHORT_NAME;
+		} else if (c[0] == ARRAY) {
+			return CharOperation.concat(
+					getFullyQualifiedTypeName(CharOperation.subarray(c,1,c.length)),
+					SQUARE_BRACKETS);
+		} else {
+			char[] type = CharOperation.subarray(c,1,c.length);
+			CharOperation.replace(type,'/','.');
+			return type;
+		}
+	}
+	
+	/**
+	 * Given 'Ppkg/MyGenericClass<Ljava/lang/String;Ljava/lang/Integer;>;'
+	 * will return 'QMyGenericClass<QString;QInteger;>;'
+	 */
+	public static char[] createShortName(char[] c) {
+		int lt = CharOperation.indexOf('<',c);
+		int sc = CharOperation.indexOf(';',c);
+		int gt = CharOperation.indexOf('>',c);
+		
+		int smallest = 0;
+		if (lt == -1 && sc == -1 && gt == -1) {
+			// we have something like 'Ljava/lang/String' or 'I'
+			return getTypeName(c);
+		} else if (lt != -1 && (sc == -1 || lt <= sc) && (gt == -1 || lt <= gt)) {
+			// we have something like 'Ljava/lang/String<I'
+			smallest = lt;
+		} else if (sc != -1 && (lt == -1 || sc <= lt) && (gt == -1 || sc <= gt)) {
+			// we have something like 'Ljava/lang/String;I'
+			smallest = sc;
+		} else {
+			// we have something like '>;'
+			smallest = gt;
+		}
+		char[] first = CharOperation.subarray(c,0,smallest);
+		char[] second = CharOperation.subarray(c,smallest+1,c.length);
+		if (smallest == 0 && first.length == 0 && c[0] == '>') {
+			// c = {'>',';'} therefore we just want to return c to
+			// close the generic signature
+			return c;
+		} else if (first.length == 1 && second.length == 0) {
+			return first;
+		} else if (second.length == 0 || (second.length == 1 && second[0] == ';')){
+			// we've reached the end of the array, therefore only care about
+			// the first part
+			return createShortName(first);
+		} else if (smallest == lt) {
+			// if c = 'Ljava/lang/String;<I' then first = 'Ljava/Lang/String;' and
+			// second = 'I'. Want to end up with 'LString<I' and so add
+			// the '<' back.
+			char[] inclLT = CharOperation.concat(createShortName(first),BACKSLASH_LESSTHAN);
+			return CharOperation.concat(inclLT,createShortName(second));
+		} else if (smallest == gt) {
+			char[] inclLT = CharOperation.concat(createShortName(first),GREATER_THAN);
+			return CharOperation.concat(inclLT,createShortName(second));			
+		} else {
+			// if c = 'Ljava/lang/Sting;LMyClass;' then first = 'Ljava/lang/String'
+			// and second = 'LMyClass;'. Want to end up with 'QString;QMyClass;
+			// so add the ';' back
+			char[] firstTypeParam = CharOperation.concat(createShortName(first),SEMICOLON);
+			return CharOperation.concat(firstTypeParam,createShortName(second));
+		}
+	}
+
+	/**
+	 * Given 'Qjava/lang/String;' returns 'QString;'
+	 */
+	public static char[] getTypeName(char[] name) {
+		int i = CharOperation.lastIndexOf('/',name);
+		if (i != -1) {
+			if (name[0] == RESOLVED || name[0] == PARAMETERIZED) {
+				return CharOperation.concat(new char[]{UNRESOLVED},
+						CharOperation.subarray(name,i+1,name.length));
+			} else {
+				return CharOperation.concat(new char[]{name[0]},
+						CharOperation.subarray(name,i+1,name.length));
+			}
+		}
+		return name;
+	}
+}
@@ -25,8 +25,6 @@ import org.aspectj.asm.HierarchyWalker;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
-import org.aspectj.util.CharOperation;
-import org.aspectj.util.NameConvertor;
 
 
 /**
@@ -15,6 +15,8 @@ package org.aspectj.asm;
 
 // default package
 
+import org.aspectj.asm.NameConvertorTest;
+
 import junit.framework.*;
 
 public class AsmModuleTests extends TestCase {
@@ -22,6 +24,7 @@ public class AsmModuleTests extends TestCase {
     public static TestSuite suite() { 
         TestSuite suite = new TestSuite(AsmModuleTests.class.getName());
         suite.addTestSuite(AsmModuleTests.class); 
+        suite.addTestSuite(NameConvertorTest.class);
         return suite;
     }
 
@@ -0,0 +1,86 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.asm;
+
+import org.aspectj.asm.internal.CharOperation;
+import org.aspectj.asm.internal.NameConvertor;
+
+import junit.framework.TestCase;
+
+public class NameConvertorTest extends TestCase {
+
+	public void testBoolean() {
+		checkConversion("Z","boolean");
+	}
+	
+	public void testByte() {
+		checkConversion("B","byte");
+	}
+	
+	public void testChar() {
+		checkConversion("C","char");
+	}	
+	
+	public void testDouble() {
+		checkConversion("D","double");
+	}	
+	
+	public void testFloat() {
+		checkConversion("F","float");
+	}
+	
+	public void testInt() {
+		checkConversion("I","int");
+	}
+	
+	public void testLong() {
+		checkConversion("J","long");
+	}	
+	
+	public void testShort() {
+		checkConversion("S","short");
+	}	
+	
+	public void testString() {
+		checkConversion("Ljava/lang/String;","java.lang.String");
+	}
+
+	public void testType() {
+		checkConversion("LMyClass;","MyClass");
+	}
+
+	public void testListPameterizedWithString() {
+		checkConversion("Pjava/util/List<Ljava/lang/String;>;",
+				"java.util.List<java.lang.String>");
+	}
+	public void testClassParameterizedWithStringAndType() {
+		checkConversion("PMyGenericClass<Ljava/lang/String;LMyClass;>;",
+				"MyGenericClass<java.lang.String,MyClass>");
+	}
+	public void testStringArray() {
+		checkConversion("[Ljava/lang/String;","java.lang.String[]");
+	}
+	public void testTwoDimensionalStringArray() {
+		checkConversion("[[Ljava/lang/String;","java.lang.String[][]");
+	}
+	public void testIntArray() {
+		checkConversion("[I","int[]");
+	}
+
+	private void checkConversion(String signature, String expected) {
+		char[] c = NameConvertor.convertFromSignature(signature.toCharArray());
+		assertTrue("converting " + signature + ", expected " + expected + "," +
+				"but found " + String.valueOf(c),
+				CharOperation.equals(c,expected.toCharArray()));
+	}
+
+	
+}
@@ -1,116 +0,0 @@
-/********************************************************************
- * Copyright (c) 2006 Contributors. All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: IBM Corporation - initial API and implementation 
- * 				 Helen Hawkins   - initial version
- *******************************************************************/
-package org.aspectj.util;
-
-
-/**
- * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
- *
- */
-public class CharOperation {
-	
-	/**
-	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
-	 */	
-	public static final char[] subarray(char[] array, int start, int end) {
-		if (end == -1)
-			end = array.length;
-		if (start > end)
-			return null;
-		if (start < 0)
-			return null;
-		if (end > array.length)
-			return null;
-
-		char[] result = new char[end - start];
-		System.arraycopy(array, start, result, 0, end - start);
-		return result;
-	}
-	
-	/**
-	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
-	 */	
-	public static final int lastIndexOf(char toBeFound, char[] array) {
-		for (int i = array.length; --i >= 0;)
-			if (toBeFound == array[i])
-				return i;
-		return -1;
-	}
-	
-	/**
-	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
-	 */	
-	public static final boolean contains(char character, char[] array) {
-		for (int i = array.length; --i >= 0;)
-			if (array[i] == character)
-				return true;
-		return false;
-	}
-
-	/**
-	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
-	 */	
-	public static final int indexOf(char toBeFound, char[] array) {
-		for (int i = 0; i < array.length; i++)
-			if (toBeFound == array[i])
-				return i;
-		return -1;
-	}
-	
-	/**
-	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
-	 */	
-	public static final char[] concat(char[] first, char[] second) {
-		if (first == null)
-			return second;
-		if (second == null)
-			return first;
-
-		int length1 = first.length;
-		int length2 = second.length;
-		char[] result = new char[length1 + length2];
-		System.arraycopy(first, 0, result, 0, length1);
-		System.arraycopy(second, 0, result, length1, length2);
-		return result;
-	}
-	
-	/**
-	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
-	 */	
-	public static final boolean equals(char[] first, char[] second) {
-		if (first == second)
-			return true;
-		if (first == null || second == null)
-			return false;
-		if (first.length != second.length)
-			return false;
-
-		for (int i = first.length; --i >= 0;)
-			if (first[i] != second[i])
-				return false;
-		return true;
-	}
-	
-	/**
-	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
-	 */	
-	public static final void replace(
-		char[] array,
-		char toBeReplaced,
-		char replacementChar) {
-		if (toBeReplaced != replacementChar) {
-			for (int i = 0, max = array.length; i < max; i++) {
-				if (array[i] == toBeReplaced)
-					array[i] = replacementChar;
-			}
-		}
-	}
-}
@@ -1,213 +0,0 @@
-/********************************************************************
- * Copyright (c) 2006 Contributors. All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: IBM Corporation - initial API and implementation 
- * 				 Helen Hawkins   - initial version
- *******************************************************************/
-package org.aspectj.util;
-
-public class NameConvertor {
-
-	private static final char BOOLEAN 	= 'Z';
-	private static final char BYTE 		= 'B';
-	private static final char CHAR 		= 'C';
-	private static final char DOUBLE 	= 'D';
-	private static final char FLOAT 	= 'F';
-	private static final char INT 		= 'I';
-	private static final char LONG		= 'J';
-	private static final char SHORT		= 'S';
-	private static final char ARRAY		= '[';
-	private static final char RESOLVED = 'L';
-	private static final char UNRESOLVED = 'Q';
-	
-	public static final char PARAMETERIZED = 'P';
-	
-	private static final char[] BOOLEAN_NAME = new char[]{'b','o','o','l','e','a','n'};
-	private static final char[] BYTE_NAME = new char[]{'b','y','t','e'};
-	private static final char[] CHAR_NAME = new char[]{'c','h','a','r'};
-	private static final char[] DOUBLE_NAME = new char[]{'d','o','u','b','l','e'};
-	private static final char[] FLOAT_NAME = new char[]{'f','l','o','a','t'};
-	private static final char[] INT_NAME = new char[]{'i','n','t'};
-	private static final char[] LONG_NAME = new char[]{'l','o','n','g'};
-	private static final char[] SHORT_NAME = new char[]{'s','h','o','r','t'};
-
-	private static final char[] SQUARE_BRACKETS = new char[]{'[',']'};
-	private static final char[] GREATER_THAN = new char[]{'>'};
-	private static final char[] LESS_THAN = new char[]{'<'};
-	private static final char[] COMMA = new char[]{','};
-	private static final char[] BACKSLASH_LESSTHAN = new char[]{'\\','<'};
-	private static final char[] SEMICOLON = new char[]{';'};
-	
-	
-	/**
-	 * Creates a readable name from the given char array, for example, 
-	 * given 'I' returns 'int'. Moreover, given 
-	 * 'Ljava/lang/String;<Ljava/lang/String;>' returns
-	 * 'java.lang.String<java.lang.String>'
-	 */
-	public static char[] convertFromSignature(char[] c) {
-		int lt = CharOperation.indexOf('<',c);
-		int sc = CharOperation.indexOf(';',c);
-		int gt = CharOperation.indexOf('>',c);
-		
-		int smallest = 0;
-		if (lt  == -1 && sc == -1 && gt == -1) {
-			// we have something like 'Ljava/lang/String' or 'I'
-			return getFullyQualifiedTypeName(c);
-		} else if (lt != -1 && (sc == -1 || lt <= sc) && (gt == -1 || lt <= gt)) {
-			// we have something like 'Ljava/lang/String<I'
-			smallest = lt;
-		} else if (sc != -1 && (lt == -1 || sc <= lt) && (gt == -1 || sc <= gt)) {
-			// we have something like 'Ljava/lang/String;I'
-			smallest = sc;
-		} else {
-			// we have something like '>;'
-			smallest = gt;
-		}
-		char[] first = CharOperation.subarray(c,0,smallest);
-		char[] second = CharOperation.subarray(c,smallest+1,c.length);
-		if (smallest == 0 && first.length == 0 && c[0] == '>') {
-			// c = {'>',';'} therefore we just want to return '>' to
-			// close the generic signature
-			return GREATER_THAN;
-		} else if (first.length == 1 && second.length == 0) {
-			return first;
-		} else if (second.length == 0 || (second.length == 1 && second[0] == ';')){
-			// we've reached the end of the array, therefore only care about
-			// the first part
-			return convertFromSignature(first);
-		} else if (smallest == lt) {
-			// if c = 'Ljava/lang/String;<I' then first = 'Ljava/Lang/String;' and
-			// second = 'I'. Want to end up with 'Ljava.lang.String<I' and so add
-			// the '<' back.
-			char[] inclLT = CharOperation.concat(convertFromSignature(first),LESS_THAN);
-			return CharOperation.concat(inclLT,convertFromSignature(second));
-		} else if (smallest == gt) {
-			char[] inclLT = CharOperation.concat(convertFromSignature(first),GREATER_THAN);
-			return CharOperation.concat(inclLT,convertFromSignature(second));			
-		} else if (second.length != 2) {
-			// if c = 'Ljava/lang/Sting;LMyClass' then first = 'Ljava/lang/String'
-			// and second = 'LMyClass'. Want to end up with 'java.lang.String,MyClass
-			// so want to add a ','. However, only want to do this if we're in the 
-			// middle of a '<...>'
-			char[] inclComma = CharOperation.concat(convertFromSignature(first),COMMA);
-			return CharOperation.concat(inclComma,convertFromSignature(second));
-		}
-		return CharOperation.concat(convertFromSignature(first),convertFromSignature(second));
-	}
-	
-	
-	/**
-	 * Given a char array, returns the type name for this. For example
-	 * 'I' returns 'int', 'Ljava/lang/String' returns 'java.lang.String' and
-	 * '[Ljava/lang/String' returns 'java.lang.String[]'
-	 * 
-	 * NOTE: Doesn't go any deaper so given 'Ljava/lang/String;<Ljava/lang/String;>' 
-	 * it would return 'java.lang.String;<Ljava.lang.String;>', however, only called
-	 * with something like 'Ljava/lang/String'
-	 */
-	private static char[] getFullyQualifiedTypeName(char[] c) {
-		if (c.length == 0) {
-			return c;
-		} 
-		if (c[0] == BOOLEAN) {
-			return BOOLEAN_NAME;
-		} else if (c[0] == BYTE) {
-			return BYTE_NAME;
-		} else if (c[0] == CHAR) {
-			return CHAR_NAME;
-		} else if (c[0] == DOUBLE) {
-			return DOUBLE_NAME;
-		} else if (c[0] == FLOAT) {
-			return FLOAT_NAME;
-		} else if (c[0] == INT) {
-			return INT_NAME;
-		} else if (c[0] == LONG) {
-			return LONG_NAME;
-		} else if (c[0] == SHORT) {
-			return SHORT_NAME;
-		} else if (c[0] == ARRAY) {
-			return CharOperation.concat(
-					getFullyQualifiedTypeName(CharOperation.subarray(c,1,c.length)),
-					SQUARE_BRACKETS);
-		} else {
-			char[] type = CharOperation.subarray(c,1,c.length);
-			CharOperation.replace(type,'/','.');
-			return type;
-		}
-	}
-	
-	/**
-	 * Given 'Ppkg/MyGenericClass<Ljava/lang/String;Ljava/lang/Integer;>;'
-	 * will return 'QMyGenericClass<QString;QInteger;>;'
-	 */
-	public static char[] createShortName(char[] c) {
-		int lt = CharOperation.indexOf('<',c);
-		int sc = CharOperation.indexOf(';',c);
-		int gt = CharOperation.indexOf('>',c);
-		
-		int smallest = 0;
-		if (lt == -1 && sc == -1 && gt == -1) {
-			// we have something like 'Ljava/lang/String' or 'I'
-			return getTypeName(c);
-		} else if (lt != -1 && (sc == -1 || lt <= sc) && (gt == -1 || lt <= gt)) {
-			// we have something like 'Ljava/lang/String<I'
-			smallest = lt;
-		} else if (sc != -1 && (lt == -1 || sc <= lt) && (gt == -1 || sc <= gt)) {
-			// we have something like 'Ljava/lang/String;I'
-			smallest = sc;
-		} else {
-			// we have something like '>;'
-			smallest = gt;
-		}
-		char[] first = CharOperation.subarray(c,0,smallest);
-		char[] second = CharOperation.subarray(c,smallest+1,c.length);
-		if (smallest == 0 && first.length == 0 && c[0] == '>') {
-			// c = {'>',';'} therefore we just want to return c to
-			// close the generic signature
-			return c;
-		} else if (first.length == 1 && second.length == 0) {
-			return first;
-		} else if (second.length == 0 || (second.length == 1 && second[0] == ';')){
-			// we've reached the end of the array, therefore only care about
-			// the first part
-			return createShortName(first);
-		} else if (smallest == lt) {
-			// if c = 'Ljava/lang/String;<I' then first = 'Ljava/Lang/String;' and
-			// second = 'I'. Want to end up with 'LString<I' and so add
-			// the '<' back.
-			char[] inclLT = CharOperation.concat(createShortName(first),BACKSLASH_LESSTHAN);
-			return CharOperation.concat(inclLT,createShortName(second));
-		} else if (smallest == gt) {
-			char[] inclLT = CharOperation.concat(createShortName(first),GREATER_THAN);
-			return CharOperation.concat(inclLT,createShortName(second));			
-		} else {
-			// if c = 'Ljava/lang/Sting;LMyClass;' then first = 'Ljava/lang/String'
-			// and second = 'LMyClass;'. Want to end up with 'QString;QMyClass;
-			// so add the ';' back
-			char[] firstTypeParam = CharOperation.concat(createShortName(first),SEMICOLON);
-			return CharOperation.concat(firstTypeParam,createShortName(second));
-		}
-	}
-
-	/**
-	 * Given 'Qjava/lang/String;' returns 'QString;'
-	 */
-	public static char[] getTypeName(char[] name) {
-		int i = CharOperation.lastIndexOf('/',name);
-		if (i != -1) {
-			if (name[0] == RESOLVED || name[0] == PARAMETERIZED) {
-				return CharOperation.concat(new char[]{UNRESOLVED},
-						CharOperation.subarray(name,i+1,name.length));
-			} else {
-				return CharOperation.concat(new char[]{name[0]},
-						CharOperation.subarray(name,i+1,name.length));
-			}
-		}
-		return name;
-	}
-}
@@ -1,83 +0,0 @@
-/********************************************************************
- * Copyright (c) 2006 Contributors. All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: IBM Corporation - initial API and implementation 
- * 				 Helen Hawkins   - initial version
- *******************************************************************/
-package org.aspectj.util;
-
-import junit.framework.TestCase;
-
-public class NameConvertorTest extends TestCase {
-
-	public void testBoolean() {
-		checkConversion("Z","boolean");
-	}
-	
-	public void testByte() {
-		checkConversion("B","byte");
-	}
-	
-	public void testChar() {
-		checkConversion("C","char");
-	}	
-	
-	public void testDouble() {
-		checkConversion("D","double");
-	}	
-	
-	public void testFloat() {
-		checkConversion("F","float");
-	}
-	
-	public void testInt() {
-		checkConversion("I","int");
-	}
-	
-	public void testLong() {
-		checkConversion("J","long");
-	}	
-	
-	public void testShort() {
-		checkConversion("S","short");
-	}	
-	
-	public void testString() {
-		checkConversion("Ljava/lang/String;","java.lang.String");
-	}
-
-	public void testType() {
-		checkConversion("LMyClass;","MyClass");
-	}
-
-	public void testListPameterizedWithString() {
-		checkConversion("Pjava/util/List<Ljava/lang/String;>;",
-				"java.util.List<java.lang.String>");
-	}
-	public void testClassParameterizedWithStringAndType() {
-		checkConversion("PMyGenericClass<Ljava/lang/String;LMyClass;>;",
-				"MyGenericClass<java.lang.String,MyClass>");
-	}
-	public void testStringArray() {
-		checkConversion("[Ljava/lang/String;","java.lang.String[]");
-	}
-	public void testTwoDimensionalStringArray() {
-		checkConversion("[[Ljava/lang/String;","java.lang.String[][]");
-	}
-	public void testIntArray() {
-		checkConversion("[I","int[]");
-	}
-
-	private void checkConversion(String signature, String expected) {
-		char[] c = NameConvertor.convertFromSignature(signature.toCharArray());
-		assertTrue("converting " + signature + ", expected " + expected + "," +
-				"but found " + String.valueOf(c),
-				CharOperation.equals(c,expected.toCharArray()));
-	}
-
-	
-}
@@ -23,7 +23,6 @@ public class UtilTests extends TestCase {
         //$JUnit-BEGIN$
         suite.addTestSuite(FileUtilTest.class); 
         suite.addTestSuite(LangUtilTest.class); 
-        suite.addTestSuite(NameConvertorTest.class);
         //$JUnit-END$
         return suite;
     }
@@ -18,8 +18,8 @@ import junit.framework.Test;
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IHierarchy;
 import org.aspectj.asm.IProgramElement;
+import org.aspectj.asm.internal.CharOperation;
 import org.aspectj.testing.XMLBasedAjcTestCase;
-import org.aspectj.util.CharOperation;
 
 public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
@@ -56,7 +56,6 @@ import org.aspectj.apache.bcel.generic.annotation.AnnotationGen;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.bridge.SourceLocation;
-import org.aspectj.util.CollectionUtil;
 import org.aspectj.weaver.AjAttribute;
 import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.Member;
@@ -83,6 +82,8 @@ public final class LazyClassGen {
 
 	private static final int ACC_SYNTHETIC    = 0x1000;
 
+    private static final String[] NO_STRINGS = new String[0];
+
 	int highestLineNumber = 0; // ---- JSR 45 info
 
 	private SortedMap /* <String, InlinedSourceFileInfo> */ inlinedFiles = new TreeMap();
@@ -850,7 +851,7 @@ public final class LazyClassGen {
         	Type.VOID,
         	"<clinit>",
         	new Type[0],
-        	CollectionUtil.NO_STRINGS,
+        	NO_STRINGS,
         	this);
        	clinit.getBody().insert(InstructionConstants.RETURN);
         methodGens.add(clinit);
@@ -867,7 +868,7 @@ public final class LazyClassGen {
         	Type.VOID,
         	NameMangler.AJC_PRE_CLINIT_NAME,
         	new Type[0],
-        	CollectionUtil.NO_STRINGS,
+        	NO_STRINGS,
         	this);
        	ajcClinit.getBody().insert(InstructionConstants.RETURN);
         methodGens.add(ajcClinit);
@@ -19,6 +19,11 @@ import java.io.File;
 /**
  * Represent source location as a starting line/column and ending
  * line in a source file.
+ * Implementations should be immutable. XXX why?
+ * @see org.aspectj.lang.reflect.SourceLocation
+ * @see org.aspectj.compiler.base.parser.SourceInfo
+ * @see org.aspectj.tools.ide.SourceLine
+ * @see org.aspectj.testing.harness.ErrorLine
  */
 public interface ISourceLocation  {
     static final int MAX_LINE = Integer.MAX_VALUE / 2;
@@ -22,6 +22,10 @@ import org.aspectj.util.LangUtil;
  * Immutable source location.
  * This guarantees that the source file is not null
  * and that the numeric values are positive and line <= endLine.
+ * @see org.aspectj.lang.reflect.SourceLocation
+ * @see org.aspectj.compiler.base.parser.SourceInfo
+ * @see org.aspectj.tools.ide.SourceLine
+ * @see org.aspectj.testing.harness.ErrorLine
  */
 public class SourceLocation implements ISourceLocation, java.io.Serializable {
 
@@ -14,6 +14,7 @@ import java.util.logging.Handler;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
+// OPTIMIZE move out for now? check what doc says about using these variants on trace (commons/14)
 public class Jdk14Trace extends AbstractTrace {
 
 	private Logger logger;
@@ -13,14 +13,19 @@
 
 package org.aspectj.weaver.patterns;
 
-import java.io.*;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
 import java.util.Arrays;
 
-import org.aspectj.weaver.bcel.*;
-import org.aspectj.util.*;
-
 import junit.framework.TestCase;
-import org.aspectj.weaver.*;
+
+import org.aspectj.util.FuzzyBoolean;
+import org.aspectj.weaver.ResolvedType;
+import org.aspectj.weaver.VersionedDataInputStream;
+import org.aspectj.weaver.World;
+import org.aspectj.weaver.bcel.BcelWorld;
 
 /**
  * @author hugunin
@@ -119,9 +124,11 @@ public class TypePatternListTestCase extends TestCase {
 		String msg = "matches statically " + pattern + " to " + Arrays.asList(types);
         assertEquals(msg, shouldMatchStatically, result);       
 	}
-	
+
+    public static final String[] NO_STRINGS = new String[0];
+    
 	private TestScope makeTestScope() {
-		TestScope scope = new TestScope(CollectionUtil.NO_STRINGS, CollectionUtil.NO_STRINGS, world);
+		TestScope scope = new TestScope(NO_STRINGS, NO_STRINGS, world);
 		return scope;
 	}
 
@@ -1,60 +0,0 @@
-/* *******************************************************************
- * Copyright (c) 1999-2001 Xerox Corporation, 
- *               2002 Palo Alto Research Center, Incorporated (PARC).
- * All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://www.eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: 
- *     Xerox/PARC     initial implementation 
- * ******************************************************************/
-
-
-package org.aspectj.util;
-
-
-import java.util.*;
-
-public class CollectionUtil {
-	public static final String[] NO_STRINGS = new String[0];
-	
-	
-    public static List getListInMap(Map map, Object key) {
-        List list = (List)map.get(key);
-        if (list == null) {
-            list = new ArrayList();
-            map.put(key, list);
-        }
-        return list;
-    }
-
-    public static SortedSet getSortedSetInMap(Map map, Object key) {
-        SortedSet list = (SortedSet)map.get(key);
-        if (list == null) {
-            list = new TreeSet();
-            map.put(key, list);
-        }
-        return list;
-    }
-
-    public static Set getSetInMap(Map map, Object key) {
-        Set list = (Set)map.get(key);
-        if (list == null) {
-            list = new HashSet();
-            map.put(key, list);
-        }
-        return list;
-    }
-
-    public static Map getMapInMap(Map map, Object key) {
-        Map list = (Map)map.get(key);
-        if (list == null) {
-            list = new HashMap();
-            map.put(key, list);
-        }
-        return list;
-    }
-    
-}
@@ -23,7 +23,7 @@ import java.util.Map;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.util.FuzzyBoolean;
-import org.aspectj.weaver.BetaException;
+import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.ISourceContext;
 import org.aspectj.weaver.IntMap;
 import org.aspectj.weaver.ResolvedType;
@@ -293,7 +293,7 @@ public class ArgsPointcut extends NameBindingPointcut {
 			}
 			return findResidueNoEllipsis(shadow, state, patternsWithoutEllipsis);
 		} else {
-			throw new BetaException("unimplemented");
+			throw new BCException("unimplemented");
 		}
 	}
 
@@ -1,29 +0,0 @@
-/* *******************************************************************
- * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
- * All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://www.eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: 
- *     PARC     initial implementation 
- * ******************************************************************/
-
-
-package org.aspectj.weaver;
-
-/**
- * Exception to use inside the bcweaver.
- */
-public class BetaException extends RuntimeException {
-
-    public BetaException() {
-        super();
-    }
-
-    public BetaException(String s) {
-        super(s);
-    }
-
-}
@@ -356,6 +356,7 @@ public class AjTypeImpl<T> implements AjType<T> {
 
 	private boolean isReallyAMethod(Method method) {
 		if (method.getName().startsWith(ajcMagic)) return false;
+		if (method.getAnnotations().length==0) return true;
 		if (method.isAnnotationPresent(org.aspectj.lang.annotation.Pointcut.class)) return false;
 		if (method.isAnnotationPresent(Before.class)) return false;
 		if (method.isAnnotationPresent(After.class)) return false;
@@ -39,7 +39,6 @@ import org.aspectj.bridge.Version;
 import org.aspectj.org.eclipse.jdt.core.compiler.InvalidInputException;
 import org.aspectj.org.eclipse.jdt.internal.compiler.batch.Main;
 import org.aspectj.org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
-import org.aspectj.util.ConfigParser;
 import org.aspectj.util.FileUtil;
 import org.aspectj.util.LangUtil;
 import org.aspectj.weaver.Constants;
@@ -0,0 +1,316 @@
+/* *******************************************************************
+ * Copyright (c) 1999-2001 Xerox Corporation, 
+ *               2002 Palo Alto Research Center, Incorporated (PARC).
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *     Xerox/PARC     initial implementation 
+ * ******************************************************************/
+
+
+
+package org.aspectj.ajdt.ajc;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileFilter;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
+
+public class ConfigParser {
+    Location location;
+    protected File relativeDirectory = null;
+    protected List files = new LinkedList();
+    private boolean fileParsed = false;
+    protected static String CONFIG_MSG = "build config error: ";  
+    
+    public List getFiles() { return files; }
+
+    public void parseCommandLine(String[] argsArray) throws ParseException {
+        location = new CommandLineLocation();
+        LinkedList args = new LinkedList();
+        for (int i = 0; i < argsArray.length; i++) {
+            args.add(new Arg(argsArray[i], location));
+        }
+        parseArgs(args);
+    }
+
+    public void parseConfigFile(File configFile) throws ParseException {
+        if (fileParsed == true) {
+            throw new ParseException(CONFIG_MSG + "The file has already been parsed.", null);
+        } else {
+            parseConfigFileHelper(configFile);
+        }
+    }
+
+    /**
+     * @throws ParseException   if the config file has already been prased.
+     */
+    private void parseConfigFileHelper(File configFile) {
+        if (!configFile.exists()) {
+            showError("file does not exist: " + configFile.getPath());
+            return;
+        }
+
+        LinkedList args = new LinkedList();
+        int lineNum = 0;
+
+        try {
+            BufferedReader stream =
+                new BufferedReader(new FileReader(configFile));
+            String line = null;
+            while ( (line = stream.readLine()) != null) {
+                lineNum += 1;
+                line = stripWhitespaceAndComments(line);
+                if (line.length() == 0) continue;
+                args.add(new Arg(line, new CPSourceLocation(configFile, lineNum)));
+            }
+            stream.close();
+        } catch (IOException e) {
+            location = new CPSourceLocation(configFile, lineNum);
+            showError("error reading config file: " + e.toString());
+        }
+        File oldRelativeDirectory = relativeDirectory; // for nested arg files;
+        relativeDirectory = configFile.getParentFile();
+        parseArgs(args);
+        relativeDirectory = oldRelativeDirectory;
+        fileParsed = true;
+    }
+
+    File getCurrentDir() {
+        return location.getDirectory();
+    }
+
+    String stripSingleLineComment(String s, String commentString) {
+        int commentStart = s.indexOf(commentString);
+        if (commentStart == -1) return s;
+        else return s.substring(0, commentStart);
+    }
+
+    String stripWhitespaceAndComments(String s) {
+        s = stripSingleLineComment(s, "//");
+        s = stripSingleLineComment(s, "#");
+        s = s.trim();
+        if (s.startsWith("\"") && s.endsWith("\"")) {
+            s = s.substring(1, s.length()-1);
+        }
+        return s;
+    }
+
+
+    /** ??? We would like to call a showNonFatalError method here
+     *  to show all errors in config files before aborting the compilation
+     */
+    protected void addFile(File sourceFile) {
+        if (!sourceFile.isFile()) {
+            showError("source file does not exist: " + sourceFile.getPath());
+        }
+        
+        files.add(sourceFile);
+    }
+
+    void addFileOrPattern(File sourceFile) {
+        if (sourceFile.getName().equals("*.java")) {
+            addFiles(sourceFile.getParentFile(), new FileFilter() {
+                    public boolean accept(File f) {
+                        return f != null && f.getName().endsWith(".java");
+                    }});
+        } else if (sourceFile.getName().equals("*.aj")) {
+            addFiles(sourceFile.getParentFile(), new FileFilter() {
+                    public boolean accept(File f) {
+                        return f != null && f.getName().endsWith(".aj");
+                    }});
+        } else {
+            addFile(sourceFile);
+        }
+    }
+
+    void addFiles(File dir, FileFilter filter) {
+        if (dir == null) dir = new File(System.getProperty("user.dir"));
+        
+        if (!dir.isDirectory()) {
+            showError("can't find " + dir.getPath());
+        } else {
+
+          File[] files = dir.listFiles(filter);
+          if (files.length == 0) {
+            showWarning("no matching files found in: " + dir);
+          }
+
+          for (int i = 0; i < files.length; i++) {
+            addFile(files[i]);
+          }
+        }
+    }
+
+    protected void parseOption(String arg, LinkedList args) {
+        showWarning("unrecognized option: " + arg);
+    }
+
+    protected void showWarning(String message) {
+        if (location != null) {
+            message += " at " + location.toString();
+        }
+        System.err.println(CONFIG_MSG + message);
+    }
+
+    protected void showError(String message) {
+        throw new ParseException(CONFIG_MSG + message, location);
+    }
+
+    void parseArgs(LinkedList args) {
+        while (args.size() > 0) parseOneArg(args);
+    }
+
+    protected Arg removeArg(LinkedList args) {
+        if (args.size() == 0) {
+            showError("value missing");
+            return null;
+        } else {
+            return (Arg)args.removeFirst();
+        }
+    }
+
+    protected String removeStringArg(LinkedList args) {
+        Arg arg = removeArg(args);
+        if (arg == null) return null;
+        return arg.getValue();
+    }
+
+    boolean isSourceFileName(String s) {
+        if (s.endsWith(".java")) return true;
+        if (s.endsWith(".aj")) return true;
+        if (s.endsWith(".ajava")) {
+            showWarning(".ajava is deprecated, replace with .aj or .java: " + s);
+            return true;
+        }
+        return false;
+    }
+
+    void parseOneArg(LinkedList args) {
+        Arg arg = removeArg(args);
+        String v = arg.getValue();
+        location = arg.getLocation();
+        if (v.startsWith("@")) {
+            parseImportedConfigFile(v.substring(1));
+        } else if (v.equals("-argfile")) {
+            parseConfigFileHelper(makeFile(removeArg(args).getValue()));
+        } else if (isSourceFileName(v)) {
+            addFileOrPattern(makeFile(v));
+        } else {
+            parseOption(arg.getValue(), args);
+        }
+    }
+
+	protected void parseImportedConfigFile(String relativeFilePath) {
+		parseConfigFileHelper(makeFile(relativeFilePath));		
+	}
+
+    public File makeFile(String name) {
+        if (relativeDirectory != null) {
+            return makeFile(relativeDirectory,name);
+        } else {
+            return makeFile(getCurrentDir(), name);
+        }
+    }
+
+    private File makeFile(File dir, String name) {
+        name = name.replace('/', File.separatorChar);
+        File ret = new File(name);
+        boolean isAbsolute = ret.isAbsolute()
+            || (ret.exists() && ret.getPath().startsWith(File.separator));
+        if (!isAbsolute && (dir != null)) { 
+          ret = new File(dir, name);
+        }
+        try {
+        	ret = ret.getCanonicalFile();
+        } catch (IOException ioEx) {
+        	// proceed without canonicalization
+        	// so nothing to do here
+        }
+        return ret;
+    }
+
+
+    protected static class Arg {
+        private Location location;
+        private String value;
+        public Arg(String value, Location location) {
+            this.value = value;
+            this.location = location;
+        }
+	
+		public void setValue(String value) {
+			this.value = value;	
+		}
+
+		public void setLocation(Location location) {
+			this.location = location;
+		}
+		
+        public String getValue() { return value; }
+        public Location getLocation() { return location; }
+    }
+    
+    static abstract class Location {
+        public abstract File getFile();
+        public abstract File getDirectory();
+        public abstract int getLine();
+        public abstract String toString();
+    }
+
+    static class CPSourceLocation extends Location {
+        private int line;
+        private File file;
+        public CPSourceLocation(File file, int line) {
+            this.line = line;
+            this.file = file;
+        }
+
+        public File getFile() { return file; }
+        public File getDirectory() { return file.getParentFile(); }
+        public int getLine() { return line; }
+
+        public String toString() {
+            return file.getPath()+":"+line;
+        }
+    }
+    
+    static class CommandLineLocation extends Location {
+        public File getFile() {
+            return new File(System.getProperty("user.dir"));
+        }
+        
+        public File getDirectory() {
+            return new File(System.getProperty("user.dir"));
+        }
+        public int getLine() { return -1; }
+        public String toString() {
+            return "command-line";
+        }
+    }
+
+    public static class ParseException extends RuntimeException {
+        private Location location;
+
+        public ParseException(String message, Location location) {
+            super(message);
+            this.location = location;
+        }
+
+        public int getLine() {
+            if (location == null) return -1;
+            return location.getLine();
+        }
+        public File getFile() {
+            if (location == null) return null;
+            return location.getFile();
+        }
+    }
+}
@@ -24,6 +24,7 @@ import org.aspectj.ajde.core.IOutputLocationManager;
 import org.aspectj.ajde.core.JavaOptions;
 import org.aspectj.ajdt.ajc.AjdtCommand;
 import org.aspectj.ajdt.ajc.BuildArgParser;
+import org.aspectj.ajdt.ajc.ConfigParser;
 import org.aspectj.ajdt.internal.core.builder.AjBuildConfig;
 import org.aspectj.ajdt.internal.core.builder.AjBuildManager;
 import org.aspectj.ajdt.internal.core.builder.AjState;
@@ -38,7 +39,6 @@ import org.aspectj.bridge.Message;
 import org.aspectj.bridge.SourceLocation;
 import org.aspectj.bridge.context.CompilationAndWeavingContext;
 import org.aspectj.org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
-import org.aspectj.util.ConfigParser;
 import org.aspectj.util.LangUtil;
 
 /**
@@ -30,7 +30,7 @@ public interface EditorAdapter {
     public void showSourceLine(String filePath, int lineNumber, boolean highlight);
 
 	/**
-	 * Seek the editor to a {@link SourceLocation} and highlight if specified.
+	 * Seek the editor to a SourceLocation and highlight if specified.
 	 */
     public void showSourceLine(ISourceLocation sourceLocation, boolean highlight);
 
@@ -18,7 +18,7 @@ import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 
-import org.aspectj.util.ConfigParser;
+import org.aspectj.ajdt.ajc.ConfigParser;
 
 /**
  * @author Mik Kersten
@@ -29,9 +29,9 @@ import java.util.TreeSet;
 
 import org.aspectj.ajde.Ajde;
 import org.aspectj.ajde.ui.BuildConfigNode;
+import org.aspectj.ajdt.ajc.ConfigParser;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.Message;
-import org.aspectj.util.ConfigParser;
 
 /**
  * Used for reading and writing build configuration (".lst") files.
@@ -27,10 +27,10 @@ import java.util.List;
 import org.aspectj.ajde.Ajde;
 import org.aspectj.ajde.ui.BuildConfigModel;
 import org.aspectj.ajde.ui.BuildConfigNode;
+import org.aspectj.ajdt.ajc.ConfigParser;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.Message;
 import org.aspectj.bridge.SourceLocation;
-import org.aspectj.util.ConfigParser;
 import org.aspectj.util.FileUtil;
 
 /**
@@ -1,311 +0,0 @@
-/* *******************************************************************
- * Copyright (c) 1999-2001 Xerox Corporation, 
- *               2002 Palo Alto Research Center, Incorporated (PARC).
- * All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://www.eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: 
- *     Xerox/PARC     initial implementation 
- * ******************************************************************/
-
-
-
-package org.aspectj.util;
-
-import java.util.*;
-import java.io.*;
-
-public class ConfigParser {
-    Location location;
-    protected File relativeDirectory = null;
-    protected List files = new LinkedList();
-    private boolean fileParsed = false;
-    protected static String CONFIG_MSG = "build config error: ";  
-    
-    public List getFiles() { return files; }
-
-    public void parseCommandLine(String[] argsArray) throws ParseException {
-        location = new CommandLineLocation();
-        LinkedList args = new LinkedList();
-        for (int i = 0; i < argsArray.length; i++) {
-            args.add(new Arg(argsArray[i], location));
-        }
-        parseArgs(args);
-    }
-
-    public void parseConfigFile(File configFile) throws ParseException {
-        if (fileParsed == true) {
-            throw new ParseException(CONFIG_MSG + "The file has already been parsed.", null);
-        } else {
-            parseConfigFileHelper(configFile);
-        }
-    }
-
-    /**
-     * @throws ParseException   if the config file has already been prased.
-     */
-    private void parseConfigFileHelper(File configFile) {
-        if (!configFile.exists()) {
-            showError("file does not exist: " + configFile.getPath());
-            return;
-        }
-
-        LinkedList args = new LinkedList();
-        int lineNum = 0;
-
-        try {
-            BufferedReader stream =
-                new BufferedReader(new FileReader(configFile));
-            String line = null;
-            while ( (line = stream.readLine()) != null) {
-                lineNum += 1;
-                line = stripWhitespaceAndComments(line);
-                if (line.length() == 0) continue;
-                args.add(new Arg(line, new SourceLocation(configFile, lineNum)));
-            }
-            stream.close();
-        } catch (IOException e) {
-            location = new SourceLocation(configFile, lineNum);
-            showError("error reading config file: " + e.toString());
-        }
-        File oldRelativeDirectory = relativeDirectory; // for nested arg files;
-        relativeDirectory = configFile.getParentFile();
-        parseArgs(args);
-        relativeDirectory = oldRelativeDirectory;
-        fileParsed = true;
-    }
-
-    File getCurrentDir() {
-        return location.getDirectory();
-    }
-
-    String stripSingleLineComment(String s, String commentString) {
-        int commentStart = s.indexOf(commentString);
-        if (commentStart == -1) return s;
-        else return s.substring(0, commentStart);
-    }
-
-    String stripWhitespaceAndComments(String s) {
-        s = stripSingleLineComment(s, "//");
-        s = stripSingleLineComment(s, "#");
-        s = s.trim();
-        if (s.startsWith("\"") && s.endsWith("\"")) {
-            s = s.substring(1, s.length()-1);
-        }
-        return s;
-    }
-
-
-    /** ??? We would like to call a showNonFatalError method here
-     *  to show all errors in config files before aborting the compilation
-     */
-    protected void addFile(File sourceFile) {
-        if (!sourceFile.isFile()) {
-            showError("source file does not exist: " + sourceFile.getPath());
-        }
-        
-        files.add(sourceFile);
-    }
-
-    void addFileOrPattern(File sourceFile) {
-        if (sourceFile.getName().equals("*.java")) {
-            addFiles(sourceFile.getParentFile(), new FileFilter() {
-                    public boolean accept(File f) {
-                        return f != null && f.getName().endsWith(".java");
-                    }});
-        } else if (sourceFile.getName().equals("*.aj")) {
-            addFiles(sourceFile.getParentFile(), new FileFilter() {
-                    public boolean accept(File f) {
-                        return f != null && f.getName().endsWith(".aj");
-                    }});
-        } else {
-            addFile(sourceFile);
-        }
-    }
-
-    void addFiles(File dir, FileFilter filter) {
-        if (dir == null) dir = new File(System.getProperty("user.dir"));
-        
-        if (!dir.isDirectory()) {
-            showError("can't find " + dir.getPath());
-        } else {
-
-          File[] files = dir.listFiles(filter);
-          if (files.length == 0) {
-            showWarning("no matching files found in: " + dir);
-          }
-
-          for (int i = 0; i < files.length; i++) {
-            addFile(files[i]);
-          }
-        }
-    }
-
-    protected void parseOption(String arg, LinkedList args) {
-        showWarning("unrecognized option: " + arg);
-    }
-
-    protected void showWarning(String message) {
-        if (location != null) {
-            message += " at " + location.toString();
-        }
-        System.err.println(CONFIG_MSG + message);
-    }
-
-    protected void showError(String message) {
-        throw new ParseException(CONFIG_MSG + message, location);
-    }
-
-    void parseArgs(LinkedList args) {
-        while (args.size() > 0) parseOneArg(args);
-    }
-
-    protected Arg removeArg(LinkedList args) {
-        if (args.size() == 0) {
-            showError("value missing");
-            return null;
-        } else {
-            return (Arg)args.removeFirst();
-        }
-    }
-
-    protected String removeStringArg(LinkedList args) {
-        Arg arg = removeArg(args);
-        if (arg == null) return null;
-        return arg.getValue();
-    }
-
-    boolean isSourceFileName(String s) {
-        if (s.endsWith(".java")) return true;
-        if (s.endsWith(".aj")) return true;
-        if (s.endsWith(".ajava")) {
-            showWarning(".ajava is deprecated, replace with .aj or .java: " + s);
-            return true;
-        }
-        return false;
-    }
-
-    void parseOneArg(LinkedList args) {
-        Arg arg = removeArg(args);
-        String v = arg.getValue();
-        location = arg.getLocation();
-        if (v.startsWith("@")) {
-            parseImportedConfigFile(v.substring(1));
-        } else if (v.equals("-argfile")) {
-            parseConfigFileHelper(makeFile(removeArg(args).getValue()));
-        } else if (isSourceFileName(v)) {
-            addFileOrPattern(makeFile(v));
-        } else {
-            parseOption(arg.getValue(), args);
-        }
-    }
-
-	protected void parseImportedConfigFile(String relativeFilePath) {
-		parseConfigFileHelper(makeFile(relativeFilePath));		
-	}
-
-    public File makeFile(String name) {
-        if (relativeDirectory != null) {
-            return makeFile(relativeDirectory,name);
-        } else {
-            return makeFile(getCurrentDir(), name);
-        }
-    }
-
-    private File makeFile(File dir, String name) {
-        name = name.replace('/', File.separatorChar);
-        File ret = new File(name);
-        boolean isAbsolute = ret.isAbsolute()
-            || (ret.exists() && ret.getPath().startsWith(File.separator));
-        if (!isAbsolute && (dir != null)) { 
-          ret = new File(dir, name);
-        }
-        try {
-        	ret = ret.getCanonicalFile();
-        } catch (IOException ioEx) {
-        	// proceed without canonicalization
-        	// so nothing to do here
-        }
-        return ret;
-    }
-
-
-    protected static class Arg {
-        private Location location;
-        private String value;
-        public Arg(String value, Location location) {
-            this.value = value;
-            this.location = location;
-        }
-	
-		public void setValue(String value) {
-			this.value = value;	
-		}
-
-		public void setLocation(Location location) {
-			this.location = location;
-		}
-		
-        public String getValue() { return value; }
-        public Location getLocation() { return location; }
-    }
-    
-    static abstract class Location {
-        public abstract File getFile();
-        public abstract File getDirectory();
-        public abstract int getLine();
-        public abstract String toString();
-    }
-
-    static class SourceLocation extends Location {
-        private int line;
-        private File file;
-        public SourceLocation(File file, int line) {
-            this.line = line;
-            this.file = file;
-        }
-
-        public File getFile() { return file; }
-        public File getDirectory() { return file.getParentFile(); }
-        public int getLine() { return line; }
-
-        public String toString() {
-            return file.getPath()+":"+line;
-        }
-    }
-    
-    static class CommandLineLocation extends Location {
-        public File getFile() {
-            return new File(System.getProperty("user.dir"));
-        }
-        
-        public File getDirectory() {
-            return new File(System.getProperty("user.dir"));
-        }
-        public int getLine() { return -1; }
-        public String toString() {
-            return "command-line";
-        }
-    }
-
-    public static class ParseException extends RuntimeException {
-        private Location location;
-
-        public ParseException(String message, Location location) {
-            super(message);
-            this.location = location;
-        }
-
-        public int getLine() {
-            if (location == null) return -1;
-            return location.getLine();
-        }
-        public File getFile() {
-            if (location == null) return null;
-            return location.getFile();
-        }
-    }
-}
@@ -19,11 +19,6 @@ import java.io.File;
 /**
  * Represent source location as a starting line/column and ending
  * line in a source file.
- * Implementations should be immutable. XXX why?
- * @see org.aspectj.lang.reflect.SourceLocation
- * @see org.aspectj.compiler.base.parser.SourceInfo
- * @see org.aspectj.tools.ide.SourceLine
- * @see org.aspectj.testing.harness.ErrorLine
  */
 public interface ISourceLocation  {
     static final int MAX_LINE = Integer.MAX_VALUE / 2;
@@ -22,10 +22,6 @@ import org.aspectj.util.LangUtil;
  * Immutable source location.
  * This guarantees that the source file is not null
  * and that the numeric values are positive and line <= endLine.
- * @see org.aspectj.lang.reflect.SourceLocation
- * @see org.aspectj.compiler.base.parser.SourceInfo
- * @see org.aspectj.tools.ide.SourceLine
- * @see org.aspectj.testing.harness.ErrorLine
  */
 public class SourceLocation implements ISourceLocation, java.io.Serializable {
 
