@@ -35,7 +35,7 @@ public class TestJava5ReflectionBasedReferenceTypeDelegate extends ReflectionBas
 		int i = findMethod("toArray", 1, methods);
 		assertTrue("Couldn't find 'toArray' in the set of methods? ", i != -1);
 		// String expectedSignature = "java.lang.Object[] java.util.Collection.toArray(java.lang.Object[])";
-		String expectedSignature = "([Ljava/lang/Object;)Ljava/lang/Object;";
+		String expectedSignature = "([Ljava/lang/Object;)[Ljava/lang/Object;";
 		assertTrue("Expected signature of '" + expectedSignature + "' but it was '" + methods[i].getSignatureErased(), methods[i]
 				.getSignatureErased().equals(expectedSignature));
 	}
@@ -12,22 +12,19 @@
 
 package org.aspectj.weaver;
 
-
 import junit.framework.Test;
 import junit.framework.TestSuite;
 
 import org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest;
 
-
 public class TestJava5ReflectionBasedReferenceTypeDelegate extends ReflectionBasedReferenceTypeDelegateTest {
-	
+
 	public static Test suite() {
 		TestSuite suite = new TestSuite("TestJava5ReflectionBasedReferenceTypeDelegate");
 		suite.addTestSuite(TestJava5ReflectionBasedReferenceTypeDelegate.class);
 		return suite;
 	}
-	
-	
+
 	/**
 	 * Let's play about with a generic type and ensure we can work with it in a reflective world.
 	 */
@@ -36,9 +33,11 @@ public class TestJava5ReflectionBasedReferenceTypeDelegate extends ReflectionBas
 		world.resolve(collectionType).getRawType().resolve(world);
 		ResolvedMember[] methods = world.resolve(collectionType).getDeclaredMethods();
 		int i = findMethod("toArray", 1, methods);
-		assertTrue("Couldn't find 'toArray' in the set of methods? ",i != -1);
-		String expectedSignature = "java.lang.Object[] java.util.Collection.toArray(java.lang.Object[])";
-		assertTrue("Expected signature of '"+expectedSignature+"' but it was '"+methods[i],methods[i].toString().equals(expectedSignature));
+		assertTrue("Couldn't find 'toArray' in the set of methods? ", i != -1);
+		// String expectedSignature = "java.lang.Object[] java.util.Collection.toArray(java.lang.Object[])";
+		String expectedSignature = "([Ljava/lang/Object;)Ljava/lang/Object;";
+		assertTrue("Expected signature of '" + expectedSignature + "' but it was '" + methods[i].getSignatureErased(), methods[i]
+				.getSignatureErased().equals(expectedSignature));
 	}
 
 	/**
@@ -46,33 +45,33 @@ public class TestJava5ReflectionBasedReferenceTypeDelegate extends ReflectionBas
 	 */
 	public void testResolveEnum() {
 		ResolvedType enumType = world.resolve("java.lang.Enum");
-		assertTrue("Should be the raw type but is "+enumType.typeKind,enumType.isRawType());
+		assertTrue("Should be the raw type but is " + enumType.typeKind, enumType.isRawType());
 		ResolvedType theGenericEnumType = enumType.getGenericType();
-		assertTrue("Should have a type variable ",theGenericEnumType.getTypeVariables().length>0);
+		assertTrue("Should have a type variable ", theGenericEnumType.getTypeVariables().length > 0);
 		TypeVariable tv = theGenericEnumType.getTypeVariables()[0];
 		String expected = "TypeVar E extends java.lang.Enum<E>";
-		assertTrue("Type variable should be '"+expected+"' but is '"+tv+"'",tv.toString().equals(expected));
+		assertTrue("Type variable should be '" + expected + "' but is '" + tv + "'", tv.toString().equals(expected));
 	}
-	
+
 	public void testResolveClass() {
-		world.resolve("java.lang.Class").getGenericType();		
+		world.resolve("java.lang.Class").getGenericType();
 	}
-	
-    public void testGenericInterfaceSuperclass_ReflectionWorldResolution() {
-        
-        UnresolvedType javaUtilMap = UnresolvedType.forName("java.util.Map");
-        
-        ReferenceType rawType = (ReferenceType) world.resolve(javaUtilMap);
-        assertTrue("Should be the raw type ?!? "+rawType.getTypekind(),rawType.isRawType());
-        
-        ReferenceType genericType = (ReferenceType)rawType.getGenericType();
-        assertTrue("Should be the generic type ?!? "+genericType.getTypekind(),genericType.isGenericType());
-        
-        ResolvedType rt = rawType.getSuperclass();
-        assertTrue("Superclass for Map raw type should be Object but was "+rt,rt.equals(UnresolvedType.OBJECT));     
-        
-        ResolvedType rt2 = genericType.getSuperclass();
-        assertTrue("Superclass for Map generic type should be Object but was "+rt2,rt2.equals(UnresolvedType.OBJECT));       
-    }
-	
+
+	public void testGenericInterfaceSuperclass_ReflectionWorldResolution() {
+
+		UnresolvedType javaUtilMap = UnresolvedType.forName("java.util.Map");
+
+		ReferenceType rawType = (ReferenceType) world.resolve(javaUtilMap);
+		assertTrue("Should be the raw type ?!? " + rawType.getTypekind(), rawType.isRawType());
+
+		ReferenceType genericType = (ReferenceType) rawType.getGenericType();
+		assertTrue("Should be the generic type ?!? " + genericType.getTypekind(), genericType.isGenericType());
+
+		ResolvedType rt = rawType.getSuperclass();
+		assertTrue("Superclass for Map raw type should be Object but was " + rt, rt.equals(UnresolvedType.OBJECT));
+
+		ResolvedType rt2 = genericType.getSuperclass();
+		assertTrue("Superclass for Map generic type should be Object but was " + rt2, rt2.equals(UnresolvedType.OBJECT));
+	}
+
 }
\ No newline at end of file
@@ -814,11 +814,24 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 			// The component type might be a type variable (pr150095)
 			int dims = 1;
 			String sig = aType.getSignature();
-			while (sig.charAt(dims) == '[')
-				dims++;
+			// while (sig.charAt(dims) == '[')
+			// dims++;
+			UnresolvedType arrayType = null;
 			UnresolvedType componentSig = UnresolvedType.forSignature(sig.substring(dims));
-			UnresolvedType arrayType = ResolvedType.makeArray(parameterize(componentSig, typeVariableMap, inParameterizedType),
-					dims);
+			UnresolvedType parameterizedComponentSig = parameterize(componentSig, typeVariableMap, inParameterizedType);
+			if (parameterizedComponentSig.isTypeVariableReference()
+					&& parameterizedComponentSig instanceof UnresolvedTypeVariableReferenceType
+					&& typeVariableMap.containsKey(((UnresolvedTypeVariableReferenceType) parameterizedComponentSig)
+							.getTypeVariable().getName())) { // pr250632
+				// TODO ASC bah, this code is rubbish - i should fix it properly
+				StringBuffer newsig = new StringBuffer();
+				newsig.append("[T");
+				newsig.append(((UnresolvedTypeVariableReferenceType) parameterizedComponentSig).getTypeVariable().getName());
+				newsig.append(";");
+				arrayType = UnresolvedType.forSignature(newsig.toString());
+			} else {
+				arrayType = ResolvedType.makeArray(parameterizedComponentSig, dims);
+			}
 			return arrayType;
 		}
 		return aType;
@@ -0,0 +1,18 @@
+interface IMarker<CLOCK,STATE> { }
+
+public aspect MyAspect
+{
+
+       public void IMarker<CLOCK,STATE>.map()
+       {
+               CLOCK[] var = find();
+       };
+
+
+
+       public CLOCK[] IMarker<CLOCK,STATE>.find()
+       {
+               return null;
+       }
+
+}
@@ -18,6 +18,10 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc163Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testGenericMethodConversions_pr250632() {
+		runTest("type conversion in generic itd");
+	}
+
 	public void testGenericMethodBridging_pr250493() {
 		runTest("bridge methods for generic itds");
 	}
@@ -2,6 +2,11 @@
 
 <suite>
 
+
+    <ajc-test dir="bugs163/pr250632" title="type conversion in generic itd">
+      <compile files="MyAspect.java" options="-1.5"/>
+    </ajc-test>
+
     <ajc-test dir="bugs163/pr250493" title="bridge methods for generic itds">
       <compile files="Bridged.java" options="-1.5"/>
       <run class="Bridged">
