@@ -244,7 +244,7 @@ public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		LocalVariable[] lvt = m.getLocalVariableTable().getLocalVariableTable();
 		assertEquals(7, lvt.length); // no aroundClosure compared to second
 		// version of this test
-		assertEquals("LService; this(0) start=0 len=86", stringify(m.getLocalVariableTable(), 0));
+		assertEquals("LService; ajc$this(0) start=0 len=86", stringify(m.getLocalVariableTable(), 0));
 		assertEquals("J l(1) start=0 len=86", stringify(m.getLocalVariableTable(), 1));
 		assertEquals("Lorg/aspectj/lang/JoinPoint; thisJoinPoint(3) start=0 len=86", stringify(m.getLocalVariableTable(), 2));
 		assertEquals("LServiceInterceptor; ajc$aspectInstance(4) start=0 len=86", stringify(m.getLocalVariableTable(), 3));
@@ -266,7 +266,7 @@ public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		// private static final void method_aroundBody1$advice(Service, long,
 		// JoinPoint, ServiceInterceptorCodeStyle, AroundClosure,
 		// JoinPoint);
-		assertEquals("LService; this(0) start=0 len=68", stringify(m.getLocalVariableTable(), 0));
+		assertEquals("LService; ajc$this(0) start=0 len=68", stringify(m.getLocalVariableTable(), 0));
 		assertEquals("J l(1) start=0 len=68", stringify(m.getLocalVariableTable(), 1));
 		assertEquals("Lorg/aspectj/lang/JoinPoint; thisJoinPoint(3) start=0 len=68", stringify(m.getLocalVariableTable(), 2));
 		assertEquals("LServiceInterceptorCodeStyle; ajc$aspectInstance(4) start=0 len=68", stringify(m.getLocalVariableTable(), 3));
@@ -311,7 +311,7 @@ public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		lvt = m.getLocalVariableTable();
 		assertNotNull(lvt);
 
-		assertEquals("LC; this(0) start=0 len=0", stringify(lvt, 0));
+		assertEquals("LC; ajc$this(0) start=0 len=0", stringify(lvt, 0));
 		assertEquals("LI; target(1) start=0 len=0", stringify(lvt, 1));
 		assertEquals("Ljava/lang/String; s(2) start=0 len=0", stringify(lvt, 2));
 		assertEquals("I i(3) start=0 len=0", stringify(lvt, 3));
@@ -325,7 +325,7 @@ public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		lvt = m.getLocalVariableTable();
 		assertNotNull(lvt);
 
-		assertEquals("LC; this(0) start=0 len=0", stringify(lvt, 0));
+		assertEquals("LC; ajc$this(0) start=0 len=0", stringify(lvt, 0));
 		assertEquals("J l(1) start=0 len=0", stringify(lvt, 1));
 		assertEquals("I i(3) start=0 len=0", stringify(lvt, 2));
 		assertEquals("[Ljava/lang/String; ss(4) start=0 len=0", stringify(lvt, 3));
@@ -3150,7 +3150,7 @@ public class BcelShadow extends Shadow {
 
 		if (thisVar != null) {
 			UnresolvedType thisType = getThisType();
-			parameterNames.add(0, "this");
+			parameterNames.add(0, "ajc$this");
 			shadowParameterTypes = addTypeToFront(BcelWorld.makeBcelType(thisType), shadowParameterTypes);
 		}
 
@@ -3160,7 +3160,11 @@ public class BcelShadow extends Shadow {
 			String[] pnames = getSignature().getParameterNames(world);
 			if (pnames != null) {
 				for (int i = 0; i < pnames.length; i++) {
-					parameterNames.add(pnames[i]);
+					if (i == 0 && pnames[i].equals("this")) {
+						parameterNames.add("ajc$this");
+					} else {
+						parameterNames.add(pnames[i]);
+					}
 				}
 			}
 		}
@@ -10,7 +10,6 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.weaver.bcel;
 
 import java.util.Iterator;
@@ -32,56 +31,58 @@ import org.aspectj.weaver.Shadow;
 
 final class ShadowRange extends Range {
 
-    private BcelShadow shadow;
+	private BcelShadow shadow;
 
 	// ---- initialization
-	
+
 	/**
-	 * After this constructor is called, this range is not well situated unless both
-	 * {@link #associateWithTargets} and {@link #associateWithShadow} are called.
+	 * After this constructor is called, this range is not well situated unless both {@link #associateWithTargets} and
+	 * {@link #associateWithShadow} are called.
 	 */
 	public ShadowRange(InstructionList body) {
 		super(body);
 	}
+
 	protected void associateWithTargets(InstructionHandle start, InstructionHandle end) {
 		// assert body.contains(start) && body.contains(end);
 		this.start = start;
 		this.end = end;
 		start.addTargeter(this);
 		end.addTargeter(this);
-	}	
+	}
+
 	public void associateWithShadow(BcelShadow shadow) {
 		this.shadow = shadow;
 		shadow.setRange(this);
 	}
-	
+
 	// ----
 
-    public Shadow.Kind getKind() {
-        return shadow.getKind();
-    }
-    
-    public String toString() {
-        return shadow.toString();
-    }
+	public Shadow.Kind getKind() {
+		return shadow.getKind();
+	}
 
-    void extractInstructionsInto(LazyMethodGen freshMethod, IntMap remap, boolean addReturn) {
-    	LazyMethodGen.assertGoodBody(getBody(), toString());
-    	freshMethod.assertGoodBody();
-        InstructionList freshBody = freshMethod.getBody();
+	public String toString() {
+		return shadow.toString();
+	}
 
-        for (InstructionHandle oldIh = start.getNext(); oldIh != end; oldIh = oldIh.getNext()) {
-		    // first we copy the instruction itself.  
-            Instruction oldI = oldIh.getInstruction();
-            Instruction freshI = (oldI == RANGEINSTRUCTION) ? oldI : Utility.copyInstruction(oldI);
+	void extractInstructionsInto(LazyMethodGen freshMethod, IntMap remap, boolean addReturn) {
+		LazyMethodGen.assertGoodBody(getBody(), toString());
+		freshMethod.assertGoodBody();
+		InstructionList freshBody = freshMethod.getBody();
+
+		for (InstructionHandle oldIh = start.getNext(); oldIh != end; oldIh = oldIh.getNext()) {
+			// first we copy the instruction itself.
+			Instruction oldI = oldIh.getInstruction();
+			Instruction freshI = (oldI == RANGEINSTRUCTION) ? oldI : Utility.copyInstruction(oldI);
 
 			// Now we add it to the new instruction list.
-            InstructionHandle freshIh;
-            if (freshI instanceof InstructionBranch) {
-				//If it's a targeting instruction,
-	    		// update the target(s) to point to the new copy instead of the old copy.
-            	InstructionBranch oldBranch = (InstructionBranch) oldI;
-            	InstructionBranch freshBranch = (InstructionBranch) freshI;
+			InstructionHandle freshIh;
+			if (freshI instanceof InstructionBranch) {
+				// If it's a targeting instruction,
+				// update the target(s) to point to the new copy instead of the old copy.
+				InstructionBranch oldBranch = (InstructionBranch) oldI;
+				InstructionBranch freshBranch = (InstructionBranch) freshI;
 				InstructionHandle oldTarget = oldBranch.getTarget();
 				oldTarget.removeTargeter(oldBranch);
 				oldTarget.addTargeter(freshBranch);
@@ -94,154 +95,156 @@ final class ShadowRange extends Range {
 						oldTargets[k].addTargeter(freshSelect);
 					}
 				}
-            	freshIh = freshBody.append(freshBranch);
-            } else {
-                freshIh = freshBody.append(freshI); 
-            }
-
-				// if source comes before target:
-				// source <--> target
-				//		-->  [process: target.removeTargeter(source); target.addTargeter(sourcecopy)]
-				// source ---------\
-				//			        v
-				// sourcecopy <--> target
-				//      --> [ process: sourcecopy.updateTarget(target, targetcopy) ]
-				// source ----> target
-				// sourcecopy <--> targetcopy
-				
-				// if target comes before source
-				
-				// target <--> source
-				//  --> [process: source.updateTarget(target, targetcopy) ]
-				// target 
-				// targetcopy <--> source
-				//  --> [process: targetcopy.removeTargeter(source); targetcopy.addTargeter(sourcecopy)]
-				// target source
-				//	        v
-				// targetcopy <--> sourcecopy
-			
-			// now deal with the old instruction's targeters.  Update them all to point to us 
-			// instead of the old instruction.  We use updateTarget to do this.  One goal is
+				freshIh = freshBody.append(freshBranch);
+			} else {
+				freshIh = freshBody.append(freshI);
+			}
+
+			// if source comes before target:
+			// source <--> target
+			// --> [process: target.removeTargeter(source); target.addTargeter(sourcecopy)]
+			// source ---------\
+			// v
+			// sourcecopy <--> target
+			// --> [ process: sourcecopy.updateTarget(target, targetcopy) ]
+			// source ----> target
+			// sourcecopy <--> targetcopy
+
+			// if target comes before source
+
+			// target <--> source
+			// --> [process: source.updateTarget(target, targetcopy) ]
+			// target
+			// targetcopy <--> source
+			// --> [process: targetcopy.removeTargeter(source); targetcopy.addTargeter(sourcecopy)]
+			// target source
+			// v
+			// targetcopy <--> sourcecopy
+
+			// now deal with the old instruction's targeters. Update them all to point to us
+			// instead of the old instruction. We use updateTarget to do this. One goal is
 			// to make sure we remove all targeters from the old guy, so we can successfully
 			// delete it.
-            InstructionTargeter[] sources = oldIh.getTargetersArray();
-            if (sources != null) {
-                for (int j = sources.length - 1; j >= 0; j--) {
-                    InstructionTargeter source = sources[j];
-                    if (source instanceof LocalVariableTag) {
-                    	Shadow.Kind kind = getKind();
-                    	if (kind == Shadow.AdviceExecution ||
-                    		kind == Shadow.ConstructorExecution ||
-                    		kind == Shadow.MethodExecution ||
-                    		kind == Shadow.PreInitialization ||
-                    		kind == Shadow.Initialization ||
-                    		kind == Shadow.StaticInitialization) {
-                    		// if we're extracting a whole block we can do this...
-                    		source.updateTarget(oldIh, freshIh);
-                    	} else {
-                            // XXX destroying local variable info
-                    		// but only for a call or get join point, so no big deal
-                    		source.updateTarget(oldIh, null);
-                    	}
-                    } else if (source instanceof Range) {
-                        // exceptions and shadows are just moved
-                        ((Range)source).updateTarget(oldIh, freshIh, freshBody);
-                    } else {
-                        // line numbers can be shared,
-                        // branches will be copied along with us.
-                        source.updateTarget(oldIh, freshIh);
-                    }
-                }
-            }
+			InstructionTargeter[] sources = oldIh.getTargetersArray();
+			if (sources != null) {
+				for (int j = sources.length - 1; j >= 0; j--) {
+					InstructionTargeter source = sources[j];
+					if (source instanceof LocalVariableTag) {
+						Shadow.Kind kind = getKind();
+						if (kind == Shadow.AdviceExecution || kind == Shadow.ConstructorExecution || kind == Shadow.MethodExecution
+								|| kind == Shadow.PreInitialization || kind == Shadow.Initialization
+								|| kind == Shadow.StaticInitialization) {
+							LocalVariableTag sourceLocalVariableTag = (LocalVariableTag) source;
+							if (sourceLocalVariableTag.getSlot() == 0) {
+								// might be 'this' so should be renamed if being dumped in a static method 277616
+								if (sourceLocalVariableTag.getName().equals("this")) {
+									sourceLocalVariableTag.setName("ajc$this");
+								}
+							}
+							// if we're extracting a whole block we can do this...
+							source.updateTarget(oldIh, freshIh);
+						} else {
+							// XXX destroying local variable info
+							// but only for a call or get join point, so no big deal
+							source.updateTarget(oldIh, null);
+						}
+					} else if (source instanceof Range) {
+						// exceptions and shadows are just moved
+						((Range) source).updateTarget(oldIh, freshIh, freshBody);
+					} else {
+						// line numbers can be shared,
+						// branches will be copied along with us.
+						source.updateTarget(oldIh, freshIh);
+					}
+				}
+			}
 			// we're now done with the old instruction entirely, and will ignore them through
-			// the rest of this loop.  The only time we'll see them again is a second pass to
+			// the rest of this loop. The only time we'll see them again is a second pass to
 			// delete them.
-			
-			// now deal with local variable instructions.  If this points to a remapped 
-			// frame location, update the instruction's index.  If this doesn't, 
+
+			// now deal with local variable instructions. If this points to a remapped
+			// frame location, update the instruction's index. If this doesn't,
 			// do compaction/expansion: allocate a new local variable, and modify the remap
-			// to handle it.  XXX We're doing the safe thing and allocating ALL these local variables
+			// to handle it. XXX We're doing the safe thing and allocating ALL these local variables
 			// as double-wides, in case the location is found to hold a double-wide later.
-            if (freshI.isLocalVariableInstruction() || freshI instanceof RET) {
-//            	IndexedInstruction indexedI = (IndexedInstruction) freshI;
-                int oldIndex = freshI.getIndex();
-            	int freshIndex;
-                if (! remap.hasKey(oldIndex)) {
-                    freshIndex = freshMethod.allocateLocal(2);
-                    remap.put(oldIndex, freshIndex);
-                } else {
-                    freshIndex = remap.get(oldIndex);
-                }
-                if (freshI instanceof RET) {
-                	freshI.setIndex(freshIndex);
-                } else {
-                    freshI = ((InstructionLV)freshI).setIndexAndCopyIfNecessary(freshIndex);
-                    freshIh.setInstruction(freshI);
-                }
-            }
-//            System.err.println("JUST COPIED: " + oldIh.getInstruction().toString(freshMethod.getEnclosingClass().getConstantPoolGen().getConstantPool()) 
-//            	+ " INTO " + freshIh.getInstruction().toString(freshMethod.getEnclosingClass().getConstantPoolGen().getConstantPool()));
-        }
-        
-        // now go through again and update variable slots that have been altered as a result
-        // of remapping...
-        for (InstructionHandle newIh = freshBody.getStart(); newIh != freshBody.getEnd(); newIh = newIh.getNext()) {
-        	Iterator tIter = newIh.getTargeters().iterator();
-        	while (tIter.hasNext()) {
-        			InstructionTargeter source = (InstructionTargeter)tIter.next();
-                    if (source instanceof LocalVariableTag) {
-                    	LocalVariableTag lvt = (LocalVariableTag) source;
-                    	if (!lvt.isRemapped() && remap.hasKey(lvt.getSlot())) {
-                    		lvt.updateSlot(remap.get(lvt.getSlot()));                    		
-                    	}
-                    }
-            }
-        }
-       
-        
-        
+			if (freshI.isLocalVariableInstruction() || freshI instanceof RET) {
+				// IndexedInstruction indexedI = (IndexedInstruction) freshI;
+				int oldIndex = freshI.getIndex();
+				int freshIndex;
+				if (!remap.hasKey(oldIndex)) {
+					freshIndex = freshMethod.allocateLocal(2);
+					remap.put(oldIndex, freshIndex);
+				} else {
+					freshIndex = remap.get(oldIndex);
+				}
+				if (freshI instanceof RET) {
+					freshI.setIndex(freshIndex);
+				} else {
+					freshI = ((InstructionLV) freshI).setIndexAndCopyIfNecessary(freshIndex);
+					freshIh.setInstruction(freshI);
+				}
+			}
+			// System.err.println("JUST COPIED: " +
+			// oldIh.getInstruction().toString(freshMethod.getEnclosingClass().getConstantPoolGen().getConstantPool())
+			// + " INTO " +
+			// freshIh.getInstruction().toString(freshMethod.getEnclosingClass().getConstantPoolGen().getConstantPool()));
+		}
+
+		// now go through again and update variable slots that have been altered as a result
+		// of remapping...
+		for (InstructionHandle newIh = freshBody.getStart(); newIh != freshBody.getEnd(); newIh = newIh.getNext()) {
+			Iterator tIter = newIh.getTargeters().iterator();
+			while (tIter.hasNext()) {
+				InstructionTargeter source = (InstructionTargeter) tIter.next();
+				if (source instanceof LocalVariableTag) {
+					LocalVariableTag lvt = (LocalVariableTag) source;
+					if (!lvt.isRemapped() && remap.hasKey(lvt.getSlot())) {
+						lvt.updateSlot(remap.get(lvt.getSlot()));
+					}
+				}
+			}
+		}
 
 		// we've now copied out all the instructions.
-        // now delete the instructions... we've already taken care of the damn
-        // targets, but since TargetLostException is checked, we have to do this stuff.
-        try {
-            for (InstructionHandle oldIh = start.getNext(); oldIh != end; ) {
-                InstructionHandle next = oldIh.getNext();
-                body.delete(oldIh);
-                oldIh = next;
-            }
-        } catch (TargetLostException e) {
-            throw new BCException("shouldn't have gotten a target lost");
-        }
-        
-        // now add the return, if one is warranted.  
-        InstructionHandle ret = null;
-        if (addReturn) {
-            // we really should pull this out somewhere...
-            ret = freshBody.append(
-                InstructionFactory.createReturn(freshMethod.getReturnType()));
-        }
+		// now delete the instructions... we've already taken care of the damn
+		// targets, but since TargetLostException is checked, we have to do this stuff.
+		try {
+			for (InstructionHandle oldIh = start.getNext(); oldIh != end;) {
+				InstructionHandle next = oldIh.getNext();
+				body.delete(oldIh);
+				oldIh = next;
+			}
+		} catch (TargetLostException e) {
+			throw new BCException("shouldn't have gotten a target lost");
+		}
+
+		// now add the return, if one is warranted.
+		InstructionHandle ret = null;
+		if (addReturn) {
+			// we really should pull this out somewhere...
+			ret = freshBody.append(InstructionFactory.createReturn(freshMethod.getReturnType()));
+		}
 		// and remap all the old targeters of the end handle of the range to the return.
-        InstructionTargeter[] ts = end.getTargetersArray();
-        if (ts != null) {  // shouldn't be the case, but let's test for paranoia
-            for (int j = ts.length - 1; j >= 0; j--) {
-                InstructionTargeter t = ts[j];
-                if (t == this) continue;
-                if (! addReturn) {
-                    throw new BCException("range has target, but we aren't adding a return");
-                } else {
-                    t.updateTarget(end, ret);
-                }
-            }
-        }
-
-    	LazyMethodGen.assertGoodBody(getBody(), toString());
-    	freshMethod.assertGoodBody();
-    }
+		InstructionTargeter[] ts = end.getTargetersArray();
+		if (ts != null) { // shouldn't be the case, but let's test for paranoia
+			for (int j = ts.length - 1; j >= 0; j--) {
+				InstructionTargeter t = ts[j];
+				if (t == this)
+					continue;
+				if (!addReturn) {
+					throw new BCException("range has target, but we aren't adding a return");
+				} else {
+					t.updateTarget(end, ret);
+				}
+			}
+		}
+
+		LazyMethodGen.assertGoodBody(getBody(), toString());
+		freshMethod.assertGoodBody();
+	}
 
 	public BcelShadow getShadow() {
 		return shadow;
 	}
 
-
 }
@@ -11,67 +11,84 @@
  *   Andy Clement   pushed down into bcel module
  * ******************************************************************/
 
-
 package org.aspectj.apache.bcel.generic;
 
 public final class LocalVariableTag extends Tag {
 	private Type type; // not always known, in which case signature has to be used
-    private final String signature;
-    private final String name;
-    private int slot;
-    private final int startPos;
-    boolean remapped = false;
+	private final String signature;
+	private String name;
+	private int slot;
+	private final int startPos;
+	boolean remapped = false;
+
+	// AMC - pr101047, two local vars with the same name can share the same slot, but must in that case
+	// have different start positions.
+	public LocalVariableTag(String sig, String name, int slot, int startPosition) {
+		this.signature = sig;
+		this.name = name;
+		this.slot = slot;
+		this.startPos = startPosition;
+	}
+
+	public LocalVariableTag(Type t, String sig, String name, int slot, int startPosition) {
+		this.type = t;
+		this.signature = sig;
+		this.name = name;
+		this.slot = slot;
+		this.startPos = startPosition;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public int getSlot() {
+		return slot;
+	}
+
+	public String getType() {
+		return signature;
+	}
+
+	public Type getRealType() {
+		return type;
+	}
+
+	public void updateSlot(int newSlot) {
+		this.slot = newSlot;
+		this.remapped = true;
+	}
+
+	public boolean isRemapped() {
+		return this.remapped;
+	}
+
+	public String toString() {
+		return "local " + slot + ": " + signature + " " + name;
+	}
 
-    // AMC - pr101047, two local vars with the same name can share the same slot, but must in that case
-    // have different start positions.
-    public LocalVariableTag(String sig, String name, int slot, int startPosition) {
-        this.signature = sig;
-        this.name = name;
-        this.slot = slot;
-        this.startPos = startPosition;
-    }
-    
-    public LocalVariableTag(Type t,String sig, String name, int slot, int startPosition) {
-    	this.type = t;
-        this.signature = sig;
-        this.name = name;
-        this.slot = slot;
-        this.startPos = startPosition;
-    }
+	public boolean equals(Object other) {
+		if (!(other instanceof LocalVariableTag))
+			return false;
+		LocalVariableTag o = (LocalVariableTag) other;
+		return o.slot == slot && o.startPos == startPos && o.signature.equals(signature) && o.name.equals(name);
+	}
 
+	public void setName(String name) {
+		this.name = name;
+	}
 
-    public String getName()   {return name;}
-    public int getSlot()      {return slot;}
-    public String getType()   {return signature;}
-    public Type getRealType() {return type;}
-    
-    public void updateSlot(int newSlot) {
-    	this.slot = newSlot;
-    	this.remapped = true;
-    }
-    
-    public boolean isRemapped() { return this.remapped; }
-    
-    public String toString() {
-        return "local " + slot + ": " + signature + " " + name;
-    }
+	private int hashCode = 0;
 
-    public boolean equals(Object other) {
-        if (!(other instanceof LocalVariableTag)) return false;
-        LocalVariableTag o = (LocalVariableTag)other;
-        return o.slot == slot && o.startPos == startPos && o.signature.equals(signature) && o.name.equals(name); 
-    }
-    
-    private int hashCode = 0;
-    public int hashCode() {
-        if (hashCode == 0) {
-            int ret = 17;
-            ret = 37*ret + signature.hashCode();
-            ret = 37*ret + name.hashCode();
-            ret = 37*ret + slot;
-            ret = 37*ret + startPos;
-            hashCode = ret;
-        }
-        return hashCode;
-    }
+	public int hashCode() {
+		if (hashCode == 0) {
+			int ret = 17;
+			ret = 37 * ret + signature.hashCode();
+			ret = 37 * ret + name.hashCode();
+			ret = 37 * ret + slot;
+			ret = 37 * ret + startPos;
+			hashCode = ret;
+		}
+		return hashCode;
+	}
 }
Binary files differ
Binary files differ
Binary files differ
