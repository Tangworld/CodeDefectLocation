@@ -0,0 +1,31 @@
+public class Test {
+
+  public static void main(String[] argv) {
+    new Foo();
+  }
+
+}
+
+interface I {}
+
+abstract class AbstractFoo implements I {
+
+  String f;
+
+  AbstractFoo() {
+  }
+}
+
+class Foo extends AbstractFoo {
+
+  Foo() {
+    super();
+    f = "hello";
+  }
+}
+
+aspect X {
+
+ void around(): target(I) && set(* *) { proceed(); }
+
+}
@@ -18,7 +18,8 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc161Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
-	// AspectJ1.6.0rc1
+	// AspectJ1.6.1
+    public void testAroundAdviceOnFieldSet_pr229910() { runTest("around advice on field set"); }
     public void testPipelineCompilationGenericReturnType_pr226567() { runTest("pipeline compilation and generic return type"); }
 
     public static Test suite() {
@@ -3,9 +3,15 @@
 <!-- AspectJ v1.6.1 Tests -->
 <suite>
 
+    <ajc-test dir="bugs161/pr229910" title="around advice on field set">
+        <compile files="Test.java" options="-1.5"/>
+        <run class="Test"/>
+    </ajc-test>
+    
     <ajc-test dir="bugs161/pr226567" title="pipeline compilation and generic return type">
         <compile files="BarAspect.aj Foo.java Bar.java" options="-1.5"/>
         <compile files="BarAspect.aj Bar.java Foo.java" options="-1.5"/>
     </ajc-test>
+    
 
 </suite>
\ No newline at end of file
@@ -3460,12 +3460,12 @@ public class BcelShadow extends Shadow {
         if (targetVar != null && targetVar != thisVar) {
             UnresolvedType targetType = getTargetType();
             targetType = ensureTargetTypeIsCorrect(targetType);
-            // see pr109728 - this fixes the case when the declaring class is sometype 'X' but the getfield
+            // see pr109728,pr229910 - this fixes the case when the declaring class is sometype 'X' but the (gs)etfield
             // in the bytecode refers to a subtype of 'X'.  This makes sure we use the type originally
             // mentioned in the fieldget instruction as the method parameter and *not* the type upon which the
             // field is declared because when the instructions are extracted into the new around body,
             // they will still refer to the subtype.
-            if (getKind()==FieldGet && getActualTargetType()!=null && 
+            if ((getKind()==FieldGet || getKind()==FieldSet) && getActualTargetType()!=null && 
             	!getActualTargetType().equals(targetType.getName())) {
         		targetType =  UnresolvedType.forName(getActualTargetType()).resolve(world);
         	}
