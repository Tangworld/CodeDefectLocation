@@ -320,6 +320,7 @@ public class AjcTask extends MatchingTask {
 	private Path extdirs;
 	private Path aspectpath;
 	private Path argfiles;
+	private Path inxmlfiles;
 	private List ignored;
 	private Path sourceRoots;
 	private File xweaveDir;
@@ -390,6 +391,7 @@ public class AjcTask extends MatchingTask {
 		adapterArguments = null;
 		adapterFiles = new ArrayList();
 		argfiles = null;
+		inxmlfiles= null;
 		executing = false;
 		aspectpath = null;
 		bootclasspath = null;
@@ -994,6 +996,21 @@ public class AjcTask extends MatchingTask {
 		return argfiles.createPath();
 	}
 
+	public void setInxmlref(Reference ref) {
+		createArgfiles().setRefid(ref);
+	}
+
+	public void setInxml(Path path) { // ajc-only eajc-also docDone
+		inxmlfiles = incPath(inxmlfiles, path);
+	}
+
+	public Path createInxml() {
+		if (inxmlfiles == null) {
+			inxmlfiles = new Path(project);
+		}
+		return inxmlfiles.createPath();
+	}
+
 	// ------------------------------ run
 
 	/**
@@ -1437,6 +1454,16 @@ public class AjcTask extends MatchingTask {
 				}
 			}
 		}
+		if (inxmlfiles != null) {
+			String[] files = inxmlfiles.list();
+			for (int i = 0; i < files.length; i++) {
+				File inxmlfile = project.resolveFile(files[i]);
+				if (check(inxmlfile, files[i], false, location)) {
+					list.add("-xmlConfigured");
+					list.add(inxmlfile.getAbsolutePath());
+				}
+			}
+		}
 		if (srcdir != null) {
 			// todo: ignore any srcdir if any argfiles and no explicit includes
 			String[] dirs = srcdir.list();
@@ -16,9 +16,14 @@ import java.io.DataOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Map;
+import java.util.Set;
 
+import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
+import org.aspectj.bridge.MessageUtil;
 import org.aspectj.bridge.SourceLocation;
 import org.aspectj.util.PartialOrder;
 import org.aspectj.weaver.patterns.PerClause;
@@ -67,7 +72,7 @@ public abstract class ShadowMunger implements PartialOrder.PartialComparable, IH
 		this.end = end;
 		this.sourceContext = sourceContext;
 	}
-
+	
 	/**
 	 * All overriding methods should call super
 	 */
@@ -75,8 +80,24 @@ public abstract class ShadowMunger implements PartialOrder.PartialComparable, IH
 		if (world.isXmlConfigured() && world.isAspectIncluded(declaringType)) {
 			TypePattern scoped = world.getAspectScope(declaringType);
 			if (scoped != null) {
-				boolean b = scoped.matches(shadow.getEnclosingType().resolve(world), TypePattern.STATIC).alwaysTrue();
+				// Check the 'cached' exclusion map 
+				Set<ResolvedType> excludedTypes = world.getExclusionMap().get(declaringType);
+				ResolvedType type = shadow.getEnclosingType().resolve(world);
+				if (excludedTypes!=null && excludedTypes.contains(type)) {
+					return false;
+				}
+				boolean b = scoped.matches(type, TypePattern.STATIC).alwaysTrue();
 				if (!b) {
+					if (!world.getMessageHandler().isIgnoring(IMessage.INFO)) {
+						world.getMessageHandler().handleMessage(MessageUtil.info("Type '"+type.getName()+"' not woven by aspect '"+declaringType.getName()+"' due to scope exclusion in XML definition"));
+					}
+					if (excludedTypes==null) {
+						excludedTypes = new HashSet<ResolvedType>();
+						excludedTypes.add(type);
+						world.getExclusionMap().put(declaringType,excludedTypes);
+					} else {
+						excludedTypes.add(type);
+					}					
 					return false;
 				}
 			}
@@ -1396,5 +1396,15 @@ public abstract class World implements Dump.INode {
 	protected boolean isExpendable(ResolvedType type) {
 		return (!type.equals(UnresolvedType.OBJECT) && (!type.isExposedToWeaver()) && (!type.isPrimitiveType()));
 	}
+	
+
+	// map from aspect > excluded types
+	// memory issue here?
+	private Map<ResolvedType,Set<ResolvedType>> exclusionMap = new HashMap<ResolvedType,Set<ResolvedType>>();
+
+
+	public Map<ResolvedType,Set<ResolvedType>> getExclusionMap() {
+		return exclusionMap;
+	}
 
 }
\ No newline at end of file
@@ -15,8 +15,8 @@ import java.util.Iterator;
 import java.util.List;
 
 import org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;
-import org.aspectj.apache.bcel.classfile.annotation.ElementNameValuePairGen;
-import org.aspectj.apache.bcel.classfile.annotation.EnumElementValueGen;
+import org.aspectj.apache.bcel.classfile.annotation.NameValuePair;
+import org.aspectj.apache.bcel.classfile.annotation.EnumElementValue;
 import org.aspectj.apache.bcel.generic.InstructionFactory;
 import org.aspectj.apache.bcel.generic.InstructionList;
 import org.aspectj.apache.bcel.generic.Type;
@@ -61,8 +61,8 @@ class AnnotationAccessFieldVar extends BcelVar {
 				List vals = annotation.getValues();
 				boolean doneAndDusted = false;
 				for (Iterator iterator = vals.iterator(); iterator.hasNext();) {
-					ElementNameValuePairGen object = (ElementNameValuePairGen) iterator.next();
-					EnumElementValueGen v = (EnumElementValueGen) object.getValue();
+					NameValuePair object = (NameValuePair) iterator.next();
+					EnumElementValue v = (EnumElementValue) object.getValue();
 					String s = v.getEnumTypeString();
 					ResolvedType rt = toType.getWorld().resolve(UnresolvedType.forSignature(s));
 					if (rt.equals(toType)) {
@@ -30,12 +30,12 @@ import org.aspectj.apache.bcel.classfile.LocalVariable;
 import org.aspectj.apache.bcel.classfile.LocalVariableTable;
 import org.aspectj.apache.bcel.classfile.Method;
 import org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;
-import org.aspectj.apache.bcel.classfile.annotation.ArrayElementValueGen;
-import org.aspectj.apache.bcel.classfile.annotation.ClassElementValueGen;
-import org.aspectj.apache.bcel.classfile.annotation.ElementNameValuePairGen;
-import org.aspectj.apache.bcel.classfile.annotation.ElementValueGen;
-import org.aspectj.apache.bcel.classfile.annotation.RuntimeAnnotations;
-import org.aspectj.apache.bcel.classfile.annotation.RuntimeVisibleAnnotations;
+import org.aspectj.apache.bcel.classfile.annotation.ArrayElementValue;
+import org.aspectj.apache.bcel.classfile.annotation.ClassElementValue;
+import org.aspectj.apache.bcel.classfile.annotation.NameValuePair;
+import org.aspectj.apache.bcel.classfile.annotation.ElementValue;
+import org.aspectj.apache.bcel.classfile.annotation.RuntimeAnnos;
+import org.aspectj.apache.bcel.classfile.annotation.RuntimeVisAnnos;
 import org.aspectj.apache.bcel.generic.Type;
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IHierarchy;
@@ -173,7 +173,7 @@ public class AtAjAttributes {
 	 * @return true if runtime visible annotation
 	 */
 	public static boolean acceptAttribute(Attribute attribute) {
-		return (attribute instanceof RuntimeVisibleAnnotations);
+		return (attribute instanceof RuntimeVisAnnos);
 	}
 
 	/**
@@ -226,7 +226,7 @@ public class AtAjAttributes {
 		for (int i = 0; i < attributes.length; i++) {
 			Attribute attribute = attributes[i];
 			if (acceptAttribute(attribute)) {
-				RuntimeAnnotations rvs = (RuntimeAnnotations) attribute;
+				RuntimeAnnos rvs = (RuntimeAnnos) attribute;
 				// we don't need to look for several attribute occurrences since
 				// it cannot happen as per JSR175
 				if (!isCodeStyleAspect && !javaClass.isInterface()) {
@@ -306,9 +306,9 @@ public class AtAjAttributes {
 					// through all the annotations every time
 					// same for fields
 					mstruct = new AjAttributeMethodStruct(method, null, type, context, msgHandler);
-					processedPointcut = handlePointcutAnnotation((RuntimeAnnotations) mattribute, mstruct);
+					processedPointcut = handlePointcutAnnotation((RuntimeAnnos) mattribute, mstruct);
 					if (!processedPointcut) {
-						processedPointcut = handleDeclareMixinAnnotation((RuntimeAnnotations) mattribute, mstruct);
+						processedPointcut = handleDeclareMixinAnnotation((RuntimeAnnos) mattribute, mstruct);
 					}
 					// there can only be one RuntimeVisible bytecode attribute
 					break;
@@ -337,7 +337,7 @@ public class AtAjAttributes {
 			for (int j = 0; j < fattributes.length; j++) {
 				Attribute fattribute = fattributes[j];
 				if (acceptAttribute(fattribute)) {
-					RuntimeAnnotations frvs = (RuntimeAnnotations) fattribute;
+					RuntimeAnnos frvs = (RuntimeAnnos) fattribute;
 					if (handleDeclareErrorOrWarningAnnotation(model, frvs, fstruct)
 							|| handleDeclareParentsAnnotation(frvs, fstruct)) {
 						// semantic check - must be in an @Aspect [remove if
@@ -392,7 +392,7 @@ public class AtAjAttributes {
 			Attribute attribute = attributes[i];
 			try {
 				if (acceptAttribute(attribute)) {
-					RuntimeAnnotations rvs = (RuntimeAnnotations) attribute;
+					RuntimeAnnos rvs = (RuntimeAnnos) attribute;
 					hasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid
 							|| handleBeforeAnnotation(rvs, struct, preResolvedPointcut);
 					hasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid
@@ -478,7 +478,7 @@ public class AtAjAttributes {
 	 * @param struct
 	 * @return true if found
 	 */
-	private static boolean handleAspectAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeStruct struct) {
+	private static boolean handleAspectAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeStruct struct) {
 		AnnotationGen aspect = getAnnotation(runtimeAnnotations, AjcMemberMaker.ASPECT_ANNOTATION);
 		if (aspect != null) {
 			// semantic check for inheritance (only one level up)
@@ -491,7 +491,7 @@ public class AtAjAttributes {
 				extendsAspect = struct.enclosingType.getSuperclass().isAspect();
 			}
 
-			ElementNameValuePairGen aspectPerClause = getAnnotationElement(aspect, VALUE);
+			NameValuePair aspectPerClause = getAnnotationElement(aspect, VALUE);
 			final PerClause perClause;
 			if (aspectPerClause == null) {
 				// empty value means singleton unless inherited
@@ -598,10 +598,10 @@ public class AtAjAttributes {
 	 * @param struct
 	 * @return true if found
 	 */
-	private static boolean handlePrecedenceAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeStruct struct) {
+	private static boolean handlePrecedenceAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeStruct struct) {
 		AnnotationGen aspect = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREPRECEDENCE_ANNOTATION);
 		if (aspect != null) {
-			ElementNameValuePairGen precedence = getAnnotationElement(aspect, VALUE);
+			NameValuePair precedence = getAnnotationElement(aspect, VALUE);
 			if (precedence != null) {
 				String precedencePattern = precedence.getValue().stringifyValue();
 				PatternParser parser = new PatternParser(precedencePattern);
@@ -671,13 +671,13 @@ public class AtAjAttributes {
 	 * @param struct
 	 * @return true if found
 	 */
-	private static boolean handleDeclareParentsAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeFieldStruct struct) {// ,
+	private static boolean handleDeclareParentsAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeFieldStruct struct) {// ,
 		// ResolvedPointcutDefinition
 		// preResolvedPointcut)
 		// {
 		AnnotationGen decp = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREPARENTS_ANNOTATION);
 		if (decp != null) {
-			ElementNameValuePairGen decpPatternNVP = getAnnotationElement(decp, VALUE);
+			NameValuePair decpPatternNVP = getAnnotationElement(decp, VALUE);
 			String decpPattern = decpPatternNVP.getValue().stringifyValue();
 			if (decpPattern != null) {
 				TypePattern typePattern = parseTypePattern(decpPattern, struct);
@@ -710,9 +710,9 @@ public class AtAjAttributes {
 
 					// do we have a defaultImpl=xxx.class (ie implementation)
 					String defaultImplClassName = null;
-					ElementNameValuePairGen defaultImplNVP = getAnnotationElement(decp, "defaultImpl");
+					NameValuePair defaultImplNVP = getAnnotationElement(decp, "defaultImpl");
 					if (defaultImplNVP != null) {
-						ClassElementValueGen defaultImpl = (ClassElementValueGen) defaultImplNVP.getValue();
+						ClassElementValue defaultImpl = (ClassElementValue) defaultImplNVP.getValue();
 						defaultImplClassName = UnresolvedType.forSignature(defaultImpl.getClassString()).getName();
 						if (defaultImplClassName.equals("org.aspectj.lang.annotation.DeclareParents")) {
 							defaultImplClassName = null;
@@ -863,7 +863,7 @@ public class AtAjAttributes {
 	 * @param struct
 	 * @return true if found
 	 */
-	private static boolean handleDeclareMixinAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct) {
+	private static boolean handleDeclareMixinAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct) {
 		AnnotationGen declareMixinAnnotation = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREMIXIN_ANNOTATION);
 		if (declareMixinAnnotation == null) {
 			// No annotation found
@@ -872,7 +872,7 @@ public class AtAjAttributes {
 
 		Method annotatedMethod = struct.method;
 		World world = struct.enclosingType.getWorld();
-		ElementNameValuePairGen declareMixinPatternNameValuePair = getAnnotationElement(declareMixinAnnotation, VALUE);
+		NameValuePair declareMixinPatternNameValuePair = getAnnotationElement(declareMixinAnnotation, VALUE);
 
 		// declareMixinPattern could be of the form "Bar*" or "A || B" or "Foo+"
 		String declareMixinPattern = declareMixinPatternNameValuePair.getValue().stringifyValue();
@@ -896,16 +896,16 @@ public class AtAjAttributes {
 		// supplied as a list in the 'Class[] interfaces' value in the annotation value
 		// supplied as just the interface return value of the annotated method
 		// supplied as just the class return value of the annotated method
-		ElementNameValuePairGen interfaceListSpecified = getAnnotationElement(declareMixinAnnotation, "interfaces");
+		NameValuePair interfaceListSpecified = getAnnotationElement(declareMixinAnnotation, "interfaces");
 
 		List<TypePattern> newParents = new ArrayList<TypePattern>(1);
 		List<ResolvedType> newInterfaceTypes = new ArrayList<ResolvedType>(1);
 		if (interfaceListSpecified != null) {
-			ArrayElementValueGen arrayOfInterfaceTypes = (ArrayElementValueGen) interfaceListSpecified.getValue();
+			ArrayElementValue arrayOfInterfaceTypes = (ArrayElementValue) interfaceListSpecified.getValue();
 			int numberOfTypes = arrayOfInterfaceTypes.getElementValuesArraySize();
-			ElementValueGen[] theTypes = arrayOfInterfaceTypes.getElementValuesArray();
+			ElementValue[] theTypes = arrayOfInterfaceTypes.getElementValuesArray();
 			for (int i = 0; i < numberOfTypes; i++) {
-				ClassElementValueGen interfaceType = (ClassElementValueGen) theTypes[i];
+				ClassElementValue interfaceType = (ClassElementValue) theTypes[i];
 				// Check: needs to be resolvable
 				// TODO crappy replace required
 				ResolvedType ajInterfaceType = UnresolvedType.forSignature(interfaceType.getClassString().replace("/", "."))
@@ -995,11 +995,11 @@ public class AtAjAttributes {
 	 * @param struct
 	 * @return true if found
 	 */
-	private static boolean handleBeforeAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct,
+	private static boolean handleBeforeAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct,
 			ResolvedPointcutDefinition preResolvedPointcut) {
 		AnnotationGen before = getAnnotation(runtimeAnnotations, AjcMemberMaker.BEFORE_ANNOTATION);
 		if (before != null) {
-			ElementNameValuePairGen beforeAdvice = getAnnotationElement(before, VALUE);
+			NameValuePair beforeAdvice = getAnnotationElement(before, VALUE);
 			if (beforeAdvice != null) {
 				// this/target/args binding
 				String argumentNames = getArgNamesValue(before);
@@ -1047,11 +1047,11 @@ public class AtAjAttributes {
 	 * @param struct
 	 * @return true if found
 	 */
-	private static boolean handleAfterAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct,
+	private static boolean handleAfterAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct,
 			ResolvedPointcutDefinition preResolvedPointcut) {
 		AnnotationGen after = getAnnotation(runtimeAnnotations, AjcMemberMaker.AFTER_ANNOTATION);
 		if (after != null) {
-			ElementNameValuePairGen afterAdvice = getAnnotationElement(after, VALUE);
+			NameValuePair afterAdvice = getAnnotationElement(after, VALUE);
 			if (afterAdvice != null) {
 				// this/target/args binding
 				FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
@@ -1098,14 +1098,14 @@ public class AtAjAttributes {
 	 * @param struct
 	 * @return true if found
 	 */
-	private static boolean handleAfterReturningAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct,
+	private static boolean handleAfterReturningAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct,
 			ResolvedPointcutDefinition preResolvedPointcut, BcelMethod owningMethod)
 			throws ReturningFormalNotDeclaredInAdviceSignatureException {
 		AnnotationGen after = getAnnotation(runtimeAnnotations, AjcMemberMaker.AFTERRETURNING_ANNOTATION);
 		if (after != null) {
-			ElementNameValuePairGen annValue = getAnnotationElement(after, VALUE);
-			ElementNameValuePairGen annPointcut = getAnnotationElement(after, POINTCUT);
-			ElementNameValuePairGen annReturned = getAnnotationElement(after, RETURNING);
+			NameValuePair annValue = getAnnotationElement(after, VALUE);
+			NameValuePair annPointcut = getAnnotationElement(after, POINTCUT);
+			NameValuePair annReturned = getAnnotationElement(after, RETURNING);
 
 			// extract the pointcut and returned type/binding - do some checks
 			String pointcut = null;
@@ -1187,14 +1187,14 @@ public class AtAjAttributes {
 	 * @param struct
 	 * @return true if found
 	 */
-	private static boolean handleAfterThrowingAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct,
+	private static boolean handleAfterThrowingAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct,
 			ResolvedPointcutDefinition preResolvedPointcut, BcelMethod owningMethod)
 			throws ThrownFormalNotDeclaredInAdviceSignatureException {
 		AnnotationGen after = getAnnotation(runtimeAnnotations, AjcMemberMaker.AFTERTHROWING_ANNOTATION);
 		if (after != null) {
-			ElementNameValuePairGen annValue = getAnnotationElement(after, VALUE);
-			ElementNameValuePairGen annPointcut = getAnnotationElement(after, POINTCUT);
-			ElementNameValuePairGen annThrown = getAnnotationElement(after, THROWING);
+			NameValuePair annValue = getAnnotationElement(after, VALUE);
+			NameValuePair annPointcut = getAnnotationElement(after, POINTCUT);
+			NameValuePair annThrown = getAnnotationElement(after, THROWING);
 
 			// extract the pointcut and throwned type/binding - do some checks
 			String pointcut = null;
@@ -1275,11 +1275,11 @@ public class AtAjAttributes {
 	 * @param struct
 	 * @return true if found
 	 */
-	private static boolean handleAroundAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct,
+	private static boolean handleAroundAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct,
 			ResolvedPointcutDefinition preResolvedPointcut) {
 		AnnotationGen around = getAnnotation(runtimeAnnotations, AjcMemberMaker.AROUND_ANNOTATION);
 		if (around != null) {
-			ElementNameValuePairGen aroundAdvice = getAnnotationElement(around, VALUE);
+			NameValuePair aroundAdvice = getAnnotationElement(around, VALUE);
 			if (aroundAdvice != null) {
 				// this/target/args binding
 				String argumentNames = getArgNamesValue(around);
@@ -1326,11 +1326,11 @@ public class AtAjAttributes {
 	 * @param struct
 	 * @return true if a pointcut was handled
 	 */
-	private static boolean handlePointcutAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct) {
+	private static boolean handlePointcutAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct) {
 		AnnotationGen pointcut = getAnnotation(runtimeAnnotations, AjcMemberMaker.POINTCUT_ANNOTATION);
 		if (pointcut == null)
 			return false;
-		ElementNameValuePairGen pointcutExpr = getAnnotationElement(pointcut, VALUE);
+		NameValuePair pointcutExpr = getAnnotationElement(pointcut, VALUE);
 
 		// semantic check: the method must return void, or be
 		// "public static boolean" for if() support
@@ -1419,12 +1419,12 @@ public class AtAjAttributes {
 	 * @param struct
 	 * @return true if found
 	 */
-	private static boolean handleDeclareErrorOrWarningAnnotation(AsmManager model, RuntimeAnnotations runtimeAnnotations,
+	private static boolean handleDeclareErrorOrWarningAnnotation(AsmManager model, RuntimeAnnos runtimeAnnotations,
 			AjAttributeFieldStruct struct) {
 		AnnotationGen error = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREERROR_ANNOTATION);
 		boolean hasError = false;
 		if (error != null) {
-			ElementNameValuePairGen declareError = getAnnotationElement(error, VALUE);
+			NameValuePair declareError = getAnnotationElement(error, VALUE);
 			if (declareError != null) {
 				if (!STRING_DESC.equals(struct.field.getSignature()) || struct.field.getConstantValue() == null) {
 					reportError("@DeclareError used on a non String constant field", struct);
@@ -1444,7 +1444,7 @@ public class AtAjAttributes {
 		AnnotationGen warning = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREWARNING_ANNOTATION);
 		boolean hasWarning = false;
 		if (warning != null) {
-			ElementNameValuePairGen declareWarning = getAnnotationElement(warning, VALUE);
+			NameValuePair declareWarning = getAnnotationElement(warning, VALUE);
 			if (declareWarning != null) {
 				if (!STRING_DESC.equals(struct.field.getSignature()) || struct.field.getConstantValue() == null) {
 					reportError("@DeclareWarning used on a non String constant field", struct);
@@ -1626,7 +1626,7 @@ public class AtAjAttributes {
 	 * @param annotationType
 	 * @return annotation
 	 */
-	private static AnnotationGen getAnnotation(RuntimeAnnotations rvs, UnresolvedType annotationType) {
+	private static AnnotationGen getAnnotation(RuntimeAnnos rvs, UnresolvedType annotationType) {
 		final String annotationTypeName = annotationType.getName();
 		for (Iterator iterator = rvs.getAnnotations().iterator(); iterator.hasNext();) {
 			AnnotationGen rv = (AnnotationGen) iterator.next();
@@ -1644,9 +1644,9 @@ public class AtAjAttributes {
 	 * @param elementName
 	 * @return annotation NVP
 	 */
-	private static ElementNameValuePairGen getAnnotationElement(AnnotationGen annotation, String elementName) {
+	private static NameValuePair getAnnotationElement(AnnotationGen annotation, String elementName) {
 		for (Iterator iterator1 = annotation.getValues().iterator(); iterator1.hasNext();) {
-			ElementNameValuePairGen element = (ElementNameValuePairGen) iterator1.next();
+			NameValuePair element = (NameValuePair) iterator1.next();
 			if (elementName.equals(element.getNameString())) {
 				return element;
 			}
@@ -1658,8 +1658,8 @@ public class AtAjAttributes {
 	 * Return the argNames set for an annotation or null if it is not specified.
 	 */
 	private static String getArgNamesValue(AnnotationGen anno) {
-		List<ElementNameValuePairGen> elements = anno.getValues();
-		for (ElementNameValuePairGen element : elements) {
+		List<NameValuePair> elements = anno.getValues();
+		for (NameValuePair element : elements) {
 			if (ARGNAMES.equals(element.getNameString())) {
 				return element.getValue().stringifyValue();
 			}
@@ -15,10 +15,10 @@ import java.util.List;
 import java.util.Set;
 
 import org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;
-import org.aspectj.apache.bcel.classfile.annotation.ArrayElementValueGen;
-import org.aspectj.apache.bcel.classfile.annotation.ElementNameValuePairGen;
-import org.aspectj.apache.bcel.classfile.annotation.ElementValueGen;
-import org.aspectj.apache.bcel.classfile.annotation.EnumElementValueGen;
+import org.aspectj.apache.bcel.classfile.annotation.ArrayElementValue;
+import org.aspectj.apache.bcel.classfile.annotation.NameValuePair;
+import org.aspectj.apache.bcel.classfile.annotation.ElementValue;
+import org.aspectj.apache.bcel.classfile.annotation.EnumElementValue;
 import org.aspectj.weaver.AbstractAnnotationAJ;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.World;
@@ -46,13 +46,13 @@ public class BcelAnnotation extends AbstractAnnotationAJ {
 		if (!type.equals(UnresolvedType.AT_TARGET)) {
 			return Collections.emptySet();
 		}
-		List<ElementNameValuePairGen> values = bcelAnnotation.getValues();
-		ElementNameValuePairGen envp = values.get(0);
-		ArrayElementValueGen aev = (ArrayElementValueGen) envp.getValue();
-		ElementValueGen[] evs = aev.getElementValuesArray();
+		List<NameValuePair> values = bcelAnnotation.getValues();
+		NameValuePair envp = values.get(0);
+		ArrayElementValue aev = (ArrayElementValue) envp.getValue();
+		ElementValue[] evs = aev.getElementValuesArray();
 		Set<String> targets = new HashSet<String>();
 		for (int i = 0; i < evs.length; i++) {
-			EnumElementValueGen ev = (EnumElementValueGen) evs[i];
+			EnumElementValue ev = (EnumElementValue) evs[i];
 			targets.add(ev.getEnumValueString());
 		}
 		return targets;
@@ -81,10 +81,10 @@ public class BcelAnnotation extends AbstractAnnotationAJ {
 	public String stringify() {
 		StringBuffer sb = new StringBuffer();
 		sb.append("@").append(type.getClassName());
-		List<ElementNameValuePairGen> values = bcelAnnotation.getValues();
+		List<NameValuePair> values = bcelAnnotation.getValues();
 		if (values != null && values.size() != 0) {
 			sb.append("(");
-			for (ElementNameValuePairGen nvPair : values) {
+			for (NameValuePair nvPair : values) {
 				sb.append(nvPair.getNameString()).append("=").append(nvPair.getValue().stringifyValue());
 			}
 			sb.append(")");
@@ -111,11 +111,11 @@ public class BcelAnnotation extends AbstractAnnotationAJ {
 	 * {@inheritDoc}
 	 */
 	public String getStringFormOfValue(String name) {
-		List<ElementNameValuePairGen> annotationValues = this.bcelAnnotation.getValues();
+		List<NameValuePair> annotationValues = this.bcelAnnotation.getValues();
 		if (annotationValues == null || annotationValues.size() == 0) {
 			return null;
 		} else {
-			for (ElementNameValuePairGen nvPair : annotationValues) {
+			for (NameValuePair nvPair : annotationValues) {
 				if (nvPair.getNameString().equals(name)) {
 					return nvPair.getValue().stringifyValue();
 				}
@@ -29,7 +29,7 @@ import org.aspectj.apache.bcel.classfile.LocalVariable;
 import org.aspectj.apache.bcel.classfile.LocalVariableTable;
 import org.aspectj.apache.bcel.classfile.Method;
 import org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;
-import org.aspectj.apache.bcel.classfile.annotation.ElementNameValuePairGen;
+import org.aspectj.apache.bcel.classfile.annotation.NameValuePair;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.bridge.SourceLocation;
 import org.aspectj.util.GenericSignature;
@@ -140,8 +140,8 @@ class BcelMethod extends ResolvedMemberImpl {
 								|| typename.startsWith("org.aspectj.lang.annotation.After")) {
 							AnnotationGen a = ((BcelAnnotation) annotationX).getBcelAnnotation();
 							if (a != null) {
-								List<ElementNameValuePairGen> values = a.getValues();
-								for (ElementNameValuePairGen nvPair : values) {
+								List<NameValuePair> values = a.getValues();
+								for (NameValuePair nvPair : values) {
 									if (nvPair.getNameString().equals("argNames")) {
 										String argNames = nvPair.getValue().stringifyValue();
 										StringTokenizer argNameTokenizer = new StringTokenizer(argNames, " ,");
@@ -29,8 +29,8 @@ import org.aspectj.apache.bcel.classfile.JavaClass;
 import org.aspectj.apache.bcel.classfile.Method;
 import org.aspectj.apache.bcel.classfile.Signature;
 import org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;
-import org.aspectj.apache.bcel.classfile.annotation.ElementNameValuePairGen;
-import org.aspectj.apache.bcel.classfile.annotation.EnumElementValueGen;
+import org.aspectj.apache.bcel.classfile.annotation.NameValuePair;
+import org.aspectj.apache.bcel.classfile.annotation.EnumElementValue;
 import org.aspectj.bridge.IMessageHandler;
 import org.aspectj.bridge.MessageUtil;
 import org.aspectj.util.GenericSignature;
@@ -599,8 +599,8 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 					if (ax.getTypeName().equals(UnresolvedType.AT_RETENTION.getName())) {
 						List values = ((BcelAnnotation) ax).getBcelAnnotation().getValues();
 						for (Iterator it = values.iterator(); it.hasNext();) {
-							ElementNameValuePairGen element = (ElementNameValuePairGen) it.next();
-							EnumElementValueGen v = (EnumElementValueGen) element.getValue();
+							NameValuePair element = (NameValuePair) it.next();
+							EnumElementValue v = (EnumElementValue) element.getValue();
 							retentionPolicy = v.getEnumValueString();
 							return retentionPolicy;
 						}
@@ -1772,6 +1772,11 @@ public class BcelWeaver {
 		ReferenceType resolvedClassType = classType.getResolvedTypeX();
 
 		if (world.isXmlConfigured() && world.getXmlConfiguration().excludesType(resolvedClassType)) {
+			if (!world.getMessageHandler().isIgnoring(IMessage.INFO)) {
+				world.getMessageHandler().handleMessage(
+						MessageUtil.info("Type '" + resolvedClassType.getName() + "' not woven due to exclusion via XML weaver exclude section"));
+
+			}
 			if (dump) {
 				dumpUnchanged(classFile);
 			}
@@ -1008,11 +1008,6 @@ public class BcelWorld extends World implements Repository {
 					}
 				}
 			}
-			if (excluded && !world.getMessageHandler().isIgnoring(IMessage.INFO)) {
-				world.getMessageHandler().handleMessage(
-						MessageUtil.info("Type '" + typename + "' excluded from weaving due to xml configuration"));
-
-			}
 			return excluded;
 		}
 	}
@@ -16,7 +16,7 @@ import java.io.IOException;
 import java.util.List;
 
 import org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;
-import org.aspectj.apache.bcel.classfile.annotation.ElementNameValuePairGen;
+import org.aspectj.apache.bcel.classfile.annotation.NameValuePair;
 
 /**
  * For implementing declare @type interacting with declare @parents during compilation - we need to be 
@@ -48,7 +48,7 @@ public class FakeAnnotation extends AnnotationGen {
 		return sig;
 	}
 
-	public void addElementNameValuePair(ElementNameValuePairGen evp) {
+	public void addElementNameValuePair(NameValuePair evp) {
 		// doesnt need to know about name/value pairs
 	}
 
@@ -27,10 +27,10 @@ import org.aspectj.apache.bcel.classfile.ClassParser;
 import org.aspectj.apache.bcel.classfile.ConstantPool;
 import org.aspectj.apache.bcel.classfile.JavaClass;
 import org.aspectj.apache.bcel.classfile.Unknown;
-import org.aspectj.apache.bcel.classfile.annotation.ArrayElementValueGen;
-import org.aspectj.apache.bcel.classfile.annotation.ElementNameValuePairGen;
-import org.aspectj.apache.bcel.classfile.annotation.ElementValueGen;
-import org.aspectj.apache.bcel.classfile.annotation.SimpleElementValueGen;
+import org.aspectj.apache.bcel.classfile.annotation.ArrayElementValue;
+import org.aspectj.apache.bcel.classfile.annotation.NameValuePair;
+import org.aspectj.apache.bcel.classfile.annotation.ElementValue;
+import org.aspectj.apache.bcel.classfile.annotation.SimpleElementValue;
 import org.aspectj.apache.bcel.generic.ArrayType;
 import org.aspectj.apache.bcel.generic.BasicType;
 import org.aspectj.apache.bcel.generic.Instruction;
@@ -646,16 +646,16 @@ public class Utility {
 				// 1. there are no values specified (i.e. @SuppressAjWarnings)
 				// 2. there are values specified (i.e. @SuppressAjWarnings("A")
 				// or @SuppressAjWarnings({"A","B"})
-				List<ElementNameValuePairGen> vals = ((BcelAnnotation) anns[i]).getBcelAnnotation().getValues();
+				List<NameValuePair> vals = ((BcelAnnotation) anns[i]).getBcelAnnotation().getValues();
 				if (vals == null || vals.isEmpty()) { // (1)
 					suppressedWarnings.addAll(lint.allKinds());
 				} else { // (2)
 					// We know the value is an array value
-					ArrayElementValueGen array = (ArrayElementValueGen) ((ElementNameValuePairGen) vals.get(0)).getValue();
-					ElementValueGen[] values = array.getElementValuesArray();
+					ArrayElementValue array = (ArrayElementValue) ((NameValuePair) vals.get(0)).getValue();
+					ElementValue[] values = array.getElementValuesArray();
 					for (int j = 0; j < values.length; j++) {
 						// We know values in the array are strings
-						SimpleElementValueGen value = (SimpleElementValueGen) values[j];
+						SimpleElementValue value = (SimpleElementValue) values[j];
 						Lint.Kind lintKind = lint.getLintKind(value.getValueString());
 						if (lintKind != null)
 							suppressedWarnings.add(lintKind);
@@ -0,0 +1,4 @@
+package p;
+
+public class A {
+}
@@ -0,0 +1,4 @@
+package p;
+
+public class A2 {
+}
@@ -0,0 +1,5 @@
+package p;
+
+public aspect X {
+  before(): staticinitialization(!X) {}
+}
@@ -0,0 +1,5 @@
+<aspectj>
+  <aspects>
+    <aspect name="p.X" scope="p.A"/>
+  </aspects>
+</aspectj>
@@ -21,6 +21,7 @@ import java.io.PrintStream;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -319,6 +320,10 @@ class MyCompilerConfig implements ICompilerConfiguration {
 		return JavaOptions.getDefaultJavaOptions();
 	}
 
+	public List getProjectXmlConfigFiles() {
+		return Collections.EMPTY_LIST;
+	}
+
 	public String getOutJar() {
 		return outJar;
 	}
@@ -811,8 +811,13 @@ public class BcelWorld extends World implements Repository {
 	 * @param xmlFiles list of File objects representing any aop.xml files passed in to configure the build process
 	 */
 	public void setXmlFiles(List xmlFiles) {
+		if (!isXmlConfiguredWorld && !xmlFiles.isEmpty()) {
+			getMessageHandler().handleMessage(
+					MessageUtil
+							.error("xml configuration files only supported by the compiler when -xmlConfigured option specified"));
+			return;
+		}
 		if (!xmlFiles.isEmpty()) {
-			isXmlConfiguredWorld = true;
 			xmlConfiguration = new WeavingXmlConfig(this);
 		}
 		for (Iterator iterator = xmlFiles.iterator(); iterator.hasNext();) {
@@ -832,8 +837,12 @@ public class BcelWorld extends World implements Repository {
 		}
 	}
 
+	public void setXmlConfigured(boolean b) {
+		this.isXmlConfiguredWorld = b;
+	}
+
 	public boolean isXmlConfigured() {
-		return isXmlConfiguredWorld;
+		return isXmlConfiguredWorld && xmlConfiguration != null;
 	}
 
 	public boolean isAspectIncluded(ResolvedType aspectType) {
@@ -3,7 +3,7 @@
 <suite>
 
     <ajc-test dir="features164/aopconfig/one" title="aop config - 1">
-      <compile files="A.java A2.java B.java foo.xml" options="-1.5 -showWeaveInfo">
+      <compile files="A.java A2.java B.java foo.xml" options="-1.5 -showWeaveInfo -xmlConfigured">
         <message kind="weave" text="Join point 'staticinitialization(void A.&lt;clinit&gt;())' in Type 'A' (A.java:1) advised by before advice from 'A' (A.java:2)"/>
         <message kind="weave" text="Join point 'staticinitialization(void A2.&lt;clinit&gt;())' in Type 'A2' (A2.java:1) advised by before advice from 'A' (A.java:2)"/>
         <message kind="weave" text="Join point 'staticinitialization(void B.&lt;clinit&gt;())' in Type 'B' (B.java:1) advised by before advice from 'A' (A.java:2)"/>
@@ -11,14 +11,14 @@
     </ajc-test>
 
     <ajc-test dir="features164/aopconfig/one" title="aop config - 2">
-      <compile files="A.java A2.java B.java B2.java foo2.xml" options="-1.5 -showWeaveInfo">
+      <compile files="A.java A2.java B.java B2.java foo2.xml" options="-1.5 -showWeaveInfo -xmlConfigured">
         <message kind="weave" text="Join point 'staticinitialization(void B.&lt;clinit&gt;())' in Type 'B' (B.java:1) advised by before advice from 'A' (A.java:2)"/>
       </compile>
     </ajc-test>
 
     <ajc-test dir="features164/aopconfig/two" title="aop config - 3">
       <!-- type pattern in the scope in foo.xml is complete nonsense -->
-      <compile files="A.java B.java foo.xml" options="-1.5 -Xlint:ignore">
+      <compile files="A.java B.java foo.xml" options="-1.5 -Xlint:ignore -xmlConfigured">
       	<message kind="error" text="Unable to parse scope as type pattern"/>
       </compile>
     </ajc-test>
@@ -71,6 +71,13 @@ public class AjdeInteractionTestbed extends TestCase {
 		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).addProjectSourceFileChanged(changedFile);
 	}
 
+	public void addXmlConfigFile(String projectName, String xmlfile) {
+		List l = new ArrayList();
+		l.add(xmlfile);
+		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
+		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).setProjectXmlConfigFiles(l);
+	}
+
 	public void addClasspathEntry(String projectName, File classpathEntry) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
 		MultiProjTestCompilerConfiguration config = ((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration());
@@ -164,6 +171,7 @@ public class AjdeInteractionTestbed extends TestCase {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
 		resetCompilerRecords(compiler);
 		addSourceFilesToBuild(projectName, compiler);
+		// addXmlConfigFilesToBuild(projectName, compiler);
 		pause(1000); // delay to allow previous runs build stamps to be OK
 		lognoln("Building project '" + projectName + "'");
 		compiler.build();
@@ -184,6 +192,7 @@ public class AjdeInteractionTestbed extends TestCase {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
 		resetCompilerRecords(compiler);
 		addSourceFilesToBuild(projectName, compiler);
+		addXmlConfigFilesToBuild(projectName, compiler);
 		pause(1000); // delay to allow previous runs build stamps to be OK
 		lognoln("Building project '" + projectName + "'");
 		compiler.buildFresh();
@@ -226,6 +235,26 @@ public class AjdeInteractionTestbed extends TestCase {
 		}
 	}
 
+	private void addXmlConfigFilesToBuild(String pname, AjCompiler compiler) {
+		File projectBase = new File(sandboxDir, pname);
+		ICompilerConfiguration icc = compiler.getCompilerConfiguration();
+		List currentXmlFiles = icc.getProjectXmlConfigFiles();
+		List collector = new ArrayList();
+		collectUpXmlFiles(projectBase, projectBase, collector);
+		boolean changed = false;
+		for (int i = 0; i < collector.size(); i++) {
+			if (!currentXmlFiles.contains(collector.get(i)))
+				changed = true;
+		}
+		for (int i = 0; i < currentXmlFiles.size(); i++) {
+			if (!collector.contains(currentXmlFiles.get(i)))
+				changed = true;
+		}
+		if (changed) {
+			((MultiProjTestCompilerConfiguration) icc).setProjectXmlConfigFiles(collector);
+		}
+	}
+
 	private void collectUpFiles(File location, File base, List collectionPoint) {
 		String contents[] = location.list();
 		if (contents == null)
@@ -250,6 +279,27 @@ public class AjdeInteractionTestbed extends TestCase {
 		}
 	}
 
+	private void collectUpXmlFiles(File location, File base, List collectionPoint) {
+		String contents[] = location.list();
+		if (contents == null)
+			return;
+		for (int i = 0; i < contents.length; i++) {
+			String string = contents[i];
+			File f = new File(location, string);
+			if (f.isDirectory()) {
+				collectUpXmlFiles(f, base, collectionPoint);
+			} else if (f.isFile() && f.getName().endsWith(".xml")) {
+				String fileFound;
+				try {
+					fileFound = f.getCanonicalPath();
+					collectionPoint.add(fileFound);
+				} catch (IOException e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
 	/**
 	 * Make sure no errors have been recorded
 	 */
@@ -41,6 +41,7 @@ public class MultiProjTestCompilerConfiguration implements ICompilerConfiguratio
 	private List modifiedFiles;
 	private List modifiedDirs;
 	private List projectSourceFiles = new ArrayList();
+	private List xmlConfigFiles = new ArrayList();
 	private String projectPath;
 
 	int changed;
@@ -121,6 +122,10 @@ public class MultiProjTestCompilerConfiguration implements ICompilerConfiguratio
 		return projectSourceFiles;
 	}
 
+	public List getProjectXmlConfigFiles() {
+		return xmlConfigFiles;
+	}
+
 	public List getProjectSourceFilesChanged() {
 		log("ICompilerConfiguration.getProjectSourceFilesChanged()");
 		return modifiedFiles;
@@ -174,6 +179,11 @@ public class MultiProjTestCompilerConfiguration implements ICompilerConfiguratio
 		this.changed |= ICompilerConfiguration.PROJECTSOURCEFILES_CHANGED;
 	}
 
+	public void setProjectXmlConfigFiles(List xmlConfigFiles) {
+		this.xmlConfigFiles = xmlConfigFiles;
+		this.changed |= ICompilerConfiguration.XMLCONFIG_CHANGED;
+	}
+
 	public void addProjectSourceFileChanged(File f) {
 		if (this.modifiedFiles == null) {
 			this.modifiedFiles = new ArrayList();
@@ -50,6 +50,26 @@ import org.aspectj.util.FileUtil;
  */
 public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementalAjdeInteractionTestbed {
 
+	public void testXmlConfiguredProject() {
+		AjdeInteractionTestbed.VERBOSE = true;
+		String p = "xmlone";
+		initialiseProject(p);
+		configureNonStandardCompileOptions(p, "-showWeaveInfo -xmlConfigured");
+		configureShowWeaveInfoMessages(p, true);
+		addXmlConfigFile(p, getProjectRelativePath(p, "p/aop.xml").toString());
+		build(p);
+		checkWasFullBuild();
+		List weaveMessages = getWeavingMessages(p);
+		if (weaveMessages.size() != 1) {
+			for (Iterator iterator = weaveMessages.iterator(); iterator.hasNext();) {
+				Object object = (Object) iterator.next();
+				System.out.println(object);
+			}
+			fail("Expected just one weave message.  The aop.xml should have limited the weaving");
+		}
+
+	}
+
 	public void testDeclareParentsInModel() {
 		String p = "decps";
 		initialiseProject(p);
@@ -408,6 +408,7 @@ public class AjBuildConfig implements CompilerConfigurationChangeFlags {
 		setOutxmlName(global.getOutxmlName());
 		setXconfigurationInfo(global.getXconfigurationInfo());
 		setAddSerialVerUID(global.isAddSerialVerUID());
+		setXmlConfigured(global.isXmlConfigured());
 	}
 
 	void join(Collection local, Collection global) {
@@ -560,6 +561,14 @@ public class AjBuildConfig implements CompilerConfigurationChangeFlags {
 		return options.addSerialVerUID;
 	}
 
+	public void setXmlConfigured(boolean b) {
+		options.xmlConfigured = b;
+	}
+
+	public boolean isXmlConfigured() {
+		return options.xmlConfigured;
+	}
+
 	public boolean isXNotReweavable() {
 		return options.xNotReweavable;
 	}
@@ -787,6 +787,7 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 		BcelWorld bcelWorld = new BcelWorld(cp, handler, null);
 		bcelWorld.setBehaveInJava5Way(buildConfig.getBehaveInJava5Way());
 		bcelWorld.setAddSerialVerUID(buildConfig.isAddSerialVerUID());
+		bcelWorld.setXmlConfigured(buildConfig.isXmlConfigured());
 		bcelWorld.setXmlFiles(buildConfig.getXmlFiles());
 		bcelWorld.performExtraConfiguration(buildConfig.getXconfigurationInfo());
 		bcelWorld.setTargetAspectjRuntimeLevel(buildConfig.getTargetAspectjRuntimeLevel());
@@ -10,7 +10,6 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.ajdt.internal.core.builder;
 
 import java.util.Map;
@@ -19,48 +18,47 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.aspectj.org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.aspectj.weaver.Constants;
 
-
 /**
- * Compiler options used by Eclipse integration  (AJDT) 
+ * Compiler options used by Eclipse integration (AJDT)
  */
 public class AjCompilerOptions extends CompilerOptions {
 
 	// AspectJ Lint options
-	public static final String OPTION_ReportInvalidAbsoluteTypeName = "org.aspectj.ajdt.core.compiler.lint.InvalidAbsoluteTypeName"; 
-	public static final String OPTION_ReportInvalidWildcardTypeName = "org.aspectj.ajdt.core.compiler.lint.WildcardTypeName"; 
-	public static final String OPTION_ReportUnresolvableMember      = "org.aspectj.ajdt.core.compiler.lint.UnresolvableMember"; 
-	public static final String OPTION_ReportTypeNotExposedToWeaver  = "org.aspectj.ajdt.core.compiler.lint.TypeNotExposedToWeaver"; 
-	public static final String OPTION_ReportShadowNotInStructure    = "org.aspectj.ajdt.core.compiler.lint.ShadowNotInStructure"; 
-	public static final String OPTION_ReportUnmatchedSuperTypeInCall    = "org.aspectj.ajdt.core.compiler.list.UnmatchedSuperTypeInCall";
-	public static final String OPTION_ReportCannotImplementLazyTJP  = "org.aspectj.ajdt.core.compiler.lint.CannotImplementLazyTJP"; 
-	public static final String OPTION_ReportNeedSerialVersionUIDField   = "org.aspectj.ajdt.core.compiler.lint.NeedSerialVersionUIDField"; 
-	public static final String OPTION_ReportIncompatibleSerialVersion   = "org.aspectj.ajdt.core.compiler.lint.BrokeSerialVersionCompatibility";
-	
+	public static final String OPTION_ReportInvalidAbsoluteTypeName = "org.aspectj.ajdt.core.compiler.lint.InvalidAbsoluteTypeName";
+	public static final String OPTION_ReportInvalidWildcardTypeName = "org.aspectj.ajdt.core.compiler.lint.WildcardTypeName";
+	public static final String OPTION_ReportUnresolvableMember = "org.aspectj.ajdt.core.compiler.lint.UnresolvableMember";
+	public static final String OPTION_ReportTypeNotExposedToWeaver = "org.aspectj.ajdt.core.compiler.lint.TypeNotExposedToWeaver";
+	public static final String OPTION_ReportShadowNotInStructure = "org.aspectj.ajdt.core.compiler.lint.ShadowNotInStructure";
+	public static final String OPTION_ReportUnmatchedSuperTypeInCall = "org.aspectj.ajdt.core.compiler.list.UnmatchedSuperTypeInCall";
+	public static final String OPTION_ReportCannotImplementLazyTJP = "org.aspectj.ajdt.core.compiler.lint.CannotImplementLazyTJP";
+	public static final String OPTION_ReportNeedSerialVersionUIDField = "org.aspectj.ajdt.core.compiler.lint.NeedSerialVersionUIDField";
+	public static final String OPTION_ReportIncompatibleSerialVersion = "org.aspectj.ajdt.core.compiler.lint.BrokeSerialVersionCompatibility";
+
 	// General AspectJ Compiler options (excludes paths etc, these are handled separately)
-	public static final String OPTION_TerminateAfterCompilation                 = "org.aspectj.ajdt.core.compiler.weaver.TerminateAfterCompilation";
-	public static final String OPTION_XSerializableAspects    = "org.aspectj.ajdt.core.compiler.weaver.XSerializableAspects";
-	public static final String OPTION_XLazyThisJoinPoint      = "org.aspectj.ajdt.core.compiler.weaver.XLazyThisJoinPoint";
-	public static final String OPTION_XNoInline               = "org.aspectj.ajdt.core.compiler.weaver.XNoInline";
-	public static final String OPTION_XNotReweavable          = "org.aspectj.ajdt.core.compiler.weaver.XNotReweavable";
-	public static final String OPTION_XHasMember              = "org.aspectj.ajdt.core.compiler.weaver.XHasMember";
-	public static final String OPTION_XdevPinpoint            = "org.aspectj.ajdt.core.compiler.weaver.XdevPinpoint";
-	
+	public static final String OPTION_TerminateAfterCompilation = "org.aspectj.ajdt.core.compiler.weaver.TerminateAfterCompilation";
+	public static final String OPTION_XSerializableAspects = "org.aspectj.ajdt.core.compiler.weaver.XSerializableAspects";
+	public static final String OPTION_XLazyThisJoinPoint = "org.aspectj.ajdt.core.compiler.weaver.XLazyThisJoinPoint";
+	public static final String OPTION_XNoInline = "org.aspectj.ajdt.core.compiler.weaver.XNoInline";
+	public static final String OPTION_XNotReweavable = "org.aspectj.ajdt.core.compiler.weaver.XNotReweavable";
+	public static final String OPTION_XHasMember = "org.aspectj.ajdt.core.compiler.weaver.XHasMember";
+	public static final String OPTION_XdevPinpoint = "org.aspectj.ajdt.core.compiler.weaver.XdevPinpoint";
+
 	// these next four not exposed by IDEs
 	public static final String OPTION_XDevNoAtAspectJProcessing = "org.aspectj.ajdt.core.compiler.ast.NoAtAspectJProcessing";
-    public static final String OPTION_GenerateModel           = "org.aspectj.ajdt.core.compiler.model.GenerateModel";
-    public static final String OPTION_GenerateJavaDocsInModel = "org.aspectj.ajdt.core.compiler.model.GenerateJavaDocsInModel";
-    public static final String OPTION_Emacssym                = "org.aspectj.ajdt.core.compiler.model.Emacssym";
-	
+	public static final String OPTION_GenerateModel = "org.aspectj.ajdt.core.compiler.model.GenerateModel";
+	public static final String OPTION_GenerateJavaDocsInModel = "org.aspectj.ajdt.core.compiler.model.GenerateJavaDocsInModel";
+	public static final String OPTION_Emacssym = "org.aspectj.ajdt.core.compiler.model.Emacssym";
+
 	// constants for irritant levels
-	public static final long InvalidAbsoluteTypeName    = ASTNode.Bit47L;
-	public static final long InvalidWildCardTypeName    = ASTNode.Bit48L;
-	public static final long UnresolvableMember           = ASTNode.Bit49L;
-	public static final long TypeNotExposedToWeaver   = ASTNode.Bit50L;
-	public static final long ShadowNotInStructure       = ASTNode.Bit51L;
-	public static final long UnmatchedSuperTypeInCall   = ASTNode.Bit52L;
-	public static final long CannotImplementLazyTJP     = ASTNode.Bit53L;
-	public static final long NeedSerialVersionUIDField  = ASTNode.Bit54L;
-	public static final long IncompatibleSerialVersion  = ASTNode.Bit55L;
+	public static final long InvalidAbsoluteTypeName = ASTNode.Bit47L;
+	public static final long InvalidWildCardTypeName = ASTNode.Bit48L;
+	public static final long UnresolvableMember = ASTNode.Bit49L;
+	public static final long TypeNotExposedToWeaver = ASTNode.Bit50L;
+	public static final long ShadowNotInStructure = ASTNode.Bit51L;
+	public static final long UnmatchedSuperTypeInCall = ASTNode.Bit52L;
+	public static final long CannotImplementLazyTJP = ASTNode.Bit53L;
+	public static final long NeedSerialVersionUIDField = ASTNode.Bit54L;
+	public static final long IncompatibleSerialVersion = ASTNode.Bit55L;
 
 	public boolean terminateAfterCompilation = false;
 	public boolean xSerializableAspects = false;
@@ -70,103 +68,120 @@ public class AjCompilerOptions extends CompilerOptions {
 	public boolean xHasMember = false;
 	public boolean xdevPinpoint = false;
 	public boolean showWeavingInformation = false;
-	
+
 	public String xOptionalJoinpoints = null;
-	
+
 	// If true - autoboxing behaves differently ...
 	public boolean behaveInJava5Way = false;
-	
+
 	// Specifies the level of the aspectjrt.jar we are targetting
 	public String targetAspectjRuntimeLevel = Constants.RUNTIME_LEVEL_DEFAULT;
-	
+
 	public String xConfigurationInfo;
 	public boolean addSerialVerUID = false;
-	
+	public boolean xmlConfigured = false;
+
 	// these next four not exposed by IDEs
 	public boolean generateModel = false;
 	public boolean generateJavaDocsInModel = false;
 	public boolean generateEmacsSymFiles = false;
 	public boolean noAtAspectJProcessing = false;
-	
+
 	/**
-	 * Generates a map of cross references based on information
-	 * in the structure model.
+	 * Generates a map of cross references based on information in the structure model.
 	 */
 	public boolean generateCrossRefs = false;
-	
+
 	// Check aspectjrt*.jar exists and within it the version number is right (see AjBuildManager.checkRtJar())
 	public boolean checkRuntimeVersion = true;
-	
+
 	public boolean proceedOnError = false;
 
-	
-	/** 
+	/**
 	 * Initializing the compiler options with defaults
 	 */
-	public AjCompilerOptions(){
+	public AjCompilerOptions() {
 		super();
-		setAspectJWarningDefaults();			
+		setAspectJWarningDefaults();
 	}
 
-	/** 
+	/**
 	 * Initializing the compiler options with external settings
+	 * 
 	 * @param settings
 	 */
-	public AjCompilerOptions(Map settings){
+	public AjCompilerOptions(Map settings) {
 		setAspectJWarningDefaults();
-		if (settings == null) return;
-		set(settings);	
+		if (settings == null)
+			return;
+		set(settings);
 	}
-	/* (non-Javadoc)
+
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.eclipse.jdt.internal.compiler.impl.CompilerOptions#getMap()
 	 */
 	public Map getMap() {
 		Map map = super.getMap();
 		// now add AspectJ additional options
-		map.put(OPTION_ReportInvalidAbsoluteTypeName,getSeverityString(InvalidAbsoluteTypeName));
-		map.put(OPTION_ReportInvalidWildcardTypeName,getSeverityString(InvalidWildCardTypeName));
-		map.put(OPTION_ReportUnresolvableMember,getSeverityString(UnresolvableMember));
-		map.put(OPTION_ReportTypeNotExposedToWeaver,getSeverityString(TypeNotExposedToWeaver));
-		map.put(OPTION_ReportShadowNotInStructure,getSeverityString(ShadowNotInStructure));
-		map.put(OPTION_ReportUnmatchedSuperTypeInCall,getSeverityString(UnmatchedSuperTypeInCall));
-		map.put(OPTION_ReportCannotImplementLazyTJP,getSeverityString(CannotImplementLazyTJP));
-		map.put(OPTION_ReportNeedSerialVersionUIDField,getSeverityString(NeedSerialVersionUIDField));
-		map.put(OPTION_ReportIncompatibleSerialVersion,getSeverityString(IncompatibleSerialVersion));
-		map.put(CompilerOptions.OPTION_ReportSwallowedExceptionInCatchBlock,getSeverityString(CompilerOptions.SwallowedExceptionInCatchBlock));
-		
+		map.put(OPTION_ReportInvalidAbsoluteTypeName, getSeverityString(InvalidAbsoluteTypeName));
+		map.put(OPTION_ReportInvalidWildcardTypeName, getSeverityString(InvalidWildCardTypeName));
+		map.put(OPTION_ReportUnresolvableMember, getSeverityString(UnresolvableMember));
+		map.put(OPTION_ReportTypeNotExposedToWeaver, getSeverityString(TypeNotExposedToWeaver));
+		map.put(OPTION_ReportShadowNotInStructure, getSeverityString(ShadowNotInStructure));
+		map.put(OPTION_ReportUnmatchedSuperTypeInCall, getSeverityString(UnmatchedSuperTypeInCall));
+		map.put(OPTION_ReportCannotImplementLazyTJP, getSeverityString(CannotImplementLazyTJP));
+		map.put(OPTION_ReportNeedSerialVersionUIDField, getSeverityString(NeedSerialVersionUIDField));
+		map.put(OPTION_ReportIncompatibleSerialVersion, getSeverityString(IncompatibleSerialVersion));
+		map.put(CompilerOptions.OPTION_ReportSwallowedExceptionInCatchBlock,
+				getSeverityString(CompilerOptions.SwallowedExceptionInCatchBlock));
+
 		map.put(OPTION_TerminateAfterCompilation, this.terminateAfterCompilation ? ENABLED : DISABLED);
-		map.put(OPTION_XSerializableAspects,this.xSerializableAspects ? ENABLED : DISABLED);
-		map.put(OPTION_XLazyThisJoinPoint,this.xLazyThisJoinPoint ? ENABLED : DISABLED);
-		map.put(OPTION_XNoInline,this.xNoInline ? ENABLED : DISABLED);
-		map.put(OPTION_XNotReweavable,this.xNotReweavable ? ENABLED : DISABLED);
+		map.put(OPTION_XSerializableAspects, this.xSerializableAspects ? ENABLED : DISABLED);
+		map.put(OPTION_XLazyThisJoinPoint, this.xLazyThisJoinPoint ? ENABLED : DISABLED);
+		map.put(OPTION_XNoInline, this.xNoInline ? ENABLED : DISABLED);
+		map.put(OPTION_XNotReweavable, this.xNotReweavable ? ENABLED : DISABLED);
 		map.put(OPTION_XHasMember, this.xHasMember ? ENABLED : DISABLED);
 		map.put(OPTION_XdevPinpoint, this.xdevPinpoint ? ENABLED : DISABLED);
 
-		map.put(OPTION_GenerateModel,this.generateModel ? ENABLED : DISABLED);
-		map.put(OPTION_GenerateJavaDocsInModel,this.generateJavaDocsInModel ? ENABLED : DISABLED);
-		map.put(OPTION_Emacssym,this.generateEmacsSymFiles ? ENABLED : DISABLED);
-		map.put(OPTION_XDevNoAtAspectJProcessing,this.noAtAspectJProcessing ? ENABLED : DISABLED);
-		
+		map.put(OPTION_GenerateModel, this.generateModel ? ENABLED : DISABLED);
+		map.put(OPTION_GenerateJavaDocsInModel, this.generateJavaDocsInModel ? ENABLED : DISABLED);
+		map.put(OPTION_Emacssym, this.generateEmacsSymFiles ? ENABLED : DISABLED);
+		map.put(OPTION_XDevNoAtAspectJProcessing, this.noAtAspectJProcessing ? ENABLED : DISABLED);
+
 		return map;
 	}
-	
-	/* (non-Javadoc)
+
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.eclipse.jdt.internal.compiler.impl.CompilerOptions#set(java.util.Map)
 	 */
 	public void set(Map optionsMap) {
 		super.set(optionsMap);
 		Object optionValue;
-		if ((optionValue = optionsMap.get(OPTION_ReportInvalidAbsoluteTypeName)) != null) updateSeverity(InvalidAbsoluteTypeName, optionValue);
-		if ((optionValue = optionsMap.get(OPTION_ReportInvalidWildcardTypeName)) != null) updateSeverity(InvalidWildCardTypeName, optionValue);
-		if ((optionValue = optionsMap.get(OPTION_ReportUnresolvableMember)) != null) updateSeverity(UnresolvableMember, optionValue);
-		if ((optionValue = optionsMap.get(OPTION_ReportTypeNotExposedToWeaver)) != null) updateSeverity(TypeNotExposedToWeaver, optionValue);
-		if ((optionValue = optionsMap.get(OPTION_ReportShadowNotInStructure)) != null) updateSeverity(ShadowNotInStructure, optionValue);
-		if ((optionValue = optionsMap.get(OPTION_ReportUnmatchedSuperTypeInCall)) != null) updateSeverity(UnmatchedSuperTypeInCall, optionValue);
-		if ((optionValue = optionsMap.get(OPTION_ReportCannotImplementLazyTJP)) != null) updateSeverity(CannotImplementLazyTJP, optionValue);
-		if ((optionValue = optionsMap.get(OPTION_ReportNeedSerialVersionUIDField)) != null) updateSeverity(NeedSerialVersionUIDField, optionValue);
-		if ((optionValue = optionsMap.get(OPTION_ReportIncompatibleSerialVersion)) != null) updateSeverity(IncompatibleSerialVersion, optionValue);
-		if ((optionValue = optionsMap.get(CompilerOptions.OPTION_ReportSwallowedExceptionInCatchBlock)) != null) updateSeverity(CompilerOptions.SwallowedExceptionInCatchBlock, optionValue);
-		
+		if ((optionValue = optionsMap.get(OPTION_ReportInvalidAbsoluteTypeName)) != null)
+			updateSeverity(InvalidAbsoluteTypeName, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportInvalidWildcardTypeName)) != null)
+			updateSeverity(InvalidWildCardTypeName, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportUnresolvableMember)) != null)
+			updateSeverity(UnresolvableMember, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportTypeNotExposedToWeaver)) != null)
+			updateSeverity(TypeNotExposedToWeaver, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportShadowNotInStructure)) != null)
+			updateSeverity(ShadowNotInStructure, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportUnmatchedSuperTypeInCall)) != null)
+			updateSeverity(UnmatchedSuperTypeInCall, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportCannotImplementLazyTJP)) != null)
+			updateSeverity(CannotImplementLazyTJP, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportNeedSerialVersionUIDField)) != null)
+			updateSeverity(NeedSerialVersionUIDField, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportIncompatibleSerialVersion)) != null)
+			updateSeverity(IncompatibleSerialVersion, optionValue);
+		if ((optionValue = optionsMap.get(CompilerOptions.OPTION_ReportSwallowedExceptionInCatchBlock)) != null)
+			updateSeverity(CompilerOptions.SwallowedExceptionInCatchBlock, optionValue);
+
 		if ((optionValue = optionsMap.get(OPTION_TerminateAfterCompilation)) != null) {
 			if (ENABLED.equals(optionValue)) {
 				this.terminateAfterCompilation = true;
@@ -203,17 +218,10 @@ public class AjCompilerOptions extends CompilerOptions {
 			}
 		}
 		/*
-		if ((optionValue = optionsMap.get(OPTION_XReweavableCompress)) != null) {
-			if (ENABLED.equals(optionValue)) {
-				this.xReweavableCompress = true;
-			} else if (DISABLED.equals(optionValue)) {
-				this.xReweavableCompress = false;
-			}
-		}
-*/
-		
-		
-		
+		 * if ((optionValue = optionsMap.get(OPTION_XReweavableCompress)) != null) { if (ENABLED.equals(optionValue)) {
+		 * this.xReweavableCompress = true; } else if (DISABLED.equals(optionValue)) { this.xReweavableCompress = false; } }
+		 */
+
 		if ((optionValue = optionsMap.get(OPTION_XHasMember)) != null) {
 			if (ENABLED.equals(optionValue)) {
 				this.xHasMember = true;
@@ -258,28 +266,24 @@ public class AjCompilerOptions extends CompilerOptions {
 				this.noAtAspectJProcessing = false;
 			}
 		}
-		
+
 	}
-	
+
 	/**
 	 * Add these warnings to the default set...
 	 */
 	private void setAspectJWarningDefaults() {
-		super.warningThreshold = 
-			super.warningThreshold |
-			InvalidAbsoluteTypeName |
-			UnresolvableMember |
-			TypeNotExposedToWeaver |
-			UnmatchedSuperTypeInCall |
-			CannotImplementLazyTJP |
-			CompilerOptions.SwallowedExceptionInCatchBlock;
+		super.warningThreshold = super.warningThreshold | InvalidAbsoluteTypeName | UnresolvableMember | TypeNotExposedToWeaver
+				| UnmatchedSuperTypeInCall | CannotImplementLazyTJP | CompilerOptions.SwallowedExceptionInCatchBlock;
 	}
-	
-	/* (non-Javadoc)
+
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see java.lang.Object#toString()
 	 */
 	public String toString() {
-		StringBuffer buf = new StringBuffer( super.toString() );
+		StringBuffer buf = new StringBuffer(super.toString());
 		// now add AspectJ additional options
 		buf.append("\n\tAspectJ Specific Options:");
 		buf.append("\n\t- terminate after compilation: ").append(this.terminateAfterCompilation ? ENABLED : DISABLED); //$NON-NLS-1$
@@ -293,7 +297,7 @@ public class AjCompilerOptions extends CompilerOptions {
 		buf.append("\n\t- generate Javadocs in AJDE model: ").append(this.generateJavaDocsInModel ? ENABLED : DISABLED); //$NON-NLS-1$		
 		buf.append("\n\t- generate Emacs symbol files: ").append(this.generateEmacsSymFiles ? ENABLED : DISABLED); //$NON-NLS-1$
 		buf.append("\n\t- suppress @AspectJ processing: ").append(this.noAtAspectJProcessing ? ENABLED : DISABLED); //$NON-NLS-1$
-		
+
 		buf.append("\n\t- invalid absolute type name (XLint): ").append(getSeverityString(InvalidAbsoluteTypeName)); //$NON-NLS-1$
 		buf.append("\n\t- invalid wildcard type name (XLint): ").append(getSeverityString(InvalidWildCardTypeName)); //$NON-NLS-1$
 		buf.append("\n\t- unresolvable member (XLint): ").append(getSeverityString(UnresolvableMember)); //$NON-NLS-1$
@@ -303,9 +307,9 @@ public class AjCompilerOptions extends CompilerOptions {
 		buf.append("\n\t- cannot implement lazy thisJoinPoint (XLint): ").append(getSeverityString(CannotImplementLazyTJP)); //$NON-NLS-1$
 		buf.append("\n\t- need serialVersionUID field (XLint): ").append(getSeverityString(NeedSerialVersionUIDField)); //$NON-NLS-1$
 		buf.append("\n\t- incompatible serial version (XLint): ").append(getSeverityString(IncompatibleSerialVersion)); //$NON-NLS-1$
-		buf.append("\n\t- swallowed exception in catch block (XLint): ").append(getSeverityString(CompilerOptions.SwallowedExceptionInCatchBlock)); //$NON-NLS-1$
-		
+		buf
+				.append("\n\t- swallowed exception in catch block (XLint): ").append(getSeverityString(CompilerOptions.SwallowedExceptionInCatchBlock)); //$NON-NLS-1$
+
 		return buf.toString();
 	}
 }
-  
@@ -25,6 +25,7 @@ public interface CompilerConfigurationChangeFlags {
 	int PROJECTSOURCERESOURCES_CHANGED = 0x0080;
 	int OUTPUTDESTINATIONS_CHANGED = 0x0100;
 	int INJARS_CHANGED = 0x0200; // deprecated, not in use any more
+	int XMLCONFIG_CHANGED = 0x0400;
 	int EVERYTHING = 0xffff;
 
 }
@@ -544,6 +544,8 @@ public class BuildArgParser extends Main {
 				buildConfig.setNoAtAspectJAnnotationProcessing(true);
 			} else if (arg.equals("-XaddSerialVersionUID")) {
 				buildConfig.setAddSerialVerUID(true);
+			} else if (arg.equals("-xmlConfigured")) {
+				buildConfig.setXmlConfigured(true);
 			} else if (arg.equals("-Xdev:Pinpoint")) {
 				buildConfig.setXdevPinpointMode(true);
 			} else if (arg.startsWith("-Xjoinpoints:")) {
@@ -13,6 +13,7 @@ package org.aspectj.ajde.core;
 import java.io.File;
 import java.io.FileFilter;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.List;
@@ -52,6 +53,10 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 		return aspectpath;
 	}
 
+	public List getProjectXmlConfigFiles() {
+		return Collections.EMPTY_LIST;
+	}
+
 	public String getClasspath() {
 		return projectPath + File.pathSeparator + System.getProperty("sun.boot.class.path") + File.pathSeparator
 				+ AjcTests.aspectjrtClasspath();
@@ -46,6 +46,11 @@ public interface ICompilerConfiguration extends CompilerConfigurationChangeFlags
 	public List /* String */getProjectSourceFiles();
 
 	/**
+	 * @return a list of those files that should be used to configure a build
+	 */
+	public List /* String */getProjectXmlConfigFiles();
+
+	/**
 	 * Return a subset of those files we'd get on getProjectSourceFiles() - the subset that have changed since the last build. If
 	 * someone else has already worked out what needs rebuilding, we don't need to do it again by checking all of the
 	 * projectSourceFiles(). Returning an empty list means nothing has changed, returning null means you have no idea what changed
@@ -77,7 +77,8 @@ public class AjdeCoreBuildManager {
 		// If an incremental build is requested, check that we can
 		if (!fullBuild) {
 			AjState existingState = IncrementalStateManager.retrieveStateFor(compiler.getId());
-			if (existingState == null || existingState.getBuildConfig()==null || ajBuildManager.getState().getBuildConfig() == null) {
+			if (existingState == null || existingState.getBuildConfig() == null
+					|| ajBuildManager.getState().getBuildConfig() == null) {
 				// No existing state so we must do a full build
 				fullBuild = true;
 			} else {
@@ -220,7 +221,20 @@ public class AjdeCoreBuildManager {
 			if (l == null) {
 				return null;
 			}
-			args = (String[]) l.toArray(new String[l.size()]);
+			List xmlfiles = compilerConfig.getProjectXmlConfigFiles();
+			if (xmlfiles != null && !xmlfiles.isEmpty()) {
+				args = new String[l.size() + xmlfiles.size()];
+				// TODO speedup
+				int p = 0;
+				for (int i = 0; i < l.size(); i++) {
+					args[p++] = (String) l.get(i);
+				}
+				for (int i = 0; i < xmlfiles.size(); i++) {
+					args[p++] = (String) xmlfiles.get(i);
+				}
+			} else {
+				args = (String[]) l.toArray(new String[l.size()]);
+			}
 		}
 
 		BuildArgParser parser = new BuildArgParser(handler);
@@ -13,6 +13,7 @@ package org.aspectj.ajde.ui.utils;
 import java.io.File;
 import java.io.FileFilter;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.List;
@@ -54,6 +55,10 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 	public void configurationRead() {
 	}
 
+	public List getProjectXmlConfigFiles() {
+		return Collections.EMPTY_LIST;
+	}
+
 	public Set getAspectPath() {
 		return aspectpath;
 	}
@@ -11,6 +11,7 @@
 package org.aspectj.tools.ajbrowser.core;
 
 import java.io.File;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -106,4 +107,8 @@ public class BrowserCompilerConfiguration implements ICompilerConfiguration {
 	public List getClasspathElementsWithModifiedContents() {
 		return null;
 	}
+
+	public List getProjectXmlConfigFiles() {
+		return Collections.EMPTY_LIST;
+	}
 }
@@ -0,0 +1,3 @@
+aspect A {
+  before():staticinitialization(*) {}
+}
@@ -0,0 +1,2 @@
+public class B {
+}
@@ -0,0 +1,6 @@
+<aspectj>
+<aspects>
+  <aspect name="A" scope="("/>
+  <!-- <aspect name="A2"/> -->
+</aspects>
+</aspectj>
@@ -29,16 +29,26 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testHandles_pr263310() {
+		runTest("inner handles");
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
+		IProgramElement ipe = null;
+		ipe = findElementAtLine(top.getRoot(), 13);
+		assertEquals("<p{HandleTestingAspect.java}HandleTestingAspect[InnerClass}InnerInnerAspect|1", ipe.getHandleIdentifier());
+		// ipe = findElementAtLine(top.getRoot(), 29);
+		// assertEquals("<x*OverrideOptions.aj}OverrideOptions&around!2", ipe.getHandleIdentifier());
+	}
+
 	public void testHandles_pr263666() {
 		runTest("around advice handles");
 		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		IProgramElement ipe = null;
-		ipe = findElementAtLine(top.getRoot(), 22);// public java.util.List<String> Ship.i(List<String>[][] u)
+		ipe = findElementAtLine(top.getRoot(), 22);
 		assertEquals("<x*OverrideOptions.aj}OverrideOptions&around", ipe.getHandleIdentifier());
-		ipe = findElementAtLine(top.getRoot(), 29);// public java.util.List<String> Ship.i(List<String>[][] u)
+		ipe = findElementAtLine(top.getRoot(), 29);
 		assertEquals("<x*OverrideOptions.aj}OverrideOptions&around!2", ipe.getHandleIdentifier());
 	}
-/*
+
 	// Only one of two aspects named
 	public void testAopConfig1() {
 		runTest("aop config - 1");
@@ -48,7 +58,12 @@ public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	public void testAopConfig2() {
 		runTest("aop config - 2");
 	}
-*/
+
+	// Invalid scope specified - cannot be parsed as type pattern
+	public void testAopConfig3() {
+		runTest("aop config - 3");
+	}
+
 	public void testAjcThisNotRead() {
 		runTest("ajcthis not read");
 	}
@@ -2,11 +2,6 @@
 
 <suite>
 
-    <ajc-test dir="bugs164/pr263666" title="around advice handles">
-      <compile files="x/A.java x/B.java x/OverrideOptions.aj" options="-1.5 -emacssym"/>
-    </ajc-test>
-    
-    
     <ajc-test dir="features164/aopconfig/one" title="aop config - 1">
       <compile files="A.java A2.java B.java foo.xml" options="-1.5 -showWeaveInfo">
         <message kind="weave" text="Join point 'staticinitialization(void A.&lt;clinit&gt;())' in Type 'A' (A.java:1) advised by before advice from 'A' (A.java:2)"/>
@@ -21,6 +16,21 @@
       </compile>
     </ajc-test>
 
+    <ajc-test dir="features164/aopconfig/two" title="aop config - 3">
+      <!-- type pattern in the scope in foo.xml is complete nonsense -->
+      <compile files="A.java B.java foo.xml" options="-1.5 -Xlint:ignore">
+      	<message kind="error" text="Unable to parse scope as type pattern"/>
+      </compile>
+    </ajc-test>
+    
+    <ajc-test dir="bugs164/pr263310" title="inner handles">
+      <compile files="HandleTestingAspect.java" options="-1.5 -emacssym -Xlint:ignore"/>
+    </ajc-test>
+    
+    <ajc-test dir="bugs164/pr263666" title="around advice handles">
+      <compile files="x/A.java x/B.java x/OverrideOptions.aj" options="-1.5 -emacssym"/>
+    </ajc-test>
+    
     <ajc-test dir="bugs164" title="ajcthis not read">
       <compile files="pr195090.java" options="-1.5 -warn:+unusedArgument">
       </compile>
@@ -0,0 +1,43 @@
+This is to cover https://bugs.eclipse.org/bugs/show_bug.cgi?id=124460 which relates
+to the use of aop.xml configure compile time and binary weaving, in addition to
+load time weaving.
+
+For source compilation and binary weaving the goal is to offer the same experience 
+users will get when using their aop.xml for LTW.
+
+Additionally for source compilation it also offers a way to control
+aspects when they are extracted from source src zip and then used across some
+set of source folders they were never originally intended for (see the
+compiling spring bug where a test aspect is leaking across all the source folders
+in the whole of spring).
+
+So - that means consuming aspects from either the inpath/aspectpath or source folders
+should include aop.xml searching.  Or they can be specified directly as source
+entries perhaps when passing source files:
+
+ajc A.java B.java foo.xml
+
+
+--
+Testing
+
+- basic aop.xml that includes one aspect
+- the variety of mungers (checkers/itd members/advice/decp/deca)
+- wildcarded includes/excludes
+- compound type patterns for scope
+- new messages: ignoring weaver sections, scoping aspects, excluding aspects, problems processing aop.xml
+- aspect supertypes included if subtypes excluded?
+- annotation style
+- inner aspects
+- needs a command line option to switch support for this on/off (ie. to make it search
+  for xml files on aspectpath/inpath - we dont want unexpected behaviour)
+
+--
+Implementation Notes
+
+- Just because the contents of the aspect are not used in weaving, doesnt mean
+  the aspect shouldn't be fully compiled/resolved and written to the bin folder
+  correctly as a valid aspect for later consumption.  So we can't short circuit
+  resolution if the aspect is included - we really just want to exclude inclusion
+  of that aspect in the crosscuttingset - or maybe even later we just want to
+  skip any mungers that came from it (but what about inherited mungers from supertypes?)
@@ -0,0 +1,3 @@
+aspect A {
+  before():staticinitialization(*) {}
+}
@@ -0,0 +1,3 @@
+aspect A2 {
+  before():staticinitialization(*) {}
+}
@@ -0,0 +1,2 @@
+public class B {
+}
@@ -0,0 +1,2 @@
+public class B2 {
+}
@@ -0,0 +1,6 @@
+<aspectj>
+<aspects>
+  <aspect name="A"/>
+  <!-- <aspect name="A2"/> -->
+</aspects>
+</aspectj>
@@ -0,0 +1,7 @@
+<!-- A is scoped to only affect certain types matching the scope -->
+<aspectj>
+<aspects>
+  <aspect name="A" scope="B"/>
+  <!-- <aspect name="A2"/> -->
+</aspects>
+</aspectj>
@@ -787,6 +787,7 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 		BcelWorld bcelWorld = new BcelWorld(cp, handler, null);
 		bcelWorld.setBehaveInJava5Way(buildConfig.getBehaveInJava5Way());
 		bcelWorld.setAddSerialVerUID(buildConfig.isAddSerialVerUID());
+		bcelWorld.setXmlFiles(buildConfig.getXmlFiles());
 		bcelWorld.performExtraConfiguration(buildConfig.getXconfigurationInfo());
 		bcelWorld.setTargetAspectjRuntimeLevel(buildConfig.getTargetAspectjRuntimeLevel());
 		bcelWorld.setOptionalJoinpoints(buildConfig.getXJoinpoints());
@@ -363,6 +363,14 @@ public class Ajc {
 				File f = new File(args[i]);
 				// newArgs[i] = new File(baseDir,args[i]).getAbsolutePath(); // might be quicker?
 				newArgs[i] = adjustFileOrDir(f, doCopy).getAbsolutePath();
+			} else if (args[i].endsWith(".xml") && !args[i].startsWith("-")) {
+				if (i > 0 && args[i - 1].equals("-outxmlfile")) {
+					// dont adjust it
+				} else {
+					File f = new File(args[i]);
+					// newArgs[i] = new File(baseDir,args[i]).getAbsolutePath(); // might be quicker?
+					newArgs[i] = adjustFileOrDir(f, doCopy).getAbsolutePath();
+				}
 			} else {
 				if ((args[i].equals("-aspectpath") || args[i].equals("-inpath") || args[i].equals("-injars")
 						|| args[i].equals("-outjar") || args[i].equals("-classpath") || args[i].equals("-sourceroots")
@@ -34,6 +34,7 @@ public class CrosscuttingMembersSet {
 	// FIXME AV - ? we may need a sequencedHashMap there to ensure source based precedence for @AJ advice
 	private final Map /* ResolvedType (the aspect) > CrosscuttingMembers */members = new HashMap();
 
+	private World world;
 	private List shadowMungers = null;
 	private List typeMungers = null;
 	private List lateTypeMungers = null;
@@ -46,14 +47,12 @@ public class CrosscuttingMembersSet {
 	private boolean changedSinceLastReset = false;
 
 	private List /* IVerificationRequired */verificationList = null; // List of things to be verified once the type system is
-																	// 'complete'
+	// 'complete'
 
 	private static Trace trace = TraceFactory.getTraceFactory().getTrace(CrosscuttingMembersSet.class);
 
 	public CrosscuttingMembersSet(World world) {
-		trace.enter("<init>", this, world);
-
-		trace.exit("<init>");
+		this.world = world;
 	}
 
 	public boolean addOrReplaceAspect(ResolvedType aspectType) {
@@ -65,7 +64,10 @@ public class CrosscuttingMembersSet {
 	 *         this
 	 */
 	public boolean addOrReplaceAspect(ResolvedType aspectType, boolean inWeavingPhase) {
-		trace.enter("addOrReplaceAspect", this, new Object[] { aspectType, new Boolean(inWeavingPhase) });
+
+		if (!world.isAspectIncluded(aspectType)) {
+			return false;
+		}
 
 		boolean change = false;
 		CrosscuttingMembers xcut = (CrosscuttingMembers) members.get(aspectType);
@@ -93,7 +95,6 @@ public class CrosscuttingMembersSet {
 		}
 		changedSinceLastReset = changedSinceLastReset || change;
 
-		trace.exit("addOrReplaceAspect", change);
 		return change;
 	}
 
@@ -117,6 +118,9 @@ public class CrosscuttingMembersSet {
 	}
 
 	public void addAdviceLikeDeclares(ResolvedType aspectType) {
+		if (!members.containsKey(aspectType)) {
+			return;
+		}
 		CrosscuttingMembers xcut = (CrosscuttingMembers) members.get(aspectType);
 		xcut.addDeclares(aspectType.collectDeclares(true));
 	}
@@ -21,6 +21,7 @@ import org.aspectj.bridge.SourceLocation;
 import org.aspectj.util.PartialOrder;
 import org.aspectj.weaver.patterns.PerClause;
 import org.aspectj.weaver.patterns.Pointcut;
+import org.aspectj.weaver.patterns.TypePattern;
 
 /**
  * For every shadow munger, nothing can be done with it until it is concretized. Then...
@@ -66,6 +67,15 @@ public abstract class ShadowMunger implements PartialOrder.PartialComparable, IH
 	 * All overriding methods should call super
 	 */
 	public boolean match(Shadow shadow, World world) {
+		if (world.isXmlConfigured() && world.isAspectIncluded(declaringType)) {
+			TypePattern scoped = world.getAspectScope(declaringType);
+			if (scoped != null) {
+				boolean b = scoped.matches(shadow.getEnclosingType().resolve(world), TypePattern.STATIC).alwaysTrue();
+				if (!b) {
+					return false;
+				}
+			}
+		}
 		return pointcut.match(shadow).maybeTrue();
 	}
 
@@ -38,6 +38,7 @@ import org.aspectj.util.IStructureModel;
 import org.aspectj.weaver.UnresolvedType.TypeKind;
 import org.aspectj.weaver.patterns.DeclarePrecedence;
 import org.aspectj.weaver.patterns.Pointcut;
+import org.aspectj.weaver.patterns.TypePattern;
 import org.aspectj.weaver.tools.PointcutDesignatorHandler;
 import org.aspectj.weaver.tools.Trace;
 import org.aspectj.weaver.tools.TraceFactory;
@@ -1290,8 +1291,12 @@ public abstract class World implements Dump.INode {
 		return false;
 	}
 
-	// public boolean specifiesInclusionOfAspect(String name) {
-	// return true;
-	// }
+	public boolean isAspectIncluded(ResolvedType aspectType) {
+		return true;
+	}
+
+	public TypePattern getAspectScope(ResolvedType declaringType) {
+		return null;
+	}
 
 }
\ No newline at end of file
@@ -106,6 +106,7 @@ aspect
 <!ELEMENT aspect EMPTY>
 <!ATTLIST aspect
     name CDATA #REQUIRED
+    scope CDATA #IMPLIED
 >
 <!--*****************************************************************************************************************************
 exclude
@@ -18,8 +18,10 @@ import java.io.IOException;
 import java.lang.reflect.Modifier;
 import java.net.MalformedURLException;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.StringTokenizer;
 
 import org.aspectj.apache.bcel.Constants;
@@ -45,6 +47,7 @@ import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.IMessageHandler;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.bridge.Message;
+import org.aspectj.bridge.MessageUtil;
 import org.aspectj.bridge.WeaveMessage;
 import org.aspectj.weaver.Advice;
 import org.aspectj.weaver.AdviceKind;
@@ -73,6 +76,8 @@ import org.aspectj.weaver.loadtime.definition.DocumentParser;
 import org.aspectj.weaver.model.AsmRelationshipProvider;
 import org.aspectj.weaver.patterns.DeclareAnnotation;
 import org.aspectj.weaver.patterns.DeclareParents;
+import org.aspectj.weaver.patterns.PatternParser;
+import org.aspectj.weaver.patterns.TypePattern;
 import org.aspectj.weaver.tools.Trace;
 import org.aspectj.weaver.tools.TraceFactory;
 
@@ -82,7 +87,8 @@ public class BcelWorld extends World implements Repository {
 	protected Repository delegate;
 	private BcelWeakClassLoaderReference loaderRef;
 	private final BcelWeavingSupport bcelWeavingSupport = new BcelWeavingSupport();
-	private List/* File */xmlFiles;
+	private boolean isXmlConfiguredWorld = false;
+	private WeavingXmlConfig xmlConfiguration;
 
 	private static Trace trace = TraceFactory.getTraceFactory().getTrace(BcelWorld.class);
 
@@ -563,6 +569,12 @@ public class BcelWorld extends World implements Repository {
 	 * BcelObjectType - this happens quite often when incrementally compiling.
 	 */
 	public static BcelObjectType getBcelObjectType(ResolvedType concreteAspect) {
+		if (concreteAspect == null) {
+			return null;
+		}
+		if (!(concreteAspect instanceof ReferenceType)) { // Might be Missing
+			return null;
+		}
 		ReferenceTypeDelegate rtDelegate = ((ReferenceType) concreteAspect).getDelegate();
 		if (rtDelegate instanceof BcelObjectType) {
 			return (BcelObjectType) rtDelegate;
@@ -799,17 +811,23 @@ public class BcelWorld extends World implements Repository {
 	 * @param xmlFiles list of File objects representing any aop.xml files passed in to configure the build process
 	 */
 	public void setXmlFiles(List xmlFiles) {
-		this.xmlFiles = xmlFiles;
+		if (!xmlFiles.isEmpty()) {
+			isXmlConfiguredWorld = true;
+			xmlConfiguration = new WeavingXmlConfig(this);
+		}
 		for (Iterator iterator = xmlFiles.iterator(); iterator.hasNext();) {
 			File xmlfile = (File) iterator.next();
 			try {
 				Definition d = DocumentParser.parse(xmlfile.toURI().toURL());
-				xmlAspectNames.addAll(d.getAspectClassNames());
-				isXmlConfiguredWorld = true;
+				xmlConfiguration.add(d);
 			} catch (MalformedURLException e) {
-				e.printStackTrace();
+				getMessageHandler().handleMessage(
+						MessageUtil.error("Unexpected problem processing XML config file '" + xmlfile.getName() + "' :"
+								+ e.getMessage()));
 			} catch (Exception e) {
-				e.printStackTrace();
+				getMessageHandler().handleMessage(
+						MessageUtil.error("Unexpected problem processing XML config file '" + xmlfile.getName() + "' :"
+								+ e.getMessage()));
 			}
 		}
 	}
@@ -818,11 +836,96 @@ public class BcelWorld extends World implements Repository {
 		return isXmlConfiguredWorld;
 	}
 
-	// public boolean specifiesInclusionOfAspect(String name) {
-	// return xmlAspectNames.contains(name);
-	// }
+	public boolean isAspectIncluded(ResolvedType aspectType) {
+		if (!isXmlConfigured()) {
+			return true;
+		}
+		return xmlConfiguration.specifiesInclusionOfAspect(aspectType.getName());
+	}
 
-	private boolean isXmlConfiguredWorld = false;
-	private List/* String */xmlAspectNames = new ArrayList();
+	public TypePattern getAspectScope(ResolvedType declaringType) {
+		return xmlConfiguration.getScopeFor(declaringType.getName());
+	}
+
+	/**
+	 * A WeavingXmlConfig is initially a collection of definitions from XML files - once the world is ready and weaving is running
+	 * it will initialize and transform those definitions into an optimized set of values (eg. resolve type patterns and string
+	 * names to real entities). It can then answer questions quickly: (1) is this aspect included in the weaving? (2) Is there a
+	 * scope specified for this aspect and does it include type X?
+	 * 
+	 */
+	static class WeavingXmlConfig {
+
+		private boolean initialized = false; // Lazily done
+		private List/* Definition */definitions = new ArrayList();
+
+		private List/* <String> */resolvedIncludedAspects = new ArrayList();
+		private Map/* <String,TypePattern> */scopes = new HashMap();
+
+		private BcelWorld world;
+
+		public WeavingXmlConfig(BcelWorld bcelWorld) {
+			this.world = bcelWorld;
+		}
+
+		public void add(Definition d) {
+			definitions.add(d);
+		}
+
+		public void ensureInitialized() {
+			if (!initialized) {
+				try {
+					resolvedIncludedAspects = new ArrayList();
+					// Process the definitions into something more optimal
+					for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
+						Definition definition = (Definition) iterator.next();
+						List/* String */aspectNames = definition.getAspectClassNames();
+						for (Iterator iterator2 = aspectNames.iterator(); iterator2.hasNext();) {
+							String name = (String) iterator2.next();
+							resolvedIncludedAspects.add(name);
+							// TODO check for existence?
+							// ResolvedType resolvedAspect = resolve(UnresolvedType.forName(name));
+							// if (resolvedAspect.isMissing()) {
+							// // ERROR
+							// } else {
+							// resolvedIncludedAspects.add(resolvedAspect);
+							// }
+							String scope = definition.getScopeForAspect(name);
+							if (scope != null) {
+								// Resolve the type pattern
+								try {
+									TypePattern scopePattern = new PatternParser(scope).parseTypePattern();
+									scopePattern.resolve(world);
+									scopes.put(name, scopePattern);
+									if (!world.getMessageHandler().isIgnoring(IMessage.INFO)) {
+										world.getMessageHandler().handleMessage(
+												MessageUtil.info("Aspect '" + name
+														+ "' is scoped to apply against types matching pattern '"
+														+ scopePattern.toString() + "'"));
+									}
+								} catch (Exception e) {
+									// TODO definitions should remember which file they came from, for inclusion in this message
+									world.getMessageHandler().handleMessage(
+											MessageUtil.error("Unable to parse scope as type pattern.  Scope was '" + scope + "': "
+													+ e.getMessage()));
+								}
+							}
+						}
+					}
+				} finally {
+					initialized = true;
+				}
+			}
+		}
+
+		public boolean specifiesInclusionOfAspect(String name) {
+			ensureInitialized();
+			return resolvedIncludedAspects.contains(name);
+		}
+
+		public TypePattern getScopeFor(String name) {
+			return (TypePattern) scopes.get(name);
+		}
+	}
 
-}
\ No newline at end of file
+}
@@ -12,7 +12,9 @@
 package org.aspectj.weaver.loadtime.definition;
 
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 /**
  * A POJO that contains raw strings from the XML (sort of XMLBean for our simple LTW DTD)
@@ -41,6 +43,11 @@ public class Definition {
 
 	private final List m_concreteAspects;
 
+	/**
+	 * When aspects are defined, they can specify a scope type pattern and then will only apply to types matching that pattern.
+	 */
+	private final Map scopedAspects;
+
 	public Definition() {
 		m_weaverOptions = new StringBuffer();
 		m_dumpBefore = false;
@@ -52,6 +59,7 @@ public class Definition {
 		m_aspectExcludePatterns = new ArrayList(0);
 		m_aspectIncludePatterns = new ArrayList(0);
 		m_concreteAspects = new ArrayList(0);
+		scopedAspects = new HashMap();
 	}
 
 	public String getWeaverOptions() {
@@ -144,4 +152,12 @@ public class Definition {
 		m_weaverOptions.append(option.trim()).append(' ');
 	}
 
+	public void addScopedAspect(String name, String scopePattern) {
+		scopedAspects.put(name, scopePattern);
+	}
+
+	public String getScopeForAspect(String name) {
+		return (String) scopedAspects.get(name);
+	}
+
 }
@@ -60,6 +60,7 @@ public class DocumentParser extends DefaultHandler {
 	private final static String ASPECT_ELEMENT = "aspect";
 	private final static String CONCRETE_ASPECT_ELEMENT = "concrete-aspect";
 	private final static String NAME_ATTRIBUTE = "name";
+	private final static String SCOPE_ATTRIBUTE = "scope";
 	private final static String EXTEND_ATTRIBUTE = "extends";
 	private final static String PRECEDENCE_ATTRIBUTE = "precedence";
 	private final static String PERCLAUSE_ATTRIBUTE = "perclause";
@@ -150,8 +151,12 @@ public class DocumentParser extends DefaultHandler {
 	public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
 		if (ASPECT_ELEMENT.equals(qName)) {
 			String name = attributes.getValue(NAME_ATTRIBUTE);
+			String scopePattern = replaceXmlAnd(attributes.getValue(SCOPE_ATTRIBUTE));
 			if (!isNull(name)) {
 				m_definition.getAspectClassNames().add(name);
+				if (scopePattern != null) {
+					m_definition.addScopedAspect(name, scopePattern);
+				}
 			}
 		} else if (WEAVER_ELEMENT.equals(qName)) {
 			String options = attributes.getValue(OPTIONS_ATTRIBUTE);
@@ -1283,4 +1283,15 @@ public abstract class World implements Dump.INode {
 	public void reportCheckerMatch(Checker checker, Shadow shadow) {
 	}
 
+	/**
+	 * @return true if this world has the activation and scope of application of the aspects controlled via aop.xml files
+	 */
+	public boolean isXmlConfigured() {
+		return false;
+	}
+
+	// public boolean specifiesInclusionOfAspect(String name) {
+	// return true;
+	// }
+
 }
\ No newline at end of file
@@ -16,6 +16,7 @@ package org.aspectj.weaver.bcel;
 import java.io.File;
 import java.io.IOException;
 import java.lang.reflect.Modifier;
+import java.net.MalformedURLException;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -67,6 +68,8 @@ import org.aspectj.weaver.Shadow;
 import org.aspectj.weaver.ShadowMunger;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.World;
+import org.aspectj.weaver.loadtime.definition.Definition;
+import org.aspectj.weaver.loadtime.definition.DocumentParser;
 import org.aspectj.weaver.model.AsmRelationshipProvider;
 import org.aspectj.weaver.patterns.DeclareAnnotation;
 import org.aspectj.weaver.patterns.DeclareParents;
@@ -79,6 +82,7 @@ public class BcelWorld extends World implements Repository {
 	protected Repository delegate;
 	private BcelWeakClassLoaderReference loaderRef;
 	private final BcelWeavingSupport bcelWeavingSupport = new BcelWeavingSupport();
+	private List/* File */xmlFiles;
 
 	private static Trace trace = TraceFactory.getTraceFactory().getTrace(BcelWorld.class);
 
@@ -788,4 +792,37 @@ public class BcelWorld extends World implements Repository {
 		return (AsmManager) getModel(); // For now... always an AsmManager in a bcel environment
 	}
 
+	/**
+	 * These are aop.xml files that can be used to alter the aspects that actually apply from those passed in - and also their scope
+	 * of application to other files in the system.
+	 * 
+	 * @param xmlFiles list of File objects representing any aop.xml files passed in to configure the build process
+	 */
+	public void setXmlFiles(List xmlFiles) {
+		this.xmlFiles = xmlFiles;
+		for (Iterator iterator = xmlFiles.iterator(); iterator.hasNext();) {
+			File xmlfile = (File) iterator.next();
+			try {
+				Definition d = DocumentParser.parse(xmlfile.toURI().toURL());
+				xmlAspectNames.addAll(d.getAspectClassNames());
+				isXmlConfiguredWorld = true;
+			} catch (MalformedURLException e) {
+				e.printStackTrace();
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+	}
+
+	public boolean isXmlConfigured() {
+		return isXmlConfiguredWorld;
+	}
+
+	// public boolean specifiesInclusionOfAspect(String name) {
+	// return xmlAspectNames.contains(name);
+	// }
+
+	private boolean isXmlConfiguredWorld = false;
+	private List/* String */xmlAspectNames = new ArrayList();
+
 }
\ No newline at end of file
@@ -144,6 +144,9 @@ public class BuildArgParser extends Main {
 
 			boolean incrementalMode = buildConfig.isIncrementalMode() || buildConfig.isIncrementalFileMode();
 
+			List xmlfileList = new ArrayList();
+			xmlfileList.addAll(parser.getXmlFiles());
+
 			List fileList = new ArrayList();
 			List files = parser.getFiles();
 			if (!LangUtil.isEmpty(files)) {
@@ -179,6 +182,8 @@ public class BuildArgParser extends Main {
 				}
 			}
 
+			buildConfig.setXmlFiles(xmlfileList);
+
 			buildConfig.setFiles(fileList);
 			if (destinationPath != null) { // XXX ?? unparsed but set?
 				buildConfig.setOutputDir(new File(destinationPath));
@@ -18,6 +18,7 @@ import java.io.File;
 import java.io.FileFilter;
 import java.io.FileReader;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
 
@@ -25,6 +26,7 @@ public class ConfigParser {
 	Location location;
 	protected File relativeDirectory = null;
 	protected List files = new LinkedList();
+	protected List xmlfiles = new ArrayList();
 	private boolean fileParsed = false;
 	protected static String CONFIG_MSG = "build config error: ";
 
@@ -32,6 +34,10 @@ public class ConfigParser {
 		return files;
 	}
 
+	public List getXmlFiles() {
+		return xmlfiles;
+	}
+
 	public void parseCommandLine(String[] argsArray) throws ParseException {
 		location = new CommandLineLocation();
 		LinkedList args = new LinkedList();
@@ -100,7 +106,7 @@ public class ConfigParser {
 		s = stripSingleLineComment(s, "#");
 		s = s.trim();
 		if (s.startsWith("\"") && s.endsWith("\"")) {
-			if (s.length()==1) {
+			if (s.length() == 1) {
 				return "";
 			} else {
 				s = s.substring(1, s.length() - 1);
@@ -116,10 +122,16 @@ public class ConfigParser {
 		if (!sourceFile.isFile()) {
 			showError("source file does not exist: " + sourceFile.getPath());
 		}
-
 		files.add(sourceFile);
 	}
 
+	protected void addXmlFile(File xmlFile) {
+		if (!xmlFile.isFile()) {
+			showError("XML file does not exist: " + xmlFile.getPath());
+		}
+		xmlfiles.add(xmlFile);
+	}
+
 	void addFileOrPattern(File sourceFile) {
 		if (sourceFile.getName().charAt(0) == '*') {
 			if (sourceFile.getName().equals("*.java")) {
@@ -197,6 +209,13 @@ public class ConfigParser {
 		return arg.getValue();
 	}
 
+	/**
+	 * aop.xml configuration files can be passed on the command line.
+	 */
+	boolean isXml(String s) {
+		return s.endsWith(".xml");
+	}
+
 	boolean isSourceFileName(String s) {
 		if (s.endsWith(".java"))
 			return true;
@@ -219,6 +238,8 @@ public class ConfigParser {
 			parseConfigFileHelper(makeFile(removeArg(args).getValue()));
 		} else if (isSourceFileName(v)) {
 			addFileOrPattern(makeFile(v));
+		} else if (isXml(v)) {
+			addXmlFile(makeFile(v));
 		} else {
 			parseOption(arg.getValue(), args);
 		}
@@ -47,6 +47,7 @@ public class AjBuildConfig implements CompilerConfigurationChangeFlags {
 	private List/* File */sourceRoots = new ArrayList();
 	private List/* File */changedFiles;
 	private List/* File */files = new ArrayList();
+	private List/* File */xmlfiles = new ArrayList();
 	private List /* File */binaryFiles = new ArrayList(); // .class files in indirs...
 	private List/* File */inJars = new ArrayList();
 	private List/* File */inPath = new ArrayList();
@@ -71,7 +72,7 @@ public class AjBuildConfig implements CompilerConfigurationChangeFlags {
 	public String toString() {
 		StringBuffer sb = new StringBuffer();
 		sb.append("BuildConfig[" + (configFile == null ? "null" : configFile.getAbsoluteFile().toString()) + "] #Files="
-				+ files.size());
+				+ files.size() + " AopXmls=#" + xmlfiles.size());
 		return sb.toString();
 	}
 
@@ -120,6 +121,10 @@ public class AjBuildConfig implements CompilerConfigurationChangeFlags {
 		return files;
 	}
 
+	public List/* File */getXmlFiles() {
+		return xmlfiles;
+	}
+
 	/**
 	 * returned files includes all .class files found in a directory on the inpath, but does not include .class files contained
 	 * within jars.
@@ -144,6 +149,10 @@ public class AjBuildConfig implements CompilerConfigurationChangeFlags {
 		this.files = files;
 	}
 
+	public void setXmlFiles(List xmlfiles) {
+		this.xmlfiles = xmlfiles;
+	}
+
 	public void setOutputDir(File outputDir) {
 		this.outputDir = outputDir;
 	}
@@ -341,6 +350,7 @@ public class AjBuildConfig implements CompilerConfigurationChangeFlags {
 			setEmacsSymMode(true);
 		}
 		join(files, global.files);
+		join(xmlfiles, global.xmlfiles);
 		if (!isGenerateModelMode() && global.isGenerateModelMode()) {
 			setGenerateModelMode(true);
 		}
@@ -1,147 +0,0 @@
-<!--*****************************************************************************************************************************
-/*******************************************************************************
- * Copyright (c) 2005 Contributors.
- * All rights reserved.
- * This program and the accompanying materials are made available
- * under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution and is available at
- * http://eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *   Alexandre Vasseur         initial implementation
- *******************************************************************************/
-AspectJ 5 DTD
-
-To use this DTD, start your defintion file with
-	<!DOCTYPE aspectj PUBLIC
-	    "-//AspectJ//DTD 1.5.0//EN"
-	    "http://.../dtd/aspectj_1_5_0.dtd">
-
-You can also use the "aliasing DTD" that matchs always the latest release of AspectJ
-<!DOCTYPE aspectj PUBLIC
-    "-//AspectJ//DTD//EN"
-    "http://.../dtd/aspectj.dtd">
-
-To not use this DTD, start your definition file with
-	<?xml version="1.0"?>
-
-******************************************************************************************************************************-->
-
-
-<!--*****************************************************************************************************************************
-aspectj
-*********************************************************************************************************************************
-[aspectj] defines the root element
-******************************************************************************************************************************-->
-<!ELEMENT aspectj (
-    weaver?,
-    aspects?
-)>
-<!--*****************************************************************************************************************************
-weaver
-*********************************************************************************************************************************
-[weaver] defines the weaver configuration
-@options defines a command like line of option
-    When multiple aspectj DD are found, the options are simply toggled
-    TODO: Note: the scope of the options can be ClassLoader aware but should be assumed JVM wide
-******************************************************************************************************************************-->
-<!ELEMENT weaver (
-    (include | exclude | dump)*
-)>
-<!ATTLIST weaver
-    options CDATA #IMPLIED
->
-<!--*****************************************************************************************************************************
-include
-*********************************************************************************************************************************
-[include] narrows the scope of the weaver
-A class must be matched by ALL the include elements to be exposed to the weaver
-@within defines a type pattern
-    (it is not a startWith)
-******************************************************************************************************************************-->
-<!ELEMENT include EMPTY>
-<!ATTLIST include
-    within CDATA #REQUIRED
->
-<!--*****************************************************************************************************************************
-exclude
-*********************************************************************************************************************************
-[exclude] narrows the scope of the weaver
-A class must be matched by NONE of the exclude elements to be exposed to the weaver
-@within defines a type pattern
-    (it is not a startWith)
-    TODO should it be called @from: "<exclude from=..>  instead of <exclude within=..>
-    TODO: AND must be written that way and not with the "&&" symbol. Thus NOT and OR exists as well.
-******************************************************************************************************************************-->
-<!ELEMENT exclude EMPTY>
-<!ATTLIST exclude
-    within CDATA #REQUIRED
->
-<!--*****************************************************************************************************************************
-dump
-*********************************************************************************************************************************
-[dump] control post-weaving dump to the "./_dump" folder (debugging purpose only)
-@within defines a type pattern
-    (it is not a startWith)
-******************************************************************************************************************************-->
-<!ELEMENT dump EMPTY>
-<!ATTLIST dump
-    within CDATA #REQUIRED
->
-<!--*****************************************************************************************************************************
-aspects
-*********************************************************************************************************************************
-[aspects] defines a set of aspects
-Note: include only include among Union{aspect, concrete-aspect} WITHIN THIS SOLE aop.xml
-******************************************************************************************************************************-->
-<!ELEMENT aspects (
-    (aspect | exclude | include | concrete-aspect)*
-)>
-<!--*****************************************************************************************************************************
-aspect
-*********************************************************************************************************************************
-[aspect] defines an aspect to include
-    @name   FQN of the aspect, nested class must use $
-******************************************************************************************************************************-->
-<!ELEMENT aspect EMPTY>
-<!ATTLIST aspect
-    name CDATA #REQUIRED
->
-<!--*****************************************************************************************************************************
-exclude
-*********************************************************************************************************************************
-[exclude] defines a set of aspect to exclude
-    @within within pattern (even from other systems / parent classloader)
-SAME AS FOR weaver/exclude
-******************************************************************************************************************************-->
-<!--*****************************************************************************************************************************
-concrete-aspect
-*********************************************************************************************************************************
-[concrete-aspect] defines a concrete aspect from an abstract one
-    @name   FQN of the concrete aspect (use $ for nested class) [will be jit generated]
-    @extends FQN of the abstract aspect (use $ for nested class)
-******************************************************************************************************************************-->
-<!ELEMENT concrete-aspect (
-    pointcut+
-)>
-<!ATTLIST concrete-aspect
-    name CDATA #REQUIRED
-    extends CDATA #REQUIRED
-    precedence CDATA #IMPLIED
-    perclause CDATA #IMPLIED
->
-<!--*****************************************************************************************************************************
-pointcut
-*********************************************************************************************************************************
-[pointcut] defines a concrete pointcut within a concrete aspect from an abstract one
-    @name   name of the abstract pointcut (method name, unique in aspect class hierarchy)
-    @expression pointcut expression
-        Note: for argument binding, the bounded arguments must be present and bounded:
-        <pointcut name="myAdvice(int i)" expression="... AND args(i)"/>
-        TODO: AND must be written that way and not with the "&&" symbol. Thus NOT and OR exists as well.
-******************************************************************************************************************************-->
-<!ELEMENT pointcut EMPTY>
-<!ATTLIST pointcut
-    name CDATA #REQUIRED
-    expression CDATA #REQUIRED
->
@@ -1,147 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2005 Contributors.
- * All rights reserved.
- * This program and the accompanying materials are made available
- * under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution and is available at
- * http://eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *   Alexandre Vasseur         initial implementation
- *******************************************************************************/
-package org.aspectj.weaver.loadtime.definition;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * A POJO that contains raw strings from the XML (sort of XMLBean for our simple LTW DTD)
- * 
- * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
- */
-public class Definition {
-
-	private final StringBuffer m_weaverOptions;
-
-	private final List m_dumpPatterns;
-
-	private boolean m_dumpBefore;
-	
-	private boolean perClassloaderDumpDir;
-
-	private final List m_includePatterns;
-
-	private final List m_excludePatterns;
-
-	private final List m_aspectClassNames;
-
-	private final List m_aspectExcludePatterns;
-
-	private final List m_aspectIncludePatterns;
-
-	private final List m_concreteAspects;
-
-	public Definition() {
-		m_weaverOptions = new StringBuffer();
-		m_dumpBefore = false;
-		perClassloaderDumpDir = false;
-		m_dumpPatterns = new ArrayList(0);
-		m_includePatterns = new ArrayList(0);
-		m_excludePatterns = new ArrayList(0);
-		m_aspectClassNames = new ArrayList();
-		m_aspectExcludePatterns = new ArrayList(0);
-		m_aspectIncludePatterns = new ArrayList(0);
-		m_concreteAspects = new ArrayList(0);
-	}
-
-	public String getWeaverOptions() {
-		return m_weaverOptions.toString();
-	}
-
-	public List getDumpPatterns() {
-		return m_dumpPatterns;
-	}
-
-	public void setDumpBefore(boolean b) {
-		m_dumpBefore = b;
-	}
-
-	public boolean shouldDumpBefore() {
-		return m_dumpBefore;
-	}
-
-	public void setCreateDumpDirPerClassloader(boolean b) {
-		perClassloaderDumpDir = b;
-	}
-
-	public boolean createDumpDirPerClassloader() {
-		return perClassloaderDumpDir;
-	}
-
-	public List getIncludePatterns() {
-		return m_includePatterns;
-	}
-
-	public List getExcludePatterns() {
-		return m_excludePatterns;
-	}
-
-	public List getAspectClassNames() {
-		return m_aspectClassNames;
-	}
-
-	public List getAspectExcludePatterns() {
-		return m_aspectExcludePatterns;
-	}
-
-	public List getAspectIncludePatterns() {
-		return m_aspectIncludePatterns;
-	}
-
-	public List getConcreteAspects() {
-		return m_concreteAspects;
-	}
-
-	public static class ConcreteAspect {
-		public final String name;
-		public final String extend;
-		public final String precedence;
-		public final List pointcuts;
-		public final String perclause;
-
-		public ConcreteAspect(String name, String extend) {
-			this(name, extend, null, null);
-		}
-
-		public ConcreteAspect(String name, String extend, String precedence, String perclause) {
-			this.name = name;
-			// make sure extend set to null if ""
-			if (extend == null || extend.length() == 0) {
-				this.extend = null;
-				if (precedence == null || precedence.length() == 0) {
-					throw new RuntimeException("Not allowed");
-				}
-			} else {
-				this.extend = extend;
-			}
-			this.precedence = precedence;
-			this.pointcuts = new ArrayList();
-			this.perclause = perclause;
-		}
-	}
-
-	public static class Pointcut {
-		public final String name;
-		public final String expression;
-
-		public Pointcut(String name, String expression) {
-			this.name = name;
-			this.expression = expression;
-		}
-	}
-
-	public void appendWeaverOptions(String option) {
-		m_weaverOptions.append(option.trim()).append(' ');
-	}
-
-}
@@ -1,272 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2005 Contributors.
- * All rights reserved.
- * This program and the accompanying materials are made available
- * under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution and is available at
- * http://eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *   Alexandre Vasseur         initial implementation
- *******************************************************************************/
-package org.aspectj.weaver.loadtime.definition;
-
-import java.io.InputStream;
-import java.net.URL;
-
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParserFactory;
-
-import org.aspectj.util.LangUtil;
-import org.xml.sax.Attributes;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-import org.xml.sax.SAXParseException;
-import org.xml.sax.XMLReader;
-import org.xml.sax.helpers.DefaultHandler;
-import org.xml.sax.helpers.XMLReaderFactory;
-
-/**
- * FIXME AV - doc, concrete aspect
- * 
- * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
- */
-public class DocumentParser extends DefaultHandler {
-
-	/**
-	 * The current DTD public id. The matching dtd will be searched as a resource.
-	 */
-	private final static String DTD_PUBLIC_ID = "-//AspectJ//DTD 1.5.0//EN";
-
-	/**
-	 * The DTD alias, for better user experience.
-	 */
-	private final static String DTD_PUBLIC_ID_ALIAS = "-//AspectJ//DTD//EN";
-
-	/**
-	 * A handler to the DTD stream so that we are only using one file descriptor
-	 */
-	private final static InputStream DTD_STREAM = DocumentParser.class.getResourceAsStream("/aspectj_1_5_0.dtd");
-
-	private final static String ASPECTJ_ELEMENT = "aspectj";
-	private final static String WEAVER_ELEMENT = "weaver";
-	private final static String DUMP_ELEMENT = "dump";
-	private final static String DUMP_BEFOREANDAFTER_ATTRIBUTE = "beforeandafter";
-	private final static String DUMP_PERCLASSLOADERDIR_ATTRIBUTE = "perclassloaderdumpdir";
-	private final static String INCLUDE_ELEMENT = "include";
-	private final static String EXCLUDE_ELEMENT = "exclude";
-	private final static String OPTIONS_ATTRIBUTE = "options";
-	private final static String ASPECTS_ELEMENT = "aspects";
-	private final static String ASPECT_ELEMENT = "aspect";
-	private final static String CONCRETE_ASPECT_ELEMENT = "concrete-aspect";
-	private final static String NAME_ATTRIBUTE = "name";
-	private final static String EXTEND_ATTRIBUTE = "extends";
-	private final static String PRECEDENCE_ATTRIBUTE = "precedence";
-	private final static String PERCLAUSE_ATTRIBUTE = "perclause";
-	private final static String POINTCUT_ELEMENT = "pointcut";
-	private final static String WITHIN_ATTRIBUTE = "within";
-	private final static String EXPRESSION_ATTRIBUTE = "expression";
-
-	private final Definition m_definition;
-
-	private boolean m_inAspectJ;
-	private boolean m_inWeaver;
-	private boolean m_inAspects;
-
-	private Definition.ConcreteAspect m_lastConcreteAspect;
-
-	private DocumentParser() {
-		m_definition = new Definition();
-	}
-
-	public static Definition parse(final URL url) throws Exception {
-		InputStream in = null;
-		try {
-			DocumentParser parser = new DocumentParser();
-
-			XMLReader xmlReader = getXMLReader();
-			xmlReader.setContentHandler(parser);
-			xmlReader.setErrorHandler(parser);
-
-			try {
-				xmlReader.setFeature("http://xml.org/sax/features/validation", false);
-			} catch (SAXException e) {
-				// fine, the parser don't do validation
-			}
-			try {
-				xmlReader.setFeature("http://xml.org/sax/features/external-general-entities", false);
-			} catch (SAXException e) {
-				// fine, the parser don't do validation
-			}
-			try {
-				xmlReader.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
-			} catch (SAXException e) {
-				// fine, the parser don't do validation
-			}
-
-			xmlReader.setEntityResolver(parser);
-			in = url.openStream();
-			xmlReader.parse(new InputSource(in));
-			return parser.m_definition;
-		} finally {
-			try {
-				in.close();
-			} catch (Throwable t) {
-
-			}
-		}
-	}
-
-	private static XMLReader getXMLReader() throws SAXException, ParserConfigurationException {
-		XMLReader xmlReader = null;
-
-		/* Try this first for Java 5 */
-		try {
-			xmlReader = XMLReaderFactory.createXMLReader();
-		}
-
-		/* .. and ignore "System property ... not set" and then try this instead */
-		catch (SAXException ex) {
-			xmlReader = SAXParserFactory.newInstance().newSAXParser().getXMLReader();
-		}
-		return xmlReader;
-	}
-
-	public InputSource resolveEntity(String publicId, String systemId) throws SAXException {
-		if (publicId.equals(DTD_PUBLIC_ID) || publicId.equals(DTD_PUBLIC_ID_ALIAS)) {
-			InputStream in = DTD_STREAM;
-			if (in == null) {
-				System.err.println("AspectJ - WARN - could not read DTD " + publicId);
-				return null;
-			} else {
-				return new InputSource(in);
-			}
-		} else {
-			System.err.println("AspectJ - WARN - unknown DTD " + publicId + " - consider using " + DTD_PUBLIC_ID);
-			return null;
-		}
-	}
-
-	public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
-		if (ASPECT_ELEMENT.equals(qName)) {
-			String name = attributes.getValue(NAME_ATTRIBUTE);
-			if (!isNull(name)) {
-				m_definition.getAspectClassNames().add(name);
-			}
-		} else if (WEAVER_ELEMENT.equals(qName)) {
-			String options = attributes.getValue(OPTIONS_ATTRIBUTE);
-			if (!isNull(options)) {
-				m_definition.appendWeaverOptions(options);
-			}
-			m_inWeaver = true;
-		} else if (CONCRETE_ASPECT_ELEMENT.equals(qName)) {
-			String name = attributes.getValue(NAME_ATTRIBUTE);
-			String extend = attributes.getValue(EXTEND_ATTRIBUTE);
-			String precedence = attributes.getValue(PRECEDENCE_ATTRIBUTE);
-			String perclause = attributes.getValue(PERCLAUSE_ATTRIBUTE);
-			if (!isNull(name)) {
-				m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend, precedence, perclause);
-				// if (isNull(precedence) && !isNull(extend)) {// if no precedence, then extends must be there
-				// m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend);
-				// } else if (!isNull(precedence)) {
-				// // wether a pure precedence def, or an extendsANDprecedence def.
-				// m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend, precedence, perclause);
-				// }
-				m_definition.getConcreteAspects().add(m_lastConcreteAspect);
-			}
-		} else if (POINTCUT_ELEMENT.equals(qName) && m_lastConcreteAspect != null) {
-			String name = attributes.getValue(NAME_ATTRIBUTE);
-			String expression = attributes.getValue(EXPRESSION_ATTRIBUTE);
-			if (!isNull(name) && !isNull(expression)) {
-				m_lastConcreteAspect.pointcuts.add(new Definition.Pointcut(name, replaceXmlAnd(expression)));
-			}
-		} else if (ASPECTJ_ELEMENT.equals(qName)) {
-			if (m_inAspectJ) {
-				throw new SAXException("Found nested <aspectj> element");
-			}
-			m_inAspectJ = true;
-		} else if (ASPECTS_ELEMENT.equals(qName)) {
-			m_inAspects = true;
-		} else if (INCLUDE_ELEMENT.equals(qName) && m_inWeaver) {
-			String typePattern = getWithinAttribute(attributes);
-			if (!isNull(typePattern)) {
-				m_definition.getIncludePatterns().add(typePattern);
-			}
-		} else if (EXCLUDE_ELEMENT.equals(qName) && m_inWeaver) {
-			String typePattern = getWithinAttribute(attributes);
-			if (!isNull(typePattern)) {
-				m_definition.getExcludePatterns().add(typePattern);
-			}
-		} else if (DUMP_ELEMENT.equals(qName) && m_inWeaver) {
-			String typePattern = getWithinAttribute(attributes);
-			if (!isNull(typePattern)) {
-				m_definition.getDumpPatterns().add(typePattern);
-			}
-			String beforeAndAfter = attributes.getValue(DUMP_BEFOREANDAFTER_ATTRIBUTE);
-			if (isTrue(beforeAndAfter)) {
-				m_definition.setDumpBefore(true);
-			}
-			String perWeaverDumpDir = attributes.getValue(DUMP_PERCLASSLOADERDIR_ATTRIBUTE);
-			if (isTrue(perWeaverDumpDir)) {
-				m_definition.setCreateDumpDirPerClassloader(true);
-			}
-		} else if (EXCLUDE_ELEMENT.equals(qName) && m_inAspects) {
-			String typePattern = getWithinAttribute(attributes);
-			if (!isNull(typePattern)) {
-				m_definition.getAspectExcludePatterns().add(typePattern);
-			}
-		} else if (INCLUDE_ELEMENT.equals(qName) && m_inAspects) {
-			String typePattern = getWithinAttribute(attributes);
-			if (!isNull(typePattern)) {
-				m_definition.getAspectIncludePatterns().add(typePattern);
-			}
-		} else {
-			throw new SAXException("Unknown element while parsing <aspectj> element: " + qName);
-		}
-		super.startElement(uri, localName, qName, attributes);
-	}
-
-	private String getWithinAttribute(Attributes attributes) {
-		return replaceXmlAnd(attributes.getValue(WITHIN_ATTRIBUTE));
-	}
-
-	public void endElement(String uri, String localName, String qName) throws SAXException {
-		if (CONCRETE_ASPECT_ELEMENT.equals(qName)) {
-			m_lastConcreteAspect = null;
-		} else if (ASPECTJ_ELEMENT.equals(qName)) {
-			m_inAspectJ = false;
-		} else if (WEAVER_ELEMENT.equals(qName)) {
-			m_inWeaver = false;
-		} else if (ASPECTS_ELEMENT.equals(qName)) {
-			m_inAspects = false;
-		}
-		super.endElement(uri, localName, qName);
-	}
-
-	// TODO AV - define what we want for XML parser error - for now stderr
-	public void warning(SAXParseException e) throws SAXException {
-		super.warning(e);
-	}
-
-	public void error(SAXParseException e) throws SAXException {
-		super.error(e);
-	}
-
-	public void fatalError(SAXParseException e) throws SAXException {
-		super.fatalError(e);
-	}
-
-	private static String replaceXmlAnd(String expression) {
-		// TODO AV do we need to handle "..)AND" or "AND(.." ?
-		return LangUtil.replace(expression, " AND ", " && ");
-	}
-
-	private boolean isNull(String s) {
-		return (s == null || s.length() <= 0);
-	}
-
-	private boolean isTrue(String s) {
-		return (s != null && s.equals("true"));
-	}
-
-}
@@ -0,0 +1,147 @@
+<!--*****************************************************************************************************************************
+/*******************************************************************************
+ * Copyright (c) 2005 Contributors.
+ * All rights reserved.
+ * This program and the accompanying materials are made available
+ * under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution and is available at
+ * http://eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Alexandre Vasseur         initial implementation
+ *******************************************************************************/
+AspectJ 5 DTD
+
+To use this DTD, start your defintion file with
+	<!DOCTYPE aspectj PUBLIC
+	    "-//AspectJ//DTD 1.5.0//EN"
+	    "http://.../dtd/aspectj_1_5_0.dtd">
+
+You can also use the "aliasing DTD" that matchs always the latest release of AspectJ
+<!DOCTYPE aspectj PUBLIC
+    "-//AspectJ//DTD//EN"
+    "http://.../dtd/aspectj.dtd">
+
+To not use this DTD, start your definition file with
+	<?xml version="1.0"?>
+
+******************************************************************************************************************************-->
+
+
+<!--*****************************************************************************************************************************
+aspectj
+*********************************************************************************************************************************
+[aspectj] defines the root element
+******************************************************************************************************************************-->
+<!ELEMENT aspectj (
+    weaver?,
+    aspects?
+)>
+<!--*****************************************************************************************************************************
+weaver
+*********************************************************************************************************************************
+[weaver] defines the weaver configuration
+@options defines a command like line of option
+    When multiple aspectj DD are found, the options are simply toggled
+    TODO: Note: the scope of the options can be ClassLoader aware but should be assumed JVM wide
+******************************************************************************************************************************-->
+<!ELEMENT weaver (
+    (include | exclude | dump)*
+)>
+<!ATTLIST weaver
+    options CDATA #IMPLIED
+>
+<!--*****************************************************************************************************************************
+include
+*********************************************************************************************************************************
+[include] narrows the scope of the weaver
+A class must be matched by ALL the include elements to be exposed to the weaver
+@within defines a type pattern
+    (it is not a startWith)
+******************************************************************************************************************************-->
+<!ELEMENT include EMPTY>
+<!ATTLIST include
+    within CDATA #REQUIRED
+>
+<!--*****************************************************************************************************************************
+exclude
+*********************************************************************************************************************************
+[exclude] narrows the scope of the weaver
+A class must be matched by NONE of the exclude elements to be exposed to the weaver
+@within defines a type pattern
+    (it is not a startWith)
+    TODO should it be called @from: "<exclude from=..>  instead of <exclude within=..>
+    TODO: AND must be written that way and not with the "&&" symbol. Thus NOT and OR exists as well.
+******************************************************************************************************************************-->
+<!ELEMENT exclude EMPTY>
+<!ATTLIST exclude
+    within CDATA #REQUIRED
+>
+<!--*****************************************************************************************************************************
+dump
+*********************************************************************************************************************************
+[dump] control post-weaving dump to the "./_dump" folder (debugging purpose only)
+@within defines a type pattern
+    (it is not a startWith)
+******************************************************************************************************************************-->
+<!ELEMENT dump EMPTY>
+<!ATTLIST dump
+    within CDATA #REQUIRED
+>
+<!--*****************************************************************************************************************************
+aspects
+*********************************************************************************************************************************
+[aspects] defines a set of aspects
+Note: include only include among Union{aspect, concrete-aspect} WITHIN THIS SOLE aop.xml
+******************************************************************************************************************************-->
+<!ELEMENT aspects (
+    (aspect | exclude | include | concrete-aspect)*
+)>
+<!--*****************************************************************************************************************************
+aspect
+*********************************************************************************************************************************
+[aspect] defines an aspect to include
+    @name   FQN of the aspect, nested class must use $
+******************************************************************************************************************************-->
+<!ELEMENT aspect EMPTY>
+<!ATTLIST aspect
+    name CDATA #REQUIRED
+>
+<!--*****************************************************************************************************************************
+exclude
+*********************************************************************************************************************************
+[exclude] defines a set of aspect to exclude
+    @within within pattern (even from other systems / parent classloader)
+SAME AS FOR weaver/exclude
+******************************************************************************************************************************-->
+<!--*****************************************************************************************************************************
+concrete-aspect
+*********************************************************************************************************************************
+[concrete-aspect] defines a concrete aspect from an abstract one
+    @name   FQN of the concrete aspect (use $ for nested class) [will be jit generated]
+    @extends FQN of the abstract aspect (use $ for nested class)
+******************************************************************************************************************************-->
+<!ELEMENT concrete-aspect (
+    pointcut+
+)>
+<!ATTLIST concrete-aspect
+    name CDATA #REQUIRED
+    extends CDATA #REQUIRED
+    precedence CDATA #IMPLIED
+    perclause CDATA #IMPLIED
+>
+<!--*****************************************************************************************************************************
+pointcut
+*********************************************************************************************************************************
+[pointcut] defines a concrete pointcut within a concrete aspect from an abstract one
+    @name   name of the abstract pointcut (method name, unique in aspect class hierarchy)
+    @expression pointcut expression
+        Note: for argument binding, the bounded arguments must be present and bounded:
+        <pointcut name="myAdvice(int i)" expression="... AND args(i)"/>
+        TODO: AND must be written that way and not with the "&&" symbol. Thus NOT and OR exists as well.
+******************************************************************************************************************************-->
+<!ELEMENT pointcut EMPTY>
+<!ATTLIST pointcut
+    name CDATA #REQUIRED
+    expression CDATA #REQUIRED
+>
@@ -0,0 +1,147 @@
+/*******************************************************************************
+ * Copyright (c) 2005 Contributors.
+ * All rights reserved.
+ * This program and the accompanying materials are made available
+ * under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution and is available at
+ * http://eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Alexandre Vasseur         initial implementation
+ *******************************************************************************/
+package org.aspectj.weaver.loadtime.definition;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A POJO that contains raw strings from the XML (sort of XMLBean for our simple LTW DTD)
+ * 
+ * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
+ */
+public class Definition {
+
+	private final StringBuffer m_weaverOptions;
+
+	private final List m_dumpPatterns;
+
+	private boolean m_dumpBefore;
+
+	private boolean perClassloaderDumpDir;
+
+	private final List m_includePatterns;
+
+	private final List m_excludePatterns;
+
+	private final List m_aspectClassNames;
+
+	private final List m_aspectExcludePatterns;
+
+	private final List m_aspectIncludePatterns;
+
+	private final List m_concreteAspects;
+
+	public Definition() {
+		m_weaverOptions = new StringBuffer();
+		m_dumpBefore = false;
+		perClassloaderDumpDir = false;
+		m_dumpPatterns = new ArrayList(0);
+		m_includePatterns = new ArrayList(0);
+		m_excludePatterns = new ArrayList(0);
+		m_aspectClassNames = new ArrayList();
+		m_aspectExcludePatterns = new ArrayList(0);
+		m_aspectIncludePatterns = new ArrayList(0);
+		m_concreteAspects = new ArrayList(0);
+	}
+
+	public String getWeaverOptions() {
+		return m_weaverOptions.toString();
+	}
+
+	public List getDumpPatterns() {
+		return m_dumpPatterns;
+	}
+
+	public void setDumpBefore(boolean b) {
+		m_dumpBefore = b;
+	}
+
+	public boolean shouldDumpBefore() {
+		return m_dumpBefore;
+	}
+
+	public void setCreateDumpDirPerClassloader(boolean b) {
+		perClassloaderDumpDir = b;
+	}
+
+	public boolean createDumpDirPerClassloader() {
+		return perClassloaderDumpDir;
+	}
+
+	public List getIncludePatterns() {
+		return m_includePatterns;
+	}
+
+	public List getExcludePatterns() {
+		return m_excludePatterns;
+	}
+
+	public List getAspectClassNames() {
+		return m_aspectClassNames;
+	}
+
+	public List getAspectExcludePatterns() {
+		return m_aspectExcludePatterns;
+	}
+
+	public List getAspectIncludePatterns() {
+		return m_aspectIncludePatterns;
+	}
+
+	public List getConcreteAspects() {
+		return m_concreteAspects;
+	}
+
+	public static class ConcreteAspect {
+		public final String name;
+		public final String extend;
+		public final String precedence;
+		public final List pointcuts;
+		public final String perclause;
+
+		public ConcreteAspect(String name, String extend) {
+			this(name, extend, null, null);
+		}
+
+		public ConcreteAspect(String name, String extend, String precedence, String perclause) {
+			this.name = name;
+			// make sure extend set to null if ""
+			if (extend == null || extend.length() == 0) {
+				this.extend = null;
+				if (precedence == null || precedence.length() == 0) {
+					throw new RuntimeException("Not allowed");
+				}
+			} else {
+				this.extend = extend;
+			}
+			this.precedence = precedence;
+			this.pointcuts = new ArrayList();
+			this.perclause = perclause;
+		}
+	}
+
+	public static class Pointcut {
+		public final String name;
+		public final String expression;
+
+		public Pointcut(String name, String expression) {
+			this.name = name;
+			this.expression = expression;
+		}
+	}
+
+	public void appendWeaverOptions(String option) {
+		m_weaverOptions.append(option.trim()).append(' ');
+	}
+
+}
@@ -0,0 +1,272 @@
+/*******************************************************************************
+ * Copyright (c) 2005 Contributors.
+ * All rights reserved.
+ * This program and the accompanying materials are made available
+ * under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution and is available at
+ * http://eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Alexandre Vasseur         initial implementation
+ *******************************************************************************/
+package org.aspectj.weaver.loadtime.definition;
+
+import java.io.InputStream;
+import java.net.URL;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.parsers.SAXParserFactory;
+
+import org.aspectj.util.LangUtil;
+import org.xml.sax.Attributes;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+import org.xml.sax.SAXParseException;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.DefaultHandler;
+import org.xml.sax.helpers.XMLReaderFactory;
+
+/**
+ * FIXME AV - doc, concrete aspect
+ * 
+ * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
+ */
+public class DocumentParser extends DefaultHandler {
+
+	/**
+	 * The current DTD public id. The matching dtd will be searched as a resource.
+	 */
+	private final static String DTD_PUBLIC_ID = "-//AspectJ//DTD 1.5.0//EN";
+
+	/**
+	 * The DTD alias, for better user experience.
+	 */
+	private final static String DTD_PUBLIC_ID_ALIAS = "-//AspectJ//DTD//EN";
+
+	/**
+	 * A handler to the DTD stream so that we are only using one file descriptor
+	 */
+	private final static InputStream DTD_STREAM = DocumentParser.class.getResourceAsStream("/aspectj_1_5_0.dtd");
+
+	private final static String ASPECTJ_ELEMENT = "aspectj";
+	private final static String WEAVER_ELEMENT = "weaver";
+	private final static String DUMP_ELEMENT = "dump";
+	private final static String DUMP_BEFOREANDAFTER_ATTRIBUTE = "beforeandafter";
+	private final static String DUMP_PERCLASSLOADERDIR_ATTRIBUTE = "perclassloaderdumpdir";
+	private final static String INCLUDE_ELEMENT = "include";
+	private final static String EXCLUDE_ELEMENT = "exclude";
+	private final static String OPTIONS_ATTRIBUTE = "options";
+	private final static String ASPECTS_ELEMENT = "aspects";
+	private final static String ASPECT_ELEMENT = "aspect";
+	private final static String CONCRETE_ASPECT_ELEMENT = "concrete-aspect";
+	private final static String NAME_ATTRIBUTE = "name";
+	private final static String EXTEND_ATTRIBUTE = "extends";
+	private final static String PRECEDENCE_ATTRIBUTE = "precedence";
+	private final static String PERCLAUSE_ATTRIBUTE = "perclause";
+	private final static String POINTCUT_ELEMENT = "pointcut";
+	private final static String WITHIN_ATTRIBUTE = "within";
+	private final static String EXPRESSION_ATTRIBUTE = "expression";
+
+	private final Definition m_definition;
+
+	private boolean m_inAspectJ;
+	private boolean m_inWeaver;
+	private boolean m_inAspects;
+
+	private Definition.ConcreteAspect m_lastConcreteAspect;
+
+	private DocumentParser() {
+		m_definition = new Definition();
+	}
+
+	public static Definition parse(final URL url) throws Exception {
+		InputStream in = null;
+		try {
+			DocumentParser parser = new DocumentParser();
+
+			XMLReader xmlReader = getXMLReader();
+			xmlReader.setContentHandler(parser);
+			xmlReader.setErrorHandler(parser);
+
+			try {
+				xmlReader.setFeature("http://xml.org/sax/features/validation", false);
+			} catch (SAXException e) {
+				// fine, the parser don't do validation
+			}
+			try {
+				xmlReader.setFeature("http://xml.org/sax/features/external-general-entities", false);
+			} catch (SAXException e) {
+				// fine, the parser don't do validation
+			}
+			try {
+				xmlReader.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
+			} catch (SAXException e) {
+				// fine, the parser don't do validation
+			}
+
+			xmlReader.setEntityResolver(parser);
+			in = url.openStream();
+			xmlReader.parse(new InputSource(in));
+			return parser.m_definition;
+		} finally {
+			try {
+				in.close();
+			} catch (Throwable t) {
+
+			}
+		}
+	}
+
+	private static XMLReader getXMLReader() throws SAXException, ParserConfigurationException {
+		XMLReader xmlReader = null;
+
+		/* Try this first for Java 5 */
+		try {
+			xmlReader = XMLReaderFactory.createXMLReader();
+		}
+
+		/* .. and ignore "System property ... not set" and then try this instead */
+		catch (SAXException ex) {
+			xmlReader = SAXParserFactory.newInstance().newSAXParser().getXMLReader();
+		}
+		return xmlReader;
+	}
+
+	public InputSource resolveEntity(String publicId, String systemId) throws SAXException {
+		if (publicId.equals(DTD_PUBLIC_ID) || publicId.equals(DTD_PUBLIC_ID_ALIAS)) {
+			InputStream in = DTD_STREAM;
+			if (in == null) {
+				System.err.println("AspectJ - WARN - could not read DTD " + publicId);
+				return null;
+			} else {
+				return new InputSource(in);
+			}
+		} else {
+			System.err.println("AspectJ - WARN - unknown DTD " + publicId + " - consider using " + DTD_PUBLIC_ID);
+			return null;
+		}
+	}
+
+	public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
+		if (ASPECT_ELEMENT.equals(qName)) {
+			String name = attributes.getValue(NAME_ATTRIBUTE);
+			if (!isNull(name)) {
+				m_definition.getAspectClassNames().add(name);
+			}
+		} else if (WEAVER_ELEMENT.equals(qName)) {
+			String options = attributes.getValue(OPTIONS_ATTRIBUTE);
+			if (!isNull(options)) {
+				m_definition.appendWeaverOptions(options);
+			}
+			m_inWeaver = true;
+		} else if (CONCRETE_ASPECT_ELEMENT.equals(qName)) {
+			String name = attributes.getValue(NAME_ATTRIBUTE);
+			String extend = attributes.getValue(EXTEND_ATTRIBUTE);
+			String precedence = attributes.getValue(PRECEDENCE_ATTRIBUTE);
+			String perclause = attributes.getValue(PERCLAUSE_ATTRIBUTE);
+			if (!isNull(name)) {
+				m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend, precedence, perclause);
+				// if (isNull(precedence) && !isNull(extend)) {// if no precedence, then extends must be there
+				// m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend);
+				// } else if (!isNull(precedence)) {
+				// // wether a pure precedence def, or an extendsANDprecedence def.
+				// m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend, precedence, perclause);
+				// }
+				m_definition.getConcreteAspects().add(m_lastConcreteAspect);
+			}
+		} else if (POINTCUT_ELEMENT.equals(qName) && m_lastConcreteAspect != null) {
+			String name = attributes.getValue(NAME_ATTRIBUTE);
+			String expression = attributes.getValue(EXPRESSION_ATTRIBUTE);
+			if (!isNull(name) && !isNull(expression)) {
+				m_lastConcreteAspect.pointcuts.add(new Definition.Pointcut(name, replaceXmlAnd(expression)));
+			}
+		} else if (ASPECTJ_ELEMENT.equals(qName)) {
+			if (m_inAspectJ) {
+				throw new SAXException("Found nested <aspectj> element");
+			}
+			m_inAspectJ = true;
+		} else if (ASPECTS_ELEMENT.equals(qName)) {
+			m_inAspects = true;
+		} else if (INCLUDE_ELEMENT.equals(qName) && m_inWeaver) {
+			String typePattern = getWithinAttribute(attributes);
+			if (!isNull(typePattern)) {
+				m_definition.getIncludePatterns().add(typePattern);
+			}
+		} else if (EXCLUDE_ELEMENT.equals(qName) && m_inWeaver) {
+			String typePattern = getWithinAttribute(attributes);
+			if (!isNull(typePattern)) {
+				m_definition.getExcludePatterns().add(typePattern);
+			}
+		} else if (DUMP_ELEMENT.equals(qName) && m_inWeaver) {
+			String typePattern = getWithinAttribute(attributes);
+			if (!isNull(typePattern)) {
+				m_definition.getDumpPatterns().add(typePattern);
+			}
+			String beforeAndAfter = attributes.getValue(DUMP_BEFOREANDAFTER_ATTRIBUTE);
+			if (isTrue(beforeAndAfter)) {
+				m_definition.setDumpBefore(true);
+			}
+			String perWeaverDumpDir = attributes.getValue(DUMP_PERCLASSLOADERDIR_ATTRIBUTE);
+			if (isTrue(perWeaverDumpDir)) {
+				m_definition.setCreateDumpDirPerClassloader(true);
+			}
+		} else if (EXCLUDE_ELEMENT.equals(qName) && m_inAspects) {
+			String typePattern = getWithinAttribute(attributes);
+			if (!isNull(typePattern)) {
+				m_definition.getAspectExcludePatterns().add(typePattern);
+			}
+		} else if (INCLUDE_ELEMENT.equals(qName) && m_inAspects) {
+			String typePattern = getWithinAttribute(attributes);
+			if (!isNull(typePattern)) {
+				m_definition.getAspectIncludePatterns().add(typePattern);
+			}
+		} else {
+			throw new SAXException("Unknown element while parsing <aspectj> element: " + qName);
+		}
+		super.startElement(uri, localName, qName, attributes);
+	}
+
+	private String getWithinAttribute(Attributes attributes) {
+		return replaceXmlAnd(attributes.getValue(WITHIN_ATTRIBUTE));
+	}
+
+	public void endElement(String uri, String localName, String qName) throws SAXException {
+		if (CONCRETE_ASPECT_ELEMENT.equals(qName)) {
+			m_lastConcreteAspect = null;
+		} else if (ASPECTJ_ELEMENT.equals(qName)) {
+			m_inAspectJ = false;
+		} else if (WEAVER_ELEMENT.equals(qName)) {
+			m_inWeaver = false;
+		} else if (ASPECTS_ELEMENT.equals(qName)) {
+			m_inAspects = false;
+		}
+		super.endElement(uri, localName, qName);
+	}
+
+	// TODO AV - define what we want for XML parser error - for now stderr
+	public void warning(SAXParseException e) throws SAXException {
+		super.warning(e);
+	}
+
+	public void error(SAXParseException e) throws SAXException {
+		super.error(e);
+	}
+
+	public void fatalError(SAXParseException e) throws SAXException {
+		super.fatalError(e);
+	}
+
+	private static String replaceXmlAnd(String expression) {
+		// TODO AV do we need to handle "..)AND" or "AND(.." ?
+		return LangUtil.replace(expression, " AND ", " && ");
+	}
+
+	private boolean isNull(String s) {
+		return (s == null || s.length() <= 0);
+	}
+
+	private boolean isTrue(String s) {
+		return (s != null && s.equals("true"));
+	}
+
+}
