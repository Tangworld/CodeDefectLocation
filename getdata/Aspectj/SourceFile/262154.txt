@@ -396,9 +396,9 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 		ResolvedMember[] pointcuts = getDeclaredPointcuts();
 		boolean sawError = false;
 		for (int i = 0, len = pointcuts.length; i < len; i++) {
-			if (pointcuts[i]==null) {
+			if (pointcuts[i] == null) {
 				// Something else is broken in this file and will be reported separately
-				continue; 
+				continue;
 			}
 			if (pointcuts[i].isAbstract()) {
 				if (!this.isAspect()) {
@@ -413,9 +413,9 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 			}
 
 			for (int j = i + 1; j < len; j++) {
-				if (pointcuts[j]==null) {
+				if (pointcuts[j] == null) {
 					// Something else is broken in this file and will be reported separately
-					continue; 
+					continue;
 				}
 				if (pointcuts[i].getName().equals(pointcuts[j].getName())) {
 					eclipseWorld().showMessage(IMessage.ERROR, "duplicate pointcut name: " + pointcuts[j].getName(),
@@ -463,13 +463,12 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 
 	public boolean isEnum() {
 		return (binding.getAccessFlags() & ACC_ENUM) != 0;
-		}
+	}
 
 	public boolean isAnnotation() {
 		return (binding.getAccessFlags() & ACC_ANNOTATION) != 0;
 	}
 
-
 	public boolean isAnnotationWithRuntimeRetention() {
 		if (!isAnnotation()) {
 			return false;
@@ -693,11 +692,10 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 		} else {
 			if (memberValuePairReturnType.isArrayType() && !defaultValueBinding.isArrayType()) {
 				if (constant != null && constant != Constant.NotAConstant) {
-					throw new MissingImplementationException(
-							"Please raise an AspectJ bug.  AspectJ does not know how to convert this annotation value ["
-									+ defaultValue + "]");
-					// generateElementValue(attributeOffset, defaultValue,
-					// constant, memberValuePairReturnType.leafComponentType());
+					// Testcase for this clause is MultiProjectIncrementalTests.testAnnotations_pr262154()
+					AnnotationValue av = EclipseAnnotationConvertor.generateElementValueForConstantExpression(defaultValue,
+							defaultValueBinding);
+					return new ArrayAnnotationValue(new AnnotationValue[] { av });
 				} else {
 					AnnotationValue av = generateElementValueForNonConstantExpression(defaultValue, defaultValueBinding);
 					return new ArrayAnnotationValue(new AnnotationValue[] { av });
@@ -0,0 +1,32 @@
+import java.util.Map;
+
+import org.aspectj.lang.annotation.AfterThrowing;
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.annotation.Pointcut;
+
+@Aspect
+//@Goo("abc")
+@SuppressWarnings("unchecked")
+public class DeliveryCallbackInterceptor {
+	@Pointcut("execution(boolean org.springframework.integration.message.MessageHandler+.handleMessage(Message))&& args(message)")
+	public void handleMethod(Message message) {
+	}
+
+	@AfterThrowing(pointcut = "handleMethod(message)", throwing = "e")
+	public void invokeDeliveryCallback(Message message, Throwable e) {
+		((DeliveryFailureCallback) message.getHeaders().get("errorcallback")).onDeliveryFailed(message, e);
+	}
+}
+
+class DeliveryFailureCallback {
+	public void onDeliveryFailed(Object o, Object p) {
+	}
+}
+
+class Message {
+	public Map<String, DeliveryFailureCallback> getHeaders() {
+		return null;
+	}
+}
+
+@interface Goo { String value(); }
@@ -0,0 +1,32 @@
+import java.util.Map;
+
+import org.aspectj.lang.annotation.AfterThrowing;
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.annotation.Pointcut;
+
+@Aspect
+//@Goo("abc")
+@SuppressWarnings("unchecked")
+public class DeliveryCallbackInterceptor {
+	@Pointcut("execution(boolean org.springframework.integration.message.MessageHandler+.handleMessage(Message))&& args(message)")
+	public void handleMethod(Message message) {
+	}
+
+	@AfterThrowing(pointcut = "handleMethod(message, e)", throwing = "e")
+	public void invokeDeliveryCallback(Message message, Throwable e) {
+		((DeliveryFailureCallback) message.getHeaders().get("errorcallback")).onDeliveryFailed(message, e);
+	}
+}
+
+class DeliveryFailureCallback {
+	public void onDeliveryFailed(Object o, Object p) {
+	}
+}
+
+class Message {
+	public Map<String, DeliveryFailureCallback> getHeaders() {
+		return null;
+	}
+}
+
+@interface Goo { String value(); }
@@ -244,6 +244,17 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		assertEquals("=BrokenHandles<p{GetInfo.java}GetInfo`declare parents!3", ipe.getHandleIdentifier());
 	}
 
+	public void testAnnotations_pr262154() {
+		String p = "pr262154";
+		initialiseProject(p);
+		build(p);
+		checkWasFullBuild();
+		alter(p, "inc1");
+		build(p);
+		List l = getCompilerErrorMessages(p);
+		assertEquals("Unexpected compiler error", 0, l.size());
+	}
+
 	public void testAnnotations_pr255555() {
 		String p = "pr255555";
 		initialiseProject(p);
@@ -261,8 +272,8 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 	}
 
 	/**
-	 * Test what is in the model for package declarations and import statements.  Package Declaration nodes are new
-	 * in AspectJ 1.6.4.  Import statements are contained with an 'import references' node.
+	 * Test what is in the model for package declarations and import statements. Package Declaration nodes are new in AspectJ 1.6.4.
+	 * Import statements are contained with an 'import references' node.
 	 */
 	public void testImportHandles() {
 		String p = "Imports";
@@ -270,21 +281,20 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		build(p);
 
 		IProgramElement root = getModelFor(p).getHierarchy().getRoot();
-		
+
 		// Looking for 'package p.q'
 		IProgramElement ipe = findElementAtLine(root, 1);
-		ipe = (IProgramElement)ipe.getChildren().get(0); // package decl is first entry in the type
-		System.out.println(ipe.getHandleIdentifier()+"  "+ipe.getKind());
+		ipe = (IProgramElement) ipe.getChildren().get(0); // package decl is first entry in the type
+		System.out.println(ipe.getHandleIdentifier() + "  " + ipe.getKind());
 		assertEquals(IProgramElement.Kind.PACKAGE_DECLARATION, ipe.getKind());
 		assertEquals("=Imports<p.q*Example.aj%p.q", ipe.getHandleIdentifier());
 		assertEquals("package p.q;", ipe.getSourceSignature());
-		assertEquals(ipe.getSourceLocation().getOffset(),8); // "package p.q" - location of p.q
+		assertEquals(ipe.getSourceLocation().getOffset(), 8); // "package p.q" - location of p.q
 
-		
 		// Looking for import containing containing string and integer
 		ipe = findElementAtLine(root, 3); // first import
 		ipe = ipe.getParent(); // imports container
-		System.out.println(ipe.getHandleIdentifier()+"  "+ipe.getKind());
+		System.out.println(ipe.getHandleIdentifier() + "  " + ipe.getKind());
 		dumptree(getModelFor(p).getHierarchy().getRoot(), 0);
 		assertEquals("=Imports<p.q*Example.aj#", ipe.getHandleIdentifier());
 	}
@@ -384,7 +394,6 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		checkWasntFullBuild();
 	}
 
-
 	public void testIncrementalBuildsWithItds_pr259528() {
 		String p = "pr259528";
 		AjdeInteractionTestbed.VERBOSE = true;
