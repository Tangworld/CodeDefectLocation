@@ -115,6 +115,7 @@ public class AjdeCoreBuildManager {
 					buildConfig = ajBuildManager.getState().getBuildConfig();
 					buildConfig.setChanged(changes); // pass it through for the state to use it when making decisions
 					buildConfig.setModifiedFiles(compilerConfig.getProjectSourceFilesChanged());
+					buildConfig.setClasspathElementsWithModifiedContents(compilerConfig.getClasspathElementsWithModifiedContents());
 					compilerConfig.configurationRead();
 				}
 				ajBuildManager.incrementalBuild(buildConfig, msgHandlerAdapter);
@@ -54,6 +54,7 @@ public class AjBuildConfig implements CompilerConfigurationChangeFlags {
 	private List/* File */aspectpath = new ArrayList();
 	private List/* String */classpath = new ArrayList();
 	private List/* String */bootclasspath = new ArrayList();
+	private List/* String */cpElementsWithModifiedContents = new ArrayList();
 
 	private File configFile;
 	private String lintMode = AJLINT_DEFAULT;
@@ -659,4 +660,12 @@ public class AjBuildConfig implements CompilerConfigurationChangeFlags {
 	public List getModifiedFiles() {
 		return this.changedFiles;
 	}
+
+	public void setClasspathElementsWithModifiedContents(List cpElementsWithModifiedContents) {
+		this.cpElementsWithModifiedContents = cpElementsWithModifiedContents;
+	}
+
+	public List getClasspathElementsWithModifiedContents() {
+		return this.cpElementsWithModifiedContents;
+	}
 }
@@ -60,6 +60,9 @@ import org.aspectj.weaver.bcel.UnwovenClassFile;
  */
 public class AjState implements CompilerConfigurationChangeFlags {
 
+	// SECRETAPI configures whether we use state instead of lastModTime - see pr245566
+	public static boolean CHECK_STATE_FIRST = false;
+
 	// SECRETAPI static so beware of multi-threading bugs...
 	public static IStateListener stateListener = null;
 
@@ -422,41 +425,60 @@ public class AjState implements CompilerConfigurationChangeFlags {
 
 		for (Iterator iterator = classFiles.iterator(); iterator.hasNext();) {
 			File classFile = (File) iterator.next();
-			long modTime = classFile.lastModified();
-			if ((modTime + 1000) >= lastSuccessfulBuildTime) {
-				// so the class on disk has changed since the last successful build for this state object
-
-				// BUG? we stop on the first change that leads us to an incremental build, surely we need to continue and look
-				// at all files incase another change means we need to incremental a bit more stuff?
-
-				// To work out if it is a real change we should ask any state
-				// object managing the output location whether the file has
-				// structurally changed or not
-				if (state != null) {
-					if (state.isAspect(classFile)) {
-						return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;
+			if (CHECK_STATE_FIRST && state != null) {
+				if (state.isAspect(classFile)) {
+					return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;
+				}
+				if (state.hasStructuralChangedSince(classFile, lastSuccessfulBuildTime)) {
+					if (listenerDefined()) {
+						getListener().recordDecision("Structural change detected in : " + classFile);
 					}
-					if (state.hasStructuralChangedSince(classFile, lastSuccessfulBuildTime)) {
-						if (listenerDefined()) {
-							getListener().recordDecision("Structural change detected in : " + classFile);
-						}
 
-						if (isTypeWeReferTo(classFile)) {
-							if (affectedFiles.size() > MAX_AFFECTED_FILES_BEFORE_FULL_BUILD)
-								return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;
-						}
-					} else {
-						if (listenerDefined())
-							getListener().recordDecision("Change detected in " + classFile + " but it is not structural");
-					}
-				} else {
-					// No state object to ask, so it only matters if we know which type depends on this file
 					if (isTypeWeReferTo(classFile)) {
 						if (affectedFiles.size() > MAX_AFFECTED_FILES_BEFORE_FULL_BUILD)
 							return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;
-						return CLASS_FILE_CHANGED_THAT_NEEDS_INCREMENTAL_BUILD;
+					}
+					// } else {
+					// if (listenerDefined())
+					// getListener().recordDecision("Change detected in " + classFile + " but it is not structural");
+				}
+			} else {
+				long modTime = classFile.lastModified();
+				if ((modTime + 1000) >= lastSuccessfulBuildTime) {
+					// so the class on disk has changed since the last successful build for this state object
+
+					// BUG? we stop on the first change that leads us to an incremental build, surely we need to continue and look
+					// at all files incase another change means we need to incremental a bit more stuff?
+
+					// To work out if it is a real change we should ask any state
+					// object managing the output location whether the file has
+					// structurally changed or not
+					if (state != null) {
+						if (state.isAspect(classFile)) {
+							return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;
+						}
+						if (state.hasStructuralChangedSince(classFile, lastSuccessfulBuildTime)) {
+							if (listenerDefined()) {
+								getListener().recordDecision("Structural change detected in : " + classFile);
+							}
+
+							if (isTypeWeReferTo(classFile)) {
+								if (affectedFiles.size() > MAX_AFFECTED_FILES_BEFORE_FULL_BUILD)
+									return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;
+							}
+						} else {
+							if (listenerDefined())
+								getListener().recordDecision("Change detected in " + classFile + " but it is not structural");
+						}
 					} else {
-						return CLASS_FILE_NO_CHANGES;
+						// No state object to ask, so it only matters if we know which type depends on this file
+						if (isTypeWeReferTo(classFile)) {
+							if (affectedFiles.size() > MAX_AFFECTED_FILES_BEFORE_FULL_BUILD)
+								return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;
+							return CLASS_FILE_CHANGED_THAT_NEEDS_INCREMENTAL_BUILD;
+						} else {
+							return CLASS_FILE_NO_CHANGES;
+						}
 					}
 				}
 			}
@@ -465,8 +487,9 @@ public class AjState implements CompilerConfigurationChangeFlags {
 	}
 
 	private boolean isAspect(File file) {
-		if (aspectsFromFileNames == null)
+		if (aspectsFromFileNames == null) {
 			return false;
+		}
 		return aspectsFromFileNames.containsKey(file);
 	}
 
@@ -678,27 +701,43 @@ public class AjState implements CompilerConfigurationChangeFlags {
 		if ((changes & (CLASSPATH_CHANGED | ASPECTPATH_CHANGED | INPATH_CHANGED | OUTPUTDESTINATIONS_CHANGED | INJARS_CHANGED)) != 0) {
 			List oldOutputLocs = getOutputLocations(previousConfig);
 
+			Set alreadyAnalysedPaths = new HashSet();
+
 			List oldClasspath = previousConfig.getClasspath();
 			List newClasspath = newConfig.getClasspath();
 			if (stateListener != null)
 				stateListener.aboutToCompareClasspaths(oldClasspath, newClasspath);
-			if (changedAndNeedsFullBuild(oldClasspath, newClasspath, true, oldOutputLocs))
+			if (classpathChangedAndNeedsFullBuild(oldClasspath, newClasspath, true, oldOutputLocs, alreadyAnalysedPaths))
 				return true;
 
 			List oldAspectpath = previousConfig.getAspectpath();
 			List newAspectpath = newConfig.getAspectpath();
-			if (changedAndNeedsFullBuild(oldAspectpath, newAspectpath, true, oldOutputLocs))
+			if (changedAndNeedsFullBuild(oldAspectpath, newAspectpath, true, oldOutputLocs, alreadyAnalysedPaths))
 				return true;
 
 			List oldInPath = previousConfig.getInpath();
 			List newInPath = newConfig.getInpath();
-			if (changedAndNeedsFullBuild(oldInPath, newInPath, false, oldOutputLocs))
+			if (changedAndNeedsFullBuild(oldInPath, newInPath, false, oldOutputLocs, alreadyAnalysedPaths))
 				return true;
 
 			List oldInJars = previousConfig.getInJars();
 			List newInJars = newConfig.getInJars();
-			if (changedAndNeedsFullBuild(oldInJars, newInJars, false, oldOutputLocs))
+			if (changedAndNeedsFullBuild(oldInJars, newInJars, false, oldOutputLocs, alreadyAnalysedPaths))
 				return true;
+		} else if (newConfig.getClasspathElementsWithModifiedContents() != null) {
+			// Although the classpath entries themselves are the same as before, the contents of one of the
+			// directories on the classpath has changed - rather than go digging around to find it, let's ask
+			// the compiler configuration. This will allow for projects with long classpaths where classpaths
+			// are also capturing project dependencies - when a project we depend on is rebuilt, we can just check
+			// it as a standalone element on our classpath rather than going through them all
+			List/* String */modifiedCpElements = newConfig.getClasspathElementsWithModifiedContents();
+			for (Iterator iterator = modifiedCpElements.iterator(); iterator.hasNext();) {
+				File cpDir = new File((String) iterator.next());
+				int classFileChanges = classFileChangedInDirSinceLastBuildRequiringFullBuild(cpDir);
+				if (classFileChanges == CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD) {
+					return true;
+				}
+			}
 		}
 
 		return false;
@@ -747,17 +786,17 @@ public class AjState implements CompilerConfigurationChangeFlags {
 	 * @param outputLocs the output locations that should be ignored if they occur on the paths being compared
 	 * @return true if a change is detected that requires a full build
 	 */
-	private boolean changedAndNeedsFullBuild(List oldPath, List newPath, boolean checkClassFiles, List outputLocs) {
-		if (oldPath == null) {
-			oldPath = new ArrayList();
-		}
-		if (newPath == null) {
-			newPath = new ArrayList();
-		}
+	private boolean changedAndNeedsFullBuild(List oldPath, List newPath, boolean checkClassFiles, List outputLocs,
+			Set alreadyAnalysedPaths) {
+		// if (oldPath == null) {
+		// oldPath = new ArrayList();
+		// }
+		// if (newPath == null) {
+		// newPath = new ArrayList();
+		// }
 		if (oldPath.size() != newPath.size()) {
 			return true;
 		}
-		Set analysedPaths = new HashSet();
 		for (int i = 0; i < oldPath.size(); i++) {
 			if (!oldPath.get(i).equals(newPath.get(i))) {
 				return true;
@@ -780,19 +819,75 @@ public class AjState implements CompilerConfigurationChangeFlags {
 				// that should save a massive amount of processing for incremental builds in a multi project scenario
 
 				boolean foundMatch = false;
-				for (Iterator iterator = outputLocs.iterator(); iterator.hasNext();) {
+				for (Iterator iterator = outputLocs.iterator(); !foundMatch && iterator.hasNext();) {
+					File dir = (File) iterator.next();
+					if (f.equals(dir)) {
+						foundMatch = true;
+					}
+				}
+				if (!foundMatch) {
+					if (!alreadyAnalysedPaths.contains(f.getAbsolutePath())) { // Do not check paths more than once
+						alreadyAnalysedPaths.add(f.getAbsolutePath());
+						int classFileChanges = classFileChangedInDirSinceLastBuildRequiringFullBuild(f);
+						if (classFileChanges == CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD)
+							return true;
+					}
+				}
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Check the old and new paths, if they vary by length or individual elements then that is considered a change. Or if the last
+	 * modified time of a path entry has changed (or last modified time of a classfile in that path entry has changed) then return
+	 * true. The outputlocations are supplied so they can be 'ignored' in the comparison.
+	 * 
+	 * @param oldPath
+	 * @param newPath
+	 * @param checkClassFiles whether to examine individual class files within directories
+	 * @param outputLocs the output locations that should be ignored if they occur on the paths being compared
+	 * @return true if a change is detected that requires a full build
+	 */
+	private boolean classpathChangedAndNeedsFullBuild(List oldPath, List newPath, boolean checkClassFiles, List outputLocs,
+			Set alreadyAnalysedPaths) {
+		// if (oldPath == null) {
+		// oldPath = new ArrayList();
+		// }
+		// if (newPath == null) {
+		// newPath = new ArrayList();
+		// }
+		if (oldPath.size() != newPath.size()) {
+			return true;
+		}
+		for (int i = 0; i < oldPath.size(); i++) {
+			if (!oldPath.get(i).equals(newPath.get(i))) {
+				return true;
+			}
+			File f = new File((String) oldPath.get(i));
+			if (f.exists() && !f.isDirectory() && (f.lastModified() >= lastSuccessfulBuildTime)) {
+				return true;
+			}
+			if (checkClassFiles && f.exists() && f.isDirectory()) {
+
+				// We should use here a list/set of directories we know have or have not changed - some kind of
+				// List<File> buildConfig.getClasspathEntriesWithChangedContents()
+				// and then only proceed to look inside directories if it is one of these, ignoring others -
+				// that should save a massive amount of processing for incremental builds in a multi project scenario
+
+				boolean foundMatch = false;
+				for (Iterator iterator = outputLocs.iterator(); !foundMatch && iterator.hasNext();) {
 					File dir = (File) iterator.next();
 					if (f.equals(dir)) {
 						foundMatch = true;
 					}
 				}
 				if (!foundMatch) {
-					if (!analysedPaths.contains(f.getAbsolutePath())) { // Do not check paths more than once
-						analysedPaths.add(f.getAbsolutePath());
+					if (!alreadyAnalysedPaths.contains(f.getAbsolutePath())) { // Do not check paths more than once
+						alreadyAnalysedPaths.add(f.getAbsolutePath());
 						int classFileChanges = classFileChangedInDirSinceLastBuildRequiringFullBuild(f);
 						if (classFileChanges == CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD)
 							return true;
-						// if (b && stateListener!=null) stateListener.detectedClassChangeInThisDir(f);
 					}
 				}
 			}
@@ -65,6 +65,11 @@ public class AjdeInteractionTestbed extends TestCase {
 		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).addProjectSourceFileChanged(changedFile);
 	}
 
+	public void addClasspathEntryChanged(String projectName, String changedDir) {
+		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
+		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).addClasspathEntryChanged(changedDir);
+	}
+
 	public void configureNonStandardCompileOptions(String projectName, String options) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
 		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).setNonStandardOptions(options);
@@ -13,6 +13,8 @@ package org.aspectj.systemtest.incremental.tools;
 import java.io.File;
 import java.io.IOException;
 
+import org.aspectj.ajde.core.ICompilerConfiguration;
+
 /**
  * Testing the performance of incremental compilation as it would be in AJDT.
  * 
@@ -90,9 +92,52 @@ public class IncrementalPerformanceTests extends AbstractMultiProjectIncremental
 		assertTrue(whitespacechangeDoTellCompiler < fullbuildtime);
 
 		assertTrue(nochangebuild < whitespacechangeDontTellCompiler);
-		assertTrue(nochangebuild < whitespacechangeDoTellCompiler);
+		// assertTrue(nochangebuild < whitespacechangeDoTellCompiler);
+
+		// assertTrue(whitespacechangeDoTellCompiler < whitespacechangeDontTellCompiler);
+	}
+
+	/**
+	 * Project dependencies are captured by using classpath. The dependee project has the bin folder for the project upon which it
+	 * depends on its classpath. This can make it expensive when determining whether to build the dependee project as we may need to
+	 * analyse all the classpath entries, we don't know which are project related. However, a new API in ICompilerConfiguration
+	 * called getClasspathElementsWithModifiedContents() can be returned by an implementor to tell us which parts of the classpath
+	 * to check.
+	 */
+	public void testBuildingTwoProjects() {
+		AjdeInteractionTestbed.VERBOSE = true;
+
+		String projA = "Proj64";
+		String projB = "Dependee";
+
+		// A full build:
+		initialiseProject(projA);
+		initialiseProject(projB);
+		configureNewProjectDependency(projB, projA);
+		build(projA);
+		checkWasFullBuild();
+		build(projB);
+		checkWasFullBuild();
+
+		alter(projA, "C43changeOne"); // C43 made package private
+		build(projA);
+		setNextChangeResponse(projB, ICompilerConfiguration.EVERYTHING);
+		build(projB);
+		long timeTakenWhenFullyAnalysingClasspath = getTimeTakenForBuild(projB);
+		checkWasntFullBuild();
+
+		alter(projA, "C43changeOne"); // C43 made package private
+		build(projA);
+		addClasspathEntryChanged(projB, getProjectRelativePath(projA, "bin").getPath());
+		// waitForReturn();
+		build(projB);
+		long timeTakenWhenFullyToldSpecifically = getTimeTakenForBuild(projB);
+		// waitFor10();
+		checkWasntFullBuild();
+
+		System.out.println("Without: " + timeTakenWhenFullyAnalysingClasspath + "ms   With: " + timeTakenWhenFullyToldSpecifically
+				+ "ms");
 
-//		assertTrue(whitespacechangeDoTellCompiler < whitespacechangeDontTellCompiler);
 	}
 
 	// --- helper code ---
@@ -39,6 +39,7 @@ public class MultiProjTestCompilerConfiguration implements ICompilerConfiguratio
 	private String outjar;
 	private String nonstandardoptions;
 	private List modifiedFiles;
+	private List modifiedDirs;
 	private List projectSourceFiles = new ArrayList();
 	private String projectPath;
 
@@ -182,6 +183,15 @@ public class MultiProjTestCompilerConfiguration implements ICompilerConfiguratio
 		}
 	}
 
+	public void addClasspathEntryChanged(String f) {
+		if (this.modifiedDirs == null) {
+			this.modifiedDirs = new ArrayList();
+		}
+		if (f != null) {
+			modifiedDirs.add(f);
+		}
+	}
+
 	public void setSourcePathResources(Map sourcePathResources) {
 		this.sourcePathResources = sourcePathResources;
 		this.changed |= ICompilerConfiguration.PROJECTSOURCERESOURCES_CHANGED;
@@ -204,6 +214,11 @@ public class MultiProjTestCompilerConfiguration implements ICompilerConfiguratio
 	public void configurationRead() {
 		changed = NO_CHANGES;
 		modifiedFiles = null;
+		modifiedDirs = null;
+	}
+
+	public List getClasspathElementsWithModifiedContents() {
+		return modifiedDirs;
 	}
 
 }
@@ -356,6 +356,11 @@ class MyCompilerConfig implements ICompilerConfiguration {
 	public int getConfigurationChanges() {
 		return ICompilerConfiguration.EVERYTHING;
 	}
+
+	public List getClasspathElementsWithModifiedContents() {
+		return null;
+	}
+
 }
 
 class MyOutputLocationManager implements IOutputLocationManager {
@@ -379,5 +384,4 @@ class MyOutputLocationManager implements IOutputLocationManager {
 	public String getUniqueIdentifier() {
 		return null;
 	}
-
 }
@@ -158,4 +158,8 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 		return ICompilerConfiguration.EVERYTHING;
 	}
 
+	public List getClasspathElementsWithModifiedContents() {
+		return null;
+	}
+
 }
@@ -106,4 +106,16 @@ public interface ICompilerConfiguration extends CompilerConfigurationChangeFlags
 	 */
 	public void configurationRead();
 
+	/**
+	 * Return a List (Strings) of the directory elements on the classpath that are likely to contain modified .class files since the
+	 * previous build and must be checked. This would be used in the situation where a project has a dependency on another project
+	 * and the dependency is captured by inclusion of one project on the classpath for the other. When the first project is built,
+	 * we need to check the classpath element on the second projects classpath that represents the bin folder of the first project.
+	 * By explicitly returning a list here we can avoid checking EVERYTHING.
+	 * 
+	 * @return a list of modified elements that should be checked (can be empty) or null if unknown (and in which case every
+	 *         classpath element will be checked)
+	 */
+	public List getClasspathElementsWithModifiedContents();
+
 }
@@ -102,4 +102,8 @@ public class BrowserCompilerConfiguration implements ICompilerConfiguration {
 
 	public void configurationRead() {
 	}
+
+	public List getClasspathElementsWithModifiedContents() {
+		return null;
+	}
 }
@@ -161,4 +161,8 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 		return ICompilerConfiguration.EVERYTHING;
 	}
 
+	public List getClasspathElementsWithModifiedContents() {
+		return null;
+	}
+
 }
@@ -51,6 +51,8 @@ public class IncrementalPerformanceTests extends AbstractMultiProjectIncremental
 		long nochangebuild = getTimeTakenForBuild(proj);
 		System.out.println("Incr build time for no changes at all: " + nochangebuild + "ms");
 
+		// An incremental build with no source file changes at all *and* we tell the compiler there are
+		// no source changes (so it doesn't need to check timestamps). super fast
 		addProjectSourceFileChanged(proj, null);
 		build(proj);
 		checkWasntFullBuild();
@@ -374,6 +374,12 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 		return ret;
 	}
 
+	/**
+	 * Open an output jar file in which to write the compiler output.
+	 * 
+	 * @param outJar the jar file to open
+	 * @return true if successful
+	 */
 	private boolean openOutputStream(File outJar) {
 		try {
 			OutputStream os = FileUtil.makeOutputStream(buildConfig.getOutputJar());
@@ -389,8 +395,9 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 
 	private void closeOutputStream(File outJar) {
 		try {
-			if (zos != null)
+			if (zos != null) {
 				zos.close();
+			}
 			zos = null;
 
 			/* Ensure we don't write an incomplete JAR bug-71339 */
@@ -856,37 +863,11 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 		}
 	}
 
-	// public boolean weaveAndGenerateClassFiles() throws IOException {
-	// handler.handleMessage(MessageUtil.info("weaving"));
-	// if (progressListener != null) progressListener.setText("weaving aspects");
-	// bcelWeaver.setProgressListener(progressListener, 0.5, 0.5/state.addedClassFiles.size());
-	// //!!! doesn't provide intermediate progress during weaving
-	// // XXX add all aspects even during incremental builds?
-	// addAspectClassFilesToWeaver(state.addedClassFiles);
-	// if (buildConfig.isNoWeave()) {
-	// if (buildConfig.getOutputJar() != null) {
-	// bcelWeaver.dumpUnwoven(buildConfig.getOutputJar());
-	// } else {
-	// bcelWeaver.dumpUnwoven();
-	// bcelWeaver.dumpResourcesToOutPath();
-	// }
-	// } else {
-	// if (buildConfig.getOutputJar() != null) {
-	// bcelWeaver.weave(buildConfig.getOutputJar());
-	// } else {
-	// bcelWeaver.weave();
-	// bcelWeaver.dumpResourcesToOutPath();
-	// }
-	// }
-	// if (progressListener != null) progressListener.setProgress(1.0);
-	// return true;
-	// //return messageAdapter.getErrorCount() == 0; //!javaBuilder.notifier.anyErrors();
-	// }
-
 	public FileSystem getLibraryAccess(String[] classpaths, String[] filenames) {
 		String defaultEncoding = buildConfig.getOptions().defaultEncoding;
-		if ("".equals(defaultEncoding)) //$NON-NLS-1$
+		if ("".equals(defaultEncoding)) {//$NON-NLS-1$
 			defaultEncoding = null; //$NON-NLS-1$	
+		}
 		// Bug 46671: We need an array as long as the number of elements in the classpath - *even though* not every
 		// element of the classpath is likely to be a directory. If we ensure every element of the array is set to
 		// only look for BINARY, then we make sure that for any classpath element that is a directory, we won't build
@@ -938,36 +919,42 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 			sourceFileCount = files.size();
 			progressListener.setText("compiling source files");
 		}
-		// System.err.println("got files: " + files);
+
+		// Translate from strings to File objects
 		String[] filenames = new String[files.size()];
-		int ii = 0;
+		int idx = 0;
 		for (Iterator fIterator = files.iterator(); fIterator.hasNext();) {
 			File f = (File) fIterator.next();
-			filenames[ii++] = f.getPath();
+			filenames[idx++] = f.getPath();
 		}
 
-		List cps = buildConfig.getFullClasspath();
-		Dump.saveFullClasspath(cps);
-		String[] classpaths = new String[cps.size()];
-		for (int i = 0; i < cps.size(); i++) {
-			classpaths[i] = (String) cps.get(i);
+		environment = state.getNameEnvironment();
+
+		boolean environmentNeedsRebuilding = false;
+
+		// Might be a bit too cautious, but let us see how it goes
+		if (buildConfig.getChanged() != AjBuildConfig.NO_CHANGES) {
+			environmentNeedsRebuilding = true;
 		}
 
-		// System.out.println("compiling");
-		environment = getLibraryAccess(classpaths, filenames);
+		if (environment == null || environmentNeedsRebuilding) {
+			List cps = buildConfig.getFullClasspath();
+			Dump.saveFullClasspath(cps);
+			String[] classpaths = new String[cps.size()];
+			for (int i = 0; i < cps.size(); i++) {
+				classpaths[i] = (String) cps.get(i);
+			}
+			environment = new StatefulNameEnvironment(getLibraryAccess(classpaths, filenames), state.getClassNameToFileMap(), state);
+			state.setNameEnvironment(environment);
 
-		// if (!state.getClassNameToFileMap().isEmpty()) { // see pr133532 (disabled to state can be used to answer questions)
-		environment = new StatefulNameEnvironment(environment, state.getClassNameToFileMap(), state);
-		// }
+		}
 
 		org.aspectj.ajdt.internal.compiler.CompilerAdapter.setCompilerAdapterFactory(this);
 		org.aspectj.org.eclipse.jdt.internal.compiler.Compiler compiler = new org.aspectj.org.eclipse.jdt.internal.compiler.Compiler(
 				environment, DefaultErrorHandlingPolicies.proceedWithAllProblems(), buildConfig.getOptions().getMap(),
 				getBatchRequestor(), getProblemFactory());
 
-		CompilerOptions options = compiler.options;
-
-		options.produceReferenceInfo = true; // TODO turn off when not needed
+		compiler.options.produceReferenceInfo = true; // TODO turn off when not needed
 
 		try {
 			compiler.compile(getCompilationUnits(filenames));
@@ -977,8 +964,8 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 		// cleanup
 		org.aspectj.ajdt.internal.compiler.CompilerAdapter.setCompilerAdapterFactory(null);
 		AnonymousClassPublisher.aspectOf().setAnonymousClassCreationListener(null);
-		environment.cleanup();
-		environment = null;
+		// environment.cleanup();
+		// environment = null;
 	}
 
 	/*
@@ -44,6 +44,7 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.classfmt.ClassFormatExcepti
 import org.aspectj.org.eclipse.jdt.internal.compiler.env.IBinaryField;
 import org.aspectj.org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.aspectj.org.eclipse.jdt.internal.compiler.env.IBinaryType;
+import org.aspectj.org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
 import org.aspectj.org.eclipse.jdt.internal.core.builder.ReferenceCollection;
 import org.aspectj.org.eclipse.jdt.internal.core.builder.StringSet;
@@ -74,6 +75,7 @@ public class AjState implements CompilerConfigurationChangeFlags {
 
 	private AjBuildManager buildManager;
 	private boolean couldBeSubsequentIncrementalBuild = false;
+	private INameEnvironment nameEnvironment;
 
 	private IHierarchy structureModel;
 	private IRelationshipMap relmap;
@@ -1690,4 +1692,12 @@ public class AjState implements CompilerConfigurationChangeFlags {
 	public AjBuildManager getAjBuildManager() {
 		return buildManager;
 	}
+
+	public INameEnvironment getNameEnvironment() {
+		return this.nameEnvironment;
+	}
+
+	public void setNameEnvironment(INameEnvironment nameEnvironment) {
+		this.nameEnvironment = nameEnvironment;
+	}
 }
@@ -41,159 +41,156 @@ import org.aspectj.testing.harness.bridge.Globals;
 import org.aspectj.util.FileUtil;
 
 /**
- * This re-uses the same config file to setup ajde
- * so that recompiles appear to be of the same configuration.
+ * This re-uses the same config file to setup ajde so that recompiles appear to be of the same configuration.
+ * 
  * @since Java 1.3 (uses dynamic proxies)
  */
 public class CompileCommand implements ICommand {
-    // time out waiting for build at three minutes
-    long MAX_TIME = 180 * 1000;
-    // this proxy ignores calls
-    InvocationHandler proxy = new VoidInvocationHandler();
-    InvocationHandler loggingProxy = new LoggingInvocationHandler();
-    MyMessageHandler myHandler = new MyMessageHandler();
-    long endTime;
-    boolean buildNextFresh;
-    File tempDir;
-    
-    private AjCompiler compiler;
-
-    /**
-     * Clients call this before repeatCommand as a one-shot
-     * request for a full rebuild of the same configuration.  
-     * (Requires a downcast from ICommand to CompileCommand.)
-     */
-    public void buildNextFresh() {
-        buildNextFresh = true;
-    }
-
-    // --------- ICommand interface
-    public boolean runCommand(String[] args, IMessageHandler handler) {
-        setup(args);
-        myHandler.start();
-        long startTime = System.currentTimeMillis();
-        try {
-        	compiler.buildFresh();
-        } finally {
-            runCommandCleanup();
-        }
-        return !myHandler.hasError();
-    }
-
-    public boolean repeatCommand(IMessageHandler handler) {
-        myHandler.start();
-        long startTime = System.currentTimeMillis();
-        // System.err.println("recompiling...");
-        if (buildNextFresh) {
-            buildNextFresh = false;
-            compiler.buildFresh();
-        } else {
-        	compiler.build();
-        }
-        return !myHandler.hasError();
-    }
-    void runCommandCleanup() {
-        if (null != tempDir) {
-            FileUtil.deleteContents(tempDir);
-            tempDir.delete();
-        }
-    }
-
-    // set by build progress monitor when done
-    void setEndTime(long endTime) {
-        this.endTime = endTime;
-    }
-    
-    private void setup(String[] args) {
-        File config = writeConfig(args);
-        if (null == config) {
-            throw new Error("unable to write config file");
-        }
-        IBuildProgressMonitor buildProgressMonitor = new MyBuildProgressMonitor();
-        String classesDir = "../testing/bin/classes";
-        for (int i = 0; i < args.length; i++) {
-            if ("-d".equals(args[i]) && ((1 +i) < args.length)) {
-                classesDir = args[1 + i];
-                break;
-            }
-        }
-        MyCompilerConfig compilerConfig = new MyCompilerConfig();
-        compiler = new AjCompiler("blah",compilerConfig,buildProgressMonitor,myHandler);
-    }
-
-    private File writeConfig(String[] args) {
-        tempDir = FileUtil.getTempDir("CompileCommand");
-        File result = new File(tempDir, "config.lst");
-        OutputStream out = null;
-        try {
-            out = new FileOutputStream(result);
-            PrintStream outs = new PrintStream(out, true);
-            for (int i = 0; i < args.length; i++) {
-                outs.println(args[i]);
-            }
-            return result;
-        } catch (IOException e) {
-            return null;
-        } finally {
-            try {
-                out.close();
-            } catch (IOException e) {
-            }
-        }
-    }
-
-//    private Object makeLoggingProxy(Class interfac) {
-//        return Proxy.newProxyInstance(
-//            interfac.getClassLoader(),
-//            new Class[] { interfac },
-//            loggingProxy);
-//    }
-    
-    private Object makeProxy(Class interfac) {
-        return Proxy.newProxyInstance(
-            interfac.getClassLoader(),
-            new Class[] { interfac },
-            proxy);
-    }
+	// time out waiting for build at three minutes
+	long MAX_TIME = 180 * 1000;
+	// this proxy ignores calls
+	InvocationHandler proxy = new VoidInvocationHandler();
+	InvocationHandler loggingProxy = new LoggingInvocationHandler();
+	MyMessageHandler myHandler = new MyMessageHandler();
+	long endTime;
+	boolean buildNextFresh;
+	File tempDir;
+
+	private AjCompiler compiler;
+
+	/**
+	 * Clients call this before repeatCommand as a one-shot request for a full rebuild of the same configuration. (Requires a
+	 * downcast from ICommand to CompileCommand.)
+	 */
+	public void buildNextFresh() {
+		buildNextFresh = true;
+	}
+
+	// --------- ICommand interface
+	public boolean runCommand(String[] args, IMessageHandler handler) {
+		setup(args);
+		myHandler.start();
+		long startTime = System.currentTimeMillis();
+		try {
+			compiler.buildFresh();
+		} finally {
+			runCommandCleanup();
+		}
+		return !myHandler.hasError();
+	}
+
+	public boolean repeatCommand(IMessageHandler handler) {
+		myHandler.start();
+		long startTime = System.currentTimeMillis();
+		// System.err.println("recompiling...");
+		if (buildNextFresh) {
+			buildNextFresh = false;
+			compiler.buildFresh();
+		} else {
+			compiler.build();
+		}
+		return !myHandler.hasError();
+	}
+
+	void runCommandCleanup() {
+		if (null != tempDir) {
+			FileUtil.deleteContents(tempDir);
+			tempDir.delete();
+		}
+	}
+
+	// set by build progress monitor when done
+	void setEndTime(long endTime) {
+		this.endTime = endTime;
+	}
+
+	private void setup(String[] args) {
+		File config = writeConfig(args);
+		if (null == config) {
+			throw new Error("unable to write config file");
+		}
+		IBuildProgressMonitor buildProgressMonitor = new MyBuildProgressMonitor();
+		String classesDir = "../testing/bin/classes";
+		for (int i = 0; i < args.length; i++) {
+			if ("-d".equals(args[i]) && ((1 + i) < args.length)) {
+				classesDir = args[1 + i];
+				break;
+			}
+		}
+		MyCompilerConfig compilerConfig = new MyCompilerConfig();
+		compiler = new AjCompiler("blah", compilerConfig, buildProgressMonitor, myHandler);
+	}
+
+	private File writeConfig(String[] args) {
+		tempDir = FileUtil.getTempDir("CompileCommand");
+		File result = new File(tempDir, "config.lst");
+		OutputStream out = null;
+		try {
+			out = new FileOutputStream(result);
+			PrintStream outs = new PrintStream(out, true);
+			for (int i = 0; i < args.length; i++) {
+				outs.println(args[i]);
+			}
+			return result;
+		} catch (IOException e) {
+			return null;
+		} finally {
+			try {
+				out.close();
+			} catch (IOException e) {
+			}
+		}
+	}
+
+	// private Object makeLoggingProxy(Class interfac) {
+	// return Proxy.newProxyInstance(
+	// interfac.getClassLoader(),
+	// new Class[] { interfac },
+	// loggingProxy);
+	// }
+
+	private Object makeProxy(Class interfac) {
+		return Proxy.newProxyInstance(interfac.getClassLoader(), new Class[] { interfac }, proxy);
+	}
 }
 
 class MyMessageHandler implements IBuildMessageHandler {
 
-    boolean hasError;
-    boolean hasWarning;
-    
-    private MessageHandler messageHandler = new MessageHandler(false);
+	boolean hasError;
+	boolean hasWarning;
+
+	private MessageHandler messageHandler = new MessageHandler(false);
 
 	public boolean handleMessage(IMessage message) throws AbortException {
 		maintainHasWarning(message.getKind());
-        return messageHandler.handleMessage(message);
-	}
-	
-    private void maintainHasWarning(IMessage.Kind kind) {
-        if (!hasError) {
-            if (IMessage.ERROR.isSameOrLessThan(kind)) {
-                hasError = true;
-                hasWarning = true;
-            }
-        }
-        if (!hasWarning && IMessage.WARNING.isSameOrLessThan(kind)) {
-            hasWarning = true;
-        }
-    }
-    
-    public boolean hasWarning() {
-        return hasWarning;
-    }
-
-    public boolean hasError() {
-        return hasError;
-    }
-    
-    public void start() {
-    	hasWarning = false;
-    	hasError = false;
-    	messageHandler.init(true);
-    }
+		return messageHandler.handleMessage(message);
+	}
+
+	private void maintainHasWarning(IMessage.Kind kind) {
+		if (!hasError) {
+			if (IMessage.ERROR.isSameOrLessThan(kind)) {
+				hasError = true;
+				hasWarning = true;
+			}
+		}
+		if (!hasWarning && IMessage.WARNING.isSameOrLessThan(kind)) {
+			hasWarning = true;
+		}
+	}
+
+	public boolean hasWarning() {
+		return hasWarning;
+	}
+
+	public boolean hasError() {
+		return hasError;
+	}
+
+	public void start() {
+		hasWarning = false;
+		hasError = false;
+		messageHandler.init(true);
+	}
 
 	public void dontIgnore(Kind kind) {
 		messageHandler.dontIgnore(kind);
@@ -206,7 +203,7 @@ class MyMessageHandler implements IBuildMessageHandler {
 	public boolean isIgnoring(Kind kind) {
 		return messageHandler.isIgnoring(kind);
 	}
-	
+
 }
 
 class MyBuildProgressMonitor implements IBuildProgressMonitor {
@@ -226,91 +223,112 @@ class MyBuildProgressMonitor implements IBuildProgressMonitor {
 
 	public void setProgressText(String text) {
 	}
-	
+
 }
 
 class VoidInvocationHandler implements InvocationHandler {
-    public Object invoke(Object me, Method method, Object[] args)
-        throws Throwable {
-        //       System.err.println("Proxying"
-        //       // don't call toString on self b/c proxied
-        //        // + " me=" + me.getClass().getName() 
-        //        + " method=" + method
-        //        + " args=" + (LangUtil.isEmpty(args) 
-        //            ? "[]" : Arrays.asList(args).toString()));
-        return null;
-    }
+	public Object invoke(Object me, Method method, Object[] args) throws Throwable {
+		// System.err.println("Proxying"
+		// // don't call toString on self b/c proxied
+		// // + " me=" + me.getClass().getName()
+		// + " method=" + method
+		// + " args=" + (LangUtil.isEmpty(args)
+		// ? "[]" : Arrays.asList(args).toString()));
+		return null;
+	}
 }
 
 class LoggingInvocationHandler implements InvocationHandler {
-    public Object invoke(Object me, Method method, Object[] args)
-        throws Throwable {
-        System.err.println("Proxying " + render(method, args));
-        return null;
-    }
-    public static String render(Class c) {
-        if (null == c) {
-            return "(Class) null";
-        }
-        String result = c.getName();
-        if (result.startsWith("java")) {
-            int loc = result.lastIndexOf(".");
-            if (-1 != loc) {
-                result = result.substring(loc+1);
-            }
-        }
-        return result;
-    }
-
-    public static String render(Method method, Object[] args) {
-        StringBuffer sb = new StringBuffer();
-        sb.append(render(method.getReturnType()));
-        sb.append(" ");
-        sb.append(method.getName());
-        sb.append("(");
-        Class[] parmTypes = method.getParameterTypes();
-        int parmTypesLength = (null == parmTypes ? 0 : parmTypes.length);
-        int argsLength = (null == args ? 0 : args.length);
-        boolean doType = (parmTypesLength == argsLength);
-        for (int i = 0; i < argsLength; i++) {
-            if (i > 0) {
-                sb.append(", ");
-            }
-            if (doType) {
-                sb.append("(");
-                sb.append(render(parmTypes[i]));
-                sb.append(") ");
-            }
-            if (null == args[i]) {
-                sb.append("null");                
-            } else { // also don't recurse into proxied toString?
-                sb.append(args[i].toString());
-            }
-        }
-        sb.append(")");
-        return sb.toString();
-    }
+	public Object invoke(Object me, Method method, Object[] args) throws Throwable {
+		System.err.println("Proxying " + render(method, args));
+		return null;
+	}
+
+	public static String render(Class c) {
+		if (null == c) {
+			return "(Class) null";
+		}
+		String result = c.getName();
+		if (result.startsWith("java")) {
+			int loc = result.lastIndexOf(".");
+			if (-1 != loc) {
+				result = result.substring(loc + 1);
+			}
+		}
+		return result;
+	}
+
+	public static String render(Method method, Object[] args) {
+		StringBuffer sb = new StringBuffer();
+		sb.append(render(method.getReturnType()));
+		sb.append(" ");
+		sb.append(method.getName());
+		sb.append("(");
+		Class[] parmTypes = method.getParameterTypes();
+		int parmTypesLength = (null == parmTypes ? 0 : parmTypes.length);
+		int argsLength = (null == args ? 0 : args.length);
+		boolean doType = (parmTypesLength == argsLength);
+		for (int i = 0; i < argsLength; i++) {
+			if (i > 0) {
+				sb.append(", ");
+			}
+			if (doType) {
+				sb.append("(");
+				sb.append(render(parmTypes[i]));
+				sb.append(") ");
+			}
+			if (null == args[i]) {
+				sb.append("null");
+			} else { // also don't recurse into proxied toString?
+				sb.append(args[i].toString());
+			}
+		}
+		sb.append(")");
+		return sb.toString();
+	}
 }
 
 class MyCompilerConfig implements ICompilerConfiguration {
 
-    private Set inpath;
-    private Set aspectPath;
-    private String outJar;
-    private IOutputLocationManager locationMgr;
-    
-	public Set getAspectPath() { return aspectPath;}
-	public void setAspectPath(Set path) {aspectPath = path;}
-	
-	public String getClasspath() { return Globals.S_aspectjrt_jar;  }
+	private Set inpath;
+	private Set aspectPath;
+	private String outJar;
+	private IOutputLocationManager locationMgr;
+
+	public Set getAspectPath() {
+		return aspectPath;
+	}
+
+	public void setAspectPath(Set path) {
+		aspectPath = path;
+	}
+
+	public String getClasspath() {
+		return Globals.S_aspectjrt_jar;
+	}
+
+	public Set getInpath() {
+		return inpath;
+	}
+
+	public void setInpath(Set input) {
+		inpath = input;
+	}
+
+	public Map getJavaOptionsMap() {
+		return JavaOptions.getDefaultJavaOptions();
+	}
+
+	public String getOutJar() {
+		return outJar;
+	}
 
-	public Set getInpath() { return inpath; }
-    public void setInpath(Set input) { inpath = input; }
-    
-	public Map getJavaOptionsMap() {return JavaOptions.getDefaultJavaOptions();}
+	public void configurationRead() {
+	}
 
-	public String getOutJar() { return outJar; }
-    public void setOutJar(String input){ outJar = input; }
+	public void setOutJar(String input) {
+		outJar = input;
+	}
 
 	public IOutputLocationManager getOutputLocationManager() {
 		if (locationMgr == null) {
@@ -319,23 +337,47 @@ class MyCompilerConfig implements ICompilerConfiguration {
 		return locationMgr;
 	}
 
-	public String getNonStandardOptions() {return null;}
-	public List getProjectSourceFiles() {return null;}
-	public List getProjectSourceFilesChanged() {return null;}
-	public Map getSourcePathResources() {return null;}
-	
+	public String getNonStandardOptions() {
+		return null;
+	}
+
+	public List getProjectSourceFiles() {
+		return null;
+	}
+
+	public List getProjectSourceFilesChanged() {
+		return null;
+	}
+
+	public Map getSourcePathResources() {
+		return null;
+	}
+
+	public int getConfigurationChanges() {
+		return ICompilerConfiguration.EVERYTHING;
+	}
 }
 
 class MyOutputLocationManager implements IOutputLocationManager {
 
-	public List getAllOutputLocations() {return null;}
+	public List getAllOutputLocations() {
+		return null;
+	}
 
-	public File getDefaultOutputLocation() {return null;}
+	public File getDefaultOutputLocation() {
+		return null;
+	}
 
-	public File getOutputLocationForClass(File compilationUnit) {return null;}
+	public File getOutputLocationForClass(File compilationUnit) {
+		return null;
+	}
+
+	public File getOutputLocationForResource(File resource) {
+		return null;
+	}
 
-	public File getOutputLocationForResource(File resource) {return null;}
+	public String getUniqueIdentifier() {
+		return null;
+	}
 
-	public String getUniqueIdentifier() {return null;}
-	
 }
@@ -23,18 +23,15 @@ import org.aspectj.tools.ajc.AjcTests;
 import org.aspectj.util.FileUtil;
 
 /**
- * Test implementation of ICompilerConfiguration. Allows users to configure
- * the settings via setter methods. By default returns null for all options
- * except getClasspath(), getJavaOptionsMap() (by default returns that it's 
- * 1.3 compliant), getOutputLocationManager(), getSourcePathResources() (it
- * recursively looks for them) and getProjectSourceFiles(). If no source
- * files are specified by the user, then getProjectSourceFiles() returns
- * an empty list.
+ * Test implementation of ICompilerConfiguration. Allows users to configure the settings via setter methods. By default returns null
+ * for all options except getClasspath(), getJavaOptionsMap() (by default returns that it's 1.3 compliant),
+ * getOutputLocationManager(), getSourcePathResources() (it recursively looks for them) and getProjectSourceFiles(). If no source
+ * files are specified by the user, then getProjectSourceFiles() returns an empty list.
  */
 public class TestCompilerConfiguration implements ICompilerConfiguration {
 
 	private String projectPath;
-	
+
 	private Set aspectpath;
 	private Set inpath;
 	private String outjar;
@@ -42,25 +39,22 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 	private String nonStandardOptions;
 	private List projectSourceFiles = new ArrayList();
 	private Map sourcePathResources;
-	
+
 	private String srcDirName = "src";
-	
+
 	private IOutputLocationManager outputLoc;
-	
+
 	public TestCompilerConfiguration(String projectPath) {
 		this.projectPath = projectPath;
 	}
-	
+
 	public Set getAspectPath() {
 		return aspectpath;
 	}
 
 	public String getClasspath() {
-		return projectPath 
-        	+ File.pathSeparator 
-        	+ System.getProperty("sun.boot.class.path")
-        	+ File.pathSeparator 
-        	+ AjcTests.aspectjrtClasspath();  
+		return projectPath + File.pathSeparator + System.getProperty("sun.boot.class.path") + File.pathSeparator
+				+ AjcTests.aspectjrtClasspath();
 	}
 
 	public Set getInpath() {
@@ -70,8 +64,8 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 	public Map getJavaOptionsMap() {
 		if (javaOptions == null) {
 			javaOptions = new Hashtable();
-			javaOptions.put(JavaOptions.COMPLIANCE_LEVEL,JavaOptions.VERSION_13);
-			javaOptions.put(JavaOptions.SOURCE_COMPATIBILITY_LEVEL,JavaOptions.VERSION_13);
+			javaOptions.put(JavaOptions.COMPLIANCE_LEVEL, JavaOptions.VERSION_13);
+			javaOptions.put(JavaOptions.SOURCE_COMPATIBILITY_LEVEL, JavaOptions.VERSION_13);
 		}
 		return javaOptions;
 	}
@@ -94,31 +88,31 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 	public List getProjectSourceFiles() {
 		return projectSourceFiles;
 	}
-	
+
 	public List getProjectSourceFilesChanged() {
 		return null;
 	}
 
+	public void configurationRead() {
+	}
+
 	public Map getSourcePathResources() {
 		if (sourcePathResources == null) {
 			sourcePathResources = new HashMap();
 
-			/* Allow the user to override the testProjectPath by using sourceRoots */ 
+			/* Allow the user to override the testProjectPath by using sourceRoots */
 			File[] srcBase = new File[] { new File(projectPath + File.separator + srcDirName) };
-			
+
 			for (int j = 0; j < srcBase.length; j++) {
 				File[] fromResources = FileUtil.listFiles(srcBase[j], new FileFilter() {
 					public boolean accept(File pathname) {
 						String name = pathname.getName().toLowerCase();
-						return !name.endsWith(".class") 
-							&& !name.endsWith(".java") 
-							&& !name.endsWith(".aj")
-							&& !name.endsWith(".lst")
-							&& !name.endsWith(".jar");
+						return !name.endsWith(".class") && !name.endsWith(".java") && !name.endsWith(".aj")
+								&& !name.endsWith(".lst") && !name.endsWith(".jar");
 					}
 				});
 				for (int i = 0; i < fromResources.length; i++) {
-					String normPath = FileUtil.normalizedPath(fromResources[i] ,srcBase[j]);
+					String normPath = FileUtil.normalizedPath(fromResources[i], srcBase[j]);
 					sourcePathResources.put(normPath, fromResources[i]);
 
 				}
@@ -127,7 +121,6 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 		return sourcePathResources;
 	}
 
-	
 	// -------------------- setter methods useful for testing ---------------
 	public void setAspectPath(Set aspectPath) {
 		this.aspectpath = aspectPath;
@@ -144,7 +137,7 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 	public void setJavaOptions(Map javaOptions) {
 		this.javaOptions = javaOptions;
 	}
-	
+
 	public void setNonStandardOptions(String options) {
 		this.nonStandardOptions = options;
 	}
@@ -156,9 +149,13 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 	public void setSourcePathResources(Map sourcePathResources) {
 		this.sourcePathResources = sourcePathResources;
 	}
-	
+
 	public void setSourceDir(String srcDirName) {
 		this.srcDirName = srcDirName;
 	}
-	
+
+	public int getConfigurationChanges() {
+		return ICompilerConfiguration.EVERYTHING;
+	}
+
 }
@@ -13,7 +13,6 @@
  * 					  Bugzilla #29768, 29769
  * ******************************************************************/
 
-
 package org.aspectj.ajdt.internal.core.builder;
 
 import java.io.File;
@@ -29,87 +28,89 @@ import org.aspectj.ajdt.internal.compiler.CompilationResultDestinationManager;
 import org.aspectj.util.FileUtil;
 
 /**
- * All configuration information needed to run the AspectJ compiler.
- * Compiler options (as opposed to path information) are held in an AjCompilerOptions instance
+ * All configuration information needed to run the AspectJ compiler. Compiler options (as opposed to path information) are held in
+ * an AjCompilerOptions instance
  */
-public class AjBuildConfig {
-	
+public class AjBuildConfig implements CompilerConfigurationChangeFlags {
+
 	private boolean shouldProceed = true;
-	
+
 	public static final String AJLINT_IGNORE = "ignore";
 	public static final String AJLINT_WARN = "warn";
 	public static final String AJLINT_ERROR = "error";
 	public static final String AJLINT_DEFAULT = "default";
-	
+
 	private File outputDir;
 	private File outputJar;
 	private String outxmlName;
 	private CompilationResultDestinationManager compilationResultDestinationManager = null;
-	private List/*File*/ sourceRoots = new ArrayList();
-	private List/*File*/ files = new ArrayList();
-	private List /*File*/ binaryFiles = new ArrayList();  // .class files in indirs...
-	private List/*File*/ inJars = new ArrayList();
-	private List/*File*/ inPath = new ArrayList();
-	private Map/*String->File*/ sourcePathResources = new HashMap();
-	private List/*File*/ aspectpath = new ArrayList();
-	private List/*String*/ classpath = new ArrayList();
-	private List/*String*/ bootclasspath = new ArrayList();
-	
+	private List/* File */sourceRoots = new ArrayList();
+	private List/* File */changedFiles;
+	private List/* File */files = new ArrayList();
+	private List /* File */binaryFiles = new ArrayList(); // .class files in indirs...
+	private List/* File */inJars = new ArrayList();
+	private List/* File */inPath = new ArrayList();
+	private Map/* String->File */sourcePathResources = new HashMap();
+	private List/* File */aspectpath = new ArrayList();
+	private List/* String */classpath = new ArrayList();
+	private List/* String */bootclasspath = new ArrayList();
+
 	private File configFile;
 	private String lintMode = AJLINT_DEFAULT;
 	private File lintSpecFile = null;
-	
+
+	private int changes = EVERYTHING; // bitflags, see CompilerConfigurationChangeFlags
+
 	private AjCompilerOptions options;
-    
-    /** if true, then global values override local when joining */
-    private boolean override = true;
-
-    // incremental variants handled by the compiler client, but parsed here
-    private boolean incrementalMode;
-    private File incrementalFile;
-	
+
+	/** if true, then global values override local when joining */
+	private boolean override = true;
+
+	// incremental variants handled by the compiler client, but parsed here
+	private boolean incrementalMode;
+	private File incrementalFile;
+
 	public String toString() {
 		StringBuffer sb = new StringBuffer();
-		sb.append("BuildConfig["+(configFile==null?"null":configFile.getAbsoluteFile().toString())+"] #Files="+files.size());
+		sb.append("BuildConfig[" + (configFile == null ? "null" : configFile.getAbsoluteFile().toString()) + "] #Files="
+				+ files.size());
 		return sb.toString();
 	}
-    
+
 	public static class BinarySourceFile {
 		public BinarySourceFile(File dir, File src) {
 			this.fromInPathDirectory = dir;
 			this.binSrc = src;
 		}
+
 		public File fromInPathDirectory;
 		public File binSrc;
-		
+
 		public boolean equals(Object obj) {
-			if ((obj instanceof BinarySourceFile) &&
-				(obj != null)) {
-				BinarySourceFile other = (BinarySourceFile)obj;
-				return(binSrc.equals(other.binSrc));
+			if (obj != null && (obj instanceof BinarySourceFile)) {
+				BinarySourceFile other = (BinarySourceFile) obj;
+				return (binSrc.equals(other.binSrc));
 			}
 			return false;
 		}
+
 		public int hashCode() {
-			return binSrc != null ? binSrc.hashCode() : 0; 
+			return binSrc != null ? binSrc.hashCode() : 0;
 		}
 	}
-    
+
 	/**
-	 * Intialises the javaOptions Map to hold the default 
-	 * JDT Compiler settings. Added by AMC 01.20.2003 in reponse
-	 * to bug #29768 and enh. 29769.
-	 * The settings here are duplicated from those set in
-	 * org.eclipse.jdt.internal.compiler.batch.Main, but I've elected to
-	 * copy them rather than refactor the JDT class since this keeps
-	 * integration with future JDT releases easier (?).
+	 * Intialises the javaOptions Map to hold the default JDT Compiler settings. Added by AMC 01.20.2003 in reponse to bug #29768
+	 * and enh. 29769. The settings here are duplicated from those set in org.eclipse.jdt.internal.compiler.batch.Main, but I've
+	 * elected to copy them rather than refactor the JDT class since this keeps integration with future JDT releases easier (?).
 	 */
-	public AjBuildConfig( ) {
+	public AjBuildConfig() {
 		options = new AjCompilerOptions();
 	}
 
 	/**
-	 * returned files includes <ul>
+	 * returned files includes
+	 * <ul>
 	 * <li>files explicitly listed on command-line</li>
 	 * <li>files listed by reference in argument list files</li>
 	 * <li>files contained in sourceRootDir if that exists</li>
@@ -117,23 +118,22 @@ public class AjBuildConfig {
 	 * 
 	 * @return all source files that should be compiled.
 	 */
-	public List/*File*/ getFiles() {
+	public List/* File */getFiles() {
 		return files;
 	}
 
 	/**
-	 * returned files includes all .class files found in
-	 * a directory on the inpath, but does not include
-	 * .class files contained within jars.
+	 * returned files includes all .class files found in a directory on the inpath, but does not include .class files contained
+	 * within jars.
 	 */
-	public List/*BinarySourceFile*/ getBinaryFiles() {
+	public List/* BinarySourceFile */getBinaryFiles() {
 		return binaryFiles;
 	}
-	
-	public File getOutputDir() {  
+
+	public File getOutputDir() {
 		return outputDir;
 	}
-	
+
 	public CompilationResultDestinationManager getCompilationResultDestinationManager() {
 		return this.compilationResultDestinationManager;
 	}
@@ -141,7 +141,7 @@ public class AjBuildConfig {
 	public void setCompilationResultDestinationManager(CompilationResultDestinationManager mgr) {
 		this.compilationResultDestinationManager = mgr;
 	}
-	
+
 	public void setFiles(List files) {
 		this.files = files;
 	}
@@ -164,11 +164,11 @@ public class AjBuildConfig {
 	public void setClasspath(List classpath) {
 		this.classpath = classpath;
 	}
-	
+
 	public List getBootclasspath() {
 		return bootclasspath;
 	}
-	
+
 	public void setBootclasspath(List bootclasspath) {
 		this.bootclasspath = bootclasspath;
 	}
@@ -180,13 +180,13 @@ public class AjBuildConfig {
 	public String getOutxmlName() {
 		return outxmlName;
 	}
-	
-	public List/*File*/ getInpath() {
+
+	public List/* File */getInpath() {
 		// Elements of the list are either archives (jars/zips) or directories
 		return inPath;
 	}
 
-	public List/*File*/ getInJars() {
+	public List/* File */getInJars() {
 		return inJars;
 	}
 
@@ -205,24 +205,25 @@ public class AjBuildConfig {
 	public void setInJars(List sourceJars) {
 		this.inJars = sourceJars;
 	}
-	
+
 	public void setInPath(List dirsOrJars) {
 		inPath = dirsOrJars;
-		
+
 		// remember all the class files in directories on the inpath
 		binaryFiles = new ArrayList();
 		FileFilter filter = new FileFilter() {
 			public boolean accept(File pathname) {
 				return pathname.getPath().endsWith(".class");
-			}};
+			}
+		};
 		for (Iterator iter = dirsOrJars.iterator(); iter.hasNext();) {
 			File inpathElement = (File) iter.next();
 			if (inpathElement.isDirectory()) {
-			    File[] files = FileUtil.listFiles(inpathElement, filter);
+				File[] files = FileUtil.listFiles(inpathElement, filter);
 				for (int i = 0; i < files.length; i++) {
-					binaryFiles.add(new BinarySourceFile(inpathElement,files[i]));
+					binaryFiles.add(new BinarySourceFile(inpathElement, files[i]));
 				}
-			}			
+			}
 		}
 	}
 
@@ -242,47 +243,47 @@ public class AjBuildConfig {
 		this.configFile = configFile;
 	}
 
-    public void setIncrementalMode(boolean incrementalMode) {
-        this.incrementalMode = incrementalMode;
-    }
-
-    public boolean isIncrementalMode() {
-        return incrementalMode;
-    }
-
-    public void setIncrementalFile(File incrementalFile) {
-        this.incrementalFile = incrementalFile;
-    }
-
-    public boolean isIncrementalFileMode() {
-        return (null != incrementalFile);
-    }
-
-    /**
-     * @return List (String) classpath of bootclasspath, injars, inpath, aspectpath 
-     *   entries, specified classpath (extdirs, and classpath), and output dir or jar
-     */
-    public List getFullClasspath() {
-        List full = new ArrayList();
-        full.addAll(getBootclasspath()); // XXX Is it OK that boot classpath overrides inpath/injars/aspectpath?
-        for (Iterator i = inJars.iterator(); i.hasNext(); ) {
-            full.add(((File)i.next()).getAbsolutePath());
-        }
-        for (Iterator i = inPath.iterator();i.hasNext();) {
-        	full.add(((File)i.next()).getAbsolutePath());
-        }
-        for (Iterator i = aspectpath.iterator(); i.hasNext(); ) {
-            full.add(((File)i.next()).getAbsolutePath());        
-        }
-        full.addAll(getClasspath());
-//        if (null != outputDir) {
-//            full.add(outputDir.getAbsolutePath());
-//        } else if (null != outputJar) {
-//            full.add(outputJar.getAbsolutePath());
-//        }
-        return full;
-    }
-    
+	public void setIncrementalMode(boolean incrementalMode) {
+		this.incrementalMode = incrementalMode;
+	}
+
+	public boolean isIncrementalMode() {
+		return incrementalMode;
+	}
+
+	public void setIncrementalFile(File incrementalFile) {
+		this.incrementalFile = incrementalFile;
+	}
+
+	public boolean isIncrementalFileMode() {
+		return (null != incrementalFile);
+	}
+
+	/**
+	 * @return List (String) classpath of bootclasspath, injars, inpath, aspectpath entries, specified classpath (extdirs, and
+	 *         classpath), and output dir or jar
+	 */
+	public List getFullClasspath() {
+		List full = new ArrayList();
+		full.addAll(getBootclasspath()); // XXX Is it OK that boot classpath overrides inpath/injars/aspectpath?
+		for (Iterator i = inJars.iterator(); i.hasNext();) {
+			full.add(((File) i.next()).getAbsolutePath());
+		}
+		for (Iterator i = inPath.iterator(); i.hasNext();) {
+			full.add(((File) i.next()).getAbsolutePath());
+		}
+		for (Iterator i = aspectpath.iterator(); i.hasNext();) {
+			full.add(((File) i.next()).getAbsolutePath());
+		}
+		full.addAll(getClasspath());
+		// if (null != outputDir) {
+		// full.add(outputDir.getAbsolutePath());
+		// } else if (null != outputJar) {
+		// full.add(outputJar.getAbsolutePath());
+		// }
+		return full;
+	}
+
 	public File getLintSpecFile() {
 		return lintSpecFile;
 	}
@@ -299,132 +300,127 @@ public class AjBuildConfig {
 		this.aspectpath = aspectpath;
 	}
 
-    /** @return true if any config file, sourceroots, sourcefiles, injars or inpath */
-    public boolean hasSources() {
-        return ((null != configFile)
-            || (0 < sourceRoots.size())
-            || (0 < files.size())
-            || (0 < inJars.size())
-            || (0 < inPath.size())
-            );
-    }
-    
-//    /** @return null if no errors, String errors otherwise */
-//    public String configErrors() {
-//        StringBuffer result = new StringBuffer();
-//        // ok, permit both.  sigh.
-////        if ((null != outputDir) && (null != outputJar)) {
-////            result.append("specified both outputDir and outputJar");
-////        }
-//        // incremental => only sourceroots
-//        // 
-//        return (0 == result.length() ? null : result.toString());
-//    }
-
-    /**
-     * Install global values into local config
-     * unless values conflict:
-     * <ul>
-     * <li>Collections are unioned</li>
-     * <li>values takes local value unless default and global set</li>
-     * <li>this only sets one of outputDir and outputJar as needed</li>
-     * <ul>
-     * This also configures super if javaOptions change.
-     * @param global the AjBuildConfig to read globals from
-     */
-    public void installGlobals(AjBuildConfig global) { // XXX relies on default values
-    	// don't join the options - they already have defaults taken care of.
-//        Map optionsMap = options.getMap();
-//        join(optionsMap,global.getOptions().getMap());
-//        options.set(optionsMap);
-        join(aspectpath, global.aspectpath);
-        join(classpath, global.classpath);
-        if (null == configFile) {
-            configFile = global.configFile; // XXX correct?
-        }
-        if (!isEmacsSymMode() && global.isEmacsSymMode()) {
-            setEmacsSymMode(true);
-        }
-        join(files, global.files);
-        if (!isGenerateModelMode() && global.isGenerateModelMode()) {
-            setGenerateModelMode(true);
-        }
-        if (null == incrementalFile) {
-            incrementalFile = global.incrementalFile;
-        }
-        if (!incrementalMode && global.incrementalMode) {
-            incrementalMode = true;
-        }
-        
-        if (isCheckRuntimeVersion() && !global.isCheckRuntimeVersion()) {
-        	setCheckRuntimeVersion(false);
-        }
-        
-        join(inJars, global.inJars);
-        join(inPath, global.inPath);
-        if ((null == lintMode) 
-            || (AJLINT_DEFAULT.equals(lintMode))) {
-            setLintMode(global.lintMode);
-        }
-        if (null == lintSpecFile) {
-            lintSpecFile = global.lintSpecFile;
-        }
-        if (!isTerminateAfterCompilation() && global.isTerminateAfterCompilation()) {
-            setTerminateAfterCompilation(true);
-        }
-        if ((null == outputDir) && (null == outputJar)) {
-            if (null != global.outputDir) {
-                outputDir = global.outputDir;
-            }
-            if (null != global.outputJar) {
-                outputJar = global.outputJar;
-            }
-        }        
-        join(sourceRoots, global.sourceRoots);
-        if (!isXnoInline() && global.isXnoInline()) {
-            setXnoInline(true);
-        }
-        if (!isXserializableAspects() && global.isXserializableAspects()) {
-            setXserializableAspects(true);
-        }
-        if (!isXlazyTjp() && global.isXlazyTjp()) {
-        	setXlazyTjp(true);
-        }
-        if (!getProceedOnError() && global.getProceedOnError()) {
-        	setProceedOnError(true);
-        }
-       	setTargetAspectjRuntimeLevel(global.getTargetAspectjRuntimeLevel());
-       	setXJoinpoints(global.getXJoinpoints());
-        if (!isXHasMemberEnabled() && global.isXHasMemberEnabled()) {
-        	setXHasMemberSupport(true);
-        }
-        if (!isXNotReweavable() && global.isXNotReweavable()) {
-        	setXnotReweavable(true);
-        }
-        setOutxmlName(global.getOutxmlName());
-        setXconfigurationInfo(global.getXconfigurationInfo());
-        setAddSerialVerUID(global.isAddSerialVerUID());
-    }
-
-    void join(Collection local, Collection global) {
-        for (Iterator iter = global.iterator(); iter.hasNext();) {
-            Object next = iter.next();
-            if (!local.contains(next)) {
-                local.add(next);        
-            }
-        }
-    }
-    void join(Map local, Map global) {
-        for (Iterator iter = global.keySet().iterator(); iter.hasNext();) {
-            Object key = iter.next();
-            if (override || (null == local.get(key))) { // 
-                Object value = global.get(key);
-                if (null != value) {
-                    local.put(key, value);
-                }
-            }
-        }
-    }
+	/** @return true if any config file, sourceroots, sourcefiles, injars or inpath */
+	public boolean hasSources() {
+		return ((null != configFile) || (0 < sourceRoots.size()) || (0 < files.size()) || (0 < inJars.size()) || (0 < inPath.size()));
+	}
+
+	// /** @return null if no errors, String errors otherwise */
+	// public String configErrors() {
+	// StringBuffer result = new StringBuffer();
+	// // ok, permit both. sigh.
+	// // if ((null != outputDir) && (null != outputJar)) {
+	// // result.append("specified both outputDir and outputJar");
+	// // }
+	// // incremental => only sourceroots
+	// //
+	// return (0 == result.length() ? null : result.toString());
+	// }
+
+	/**
+	 * Install global values into local config unless values conflict:
+	 * <ul>
+	 * <li>Collections are unioned</li>
+	 * <li>values takes local value unless default and global set</li>
+	 * <li>this only sets one of outputDir and outputJar as needed</li>
+	 * <ul>
+	 * This also configures super if javaOptions change.
+	 * 
+	 * @param global the AjBuildConfig to read globals from
+	 */
+	public void installGlobals(AjBuildConfig global) { // XXX relies on default values
+		// don't join the options - they already have defaults taken care of.
+		// Map optionsMap = options.getMap();
+		// join(optionsMap,global.getOptions().getMap());
+		// options.set(optionsMap);
+		join(aspectpath, global.aspectpath);
+		join(classpath, global.classpath);
+		if (null == configFile) {
+			configFile = global.configFile; // XXX correct?
+		}
+		if (!isEmacsSymMode() && global.isEmacsSymMode()) {
+			setEmacsSymMode(true);
+		}
+		join(files, global.files);
+		if (!isGenerateModelMode() && global.isGenerateModelMode()) {
+			setGenerateModelMode(true);
+		}
+		if (null == incrementalFile) {
+			incrementalFile = global.incrementalFile;
+		}
+		if (!incrementalMode && global.incrementalMode) {
+			incrementalMode = true;
+		}
+
+		if (isCheckRuntimeVersion() && !global.isCheckRuntimeVersion()) {
+			setCheckRuntimeVersion(false);
+		}
+
+		join(inJars, global.inJars);
+		join(inPath, global.inPath);
+		if ((null == lintMode) || (AJLINT_DEFAULT.equals(lintMode))) {
+			setLintMode(global.lintMode);
+		}
+		if (null == lintSpecFile) {
+			lintSpecFile = global.lintSpecFile;
+		}
+		if (!isTerminateAfterCompilation() && global.isTerminateAfterCompilation()) {
+			setTerminateAfterCompilation(true);
+		}
+		if ((null == outputDir) && (null == outputJar)) {
+			if (null != global.outputDir) {
+				outputDir = global.outputDir;
+			}
+			if (null != global.outputJar) {
+				outputJar = global.outputJar;
+			}
+		}
+		join(sourceRoots, global.sourceRoots);
+		if (!isXnoInline() && global.isXnoInline()) {
+			setXnoInline(true);
+		}
+		if (!isXserializableAspects() && global.isXserializableAspects()) {
+			setXserializableAspects(true);
+		}
+		if (!isXlazyTjp() && global.isXlazyTjp()) {
+			setXlazyTjp(true);
+		}
+		if (!getProceedOnError() && global.getProceedOnError()) {
+			setProceedOnError(true);
+		}
+		setTargetAspectjRuntimeLevel(global.getTargetAspectjRuntimeLevel());
+		setXJoinpoints(global.getXJoinpoints());
+		if (!isXHasMemberEnabled() && global.isXHasMemberEnabled()) {
+			setXHasMemberSupport(true);
+		}
+		if (!isXNotReweavable() && global.isXNotReweavable()) {
+			setXnotReweavable(true);
+		}
+		setOutxmlName(global.getOutxmlName());
+		setXconfigurationInfo(global.getXconfigurationInfo());
+		setAddSerialVerUID(global.isAddSerialVerUID());
+	}
+
+	void join(Collection local, Collection global) {
+		for (Iterator iter = global.iterator(); iter.hasNext();) {
+			Object next = iter.next();
+			if (!local.contains(next)) {
+				local.add(next);
+			}
+		}
+	}
+
+	void join(Map local, Map global) {
+		for (Iterator iter = global.keySet().iterator(); iter.hasNext();) {
+			Object key = iter.next();
+			if (override || (null == local.get(key))) { // 
+				Object value = global.get(key);
+				if (null != value) {
+					local.put(key, value);
+				}
+			}
+		}
+	}
 
 	public void setSourcePathResources(Map map) {
 		sourcePathResources = map;
@@ -444,7 +440,7 @@ public class AjBuildConfig {
 	public String getLintMode() {
 		return lintMode;
 	}
-	
+
 	// options...
 
 	public void setLintMode(String lintMode) {
@@ -457,22 +453,22 @@ public class AjBuildConfig {
 		} else if (AJLINT_ERROR.equals(lintMode)) {
 			lintValue = AjCompilerOptions.ERROR;
 		}
-		
+
 		if (lintValue != null) {
 			Map lintOptions = new HashMap();
-			lintOptions.put(AjCompilerOptions.OPTION_ReportInvalidAbsoluteTypeName,lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportInvalidWildcardTypeName,lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportUnresolvableMember,lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportTypeNotExposedToWeaver,lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportShadowNotInStructure,lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportUnmatchedSuperTypeInCall,lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportCannotImplementLazyTJP,lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportNeedSerialVersionUIDField,lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportIncompatibleSerialVersion,lintValue);
+			lintOptions.put(AjCompilerOptions.OPTION_ReportInvalidAbsoluteTypeName, lintValue);
+			lintOptions.put(AjCompilerOptions.OPTION_ReportInvalidWildcardTypeName, lintValue);
+			lintOptions.put(AjCompilerOptions.OPTION_ReportUnresolvableMember, lintValue);
+			lintOptions.put(AjCompilerOptions.OPTION_ReportTypeNotExposedToWeaver, lintValue);
+			lintOptions.put(AjCompilerOptions.OPTION_ReportShadowNotInStructure, lintValue);
+			lintOptions.put(AjCompilerOptions.OPTION_ReportUnmatchedSuperTypeInCall, lintValue);
+			lintOptions.put(AjCompilerOptions.OPTION_ReportCannotImplementLazyTJP, lintValue);
+			lintOptions.put(AjCompilerOptions.OPTION_ReportNeedSerialVersionUIDField, lintValue);
+			lintOptions.put(AjCompilerOptions.OPTION_ReportIncompatibleSerialVersion, lintValue);
 			options.set(lintOptions);
 		}
 	}
-	
+
 	public boolean isTerminateAfterCompilation() {
 		return options.terminateAfterCompilation;
 	}
@@ -488,11 +484,11 @@ public class AjBuildConfig {
 	public void setXserializableAspects(boolean xserializableAspects) {
 		options.xSerializableAspects = xserializableAspects;
 	}
-	
+
 	public void setXJoinpoints(String jps) {
 		options.xOptionalJoinpoints = jps;
 	}
-	
+
 	public String getXJoinpoints() {
 		return options.xOptionalJoinpoints;
 	}
@@ -504,7 +500,7 @@ public class AjBuildConfig {
 	public void setXnoInline(boolean xnoInline) {
 		options.xNoInline = xnoInline;
 	}
-    
+
 	public boolean isXlazyTjp() {
 		return options.xLazyThisJoinPoint;
 	}
@@ -516,37 +512,38 @@ public class AjBuildConfig {
 	public void setXnotReweavable(boolean b) {
 		options.xNotReweavable = b;
 	}
-	
+
 	public void setXconfigurationInfo(String info) {
 		options.xConfigurationInfo = info;
 	}
+
 	public String getXconfigurationInfo() {
 		return options.xConfigurationInfo;
 	}
-	
+
 	public void setXHasMemberSupport(boolean enabled) {
 		options.xHasMember = enabled;
 	}
-	
+
 	public boolean isXHasMemberEnabled() {
 		return options.xHasMember;
 	}
-	
+
 	public void setXdevPinpointMode(boolean enabled) {
 		options.xdevPinpoint = enabled;
 	}
-	
+
 	public boolean isXdevPinpoint() {
 		return options.xdevPinpoint;
 	}
-	
+
 	public void setAddSerialVerUID(boolean b) {
 		options.addSerialVerUID = b;
 	}
+
 	public boolean isAddSerialVerUID() {
 		return options.addSerialVerUID;
 	}
-		
 
 	public boolean isXNotReweavable() {
 		return options.xNotReweavable;
@@ -555,9 +552,8 @@ public class AjBuildConfig {
 	public boolean isGenerateJavadocsInModelMode() {
 		return options.generateJavaDocsInModel;
 	}
-	
-	public void setGenerateJavadocsInModelMode(
-			boolean generateJavadocsInModelMode) {
+
+	public void setGenerateJavadocsInModelMode(boolean generateJavadocsInModelMode) {
 		options.generateJavaDocsInModel = generateJavadocsInModelMode;
 	}
 
@@ -572,11 +568,11 @@ public class AjBuildConfig {
 	public boolean isCheckRuntimeVersion() {
 		return options.checkRuntimeVersion;
 	}
-	
+
 	public void setCheckRuntimeVersion(boolean on) {
 		options.checkRuntimeVersion = on;
 	}
-	
+
 	public boolean isEmacsSymMode() {
 		return options.generateEmacsSymFiles;
 	}
@@ -592,27 +588,27 @@ public class AjBuildConfig {
 	public void setGenerateModelMode(boolean structureModelMode) {
 		options.generateModel = structureModelMode;
 	}
-	
+
 	public boolean isNoAtAspectJAnnotationProcessing() {
 		return options.noAtAspectJProcessing;
 	}
-	
+
 	public void setNoAtAspectJAnnotationProcessing(boolean noProcess) {
 		options.noAtAspectJProcessing = noProcess;
 	}
-	
+
 	public void setShowWeavingInformation(boolean b) {
 		options.showWeavingInformation = true;
 	}
-	
-	public boolean getShowWeavingInformation() { 
+
+	public boolean getShowWeavingInformation() {
 		return options.showWeavingInformation;
 	}
 
 	public void setProceedOnError(boolean b) {
 		options.proceedOnError = b;
 	}
-	
+
 	public boolean getProceedOnError() {
 		return options.proceedOnError;
 	}
@@ -620,11 +616,11 @@ public class AjBuildConfig {
 	public void setBehaveInJava5Way(boolean b) {
 		options.behaveInJava5Way = b;
 	}
-	
+
 	public boolean getBehaveInJava5Way() {
 		return options.behaveInJava5Way;
 	}
-	
+
 	public void setTargetAspectjRuntimeLevel(String level) {
 		options.targetAspectjRuntimeLevel = level;
 	}
@@ -632,4 +628,31 @@ public class AjBuildConfig {
 	public String getTargetAspectjRuntimeLevel() {
 		return options.targetAspectjRuntimeLevel;
 	}
+
+	/**
+	 * Indicates what has changed in this configuration compared to the last time it was used, allowing the state management logic
+	 * to make intelligent optimizations and skip unnecessary work.
+	 * 
+	 * @param changes set of bitflags, see {@link CompilerConfigurationChangeFlags} for flags
+	 */
+	public void setChanged(int changes) {
+		this.changes = changes;
+	}
+
+	/**
+	 * Return the bit flags indicating what has changed since the last time this config was used.
+	 * 
+	 * @return the bitflags according too {@link CompilerConfigurationChangeFlags}
+	 */
+	public int getChanged() {
+		return this.changes;
+	}
+
+	public void setModifiedFiles(List projectSourceFilesChanged) {
+		this.changedFiles = projectSourceFilesChanged;
+	}
+
+	public List getModifiedFiles() {
+		return this.changedFiles;
+	}
 }
@@ -21,6 +21,7 @@ import java.lang.ref.SoftReference;
 import java.util.AbstractMap;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Hashtable;
@@ -60,7 +61,7 @@ import org.aspectj.weaver.bcel.UnwovenClassFile;
  * lets just do it for all now)
  * 
  */
-public class AjState {
+public class AjState implements CompilerConfigurationChangeFlags {
 
 	// SECRETAPI static so beware of multi-threading bugs...
 	public static IStateListener stateListener = null;
@@ -272,13 +273,18 @@ public class AjState {
 		else
 			qualifiedStrings.clear();
 
-		Set oldFiles = new HashSet(buildConfig.getFiles());
-		Set newFiles = new HashSet(newBuildConfig.getFiles());
+		if ((newBuildConfig.getChanged() & PROJECTSOURCEFILES_CHANGED) == 0) {
+			addedFiles = Collections.EMPTY_SET;
+			deletedFiles = Collections.EMPTY_SET;
+		} else {
+			Set oldFiles = new HashSet(buildConfig.getFiles());
+			Set newFiles = new HashSet(newBuildConfig.getFiles());
 
-		addedFiles = new HashSet(newFiles);
-		addedFiles.removeAll(oldFiles);
-		deletedFiles = new HashSet(oldFiles);
-		deletedFiles.removeAll(newFiles);
+			addedFiles = new HashSet(newFiles);
+			addedFiles.removeAll(oldFiles);
+			deletedFiles = new HashSet(oldFiles);
+			deletedFiles.removeAll(newFiles);
+		}
 
 		Set oldBinaryFiles = new HashSet(buildConfig.getBinaryFiles());
 		Set newBinaryFiles = new HashSet(newBuildConfig.getBinaryFiles());
@@ -334,18 +340,27 @@ public class AjState {
 
 	Collection getModifiedFiles(long lastBuildTime) {
 		Set ret = new HashSet();
-		// not our job to account for new and deleted files
-		for (Iterator i = buildConfig.getFiles().iterator(); i.hasNext();) {
-			File file = (File) i.next();
-			if (!file.exists())
-				continue;
 
-			long modTime = file.lastModified();
-			// System.out.println("check: " + file + " mod " + modTime + " build " + lastBuildTime);
-			// need to add 1000 since lastModTime is only accurate to a second on some (all?) platforms
-			if (modTime + 1000 > lastBuildTime) {
-				ret.add(file);
+		// Check if the build configuration knows what files have changed...
+		List/* File */modifiedFiles = buildConfig.getModifiedFiles();
+
+		if (modifiedFiles == null) {
+			// do not know, so need to go looking
+			// not our job to account for new and deleted files
+			for (Iterator i = buildConfig.getFiles().iterator(); i.hasNext();) {
+				File file = (File) i.next();
+				if (!file.exists())
+					continue;
+
+				long modTime = file.lastModified();
+				// System.out.println("check: " + file + " mod " + modTime + " build " + lastBuildTime);
+				// need to add 1000 since lastModTime is only accurate to a second on some (all?) platforms
+				if (modTime + 1000 > lastBuildTime) {
+					ret.add(file);
+				}
 			}
+		} else {
+			ret.addAll(modifiedFiles);
 		}
 		ret.addAll(affectedFiles);
 		return ret;
@@ -658,34 +673,57 @@ public class AjState {
 		return (strucModTime > lastSuccessfulBuildTime);
 	}
 
-	private boolean pathChange(AjBuildConfig oldConfig, AjBuildConfig newConfig) {
-		boolean changed = false;
+	/**
+	 * Determine if something has changed on the classpath/inpath/aspectpath and a full build is required rather than an incremental
+	 * one.
+	 * 
+	 * @param previousConfig the previous configuration used
+	 * @param newConfig the new configuration being used
+	 * @return true if full build required
+	 */
+	private boolean pathChange(AjBuildConfig previousConfig, AjBuildConfig newConfig) {
+		int changes = newConfig.getChanged();
 
-		List oldOutputLocs = getOutputLocations(oldConfig);
+		// currently very coarse grained
+		if ((changes & (CLASSPATH_CHANGED | ASPECTPATH_CHANGED | INPATH_CHANGED | OUTPUTDESTINATIONS_CHANGED | INJARS_CHANGED)) != 0) {
+			List oldOutputLocs = getOutputLocations(previousConfig);
 
-		List oldClasspath = oldConfig.getClasspath();
-		List newClasspath = newConfig.getClasspath();
-		if (stateListener != null)
-			stateListener.aboutToCompareClasspaths(oldClasspath, newClasspath);
-		if (changedAndNeedsFullBuild(oldClasspath, newClasspath, true, oldOutputLocs))
-			return true;
-		List oldAspectpath = oldConfig.getAspectpath();
-		List newAspectpath = newConfig.getAspectpath();
-		if (changedAndNeedsFullBuild(oldAspectpath, newAspectpath, true, oldOutputLocs))
-			return true;
-		List oldInJars = oldConfig.getInJars();
-		List newInJars = newConfig.getInJars();
-		if (changedAndNeedsFullBuild(oldInJars, newInJars, false, oldOutputLocs))
-			return true;
-		List oldInPath = oldConfig.getInpath();
-		List newInPath = newConfig.getInpath();
-		if (changedAndNeedsFullBuild(oldInPath, newInPath, false, oldOutputLocs))
-			return true;
-		return changed;
+			List oldClasspath = previousConfig.getClasspath();
+			List newClasspath = newConfig.getClasspath();
+			if (stateListener != null)
+				stateListener.aboutToCompareClasspaths(oldClasspath, newClasspath);
+			if (changedAndNeedsFullBuild(oldClasspath, newClasspath, true, oldOutputLocs))
+				return true;
+
+			List oldAspectpath = previousConfig.getAspectpath();
+			List newAspectpath = newConfig.getAspectpath();
+			if (changedAndNeedsFullBuild(oldAspectpath, newAspectpath, true, oldOutputLocs))
+				return true;
+
+			List oldInPath = previousConfig.getInpath();
+			List newInPath = newConfig.getInpath();
+			if (changedAndNeedsFullBuild(oldInPath, newInPath, false, oldOutputLocs))
+				return true;
+
+			List oldInJars = previousConfig.getInJars();
+			List newInJars = newConfig.getInJars();
+			if (changedAndNeedsFullBuild(oldInJars, newInJars, false, oldOutputLocs))
+				return true;
+		}
+
+		return false;
 	}
 
+	/**
+	 * Return a list of the output locations - this includes any 'default' output location and then any known by a registered
+	 * CompilationResultDestinationManager.
+	 * 
+	 * @param config the build configuration for which the output locations should be determined
+	 * @return a list of file objects
+	 */
 	private List /* File */getOutputLocations(AjBuildConfig config) {
 		List outputLocs = new ArrayList();
+		// Is there a default location?
 		if (config.getOutputDir() != null) {
 			try {
 				outputLocs.add(config.getOutputDir().getCanonicalFile());
@@ -697,10 +735,10 @@ public class AjState {
 			for (Iterator iterator = dirs.iterator(); iterator.hasNext();) {
 				File f = (File) iterator.next();
 				try {
-					if (!outputLocs.contains(f.getCanonicalFile())) {
-						outputLocs.add(f.getCanonicalFile());
+					File cf = f.getCanonicalFile();
+					if (!outputLocs.contains(cf)) {
+						outputLocs.add(cf);
 					}
-
 				} catch (IOException e) {
 				}
 			}
@@ -708,6 +746,17 @@ public class AjState {
 		return outputLocs;
 	}
 
+	/**
+	 * Check the old and new paths, if they vary by length or individual elements then that is considered a change. Or if the last
+	 * modified time of a path entry has changed (or last modified time of a classfile in that path entry has changed) then return
+	 * true. The outputlocations are supplied so they can be 'ignored' in the comparison.
+	 * 
+	 * @param oldPath
+	 * @param newPath
+	 * @param checkClassFiles whether to examine individual class files within directories
+	 * @param outputLocs the output locations that should be ignored if they occur on the paths being compared
+	 * @return true if a change is detected that requires a full build
+	 */
 	private boolean changedAndNeedsFullBuild(List oldPath, List newPath, boolean checkClassFiles, List outputLocs) {
 		if (oldPath == null)
 			oldPath = new ArrayList();
@@ -731,7 +780,7 @@ public class AjState {
 			if (f.exists() && !f.isDirectory() && (f.lastModified() >= lastSuccessfulBuildTime)) {
 				return true;
 			}
-			if (f.exists() && f.isDirectory() && checkClassFiles) {
+			if (checkClassFiles && f.exists() && f.isDirectory()) {
 				boolean foundMatch = false;
 				for (Iterator iterator = outputLocs.iterator(); iterator.hasNext();) {
 					File dir = (File) iterator.next();
@@ -0,0 +1,30 @@
+/********************************************************************
+ * Copyright (c) 2008 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: Andy Clement
+ *******************************************************************/
+package org.aspectj.ajdt.internal.core.builder;
+
+/**
+ * Bit flags that can indicate what has changed in a configuration, see ICompilerConfiguration
+ */
+public interface CompilerConfigurationChangeFlags {
+
+	int NO_CHANGES = 0x0000;
+	int PROJECTSOURCEFILES_CHANGED = 0x0001;
+	int JAVAOPTIONS_CHANGED = 0x0002;
+	int ASPECTPATH_CHANGED = 0x0004;
+	int CLASSPATH_CHANGED = 0x0008;
+	int INPATH_CHANGED = 0x0010;
+	int NONSTANDARDOPTIONS_CHANGED = 0x0020;
+	int OUTJAR_CHANGED = 0x0040;
+	int PROJECTSOURCERESOURCES_CHANGED = 0x0080;
+	int OUTPUTDESTINATIONS_CHANGED = 0x0100;
+	int INJARS_CHANGED = 0x0200; // deprecated, not in use any more
+	int EVERYTHING = 0xffff;
+
+}
@@ -14,92 +14,96 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import org.aspectj.ajdt.internal.core.builder.CompilerConfigurationChangeFlags;
+
 /**
- * Interface that contains all the configuration required for the 
- * compiler to be able to perform a build
+ * Interface that contains all the configuration required for the compiler to be able to perform a build
  */
-public interface ICompilerConfiguration {
-	
+public interface ICompilerConfiguration extends CompilerConfigurationChangeFlags {
+
 	/**
-	 * Returns the table of the current custom java options. 
+	 * Returns the table of the current custom java options.
 	 * <p>
-	 * For a complete description of the configurable options, see 
-	 * {@link org.aspectj.ajde.core.JavaOptions#getDefaultJavaOptions}
+	 * For a complete description of the configurable options, see {@link org.aspectj.ajde.core.JavaOptions#getDefaultJavaOptions}
 	 * or {@link org.aspectj.org.eclipse.jdt.core.IJavaProject#getOptions(boolean)}
 	 * </p>
 	 * 
-	 * @return table of current settings of all options 
-	 *   (key type: <code>String</code>; value type: <code>String</code>)
+	 * @return table of current settings of all options (key type: <code>String</code>; value type: <code>String</code>)
 	 * @see org.aspectj.ajde.core.JavaOptions#getDefaultJavaOptions or
-	 * org.aspectj.org.eclipse.jdt.core.IJavaProject#getOptions(boolean)
+	 *      org.aspectj.org.eclipse.jdt.core.IJavaProject#getOptions(boolean)
 	 */
-	public Map /*String --> String */getJavaOptionsMap();
-	
+	public Map /* String --> String */getJavaOptionsMap();
+
 	/**
-	 * The non-standard options, typically prefaced with -X when used 
-	 * with a command line compiler. The default is no non-standard 
-	 * options. Options should be separated by a space, for example 
-	 * "-showWeaveInfo -XnoInline"
+	 * The non-standard options, typically prefaced with -X when used with a command line compiler. The default is no non-standard
+	 * options. Options should be separated by a space, for example "-showWeaveInfo -XnoInline"
 	 */
 	public String getNonStandardOptions();
-	
+
 	/**
 	 * @return a list of those files to include in the build
 	 */
-    public List /*String*/ getProjectSourceFiles();
-
-    /**
-     * Return a subset of those files we'd get on getProjectSourceFiles() - the subset that have changed since
-     * the last build.  If someone else has already worked out what needs rebuilding, we don't need to do it again
-     * by checking all of the projectSourceFiles(). Returning an empty list means nothing has changed, returning null
-     * means you have no idea what changed and the compiler should work it out.
-     * 
-     * @return a subset of those files that would be returned on getProjectSourceFiles() that have actually *changed*
-     */
-    public List /*String*/ getProjectSourceFilesChanged();
-    
-    /**
-     * @return the classpath to use
-     */
-    public String getClasspath();
-
-    /**
-     * @return the IOutputLocationManager associated with this 
-     * compiler configuration
-     */
-    public IOutputLocationManager getOutputLocationManager();
+	public List /* String */getProjectSourceFiles();
+
+	/**
+	 * Return a subset of those files we'd get on getProjectSourceFiles() - the subset that have changed since the last build. If
+	 * someone else has already worked out what needs rebuilding, we don't need to do it again by checking all of the
+	 * projectSourceFiles(). Returning an empty list means nothing has changed, returning null means you have no idea what changed
+	 * and the compiler should work it out.
+	 * 
+	 * @return a subset of those files that would be returned on getProjectSourceFiles() that have actually *changed*
+	 */
+	public List /* File */getProjectSourceFilesChanged();
+
+	/**
+	 * @return the classpath to use
+	 */
+	public String getClasspath();
+
+	/**
+	 * @return the IOutputLocationManager associated with this compiler configuration
+	 */
+	public IOutputLocationManager getOutputLocationManager();
+
+	/**
+	 * @return the set of input path elements for this compilation. Set members should be of the type java.io.File. An empty set or
+	 *         null is acceptable for this option. From -inpath
+	 */
+	public Set /* java.io.File */getInpath();
 
 	/**
-	 * @return the set of input path elements for this compilation.
-	 * Set members should be of the type java.io.File.
-	 * An empty set or null is acceptable for this option.
-	 * From -inpath
+	 * @return the output jar file for the compilation results. Return null to leave classfiles unjar'd in output directory From
+	 *         -outjar
 	 */
-    public Set /*java.io.File*/ getInpath();
-    
+	public String getOutJar();
+
 	/**
-	 * @return the output jar file for the compilation results.
-	 * Return null to leave classfiles unjar'd in output directory
-	 * From -outjar
+	 * @return the set of aspect jar files to be used for the compilation. Returning null or an empty set disables this option. Set
+	 *         members should be of type java.io.File. From -aspectpath
 	 */
-    public String getOutJar();
+	public Set /* java.io.File */getAspectPath();
 
 	/**
-	 * @return the set of aspect jar files to be used for the compilation.
-	 * Returning null or an empty set disables this option. Set members
-	 * should be of type java.io.File.
-	 * From -aspectpath
+	 * Get the set of non-Java resources for this compilation. Set members should be of type java.io.File. An empty set or null is
+	 * acceptable for this option.
+	 * 
+	 * @return map from unique resource name to absolute path to source resource (String to File)
 	 */
-    public Set /*java.io.File*/ getAspectPath();
-    
+	public Map /* String --> java.io.File */getSourcePathResources();
+
 	/**
-	 * Get the set of non-Java resources for this compilation.
-	 * Set members should be of type java.io.File.
-	 * An empty set or null is acceptable for this option.
+	 * Returns a set of bit flags indicating what has changed in the configuration since it was previously read. This allows the
+	 * compiler to avoid repeating computation for values that are the same as before.
 	 * 
-	 * @return map from unique resource name to absolute path to source 
-	 * resource (String to File)
+	 * @return set of bit flags, see the constants in @link {@link CompilerConfigurationChangeFlags}. If unsure return EVERYTHING
+	 */
+	public int getConfigurationChanges();
+
+	/**
+	 * Called by AspectJ once it has processed the configuration object and is ready to do a build. The configuration object may or
+	 * may not be interested in this event. It probably will be if it is correctly tracking changes and answering
+	 * getConfigurationChanges() with something other than EVERYTHING.
 	 */
-    public Map /*String --> java.io.File */getSourcePathResources();
-	
+	public void configurationRead();
+
 }
@@ -41,175 +41,189 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.aspectj.util.LangUtil;
 
 /**
- * Build Manager which drives the build for a given AjCompiler.
- * Tools call build on the AjCompiler which drives this.
+ * Build Manager which drives the build for a given AjCompiler. Tools call build on the AjCompiler which drives this.
  */
 public class AjdeCoreBuildManager {
 
 	private AjCompiler compiler;
-	
-    private AjdeCoreBuildNotifierAdapter currNotifier = null;
+
+	private AjdeCoreBuildNotifierAdapter currNotifier = null;
 	private AjBuildManager ajBuildManager;
 	private IMessageHandler msgHandlerAdapter;
-	
+
 	public AjdeCoreBuildManager(AjCompiler compiler) {
 		this.compiler = compiler;
 		msgHandlerAdapter = new AjdeCoreMessageHandlerAdapter(compiler.getMessageHandler());
 		ajBuildManager = new AjBuildManager(msgHandlerAdapter);
 		ajBuildManager.environmentSupportsIncrementalCompilation(true);
-		// this static information needs to be set to ensure 
+		// this static information needs to be set to ensure
 		// incremental compilation works correctly
-		IncrementalStateManager.recordIncrementalStates=true;
-		IncrementalStateManager.debugIncrementalStates=false;
+		IncrementalStateManager.recordIncrementalStates = true;
+		IncrementalStateManager.debugIncrementalStates = false;
 		AsmManager.attemptIncrementalModelRepairs = true;
 	}
-	
+
 	// XXX hideous, should not be Object
 	public void setCustomMungerFactory(Object o) {
 		ajBuildManager.setCustomMungerFactory(o);
 	}
-	
+
 	public Object getCustomMungerFactory() {
 		return ajBuildManager.getCustomMungerFactory();
 	}
-	
+
 	/**
 	 * @param buildFresh - true if want to force a full build, false otherwise
 	 */
 	public void doBuild(boolean buildFresh) {
-       	if (!buildFresh) {
-       		buildFresh = updateAsmManagerInformation();
-       	}
-        try {
-        	startNotifiers();
-        	
-        	// record the options passed to the compiler
-			handleMessage(new Message(getFormattedOptionsString(),IMessage.INFO,null,null));
+		if (!buildFresh) {
+			buildFresh = updateAsmManagerInformation();
+		}
+		try {
+			startNotifiers();
+
+			// record the options passed to the compiler
+			if (!compiler.getMessageHandler().isIgnoring(IMessage.INFO)) {
+				handleMessage(new Message(getFormattedOptionsString(), IMessage.INFO, null, null));
+			}
 
 			CompilationAndWeavingContext.reset();
 
-			AjBuildConfig buildConfig = genAjBuildConfig();
-			if (buildConfig == null) return;
-
-            if (buildFresh) {
-            	ajBuildManager.batchBuild(buildConfig,msgHandlerAdapter); 
-            } else {
-				ajBuildManager.incrementalBuild(buildConfig,msgHandlerAdapter);				
-            }
-/*			
-            if (buildFresh) {
-    			AjBuildConfig buildConfig = genAjBuildConfig();
-    			if (buildConfig == null) return;
-            	ajBuildManager.batchBuild(buildConfig,msgHandlerAdapter); 
-            } else {
-            	AjBuildConfig buildConfig = ajBuildManager.getState().getBuildConfig();
-            	
-				ajBuildManager.incrementalBuild(buildConfig,msgHandlerAdapter);				
-            }
-*/
-			IncrementalStateManager.recordSuccessfulBuild(compiler.getId(),ajBuildManager.getState());
-            
-        } catch (ConfigParser.ParseException pe) {
-        	handleMessage(new Message("Config file entry invalid, file: " + pe.getFile().getPath() 
-                	+ ", line number: " + pe.getLine(),IMessage.WARNING,null,null));
+			if (buildFresh) {
+				AjBuildConfig buildConfig = genAjBuildConfig();
+				if (buildConfig == null) {
+					return;
+				}
+				ajBuildManager.batchBuild(buildConfig, msgHandlerAdapter);
+			} else {
+				// Only rebuild the config object if the configuration has changed
+				AjBuildConfig buildConfig = null;
+				ICompilerConfiguration compilerConfig = compiler.getCompilerConfiguration();
+				int changes = compilerConfig.getConfigurationChanges();
+				if (changes != ICompilerConfiguration.NO_CHANGES) {
+					buildConfig = genAjBuildConfig();
+					if (buildConfig == null) {
+						return;
+					}
+				} else {
+					buildConfig = ajBuildManager.getState().getBuildConfig();
+					buildConfig.setChanged(changes); // pass it through for the state to use it when making decisions
+					buildConfig.setModifiedFiles(compilerConfig.getProjectSourceFilesChanged());
+					compilerConfig.configurationRead();
+				}
+				ajBuildManager.incrementalBuild(buildConfig, msgHandlerAdapter);
+			}
+			/*
+			 * if (buildFresh) { AjBuildConfig buildConfig = genAjBuildConfig(); if (buildConfig == null) return;
+			 * ajBuildManager.batchBuild(buildConfig,msgHandlerAdapter); } else { AjBuildConfig buildConfig =
+			 * ajBuildManager.getState().getBuildConfig();
+			 * 
+			 * ajBuildManager.incrementalBuild(buildConfig,msgHandlerAdapter); }
+			 */
+			IncrementalStateManager.recordSuccessfulBuild(compiler.getId(), ajBuildManager.getState());
+
+		} catch (ConfigParser.ParseException pe) {
+			handleMessage(new Message("Config file entry invalid, file: " + pe.getFile().getPath() + ", line number: "
+					+ pe.getLine(), IMessage.WARNING, null, null));
 		} catch (AbortException e) {
-            final IMessage message = e.getIMessage();
-            if (message == null) {
-                handleMessage(new Message(LangUtil.unqualifiedClassName(e) + " thrown: " 
-                		+ e.getMessage(),IMessage.ERROR,e,null));
-            } else {
-            	handleMessage(new Message(message.getMessage() + "\n" 
-            			+ CompilationAndWeavingContext.getCurrentContext(),IMessage.ERROR,e,null));
-            }
+			final IMessage message = e.getIMessage();
+			if (message == null) {
+				handleMessage(new Message(LangUtil.unqualifiedClassName(e) + " thrown: " + e.getMessage(), IMessage.ERROR, e, null));
+			} else {
+				handleMessage(new Message(message.getMessage() + "\n" + CompilationAndWeavingContext.getCurrentContext(),
+						IMessage.ERROR, e, null));
+			}
 		} catch (Throwable t) {
-            handleMessage(new Message("Compile error: " + LangUtil.unqualifiedClassName(t) + " thrown: " +
-            		"" + t.getMessage(),IMessage.ABORT,t,null));
-        } finally {
-        	compiler.getBuildProgressMonitor().finish(ajBuildManager.wasFullBuild());
-        }
+			handleMessage(new Message("Compile error: " + LangUtil.unqualifiedClassName(t) + " thrown: " + "" + t.getMessage(),
+					IMessage.ABORT, t, null));
+		} finally {
+			compiler.getBuildProgressMonitor().finish(ajBuildManager.wasFullBuild());
+		}
 	}
-	
+
 	/**
 	 * Starts the various notifiers which are interested in the build progress
 	 */
 	private void startNotifiers() {
-    	compiler.getBuildProgressMonitor().begin();
-		currNotifier = new AjdeCoreBuildNotifierAdapter(compiler.getBuildProgressMonitor());		
-		ajBuildManager.setProgressListener(currNotifier);		
+		compiler.getBuildProgressMonitor().begin();
+		currNotifier = new AjdeCoreBuildNotifierAdapter(compiler.getBuildProgressMonitor());
+		ajBuildManager.setProgressListener(currNotifier);
 	}
-	
+
 	/**
-	 * Switches the relationshipMap and hierarchy used by AsmManager to be
-	 * the one for the current compiler - this will not be necessary once
-	 * the static nature is removed from the asm.
+	 * Switches the relationshipMap and hierarchy used by AsmManager to be the one for the current compiler - this will not be
+	 * necessary once the static nature is removed from the asm.
 	 */
 	private boolean updateAsmManagerInformation() {
-   		AjState updatedState = IncrementalStateManager.retrieveStateFor(compiler.getId());
-   		if (updatedState == null) {
-   			return true;
-   		} else {
-       		AsmManager.getDefault().setRelationshipMap(updatedState.getRelationshipMap());
-       		AsmManager.getDefault().setHierarchy(updatedState.getStructureModel());
-   		}
+		AjState updatedState = IncrementalStateManager.retrieveStateFor(compiler.getId());
+		if (updatedState == null) {
+			return true;
+		} else {
+			AsmManager.getDefault().setRelationshipMap(updatedState.getRelationshipMap());
+			AsmManager.getDefault().setHierarchy(updatedState.getStructureModel());
+		}
 		return false;
 	}
-    
-	// AMC - updated for AspectJ 1.1 options
+
 	private String getFormattedOptionsString() {
 		ICompilerConfiguration compilerConfig = compiler.getCompilerConfiguration();
-		return "Building with settings: "
-			+ "\n-> output paths: " + formatCollection(compilerConfig.getOutputLocationManager()
-					.getAllOutputLocations())
-			+ "\n-> classpath: " + compilerConfig.getClasspath()
-			+ "\n-> -inpath " + formatCollection(compilerConfig.getInpath())
-			+ "\n-> -outjar " + formatOptionalString(compilerConfig.getOutJar())
-			+ "\n-> -aspectpath " + formatCollection(compilerConfig.getAspectPath())
-			+ "\n-> -sourcePathResources " + formatMap(compilerConfig.getSourcePathResources())
-			+ "\n-> non-standard options: " + compilerConfig.getNonStandardOptions()
-			+ "\n-> javaoptions:" + formatMap(compilerConfig.getJavaOptionsMap());
+		return "Building with settings: " + "\n-> output paths: "
+				+ formatCollection(compilerConfig.getOutputLocationManager().getAllOutputLocations()) + "\n-> classpath: "
+				+ compilerConfig.getClasspath() + "\n-> -inpath " + formatCollection(compilerConfig.getInpath()) + "\n-> -outjar "
+				+ formatOptionalString(compilerConfig.getOutJar()) + "\n-> -aspectpath "
+				+ formatCollection(compilerConfig.getAspectPath()) + "\n-> -sourcePathResources "
+				+ formatMap(compilerConfig.getSourcePathResources()) + "\n-> non-standard options: "
+				+ compilerConfig.getNonStandardOptions() + "\n-> javaoptions:" + formatMap(compilerConfig.getJavaOptionsMap());
 	}
-	
-	private String formatCollection( Collection options ) {
-		if ( options == null ) return "<default>";
-		if ( options.isEmpty() ) return "none";
-		
+
+	private String formatCollection(Collection options) {
+		if (options == null)
+			return "<default>";
+		if (options.isEmpty())
+			return "none";
+
 		StringBuffer formattedOptions = new StringBuffer();
 		Iterator it = options.iterator();
 		while (it.hasNext()) {
 			String o = it.next().toString();
-			if (formattedOptions.length() > 0) formattedOptions.append(", ");
-			formattedOptions.append( o );
+			if (formattedOptions.length() > 0)
+				formattedOptions.append(", ");
+			formattedOptions.append(o);
 		}
 		return formattedOptions.toString();
 	}
-	
-	private String formatMap( Map options) {
-		if (options == null) return "<default>";
-		if (options.isEmpty()) return "none";
-		
+
+	private String formatMap(Map options) {
+		if (options == null)
+			return "<default>";
+		if (options.isEmpty())
+			return "none";
+
 		return options.toString();
 	}
-	
-	private String formatOptionalString( String s ) {
-		if ( s == null ) { return ""	; }
-		else { return s; }
+
+	private String formatOptionalString(String s) {
+		if (s == null) {
+			return "";
+		} else {
+			return s;
+		}
 	}
-	
-    /**
-     * Generate a new AjBuildConfig from the compiler configuration
-     * associated with this AjdeCoreBuildManager
-     * 
-     * @return null if invalid configuration, corresponding 
-     * AjBuildConfig otherwise
-     */
+
+	/**
+	 * Generate a new AjBuildConfig from the compiler configuration associated with this AjdeCoreBuildManager
+	 * 
+	 * @return null if invalid configuration, corresponding AjBuildConfig otherwise
+	 */
 	public AjBuildConfig genAjBuildConfig() {
-	    File configFile = new File(compiler.getId());
-	    String[] args = null;
-	    if (configFile.exists() && configFile.isFile()) {
+		File configFile = new File(compiler.getId());
+		String[] args = null;
+		if (configFile.exists() && configFile.isFile()) {
 			args = new String[] { "@" + configFile.getAbsolutePath() };
 		} else {
 			List l = compiler.getCompilerConfiguration().getProjectSourceFiles();
-			if (l == null) return null;
+			if (l == null)
+				return null;
 			args = new String[l.size()];
 			int counter = 0;
 			for (Iterator iter = l.iterator(); iter.hasNext();) {
@@ -218,163 +232,159 @@ public class AjdeCoreBuildManager {
 				counter++;
 			}
 		}
-        CountingMessageHandler handler = CountingMessageHandler.makeCountingMessageHandler(
-        		msgHandlerAdapter);
+		CountingMessageHandler handler = CountingMessageHandler.makeCountingMessageHandler(msgHandlerAdapter);
 		BuildArgParser parser = new BuildArgParser(handler);
-		
+
 		AjBuildConfig config = new AjBuildConfig();
-        parser.populateBuildConfig(config, args, false, configFile); 
-        configureCompilerOptions(config);
+		parser.populateBuildConfig(config, args, false, configFile);
+		configureCompilerOptions(config);
+		compiler.getCompilerConfiguration().configurationRead();
 
 		ISourceLocation location = null;
 		if (config.getConfigFile() != null) {
-			location = new SourceLocation(config.getConfigFile(), 0); 
+			location = new SourceLocation(config.getConfigFile(), 0);
 		}
-        
+
 		String message = parser.getOtherMessages(true);
-		if (null != message) {  
-			IMessage m = new Message(message, IMessage.ERROR, null, location);            
+		if (null != message) {
+			IMessage m = new Message(message, IMessage.ERROR, null, location);
 			handler.handleMessage(m);
 		}
-        
-        // always force model generation in AJDE
-        config.setGenerateModelMode(true);      
-        // always be in incremental mode in AJDE
-        config.setIncrementalMode(true);
-        // always force proceedOnError in AJDE
-        config.setProceedOnError(true);
+
+		// always force model generation in AJDE
+		config.setGenerateModelMode(true);
+		// always be in incremental mode in AJDE
+		config.setIncrementalMode(true);
+		// always force proceedOnError in AJDE
+		config.setProceedOnError(true);
 		return config;
 	}
-	
+
 	/**
-	 * Configure the given AjBuildConfig with the options found in the
-	 * ICompilerConfiguration implementation associated with the AjCompiler
-	 * for this AjdeCoreBuildManager
+	 * Configure the given AjBuildConfig with the options found in the ICompilerConfiguration implementation associated with the
+	 * AjCompiler for this AjdeCoreBuildManager
 	 * 
 	 * @param config
 	 */
 	private void configureCompilerOptions(AjBuildConfig config) {
-		
-        String propcp = compiler.getCompilerConfiguration().getClasspath();
-        if (!LangUtil.isEmpty(propcp)) {
-            StringTokenizer st = new StringTokenizer(propcp, File.pathSeparator);
-            List configClasspath = config.getClasspath();
-            ArrayList toAdd = new ArrayList();
-            while (st.hasMoreTokens()) {
-                String entry = st.nextToken();
-                if (!configClasspath.contains(entry)) {
-                    toAdd.add(entry);
-                }
-            }
-            if (0 < toAdd.size()) {
-                ArrayList both = new ArrayList(configClasspath.size() + toAdd.size());
-                both.addAll(configClasspath);
-                both.addAll(toAdd);
-                config.setClasspath(both);
-            }
-        }
-        
-        // set the outputjar
-        if (config.getOutputJar() == null) {
-            String outJar = compiler.getCompilerConfiguration().getOutJar();
-            if (!LangUtil.isEmpty(outJar)) {
-                config.setOutputJar(new File( outJar ) );  
-            }
-        }
-        
-        // set compilation result destination manager 
-        IOutputLocationManager outputLocationManager = compiler.getCompilerConfiguration().getOutputLocationManager();
-        if (config.getCompilationResultDestinationManager() == null && outputLocationManager != null) {
-        	config.setCompilationResultDestinationManager(new OutputLocationAdapter(outputLocationManager));
-        }
-
-        join(config.getInpath(),compiler.getCompilerConfiguration().getInpath());
-        // bug 168840 - calling 'setInPath(..)' creates BinarySourceFiles which
-        // are used to see if there have been changes in classes on the inpath
-        if (config.getInpath() != null) config.setInPath(config.getInpath());
+
+		String propcp = compiler.getCompilerConfiguration().getClasspath();
+		if (!LangUtil.isEmpty(propcp)) {
+			StringTokenizer st = new StringTokenizer(propcp, File.pathSeparator);
+			List configClasspath = config.getClasspath();
+			ArrayList toAdd = new ArrayList();
+			while (st.hasMoreTokens()) {
+				String entry = st.nextToken();
+				if (!configClasspath.contains(entry)) {
+					toAdd.add(entry);
+				}
+			}
+			if (0 < toAdd.size()) {
+				ArrayList both = new ArrayList(configClasspath.size() + toAdd.size());
+				both.addAll(configClasspath);
+				both.addAll(toAdd);
+				config.setClasspath(both);
+			}
+		}
+
+		// set the outputjar
+		if (config.getOutputJar() == null) {
+			String outJar = compiler.getCompilerConfiguration().getOutJar();
+			if (!LangUtil.isEmpty(outJar)) {
+				config.setOutputJar(new File(outJar));
+			}
+		}
+
+		// set compilation result destination manager
+		IOutputLocationManager outputLocationManager = compiler.getCompilerConfiguration().getOutputLocationManager();
+		if (config.getCompilationResultDestinationManager() == null && outputLocationManager != null) {
+			config.setCompilationResultDestinationManager(new OutputLocationAdapter(outputLocationManager));
+		}
+
+		join(config.getInpath(), compiler.getCompilerConfiguration().getInpath());
+		// bug 168840 - calling 'setInPath(..)' creates BinarySourceFiles which
+		// are used to see if there have been changes in classes on the inpath
+		if (config.getInpath() != null)
+			config.setInPath(config.getInpath());
 		config.setSourcePathResources(compiler.getCompilerConfiguration().getSourcePathResources());
-        join(config.getAspectpath(), compiler.getCompilerConfiguration().getAspectPath());
-        
+		join(config.getAspectpath(), compiler.getCompilerConfiguration().getAspectPath());
+
 		Map jom = compiler.getCompilerConfiguration().getJavaOptionsMap();
-		if (jom!=null) {
-			String version = (String)jom.get(CompilerOptions.OPTION_Compliance);
-			if (version!=null && ( version.equals(CompilerOptions.VERSION_1_5) || version.equals(CompilerOptions.VERSION_1_6))) {
+		if (jom != null) {
+			String version = (String) jom.get(CompilerOptions.OPTION_Compliance);
+			if (version != null && (version.equals(CompilerOptions.VERSION_1_5) || version.equals(CompilerOptions.VERSION_1_6))) {
 				config.setBehaveInJava5Way(true);
 			}
 			config.getOptions().set(jom);
 		}
-		
-		configureNonStandardOptions(config);	
+
+		configureNonStandardOptions(config);
 	}
-	
-    private void join(Collection target, Collection source) { 
-        if ((null == target) || (null == source)) {
-            return;
-        }
-        for (Iterator iter = source.iterator(); iter.hasNext();) {
-            Object next = iter.next();
-            if (! target.contains(next)) {
-                target.add(next);
-            }
-        }
-    }
-    
+
+	private void join(Collection target, Collection source) {
+		if ((null == target) || (null == source)) {
+			return;
+		}
+		for (Iterator iter = source.iterator(); iter.hasNext();) {
+			Object next = iter.next();
+			if (!target.contains(next)) {
+				target.add(next);
+			}
+		}
+	}
+
 	/**
-	 * Helper method for configure build options. This reads all command-line 
-	 * options specified in the non-standard options text entry and sets any 
-	 * corresponding unset values in config.
+	 * Helper method for configure build options. This reads all command-line options specified in the non-standard options text
+	 * entry and sets any corresponding unset values in config.
 	 */
 	private void configureNonStandardOptions(AjBuildConfig config) {
 
 		String nonStdOptions = compiler.getCompilerConfiguration().getNonStandardOptions();
-        if (LangUtil.isEmpty(nonStdOptions)) {
-            return;
-        }
-		
+		if (LangUtil.isEmpty(nonStdOptions)) {
+			return;
+		}
+
 		// Break a string into a string array of non-standard options.
-		// Allows for one option to include a ' '.   i.e. assuming it has been quoted, it
+		// Allows for one option to include a ' '. i.e. assuming it has been quoted, it
 		// won't accidentally get treated as a pair of options (can be needed for xlint props file option)
 		List tokens = new ArrayList();
 		int ind = nonStdOptions.indexOf('\"');
-		int ind2 = nonStdOptions.indexOf('\"',ind+1);
+		int ind2 = nonStdOptions.indexOf('\"', ind + 1);
 		if ((ind > -1) && (ind2 > -1)) { // dont tokenize within double quotes
-			String pre = nonStdOptions.substring(0,ind);
-			String quoted = nonStdOptions.substring(ind+1,ind2);
-			String post = nonStdOptions.substring(ind2+1,nonStdOptions.length());
+			String pre = nonStdOptions.substring(0, ind);
+			String quoted = nonStdOptions.substring(ind + 1, ind2);
+			String post = nonStdOptions.substring(ind2 + 1, nonStdOptions.length());
 			tokens.addAll(tokenizeString(pre));
 			tokens.add(quoted);
 			tokens.addAll(tokenizeString(post));
 		} else {
 			tokens.addAll(tokenizeString(nonStdOptions));
 		}
-		String[] args = (String[])tokens.toArray(new String[]{});
-		
-		
+		String[] args = (String[]) tokens.toArray(new String[] {});
+
 		// set the non-standard options in an alternate build config
 		// (we don't want to lose the settings we already have)
-        CountingMessageHandler counter 
-            = CountingMessageHandler.makeCountingMessageHandler(msgHandlerAdapter);
+		CountingMessageHandler counter = CountingMessageHandler.makeCountingMessageHandler(msgHandlerAdapter);
 		AjBuildConfig altConfig = AjdtCommand.genBuildConfig(args, counter);
 		if (counter.hasErrors()) {
-            return;
-        }
-        // copy globals where local is not set
-        config.installGlobals(altConfig);
-    }
-	
+			return;
+		}
+		// copy globals where local is not set
+		config.installGlobals(altConfig);
+	}
+
 	/** Local helper method for splitting option strings */
 	private List tokenizeString(String str) {
 		List tokens = new ArrayList();
 		StringTokenizer tok = new StringTokenizer(str);
-		while ( tok.hasMoreTokens() ) {
-			tokens.add(tok.nextToken());	
+		while (tok.hasMoreTokens()) {
+			tokens.add(tok.nextToken());
 		}
 		return tokens;
 	}
-	
+
 	/**
-	 * Helper method to ask the messagehandler to handle the 
-	 * given message
+	 * Helper method to ask the messagehandler to handle the given message
 	 */
 	private void handleMessage(Message msg) {
 		compiler.getMessageHandler().handleMessage(msg);
@@ -22,11 +22,9 @@ import org.aspectj.ajde.ui.UserPreferencesAdapter;
 import org.aspectj.tools.ajbrowser.BrowserManager;
 
 /**
- * AjBrowser implementation of ICompilerConfiguration which returns something
- * for getClasspath(), getJavaOptionsMap(), getNonStandardOptions() and 
- * getOutputLocationManager() and null for everything else. The reason it doesn't
- * return anything for getProjectSourceFiles() is that it uses .lst files to record
- * what is needed to build (via BuildConfigManager).
+ * AjBrowser implementation of ICompilerConfiguration which returns something for getClasspath(), getJavaOptionsMap(),
+ * getNonStandardOptions() and getOutputLocationManager() and null for everything else. The reason it doesn't return anything for
+ * getProjectSourceFiles() is that it uses .lst files to record what is needed to build (via BuildConfigManager).
  */
 public class BrowserCompilerConfiguration implements ICompilerConfiguration {
 
@@ -39,8 +37,7 @@ public class BrowserCompilerConfiguration implements ICompilerConfiguration {
 
 	public String getClasspath() {
 		StringBuffer classpath = new StringBuffer();
-		String userPath = preferencesAdapter
-			.getProjectPreference(PreferenceStoreConstants.BUILD_CLASSPATH);
+		String userPath = preferencesAdapter.getProjectPreference(PreferenceStoreConstants.BUILD_CLASSPATH);
 		if (userPath != null && userPath.trim().length() != 0) {
 			classpath.append(userPath);
 		}
@@ -50,7 +47,7 @@ public class BrowserCompilerConfiguration implements ICompilerConfiguration {
 			classpath.append(File.pathSeparator + dir.getAbsolutePath() + File.pathSeparator);
 		}
 		classpath.append(System.getProperty("java.class.path", "."));
-		//System.out.println("classpath: " + classpath.toString());
+		// System.out.println("classpath: " + classpath.toString());
 		return classpath.toString();
 	}
 
@@ -59,8 +56,7 @@ public class BrowserCompilerConfiguration implements ICompilerConfiguration {
 	}
 
 	public String getNonStandardOptions() {
-		return preferencesAdapter
-				.getProjectPreference(PreferenceStoreConstants.NONSTANDARD_OPTIONS);
+		return preferencesAdapter.getProjectPreference(PreferenceStoreConstants.NONSTANDARD_OPTIONS);
 	}
 
 	public IOutputLocationManager getOutputLocationManager() {
@@ -80,7 +76,6 @@ public class BrowserCompilerConfiguration implements ICompilerConfiguration {
 		return null;
 	}
 
-
 	public Map getSourcePathResources() {
 		// unimplemented in AjBrowser
 		return null;
@@ -100,4 +95,11 @@ public class BrowserCompilerConfiguration implements ICompilerConfiguration {
 		// unimplemented in AjBrowser
 		return null;
 	}
+
+	public int getConfigurationChanges() {
+		return ICompilerConfiguration.EVERYTHING;
+	}
+
+	public void configurationRead() {
+	}
 }
@@ -26,18 +26,15 @@ import org.aspectj.tools.ajc.AjcTests;
 import org.aspectj.util.FileUtil;
 
 /**
- * Test implementation of ICompilerConfiguration. Allows users to configure
- * the settings via setter methods. By default returns null for all options
- * except getClasspath(), getJavaOptionsMap() (by default returns that it's 
- * 1.3 compliant), getOutputLocationManager(), getSourcePathResources() (it
- * recursively looks for them) and getProjectSourceFiles(). If no source
- * files are specified by the user, then getProjectSourceFiles() returns
- * an empty list.
+ * Test implementation of ICompilerConfiguration. Allows users to configure the settings via setter methods. By default returns null
+ * for all options except getClasspath(), getJavaOptionsMap() (by default returns that it's 1.3 compliant),
+ * getOutputLocationManager(), getSourcePathResources() (it recursively looks for them) and getProjectSourceFiles(). If no source
+ * files are specified by the user, then getProjectSourceFiles() returns an empty list.
  */
 public class TestCompilerConfiguration implements ICompilerConfiguration {
 
 	private String projectPath;
-	
+
 	private Set aspectpath;
 	private Set inpath;
 	private String outjar;
@@ -45,25 +42,25 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 	private String nonStandardOptions;
 	private List projectSourceFiles = new ArrayList();
 	private Map sourcePathResources;
-	
+
 	private String srcDirName = "src";
-	
+
 	private IOutputLocationManager outputLoc;
-	
+
 	public TestCompilerConfiguration(String projectPath) {
 		this.projectPath = projectPath;
 	}
-	
+
+	public void configurationRead() {
+	}
+
 	public Set getAspectPath() {
 		return aspectpath;
 	}
 
 	public String getClasspath() {
-		return projectPath 
-        	+ File.pathSeparator 
-        	+ System.getProperty("sun.boot.class.path")
-        	+ File.pathSeparator 
-        	+ AjcTests.aspectjrtClasspath();  
+		return projectPath + File.pathSeparator + System.getProperty("sun.boot.class.path") + File.pathSeparator
+				+ AjcTests.aspectjrtClasspath();
 	}
 
 	public Set getInpath() {
@@ -73,8 +70,8 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 	public Map getJavaOptionsMap() {
 		if (javaOptions == null) {
 			javaOptions = new Hashtable();
-			javaOptions.put(JavaOptions.COMPLIANCE_LEVEL,JavaOptions.VERSION_13);
-			javaOptions.put(JavaOptions.SOURCE_COMPATIBILITY_LEVEL,JavaOptions.VERSION_13);
+			javaOptions.put(JavaOptions.COMPLIANCE_LEVEL, JavaOptions.VERSION_13);
+			javaOptions.put(JavaOptions.SOURCE_COMPATIBILITY_LEVEL, JavaOptions.VERSION_13);
 		}
 		return javaOptions;
 	}
@@ -106,22 +103,19 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 		if (sourcePathResources == null) {
 			sourcePathResources = new HashMap();
 
-			/* Allow the user to override the testProjectPath by using sourceRoots */ 
+			/* Allow the user to override the testProjectPath by using sourceRoots */
 			File[] srcBase = new File[] { new File(projectPath + File.separator + srcDirName) };
-			
+
 			for (int j = 0; j < srcBase.length; j++) {
 				File[] fromResources = FileUtil.listFiles(srcBase[j], new FileFilter() {
 					public boolean accept(File pathname) {
 						String name = pathname.getName().toLowerCase();
-						return !name.endsWith(".class") 
-							&& !name.endsWith(".java") 
-							&& !name.endsWith(".aj")
-							&& !name.endsWith(".lst")
-							&& !name.endsWith(".jar");
+						return !name.endsWith(".class") && !name.endsWith(".java") && !name.endsWith(".aj")
+								&& !name.endsWith(".lst") && !name.endsWith(".jar");
 					}
 				});
 				for (int i = 0; i < fromResources.length; i++) {
-					String normPath = FileUtil.normalizedPath(fromResources[i] ,srcBase[j]);
+					String normPath = FileUtil.normalizedPath(fromResources[i], srcBase[j]);
 					sourcePathResources.put(normPath, fromResources[i]);
 
 				}
@@ -130,7 +124,6 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 		return sourcePathResources;
 	}
 
-	
 	// -------------------- setter methods useful for testing ---------------
 	public void setAspectPath(Set aspectPath) {
 		this.aspectpath = aspectPath;
@@ -147,7 +140,7 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 	public void setJavaOptions(Map javaOptions) {
 		this.javaOptions = javaOptions;
 	}
-	
+
 	public void setNonStandardOptions(String options) {
 		this.nonStandardOptions = options;
 	}
@@ -159,9 +152,13 @@ public class TestCompilerConfiguration implements ICompilerConfiguration {
 	public void setSourcePathResources(Map sourcePathResources) {
 		this.sourcePathResources = sourcePathResources;
 	}
-	
+
 	public void setSourceDir(String srcDirName) {
 		this.srcDirName = srcDirName;
 	}
 
+	public int getConfigurationChanges() {
+		return ICompilerConfiguration.EVERYTHING;
+	}
+
 }
@@ -13,6 +13,7 @@ import org.aspectj.systemtest.ajc152.AllTestsAspectJ152;
 import org.aspectj.systemtest.ajc153.AllTestsAspectJ153;
 import org.aspectj.systemtest.ajc154.AllTestsAspectJ154;
 import org.aspectj.systemtest.incremental.tools.IncrementalOutputLocationManagerTests;
+import org.aspectj.systemtest.incremental.tools.IncrementalPerformanceTests;
 import org.aspectj.systemtest.incremental.tools.MoreOutputLocationManagerTests;
 import org.aspectj.systemtest.incremental.tools.MultiProjectIncrementalTests;
 import org.aspectj.systemtest.model.Model5Tests;
@@ -22,7 +23,7 @@ public class AllTests15 {
 
 	public static Test suite() {
 		TestSuite suite = new TestSuite("AspectJ System Test Suite - JDK 1.5");
-		//$JUnit-BEGIN$
+		// $JUnit-BEGIN$
 		suite.addTest(AllTests14.suite());
 		suite.addTest(AllTestsAspectJ150.suite());
 		suite.addTest(AllTestsAspectJ151.suite());
@@ -31,16 +32,16 @@ public class AllTests15 {
 		suite.addTest(AllTestsAspectJ154.suite());
 		suite.addTest(AtAjAnnotationGenTests.suite());
 		suite.addTest(Model5Tests.suite());
-		/* FIXME maw Many of these tests do not depend on Java 5 but they
-		 * cannot be executed in Eclipse with 1.3 because of XML issues and
-		 * are excluded on the build machine so moving them here loses nothing
-		 * for the moment.
+		/*
+		 * FIXME maw Many of these tests do not depend on Java 5 but they cannot be executed in Eclipse with 1.3 because of XML
+		 * issues and are excluded on the build machine so moving them here loses nothing for the moment.
 		 */
 		suite.addTestSuite(MultiProjectIncrementalTests.class);
+		suite.addTestSuite(IncrementalPerformanceTests.class);
 		suite.addTestSuite(MoreOutputLocationManagerTests.class);
 		suite.addTestSuite(IncrementalOutputLocationManagerTests.class);
 		suite.addTest(XLint5Tests.suite());
-		//$JUnit-END$
+		// $JUnit-END$
 		return suite;
 	}
 }
@@ -24,6 +24,7 @@ import junit.framework.TestCase;
 
 import org.aspectj.ajde.core.AjCompiler;
 import org.aspectj.ajde.core.IBuildMessageHandler;
+import org.aspectj.ajde.core.ICompilerConfiguration;
 import org.aspectj.ajde.core.IOutputLocationManager;
 import org.aspectj.ajdt.internal.core.builder.AbstractStateListener;
 import org.aspectj.ajdt.internal.core.builder.AjState;
@@ -35,64 +36,72 @@ import org.aspectj.tools.ajc.Ajc;
 /**
  * This class uses Ajde in the same way that an IDE (e.g. AJDT) does.
  * 
- * The build is driven through 'doBuild(projectName)' but the
- * build can be configured by the methods beginning 'configure***'.
- * Information about what happened during a build is accessible
- * through the get*, was*, print* public methods...
+ * The build is driven through 'doBuild(projectName)' but the build can be configured by the methods beginning 'configure***'.
+ * Information about what happened during a build is accessible through the get*, was*, print* public methods...
  * 
  */
 public class AjdeInteractionTestbed extends TestCase {
 
 	public static boolean VERBOSE = false; // do you want the gory details?
-	
+
 	public static String testdataSrcDir = "../tests/multiIncremental";
 	protected static File sandboxDir;
-	
+
 	private static boolean buildModel;
 
 	// Methods for configuring the build
 	public void configureNewProjectDependency(String fromProjectName, String projectItDependsOn) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + fromProjectName);
-		((MultiProjTestCompilerConfiguration)compiler.getCompilerConfiguration()).addDependancy(projectItDependsOn);
+		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).addDependancy(projectItDependsOn);
 	}
-	
+
+	public void setNextChangeResponse(String projName, int flags) {
+		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projName);
+		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).changed = flags;
+	}
+
+	public void addProjectSourceFileChanged(String projectName, File changedFile) {
+		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
+		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).addProjectSourceFileChanged(changedFile);
+	}
+
 	public void configureNonStandardCompileOptions(String projectName, String options) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
-		((MultiProjTestCompilerConfiguration)compiler.getCompilerConfiguration()).setNonStandardOptions(options);
+		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).setNonStandardOptions(options);
 	}
-	
+
 	public void configureAspectPath(String projectName, Set aspectpath) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
-		((MultiProjTestCompilerConfiguration)compiler.getCompilerConfiguration()).setAspectPath(aspectpath);
-	} 
+		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).setAspectPath(aspectpath);
+	}
 
 	public void configureAspectPath(String projectName, File aspectpath) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
 		Set s = new HashSet();
 		s.add(aspectpath);
-		((MultiProjTestCompilerConfiguration)compiler.getCompilerConfiguration()).setAspectPath(s);
-	} 
-	
+		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).setAspectPath(s);
+	}
+
 	public void configureResourceMap(String projectName, Map resourcesMap) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
-		((MultiProjTestCompilerConfiguration)compiler.getCompilerConfiguration()).setSourcePathResources(resourcesMap);
+		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).setSourcePathResources(resourcesMap);
 	}
-	
+
 	public void configureJavaOptionsMap(String projectName, Map options) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
-		((MultiProjTestCompilerConfiguration)compiler.getCompilerConfiguration()).setJavaOptions(options);		
+		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).setJavaOptions(options);
 	}
-	
+
 	public static void configureInPath(String projectName, Set inpath) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
-		((MultiProjTestCompilerConfiguration)compiler.getCompilerConfiguration()).setInpath(inpath);		
+		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).setInpath(inpath);
 	}
-	
+
 	public static void configureOutputLocationManager(String projectName, IOutputLocationManager mgr) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
-		((MultiProjTestCompilerConfiguration)compiler.getCompilerConfiguration()).setOutputLocationManager(mgr);
+		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).setOutputLocationManager(mgr);
 	}
-	
+
 	public void configureShowWeaveInfoMessages(String projectName, boolean showWeaveInfo) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
 		IBuildMessageHandler handler = compiler.getMessageHandler();
@@ -102,48 +111,50 @@ public class AjdeInteractionTestbed extends TestCase {
 			handler.ignore(IMessage.WEAVEINFO);
 		}
 	}
-	
+
 	// End of methods for configuring the build
-	
+
 	public AjCompiler getCompilerForProjectWithName(String projectName) {
 		return CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
 	}
-	
-	protected File getWorkingDir() { return sandboxDir; }
-	
+
+	protected File getWorkingDir() {
+		return sandboxDir;
+	}
+
 	protected void setUp() throws Exception {
 		super.setUp();
 		// need this line because otherwise reset in previous tests
 		AsmManager.attemptIncrementalModelRepairs = true;
-		if (AjState.stateListener==null) {
-			AjState.stateListener=MyStateListener.getInstance();
-		
+		if (AjState.stateListener == null) {
+			AjState.stateListener = MyStateListener.getInstance();
+
 		}
 		MyStateListener.reset();
 		// Create a sandbox in which to work
 		sandboxDir = Ajc.createEmptySandbox();
 	}
-	
+
 	protected void tearDown() throws Exception {
 		super.tearDown();
-		AjState.stateListener=null;
+		AjState.stateListener = null;
 		CompilerFactory.clearCompilerMap();
 		IncrementalStateManager.clearIncrementalStates();
 	}
-	
+
 	/** Drives a build */
 	public boolean doBuild(String projectName) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
 		resetCompilerRecords(compiler);
 		addSourceFilesToBuild(projectName, compiler);
 		pause(1000); // delay to allow previous runs build stamps to be OK
-		lognoln("Building project '"+projectName+"'");
+		lognoln("Building project '" + projectName + "'");
 		compiler.build();
 		log("");
 		checkForErrors(compiler);
-		log("Build finished, time taken = " +((MultiProjTestBuildProgressMonitor)
-				compiler.getBuildProgressMonitor()).getTimeTaken()+"ms");
-		return true;	
+		log("Build finished, time taken = "
+				+ ((MultiProjTestBuildProgressMonitor) compiler.getBuildProgressMonitor()).getTimeTaken() + "ms");
+		return true;
 	}
 
 	/** Drives a full build **/
@@ -152,58 +163,71 @@ public class AjdeInteractionTestbed extends TestCase {
 		resetCompilerRecords(compiler);
 		addSourceFilesToBuild(projectName, compiler);
 		pause(1000); // delay to allow previous runs build stamps to be OK
-		lognoln("Building project '"+projectName+"'");
+		lognoln("Building project '" + projectName + "'");
 		compiler.buildFresh();
 		log("");
 		checkForErrors(compiler);
-		log("Build finished, time taken = " +((MultiProjTestBuildProgressMonitor)
-				compiler.getBuildProgressMonitor()).getTimeTaken()+"ms");
-		return true;	
+		log("Build finished, time taken = "
+				+ ((MultiProjTestBuildProgressMonitor) compiler.getBuildProgressMonitor()).getTimeTaken() + "ms");
+		return true;
 	}
-	
+
 	/**
 	 * Clears any maps associated with the compiler
 	 */
 	private void resetCompilerRecords(AjCompiler compiler) {
-		((MultiProjTestBuildProgressMonitor)compiler.getBuildProgressMonitor()).reset();
-		((MultiProjTestMessageHandler)compiler.getMessageHandler()).reset();
+		((MultiProjTestBuildProgressMonitor) compiler.getBuildProgressMonitor()).reset();
+		((MultiProjTestMessageHandler) compiler.getMessageHandler()).reset();
 	}
-	
+
 	/**
-	 * Find the source files associated with the given project and add them to the 
-	 * list of projectSourceFiles in the MultiProjTestCompilerConfiguration to be 
-	 * used in the subsequent build
+	 * Find the source files associated with the given project and add them to the list of projectSourceFiles in the
+	 * MultiProjTestCompilerConfiguration to be used in the subsequent build
 	 */
 	private void addSourceFilesToBuild(String pname, AjCompiler compiler) {
-		File projectBase = new File(sandboxDir,pname);
+		File projectBase = new File(sandboxDir, pname);
+		ICompilerConfiguration icc = compiler.getCompilerConfiguration();
+		List currentFiles = icc.getProjectSourceFiles();
 		List filesForCompilation = new ArrayList();
-		collectUpFiles(projectBase,projectBase,filesForCompilation);
-		((MultiProjTestCompilerConfiguration)compiler.getCompilerConfiguration()).setProjectSourceFiles(filesForCompilation);
+		collectUpFiles(projectBase, projectBase, filesForCompilation);
+		boolean changed = false;
+		for (int i = 0; i < filesForCompilation.size(); i++) {
+			if (!currentFiles.contains(filesForCompilation.get(i)))
+				changed = true;
+		}
+		for (int i = 0; i < currentFiles.size(); i++) {
+			if (!filesForCompilation.contains(currentFiles.get(i)))
+				changed = true;
+		}
+		if (changed) {
+			((MultiProjTestCompilerConfiguration) icc).setProjectSourceFiles(filesForCompilation);
+		}
 	}
-	
+
 	private void collectUpFiles(File location, File base, List collectionPoint) {
 		String contents[] = location.list();
-		if (contents==null) return;
+		if (contents == null)
+			return;
 		for (int i = 0; i < contents.length; i++) {
 			String string = contents[i];
-			File f = new File(location,string);
+			File f = new File(location, string);
 			if (f.isDirectory()) {
-				collectUpFiles(f,base,collectionPoint);
+				collectUpFiles(f, base, collectionPoint);
 			} else if (f.isFile() && (f.getName().endsWith(".aj") || f.getName().endsWith(".java"))) {
 				String fileFound;
 				try {
 					fileFound = f.getCanonicalPath();
 					collectionPoint.add(fileFound);
-//					String toRemove  = base.getCanonicalPath();
-//					if (!fileFound.startsWith(toRemove)) throw new RuntimeException("eh? "+fileFound+"   "+toRemove);
-//					collectionPoint.add(fileFound.substring(toRemove.length()+1));//+1 captures extra separator
+					// String toRemove = base.getCanonicalPath();
+					// if (!fileFound.startsWith(toRemove)) throw new RuntimeException("eh? "+fileFound+"   "+toRemove);
+					// collectionPoint.add(fileFound.substring(toRemove.length()+1));//+1 captures extra separator
 				} catch (IOException e) {
 					e.printStackTrace();
 				}
 			}
 		}
 	}
-	
+
 	/**
 	 * Make sure no errors have been recorded
 	 */
@@ -215,192 +239,207 @@ public class AjdeInteractionTestbed extends TestCase {
 				IMessage element = (IMessage) iter.next();
 				System.err.println(element);
 			}
-			System.err.println("---------");			
+			System.err.println("---------");
 		}
 	}
-	
+
 	public List getErrorMessages(String projectName) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
 		return ((MultiProjTestMessageHandler) compiler.getMessageHandler()).getErrorMessages();
 	}
-	
+
 	public List getWarningMessages(String projectName) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
 		return ((MultiProjTestMessageHandler) compiler.getMessageHandler()).getWarningMessages();
 	}
-	
+
 	public List getWeavingMessages(String projectName) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
 		return ((MultiProjTestMessageHandler) compiler.getMessageHandler()).getWeavingMessages();
 	}
-	
+
 	public List getCompilerErrorMessages(String projectName) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
 		return ((MultiProjTestMessageHandler) compiler.getMessageHandler()).getCompilerErrors();
 	}
-	
+
 	public void checkForError(String projectName, String anError) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
-		List messages = ((MultiProjTestMessageHandler)compiler.getMessageHandler()).getErrorMessages();
+		List messages = ((MultiProjTestMessageHandler) compiler.getMessageHandler()).getErrorMessages();
 		for (Iterator iter = messages.iterator(); iter.hasNext();) {
 			IMessage element = (IMessage) iter.next();
-			if (element.getMessage().indexOf(anError)!=-1) return;
+			if (element.getMessage().indexOf(anError) != -1)
+				return;
 		}
-		fail("Didn't find the error message:\n'"+anError+"'.\nErrors that occurred:\n"+messages);
+		fail("Didn't find the error message:\n'" + anError + "'.\nErrors that occurred:\n" + messages);
 	}
-	
+
 	private void pause(int millis) {
 		try {
 			Thread.sleep(millis);
-		} catch (InterruptedException ie) {}
+		} catch (InterruptedException ie) {
+		}
 	}
 
 	// Methods for querying what happened during a build and accessing information
 	// about the build:
-	
+
 	/**
-	 * Helper method for dumping info about which files were compiled and
-	 * woven during the last build.
+	 * Helper method for dumping info about which files were compiled and woven during the last build.
 	 */
 	public String printCompiledAndWovenFiles(String projectName) {
 		StringBuffer sb = new StringBuffer();
-		if (getCompiledFiles(projectName).size()==0 && getWovenClasses(projectName).size()==0)
+		if (getCompiledFiles(projectName).size() == 0 && getWovenClasses(projectName).size() == 0)
 			sb.append("No files were compiled or woven\n");
 		for (Iterator iter = getCompiledFiles(projectName).iterator(); iter.hasNext();) {
 			Object element = (Object) iter.next();
-			sb.append("compiled: "+element+"\n");
+			sb.append("compiled: " + element + "\n");
 		}
 		for (Iterator iter = getWovenClasses(projectName).iterator(); iter.hasNext();) {
 			Object element = (Object) iter.next();
-			sb.append("woven: "+element+"\n");
+			sb.append("woven: " + element + "\n");
 		}
 		return sb.toString();
 	}
-	
+
 	/**
 	 * Summary report on what happened in the most recent build
 	 */
 	public void printBuildReport(String projectName) {
-		System.out.println("\n====== BUILD REPORT (Project "+projectName+") ===========");
-		System.out.println("Build took: "+getTimeTakenForBuild(projectName)+"ms");
-		List compiled=getCompiledFiles(projectName);
-		System.out.println("Compiled: "+compiled.size()+" files");
+		System.out.println("\n====== BUILD REPORT (Project " + projectName + ") ===========");
+		System.out.println("Build took: " + getTimeTakenForBuild(projectName) + "ms");
+		List compiled = getCompiledFiles(projectName);
+		System.out.println("Compiled: " + compiled.size() + " files");
 		for (Iterator iter = compiled.iterator(); iter.hasNext();) {
-			System.out.println("        :"+iter.next());			
+			System.out.println("        :" + iter.next());
 		}
-		List woven=getWovenClasses(projectName);
-		System.out.println("Wove: "+woven.size()+" files");
+		List woven = getWovenClasses(projectName);
+		System.out.println("Wove: " + woven.size() + " files");
 		for (Iterator iter = woven.iterator(); iter.hasNext();) {
-			System.out.println("    :"+iter.next());			
+			System.out.println("    :" + iter.next());
 		}
-		if (wasFullBuild()) System.out.println("It was a batch (full) build");
+		if (wasFullBuild())
+			System.out.println("It was a batch (full) build");
 		System.out.println("=============================================");
 	}
 
 	/**
-	 * Check we compiled/wove the right number of files, passing '-1' indicates you don't care about
-	 * that number.
+	 * Check we compiled/wove the right number of files, passing '-1' indicates you don't care about that number.
 	 */
-	public void checkCompileWeaveCount(String projectName,int expCompile,int expWoven) {
-		if (expCompile!=-1 && getCompiledFiles(projectName).size()!=expCompile)
-			fail("Expected compilation of "+expCompile+" files but compiled "+getCompiledFiles(projectName).size()+
-					"\n"+printCompiledAndWovenFiles(projectName));
-		if (expWoven!=-1 && getWovenClasses(projectName).size()!=expWoven)
-			fail("Expected weaving of "+expWoven+" files but wove "+getWovenClasses(projectName).size()+
-					"\n"+printCompiledAndWovenFiles(projectName));
-	}
-	
+	public void checkCompileWeaveCount(String projectName, int expCompile, int expWoven) {
+		if (expCompile != -1 && getCompiledFiles(projectName).size() != expCompile)
+			fail("Expected compilation of " + expCompile + " files but compiled " + getCompiledFiles(projectName).size() + "\n"
+					+ printCompiledAndWovenFiles(projectName));
+		if (expWoven != -1 && getWovenClasses(projectName).size() != expWoven)
+			fail("Expected weaving of " + expWoven + " files but wove " + getWovenClasses(projectName).size() + "\n"
+					+ printCompiledAndWovenFiles(projectName));
+	}
+
 	public void checkWasntFullBuild() {
-		assertTrue("Shouldn't have been a full (batch) build",!wasFullBuild());
+		assertTrue("Shouldn't have been a full (batch) build", !wasFullBuild());
 	}
-	
+
 	public void checkWasFullBuild() {
-		assertTrue("Should have been a full (batch) build",wasFullBuild());
+		assertTrue("Should have been a full (batch) build", wasFullBuild());
 	}
-	
+
 	public boolean wasFullBuild() {
-	// alternatives: statelistener is debug interface, progressmonitor is new proper interface (see pr145689)
-//		return MyBuildProgressMonitor.wasFullBuild();
+		// alternatives: statelistener is debug interface, progressmonitor is new proper interface (see pr145689)
+		// return MyBuildProgressMonitor.wasFullBuild();
 		return MyStateListener.wasFullBuild();
 	}
-	
 
 	public long getTimeTakenForBuild(String projectName) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
-		return ((MultiProjTestBuildProgressMonitor)compiler.getBuildProgressMonitor()).getTimeTaken();
+		return ((MultiProjTestBuildProgressMonitor) compiler.getBuildProgressMonitor()).getTimeTaken();
 	}
-	
+
 	public List getCompiledFiles(String projectName) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
-		return ((MultiProjTestBuildProgressMonitor)compiler.getBuildProgressMonitor()).getCompiledFiles();
+		return ((MultiProjTestBuildProgressMonitor) compiler.getBuildProgressMonitor()).getCompiledFiles();
 	}
 
 	public List getWovenClasses(String projectName) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
-		return ((MultiProjTestBuildProgressMonitor)compiler.getBuildProgressMonitor()).getWovenClasses();
+		return ((MultiProjTestBuildProgressMonitor) compiler.getBuildProgressMonitor()).getWovenClasses();
 	}
-	
+
 	// Infrastructure below here
-	
+
 	private static void log(String msg) {
-		if (VERBOSE) System.out.println(msg);
+		if (VERBOSE)
+			System.out.println(msg);
 	}
-	
+
 	private static void lognoln(String msg) {
-		if (VERBOSE) System.out.print(msg);
+		if (VERBOSE)
+			System.out.print(msg);
 	}
-	
-	/** Return the *full* path to this file which is taken relative to the project dir*/
+
+	/** Return the *full* path to this file which is taken relative to the project dir */
 	protected static String getFile(String projectName, String path) {
-		return new File(sandboxDir,projectName+File.separatorChar + path).getAbsolutePath();
+		return new File(sandboxDir, projectName + File.separatorChar + path).getAbsolutePath();
 	}
-	
+
 	static class MyStateListener extends AbstractStateListener {
-		
+
 		private static MyStateListener _instance = new MyStateListener();
-		private MyStateListener() {reset();}
-		
-		public static MyStateListener getInstance() { return _instance;}
-		
+
+		private MyStateListener() {
+			reset();
+		}
+
+		public static MyStateListener getInstance() {
+			return _instance;
+		}
+
 		public static boolean informedAboutKindOfBuild;
 		public static boolean fullBuildOccurred;
 		public static List detectedDeletions = new ArrayList();
 		public static StringBuffer decisions = new StringBuffer();
-		
+
 		public static void reset() {
-			informedAboutKindOfBuild=false;
+			informedAboutKindOfBuild = false;
 			decisions = new StringBuffer();
-			fullBuildOccurred=false;
-			if (detectedDeletions!=null) detectedDeletions.clear();
+			fullBuildOccurred = false;
+			if (detectedDeletions != null)
+				detectedDeletions.clear();
+		}
+
+		public boolean pathChange = false;
+
+		public void pathChangeDetected() {
+			pathChange = true;
+		}
+
+		public void aboutToCompareClasspaths(List oldClasspath, List newClasspath) {
 		}
-		
-  	    public boolean pathChange = false;
-		public void pathChangeDetected() {pathChange = true;}
-		public void aboutToCompareClasspaths(List oldClasspath, List newClasspath) {}
+
 		public void detectedClassChangeInThisDir(File f) {
-			recordDecision("Detected class change in this directory: "+f.toString());
+			recordDecision("Detected class change in this directory: " + f.toString());
 		}
-		
+
 		public void detectedAspectDeleted(File f) {
 			detectedDeletions.add(f.toString());
 		}
 
 		public void buildSuccessful(boolean wasFullBuild) {
-			informedAboutKindOfBuild= true;
-			fullBuildOccurred=wasFullBuild;
+			informedAboutKindOfBuild = true;
+			fullBuildOccurred = wasFullBuild;
 		}
-		
+
 		public static String getDecisions() {
 			return decisions.toString();
 		}
-		
+
 		public static boolean wasFullBuild() {
-			if (!informedAboutKindOfBuild) throw new RuntimeException("I never heard about what kind of build it was!!");
+			if (!informedAboutKindOfBuild)
+				throw new RuntimeException("I never heard about what kind of build it was!!");
 			return fullBuildOccurred;
 		}
 
 		// not needed just yet...
-//		public void recordInformation(String s) { decisions.append(s).append("\n");}
+		// public void recordInformation(String s) { decisions.append(s).append("\n");}
 		public void recordDecision(String s) {
 			decisions.append(s).append("\n");
 			log(s);
@@ -0,0 +1,128 @@
+/********************************************************************
+ * Copyright (c) 2008 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *     Andy Clement          initial implementation
+ *******************************************************************/
+package org.aspectj.systemtest.incremental.tools;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * Testing the performance of incremental compilation as it would be in AJDT.
+ * 
+ * @author AndyClement
+ */
+public class IncrementalPerformanceTests extends AbstractMultiProjectIncrementalAjdeInteractionTestbed {
+
+	/**
+	 * Build a project of 64 source files and no aspects.<br>
+	 * <ul>
+	 * <li>First build is a full build.
+	 * <li>Second build is an incremental build with no changes at all.
+	 * <li>Third build is an incremental build with just a source file touched (not changed).
+	 * </ul>
+	 * 
+	 * <p>
+	 * 162-dev, 28Aug08 times: Thinkpad T61p: 3203/3140/3234/3156 173/172/172/172 313/297/297/312
+	 */
+	public void testBuildingProject64Files() {
+		String proj = "Proj64";
+
+		// A full build:
+		initialiseProject(proj);
+		build(proj);
+		checkWasFullBuild();
+		long fullbuildtime = getTimeTakenForBuild(proj);
+		System.out.println("Full build time: " + fullbuildtime + "ms");
+
+		// An incremental build with no source file changes at all. What should happen?
+		// We need to determine that nothing has to be done as fast as possible, this is all about
+		// determining from the configuration that nothing has changed and returning as fast as possible. Any
+		// delays here are unnecessary burden that will hurt every other kind of compilation.
+		build(proj);
+		checkWasntFullBuild();
+		checkCompileWeaveCount(proj, 0, 0);
+		long nochangebuild = getTimeTakenForBuild(proj);
+		System.out.println("Incr build time for no changes at all: " + nochangebuild + "ms");
+
+		addProjectSourceFileChanged(proj, null);
+		build(proj);
+		checkWasntFullBuild();
+		checkCompileWeaveCount(proj, 0, 0);
+		long nochangebuildandDoTellCompiler = getTimeTakenForBuild(proj);
+		System.out.println("Incr build time for no changes at all and telling the compiler that: " + nochangebuildandDoTellCompiler
+				+ "ms");
+
+		// Now we touch a file (C0.java) and call build. What should happen?
+		// We need to determine what has changed, we'll do that by walking over the set of input files and
+		// checking their last modified stamps. So although we won't rebuild a buildConfig object, we will
+		// call lastModifiedTime() a lot to determine which file has changed.
+		alter(proj, "inc1");
+		build(proj);
+		checkWasntFullBuild();
+		checkCompileWeaveCount(proj, 1, 1);
+		long whitespacechangeDontTellCompiler = getTimeTakenForBuild(proj);
+		System.out.println("Incr build time for whitespace change: " + whitespacechangeDontTellCompiler + "ms");
+
+		// Similar to previous test, touch that file, but this time tell the compiler which file has changed. What should happen?
+		// As we are telling the compiler what has changed, it will not jump through hoops checking the last mod time of
+		// every source file in the project configuration.
+		alter(proj, "inc1");
+		addProjectSourceFileChanged(proj, getProjectRelativePath(proj, "src/out/C0.java"));
+		build(proj);
+		checkWasntFullBuild();
+		checkCompileWeaveCount(proj, 1, 1);
+		long whitespacechangeDoTellCompiler = getTimeTakenForBuild(proj);
+		System.out.println("Incr build time for whitespace change (where we tell the compiler what changed): "
+				+ whitespacechangeDoTellCompiler + "ms");
+
+		// Lets assert what really ought to be true
+		assertTrue(nochangebuild < fullbuildtime);
+		assertTrue(whitespacechangeDontTellCompiler < fullbuildtime);
+		assertTrue(whitespacechangeDoTellCompiler < fullbuildtime);
+
+		assertTrue(nochangebuild < whitespacechangeDontTellCompiler);
+		assertTrue(nochangebuild < whitespacechangeDoTellCompiler);
+
+		assertTrue(whitespacechangeDoTellCompiler < whitespacechangeDontTellCompiler);
+	}
+
+	// --- helper code ---
+
+	private void waitFor10() {
+		try {
+			Thread.sleep(10000);
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+	}
+
+	private void waitForReturn() {
+		try {
+			System.in.read();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+
+	protected void setUp() throws Exception {
+		super.setUp();
+		testdataSrcDir = "../tests/incrementalPerformance";
+	}
+
+	protected void tearDown() throws Exception {
+		super.tearDown();
+		testdataSrcDir = "../tests/multiIncremental";
+	}
+
+	private File getProjectRelativePath(String p, String filename) {
+		File projDir = new File(getWorkingDir(), p);
+		return new File(projDir, filename);
+	}
+}
\ No newline at end of file
@@ -22,14 +22,13 @@ import org.aspectj.ajde.core.ICompilerConfiguration;
 import org.aspectj.ajde.core.IOutputLocationManager;
 
 /**
- * ICompilerConfiguration which mirrors the way AJDT behaves. Always returns
- * that its 1.5 compliant and enables the setting of all options except
- * output jar.
+ * ICompilerConfiguration which mirrors the way AJDT behaves. Always returns that its 1.5 compliant and enables the setting of all
+ * options except output jar.
  */
 public class MultiProjTestCompilerConfiguration implements ICompilerConfiguration {
 
 	private boolean verbose = false;
-	
+
 	private String classPath = "";
 	private Set aspectPath = null;
 	private Map sourcePathResources = null;
@@ -39,15 +38,18 @@ public class MultiProjTestCompilerConfiguration implements ICompilerConfiguratio
 	private Set inpath;
 	private String outjar;
 	private String nonstandardoptions;
+	private List modifiedFiles;
 	private List projectSourceFiles = new ArrayList();
 	private String projectPath;
 
+	int changed;
+
 	public MultiProjTestCompilerConfiguration(String projectPath) {
 		this.projectPath = projectPath;
 	}
-	
+
 	public Set getAspectPath() {
-		log("ICompilerConfiguration.getAspectPath("+aspectPath+")");
+		log("ICompilerConfiguration.getAspectPath(" + aspectPath + ")");
 		return aspectPath;
 	}
 
@@ -60,27 +62,21 @@ public class MultiProjTestCompilerConfiguration implements ICompilerConfiguratio
 			File dir = (File) iterator.next();
 			sb.append(File.pathSeparator + dir.getAbsolutePath());
 		}
-		String cp =  
-		  sb.toString() + File.pathSeparator + 
-		  new File(AjdeInteractionTestbed.testdataSrcDir) + File.pathSeparator +
-		  System.getProperty("sun.boot.class.path") + 
-		  File.pathSeparator + "../runtime/bin" +
-		  File.pathSeparator + this.classPath + 
-		  File.pathSeparator +  System.getProperty("aspectjrt.path") +
-		  File.pathSeparator +  "../lib/junit/junit.jar" +
-		  "c:/batik/batik-1.6/lib/batik-util.jar;"+
-		  "c:/batik/batik-1.6/lib/batik-awt-util.jar;"+
-		  "c:/batik/batik-1.6/lib/batik-dom.jar;"+
-		  "c:/batik/batik-1.6/lib/batik-svggen.jar;"+
-		  File.pathSeparator+".."+File.separator+"lib" + File.separator+"test"+File.separator+"aspectjrt.jar";
-		
+		String cp = sb.toString() + File.pathSeparator + new File(AjdeInteractionTestbed.testdataSrcDir) + File.pathSeparator
+				+ System.getProperty("sun.boot.class.path") + File.pathSeparator + "../runtime/bin" + File.pathSeparator
+				+ this.classPath + File.pathSeparator + System.getProperty("aspectjrt.path") + File.pathSeparator
+				+ "../lib/junit/junit.jar" + "c:/batik/batik-1.6/lib/batik-util.jar;"
+				+ "c:/batik/batik-1.6/lib/batik-awt-util.jar;" + "c:/batik/batik-1.6/lib/batik-dom.jar;"
+				+ "c:/batik/batik-1.6/lib/batik-svggen.jar;" + File.pathSeparator + ".." + File.separator + "lib" + File.separator
+				+ "test" + File.separator + "aspectjrt.jar";
+
 		// look at dependant projects
-		if (dependants!=null) {
+		if (dependants != null) {
 			for (Iterator iter = dependants.iterator(); iter.hasNext();) {
-				cp = AjdeInteractionTestbed.getFile((String)iter.next(),"bin")+File.pathSeparator+cp;
+				cp = AjdeInteractionTestbed.getFile((String) iter.next(), "bin") + File.pathSeparator + cp;
 			}
 		}
-		//System.err.println("For project "+projectPath+" getClasspath() returning "+cp);
+		// System.err.println("For project "+projectPath+" getClasspath() returning "+cp);
 		return cp;
 	}
 
@@ -91,17 +87,18 @@ public class MultiProjTestCompilerConfiguration implements ICompilerConfiguratio
 
 	public Map getJavaOptionsMap() {
 		log("ICompilerConfiguration.getJavaOptionsMap()");
-		if (javaOptionsMap != null && !javaOptionsMap.isEmpty() ) return javaOptionsMap;
-		
+		if (javaOptionsMap != null && !javaOptionsMap.isEmpty())
+			return javaOptionsMap;
+
 		Hashtable ht = new Hashtable();
-		ht.put("org.eclipse.jdt.core.compiler.compliance","1.5");
-		ht.put("org.eclipse.jdt.core.compiler.codegen.targetPlatform","1.5");
-		ht.put("org.eclipse.jdt.core.compiler.source","1.5");
-		return ht;				
+		ht.put("org.eclipse.jdt.core.compiler.compliance", "1.5");
+		ht.put("org.eclipse.jdt.core.compiler.codegen.targetPlatform", "1.5");
+		ht.put("org.eclipse.jdt.core.compiler.source", "1.5");
+		return ht;
 	}
 
 	public String getNonStandardOptions() {
-		log("ICompilerConfiguration.getNonStandardOptions( " + nonstandardoptions +")");
+		log("ICompilerConfiguration.getNonStandardOptions( " + nonstandardoptions + ")");
 		return nonstandardoptions;
 	}
 
@@ -125,59 +122,88 @@ public class MultiProjTestCompilerConfiguration implements ICompilerConfiguratio
 
 	public List getProjectSourceFilesChanged() {
 		log("ICompilerConfiguration.getProjectSourceFilesChanged()");
-		return null;
+		return modifiedFiles;
 	}
 
 	public Map getSourcePathResources() {
 		log("ICompilerConfiguration.getSourcePathResources()");
 		return sourcePathResources;
 	}
-	
+
 	public void log(String s) {
-		if (verbose) System.out.println(s);
+		if (verbose)
+			System.out.println(s);
 	}
-	
+
 	public void addDependancy(String projectItDependsOn) {
 		if (dependants == null) {
 			dependants = new ArrayList();
 		}
 		dependants.add(projectItDependsOn);
 	}
-	
+
 	// -------------------- setter methods useful for testing ---------------
 	public void setAspectPath(Set aspectPath) {
 		this.aspectPath = aspectPath;
+		this.changed |= ICompilerConfiguration.ASPECTPATH_CHANGED;
 	}
 
 	public void setInpath(Set inpath) {
 		this.inpath = inpath;
+		this.changed |= ICompilerConfiguration.INPATH_CHANGED;
 	}
 
 	public void setOutjar(String outjar) {
 		this.outjar = outjar;
+		this.changed |= ICompilerConfiguration.OUTJAR_CHANGED;
 	}
 
 	public void setJavaOptions(Map javaOptions) {
 		this.javaOptionsMap = javaOptions;
+		this.changed |= ICompilerConfiguration.JAVAOPTIONS_CHANGED;
 	}
-	
+
 	public void setNonStandardOptions(String options) {
 		this.nonstandardoptions = options;
+		this.changed |= ICompilerConfiguration.NONSTANDARDOPTIONS_CHANGED;
 	}
 
 	public void setProjectSourceFiles(List projectSourceFiles) {
 		this.projectSourceFiles = projectSourceFiles;
+		this.changed |= ICompilerConfiguration.PROJECTSOURCEFILES_CHANGED;
+	}
+
+	public void addProjectSourceFileChanged(File f) {
+		if (this.modifiedFiles == null) {
+			this.modifiedFiles = new ArrayList();
+		}
+		if (f != null) {
+			modifiedFiles.add(f);
+		}
 	}
 
 	public void setSourcePathResources(Map sourcePathResources) {
 		this.sourcePathResources = sourcePathResources;
+		this.changed |= ICompilerConfiguration.PROJECTSOURCERESOURCES_CHANGED;
 	}
-	
-	public void setOutputLocationManager(IOutputLocationManager manager)  {
+
+	public void setOutputLocationManager(IOutputLocationManager manager) {
 		this.outputLocationManager = manager;
 	}
-	
+
 	public void setClasspath(String path) {
 		this.classPath = path;
+		this.changed |= ICompilerConfiguration.CLASSPATH_CHANGED;
 	}
+
+	public int getConfigurationChanges() {
+		return changed;
+		// return EVERYTHING;
+	}
+
+	public void configurationRead() {
+		changed = NO_CHANGES;
+		modifiedFiles = null;
+	}
+
 }
@@ -20,6 +20,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
+import org.aspectj.ajde.core.ICompilerConfiguration;
 import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.ajdt.internal.core.builder.AjState;
 import org.aspectj.ajdt.internal.core.builder.IncrementalStateManager;
@@ -36,45 +37,26 @@ import org.aspectj.tools.ajc.Ajc;
 import org.aspectj.util.FileUtil;
 
 /**
- * The superclass knows all about talking through Ajde to the compiler.
- * The superclass isn't in charge of knowing how to simulate overlays
- * for incremental builds, that is in here.  As is the ability to
- * generate valid build configs based on a directory structure.  To
- * support this we just need access to a sandbox directory - this
- * sandbox is managed by the superclass (it only assumes all builds occur
- * in <sandboxDir>/<projectName>/ )
+ * The superclass knows all about talking through Ajde to the compiler. The superclass isn't in charge of knowing how to simulate
+ * overlays for incremental builds, that is in here. As is the ability to generate valid build configs based on a directory
+ * structure. To support this we just need access to a sandbox directory - this sandbox is managed by the superclass (it only
+ * assumes all builds occur in <sandboxDir>/<projectName>/ )
  * 
- * The idea is you can initialize multiple projects in the sandbox and
- * they can all be built independently, hopefully exploiting
- * incremental compilation.  Between builds you can alter the contents
- * of a project using the alter() method that overlays some set of 
- * new files onto the current set (adding new files/changing existing
- * ones) - you can then drive a new build and check it behaves as
- * expected.
+ * The idea is you can initialize multiple projects in the sandbox and they can all be built independently, hopefully exploiting
+ * incremental compilation. Between builds you can alter the contents of a project using the alter() method that overlays some set
+ * of new files onto the current set (adding new files/changing existing ones) - you can then drive a new build and check it behaves
+ * as expected.
  */
 public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementalAjdeInteractionTestbed {
 
 	/*
-	A.aj
-	package pack;
-	public aspect A {
-	        pointcut p() : call(* C.method
-	        before() : p() { // line 7
-	        }
-	}
-
-	C.java
-	package pack;
-	public class C {
-	        public void method1() {
-	          method2(); // line 6
-	        }
-	        public void method2() {   }
-	        public void method3() { 
-	          method2();  // line 13
-	        }
-
-	}*/
+	 * A.aj package pack; public aspect A { pointcut p() : call( C.method before() : p() { // line 7 } }
+	 * 
+	 * C.java package pack; public class C { public void method1() { method2(); // line 6 } public void method2() { } public void
+	 * method3() { method2(); // line 13 }
+	 * 
+	 * }
+	 */
 	public void testDontLoseAdviceMarkers_pr134471() {
 		try {
 			// see pr148027 AsmHierarchyBuilder.shouldAddUsesPointcut=false;
@@ -82,45 +64,40 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 			build("P4");
 			Ajc.dumpAJDEStructureModel("after full build where advice is applying");
 			// should be 4 relationship entries
-	
+
 			// In inc1 the first advised line is 'commented out'
-			alter("P4","inc1");
+			alter("P4", "inc1");
 			build("P4");
 			checkWasntFullBuild();
 			Ajc.dumpAJDEStructureModel("after inc build where first advised line is gone");
 			// should now be 2 relationship entries
-			
+
 			// This will be the line 6 entry in C.java
-			IProgramElement codeElement = findCode(checkForNode("pack","C",true));
-			
+			IProgramElement codeElement = findCode(checkForNode("pack", "C", true));
+
 			// This will be the line 7 entry in A.java
-			IProgramElement advice = findAdvice(checkForNode("pack","A",true));
-			
+			IProgramElement advice = findAdvice(checkForNode("pack", "A", true));
+
 			IRelationshipMap asmRelMap = AsmManager.getDefault().getRelationshipMap();
-			assertEquals("There should be two relationships in the relationship map",
-					2,asmRelMap.getEntries().size());
-	
+			assertEquals("There should be two relationships in the relationship map", 2, asmRelMap.getEntries().size());
+
 			for (Iterator iter = asmRelMap.getEntries().iterator(); iter.hasNext();) {
 				String sourceOfRelationship = (String) iter.next();
-				IProgramElement ipe = AsmManager.getDefault().getHierarchy()
-										.findElementForHandle(sourceOfRelationship);
-				assertNotNull("expected to find IProgramElement with handle " 
-						+ sourceOfRelationship + " but didn't",ipe);
+				IProgramElement ipe = AsmManager.getDefault().getHierarchy().findElementForHandle(sourceOfRelationship);
+				assertNotNull("expected to find IProgramElement with handle " + sourceOfRelationship + " but didn't", ipe);
 				if (ipe.getKind().equals(IProgramElement.Kind.ADVICE)) {
-					assertEquals("expected source of relationship to be " +
-							advice.toString() + " but found " +
-							ipe.toString(),advice,ipe);
+					assertEquals("expected source of relationship to be " + advice.toString() + " but found " + ipe.toString(),
+							advice, ipe);
 				} else if (ipe.getKind().equals(IProgramElement.Kind.CODE)) {
-					assertEquals("expected source of relationship to be " +
-							codeElement.toString() + " but found " +
-							ipe.toString(),codeElement,ipe);
+					assertEquals(
+							"expected source of relationship to be " + codeElement.toString() + " but found " + ipe.toString(),
+							codeElement, ipe);
 				} else {
-					fail("found unexpected relationship source " + ipe 
-							+ " with kind " + ipe.getKind()+" when looking up handle: "+sourceOfRelationship);
+					fail("found unexpected relationship source " + ipe + " with kind " + ipe.getKind()
+							+ " when looking up handle: " + sourceOfRelationship);
 				}
 				List relationships = asmRelMap.get(ipe);
-				assertNotNull("expected " + ipe.getName() +" to have some " +
-						"relationships",relationships);
+				assertNotNull("expected " + ipe.getName() + " to have some " + "relationships", relationships);
 				for (Iterator iterator = relationships.iterator(); iterator.hasNext();) {
 					Relationship rel = (Relationship) iterator.next();
 					List targets = rel.getTargets();
@@ -128,43 +105,40 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 						String t = (String) iterator2.next();
 						IProgramElement link = AsmManager.getDefault().getHierarchy().findElementForHandle(t);
 						if (ipe.getKind().equals(IProgramElement.Kind.ADVICE)) {
-							assertEquals("expected target of relationship to be " +
-									codeElement.toString() + " but found " +
-									link.toString(),codeElement,link);
+							assertEquals("expected target of relationship to be " + codeElement.toString() + " but found "
+									+ link.toString(), codeElement, link);
 						} else if (ipe.getKind().equals(IProgramElement.Kind.CODE)) {
-							assertEquals("expected target of relationship to be " +
-									advice.toString() + " but found " +
-									link.toString(),advice,link);	
+							assertEquals("expected target of relationship to be " + advice.toString() + " but found "
+									+ link.toString(), advice, link);
 						} else {
-							fail("found unexpected relationship source " + ipe.getName() 
-									+ " with kind " + ipe.getKind());
+							fail("found unexpected relationship source " + ipe.getName() + " with kind " + ipe.getKind());
 						}
-					}				
+					}
 				}
 			}
-			
+
 		} finally {
 			// see pr148027 AsmHierarchyBuilder.shouldAddUsesPointcut=true;
-			//configureBuildStructureModel(false);
+			// configureBuildStructureModel(false);
 		}
 	}
-	
+
 	public void testIncrementalItdsWithMultipleAspects_pr173729() {
 		initialiseProject("PR173729");
 		build("PR173729");
 		checkWasFullBuild();
-		alter("PR173729","inc1");
+		alter("PR173729", "inc1");
 		build("PR173729");
 		checkWasntFullBuild();
 	}
-	
+
 	// Compile a single simple project
 	public void testTheBasics() {
 		initialiseProject("P1");
 		build("P1"); // This first build will be batch
 		build("P1");
 		checkWasntFullBuild();
-		checkCompileWeaveCount("P1",0,0);
+		checkCompileWeaveCount("P1", 0, 0);
 	}
 
 	// source code doesnt matter, we are checking invalid path handling
@@ -173,74 +147,62 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		File f = new File("foo.jar");
 		Set s = new HashSet();
 		s.add(f);
-		configureAspectPath("P1",s);
+		configureAspectPath("P1", s);
 		build("P1"); // This first build will be batch
-		checkForError("P1","invalid aspectpath entry");
+		checkForError("P1", "invalid aspectpath entry");
 	}
-	
-	
+
 	/**
-	 * Build a project containing a resource - then mark the resource readOnly(), then
-	 * do an inc-compile, it will report an error about write access to the resource
-	 * in the output folder being denied
+	 * Build a project containing a resource - then mark the resource readOnly(), then do an inc-compile, it will report an error
+	 * about write access to the resource in the output folder being denied
 	 */
-	/*public void testProblemCopyingResources_pr138171() {
-		initialiseProject("PR138171");
-		
-		File f=getProjectRelativePath("PR138171","res.txt");
-		Map m = new HashMap();
-		m.put("res.txt",f);
-		AjdeInteractionTestbed.MyProjectPropertiesAdapter.getInstance().setSourcePathResources(m);
-		build("PR138171");
-		File f2 = getProjectOutputRelativePath("PR138171","res.txt");
-		boolean successful = f2.setReadOnly();
-		
-		alter("PR138171","inc1");
-		AjdeInteractionTestbed.MyProjectPropertiesAdapter.getInstance().setSourcePathResources(m);
-		build("PR138171");
-		List msgs = MyTaskListManager.getErrorMessages();
-		assertTrue("there should be one message but there are "+(msgs==null?0:msgs.size())+":\n"+msgs,msgs!=null && msgs.size()==1);
-		IMessage msg = (IMessage)msgs.get(0);
-		String exp = "unable to copy resource to output folder: 'res.txt'";
-		assertTrue("Expected message to include this text ["+exp+"] but it does not: "+msg,msg.toString().indexOf(exp)!=-1);
-	}*/
-	
-	
+	/*
+	 * public void testProblemCopyingResources_pr138171() { initialiseProject("PR138171");
+	 * 
+	 * File f=getProjectRelativePath("PR138171","res.txt"); Map m = new HashMap(); m.put("res.txt",f);
+	 * AjdeInteractionTestbed.MyProjectPropertiesAdapter.getInstance().setSourcePathResources(m); build("PR138171"); File f2 =
+	 * getProjectOutputRelativePath("PR138171","res.txt"); boolean successful = f2.setReadOnly();
+	 * 
+	 * alter("PR138171","inc1"); AjdeInteractionTestbed.MyProjectPropertiesAdapter.getInstance().setSourcePathResources(m);
+	 * build("PR138171"); List msgs = MyTaskListManager.getErrorMessages();
+	 * assertTrue("there should be one message but there are "+(msgs==null?0:msgs.size())+":\n"+msgs,msgs!=null && msgs.size()==1);
+	 * IMessage msg = (IMessage)msgs.get(0); String exp = "unable to copy resource to output folder: 'res.txt'";
+	 * assertTrue("Expected message to include this text ["+exp+"] but it does not: "+msg,msg.toString().indexOf(exp)!=-1); }
+	 */
+
 	// Make simple changes to a project, adding a class
 	public void testSimpleChanges() {
+		AjdeInteractionTestbed.VERBOSE = true;
 		initialiseProject("P1");
 		build("P1"); // This first build will be batch
-		alter("P1","inc1"); // adds a single class
+		alter("P1", "inc1"); // adds a single class
+		build("P1");
+		checkCompileWeaveCount("P1", 1, -1);
 		build("P1");
-		checkCompileWeaveCount("P1",1,-1);
-		build("P1"); 
-		checkCompileWeaveCount("P1",0,-1);
+		checkCompileWeaveCount("P1", 0, -1);
 	}
-	
-	
+
 	// Make simple changes to a project, adding a class and an aspect
 	public void testAddingAnAspect() {
 		initialiseProject("P1");
-		build("P1");							// build 1, weave 1
-		alter("P1","inc1"); // adds a class
-		alter("P1","inc2"); // adds an aspect
-		build("P1");                            // build 1,
+		build("P1"); // build 1, weave 1
+		alter("P1", "inc1"); // adds a class
+		alter("P1", "inc2"); // adds an aspect
+		build("P1"); // build 1,
 		long timeTakenForFullBuildAndWeave = getTimeTakenForBuild("P1");
-		checkWasFullBuild();  // it *will* be a full build under the new 
-		                      // "back-to-the-source strategy
-		checkCompileWeaveCount("P1",5,3); // we compile X and A (the delta) find out that
-		                             // an aspect has changed, go back to the source
-									 // and compile X,A,C, then weave them all.
+		checkWasFullBuild(); // it *will* be a full build under the new
+		// "back-to-the-source strategy
+		checkCompileWeaveCount("P1", 5, 3); // we compile X and A (the delta) find out that
+		// an aspect has changed, go back to the source
+		// and compile X,A,C, then weave them all.
 		build("P1");
 		long timeTakenForSimpleIncBuild = getTimeTakenForBuild("P1");
 		// I don't think this test will have timing issues as the times should be *RADICALLY* different
-		// On my config, first build time is 2093ms  and the second is 30ms
-		assertTrue("Should not take longer for the trivial incremental build!  first="+timeTakenForFullBuildAndWeave+
-				   "ms  second="+timeTakenForSimpleIncBuild+"ms",
-				   timeTakenForSimpleIncBuild<timeTakenForFullBuildAndWeave);
+		// On my config, first build time is 2093ms and the second is 30ms
+		assertTrue("Should not take longer for the trivial incremental build!  first=" + timeTakenForFullBuildAndWeave
+				+ "ms  second=" + timeTakenForSimpleIncBuild + "ms", timeTakenForSimpleIncBuild < timeTakenForFullBuildAndWeave);
 	}
-	
-	
+
 	public void testBuildingTwoProjectsInTurns() {
 		initialiseProject("P1");
 		initialiseProject("P2");
@@ -253,99 +215,87 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 	}
 
 	public void testBuildingBrokenCode_pr240360() {
-		AjdeInteractionTestbed.VERBOSE=true;
+		AjdeInteractionTestbed.VERBOSE = true;
 		initialiseProject("pr240360");
-		//configureNonStandardCompileOptions("pr240360","-proceedOnError");
+		// configureNonStandardCompileOptions("pr240360","-proceedOnError");
 		build("pr240360");
 		checkWasFullBuild();
-		checkCompileWeaveCount("pr240360",5,4);
-		assertTrue("There should be an error:\n"
-				+getErrorMessages("pr240360"),!getErrorMessages("pr240360").isEmpty());	
+		checkCompileWeaveCount("pr240360", 5, 4);
+		assertTrue("There should be an error:\n" + getErrorMessages("pr240360"), !getErrorMessages("pr240360").isEmpty());
 
 		Set s = AsmManager.getDefault().getRelationshipMap().getEntries();
 		int relmapLength = s.size();
 
 		// Delete the erroneous type
-		String f = getWorkingDir().getAbsolutePath() + File.separatorChar + "pr240360" + File.separatorChar + "src" + File.separatorChar + "test" + File.separatorChar + "Error.java";
+		String f = getWorkingDir().getAbsolutePath() + File.separatorChar + "pr240360" + File.separatorChar + "src"
+				+ File.separatorChar + "test" + File.separatorChar + "Error.java";
 		(new File(f)).delete();
 		build("pr240360");
 		checkWasntFullBuild();
-		checkCompileWeaveCount("pr240360",0,0);		
-		assertEquals(relmapLength,AsmManager.getDefault().getRelationshipMap().getEntries().size());
-		
+		checkCompileWeaveCount("pr240360", 0, 0);
+		assertEquals(relmapLength, AsmManager.getDefault().getRelationshipMap().getEntries().size());
+
 		// Readd the erroneous type
-		alter("pr240360","inc1");
+		alter("pr240360", "inc1");
 		build("pr240360");
 		checkWasntFullBuild();
-		checkCompileWeaveCount("pr240360",1,0);
-		assertEquals(relmapLength,AsmManager.getDefault().getRelationshipMap().getEntries().size());
+		checkCompileWeaveCount("pr240360", 1, 0);
+		assertEquals(relmapLength, AsmManager.getDefault().getRelationshipMap().getEntries().size());
 
 		// Change the advice
-		alter("pr240360","inc2");
+		alter("pr240360", "inc2");
 		build("pr240360");
 		checkWasFullBuild();
-		checkCompileWeaveCount("pr240360",6,4);
-		assertEquals(relmapLength,AsmManager.getDefault().getRelationshipMap().getEntries().size());
-	
+		checkCompileWeaveCount("pr240360", 6, 4);
+		assertEquals(relmapLength, AsmManager.getDefault().getRelationshipMap().getEntries().size());
+
 	}
-	
-	
+
 	public void testBrokenCodeCompilation() {
 		initialiseProject("pr102733_1");
-//		configureNonStandardCompileOptions("pr102733_1","-proceedOnError");
+		// configureNonStandardCompileOptions("pr102733_1","-proceedOnError");
 		build("pr102733_1");
 		checkWasFullBuild();
-		checkCompileWeaveCount("pr102733_1",1,0);
-		assertTrue("There should be an error:\n"
-				+getErrorMessages("pr102733_1"),!getErrorMessages("pr102733_1").isEmpty());	
+		checkCompileWeaveCount("pr102733_1", 1, 0);
+		assertTrue("There should be an error:\n" + getErrorMessages("pr102733_1"), !getErrorMessages("pr102733_1").isEmpty());
 		build("pr102733_1"); // incremental
-		checkCompileWeaveCount("pr102733_1",0,0);
-		checkWasntFullBuild();		
-		alter("pr102733_1","inc1"); // fix the error
+		checkCompileWeaveCount("pr102733_1", 0, 0);
+		checkWasntFullBuild();
+		alter("pr102733_1", "inc1"); // fix the error
 		build("pr102733_1");
-		checkWasntFullBuild();		
-		checkCompileWeaveCount("pr102733_1",1,1);
-		assertTrue("There should be no errors:\n"
-				+getErrorMessages("pr102733_1"),getErrorMessages("pr102733_1").isEmpty());	
-		alter("pr102733_1","inc2"); // break it again
+		checkWasntFullBuild();
+		checkCompileWeaveCount("pr102733_1", 1, 1);
+		assertTrue("There should be no errors:\n" + getErrorMessages("pr102733_1"), getErrorMessages("pr102733_1").isEmpty());
+		alter("pr102733_1", "inc2"); // break it again
 		build("pr102733_1");
-		checkWasntFullBuild();		
-		checkCompileWeaveCount("pr102733_1",1,0);
-		assertTrue("There should be an error:\n"
-				+getErrorMessages("pr102733_1"),!getErrorMessages("pr102733_1").isEmpty());	
-	}
-	
-//	public void testDeclareAtType_pr149293() {
-//		configureBuildStructureModel(true);
-//		initialiseProject("PR149293_1");
-//		build("PR149293_1");
-//		checkCompileWeaveCount(4,5);
-//		assertNoErrors();
-//		alter("PR149293_1","inc1");
-//		build("PR149293_1");
-//		assertNoErrors();
-//	}
-	
-/*
-	public void testRefactoring_pr148285() {
-		configureBuildStructureModel(true);
-		initialiseProject("PR148285");
-		build("PR148285");
-		System.err.println("xxx");
-		alter("PR148285","inc1");
-		build("PR148285");
-	}
-*/
-	
-	
+		checkWasntFullBuild();
+		checkCompileWeaveCount("pr102733_1", 1, 0);
+		assertTrue("There should be an error:\n" + getErrorMessages("pr102733_1"), !getErrorMessages("pr102733_1").isEmpty());
+	}
+
+	// public void testDeclareAtType_pr149293() {
+	// configureBuildStructureModel(true);
+	// initialiseProject("PR149293_1");
+	// build("PR149293_1");
+	// checkCompileWeaveCount(4,5);
+	// assertNoErrors();
+	// alter("PR149293_1","inc1");
+	// build("PR149293_1");
+	// assertNoErrors();
+	// }
+
+	/*
+	 * public void testRefactoring_pr148285() { configureBuildStructureModel(true); initialiseProject("PR148285");
+	 * build("PR148285"); System.err.println("xxx"); alter("PR148285","inc1"); build("PR148285"); }
+	 */
+
 	/**
-	 * In order for this next test to run, I had to move the weaver/world pair we keep in the
-	 * AjBuildManager instance down into the state object - this makes perfect sense - otherwise
-	 * when reusing the state for another project we'd not be switching to the right weaver/world
-	 * for that project.
+	 * In order for this next test to run, I had to move the weaver/world pair we keep in the AjBuildManager instance down into the
+	 * state object - this makes perfect sense - otherwise when reusing the state for another project we'd not be switching to the
+	 * right weaver/world for that project.
 	 */
 	public void testBuildingTwoProjectsMakingSmallChanges() {
-		
+
 		initialiseProject("P1");
 		initialiseProject("P2");
 
@@ -353,249 +303,224 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		build("P2");
 		build("P1");
 		checkWasntFullBuild();
-		
+
 		build("P2");
 		checkWasntFullBuild();
-		
-		alter("P1","inc1"); // adds a class
-		alter("P1","inc2"); // adds an aspect
+
+		alter("P1", "inc1"); // adds a class
+		alter("P1", "inc2"); // adds an aspect
 		build("P1");
-		checkWasFullBuild();  // adding an aspect makes us go back to the source
+		checkWasFullBuild(); // adding an aspect makes us go back to the source
 	}
 
 	public void testPr134371() {
 		initialiseProject("PR134371");
 		build("PR134371");
-		alter("PR134371","inc1");
+		alter("PR134371", "inc1");
 		build("PR134371");
-		assertTrue("There should be no exceptions handled:\n"
-				+getErrorMessages("PR134371"),getErrorMessages("PR134371").isEmpty());		
+		assertTrue("There should be no exceptions handled:\n" + getErrorMessages("PR134371"), getErrorMessages("PR134371")
+				.isEmpty());
 
 	}
-	
-	/** 
-	 * Setup up two simple projects and build them in turn - check the
-	 * structure model is right after each build 
+
+	/**
+	 * Setup up two simple projects and build them in turn - check the structure model is right after each build
 	 */
 	public void testBuildingTwoProjectsAndVerifyingModel() {
 		initialiseProject("P1");
 		initialiseProject("P2");
 
-		build("P1");	
-		checkForNode("pkg","C",true);
+		build("P1");
+		checkForNode("pkg", "C", true);
 
 		build("P2");
-		checkForNode("pkg","C",false);
+		checkForNode("pkg", "C", false);
 
 		build("P1");
-		checkForNode("pkg","C",true);
-		
+		checkForNode("pkg", "C", true);
+
 		build("P2");
-		checkForNode("pkg","C",false);
+		checkForNode("pkg", "C", false);
 	}
 
-
 	// Setup up two simple projects and build them in turn - check the
 	// structure model is right after each build
 	public void testBuildingTwoProjectsAndVerifyingStuff() {
 		initialiseProject("P1");
 		initialiseProject("P2");
 
-		build("P1");	
-		checkForNode("pkg","C",true);
+		build("P1");
+		checkForNode("pkg", "C", true);
 
 		build("P2");
-		checkForNode("pkg","C",false);
+		checkForNode("pkg", "C", false);
 
 		build("P1");
-		checkForNode("pkg","C",true);
-		
+		checkForNode("pkg", "C", true);
+
 		build("P2");
-		checkForNode("pkg","C",false);
+		checkForNode("pkg", "C", false);
 	}
-	
 
 	/**
-	 * Complex.  Here we are testing that a state object records structural changes since
-	 * the last full build correctly.  We build a simple project from scratch - this will
-	 * be a full build and so the structural changes since last build count should be 0.
-	 * We then alter a class, adding a new method and check structural changes is 1.
+	 * Complex. Here we are testing that a state object records structural changes since the last full build correctly. We build a
+	 * simple project from scratch - this will be a full build and so the structural changes since last build count should be 0. We
+	 * then alter a class, adding a new method and check structural changes is 1.
 	 */
 	public void testStateManagement1() {
-		
-		File binDirectoryForP1 = new File(getFile("P1","bin"));
-		
+
+		File binDirectoryForP1 = new File(getFile("P1", "bin"));
+
 		initialiseProject("P1");
 		build("P1"); // full build
 		AjState ajs = IncrementalStateManager.findStateManagingOutputLocation(binDirectoryForP1);
-		assertTrue("There should be a state object for project P1",ajs!=null);
-		assertTrue("Should be no structural changes as it was a full build but found: "+
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild()==0);
-		
-		
-		alter("P1","inc3"); // adds a method to the class C.java
+		assertTrue("There should be a state object for project P1", ajs != null);
+		assertTrue("Should be no structural changes as it was a full build but found: "
+				+ ajs.getNumberOfStructuralChangesSinceLastFullBuild(), ajs.getNumberOfStructuralChangesSinceLastFullBuild() == 0);
+
+		alter("P1", "inc3"); // adds a method to the class C.java
 		build("P1");
 		checkWasntFullBuild();
-		ajs = IncrementalStateManager.findStateManagingOutputLocation(new File(getFile("P1","bin")));
-		assertTrue("There should be state for project P1",ajs!=null);
+		ajs = IncrementalStateManager.findStateManagingOutputLocation(new File(getFile("P1", "bin")));
+		assertTrue("There should be state for project P1", ajs != null);
 		checkWasntFullBuild();
-		assertTrue("Should be one structural changes as it was a full build but found: "+
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild()==1);
+		assertTrue("Should be one structural changes as it was a full build but found: "
+				+ ajs.getNumberOfStructuralChangesSinceLastFullBuild(), ajs.getNumberOfStructuralChangesSinceLastFullBuild() == 1);
 
 	}
-	
-	
+
 	/**
-	 * Complex.  Here we are testing that a state object records structural changes since
-	 * the last full build correctly.  We build a simple project from scratch - this will
-	 * be a full build and so the structural changes since last build count should be 0.
-	 * We then alter a class, changing body of a method, not the structure and
-	 * check struc changes is still 0.
+	 * Complex. Here we are testing that a state object records structural changes since the last full build correctly. We build a
+	 * simple project from scratch - this will be a full build and so the structural changes since last build count should be 0. We
+	 * then alter a class, changing body of a method, not the structure and check struc changes is still 0.
 	 */
-	public void testStateManagement2() {		
-		File binDirectoryForP1 = new File(getFile("P1","bin"));
-		
+	public void testStateManagement2() {
+		File binDirectoryForP1 = new File(getFile("P1", "bin"));
+
 		initialiseProject("P1");
-		alter("P1","inc3"); // need this change in here so 'inc4' can be applied without making
-		                    // it a structural change
+		alter("P1", "inc3"); // need this change in here so 'inc4' can be applied without making
+		// it a structural change
 		build("P1"); // full build
 		AjState ajs = IncrementalStateManager.findStateManagingOutputLocation(binDirectoryForP1);
-		assertTrue("There should be state for project P1",ajs!=null);
-		assertTrue("Should be no struc changes as its a full build: "+
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild()==0);
-		
-		
-		alter("P1","inc4"); // changes body of main() method but does *not* change the structure of C.java
+		assertTrue("There should be state for project P1", ajs != null);
+		assertTrue("Should be no struc changes as its a full build: " + ajs.getNumberOfStructuralChangesSinceLastFullBuild(), ajs
+				.getNumberOfStructuralChangesSinceLastFullBuild() == 0);
+
+		alter("P1", "inc4"); // changes body of main() method but does *not* change the structure of C.java
 		build("P1");
 		checkWasntFullBuild();
-		ajs = IncrementalStateManager.findStateManagingOutputLocation(new File(getFile("P1","bin")));
-		assertTrue("There should be state for project P1",ajs!=null);
+		ajs = IncrementalStateManager.findStateManagingOutputLocation(new File(getFile("P1", "bin")));
+		assertTrue("There should be state for project P1", ajs != null);
 		checkWasntFullBuild();
-		assertTrue("Shouldn't be any structural changes but there were "+
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild()==0);
+		assertTrue("Shouldn't be any structural changes but there were " + ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
+				ajs.getNumberOfStructuralChangesSinceLastFullBuild() == 0);
 	}
-	
+
 	/**
-	 * The C.java file modified in this test has an inner class - this means the inner class
-	 * has a this$0 field and <init>(C) ctor to watch out for when checking for structural changes
-	 *
+	 * The C.java file modified in this test has an inner class - this means the inner class has a this$0 field and <init>(C) ctor
+	 * to watch out for when checking for structural changes
+	 * 
 	 */
-	public void testStateManagement3() {		
-		File binDirForInterproject1 = new File(getFile("interprojectdeps1","bin"));
-		
+	public void testStateManagement3() {
+		File binDirForInterproject1 = new File(getFile("interprojectdeps1", "bin"));
+
 		initialiseProject("interprojectdeps1");
 		build("interprojectdeps1"); // full build
 		AjState ajs = IncrementalStateManager.findStateManagingOutputLocation(binDirForInterproject1);
-		assertTrue("There should be state for project P1",ajs!=null);
-		assertTrue("Should be no struc changes as its a full build: "+
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild()==0);
-		
-		
-		alter("interprojectdeps1","inc1"); // adds a space to C.java
+		assertTrue("There should be state for project P1", ajs != null);
+		assertTrue("Should be no struc changes as its a full build: " + ajs.getNumberOfStructuralChangesSinceLastFullBuild(), ajs
+				.getNumberOfStructuralChangesSinceLastFullBuild() == 0);
+
+		alter("interprojectdeps1", "inc1"); // adds a space to C.java
 		build("interprojectdeps1");
 		checkWasntFullBuild();
-		ajs = IncrementalStateManager.findStateManagingOutputLocation(new File(getFile("interprojectdeps1","bin")));
-		assertTrue("There should be state for project interprojectdeps1",ajs!=null);
+		ajs = IncrementalStateManager.findStateManagingOutputLocation(new File(getFile("interprojectdeps1", "bin")));
+		assertTrue("There should be state for project interprojectdeps1", ajs != null);
 		checkWasntFullBuild();
-		assertTrue("Shouldn't be any structural changes but there were "+
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild()==0);
+		assertTrue("Shouldn't be any structural changes but there were " + ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
+				ajs.getNumberOfStructuralChangesSinceLastFullBuild() == 0);
 	}
-	
+
 	/**
-	 * The C.java file modified in this test has an inner class - which has two ctors - this checks
-	 * how they are mangled with an instance of C.
-	 *
+	 * The C.java file modified in this test has an inner class - which has two ctors - this checks how they are mangled with an
+	 * instance of C.
+	 * 
 	 */
-	public void testStateManagement4() {		
-		File binDirForInterproject2 = new File(getFile("interprojectdeps2","bin"));
-		
+	public void testStateManagement4() {
+		File binDirForInterproject2 = new File(getFile("interprojectdeps2", "bin"));
+
 		initialiseProject("interprojectdeps2");
 		build("interprojectdeps2"); // full build
 		AjState ajs = IncrementalStateManager.findStateManagingOutputLocation(binDirForInterproject2);
-		assertTrue("There should be state for project interprojectdeps2",ajs!=null);
-		assertTrue("Should be no struc changes as its a full build: "+
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild()==0);
-		
-		
-		alter("interprojectdeps2","inc1"); // minor change to C.java
+		assertTrue("There should be state for project interprojectdeps2", ajs != null);
+		assertTrue("Should be no struc changes as its a full build: " + ajs.getNumberOfStructuralChangesSinceLastFullBuild(), ajs
+				.getNumberOfStructuralChangesSinceLastFullBuild() == 0);
+
+		alter("interprojectdeps2", "inc1"); // minor change to C.java
 		build("interprojectdeps2");
 		checkWasntFullBuild();
-		ajs = IncrementalStateManager.findStateManagingOutputLocation(new File(getFile("interprojectdeps2","bin")));
-		assertTrue("There should be state for project interprojectdeps1",ajs!=null);
+		ajs = IncrementalStateManager.findStateManagingOutputLocation(new File(getFile("interprojectdeps2", "bin")));
+		assertTrue("There should be state for project interprojectdeps1", ajs != null);
 		checkWasntFullBuild();
-		assertTrue("Shouldn't be any structural changes but there were "+
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild()==0);
+		assertTrue("Shouldn't be any structural changes but there were " + ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
+				ajs.getNumberOfStructuralChangesSinceLastFullBuild() == 0);
 	}
-	
+
 	/**
-	 * The C.java file modified in this test has an inner class - it has two ctors but
-	 * also a reference to C.this in it - which will give rise to an accessor being
-	 * created in C
-	 *
+	 * The C.java file modified in this test has an inner class - it has two ctors but also a reference to C.this in it - which will
+	 * give rise to an accessor being created in C
+	 * 
 	 */
-	public void testStateManagement5() {		
-		File binDirForInterproject3 = new File(getFile("interprojectdeps3","bin"));
-		
+	public void testStateManagement5() {
+		File binDirForInterproject3 = new File(getFile("interprojectdeps3", "bin"));
+
 		initialiseProject("interprojectdeps3");
 		build("interprojectdeps3"); // full build
 		AjState ajs = IncrementalStateManager.findStateManagingOutputLocation(binDirForInterproject3);
-		assertTrue("There should be state for project interprojectdeps3",ajs!=null);
-		assertTrue("Should be no struc changes as its a full build: "+
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild()==0);
-		
-		
-		alter("interprojectdeps3","inc1"); // minor change to C.java
+		assertTrue("There should be state for project interprojectdeps3", ajs != null);
+		assertTrue("Should be no struc changes as its a full build: " + ajs.getNumberOfStructuralChangesSinceLastFullBuild(), ajs
+				.getNumberOfStructuralChangesSinceLastFullBuild() == 0);
+
+		alter("interprojectdeps3", "inc1"); // minor change to C.java
 		build("interprojectdeps3");
 		checkWasntFullBuild();
-		ajs = IncrementalStateManager.findStateManagingOutputLocation(new File(getFile("interprojectdeps3","bin")));
-		assertTrue("There should be state for project interprojectdeps1",ajs!=null);
+		ajs = IncrementalStateManager.findStateManagingOutputLocation(new File(getFile("interprojectdeps3", "bin")));
+		assertTrue("There should be state for project interprojectdeps1", ajs != null);
 		checkWasntFullBuild();
-		assertTrue("Shouldn't be any structural changes but there were "+
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild()==0);
+		assertTrue("Shouldn't be any structural changes but there were " + ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
+				ajs.getNumberOfStructuralChangesSinceLastFullBuild() == 0);
 	}
-	
+
 	/**
-	 * Now the most complex test.  Create a dependancy between two projects.  Building
-	 * one may affect whether the other does an incremental or full build.  The
-	 * structural information recorded in the state object should be getting used
-	 * to control whether a full build is necessary...
+	 * Now the most complex test. Create a dependancy between two projects. Building one may affect whether the other does an
+	 * incremental or full build. The structural information recorded in the state object should be getting used to control whether
+	 * a full build is necessary...
 	 */
 	public void testBuildingDependantProjects() {
 		initialiseProject("P1");
 		initialiseProject("P2");
-		configureNewProjectDependency("P2","P1");
-		
+		configureNewProjectDependency("P2", "P1");
+
 		build("P1");
 		build("P2"); // now everything is consistent and compiled
-		alter("P1","inc1"); // adds a second class
+		alter("P1", "inc1"); // adds a second class
 		build("P1");
 		build("P2"); // although a second class was added - P2 can't be using it, so we don't full build here :)
 		checkWasntFullBuild();
-		alter("P1","inc3"); // structurally changes one of the classes
+		alter("P1", "inc3"); // structurally changes one of the classes
 		build("P1");
 		build("P2"); // build notices the structural change, but is incremental of I and J as they depend on C
 		checkWasntFullBuild();
-		alter("P1","inc4");
+		alter("P1", "inc4");
 		build("P1");
 		build("P2"); // build sees a change but works out its not structural
 		checkWasntFullBuild();
 	}
-	
-	
+
 	public void testPr85132() {
 		initialiseProject("PR85132");
 		build("PR85132");
-		alter("PR85132","inc1");
+		alter("PR85132", "inc1");
 		build("PR85132");
 	}
 
@@ -603,562 +528,521 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 	public void testPr125405() {
 		initialiseProject("PR125405");
 		build("PR125405");
-		checkCompileWeaveCount("PR125405",1,1);
-		alter("PR125405","inc1");
+		checkCompileWeaveCount("PR125405", 1, 1);
+		alter("PR125405", "inc1");
 		build("PR125405");
 		// "only abstract aspects can have type parameters"
-		checkForError("PR125405","only abstract aspects can have type parameters");
-		alter("PR125405","inc2");
+		checkForError("PR125405", "only abstract aspects can have type parameters");
+		alter("PR125405", "inc2");
 		build("PR125405");
-		checkCompileWeaveCount("PR125405",1,1);
-		assertTrue("Should be no errors, but got "+getErrorMessages("PR125405"),
-				getErrorMessages("PR125405").size()==0);		
+		checkCompileWeaveCount("PR125405", 1, 1);
+		assertTrue("Should be no errors, but got " + getErrorMessages("PR125405"), getErrorMessages("PR125405").size() == 0);
 	}
-	
+
 	public void testPr128618() {
 		initialiseProject("PR128618_1");
 		initialiseProject("PR128618_2");
-		configureNewProjectDependency("PR128618_2","PR128618_1");
-		assertTrue("there should be no warning messages before we start",
-				getWarningMessages("PR128618_1").isEmpty());
-		assertTrue("there should be no warning messages before we start",
-				getWarningMessages("PR128618_2").isEmpty());
-		
+		configureNewProjectDependency("PR128618_2", "PR128618_1");
+		assertTrue("there should be no warning messages before we start", getWarningMessages("PR128618_1").isEmpty());
+		assertTrue("there should be no warning messages before we start", getWarningMessages("PR128618_2").isEmpty());
+
 		build("PR128618_1");
 		build("PR128618_2");
 		List l = getWarningMessages("PR128618_2");
-		
+
 		// there should be one warning against "PR128618_2"
 		List warnings = getWarningMessages("PR128618_2");
-		assertTrue("Should be one warning, but there are #"+warnings.size(),warnings.size()==1);
-		IMessage msg = (IMessage)(getWarningMessages("PR128618_2").get(0));
-		assertEquals("warning should be against the FFDC.aj resource","FFDC.aj",msg.getSourceLocation().getSourceFile().getName());
+		assertTrue("Should be one warning, but there are #" + warnings.size(), warnings.size() == 1);
+		IMessage msg = (IMessage) (getWarningMessages("PR128618_2").get(0));
+		assertEquals("warning should be against the FFDC.aj resource", "FFDC.aj", msg.getSourceLocation().getSourceFile().getName());
 
-		
-		alter("PR128618_2","inc1");
+		alter("PR128618_2", "inc1");
 		build("PR128618_2");
-		
+
 		checkWasntFullBuild();
-		IMessage msg2 = (IMessage)(getWarningMessages("PR128618_2").get(0));
-		assertEquals("warning should be against the FFDC.aj resource","FFDC.aj",msg2.getSourceLocation().getSourceFile().getName());
+		IMessage msg2 = (IMessage) (getWarningMessages("PR128618_2").get(0));
+		assertEquals("warning should be against the FFDC.aj resource", "FFDC.aj", msg2.getSourceLocation().getSourceFile()
+				.getName());
 		assertFalse("a new warning message should have been generated", msg.equals(msg2));
 	}
-	
+
 	public void testPr92837() {
 		initialiseProject("PR92837");
 		build("PR92837");
-		alter("PR92837","inc1");
+		alter("PR92837", "inc1");
 		build("PR92837");
 	}
 
-// See open generic itd bug mentioning 119570
-//	public void testPr119570() {
-//		initialiseProject("PR119570");
-//		build("PR119570");
-//		assertNoErrors("PR119570");
-//	}
-	
-//	public void testPr119570_212783_2() {
-//		initialiseProject("PR119570_2");
-//		build("PR119570_2");
-//		List l = getWarningMessages("PR119570_2");
-//		assertTrue("Should be no warnings, but got "+l,l.size()==0);
-//		assertNoErrors("PR119570_2");
-//	}
-//
-//	public void testPr119570_212783_3() {
-//		initialiseProject("pr119570_3");
-//		build("pr119570_3");
-//		List l = getWarningMessages("pr119570_3");
-//		assertTrue("Should be no warnings, but got "+l,l.size()==0);
-//		assertNoErrors("pr119570_3");
-//	}
-
-	
+	// See open generic itd bug mentioning 119570
+	// public void testPr119570() {
+	// initialiseProject("PR119570");
+	// build("PR119570");
+	// assertNoErrors("PR119570");
+	// }
+
+	// public void testPr119570_212783_2() {
+	// initialiseProject("PR119570_2");
+	// build("PR119570_2");
+	// List l = getWarningMessages("PR119570_2");
+	// assertTrue("Should be no warnings, but got "+l,l.size()==0);
+	// assertNoErrors("PR119570_2");
+	// }
+	//
+	// public void testPr119570_212783_3() {
+	// initialiseProject("pr119570_3");
+	// build("pr119570_3");
+	// List l = getWarningMessages("pr119570_3");
+	// assertTrue("Should be no warnings, but got "+l,l.size()==0);
+	// assertNoErrors("pr119570_3");
+	// }
+
 	// If you fiddle with the compiler options - you must manually reset the options at the end of the test
 	public void testPr117209() {
 		try {
 			initialiseProject("pr117209");
-			configureNonStandardCompileOptions("pr117209","-proceedOnError");
+			configureNonStandardCompileOptions("pr117209", "-proceedOnError");
 			build("pr117209");
-			checkCompileWeaveCount("pr117209",6,5);
+			checkCompileWeaveCount("pr117209", 6, 5);
 		} finally {
-			//MyBuildOptionsAdapter.reset();
+			// MyBuildOptionsAdapter.reset();
 		}
 	}
-	
+
 	public void testPr114875() {
 		// temporary problem with this on linux, think it is a filesystem lastmodtime issue
-		if (System.getProperty("os.name","").toLowerCase().equals("linux")) return;
+		if (System.getProperty("os.name", "").toLowerCase().equals("linux"))
+			return;
 		initialiseProject("pr114875");
 		build("pr114875");
-		alter("pr114875","inc1");
+		alter("pr114875", "inc1");
 		build("pr114875");
 		checkWasFullBuild();
-		alter("pr114875","inc2");
+		alter("pr114875", "inc2");
 		build("pr114875");
-		checkWasFullBuild();  // back to the source for an aspect change
+		checkWasFullBuild(); // back to the source for an aspect change
 	}
-	
+
 	public void testPr117882() {
-//		AjdeInteractionTestbed.VERBOSE=true;
-//		AjdeInteractionTestbed.configureBuildStructureModel(true);
+		// AjdeInteractionTestbed.VERBOSE=true;
+		// AjdeInteractionTestbed.configureBuildStructureModel(true);
 		initialiseProject("PR117882");
 		build("PR117882");
 		checkWasFullBuild();
-		alter("PR117882","inc1");
+		alter("PR117882", "inc1");
 		build("PR117882");
-		checkWasFullBuild();  // back to the source for an aspect
-//		AjdeInteractionTestbed.VERBOSE=false;
-//		AjdeInteractionTestbed.configureBuildStructureModel(false);
+		checkWasFullBuild(); // back to the source for an aspect
+		// AjdeInteractionTestbed.VERBOSE=false;
+		// AjdeInteractionTestbed.configureBuildStructureModel(false);
 	}
-	
+
 	public void testPr117882_2() {
-//		AjdeInteractionTestbed.VERBOSE=true;
-//		AjdeInteractionTestbed.configureBuildStructureModel(true);
+		// AjdeInteractionTestbed.VERBOSE=true;
+		// AjdeInteractionTestbed.configureBuildStructureModel(true);
 		initialiseProject("PR117882_2");
 		build("PR117882_2");
 		checkWasFullBuild();
-		alter("PR117882_2","inc1");
+		alter("PR117882_2", "inc1");
 		build("PR117882_2");
-		checkWasFullBuild();  // back to the source...
-		//checkCompileWeaveCount(1,4);
-		//fullBuild("PR117882_2");
-		//checkWasFullBuild();
-//		AjdeInteractionTestbed.VERBOSE=false;
-//		AjdeInteractionTestbed.configureBuildStructureModel(false);
-	}
-	
+		checkWasFullBuild(); // back to the source...
+		// checkCompileWeaveCount(1,4);
+		// fullBuild("PR117882_2");
+		// checkWasFullBuild();
+		// AjdeInteractionTestbed.VERBOSE=false;
+		// AjdeInteractionTestbed.configureBuildStructureModel(false);
+	}
+
 	public void testPr115251() {
-		//AjdeInteractionTestbed.VERBOSE=true;
+		// AjdeInteractionTestbed.VERBOSE=true;
 		initialiseProject("PR115251");
 		build("PR115251");
 		checkWasFullBuild();
-		alter("PR115251","inc1");
+		alter("PR115251", "inc1");
 		build("PR115251");
-		checkWasFullBuild();  // back to the source
+		checkWasFullBuild(); // back to the source
 	}
-	
 
 	public void testPr220255_InfiniteBuildHasMember() {
-		AjdeInteractionTestbed.VERBOSE=true;
+		AjdeInteractionTestbed.VERBOSE = true;
 		initialiseProject("pr220255");
-		configureNonStandardCompileOptions("pr220255","-XhasMember");
+		configureNonStandardCompileOptions("pr220255", "-XhasMember");
 		build("pr220255");
 		checkWasFullBuild();
-		alter("pr220255","inc1");
+		alter("pr220255", "inc1");
 		build("pr220255");
-		checkWasntFullBuild(); 
+		checkWasntFullBuild();
 	}
 
 	public void testPr157054() {
 		initialiseProject("PR157054");
-		configureNonStandardCompileOptions("PR157054","-showWeaveInfo");
-		configureShowWeaveInfoMessages("PR157054",true);
+		configureNonStandardCompileOptions("PR157054", "-showWeaveInfo");
+		configureShowWeaveInfoMessages("PR157054", true);
 		build("PR157054");
 		checkWasFullBuild();
 		List weaveMessages = getWeavingMessages("PR157054");
-		assertTrue("Should be two weaving messages but there are "+weaveMessages.size(),weaveMessages.size()==2);
-		alter("PR157054","inc1");
+		assertTrue("Should be two weaving messages but there are " + weaveMessages.size(), weaveMessages.size() == 2);
+		alter("PR157054", "inc1");
 		build("PR157054");
 		weaveMessages = getWeavingMessages("PR157054");
-		assertTrue("Should be three weaving messages but there are "+weaveMessages.size(),weaveMessages.size()==3);
+		assertTrue("Should be three weaving messages but there are " + weaveMessages.size(), weaveMessages.size() == 3);
 		checkWasntFullBuild();
 		fullBuild("PR157054");
 		weaveMessages = getWeavingMessages("PR157054");
-		assertTrue("Should be three weaving messages but there are "+weaveMessages.size(),weaveMessages.size()==3);
+		assertTrue("Should be three weaving messages but there are " + weaveMessages.size(), weaveMessages.size() == 3);
 	}
-	
-	
 
 	/**
-	 * Checks we aren't leaking mungers across compiles (accumulating multiple instances of the same one that
-	 * all do the same thing).  On the first compile the munger is added late on - so at the time we set
-	 * the count it is still zero.  On the subsequent compiles we know about this extra one.
+	 * Checks we aren't leaking mungers across compiles (accumulating multiple instances of the same one that all do the same
+	 * thing). On the first compile the munger is added late on - so at the time we set the count it is still zero. On the
+	 * subsequent compiles we know about this extra one.
 	 */
 	public void testPr141956_IncrementallyCompilingAtAj() {
 		initialiseProject("PR141956");
 		build("PR141956");
-		assertTrue("Should be zero but reports "+EclipseFactory.debug_mungerCount,EclipseFactory.debug_mungerCount==0);
-		alter("PR141956","inc1");
+		assertTrue("Should be zero but reports " + EclipseFactory.debug_mungerCount, EclipseFactory.debug_mungerCount == 0);
+		alter("PR141956", "inc1");
 		build("PR141956");
-		assertTrue("Should be two but reports "+EclipseFactory.debug_mungerCount,EclipseFactory.debug_mungerCount==2);
-		alter("PR141956","inc1");
+		assertTrue("Should be two but reports " + EclipseFactory.debug_mungerCount, EclipseFactory.debug_mungerCount == 2);
+		alter("PR141956", "inc1");
 		build("PR141956");
-		assertTrue("Should be two but reports "+EclipseFactory.debug_mungerCount,EclipseFactory.debug_mungerCount==2);
-		alter("PR141956","inc1");
+		assertTrue("Should be two but reports " + EclipseFactory.debug_mungerCount, EclipseFactory.debug_mungerCount == 2);
+		alter("PR141956", "inc1");
 		build("PR141956");
-		assertTrue("Should be two but reports "+EclipseFactory.debug_mungerCount,EclipseFactory.debug_mungerCount==2);
-		alter("PR141956","inc1");
+		assertTrue("Should be two but reports " + EclipseFactory.debug_mungerCount, EclipseFactory.debug_mungerCount == 2);
+		alter("PR141956", "inc1");
 		build("PR141956");
-		assertTrue("Should be two but reports "+EclipseFactory.debug_mungerCount,EclipseFactory.debug_mungerCount==2);
-	}
-	
-
-//	public void testPr124399() {
-//		AjdeInteractionTestbed.VERBOSE=true;
-//		configureBuildStructureModel(true);
-//		initialiseProject("PR124399");
-//		build("PR124399");
-//		checkWasFullBuild();
-//		alter("PR124399","inc1");
-//		build("PR124399");
-//		checkWasntFullBuild();
-//	}
-	
+		assertTrue("Should be two but reports " + EclipseFactory.debug_mungerCount, EclipseFactory.debug_mungerCount == 2);
+	}
+
+	// public void testPr124399() {
+	// AjdeInteractionTestbed.VERBOSE=true;
+	// configureBuildStructureModel(true);
+	// initialiseProject("PR124399");
+	// build("PR124399");
+	// checkWasFullBuild();
+	// alter("PR124399","inc1");
+	// build("PR124399");
+	// checkWasntFullBuild();
+	// }
+
 	public void testPr121384() {
-//		AjdeInteractionTestbed.VERBOSE=true;
-//		AsmManager.setReporting("c:/foo.txt",true,true,true,false);
+		// AjdeInteractionTestbed.VERBOSE=true;
+		// AsmManager.setReporting("c:/foo.txt",true,true,true,false);
 		initialiseProject("pr121384");
-		configureNonStandardCompileOptions("pr121384","-showWeaveInfo");
-		build("pr121384"); 
+		configureNonStandardCompileOptions("pr121384", "-showWeaveInfo");
+		build("pr121384");
 		checkWasFullBuild();
-		alter("pr121384","inc1");
+		alter("pr121384", "inc1");
 		build("pr121384");
 		checkWasntFullBuild();
 	}
 
-	
-/*	public void testPr111779() {
-		super.VERBOSE=true;
-		initialiseProject("PR111779");
-		build("PR111779");
-		alter("PR111779","inc1");
-		build("PR111779");
-	}
-*/
+	/*
+	 * public void testPr111779() { super.VERBOSE=true; initialiseProject("PR111779"); build("PR111779"); alter("PR111779","inc1");
+	 * build("PR111779"); }
+	 */
 
 	public void testPr93310_1() {
 		initialiseProject("PR93310_1");
 		build("PR93310_1");
 		checkWasFullBuild();
-		String fileC2 = getWorkingDir().getAbsolutePath() + File.separatorChar + "PR93310_1" + File.separatorChar + "src" + File.separatorChar + "pack" + File.separatorChar + "C2.java";
+		String fileC2 = getWorkingDir().getAbsolutePath() + File.separatorChar + "PR93310_1" + File.separatorChar + "src"
+				+ File.separatorChar + "pack" + File.separatorChar + "C2.java";
 		(new File(fileC2)).delete();
-		alter("PR93310_1","inc1");
+		alter("PR93310_1", "inc1");
 		build("PR93310_1");
 		checkWasFullBuild();
-		int l =  AjdeInteractionTestbed.MyStateListener.detectedDeletions.size();
-		assertTrue("Expected one deleted file to be noticed, but detected: "+l,l==1);
-		String name = (String)AjdeInteractionTestbed.MyStateListener.detectedDeletions.get(0);
-		assertTrue("Should end with C2.java but is "+name,name.endsWith("C2.java"));
+		int l = AjdeInteractionTestbed.MyStateListener.detectedDeletions.size();
+		assertTrue("Expected one deleted file to be noticed, but detected: " + l, l == 1);
+		String name = (String) AjdeInteractionTestbed.MyStateListener.detectedDeletions.get(0);
+		assertTrue("Should end with C2.java but is " + name, name.endsWith("C2.java"));
 	}
-	
+
 	public void testPr93310_2() {
 		initialiseProject("PR93310_2");
 		build("PR93310_2");
 		checkWasFullBuild();
-		String fileC2 = getWorkingDir().getAbsolutePath() + File.separatorChar + "PR93310_2" + File.separatorChar + "src" + File.separatorChar + "pack" + File.separatorChar + "C2.java";
+		String fileC2 = getWorkingDir().getAbsolutePath() + File.separatorChar + "PR93310_2" + File.separatorChar + "src"
+				+ File.separatorChar + "pack" + File.separatorChar + "C2.java";
 		(new File(fileC2)).delete();
-		alter("PR93310_2","inc1");
+		alter("PR93310_2", "inc1");
 		build("PR93310_2");
 		checkWasFullBuild();
-		int l =  AjdeInteractionTestbed.MyStateListener.detectedDeletions.size();
-		assertTrue("Expected one deleted file to be noticed, but detected: "+l,l==1);
-		String name = (String)AjdeInteractionTestbed.MyStateListener.detectedDeletions.get(0);
-		assertTrue("Should end with C2.java but is "+name,name.endsWith("C2.java"));
+		int l = AjdeInteractionTestbed.MyStateListener.detectedDeletions.size();
+		assertTrue("Expected one deleted file to be noticed, but detected: " + l, l == 1);
+		String name = (String) AjdeInteractionTestbed.MyStateListener.detectedDeletions.get(0);
+		assertTrue("Should end with C2.java but is " + name, name.endsWith("C2.java"));
 	}
-	
-	// Stage1: Compile two files, pack.A and pack.A1 - A1 sets a protected field in A. 
+
+	// Stage1: Compile two files, pack.A and pack.A1 - A1 sets a protected field in A.
 	// Stage2: make the field private in class A > gives compile error
 	// Stage3: Add a new aspect whilst there is a compile error !
 	public void testPr113531() {
 		initialiseProject("PR113531");
 		build("PR113531");
-		assertTrue("build should have compiled ok",
-				getErrorMessages("PR113531").isEmpty());
-		alter("PR113531","inc1");
+		assertTrue("build should have compiled ok", getErrorMessages("PR113531").isEmpty());
+		alter("PR113531", "inc1");
 		build("PR113531");
-		assertEquals("error message should be 'foo cannot be resolved' ",
-				"foo cannot be resolved",
-				((IMessage)getErrorMessages("PR113531").get(0))
-					.getMessage());
-		alter("PR113531","inc2");
+		assertEquals("error message should be 'foo cannot be resolved' ", "foo cannot be resolved", ((IMessage) getErrorMessages(
+				"PR113531").get(0)).getMessage());
+		alter("PR113531", "inc2");
 		build("PR113531");
-		assertTrue("There should be no exceptions handled:\n"
-				+getCompilerErrorMessages("PR113531"),
-				getCompilerErrorMessages("PR113531").isEmpty());		
-		assertEquals("error message should be 'foo cannot be resolved' ",
-				"foo cannot be resolved",
-				((IMessage)getErrorMessages("PR113531").get(0))
-					.getMessage());
+		assertTrue("There should be no exceptions handled:\n" + getCompilerErrorMessages("PR113531"), getCompilerErrorMessages(
+				"PR113531").isEmpty());
+		assertEquals("error message should be 'foo cannot be resolved' ", "foo cannot be resolved", ((IMessage) getErrorMessages(
+				"PR113531").get(0)).getMessage());
 	}
 
 	// Stage 1: Compile the 4 files, pack.A2 extends pack.A1 (aspects) where
-	//          A2 uses a protected field in A1 and pack.C2 extends pack.C1 (classes)
-	//          where C2 uses a protected field in C1
+	// A2 uses a protected field in A1 and pack.C2 extends pack.C1 (classes)
+	// where C2 uses a protected field in C1
 	// Stage 2: make the field private in class C1 ==> compile errors in C2
 	// Stage 3: make the field private in aspect A1 whilst there's the compile
-	//          error. 
+	// error.
 	// There shouldn't be a BCExcpetion saying can't find delegate for pack.C2
 	public void testPr119882() {
 		initialiseProject("PR119882");
 		build("PR119882");
-		assertTrue("build should have compiled ok",getErrorMessages("PR119882").isEmpty());
-		alter("PR119882","inc1");
+		assertTrue("build should have compiled ok", getErrorMessages("PR119882").isEmpty());
+		alter("PR119882", "inc1");
 		build("PR119882");
-		//fullBuild("PR119882");
+		// fullBuild("PR119882");
 		List errors = getErrorMessages("PR119882");
-		assertTrue("Should be at least one error, but got none",errors.size()==1);
-		assertEquals("error message should be 'i cannot be resolved' ",
-				"i cannot be resolved",
-				((IMessage)errors.get(0))
-					.getMessage());
-		alter("PR119882","inc2");
+		assertTrue("Should be at least one error, but got none", errors.size() == 1);
+		assertEquals("error message should be 'i cannot be resolved' ", "i cannot be resolved", ((IMessage) errors.get(0))
+				.getMessage());
+		alter("PR119882", "inc2");
 		build("PR119882");
-		assertTrue("There should be no exceptions handled:\n"
-				+getCompilerErrorMessages("PR119882"),
-				getCompilerErrorMessages("PR119882").isEmpty());	
-		assertEquals("error message should be 'i cannot be resolved' ",
-				"i cannot be resolved",
-				((IMessage)errors.get(0))
-					.getMessage());
+		assertTrue("There should be no exceptions handled:\n" + getCompilerErrorMessages("PR119882"), getCompilerErrorMessages(
+				"PR119882").isEmpty());
+		assertEquals("error message should be 'i cannot be resolved' ", "i cannot be resolved", ((IMessage) errors.get(0))
+				.getMessage());
 
 	}
-	
+
 	public void testPr112736() {
 		initialiseProject("PR112736");
 		build("PR112736");
 		checkWasFullBuild();
-		String fileC2 = getWorkingDir().getAbsolutePath() + File.separatorChar + "PR112736" + File.separatorChar + "src" + File.separatorChar + "pack" + File.separatorChar + "A.java";
+		String fileC2 = getWorkingDir().getAbsolutePath() + File.separatorChar + "PR112736" + File.separatorChar + "src"
+				+ File.separatorChar + "pack" + File.separatorChar + "A.java";
 		(new File(fileC2)).delete();
-		alter("PR112736","inc1");
+		alter("PR112736", "inc1");
 		build("PR112736");
 		checkWasFullBuild();
 	}
-	
+
 	/**
 	 * We have problems with multiple rewrites of a pointcut across incremental builds.
 	 */
 	public void testPr113257() {
 		initialiseProject("PR113257");
 		build("PR113257");
-		alter("PR113257","inc1");
+		alter("PR113257", "inc1");
 		build("PR113257");
-		checkWasFullBuild();  // back to the source
-		alter("PR113257","inc1");
+		checkWasFullBuild(); // back to the source
+		alter("PR113257", "inc1");
 		build("PR113257");
 	}
 
 	public void testPr123612() {
 		initialiseProject("PR123612");
 		build("PR123612");
-		alter("PR123612","inc1");
+		alter("PR123612", "inc1");
 		build("PR123612");
 		checkWasFullBuild(); // back to the source
 	}
-	
-    //Bugzilla Bug 152257 - Incremental compiler doesn't handle exception declaration correctly
+
+	// Bugzilla Bug 152257 - Incremental compiler doesn't handle exception declaration correctly
 	public void testPr152257() {
 		initialiseProject("PR152257");
-		configureNonStandardCompileOptions("PR152257","-XnoInline");
+		configureNonStandardCompileOptions("PR152257", "-XnoInline");
 		build("PR152257");
 		List errors = getErrorMessages("PR152257");
-		assertTrue("Should be no warnings, but there are #"+errors.size(),errors.size()==0);
+		assertTrue("Should be no warnings, but there are #" + errors.size(), errors.size() == 0);
 		checkWasFullBuild();
-		alter("PR152257","inc1");
+		alter("PR152257", "inc1");
 		build("PR152257");
 		errors = getErrorMessages("PR152257");
-		assertTrue("Should be no warnings, but there are #"+errors.size(),errors.size()==0);
+		assertTrue("Should be no warnings, but there are #" + errors.size(), errors.size() == 0);
 		checkWasntFullBuild();
 	}
 
-
 	public void testPr128655() {
 		initialiseProject("pr128655");
-		configureNonStandardCompileOptions("pr128655","-showWeaveInfo");
-		configureShowWeaveInfoMessages("pr128655",true);
+		configureNonStandardCompileOptions("pr128655", "-showWeaveInfo");
+		configureShowWeaveInfoMessages("pr128655", true);
 		build("pr128655");
 		List firstBuildMessages = getWeavingMessages("pr128655");
-		assertTrue("Should be at least one message about the dec @type, but there were none",firstBuildMessages.size()>0);
-		alter("pr128655","inc1");
+		assertTrue("Should be at least one message about the dec @type, but there were none", firstBuildMessages.size() > 0);
+		alter("pr128655", "inc1");
 		build("pr128655");
 		checkWasntFullBuild(); // back to the source
 		List secondBuildMessages = getWeavingMessages("pr128655");
 		// check they are the same
 		for (int i = 0; i < firstBuildMessages.size(); i++) {
-			IMessage m1 = (IMessage)firstBuildMessages.get(i);
-			IMessage m2 = (IMessage)secondBuildMessages.get(i);
+			IMessage m1 = (IMessage) firstBuildMessages.get(i);
+			IMessage m2 = (IMessage) secondBuildMessages.get(i);
 			if (!m1.toString().equals(m2.toString())) {
-				System.err.println("Message during first build was: "+m1);
-				System.err.println("Message during second build was: "+m1);
-				fail("The two messages should be the same, but are not: \n"+m1+"!="+m2);
+				System.err.println("Message during first build was: " + m1);
+				System.err.println("Message during second build was: " + m1);
+				fail("The two messages should be the same, but are not: \n" + m1 + "!=" + m2);
 			}
 		}
 	}
-	
+
 	// Similar to above, but now the annotation is in the default package
 	public void testPr128655_2() {
 		initialiseProject("pr128655_2");
-		configureNonStandardCompileOptions("pr128655_2","-showWeaveInfo");
+		configureNonStandardCompileOptions("pr128655_2", "-showWeaveInfo");
 		configureShowWeaveInfoMessages("pr128655_2", true);
 		build("pr128655_2");
 		List firstBuildMessages = getWeavingMessages("pr128655_2");
-		assertTrue("Should be at least one message about the dec @type, but there were none",firstBuildMessages.size()>0);
-		alter("pr128655_2","inc1");
+		assertTrue("Should be at least one message about the dec @type, but there were none", firstBuildMessages.size() > 0);
+		alter("pr128655_2", "inc1");
 		build("pr128655_2");
 		checkWasntFullBuild(); // back to the source
 		List secondBuildMessages = getWeavingMessages("pr128655_2");
 		// check they are the same
 		for (int i = 0; i < firstBuildMessages.size(); i++) {
-			IMessage m1 = (IMessage)firstBuildMessages.get(i);
-			IMessage m2 = (IMessage)secondBuildMessages.get(i);
+			IMessage m1 = (IMessage) firstBuildMessages.get(i);
+			IMessage m2 = (IMessage) secondBuildMessages.get(i);
 			if (!m1.toString().equals(m2.toString())) {
-				System.err.println("Message during first build was: "+m1);
-				System.err.println("Message during second build was: "+m1);
-				fail("The two messages should be the same, but are not: \n"+m1+"!="+m2);
+				System.err.println("Message during first build was: " + m1);
+				System.err.println("Message during second build was: " + m1);
+				fail("The two messages should be the same, but are not: \n" + m1 + "!=" + m2);
 			}
 		}
 	}
-	
+
 	// test for comment #31 - NPE
 	public void testPr129163() {
 		initialiseProject("PR129613");
 		build("PR129613");
-		alter("PR129613","inc1");
+		alter("PR129613", "inc1");
 		build("PR129613");
-		assertTrue("There should be no exceptions handled:\n"+getCompilerErrorMessages("PR129613"),
-				getCompilerErrorMessages("PR129613").isEmpty());
+		assertTrue("There should be no exceptions handled:\n" + getCompilerErrorMessages("PR129613"), getCompilerErrorMessages(
+				"PR129613").isEmpty());
 		assertEquals("warning message should be 'no match for this type name: File [Xlint:invalidAbsoluteTypeName]' ",
-				"no match for this type name: File [Xlint:invalidAbsoluteTypeName]",
-				((IMessage)getWarningMessages("PR129613").get(0))
-					.getMessage());
+				"no match for this type name: File [Xlint:invalidAbsoluteTypeName]", ((IMessage) getWarningMessages("PR129613")
+						.get(0)).getMessage());
 	}
-	
+
 	// test for comment #0 - adding a comment to a class file shouldn't
 	// cause us to go back to source and recompile everything. To force this
 	// to behave like AJDT we need to include the aspect in 'inc1' so that
-	// when AjState looks at its timestamp it thinks the aspect has been modified. 
-	// The logic within CrosscuttingMembers should then work out correctly 
-	// that there haven't really been any changes within the aspect and so 
+	// when AjState looks at its timestamp it thinks the aspect has been modified.
+	// The logic within CrosscuttingMembers should then work out correctly
+	// that there haven't really been any changes within the aspect and so
 	// we shouldn't go back to source.
 	public void testPr129163_2() {
 		// want to behave like AJDT
 		initialiseProject("pr129163_2");
 		build("pr129163_2");
 		checkWasFullBuild();
-		alter("pr129163_2","inc1");
+		alter("pr129163_2", "inc1");
 		build("pr129163_2");
-		checkWasntFullBuild(); // shouldn't be a full build because the 
-		                       // aspect hasn't changed
+		checkWasntFullBuild(); // shouldn't be a full build because the
+		// aspect hasn't changed
 	}
-	
+
 	public void testIncrementalIntelligence_Scenario01() {
-	    AjdeInteractionTestbed.VERBOSE=true;
-	    initialiseProject("Project1");
-        initialiseProject("Project2");
-        configureNewProjectDependency("Project2", "Project1");
-        build("Project1");
-        build("Project2");
-        
-        alter("Project1", "inc1"); // white space change to ClassA - no impact
-        build("Project1");
-        build("Project2");
-        checkWasntFullBuild(); // not a structural change so ignored
-
-        alter("Project1", "inc2"); // structural change to ClassB - new method!
-        build("Project1");
-        build("Project2");
-        checkWasntFullBuild(); // not a type that Project2 depends on so ignored
-        
-        alter("Project1", "inc3"); // structural change to ClassA
-        build("Project1");
-        build("Project2");
-        checkWasntFullBuild(); // Just need to recompile ClassAExtender
-        checkCompileWeaveCount("Project2", 1, 1);
-        checkCompiled("Project2", "ClassAExtender");
-        
-        alter("Project2", "inc1"); // New type that depends on ClassAExtender
-        build("Project1");
-        build("Project2");
-        checkWasntFullBuild(); // Just build ClassAExtenderExtender
-        
-        alter("Project1", "inc4"); // another structural change to ClassA
-        build("Project1");
-        build("Project2");
-        checkWasntFullBuild(); // Should rebuild ClassAExtender and ClassAExtenderExtender
-        checkCompileWeaveCount("Project2", 2, 2);
-        checkCompiled("Project2", "ClassAExtenderExtender");
-        
-        
-	}
-	
+		AjdeInteractionTestbed.VERBOSE = true;
+		initialiseProject("Project1");
+		initialiseProject("Project2");
+		configureNewProjectDependency("Project2", "Project1");
+		build("Project1");
+		build("Project2");
+
+		alter("Project1", "inc1"); // white space change to ClassA - no impact
+		build("Project1");
+		build("Project2");
+		checkWasntFullBuild(); // not a structural change so ignored
+
+		alter("Project1", "inc2"); // structural change to ClassB - new method!
+		build("Project1");
+		build("Project2");
+		checkWasntFullBuild(); // not a type that Project2 depends on so ignored
+
+		alter("Project1", "inc3"); // structural change to ClassA
+		build("Project1");
+		setNextChangeResponse("Project2", ICompilerConfiguration.EVERYTHING); // See pr245566 comment 3
+		build("Project2");
+		checkWasntFullBuild(); // Just need to recompile ClassAExtender
+		checkCompileWeaveCount("Project2", 1, 1);
+		checkCompiled("Project2", "ClassAExtender");
+
+		alter("Project2", "inc1"); // New type that depends on ClassAExtender
+		build("Project1");
+		build("Project2");
+		checkWasntFullBuild(); // Just build ClassAExtenderExtender
+
+		alter("Project1", "inc4"); // another structural change to ClassA
+		build("Project1");
+		setNextChangeResponse("Project2", ICompilerConfiguration.EVERYTHING); // See pr245566 comment 3
+		build("Project2");
+		checkWasntFullBuild(); // Should rebuild ClassAExtender and ClassAExtenderExtender
+		checkCompileWeaveCount("Project2", 2, 2);
+		checkCompiled("Project2", "ClassAExtenderExtender");
+
+	}
+
 	private void checkCompiled(String projectName, String typeNameSubstring) {
-        List files = getCompiledFiles(projectName);
-        boolean found = false;
-        for (Iterator iterator = files.iterator(); iterator.hasNext();) {
-            String object = (String) iterator.next();
-            if (object.indexOf(typeNameSubstring) != -1)
-                found = true;
-        }
-        assertTrue("Did not find '" + typeNameSubstring + "' in list of compiled files", found);
-    }
-	
-	// Case001: renaming a private field in a type
-/*	public void testPrReducingDependentBuilds_001_221427() {
-		AjdeInteractionTestbed.VERBOSE=true;
-		IncrementalStateManager.debugIncrementalStates=true;
-		initialiseProject("P221427_1");
-		initialiseProject("P221427_2");
-		configureNewProjectDependency("P221427_2","P221427_1");
-		
-		build("P221427_1");
-		build("P221427_2"); 
-		alter("P221427_1","inc1"); // rename private class in super project
-		MyStateListener.reset();
-		build("P221427_1");
-		build("P221427_2");
-
-		AjState ajs = IncrementalStateManager.findStateManagingOutputLocation(new File(getFile("P221427_1","bin")));
-		assertTrue("There should be state for project P221427_1",ajs!=null);
-		//System.out.println(MyStateListener.getInstance().getDecisions());
-		checkWasntFullBuild();
-		assertTrue("Should be one structural change but there were "+
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
-				ajs.getNumberOfStructuralChangesSinceLastFullBuild()==1);
-		
-	}
-	
-	// Case002: changing a class to final that is extended in a dependent project
-	public void testPrReducingDependentBuilds_002_221427() {
-		AjdeInteractionTestbed.VERBOSE=true;
-		IncrementalStateManager.debugIncrementalStates=true;
-		initialiseProject("P221427_3");
-		initialiseProject("P221427_4");
-		configureNewProjectDependency("P221427_4","P221427_3");
-		
-		build("P221427_3");
-		build("P221427_4"); // build OK, type in super project is non-final
-		alter("P221427_3","inc1"); // change class declaration in super-project to final
-		MyStateListener.reset();
-		build("P221427_3");
-		build("P221427_4"); // build FAIL, type in super project is now final
-
-		AjState ajs = IncrementalStateManager.findStateManagingOutputLocation(new File(getFile("P221427_3","bin")));
-		assertTrue("There should be state for project P221427_3",ajs!=null);
-		System.out.println(MyStateListener.getInstance().getDecisions());
-
-		List errors = getErrorMessages("P221427_4");
-		if (errors.size()!=1) {
-			if (errors.size()==0) fail("Expected error about not being able to extend final class");
-			for (Iterator iterator = errors.iterator(); iterator.hasNext();) {
-				Object object = (Object) iterator.next();
-				System.out.println(object);
-			}
-			fail("Expected 1 error but got "+errors.size());
+		List files = getCompiledFiles(projectName);
+		boolean found = false;
+		for (Iterator iterator = files.iterator(); iterator.hasNext();) {
+			String object = (String) iterator.next();
+			if (object.indexOf(typeNameSubstring) != -1)
+				found = true;
 		}
-//		assertTrue("Shouldn't be one structural change but there were "+
-//				ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
-//				ajs.getNumberOfStructuralChangesSinceLastFullBuild()==1);
-		
-	}*/
+		assertTrue("Did not find '" + typeNameSubstring + "' in list of compiled files", found);
+	}
+
+	// Case001: renaming a private field in a type
+	/*
+	 * public void testPrReducingDependentBuilds_001_221427() { AjdeInteractionTestbed.VERBOSE=true;
+	 * IncrementalStateManager.debugIncrementalStates=true; initialiseProject("P221427_1"); initialiseProject("P221427_2");
+	 * configureNewProjectDependency("P221427_2","P221427_1");
+	 * 
+	 * build("P221427_1"); build("P221427_2"); alter("P221427_1","inc1"); // rename private class in super project
+	 * MyStateListener.reset(); build("P221427_1"); build("P221427_2");
+	 * 
+	 * AjState ajs = IncrementalStateManager.findStateManagingOutputLocation(new File(getFile("P221427_1","bin")));
+	 * assertTrue("There should be state for project P221427_1",ajs!=null);
+	 * //System.out.println(MyStateListener.getInstance().getDecisions()); checkWasntFullBuild();
+	 * assertTrue("Should be one structural change but there were "+ ajs.getNumberOfStructuralChangesSinceLastFullBuild(),
+	 * ajs.getNumberOfStructuralChangesSinceLastFullBuild()==1);
+	 * 
+	 * }
+	 * 
+	 * // Case002: changing a class to final that is extended in a dependent project public void
+	 * testPrReducingDependentBuilds_002_221427() { AjdeInteractionTestbed.VERBOSE=true;
+	 * IncrementalStateManager.debugIncrementalStates=true; initialiseProject("P221427_3"); initialiseProject("P221427_4");
+	 * configureNewProjectDependency("P221427_4","P221427_3");
+	 * 
+	 * build("P221427_3"); build("P221427_4"); // build OK, type in super project is non-final alter("P221427_3","inc1"); // change
+	 * class declaration in super-project to final MyStateListener.reset(); build("P221427_3"); build("P221427_4"); // build FAIL,
+	 * type in super project is now final
+	 * 
+	 * AjState ajs = IncrementalStateManager.findStateManagingOutputLocation(new File(getFile("P221427_3","bin")));
+	 * assertTrue("There should be state for project P221427_3",ajs!=null);
+	 * System.out.println(MyStateListener.getInstance().getDecisions());
+	 * 
+	 * List errors = getErrorMessages("P221427_4"); if (errors.size()!=1) { if (errors.size()==0)
+	 * fail("Expected error about not being able to extend final class"); for (Iterator iterator = errors.iterator();
+	 * iterator.hasNext();) { Object object = (Object) iterator.next(); System.out.println(object); }
+	 * fail("Expected 1 error but got "+errors.size()); } // assertTrue("Shouldn't be one structural change but there were "+ //
+	 * ajs.getNumberOfStructuralChangesSinceLastFullBuild(), // ajs.getNumberOfStructuralChangesSinceLastFullBuild()==1);
+	 * 
+	 * }
+	 */
 	// test for comment #6 - simulates AJDT core builder test testBug99133a -
-	// changing the contents of a method within a class shouldn't force a 
+	// changing the contents of a method within a class shouldn't force a
 	// full build of a dependant project. To force this to behave like AJDT
 	// 'inc1' of the dependant project should just be a copy of 'base' so that
-	// AjState thinks somethings changed within the dependant project and 
-	// we do a build. Similarly, 'inc1' of the project depended on should 
+	// AjState thinks somethings changed within the dependant project and
+	// we do a build. Similarly, 'inc1' of the project depended on should
 	// include the aspect even though nothing's changed within it. This causes
-	// AjState to think that the aspect has changed. Together its then up to 
+	// AjState to think that the aspect has changed. Together its then up to
 	// logic within CrosscuttingMembers and various equals methods to decide
 	// correctly that we don't have to go back to source.
 	public void testPr129163_3() {
@@ -1166,32 +1050,30 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		build("PR129163_4");
 		checkWasFullBuild(); // should be a full build because initializing project
 		initialiseProject("PR129163_3");
-		configureNewProjectDependency("PR129163_3","PR129163_4");
+		configureNewProjectDependency("PR129163_3", "PR129163_4");
 		build("PR129163_3");
 		checkWasFullBuild(); // should be a full build because initializing project
-		alter("PR129163_4","inc1");
+		alter("PR129163_4", "inc1");
 		build("PR129163_4");
 		checkWasntFullBuild(); // should be an incremental build because although
-		                       // "inc1" includes the aspect A1.aj, it actually hasn't
-							   // changed so we shouldn't go back to source
-		alter("PR129163_3","inc1");
+		// "inc1" includes the aspect A1.aj, it actually hasn't
+		// changed so we shouldn't go back to source
+		alter("PR129163_3", "inc1");
 		build("PR129163_3");
 		checkWasntFullBuild(); // should be an incremental build because nothing has
-			                   // changed within the class and no aspects have changed
-		                       // within the running of the test
+		// changed within the class and no aspects have changed
+		// within the running of the test
 	}
-	
 
 	public void testPr133117() {
-//		System.gc();
-//		System.exit();
+		// System.gc();
+		// System.exit();
 		initialiseProject("PR133117");
-		configureNonStandardCompileOptions("PR133117","-Xlint:warning");
+		configureNonStandardCompileOptions("PR133117", "-Xlint:warning");
 		build("PR133117");
-		assertTrue("There should only be one xlint warning message reported:\n"
-				+getWarningMessages("PR133117"),
-				getWarningMessages("PR133117").size()==1);	
-		alter("PR133117","inc1");
+		assertTrue("There should only be one xlint warning message reported:\n" + getWarningMessages("PR133117"),
+				getWarningMessages("PR133117").size() == 1);
+		alter("PR133117", "inc1");
 		build("PR133117");
 		List warnings = getWarningMessages("PR133117");
 		List noGuardWarnings = new ArrayList();
@@ -1201,116 +1083,112 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 				noGuardWarnings.add(element);
 			}
 		}
-		assertTrue("There should only be two Xlint:noGuardForLazyTjp warning message reported:\n"
-				+noGuardWarnings,noGuardWarnings.size() == 2);
+		assertTrue("There should only be two Xlint:noGuardForLazyTjp warning message reported:\n" + noGuardWarnings,
+				noGuardWarnings.size() == 2);
 	}
-	
+
 	public void testPr131505() {
 		initialiseProject("PR131505");
-		configureNonStandardCompileOptions("PR131505","-outxml");
+		configureNonStandardCompileOptions("PR131505", "-outxml");
 		build("PR131505");
 		checkWasFullBuild();
-		String outputDir = getWorkingDir().getAbsolutePath() + File.separatorChar 
-			+ "PR131505" + File.separatorChar + "bin";
+		String outputDir = getWorkingDir().getAbsolutePath() + File.separatorChar + "PR131505" + File.separatorChar + "bin";
 		// aop.xml file shouldn't contain any aspects
-		checkXMLAspectCount("PR131505","",0, outputDir);
+		checkXMLAspectCount("PR131505", "", 0, outputDir);
 		// add a new aspect A which should be included in the aop.xml file
-		alter("PR131505","inc1");
+		alter("PR131505", "inc1");
 		build("PR131505");
 		checkWasFullBuild();
-		checkXMLAspectCount("PR131505","",1, outputDir);
-		checkXMLAspectCount("PR131505","A",1, outputDir);
+		checkXMLAspectCount("PR131505", "", 1, outputDir);
+		checkXMLAspectCount("PR131505", "A", 1, outputDir);
 		// make changes to the class file which shouldn't affect the contents
 		// of the aop.xml file
-		alter("PR131505","inc2");
+		alter("PR131505", "inc2");
 		build("PR131505");
 		checkWasntFullBuild();
-		checkXMLAspectCount("PR131505","",1, outputDir);
-		checkXMLAspectCount("PR131505","A",1, outputDir);		
+		checkXMLAspectCount("PR131505", "", 1, outputDir);
+		checkXMLAspectCount("PR131505", "A", 1, outputDir);
 		// add another new aspect A1 which should also be included in the aop.xml file
 		// ...there should be no duplicate entries in the file
-		alter("PR131505","inc3");
+		alter("PR131505", "inc3");
 		build("PR131505");
 		checkWasFullBuild();
-		checkXMLAspectCount("PR131505","",2, outputDir);
-		checkXMLAspectCount("PR131505","A1",1, outputDir);
-		checkXMLAspectCount("PR131505","A",1, outputDir);
+		checkXMLAspectCount("PR131505", "", 2, outputDir);
+		checkXMLAspectCount("PR131505", "A1", 1, outputDir);
+		checkXMLAspectCount("PR131505", "A", 1, outputDir);
 		// delete aspect A1 which meanss that aop.xml file should only contain A
-		File a1 = new File(getWorkingDir().getAbsolutePath() 
-				+ File.separatorChar + "PR131505" + File.separatorChar + "A1.aj");
+		File a1 = new File(getWorkingDir().getAbsolutePath() + File.separatorChar + "PR131505" + File.separatorChar + "A1.aj");
 		a1.delete();
 		build("PR131505");
 		checkWasFullBuild();
-		checkXMLAspectCount("PR131505","",1, outputDir);
-		checkXMLAspectCount("PR131505","A1",0, outputDir);
-		checkXMLAspectCount("PR131505","A",1, outputDir);	
+		checkXMLAspectCount("PR131505", "", 1, outputDir);
+		checkXMLAspectCount("PR131505", "A1", 0, outputDir);
+		checkXMLAspectCount("PR131505", "A", 1, outputDir);
 		// add another aspect called A which is in a different package, both A
 		// and pkg.A should be included in the aop.xml file
-		alter("PR131505","inc4");
+		alter("PR131505", "inc4");
 		build("PR131505");
 		checkWasFullBuild();
-		checkXMLAspectCount("PR131505","",2, outputDir);
-		checkXMLAspectCount("PR131505","A",1, outputDir);
-		checkXMLAspectCount("PR131505","pkg.A",1, outputDir);
+		checkXMLAspectCount("PR131505", "", 2, outputDir);
+		checkXMLAspectCount("PR131505", "A", 1, outputDir);
+		checkXMLAspectCount("PR131505", "pkg.A", 1, outputDir);
 	}
 
 	public void testPr136585() {
 		initialiseProject("PR136585");
 		build("PR136585");
-		alter("PR136585","inc1");
+		alter("PR136585", "inc1");
 		build("PR136585");
-		assertTrue("There should be no errors reported:\n"+getErrorMessages("PR136585"),
-				getErrorMessages("PR136585").isEmpty());	
+		assertTrue("There should be no errors reported:\n" + getErrorMessages("PR136585"), getErrorMessages("PR136585").isEmpty());
 	}
-	
+
 	public void testPr133532() {
 		initialiseProject("PR133532");
 		build("PR133532");
-		alter("PR133532","inc1");
+		alter("PR133532", "inc1");
 		build("PR133532");
-		alter("PR133532","inc2");
+		alter("PR133532", "inc2");
 		build("PR133532");
-		assertTrue("There should be no errors reported:\n"+getErrorMessages("PR133532"),
-				getErrorMessages("PR133532").isEmpty());	
+		assertTrue("There should be no errors reported:\n" + getErrorMessages("PR133532"), getErrorMessages("PR133532").isEmpty());
 	}
-	
+
 	public void testPr133532_2() {
 		initialiseProject("pr133532_2");
 		build("pr133532_2");
-		alter("pr133532_2","inc2");
+		alter("pr133532_2", "inc2");
 		build("pr133532_2");
-		assertTrue("There should be no errors reported:\n"+getErrorMessages("pr133532_2"),
-				getErrorMessages("pr133532_2").isEmpty());	
+		assertTrue("There should be no errors reported:\n" + getErrorMessages("pr133532_2"), getErrorMessages("pr133532_2")
+				.isEmpty());
 		String decisions = AjdeInteractionTestbed.MyStateListener.getDecisions();
-		String expect="Need to recompile 'A.aj'";
-		assertTrue("Couldn't find build decision: '"+expect+"' in the list of decisions made:\n"+decisions,
-				  decisions.indexOf(expect)!=-1);
+		String expect = "Need to recompile 'A.aj'";
+		assertTrue("Couldn't find build decision: '" + expect + "' in the list of decisions made:\n" + decisions, decisions
+				.indexOf(expect) != -1);
 	}
-	
+
 	public void testPr133532_3() {
 		initialiseProject("PR133532_3");
 		build("PR133532_3");
-		alter("PR133532_3","inc1");
+		alter("PR133532_3", "inc1");
 		build("PR133532_3");
-		assertTrue("There should be no errors reported:\n"+getErrorMessages("PR133532_3"),
-				getErrorMessages("PR133532_3").isEmpty());			
+		assertTrue("There should be no errors reported:\n" + getErrorMessages("PR133532_3"), getErrorMessages("PR133532_3")
+				.isEmpty());
 	}
-	
+
 	public void testPr134541() {
 		initialiseProject("PR134541");
 		build("PR134541");
-		assertEquals("[Xlint:adviceDidNotMatch] should be associated with line 5",5,
-				((IMessage)getWarningMessages("PR134541").get(0)).getSourceLocation().getLine());
-		alter("PR134541","inc1");
+		assertEquals("[Xlint:adviceDidNotMatch] should be associated with line 5", 5, ((IMessage) getWarningMessages("PR134541")
+				.get(0)).getSourceLocation().getLine());
+		alter("PR134541", "inc1");
 		build("PR134541");
 		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
-		  checkWasFullBuild(); // the line number has changed... but nothing structural about the code
-		else 
-		  checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
-		assertEquals("[Xlint:adviceDidNotMatch] should now be associated with line 7",7,
-				((IMessage)getWarningMessages("PR134541").get(0)).getSourceLocation().getLine());
+			checkWasFullBuild(); // the line number has changed... but nothing structural about the code
+		else
+			checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
+		assertEquals("[Xlint:adviceDidNotMatch] should now be associated with line 7", 7,
+				((IMessage) getWarningMessages("PR134541").get(0)).getSourceLocation().getLine());
 	}
-	
+
 	public void testJDTLikeHandleProviderWithLstFile_pr141730() {
 		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
 		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
@@ -1320,15 +1198,15 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 			initialiseProject("JDTLikeHandleProvider");
 			build("JDTLikeHandleProvider");
 			IHierarchy top = AsmManager.getDefault().getHierarchy();
-		  	IProgramElement pe = top.findElementForType("pkg","A");
-		  	String expectedHandle = "JDTLikeHandleProvider<pkg*A.aj}A";
-		  	assertEquals("expected handle to be " + expectedHandle + ", but found "
-		  			+ pe.getHandleIdentifier(),expectedHandle,pe.getHandleIdentifier());	
+			IProgramElement pe = top.findElementForType("pkg", "A");
+			String expectedHandle = "JDTLikeHandleProvider<pkg*A.aj}A";
+			assertEquals("expected handle to be " + expectedHandle + ", but found " + pe.getHandleIdentifier(), expectedHandle, pe
+					.getHandleIdentifier());
 		} finally {
 			AsmManager.getDefault().setHandleProvider(handleProvider);
 		}
 	}
-	
+
 	public void testMovingAdviceDoesntChangeHandles_pr141730() {
 		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
 		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
@@ -1337,26 +1215,24 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 			build("JDTLikeHandleProvider");
 			checkWasFullBuild();
 			IHierarchy top = AsmManager.getDefault().getHierarchy();
-			IProgramElement pe = top.findElementForLabel(top.getRoot(),
-					IProgramElement.Kind.ADVICE,"before(): <anonymous pointcut>");
-		  	// add a line which shouldn't change the handle
-			alter("JDTLikeHandleProvider","inc1");
+			IProgramElement pe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.ADVICE,
+					"before(): <anonymous pointcut>");
+			// add a line which shouldn't change the handle
+			alter("JDTLikeHandleProvider", "inc1");
 			build("JDTLikeHandleProvider");
 			checkWasntFullBuild();
 			IHierarchy top2 = AsmManager.getDefault().getHierarchy();
-			IProgramElement pe2 = top.findElementForLabel(top2.getRoot(),
-					IProgramElement.Kind.ADVICE,"before(): <anonymous pointcut>");
-			assertEquals("expected advice to be on line " + pe.getSourceLocation().getLine() + 1 
-					+ " but was on " + pe2.getSourceLocation().getLine(),
-					pe.getSourceLocation().getLine()+1,pe2.getSourceLocation().getLine());
-			assertEquals("expected advice to have handle " + pe.getHandleIdentifier()
-					+ " but found handle " + pe2.getHandleIdentifier(),
-					pe.getHandleIdentifier(),pe2.getHandleIdentifier());		
+			IProgramElement pe2 = top.findElementForLabel(top2.getRoot(), IProgramElement.Kind.ADVICE,
+					"before(): <anonymous pointcut>");
+			assertEquals("expected advice to be on line " + pe.getSourceLocation().getLine() + 1 + " but was on "
+					+ pe2.getSourceLocation().getLine(), pe.getSourceLocation().getLine() + 1, pe2.getSourceLocation().getLine());
+			assertEquals("expected advice to have handle " + pe.getHandleIdentifier() + " but found handle "
+					+ pe2.getHandleIdentifier(), pe.getHandleIdentifier(), pe2.getHandleIdentifier());
 		} finally {
 			AsmManager.getDefault().setHandleProvider(handleProvider);
 		}
 	}
-	
+
 	public void testSwappingAdviceAndHandles_pr141730() {
 		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
 		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
@@ -1365,38 +1241,31 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 			build("JDTLikeHandleProvider");
 			IHierarchy top = AsmManager.getDefault().getHierarchy();
 
-			IProgramElement call = top.findElementForLabel(top.getRoot(),
-					IProgramElement.Kind.ADVICE, "after(): callPCD..");
-			IProgramElement exec = top.findElementForLabel(top.getRoot(),
-					IProgramElement.Kind.ADVICE, "after(): execPCD..");
-		  	// swap the two after advice statements over. This forces
+			IProgramElement call = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.ADVICE, "after(): callPCD..");
+			IProgramElement exec = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.ADVICE, "after(): execPCD..");
+			// swap the two after advice statements over. This forces
 			// a full build which means 'after(): callPCD..' will now
 			// be the second after advice in the file and have the same
 			// handle as 'after(): execPCD..' originally did.
-			alter("JDTLikeHandleProvider","inc2");
+			alter("JDTLikeHandleProvider", "inc2");
 			build("JDTLikeHandleProvider");
 			checkWasFullBuild();
-			
+
 			IHierarchy top2 = AsmManager.getDefault().getHierarchy();
-			IProgramElement newCall = top2.findElementForLabel(top2.getRoot(),
-					IProgramElement.Kind.ADVICE, "after(): callPCD..");
-			IProgramElement newExec = top2.findElementForLabel(top2.getRoot(),
-					IProgramElement.Kind.ADVICE, "after(): execPCD..");
-
-			assertEquals("after swapping places, expected 'after(): callPCD..' " +
-					"to be on line " + newExec.getSourceLocation().getLine() +
-					" but was on line " + call.getSourceLocation().getLine(),
-					newExec.getSourceLocation().getLine(),
-					call.getSourceLocation().getLine());
-			assertEquals("after swapping places, expected 'after(): callPCD..' " +
-					"to have handle " + exec.getHandleIdentifier() +
-					" (because was full build) but had " + newCall.getHandleIdentifier(),
-					exec.getHandleIdentifier(), newCall.getHandleIdentifier());
+			IProgramElement newCall = top2.findElementForLabel(top2.getRoot(), IProgramElement.Kind.ADVICE, "after(): callPCD..");
+			IProgramElement newExec = top2.findElementForLabel(top2.getRoot(), IProgramElement.Kind.ADVICE, "after(): execPCD..");
+
+			assertEquals("after swapping places, expected 'after(): callPCD..' " + "to be on line "
+					+ newExec.getSourceLocation().getLine() + " but was on line " + call.getSourceLocation().getLine(), newExec
+					.getSourceLocation().getLine(), call.getSourceLocation().getLine());
+			assertEquals("after swapping places, expected 'after(): callPCD..' " + "to have handle " + exec.getHandleIdentifier()
+					+ " (because was full build) but had " + newCall.getHandleIdentifier(), exec.getHandleIdentifier(), newCall
+					.getHandleIdentifier());
 		} finally {
 			AsmManager.getDefault().setHandleProvider(handleProvider);
 		}
 	}
-	
+
 	public void testInitializerCountForJDTLikeHandleProvider_pr141730() {
 		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
 		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
@@ -1406,146 +1275,140 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 			String expected = "JDTLikeHandleProvider<pkg*A.aj[C|1";
 
 			IHierarchy top = AsmManager.getDefault().getHierarchy();
-			IProgramElement init = top.findElementForLabel(top.getRoot(),
-					IProgramElement.Kind.INITIALIZER, "...");
-			assertEquals("expected initializers handle to be " + expected + "," +
-					" but found " + init.getHandleIdentifier(true),
-					expected,init.getHandleIdentifier(true));
-			
-			alter("JDTLikeHandleProvider","inc2");
+			IProgramElement init = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.INITIALIZER, "...");
+			assertEquals("expected initializers handle to be " + expected + "," + " but found " + init.getHandleIdentifier(true),
+					expected, init.getHandleIdentifier(true));
+
+			alter("JDTLikeHandleProvider", "inc2");
 			build("JDTLikeHandleProvider");
 			checkWasFullBuild();
-			
+
 			IHierarchy top2 = AsmManager.getDefault().getHierarchy();
-			IProgramElement init2 = top2.findElementForLabel(top2.getRoot(),
-					IProgramElement.Kind.INITIALIZER, "...");
-			assertEquals("expected initializers handle to still be " + expected + "," +
-					" but found " + init2.getHandleIdentifier(true),
-					expected,init2.getHandleIdentifier(true));
+			IProgramElement init2 = top2.findElementForLabel(top2.getRoot(), IProgramElement.Kind.INITIALIZER, "...");
+			assertEquals("expected initializers handle to still be " + expected + "," + " but found "
+					+ init2.getHandleIdentifier(true), expected, init2.getHandleIdentifier(true));
 
-		
 		} finally {
 			AsmManager.getDefault().setHandleProvider(handleProvider);
 		}
 	}
-	
+
 	// 134471 related tests perform incremental compilation and verify features of the structure model post compile
 	public void testPr134471_IncrementalCompilationAndModelUpdates() {
 		try {
 			// see pr148027 AsmHierarchyBuilder.shouldAddUsesPointcut=false;
-		
-		// Step1.  Build the code, simple advice from aspect A onto class C
-		initialiseProject("PR134471");
-		configureNonStandardCompileOptions("PR134471","-showWeaveInfo -emacssym");
-		configureShowWeaveInfoMessages("PR134471",true);
-		build("PR134471");
-		
-		// Step2. Quick check that the advice points to something...
-		IProgramElement nodeForTypeA = checkForNode("pkg","A",true);
-		IProgramElement nodeForAdvice = findAdvice(nodeForTypeA);
-		List relatedElements = getRelatedElements(nodeForAdvice,1);
-		
-		// Step3. Check the advice applying at the first 'code' join point in pkg.C is from aspect pkg.A, line 7
-		IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
-		int line = programElement.getSourceLocation().getLine();
-		assertTrue("advice should be at line 7 - but is at line "+line,line==7);
-		
-		// Step4. Simulate the aspect being saved but with no change at all in it
-		alter("PR134471","inc1");
-		build("PR134471");
-
-		// Step5. Quick check that the advice points to something...
-		nodeForTypeA = checkForNode("pkg","A",true);
-		nodeForAdvice = findAdvice(nodeForTypeA);
-		relatedElements = getRelatedElements(nodeForAdvice,1);
-
-		// Step6. Check the advice applying at the first 'code' join point in pkg.C is from aspect pkg.A, line 7
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
-		line = programElement.getSourceLocation().getLine();
-		assertTrue("advice should be at line 7 - but is at line "+line,line==7);
+
+			// Step1. Build the code, simple advice from aspect A onto class C
+			initialiseProject("PR134471");
+			configureNonStandardCompileOptions("PR134471", "-showWeaveInfo -emacssym");
+			configureShowWeaveInfoMessages("PR134471", true);
+			build("PR134471");
+
+			// Step2. Quick check that the advice points to something...
+			IProgramElement nodeForTypeA = checkForNode("pkg", "A", true);
+			IProgramElement nodeForAdvice = findAdvice(nodeForTypeA);
+			List relatedElements = getRelatedElements(nodeForAdvice, 1);
+
+			// Step3. Check the advice applying at the first 'code' join point in pkg.C is from aspect pkg.A, line 7
+			IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true)));
+			int line = programElement.getSourceLocation().getLine();
+			assertTrue("advice should be at line 7 - but is at line " + line, line == 7);
+
+			// Step4. Simulate the aspect being saved but with no change at all in it
+			alter("PR134471", "inc1");
+			build("PR134471");
+
+			// Step5. Quick check that the advice points to something...
+			nodeForTypeA = checkForNode("pkg", "A", true);
+			nodeForAdvice = findAdvice(nodeForTypeA);
+			relatedElements = getRelatedElements(nodeForAdvice, 1);
+
+			// Step6. Check the advice applying at the first 'code' join point in pkg.C is from aspect pkg.A, line 7
+			programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true)));
+			line = programElement.getSourceLocation().getLine();
+			assertTrue("advice should be at line 7 - but is at line " + line, line == 7);
 		} finally {
-		// see pr148027 AsmHierarchyBuilder.shouldAddUsesPointcut=true;
+			// see pr148027 AsmHierarchyBuilder.shouldAddUsesPointcut=true;
 		}
 	}
-	
+
 	// now the advice moves down a few lines - hopefully the model will notice... see discussion in 134471
 	public void testPr134471_MovingAdvice() {
-		
+
 		// Step1. build the project
 		initialiseProject("PR134471_2");
-		configureNonStandardCompileOptions("PR134471_2","-showWeaveInfo -emacssym");
-		configureShowWeaveInfoMessages("PR134471_2",true);
+		configureNonStandardCompileOptions("PR134471_2", "-showWeaveInfo -emacssym");
+		configureShowWeaveInfoMessages("PR134471_2", true);
 		build("PR134471_2");
-		
+
 		// Step2. confirm advice is from correct location
-		IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
+		IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true)));
 		int line = programElement.getSourceLocation().getLine();
-		assertTrue("advice should be at line 7 - but is at line "+line,line==7);
-		
+		assertTrue("advice should be at line 7 - but is at line " + line, line == 7);
+
 		// Step3. No structural change to the aspect but the advice has moved down a few lines... (change in source location)
-		alter("PR134471_2","inc1");
+		alter("PR134471_2", "inc1");
 		build("PR134471_2");
 		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
-			  checkWasFullBuild(); // the line number has changed... but nothing structural about the code
-			else 
-			  checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
+			checkWasFullBuild(); // the line number has changed... but nothing structural about the code
+		else
+			checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
+
+		// checkWasFullBuild(); // this is true whilst we consider sourcelocation in the type/shadow munger equals() method - have
+		// to until the handles are independent of location
 
-		//checkWasFullBuild(); // this is true whilst we consider sourcelocation in the type/shadow munger equals() method - have to until the handles are independent of location
-		
 		// Step4. Check we have correctly realised the advice moved to line 11
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
+		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true)));
 		line = programElement.getSourceLocation().getLine();
-		assertTrue("advice should be at line 11 - but is at line "+line,line==11);
+		assertTrue("advice should be at line 11 - but is at line " + line, line == 11);
 	}
-	
 
 	public void testAddingAndRemovingDecwWithStructureModel() {
 		initialiseProject("P3");
 		build("P3");
-		alter("P3","inc1");
+		alter("P3", "inc1");
 		build("P3");
-		assertTrue("There should be no exceptions handled:\n"+getCompilerErrorMessages("P3"),
-				getCompilerErrorMessages("P3").isEmpty());		
-		alter("P3","inc2");
+		assertTrue("There should be no exceptions handled:\n" + getCompilerErrorMessages("P3"), getCompilerErrorMessages("P3")
+				.isEmpty());
+		alter("P3", "inc2");
 		build("P3");
-		assertTrue("There should be no exceptions handled:\n"+getCompilerErrorMessages("P3"),
-				getCompilerErrorMessages("P3").isEmpty());		
+		assertTrue("There should be no exceptions handled:\n" + getCompilerErrorMessages("P3"), getCompilerErrorMessages("P3")
+				.isEmpty());
 	}
-		
-	
+
 	// same as first test with an extra stage that asks for C to be recompiled, it should still be advised...
 	public void testPr134471_IncrementallyRecompilingTheAffectedClass() {
 		try {
 			// see pr148027 AsmHierarchyBuilder.shouldAddUsesPointcut=false;
 			// Step1. build the project
 			initialiseProject("PR134471");
-			configureNonStandardCompileOptions("PR134471","-showWeaveInfo -emacssym");	
-			configureShowWeaveInfoMessages("PR134471",true);
+			configureNonStandardCompileOptions("PR134471", "-showWeaveInfo -emacssym");
+			configureShowWeaveInfoMessages("PR134471", true);
 			build("PR134471");
-			
+
 			// Step2. confirm advice is from correct location
-			IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
+			IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true)));
 			int line = programElement.getSourceLocation().getLine();
-			assertTrue("advice should be at line 7 - but is at line "+line,line==7);
-	
+			assertTrue("advice should be at line 7 - but is at line " + line, line == 7);
+
 			// Step3. No change to the aspect at all
-			alter("PR134471","inc1");
+			alter("PR134471", "inc1");
 			build("PR134471");
-			
+
 			// Step4. Quick check that the advice points to something...
-			IProgramElement nodeForTypeA = checkForNode("pkg","A",true);
+			IProgramElement nodeForTypeA = checkForNode("pkg", "A", true);
 			IProgramElement nodeForAdvice = findAdvice(nodeForTypeA);
-			List relatedElements = getRelatedElements(nodeForAdvice,1);
-			
-		    // Step5. No change to the file C but it should still be advised afterwards
-			alter("PR134471","inc2");
+			List relatedElements = getRelatedElements(nodeForAdvice, 1);
+
+			// Step5. No change to the file C but it should still be advised afterwards
+			alter("PR134471", "inc2");
 			build("PR134471");
 			checkWasntFullBuild();
-		
+
 			// Step6. confirm advice is from correct location
-			programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
+			programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true)));
 			line = programElement.getSourceLocation().getLine();
-			assertTrue("advice should be at line 7 - but is at line "+line,line==7);		
+			assertTrue("advice should be at line 7 - but is at line " + line, line == 7);
 		} finally {
 			// see pr148027 AsmHierarchyBuilder.shouldAddUsesPointcut=true;
 		}
@@ -1554,158 +1417,150 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 
 	// similar to previous test but with 'declare warning' as well as advice
 	public void testPr134471_IncrementallyRecompilingAspectContainingDeclare() {
-		
+
 		// Step1. build the project
 		initialiseProject("PR134471_3");
-		configureNonStandardCompileOptions("PR134471_3","-showWeaveInfo -emacssym");
-		configureShowWeaveInfoMessages("PR134471_3",true);
+		configureNonStandardCompileOptions("PR134471_3", "-showWeaveInfo -emacssym");
+		configureShowWeaveInfoMessages("PR134471_3", true);
 		build("PR134471_3");
 		checkWasFullBuild();
-		
+
 		// Step2. confirm declare warning is from correct location, decw matches line 7 in pkg.C
-		IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true),7));
+		IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 7));
 		int line = programElement.getSourceLocation().getLine();
-		assertTrue("declare warning should be at line 10 - but is at line "+line,line==10);
-		
+		assertTrue("declare warning should be at line 10 - but is at line " + line, line == 10);
+
 		// Step3. confirm advice is from correct location, advice matches line 6 in pkg.C
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true),6));
+		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 6));
 		line = programElement.getSourceLocation().getLine();
-		assertTrue("advice should be at line 7 - but is at line "+line,line==7);
+		assertTrue("advice should be at line 7 - but is at line " + line, line == 7);
 
 		// Step4. Move declare warning in the aspect
-		alter("PR134471_3","inc1");
+		alter("PR134471_3", "inc1");
 		build("PR134471_3");
 		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
-			  checkWasFullBuild(); // the line number has changed... but nothing structural about the code
-			else 
-			  checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
+			checkWasFullBuild(); // the line number has changed... but nothing structural about the code
+		else
+			checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
 
-		//checkWasFullBuild();
+		// checkWasFullBuild();
 
 		// Step5. confirm declare warning is from correct location, decw (now at line 12) in pkg.A matches line 7 in pkg.C
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true),7));
+		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 7));
 		line = programElement.getSourceLocation().getLine();
-		assertTrue("declare warning should be at line 12 - but is at line "+line,line==12);
+		assertTrue("declare warning should be at line 12 - but is at line " + line, line == 12);
 
 		// Step6. Now just simulate 'resave' of the aspect, nothing has changed
-		alter("PR134471_3","inc2");
+		alter("PR134471_3", "inc2");
 		build("PR134471_3");
 		checkWasntFullBuild();
 
 		// Step7. confirm declare warning is from correct location, decw (now at line 12) in pkg.A matches line 7 in pkg.C
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true),7));
+		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 7));
 		line = programElement.getSourceLocation().getLine();
-		assertTrue("declare warning should be at line 12 - but is at line "+line,line==12);
+		assertTrue("declare warning should be at line 12 - but is at line " + line, line == 12);
 	}
-	
+
 	// similar to previous test but with 'declare warning' as well as advice
 	public void testPr134471_IncrementallyRecompilingTheClassAffectedByDeclare() {
-		
+
 		// Step1. build the project
 		initialiseProject("PR134471_3");
-		configureNonStandardCompileOptions("PR134471_3","-showWeaveInfo -emacssym");
-		configureShowWeaveInfoMessages("PR134471_3",true);
+		configureNonStandardCompileOptions("PR134471_3", "-showWeaveInfo -emacssym");
+		configureShowWeaveInfoMessages("PR134471_3", true);
 		build("PR134471_3");
 		checkWasFullBuild();
-		
+
 		// Step2. confirm declare warning is from correct location, decw matches line 7 in pkg.C
-		IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true),7));
+		IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 7));
 		int line = programElement.getSourceLocation().getLine();
-		assertTrue("declare warning should be at line 10 - but is at line "+line,line==10);
-		
+		assertTrue("declare warning should be at line 10 - but is at line " + line, line == 10);
+
 		// Step3. confirm advice is from correct location, advice matches line 6 in pkg.C
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true),6));
+		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 6));
 		line = programElement.getSourceLocation().getLine();
-		assertTrue("advice should be at line 7 - but is at line "+line,line==7);
+		assertTrue("advice should be at line 7 - but is at line " + line, line == 7);
 
 		// Step4. Move declare warning in the aspect
-		alter("PR134471_3","inc1");
+		alter("PR134471_3", "inc1");
 		build("PR134471_3");
 		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
-			  checkWasFullBuild(); // the line number has changed... but nothing structural about the code
-			else 
-			  checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
+			checkWasFullBuild(); // the line number has changed... but nothing structural about the code
+		else
+			checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
 
-		//checkWasFullBuild();
+		// checkWasFullBuild();
 
 		// Step5. confirm declare warning is from correct location, decw (now at line 12) in pkg.A matches line 7 in pkg.C
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true),7));
+		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 7));
 		line = programElement.getSourceLocation().getLine();
-		assertTrue("declare warning should be at line 12 - but is at line "+line,line==12);
+		assertTrue("declare warning should be at line 12 - but is at line " + line, line == 12);
 
 		// Step6. Now just simulate 'resave' of the aspect, nothing has changed
-		alter("PR134471_3","inc2");
+		alter("PR134471_3", "inc2");
 		build("PR134471_3");
 		checkWasntFullBuild();
 
 		// Step7. confirm declare warning is from correct location, decw (now at line 12) in pkg.A matches line 7 in pkg.C
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true),7));
+		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 7));
 		line = programElement.getSourceLocation().getLine();
-		assertTrue("declare warning should be at line 12 - but is at line "+line,line==12);
+		assertTrue("declare warning should be at line 12 - but is at line " + line, line == 12);
 
 		// Step8. Now just simulate resave of the pkg.C type - no change at all... are relationships gonna be repaired OK?
-		alter("PR134471_3","inc3");
+		alter("PR134471_3", "inc3");
 		build("PR134471_3");
 		checkWasntFullBuild();
 
 		// Step9. confirm declare warning is from correct location, decw (now at line 12) in pkg.A matches line 7 in pkg.C
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true),7));
+		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 7));
 		line = programElement.getSourceLocation().getLine();
-		assertTrue("declare warning should be at line 12 - but is at line "+line,line==12);
+		assertTrue("declare warning should be at line 12 - but is at line " + line, line == 12);
 	}
-	
+
 	public void testDontLoseXlintWarnings_pr141556() {
 		initialiseProject("PR141556");
-		configureNonStandardCompileOptions("PR141556","-Xlint:warning");
+		configureNonStandardCompileOptions("PR141556", "-Xlint:warning");
 		build("PR141556");
 		checkWasFullBuild();
-		String warningMessage = "can not build thisJoinPoint " +
-				"lazily for this advice since it has no suitable guard " +
-				"[Xlint:noGuardForLazyTjp]";
-		assertEquals("warning message should be '" + warningMessage + "'",
-				warningMessage,
-				((IMessage)getWarningMessages("PR141556").get(0))
-					.getMessage());
+		String warningMessage = "can not build thisJoinPoint " + "lazily for this advice since it has no suitable guard "
+				+ "[Xlint:noGuardForLazyTjp]";
+		assertEquals("warning message should be '" + warningMessage + "'", warningMessage, ((IMessage) getWarningMessages(
+				"PR141556").get(0)).getMessage());
 
 		// add a space to the Aspect but dont do a build
-		alter("PR141556","inc1");
+		alter("PR141556", "inc1");
 		// remove the space so that the Aspect is exactly as it was
-		alter("PR141556","inc2");
+		alter("PR141556", "inc2");
 		// build the project and we should not have lost the xlint warning
 		build("PR141556");
 		checkWasntFullBuild();
-		assertTrue("there should still be a warning message ",
-				!getWarningMessages("PR141556").isEmpty());
-		assertEquals("warning message should be '" + warningMessage + "'",
-				warningMessage,
-				((IMessage)getWarningMessages("PR141556").get(0))
-					.getMessage());
-	}
-	
+		assertTrue("there should still be a warning message ", !getWarningMessages("PR141556").isEmpty());
+		assertEquals("warning message should be '" + warningMessage + "'", warningMessage, ((IMessage) getWarningMessages(
+				"PR141556").get(0)).getMessage());
+	}
+
 	public void testAdviceDidNotMatch_pr152589() {
 		initialiseProject("PR152589");
 		build("PR152589");
 		List warnings = getWarningMessages("PR152589");
-		assertTrue("There should be no warnings:\n"+warnings,
-				warnings.isEmpty());
-		alter("PR152589","inc1");
+		assertTrue("There should be no warnings:\n" + warnings, warnings.isEmpty());
+		alter("PR152589", "inc1");
 		build("PR152589");
 		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
-			  checkWasFullBuild(); // the line number has changed... but nothing structural about the code
-			else 
-			  checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
+			checkWasFullBuild(); // the line number has changed... but nothing structural about the code
+		else
+			checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
 
-//		checkWasFullBuild();
+		// checkWasFullBuild();
 		warnings = getWarningMessages("PR152589");
-		assertTrue("There should be no warnings after adding a whitespace:\n"
-				+warnings,warnings.isEmpty());	
+		assertTrue("There should be no warnings after adding a whitespace:\n" + warnings, warnings.isEmpty());
 	}
-	
+
 	// see comment #11 of bug 154054
 	public void testNoFullBuildOnChangeInSysOutInAdviceBody_pr154054() {
 		initialiseProject("PR154054");
 		build("PR154054");
-		alter("PR154054","inc1");
+		alter("PR154054", "inc1");
 		build("PR154054");
 		checkWasntFullBuild();
 	}
@@ -1714,286 +1569,284 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 	public void testShouldFullBuildOnExceptionChange_pr154054() {
 		initialiseProject("PR154054_2");
 		build("PR154054_2");
-		alter("PR154054_2","inc1");
+		alter("PR154054_2", "inc1");
 		build("PR154054_2");
 		checkWasFullBuild();
 	}
-	
+
 	public void testPR158573() {
 		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
 		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
 		initialiseProject("PR158573");
 		build("PR158573");
 		List warnings = getWarningMessages("PR158573");
-		assertTrue("There should be no warnings:\n"+warnings,warnings.isEmpty());
-		alter("PR158573","inc1");
+		assertTrue("There should be no warnings:\n" + warnings, warnings.isEmpty());
+		alter("PR158573", "inc1");
 		build("PR158573");
 
 		checkWasntFullBuild();
 		warnings = getWarningMessages("PR158573");
-		assertTrue("There should be no warnings after changing the value of a " +
-				"variable:\n"+warnings,warnings.isEmpty());	
+		assertTrue("There should be no warnings after changing the value of a " + "variable:\n" + warnings, warnings.isEmpty());
 		AsmManager.getDefault().setHandleProvider(handleProvider);
 	}
-	
+
 	/**
-	 * If the user has specified that they want Java 6 compliance
-	 * and kept the default classfile and source file level settings
-	 * (also 6.0) then expect an error saying that we don't support 
-	 * java 6.
+	 * If the user has specified that they want Java 6 compliance and kept the default classfile and source file level settings
+	 * (also 6.0) then expect an error saying that we don't support java 6.
 	 */
 	public void testPR164384_1() {
 		initialiseProject("PR164384");
 
 		Hashtable javaOptions = new Hashtable();
-		javaOptions.put("org.eclipse.jdt.core.compiler.compliance","1.6");
-		javaOptions.put("org.eclipse.jdt.core.compiler.codegen.targetPlatform","1.6");
-		javaOptions.put("org.eclipse.jdt.core.compiler.source","1.6");
-		configureJavaOptionsMap("PR164384",javaOptions);
-		
+		javaOptions.put("org.eclipse.jdt.core.compiler.compliance", "1.6");
+		javaOptions.put("org.eclipse.jdt.core.compiler.codegen.targetPlatform", "1.6");
+		javaOptions.put("org.eclipse.jdt.core.compiler.source", "1.6");
+		configureJavaOptionsMap("PR164384", javaOptions);
+
 		build("PR164384");
 		List errors = getErrorMessages("PR164384");
-		
+
 		if (getCompilerForProjectWithName("PR164384").isJava6Compatible()) {
-			assertTrue("There should be no errors:\n"+errors,errors.isEmpty());	
+			assertTrue("There should be no errors:\n" + errors, errors.isEmpty());
 		} else {
 			String expectedError = "Java 6.0 compliance level is unsupported";
-			String found = ((IMessage)errors.get(0)).getMessage();
-			assertEquals("Expected 'Java 6.0 compliance level is unsupported'" +
-					" error message but found " + found,expectedError,found);
+			String found = ((IMessage) errors.get(0)).getMessage();
+			assertEquals("Expected 'Java 6.0 compliance level is unsupported'" + " error message but found " + found,
+					expectedError, found);
 			// This is because the 'Java 6.0 compliance' error is an 'error'
 			// rather than an 'abort'. Aborts are really for compiler exceptions.
-			assertTrue("expected there to be more than the one compliance level" +
-					" error but only found that one",errors.size() > 1);
+			assertTrue("expected there to be more than the one compliance level" + " error but only found that one",
+					errors.size() > 1);
 		}
-		
+
 	}
 
 	/**
-	 * If the user has specified that they want Java 6 compliance
-	 * and selected classfile and source file level settings to be
-	 * 5.0 then expect an error saying that we don't support java 6.
+	 * If the user has specified that they want Java 6 compliance and selected classfile and source file level settings to be 5.0
+	 * then expect an error saying that we don't support java 6.
 	 */
 	public void testPR164384_2() {
 		initialiseProject("PR164384");
 
 		Hashtable javaOptions = new Hashtable();
-		javaOptions.put("org.eclipse.jdt.core.compiler.compliance","1.6");
-		javaOptions.put("org.eclipse.jdt.core.compiler.codegen.targetPlatform","1.5");
-		javaOptions.put("org.eclipse.jdt.core.compiler.source","1.5");
-		configureJavaOptionsMap("PR164384",javaOptions);
-		
+		javaOptions.put("org.eclipse.jdt.core.compiler.compliance", "1.6");
+		javaOptions.put("org.eclipse.jdt.core.compiler.codegen.targetPlatform", "1.5");
+		javaOptions.put("org.eclipse.jdt.core.compiler.source", "1.5");
+		configureJavaOptionsMap("PR164384", javaOptions);
+
 		build("PR164384");
 		List errors = getErrorMessages("PR164384");
 		if (getCompilerForProjectWithName("PR164384").isJava6Compatible()) {
-			assertTrue("There should be no errors:\n"+errors,errors.isEmpty());	
+			assertTrue("There should be no errors:\n" + errors, errors.isEmpty());
 		} else {
 			String expectedError = "Java 6.0 compliance level is unsupported";
-			String found = ((IMessage)errors.get(0)).getMessage();
-			assertEquals("Expected 'Java 6.0 compliance level is unsupported'" +
-					" error message but found " + found,expectedError,found);			
+			String found = ((IMessage) errors.get(0)).getMessage();
+			assertEquals("Expected 'Java 6.0 compliance level is unsupported'" + " error message but found " + found,
+					expectedError, found);
 			// This is because the 'Java 6.0 compliance' error is an 'error'
 			// rather than an 'abort'. Aborts are really for compiler exceptions.
-			assertTrue("expected there to be more than the one compliance level" +
-					" error but only found that one",errors.size() > 1);
+			assertTrue("expected there to be more than the one compliance level" + " error but only found that one",
+					errors.size() > 1);
 		}
 	}
-	
+
 	/**
-	 * If the user has specified that they want Java 6 compliance
-	 * and set the classfile level to be 6.0 and source file level 
-	 * to be 5.0 then expect an error saying that we don't support 
-	 * java 6.
+	 * If the user has specified that they want Java 6 compliance and set the classfile level to be 6.0 and source file level to be
+	 * 5.0 then expect an error saying that we don't support java 6.
 	 */
 	public void testPR164384_3() {
 		initialiseProject("PR164384");
 
 		Hashtable javaOptions = new Hashtable();
-		javaOptions.put("org.eclipse.jdt.core.compiler.compliance","1.6");
-		javaOptions.put("org.eclipse.jdt.core.compiler.codegen.targetPlatform","1.6");
-		javaOptions.put("org.eclipse.jdt.core.compiler.source","1.5");
-		configureJavaOptionsMap("PR164384",javaOptions);
-		
+		javaOptions.put("org.eclipse.jdt.core.compiler.compliance", "1.6");
+		javaOptions.put("org.eclipse.jdt.core.compiler.codegen.targetPlatform", "1.6");
+		javaOptions.put("org.eclipse.jdt.core.compiler.source", "1.5");
+		configureJavaOptionsMap("PR164384", javaOptions);
+
 		build("PR164384");
 		List errors = getErrorMessages("PR164384");
-		
+
 		if (getCompilerForProjectWithName("PR164384").isJava6Compatible()) {
-			assertTrue("There should be no errros:\n"+errors,errors.isEmpty());	
+			assertTrue("There should be no errros:\n" + errors, errors.isEmpty());
 		} else {
 			String expectedError = "Java 6.0 compliance level is unsupported";
-			String found = ((IMessage)errors.get(0)).getMessage();
-			assertEquals("Expected 'Java 6.0 compliance level is unsupported'" +
-					" error message but found " + found,expectedError,found);			
+			String found = ((IMessage) errors.get(0)).getMessage();
+			assertEquals("Expected 'Java 6.0 compliance level is unsupported'" + " error message but found " + found,
+					expectedError, found);
 			// This is because the 'Java 6.0 compliance' error is an 'error'
 			// rather than an 'abort'. Aborts are really for compiler exceptions.
-			assertTrue("expected there to be more than the one compliance level" +
-					" error but only found that one",errors.size() > 1);
+			assertTrue("expected there to be more than the one compliance level" + " error but only found that one",
+					errors.size() > 1);
 		}
 	}
-		
+
 	public void testPr168840() throws Exception {
 		initialiseProject("inpathTesting");
-		
+
 		String inpathTestingDir = getWorkingDir() + File.separator + "inpathTesting";
-		String inpathDir  = inpathTestingDir + File.separator + "injarBin" + File.separator + "pkg";
+		String inpathDir = inpathTestingDir + File.separator + "injarBin" + File.separator + "pkg";
 		String expectedOutputDir = inpathTestingDir + File.separator + "bin";
-		
+
 		// set up the inpath to have the directory on it's path
 		File f = new File(inpathDir);
 		Set s = new HashSet();
 		s.add(f);
-		configureInPath("inpathTesting",s);
+		configureInPath("inpathTesting", s);
 		build("inpathTesting");
 		// the declare warning matches one place so expect one warning message
 		List warnings = getWarningMessages("inpathTesting");
-		assertTrue("Expected there to be one warning message but found "
-				+ warnings.size() + ": " + warnings, warnings.size() == 1);
-		
+		assertTrue("Expected there to be one warning message but found " + warnings.size() + ": " + warnings, warnings.size() == 1);
+
 		// copy over the updated version of the inpath class file
-		File from = new File(testdataSrcDir+File.separatorChar+"inpathTesting"
-				+File.separatorChar+"newInpathClass" + File.separatorChar + "InpathClass.class");
+		File from = new File(testdataSrcDir + File.separatorChar + "inpathTesting" + File.separatorChar + "newInpathClass"
+				+ File.separatorChar + "InpathClass.class");
 		File destination = new File(inpathDir + File.separatorChar + "InpathClass.class");
-		FileUtil.copyFile(from,destination);
-		
+		FileUtil.copyFile(from, destination);
+
 		build("inpathTesting");
 		checkWasntFullBuild();
 		// the newly copied inpath class means the declare warning now matches two
 		// places, therefore expect two warning messages
 		warnings = getWarningMessages("inpathTesting");
-		assertTrue("Expected there to be two warning message but found "
-				+ warnings.size() + ": " + warnings, warnings.size() == 2);
+		assertTrue("Expected there to be two warning message but found " + warnings.size() + ": " + warnings, warnings.size() == 2);
 	}
-	
+
 	// --- helper code ---
-	
+
 	/**
-	 * Retrieve program elements related to this one regardless of the relationship.  A JUnit assertion is
-	 * made that the number that the 'expected' number are found.
+	 * Retrieve program elements related to this one regardless of the relationship. A JUnit assertion is made that the number that
+	 * the 'expected' number are found.
 	 * 
 	 * @param programElement Program element whose related elements are to be found
 	 * @param expected the number of expected related elements
 	 */
-	private List/*IProgramElement*/ getRelatedElements(IProgramElement programElement,int expected) {
+	private List/* IProgramElement */getRelatedElements(IProgramElement programElement, int expected) {
 		List relatedElements = getRelatedElements(programElement);
 		StringBuffer debugString = new StringBuffer();
-		if (relatedElements!=null) {
-			for (Iterator iter = relatedElements.iterator(); iter.hasNext();) {	
+		if (relatedElements != null) {
+			for (Iterator iter = relatedElements.iterator(); iter.hasNext();) {
 				String element = (String) iter.next();
-				debugString.append(AsmManager.getDefault().getHierarchy().findElementForHandle(element).toLabelString()).append("\n");
+				debugString.append(AsmManager.getDefault().getHierarchy().findElementForHandle(element).toLabelString()).append(
+						"\n");
 			}
 		}
-		assertTrue("Should be "+expected+" element"+(expected>1?"s":"")+" related to this one '"+programElement+
-				"' but found :\n "+debugString,relatedElements!=null && relatedElements.size()==1);
+		assertTrue("Should be " + expected + " element" + (expected > 1 ? "s" : "") + " related to this one '" + programElement
+				+ "' but found :\n " + debugString, relatedElements != null && relatedElements.size() == 1);
 		return relatedElements;
 	}
-	
+
 	private IProgramElement getFirstRelatedElement(IProgramElement programElement) {
-		List rels = getRelatedElements(programElement,1);
-		return AsmManager.getDefault().getHierarchy().findElementForHandle((String)rels.get(0));
+		List rels = getRelatedElements(programElement, 1);
+		return AsmManager.getDefault().getHierarchy().findElementForHandle((String) rels.get(0));
 	}
 
-	
-	
-	private List/*IProgramElement*/ getRelatedElements(IProgramElement advice) {
+	private List/* IProgramElement */getRelatedElements(IProgramElement advice) {
 		List output = null;
 		IRelationshipMap map = AsmManager.getDefault().getRelationshipMap();
-		List/*IRelationship*/ rels = (List)map.get(advice);
-		if (rels==null) fail("Did not find any related elements!");
+		List/* IRelationship */rels = map.get(advice);
+		if (rels == null)
+			fail("Did not find any related elements!");
 		for (Iterator iter = rels.iterator(); iter.hasNext();) {
 			IRelationship element = (IRelationship) iter.next();
-			List/*String*/ targets = element.getTargets();
-			if (output==null) output = new ArrayList();
+			List/* String */targets = element.getTargets();
+			if (output == null)
+				output = new ArrayList();
 			output.addAll(targets);
 		}
 		return output;
 	}
-	
+
 	private IProgramElement findAdvice(IProgramElement ipe) {
-		return findAdvice(ipe,1);
+		return findAdvice(ipe, 1);
 	}
-	
-	private IProgramElement findAdvice(IProgramElement ipe,int whichOne) {
-		if (ipe.getKind()==IProgramElement.Kind.ADVICE) {
-			whichOne=whichOne-1;
-			if (whichOne==0) return ipe;
+
+	private IProgramElement findAdvice(IProgramElement ipe, int whichOne) {
+		if (ipe.getKind() == IProgramElement.Kind.ADVICE) {
+			whichOne = whichOne - 1;
+			if (whichOne == 0)
+				return ipe;
 		}
 		List kids = ipe.getChildren();
 		for (Iterator iter = kids.iterator(); iter.hasNext();) {
 			IProgramElement kid = (IProgramElement) iter.next();
-			IProgramElement found = findAdvice(kid,whichOne);
-			if (found!=null) return found;
+			IProgramElement found = findAdvice(kid, whichOne);
+			if (found != null)
+				return found;
 		}
 		return null;
 	}
-	
+
 	/**
 	 * Finds the first 'code' program element below the element supplied - will return null if there aren't any
 	 */
 	private IProgramElement findCode(IProgramElement ipe) {
-		return findCode(ipe,-1);
+		return findCode(ipe, -1);
 	}
-	
+
 	/**
-	 * Searches a hierarchy of program elements for a 'code' element at the specified line number, a line number
-	 * of -1 means just return the first one you find
+	 * Searches a hierarchy of program elements for a 'code' element at the specified line number, a line number of -1 means just
+	 * return the first one you find
 	 */
-	private IProgramElement findCode(IProgramElement ipe,int linenumber) {
-		if (ipe.getKind()==IProgramElement.Kind.CODE) {
-			if (linenumber==-1 || ipe.getSourceLocation().getLine()==linenumber) return ipe;
+	private IProgramElement findCode(IProgramElement ipe, int linenumber) {
+		if (ipe.getKind() == IProgramElement.Kind.CODE) {
+			if (linenumber == -1 || ipe.getSourceLocation().getLine() == linenumber)
+				return ipe;
 		}
 		List kids = ipe.getChildren();
 		for (Iterator iter = kids.iterator(); iter.hasNext();) {
 			IProgramElement kid = (IProgramElement) iter.next();
-			IProgramElement found = findCode(kid,linenumber);
-			if (found!=null) return found;
+			IProgramElement found = findCode(kid, linenumber);
+			if (found != null)
+				return found;
 		}
 		return null;
 	}
-	
-	
+
 	// other possible tests:
 	// - memory usage (freemem calls?)
 	// - relationship map
 
 	// ---------------------------------------------------------------------------------------------------
 
-	private IProgramElement checkForNode(String packageName,String typeName,boolean shouldBeFound) {
-		IProgramElement ipe = AsmManager.getDefault().getHierarchy().findElementForType(packageName,typeName);
+	private IProgramElement checkForNode(String packageName, String typeName, boolean shouldBeFound) {
+		IProgramElement ipe = AsmManager.getDefault().getHierarchy().findElementForType(packageName, typeName);
 		if (shouldBeFound) {
-           if (ipe==null) printModel();
-		   assertTrue("Should have been able to find '"+packageName+"."+typeName+"' in the asm",ipe!=null);
+			if (ipe == null)
+				printModel();
+			assertTrue("Should have been able to find '" + packageName + "." + typeName + "' in the asm", ipe != null);
 		} else {
-		   if (ipe!=null) printModel();
-		   assertTrue("Should have NOT been able to find '"+packageName+"."+typeName+"' in the asm",ipe==null);
+			if (ipe != null)
+				printModel();
+			assertTrue("Should have NOT been able to find '" + packageName + "." + typeName + "' in the asm", ipe == null);
 		}
-		return ipe;	
+		return ipe;
 	}
 
-
 	private void printModel() {
 		try {
-			AsmManager.dumptree(AsmManager.getDefault().getHierarchy().getRoot(),0);
+			AsmManager.dumptree(AsmManager.getDefault().getHierarchy().getRoot(), 0);
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
 	}
-	
+
 	private static void log(String msg) {
-		if (VERBOSE) System.out.println(msg);
+		if (VERBOSE)
+			System.out.println(msg);
 	}
 
-	private File getProjectRelativePath(String p,String filename) {
-		File projDir = new File(getWorkingDir(),p);
-		return new File(projDir,filename);
+	private File getProjectRelativePath(String p, String filename) {
+		File projDir = new File(getWorkingDir(), p);
+		return new File(projDir, filename);
 	}
 
-	private File getProjectOutputRelativePath(String p,String filename) {
-		File projDir = new File(getWorkingDir(),p);
-		return new File(projDir,"bin"+File.separator+filename);
+	private File getProjectOutputRelativePath(String p, String filename) {
+		File projDir = new File(getWorkingDir(), p);
+		return new File(projDir, "bin" + File.separator + filename);
 	}
 
 	private void assertNoErrors(String projectName) {
-		assertTrue("Should be no errors, but got "+getErrorMessages(projectName),getErrorMessages(projectName).size()==0);				
+		assertTrue("Should be no errors, but got " + getErrorMessages(projectName), getErrorMessages(projectName).size() == 0);
 	}
-	
+
 }
\ No newline at end of file
@@ -0,0 +1,8 @@
+// Auto-generated
+
+public aspect ExecutionAdviceWeaveFast {
+
+	before() : within(out.C0) && execution(void m0(..)) {
+		System.out.println("In the aspect");
+	}
+}
@@ -0,0 +1,8 @@
+// Auto-generated
+
+public aspect ExecutionAdviceWeaveMedium {
+
+	before() : args(out.C0) && execution(void m0(..)) {
+		System.out.println("In the aspect");
+	}
+}
@@ -0,0 +1,8 @@
+// Auto-generated
+
+public aspect ExecutionAdviceWeaveSlow {
+
+	before() : execution(void *(..)) {
+		System.out.println("In the aspect");
+	}
+}
@@ -0,0 +1,8 @@
+// Auto-generated
+
+public aspect GetAdviceWeaveFast {
+
+	before() : get(int out.C0.i0) {
+		System.out.println("In the aspect");
+	}
+}
@@ -0,0 +1,8 @@
+// Auto-generated
+
+public aspect GetAdviceWeaveMedium {
+
+	before() : target(out.C0) && get(int i0) {
+		System.out.println("In the aspect");
+	}
+}
@@ -0,0 +1,8 @@
+// Auto-generated
+
+public aspect GetAdviceWeaveSlow {
+
+	before() : get(int *) {
+		System.out.println("In the aspect");
+	}
+}
@@ -0,0 +1,1318 @@
+// Auto-generated
+package out;
+
+public class C0 {
+
+	int i0;
+	int i1;
+	int i2;
+	int i3;
+	int i4;
+	int i5;
+	int i6;
+	int i7;
+	int i8;
+	int i9;
+	int getter;
+
+	void m0(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m1(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m2(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m3(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m4(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m5(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m6(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m7(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m8(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m9(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m10(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m11(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m12(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m13(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m14(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m15(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m16(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m17(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m18(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m19(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m20(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m21(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m22(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m23(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m24(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m25(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m26(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m27(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m28(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m29(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m30(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m31(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m32(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m33(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m34(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m35(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m36(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m37(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m38(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m39(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m40(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m41(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m42(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m43(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m44(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m45(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m46(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m47(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m48(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m49(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m50(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m51(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m52(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m53(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m54(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m55(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m56(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m57(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m58(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m59(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m60(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m61(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m62(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m63(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m64(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m65(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m66(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m67(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m68(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m69(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m70(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m71(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m72(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m73(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m74(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m75(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m76(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m77(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m78(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m79(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m80(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m81(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m82(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m83(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m84(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m85(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m86(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m87(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m88(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m89(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m90(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m91(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m92(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m93(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m94(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m95(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m96(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m97(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m98(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m99(C0 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+}
@@ -0,0 +1,1318 @@
+// Auto-generated
+package out;
+
+public class C1 {
+
+	int i0;
+	int i1;
+	int i2;
+	int i3;
+	int i4;
+	int i5;
+	int i6;
+	int i7;
+	int i8;
+	int i9;
+	int getter;
+
+	void m0(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m1(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m2(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m3(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m4(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m5(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m6(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m7(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m8(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m9(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m10(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m11(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m12(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m13(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m14(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m15(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m16(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m17(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m18(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m19(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m20(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m21(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m22(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m23(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m24(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m25(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m26(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m27(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m28(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m29(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m30(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m31(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m32(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m33(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m34(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m35(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m36(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m37(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m38(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m39(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m40(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m41(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m42(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m43(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m44(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m45(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m46(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m47(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m48(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m49(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m50(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m51(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m52(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m53(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m54(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m55(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m56(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m57(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m58(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m59(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m60(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m61(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m62(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m63(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m64(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m65(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m66(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m67(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m68(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m69(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m70(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m71(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m72(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m73(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m74(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m75(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m76(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m77(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m78(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m79(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m80(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m81(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m82(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m83(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m84(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m85(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m86(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m87(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m88(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m89(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m90(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m91(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m92(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m93(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m94(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m95(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m96(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m97(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m98(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m99(C1 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+}
@@ -0,0 +1,1318 @@
+// Auto-generated
+package out;
+
+public class C10 {
+
+	int i0;
+	int i1;
+	int i2;
+	int i3;
+	int i4;
+	int i5;
+	int i6;
+	int i7;
+	int i8;
+	int i9;
+	int getter;
+
+	void m0(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m1(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m2(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m3(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m4(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m5(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m6(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m7(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m8(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m9(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m10(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m11(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m12(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m13(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m14(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m15(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m16(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m17(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m18(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m19(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m20(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m21(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m22(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m23(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m24(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m25(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m26(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m27(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m28(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m29(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m30(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m31(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m32(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m33(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m34(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m35(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m36(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m37(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m38(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m39(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m40(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m41(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m42(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m43(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m44(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m45(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m46(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m47(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m48(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m49(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m50(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m51(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m52(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m53(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m54(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m55(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m56(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m57(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m58(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m59(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m60(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m61(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m62(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m63(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m64(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m65(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m66(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m67(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m68(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m69(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m70(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m71(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m72(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m73(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m74(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m75(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m76(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m77(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m78(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m79(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m80(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m81(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m82(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m83(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m84(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m85(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m86(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m87(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m88(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m89(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m90(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m91(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m92(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m93(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m94(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m95(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m96(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m97(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m98(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m99(C10 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+}
@@ -0,0 +1,1318 @@
+// Auto-generated
+package out;
+
+public class C11 {
+
+	int i0;
+	int i1;
+	int i2;
+	int i3;
+	int i4;
+	int i5;
+	int i6;
+	int i7;
+	int i8;
+	int i9;
+	int getter;
+
+	void m0(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m1(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m2(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m3(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m4(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m5(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m6(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m7(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m8(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m9(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m10(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m11(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m12(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m13(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m14(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m15(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m16(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m17(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m18(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m19(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m20(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m21(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m22(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m23(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m24(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m25(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m26(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m27(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m28(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m29(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m30(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m31(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m32(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m33(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m34(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m35(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m36(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m37(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m38(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m39(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m40(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m41(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m42(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m43(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m44(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m45(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m46(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m47(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m48(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m49(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m50(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m51(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m52(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m53(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m54(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m55(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m56(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m57(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m58(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m59(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m60(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m61(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m62(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m63(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m64(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m65(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m66(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m67(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m68(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m69(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m70(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m71(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m72(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m73(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m74(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m75(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m76(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m77(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m78(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m79(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m80(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m81(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m82(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m83(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m84(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m85(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m86(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m87(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m88(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m89(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m90(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m91(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m92(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m93(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m94(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m95(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m96(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m97(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m98(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m99(C11 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+}
@@ -0,0 +1,1318 @@
+// Auto-generated
+package out;
+
+public class C12 {
+
+	int i0;
+	int i1;
+	int i2;
+	int i3;
+	int i4;
+	int i5;
+	int i6;
+	int i7;
+	int i8;
+	int i9;
+	int getter;
+
+	void m0(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m1(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m2(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m3(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m4(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m5(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m6(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m7(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m8(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m9(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m10(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m11(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m12(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m13(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m14(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m15(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m16(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m17(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m18(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m19(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m20(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m21(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m22(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m23(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m24(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m25(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m26(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m27(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m28(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m29(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m30(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m31(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m32(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m33(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m34(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m35(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m36(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m37(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m38(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m39(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m40(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m41(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m42(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m43(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m44(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m45(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m46(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m47(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m48(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m49(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m50(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m51(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m52(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m53(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m54(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m55(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m56(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m57(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m58(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m59(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m60(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m61(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m62(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m63(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m64(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m65(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m66(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m67(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m68(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m69(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m70(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m71(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m72(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m73(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m74(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m75(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m76(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m77(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m78(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m79(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m80(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m81(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m82(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m83(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m84(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m85(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m86(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m87(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m88(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m89(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m90(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m91(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m92(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m93(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m94(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m95(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m96(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m97(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m98(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m99(C12 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+}
@@ -0,0 +1,1318 @@
+// Auto-generated
+package out;
+
+public class C13 {
+
+	int i0;
+	int i1;
+	int i2;
+	int i3;
+	int i4;
+	int i5;
+	int i6;
+	int i7;
+	int i8;
+	int i9;
+	int getter;
+
+	void m0(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m1(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m2(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m3(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m4(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m5(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m6(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m7(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m8(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m9(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m10(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m11(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m12(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m13(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m14(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m15(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m16(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m17(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m18(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m19(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m20(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m21(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m22(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m23(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m24(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m25(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m26(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m27(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m28(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m29(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m30(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m31(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m32(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m33(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m34(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m35(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m36(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m37(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m38(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m39(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m40(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m41(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m42(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m43(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m44(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m45(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m46(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m47(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m48(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m49(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m50(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m51(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m52(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m53(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m54(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m55(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m56(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m57(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m58(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m59(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m60(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m61(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m62(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m63(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m64(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m65(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m66(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m67(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m68(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m69(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m70(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m71(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m72(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m73(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m74(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m75(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m76(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m77(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m78(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m79(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m80(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m81(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m82(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m83(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m84(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m85(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m86(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m87(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m88(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m89(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m90(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m91(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m92(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m93(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m94(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m95(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m96(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m97(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m98(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m99(C13 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+}
@@ -0,0 +1,1318 @@
+// Auto-generated
+package out;
+
+public class C14 {
+
+	int i0;
+	int i1;
+	int i2;
+	int i3;
+	int i4;
+	int i5;
+	int i6;
+	int i7;
+	int i8;
+	int i9;
+	int getter;
+
+	void m0(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m1(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m2(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m3(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m4(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m5(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m6(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m7(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m8(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m9(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m10(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m11(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m12(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m13(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m14(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m15(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m16(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m17(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m18(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m19(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m20(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m21(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m22(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m23(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m24(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m25(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m26(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m27(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m28(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m29(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m30(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m31(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m32(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m33(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m34(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m35(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m36(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m37(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m38(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m39(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m40(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m41(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m42(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m43(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m44(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m45(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m46(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m47(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m48(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m49(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m50(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m51(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m52(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m53(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m54(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m55(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m56(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m57(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m58(C14 arg) {
+		i0++;
+		i1++;
+		i2++;
+		i3++;
+		i4++;
+		i5++;
+		i6++;
+		i7++;
+		i8++;
+		i9++;
+	}
+
+	void m59(C14 arg) {
+		i0++;
