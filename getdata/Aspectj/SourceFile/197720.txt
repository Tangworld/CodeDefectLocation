@@ -0,0 +1,15 @@
+package test.aspects;
+
+
+public class C1<T> {
+
+    @MyAnn
+    protected void aMethod() {
+        System.out.println("Calling aMethod");
+    }
+    
+    public void callAMethod() {
+        aMethod(); // Should be a marker here...
+    }
+
+}
@@ -0,0 +1,34 @@
+package test.aspects;
+
+
+
+public class C2 extends C1<String> {
+    public void callAMethodC2() {
+        aMethod(); // Should be a marker here...
+    }
+    
+    public void innerClassCall() {
+        InnerClass ic = new InnerClass();
+        
+        ic.foo();
+    }
+    protected class InnerClass {
+        public void foo() {
+            aMethod(); // Should be a marker here...
+        }
+    }
+    
+    public static void main(String [] args) {
+        C1 c1 = new C1();
+        
+        c1.callAMethod();
+        
+        C2 c2 = new C2();
+        
+        c2.aMethod(); // Should be a marker here...
+        c2.callAMethod();
+        c2.callAMethodC2();
+        c2.innerClassCall();
+    }
+
+}
@@ -0,0 +1,40 @@
+package test.aspects;
+
+
+
+public class C3 {
+    public void callAMethodC2() {
+        C1 c1 = new C1();
+        c1.aMethod(); // Should be a marker here...
+        
+        C2 c2 = new C2();
+        c2.aMethod();  // Should be a marker here...
+    }
+    
+    public void innerClassCall() {
+        InnerClass ic = new InnerClass();
+        
+        ic.foo();
+    }
+    protected class InnerClass {
+        public void foo() {
+            C1 c1 = new C1();
+            c1.aMethod();  // Should be a marker here...
+
+            C2 c2 = new C2();
+            c2.aMethod();  // Should be a marker here...
+        }
+    }
+    
+    public static void main(String [] args) {
+        C1 c1 = new C1();
+        
+        c1.aMethod(); // Should be a marker here...
+        c1.callAMethod();
+        
+        C3 c2 = new C3();
+        
+        c2.callAMethodC2();
+        c2.innerClassCall();
+    }
+}
@@ -0,0 +1,13 @@
+package test.aspects;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Inherited
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.METHOD)
+public @interface MyAnn {
+}
@@ -0,0 +1,24 @@
+package test.aspects;
+
+import org.aspectj.lang.ProceedingJoinPoint;
+import org.aspectj.lang.annotation.Around;
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.annotation.Pointcut;
+
+@Aspect
+public class MyAnnAspect {
+	
+	@Pointcut("call(@MyAnn * *(..))")
+	void validatedMethod() {}
+	
+
+    @Around("validatedMethod()")
+    public Object validateMethodImpl(ProceedingJoinPoint thisJoinPoint) throws Throwable {
+		return doInvoke(thisJoinPoint);
+	}
+
+   private Object doInvoke(final ProceedingJoinPoint thisJoinPoint) throws Throwable {
+        System.out.println("Invoking : " + thisJoinPoint);
+        return thisJoinPoint.proceed();
+    }
+}
@@ -19,6 +19,7 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 public class Ajc162Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
 	// AspectJ1.6.2	
+	public void testMissingMarkers_pr197720() { runTest("missing markers on inherited annotated method"); }
 	public void testLostGenericsSigOnItd_pr211146() { runTest("lost generic sig on itd"); }
 	public void testLostGenericsSigOnItd_pr211146_2() { runTest("lost generic sig on itd - 2"); }
 	public void testLostGenericsSigOnItd_pr211146_3() { runTest("lost generic sig on itd - 3"); }
@@ -3,6 +3,20 @@
 <!-- AspectJ v1.6.2 Tests -->
 <suite>
 
+	<ajc-test dir="bugs162/pr197720" title="missing markers on inherited annotated method">
+	  <compile files="C1.java C2.java C3.java MyAnn.java MyAnnAspect.java" options="-1.5 -showWeaveInfo">
+	    <message kind="weave" text="Join point 'method-call(void test.aspects.C1.aMethod())' in Type 'test.aspects.C1' (C1.java:12) advised by around advice from 'test.aspects.MyAnnAspect' (MyAnnAspect.java:16)"/>
+	    <message kind="weave" text="Join point 'method-call(void test.aspects.C2.aMethod())' in Type 'test.aspects.C2$InnerClass' (C2.java:17) advised by around advice from 'test.aspects.MyAnnAspect' (MyAnnAspect.java:16)"/>
+	    <message kind="weave" text="Join point 'method-call(void test.aspects.C2.aMethod())' in Type 'test.aspects.C2' (C2.java:7) advised by around advice from 'test.aspects.MyAnnAspect' (MyAnnAspect.java:16)"/>
+	    <message kind="weave" text="Join point 'method-call(void test.aspects.C2.aMethod())' in Type 'test.aspects.C2' (C2.java:28) advised by around advice from 'test.aspects.MyAnnAspect' (MyAnnAspect.java:16)"/>
+	    <message kind="weave" text="Join point 'method-call(void test.aspects.C1.aMethod())' in Type 'test.aspects.C3$InnerClass' (C3.java:22) advised by around advice from 'test.aspects.MyAnnAspect' (MyAnnAspect.java:16)"/>
+	    <message kind="weave" text="Join point 'method-call(void test.aspects.C2.aMethod())' in Type 'test.aspects.C3$InnerClass' (C3.java:25) advised by around advice from 'test.aspects.MyAnnAspect' (MyAnnAspect.java:16)"/>
+	    <message kind="weave" text="Join point 'method-call(void test.aspects.C1.aMethod())' in Type 'test.aspects.C3' (C3.java:8) advised by around advice from 'test.aspects.MyAnnAspect' (MyAnnAspect.java:16)"/>
+	    <message kind="weave" text="Join point 'method-call(void test.aspects.C2.aMethod())' in Type 'test.aspects.C3' (C3.java:11) advised by around advice from 'test.aspects.MyAnnAspect' (MyAnnAspect.java:16)"/>
+	    <message kind="weave" text="Join point 'method-call(void test.aspects.C1.aMethod())' in Type 'test.aspects.C3' (C3.java:32) advised by around advice from 'test.aspects.MyAnnAspect' (MyAnnAspect.java:16)"/>
+	  </compile>
+	</ajc-test>
+	
 	<ajc-test dir="bugs162/pr211146" title="lost generic sig on itd">
 	  <compile files="GenericsLost.java" options="-1.5"/>
 	  <run class="GenericsLost"/>
@@ -285,12 +285,28 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 		return  (annotationTypes!=null);
 	}
 
+	/**
+	 * Check if this member has an annotation of the specified type.  If the member has a backing generic
+	 * member then this member represents a parameterization of a member in a generic type and the annotations
+	 * available on the backing generic member should be used.
+	 * 
+	 * @param ofType the type of the annotation being searched for
+	 * @return true if the annotation is found on this member or its backing generic member
+	 */
     public boolean hasAnnotation(UnresolvedType ofType) {
          // The ctors don't allow annotations to be specified ... yet - but
         // that doesn't mean it is an error to call this method.
         // Normally the weaver will be working with subtypes of 
         // this type - BcelField/BcelMethod
-        if (annotationTypes==null) return false;
+    	if (backingGenericMember!=null) {
+    		if (annotationTypes!=null) {
+    			throw new BCException("Unexpectedly found a backing generic member and a local set of annotations");
+    		}
+    		return backingGenericMember.hasAnnotation(ofType);    		
+    	}
+        if (annotationTypes==null) {
+        		return false;
+        }
 		return annotationTypes.contains(ofType);
     }
 
