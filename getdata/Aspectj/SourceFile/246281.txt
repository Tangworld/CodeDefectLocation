@@ -0,0 +1,5 @@
+import java.lang.annotation.*;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Inherited
+@interface Anno {}
@@ -0,0 +1,3 @@
+public class Child extends Parent {
+  public void bar() {}
+}
@@ -0,0 +1,4 @@
+@Anno
+public class Parent {
+  public void foo() { }
+}
@@ -0,0 +1,3 @@
+aspect X {
+  before(): execution(* (@Anno *).*(..)) {}
+}
@@ -0,0 +1,4 @@
+//@Anno
+public class Parent {
+  public void foo() { }
+}
@@ -0,0 +1,4 @@
+@Anno
+public class Parent {
+  public void foo() { }
+}
@@ -123,6 +123,26 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		}
 	}
 
+	public void testIncrementalAndAnnotations() {
+		initialiseProject("Annos");
+		build("Annos");
+		checkWasFullBuild();
+		checkCompileWeaveCount("Annos", 4, 4);
+		assertEquals("Should be 3 relationships ", 3, AsmManager.getDefault().getRelationshipMap().getEntries().size());
+
+		alter("Annos", "inc1"); // Comment out the annotation on Parent
+		build("Annos");
+		checkWasntFullBuild();
+		assertEquals("Should be no relationships ", 0, AsmManager.getDefault().getRelationshipMap().getEntries().size());
+		checkCompileWeaveCount("Annos", 3, 3);
+
+		alter("Annos", "inc2"); // Add the annotation back onto Parent
+		build("Annos");
+		checkWasntFullBuild();
+		assertEquals("Should be 3 relationships ", 3, AsmManager.getDefault().getRelationshipMap().getEntries().size());
+		checkCompileWeaveCount("Annos", 3, 3);
+	}
+
 	public void testIncrementalItdsWithMultipleAspects_pr173729() {
 		initialiseProject("PR173729");
 		build("PR173729");
@@ -41,6 +41,7 @@ import org.aspectj.org.eclipse.jdt.core.compiler.CharOperation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.aspectj.org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.aspectj.org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
+import org.aspectj.org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.env.IBinaryField;
 import org.aspectj.org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.aspectj.org.eclipse.jdt.internal.compiler.env.IBinaryType;
@@ -1341,6 +1342,27 @@ public class AjState implements CompilerConfigurationChangeFlags {
 			return true;
 		}
 
+		// have annotations changed on the type?
+		IBinaryAnnotation[] newAnnos = reader.getAnnotations();
+		if (newAnnos == null || newAnnos.length == 0) {
+			if (existingType.annotations != null && existingType.annotations.length != 0) {
+				return true;
+			}
+		} else {
+			IBinaryAnnotation[] existingAnnos = existingType.annotations;
+			if (existingAnnos == null || existingAnnos.length != newAnnos.length) {
+				return true;
+			}
+			// Does not allow for an order switch
+			// Does not cope with a change in values set on the annotation (hard to create a testcase where this is a problem tho)
+			for (int i = 0; i < newAnnos.length; i++) {
+				if (!CharOperation.equals(newAnnos[i].getTypeName(), existingAnnos[i].getTypeName())) {
+					return true;
+				}
+			}
+
+		}
+
 		// interfaces
 		char[][] existingIfs = existingType.interfaces;
 		char[][] newIfsAsChars = reader.getInterfaceNames();
