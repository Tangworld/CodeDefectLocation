@@ -4,7 +4,7 @@
      The -Xlintfile:lint.properties allows fine-grained control. In tools.jar, see
      org/aspectj/weaver/XlintDefault.properties for the default behavior and a template to copy. 
 ### AspectJ-specific messages 
-compiler.name = AspectJ Compiler 1.7.1
+compiler.name = AspectJ Compiler 1.7.3
 compiler.version = Eclipse Compiler 0.B79_R37x, 3.7
 compiler.copyright = 
 
@@ -1858,6 +1858,17 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 					int c = compareMemberPrecedence(typeTransformerSignature, existingMember);
 					// System.err.println("   c: " + c);
 					if (c < 0) {
+						ResolvedType typeTransformerTargetType = typeTransformerSignature.getDeclaringType().resolve(world);
+						if (typeTransformerTargetType.isInterface()) {
+							ResolvedType existingMemberType = existingMember.getDeclaringType().resolve(world);
+							if ((rtm instanceof NewMethodTypeMunger) && !typeTransformerTargetType.equals(existingMemberType)) {
+								// Might be pr404601. ITD is on an interface with a different visibility to the real member
+								if (Modifier.isPrivate(typeTransformerSignature.getModifiers()) &&
+									Modifier.isPublic(existingMember.getModifiers())) {
+									world.getMessageHandler().handleMessage(new Message("private intertype declaration '"+typeTransformerSignature.toString()+"' clashes with public member '"+existingMember.toString()+"'",existingMember.getSourceLocation(),true));
+								}	
+							}
+						}
 						// existingMember dominates munger
 						checkLegalOverride(typeTransformerSignature, existingMember, 0x10, typeTransformer.getAspectType());
 						return true;
@@ -0,0 +1,9 @@
+import java.lang.annotation.*;
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Foo {}
+
+aspect A1 {
+  declare @method: void Intface+.getName(): @Foo;
+}
+
@@ -0,0 +1,4 @@
+aspect A2 {
+  public void Intface.getName() { }
+}
+
@@ -0,0 +1 @@
+class C implements Intface {}
@@ -0,0 +1 @@
+interface Intface {}
@@ -0,0 +1,13 @@
+import java.lang.annotation.*;
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Foo {}
+
+aspect A {
+  declare @method: void *.getName(): @Foo;
+  public void Intface.getName() { }
+}
+
+interface Intface { }
+
+class C implements Intface {}
@@ -0,0 +1,3 @@
+public interface IUser {
+	void setUsername(String username);
+}
@@ -0,0 +1,3 @@
+public class Test {
+	public static void main(String[] argv) { new Youser("foo"); }
+}
@@ -0,0 +1,12 @@
+public aspect UserTrait {
+	public interface I extends IUser { } 
+
+	declare parents : Youser implements I;
+
+	public void I.setUsername(String username) {
+		testSetUsername(username);
+	}
+
+	private void I.testSetUsername(String username) { }
+
+}
@@ -0,0 +1,4 @@
+public class Youser {
+	public Youser(String username) { setUsername(username); }
+	public void testSetUsername(String username) { }
+}
@@ -15,6 +15,7 @@ public class AllTests17 {
 	public static Test suite() {
 		TestSuite suite = new TestSuite("AspectJ System Test Suite - 1.7");
 		// $JUnit-BEGIN$
+		suite.addTest(AllTestsAspectJ173.suite());
 		suite.addTest(AllTestsAspectJ172.suite());
 		suite.addTest(AllTestsAspectJ171.suite());
 		suite.addTest(AllTestsAspectJ170.suite());
@@ -0,0 +1,238 @@
+/*******************************************************************************
+ * Copyright (c) 2012 Contributors
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *    Andy Clement - initial API and implementation
+ *******************************************************************************/
+package org.aspectj.systemtest.ajc173;
+
+import java.io.File;
+
+import junit.framework.Test;
+
+import org.aspectj.apache.bcel.classfile.JavaClass;
+import org.aspectj.apache.bcel.classfile.Method;
+import org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;
+import org.aspectj.testing.XMLBasedAjcTestCase;
+
+/**
+ * @author Andy Clement
+ */
+public class Ajc173Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
+
+	public void testAbstractMethodError_404601() throws Exception {
+		runTest("abstract method error");
+	}
+	
+	public void testDeclareAnnoOnItd() throws Exception {
+		runTest("declare anno on itd");
+		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),"C");
+		Method m = getMethodStartsWith(jc, "getName");
+		assertNotNull(m);
+		AnnotationGen[] ags = m.getAnnotations();
+		for (int i=0;i<ags.length;i++) {
+			System.out.println(ags[i]);
+		}
+		assertEquals(1,ags.length);
+		assertEquals("LFoo;",ags[0].getTypeSignature());
+	}
+	
+	// still broken!
+//	public void testDeclareAnnoOnItd2() throws Exception {
+//		runTest("declare anno on itd 2");
+//		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),"C");
+//		Method m = getMethodStartsWith(jc, "getName");
+//		assertNotNull(m);
+//		AnnotationGen[] ags = m.getAnnotations();
+//		for (int i=0;i<ags.length;i++) {
+//			System.out.println(ags[i]);
+//		}
+//		assertEquals(1,ags.length);
+//		assertEquals("LFoo;",ags[0].getTypeSignature());
+//	}
+	
+//	// if the test is failing because the classes won't run, remove the run blocks from the ajc172.xml entry and re-run to check signatures.
+//	public void testSignatures_pr394535() throws Exception {
+//		runTest("signatures");
+//		
+//		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),"Bug2$ClassA2"); // the working one
+//		String sss = jc.getSignatureAttribute().getSignature();
+//		assertEquals("<T::LBug2$Interface12;:LBug2$Interface22;>Ljava/lang/Object;Ljava/io/Serializable;", sss);
+//		
+//		jc = getClassFrom(ajc.getSandboxDirectory(),"Bug$ClassA");
+//		sss = jc.getSignatureAttribute().getSignature();
+//		assertEquals("<T::LBug$Interface1;:LBug$Interface2;>Ljava/lang/Object;Ljava/io/Serializable;", sss);
+//	}
+//	
+//	// extends
+//	public void testPSignatures_pr399590() throws Exception {
+//		runTest("p signatures 1");
+//		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),"Cage");
+//		String sss = jc.getSignatureAttribute().getSignature();
+//		assertEquals("<T:LAnimal<+LCage<TT;>;>;>LBar;", sss);
+//		jc = getClassFrom(ajc.getSandboxDirectory(),"Cage2");
+//		sss = jc.getSignatureAttribute().getSignature();
+//		assertEquals("<T:LAnimal2<+LCage2<TT;>;>;>LBar2;Ljava/io/Serializable;", sss);
+//	}
+//	
+//	// extends two classes
+//	public void testPSignatures_pr399590_2() throws Exception {
+//		runTest("p signatures 2");
+//		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),"Cage");
+//		String sss = jc.getSignatureAttribute().getSignature();
+//		assertEquals("<T:LAnimal<+LCage<TT;LIntf;>;LIntf;>;Q:Ljava/lang/Object;>LBar;", sss);
+//		jc = getClassFrom(ajc.getSandboxDirectory(),"Cage2");
+//		sss = jc.getSignatureAttribute().getSignature();
+//		assertEquals("<T:LAnimal2<+LCage2<TT;LIntf2;>;LIntf2;>;Q:Ljava/lang/Object;>LBar2;Ljava/io/Serializable;", sss);
+//	}
+//	
+//	// super
+//	public void testPSignatures_pr399590_3() throws Exception {
+//		runTest("p signatures 3");
+//		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),"Cage");
+//		String sss = jc.getSignatureAttribute().getSignature();
+//		assertEquals("<T:LAnimal<-LXXX<TT;>;>;>LBar;", sss);
+//		jc = getClassFrom(ajc.getSandboxDirectory(),"Cage2");
+//		sss = jc.getSignatureAttribute().getSignature();
+//		assertEquals("<T:LAnimal2<-LXXX2<TT;>;>;>LBar2;Ljava/io/Serializable;", sss);
+//	}
+//
+//	// super
+//	public void testPSignatures_pr399590_4() throws Exception {
+//		runTest("p signatures 4");
+//		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),"Cage");
+//		String sss = jc.getSignatureAttribute().getSignature();
+//		assertEquals("<T:LAnimal<-LXXX<TT;>;LYYY;>;>LBar;", sss);
+//		jc = getClassFrom(ajc.getSandboxDirectory(),"Cage2");
+//		sss = jc.getSignatureAttribute().getSignature();
+//		assertEquals("<T:LAnimal2<-LXXX2<TT;>;LYYY2;>;>LBar2;Ljava/io/Serializable;", sss);
+//	}
+//
+//	// unbound
+//	public void testPSignatures_pr399590_5() throws Exception {
+//		runTest("p signatures 5");
+//		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),"Cage");
+//		String sss = jc.getSignatureAttribute().getSignature();
+//		assertEquals("<T:LAnimal<*>;>LBar;", sss);
+//		jc = getClassFrom(ajc.getSandboxDirectory(),"Cage2");
+//		sss = jc.getSignatureAttribute().getSignature();
+//		assertEquals("<T:LAnimal2<*>;>LBar2;Ljava/io/Serializable;", sss);
+//	}
+//
+//	public void testIfPointcutNames_pr398246() throws Exception {
+//		runTest("if pointcut names");
+//		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(), "X");
+//		Method m = getMethodStartsWith(jc, "ajc$if");
+//		assertEquals("ajc$if$andy", m.getName());
+//	}
+//
+//	public void testIfPointcutNames_pr398246_2() throws Exception {
+//		runTest("if pointcut names 2");
+//		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(), "X");
+//		Method m = getMethodStartsWith(jc, "ajc$if");
+//		assertEquals("ajc$if$fred", m.getName());
+//	}
+//
+//	// fully qualified annotation name is used
+//	public void testIfPointcutNames_pr398246_3() throws Exception {
+//		runTest("if pointcut names 3");
+//		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(), "X");
+//		Method m = getMethodStartsWith(jc, "ajc$if");
+//		assertEquals("ajc$if$barney", m.getName());
+//	}
+//
+//	// compiling a class later than the initial build - does it pick up the
+//	// right if clause name?
+//	public void testIfPointcutNames_pr398246_4() throws Exception {
+//		runTest("if pointcut names 4");
+//		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(), "X");
+//		Method m = getMethodStartsWith(jc, "ajc$if");
+//		assertEquals("ajc$if$sid", m.getName());
+//	}
+//
+//	// new style generated names
+//	public void testIfPointcutNames_pr398246_5() throws Exception {
+//		runTest("if pointcut names 5");
+//		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(), "X");
+//		Method m = getMethodStartsWith(jc, "ajc$if");
+//		assertEquals("ajc$if$ac0cb804", m.getName());
+//
+//		jc = getClassFrom(ajc.getSandboxDirectory(), "X2");
+//		m = getMethodStartsWith(jc, "ajc$if");
+//		assertEquals("ajc$if$ac0cb804", m.getName());
+//	}
+//
+//	// new style generated names - multiple ifs in one pointcut
+//	public void testIfPointcutNames_pr398246_6() throws Exception {
+//		runTest("if pointcut names 6");
+//		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(), "X");
+//		Method m = getMethodStartsWith(jc, "ajc$if",1);
+//		assertEquals("ajc$if$aac93da8", m.getName());
+//		m = getMethodStartsWith(jc, "ajc$if",2);
+//		assertEquals("ajc$if$1$ae5e778a", m.getName());
+//	}
+//
+//	// new style generated names - multiple ifs in one advice
+//	public void testIfPointcutNames_pr398246_7() throws Exception {
+//		runTest("if pointcut names 7");
+//		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(), "X");
+//		Method m = getMethodStartsWith(jc, "ajc$if",1);
+//		assertEquals("ajc$if$1$ac0607c", m.getName());
+//		m = getMethodStartsWith(jc, "ajc$if",2);
+//		assertEquals("ajc$if$1$1$4d4baf36", m.getName());
+//	}
+//
+//	public void testOptionalAspects_pr398588() {
+//		runTest("optional aspects");
+//	}
+//
+//	public void testInconsistentClassFile_pr389750() {
+//		runTest("inconsistent class file");
+//	}
+//
+//	public void testInconsistentClassFile_pr389750_2() {
+//		runTest("inconsistent class file 2");
+//	}
+//
+//	public void testInconsistentClassFile_pr389750_3() {
+//		runTest("inconsistent class file 3");
+//	}
+//
+//	public void testInconsistentClassFile_pr389750_4() {
+//		runTest("inconsistent class file 4");
+//	}
+//
+//	public void testAnnotationValueError_pr389752_1() {
+//		runTest("annotation value error 1");
+//	}
+//
+//	public void testAnnotationValueError_pr389752_2() {
+//		runTest("annotation value error 2");
+//	}
+//
+//	// this needs some cleverness to fix... the annotation value is parsed as a
+//	// string and then not checked
+//	// to see if the user is accidentally supplying, for example, an enum value.
+//	// Due to the use of strings, it
+//	// is hard to check. The verification code might go here:
+//	// WildAnnotationTypePattern, line 205 (the string case)
+//	// public void testAnnotationValueError_pr389752_3() {
+//	// runTest("annotation value error 3");
+//	// }
+
+	// ---
+
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(Ajc173Tests.class);
+	}
+
+	@Override
+	protected File getSpecFile() {
+		return new File("../tests/src/org/aspectj/systemtest/ajc173/ajc173.xml");
+	}
+
+}
@@ -0,0 +1,25 @@
+/*******************************************************************************
+ * Copyright (c) 2008 Contributors
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *    Andy Clement - initial API and implementation
+ *******************************************************************************/
+package org.aspectj.systemtest.ajc173;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+
+public class AllTestsAspectJ173 {
+
+	public static Test suite() {
+		TestSuite suite = new TestSuite("AspectJ 1.7.3 tests");
+		// $JUnit-BEGIN$
+		suite.addTest(Ajc173Tests.suite());
+		// $JUnit-END$
+		return suite;
+	}
+}
@@ -0,0 +1,31 @@
+<!DOCTYPE suite SYSTEM "../tests/ajcTestSuite.dtd"[]>
+
+<suite>
+
+	<ajc-test dir="bugs173/pr404601" title="abstract method error">
+		<compile files="user/IUser.java user/Test.java user/UserTrait.java user/Youser.java" options="-1.5">
+			<message kind="error" text="private intertype declaration 'void UserTrait$I.testSetUsername(java.lang.String)' clashes with public member 'void Youser.testSetUsername(java.lang.String)'"/>
+		</compile>
+	</ajc-test>
+
+	<ajc-test dir="bugs173/lyor" title="declare anno on itd">
+      <compile files="Code.java" options="-1.5 -showWeaveInfo">
+      	<message kind="weave" text="'public void Intface.getName()' (Code.java) is annotated with @Foo method annotation from 'A' (Code.java:7)"/>
+		<message kind="weave" text="Type 'C' (Code.java) has intertyped method from 'A' (Code.java:'void Intface.getName()')"/>
+		<message kind="weave" text="Type 'Intface' (Code.java) has intertyped method from 'A' (Code.java:'void Intface.getName()')"/>
+      </compile>
+    </ajc-test>
+    
+	<ajc-test dir="bugs173/lyor/2" title="declare anno on itd 2">
+		<compile files="A1.java" outjar="aspects1.jar" options="-1.5 -Xlint:ignore"/>
+		<compile files="Intface.java A2.java" aspectpath="aspects1.jar" outjar="aspects2.jar" options="-1.5"/>
+		<compile files="Code.java" aspectpath="aspects1.jar;aspects2.jar" options="-1.5"/>
+		
+      <!-- 
+      	<message kind="weave" text="'public void Intface.getName()' (A2.java) is annotated with @Foo method annotation from 'A1' (A1.java:7)"/>
+		<message kind="weave" text="Type 'C' (Code.java) has intertyped method from 'A2' (A2.java:'void Intface.getName()')"/>
+		<message kind="weave" text="Type 'Intface' (Code.java) has intertyped method from 'A2' (A2.java:'void Intface.getName()')"/>
+		-->
+    </ajc-test>
+
+</suite>
@@ -944,8 +944,7 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 				}
 			}
 
-			// If it doesn't target an interface and there is a body (i.e. it
-			// isnt abstract)
+			// If it doesn't target an interface and there is a body (i.e. it isnt abstract)
 			if (!onInterface && !Modifier.isAbstract(mangledInterMethod.getModifiers())) {
 				InstructionList body = newMethod.getBody();
 				InstructionFactory fact = classGen.getFactory();
