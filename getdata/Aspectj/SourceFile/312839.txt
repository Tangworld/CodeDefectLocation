@@ -0,0 +1,13 @@
+package com.wibble.foo;
+
+public class Class {
+  private String name = "Andy";
+
+  public static void main(String [] argv) {
+    new Class().print();
+  }
+
+  public void print() {
+    System.out.println("Hello "+name);
+  }
+}
@@ -0,0 +1,15 @@
+package com.wibble.foo;
+
+import java.lang.annotation.*;
+
+aspect X {
+  public int Class.i;
+  public String Class.getMeSomething() {
+    return "abc";
+  }
+  declare parents: Class implements java.io.Serializable;
+  declare @type: Class: @Foobar;
+}
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Foobar {}
@@ -22,6 +22,7 @@ import org.aspectj.weaver.CompressingDataOutputStream;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.Shadow;
 import org.aspectj.weaver.VersionedDataInputStream;
+import org.aspectj.weaver.patterns.ConstantPoolSimulator;
 import org.aspectj.weaver.patterns.FormalBinding;
 import org.aspectj.weaver.patterns.Pointcut;
 import org.aspectj.weaver.patterns.SimpleScope;
@@ -106,12 +107,13 @@ public class PatternWeaveTestCase extends WeaveTestCase {
 
 	public void checkSerialize(Pointcut p) throws IOException {
 		ByteArrayOutputStream bo = new ByteArrayOutputStream();
-		CompressingDataOutputStream out = new CompressingDataOutputStream(bo);
+		ConstantPoolSimulator cps = new ConstantPoolSimulator();
+		CompressingDataOutputStream out = new CompressingDataOutputStream(bo, cps);
 		p.write(out);
 		out.close();
 
 		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
-		VersionedDataInputStream in = new VersionedDataInputStream(bi);
+		VersionedDataInputStream in = new VersionedDataInputStream(bi, cps);
 		Pointcut newP = Pointcut.read(in, null);
 
 		assertEquals("write/read", p, newP);
@@ -27,6 +27,7 @@ import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.ShadowMunger;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.VersionedDataInputStream;
+import org.aspectj.weaver.patterns.ConstantPoolSimulator;
 import org.aspectj.weaver.patterns.Pointcut;
 import org.aspectj.weaver.patterns.SimpleScope;
 
@@ -172,12 +173,13 @@ public class PointcutResidueTestCase extends WeaveTestCase {
 
 	public void checkSerialize(Pointcut p) throws IOException {
 		ByteArrayOutputStream bo = new ByteArrayOutputStream();
-		CompressingDataOutputStream out = new CompressingDataOutputStream(bo);
+		ConstantPoolSimulator cps = new ConstantPoolSimulator();
+		CompressingDataOutputStream out = new CompressingDataOutputStream(bo, cps);
 		p.write(out);
 		out.close();
 
 		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
-		VersionedDataInputStream in = new VersionedDataInputStream(bi);
+		VersionedDataInputStream in = new VersionedDataInputStream(bi, cps);
 		Pointcut newP = Pointcut.read(in, null);
 
 		assertEquals("write/read", p, newP);
@@ -14,7 +14,6 @@ package org.aspectj.weaver.patterns;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-
 import junit.framework.TestCase;
 
 import org.aspectj.weaver.BoundedReferenceType;
@@ -389,12 +388,13 @@ public class WildTypePatternResolutionTestCase extends TestCase {
 	private TypePattern writeAndRead(TypePattern etp) {
 		try {
 			ByteArrayOutputStream baos = new ByteArrayOutputStream();
-			CompressingDataOutputStream dos = new CompressingDataOutputStream(baos);
+			ConstantPoolSimulator cps = new ConstantPoolSimulator();
+			CompressingDataOutputStream dos = new CompressingDataOutputStream(baos, cps);
 			etp.write(dos);
 			dos.flush();
 			dos.close();
 			ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
-			VersionedDataInputStream in = new VersionedDataInputStream(bais);
+			VersionedDataInputStream in = new VersionedDataInputStream(bais, cps);
 			in.setVersion(new WeaverVersionInfo());
 			TypePattern ret = TypePattern.read(in, null);
 			return ret;
@@ -36,7 +36,7 @@ public class ReadingAttributes extends TestCase {
 			System.out.println(attrs[i].getName());
 			if (attrs[i].getName().endsWith("WeaverState")) {
 				Unknown u = (Unknown) attrs[i];
-				VersionedDataInputStream vdis = new VersionedDataInputStream(new ByteArrayInputStream(u.getBytes()));
+				VersionedDataInputStream vdis = new VersionedDataInputStream(new ByteArrayInputStream(u.getBytes()), null);
 				// WeaverStateInfo wsi =
 				WeaverStateInfo.read(vdis, null);
 				// System.out.println(wsi);
@@ -387,12 +387,13 @@ public class WildTypePatternResolutionTestCase extends TestCase {
 	private TypePattern writeAndRead(TypePattern etp) {
 		try {
 			ByteArrayOutputStream baos = new ByteArrayOutputStream();
-			CompressingDataOutputStream dos = new CompressingDataOutputStream(baos);
+			ConstantPoolSimulator cps = new ConstantPoolSimulator();
+			CompressingDataOutputStream dos = new CompressingDataOutputStream(baos, cps);
 			etp.write(dos);
 			dos.flush();
 			dos.close();
 			ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
-			VersionedDataInputStream in = new VersionedDataInputStream(bais);
+			VersionedDataInputStream in = new VersionedDataInputStream(bais, cps);
 			in.setVersion(new WeaverVersionInfo());
 			TypePattern ret = TypePattern.read(in, null);
 			return ret;
@@ -30,106 +30,146 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
  */
 public class SanityTests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
-  // Incredibly trivial test programs that check the compiler works at all (these are easy-ish to debug)
-  public void testSimpleJava_A() { runTest("simple - a");}
-  public void testSimpleJava_B() { runTest("simple - b");}
-  public void testSimpleCode_C() { runTest("simple - c");}
-  public void testSimpleCode_D() { runTest("simple - d");}
-  public void testSimpleCode_E() { runTest("simple - e");}
-  public void testSimpleCode_F() { runTest("simple - f");}
-  public void testSimpleCode_G() { runTest("simple - g");}
-  
-  public void testSimpleCode_H() { runTest("simple - h");}
-  public void testSimpleCode_I() { runTest("simple - i");}
-  
-  // Check the version number in the classfiles is correct when Java6 options specified
-  public void testVersionCorrect1() throws ClassNotFoundException {
-	  runTest("simple - j");
-	  checkVersion("A",50,0);
-  }
-  public void testVersionCorrect2() throws ClassNotFoundException {
-	  runTest("simple - k");
-	  checkVersion("A",50,0);
-  }
-  public void testVersionCorrect3() throws ClassNotFoundException {
-	  runTest("simple - l");
-	  checkVersion("A",50,0);
-  }
-  public void testVersionCorrect4() throws ClassNotFoundException {// check it is 49.0 when -1.5 is specified
-	  runTest("simple - m");
-	  checkVersion("A",49,0);
-  }
-	  
-  // Check the stackmap stuff appears for methods in a Java6 file
-//  public void testStackMapAttributesAppear() throws ClassNotFoundException {
-//	  runTest("simple - n");
-//	  checkStackMapExistence("A","<init>_<clinit>");
-//	  checkStackMapExistence("X","<init>_<clinit>_ajc$pointcut$$complicatedPointcut$1fe");
-//  }
-
-  /* For the specified class, check that each method has a stackmap attribute */
-  private void checkStackMapExistence(String classname,String toIgnore) throws ClassNotFoundException {
-	  toIgnore="_"+(toIgnore==null?"":toIgnore)+"_";
-	  JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),classname);
-	  Method[] methods = jc.getMethods();
-	  for (int i = 0; i < methods.length; i++) {
-		Method method = methods[i];
-		if (toIgnore.contains("_"+method.getName()+"_")) continue;
-		boolean hasStackMapAttribute = findAttribute(method.getAttributes(),"StackMapTable");
-		if (!hasStackMapAttribute) fail("Could not find StackMap attribute for method "+method.getName());
-	}
-  }
-  
-  private boolean findAttribute(Attribute[] attrs,String attributeName) {
-	  if (attrs==null) return false;
-	  for (int i = 0; i < attrs.length; i++) {
-		Attribute attribute = attrs[i];
-		if (attribute.getName().equals(attributeName)) return true;
-		//System.out.println(attribute.getName());
-		if (attribute.getName().equals("Code")) {
-			Code c = (Code)attribute;
-			Attribute[] codeAttributes = c.getAttributes();
-			for (int j = 0; j < codeAttributes.length; j++) {
-				Attribute codeAttribute = codeAttributes[j];
-				if (codeAttribute.getName().equals(attributeName)) return true;
-				//System.out.println(codeAttribute.getName());
+	// Incredibly trivial test programs that check the compiler works at all (these are easy-ish to debug)
+	public void testSimpleJava_A() {
+		runTest("simple - a");
+	}
+
+	public void testSimpleJava_B() {
+		runTest("simple - b");
+	}
+
+	public void testSimpleCode_C() {
+		runTest("simple - c");
+	}
+
+	public void testSimpleCode_D() {
+		runTest("simple - d");
+	}
+
+	public void testSimpleCode_E() {
+		runTest("simple - e");
+	}
+
+	public void testSimpleCode_F() {
+		runTest("simple - f");
+	}
+
+	public void testSimpleCode_G() {
+		runTest("simple - g");
+	}
+
+	public void testSimpleCode_H() {
+		runTest("simple - h", true);
+	}
+
+	public void testSimpleCode_I() {
+		runTest("simple - i");
+	}
+
+	// Check the version number in the classfiles is correct when Java6 options specified
+	public void testVersionCorrect1() throws ClassNotFoundException {
+		runTest("simple - j");
+		checkVersion("A", 50, 0);
+	}
+
+	public void testVersionCorrect2() throws ClassNotFoundException {
+		runTest("simple - k");
+		checkVersion("A", 50, 0);
+	}
+
+	public void testVersionCorrect3() throws ClassNotFoundException {
+		runTest("simple - l");
+		checkVersion("A", 50, 0);
+	}
+
+	public void testVersionCorrect4() throws ClassNotFoundException {// check it is 49.0 when -1.5 is specified
+		runTest("simple - m");
+		checkVersion("A", 49, 0);
+	}
+
+	// Check the stackmap stuff appears for methods in a Java6 file
+	// public void testStackMapAttributesAppear() throws ClassNotFoundException {
+	// runTest("simple - n");
+	// checkStackMapExistence("A","<init>_<clinit>");
+	// checkStackMapExistence("X","<init>_<clinit>_ajc$pointcut$$complicatedPointcut$1fe");
+	// }
+
+	/* For the specified class, check that each method has a stackmap attribute */
+	private void checkStackMapExistence(String classname, String toIgnore) throws ClassNotFoundException {
+		toIgnore = "_" + (toIgnore == null ? "" : toIgnore) + "_";
+		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(), classname);
+		Method[] methods = jc.getMethods();
+		for (int i = 0; i < methods.length; i++) {
+			Method method = methods[i];
+			if (toIgnore.contains("_" + method.getName() + "_")) {
+				continue;
+			}
+			boolean hasStackMapAttribute = findAttribute(method.getAttributes(), "StackMapTable");
+			if (!hasStackMapAttribute) {
+				fail("Could not find StackMap attribute for method " + method.getName());
+			}
+		}
+	}
+
+	private boolean findAttribute(Attribute[] attrs, String attributeName) {
+		if (attrs == null) {
+			return false;
+		}
+		for (int i = 0; i < attrs.length; i++) {
+			Attribute attribute = attrs[i];
+			if (attribute.getName().equals(attributeName)) {
+				return true;
+			}
+			// System.out.println(attribute.getName());
+			if (attribute.getName().equals("Code")) {
+				Code c = (Code) attribute;
+				Attribute[] codeAttributes = c.getAttributes();
+				for (int j = 0; j < codeAttributes.length; j++) {
+					Attribute codeAttribute = codeAttributes[j];
+					if (codeAttribute.getName().equals(attributeName)) {
+						return true;
+						// System.out.println(codeAttribute.getName());
+					}
+				}
 			}
 		}
-	  }
-	  return false;
-  }
-  
-  private void checkVersion(String classname,int major,int minor) throws ClassNotFoundException {
-      JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),classname);
-      if (jc.getMajor()!=major) fail("Expected major version to be "+major+" but was "+jc.getMajor());
-      if (jc.getMinor()!=minor) fail("Expected minor version to be "+minor+" but was "+jc.getMinor());
-  }
-  
-  // Check the stackmap stuff is removed when a method gets woven (for now...)
-//  public void testStackMapAttributesDeletedInWovenCode() {
-//	  fail("Not implemented");
-//  }
-  
-
-  /////////////////////////////////////////
-  public SyntheticRepository createRepos(File cpentry) {
-	ClassPath cp = new ClassPath(cpentry+File.pathSeparator+System.getProperty("java.class.path"));
-	return SyntheticRepository.getInstance(cp);
-  }
-  
-  protected JavaClass getClassFrom(File where,String clazzname) throws ClassNotFoundException {
-	SyntheticRepository repos = createRepos(where);
-	return repos.loadClass(clazzname);
-  }
-
-  /////////////////////////////////////////
-  public static Test suite() {
-    return XMLBasedAjcTestCase.loadSuite(SanityTests.class);
-  }
-
-  protected File getSpecFile() {
-    return new File("../tests/src/org/aspectj/systemtest/ajc160/sanity-tests.xml");
-  }
-
-  
+		return false;
+	}
+
+	private void checkVersion(String classname, int major, int minor) throws ClassNotFoundException {
+		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(), classname);
+		if (jc.getMajor() != major) {
+			fail("Expected major version to be " + major + " but was " + jc.getMajor());
+		}
+		if (jc.getMinor() != minor) {
+			fail("Expected minor version to be " + minor + " but was " + jc.getMinor());
+		}
+	}
+
+	// Check the stackmap stuff is removed when a method gets woven (for now...)
+	// public void testStackMapAttributesDeletedInWovenCode() {
+	// fail("Not implemented");
+	// }
+
+	// ///////////////////////////////////////
+	public SyntheticRepository createRepos(File cpentry) {
+		ClassPath cp = new ClassPath(cpentry + File.pathSeparator + System.getProperty("java.class.path"));
+		return SyntheticRepository.getInstance(cp);
+	}
+
+	protected JavaClass getClassFrom(File where, String clazzname) throws ClassNotFoundException {
+		SyntheticRepository repos = createRepos(where);
+		return repos.loadClass(clazzname);
+	}
+
+	// ///////////////////////////////////////
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(SanityTests.class);
+	}
+
+	protected File getSpecFile() {
+		return new File("../tests/src/org/aspectj/systemtest/ajc160/sanity-tests.xml");
+	}
+
 }
@@ -18,6 +18,24 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc169Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testClassFileSize_312839_1() {
+		runTest("class file size - 1");
+		// 2531 (0x404): 1.6.9.M2 size of Class.class
+		// 2494 (0x3DF): first little stab, compressing aspectnames attached to type mungers
+		// 2370 (0x363): changed read/write sourcelocation to write path rather than File object:
+		// 2358 (0x357): aspects affecting type compressed (weaverstate reweavable info)
+		// 2102 (0x257): changed read/write sourcelocation in type munger to NOT use object streams
+		// 2053 (0x1EF): changed path in sourcelocation read/write to be constant pool (so shared between both mungers)
+		// 2019: changed resolvedMemberImpl name/signature to be compressed refs
+		// 1954 (0x18C)
+
+		// Aspect size (X.class) down from 6459 to 4722
+		// 4551: changed exact type pattern writing to use constant pool, and
+		// changed typepatternlist to not both writing/reading location
+		
+		// TODO actually test something :)
+	}
+
 	// control test - weaves everything
 	public void testScopingLTW_122460_1() {
 		runTest("scoping ltw - 1");
@@ -2,6 +2,15 @@
 
 <suite>
 
+  <ajc-test dir="bugs169/pr312839/one" title="class file size - 1">
+     <compile files="Class.java X.aj" options="-1.5"/>
+     <run class="com.wibble.foo.Class">
+       <stdout>
+         <line text="Hello Andy"/>
+       </stdout>
+     </run>
+  </ajc-test>
+  
   <ajc-test dir="bugs169/pr122460/one" title="scoping ltw - 3">
      <compile files="A.java" options="-1.5 -Xlint:ignore" outjar="aspects.jar"/>
      <compile files="Code.java Runner.java"/>
@@ -482,7 +482,8 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		alter(p, "inc1");
 		build(p);
 		// error is: inter-type declaration from X conflicts with existing member: void A.<init>()
-		List ms = getErrorMessages(p);
+		// List ms =
+		getErrorMessages(p);
 		assertEquals(4, getErrorMessages(p).size());
 		// Why 4 errors? I believe the problem is:
 		// 2 errors are reported when there is a clash - one against the aspect, one against the affected target type.
@@ -81,12 +81,13 @@ public class AndOrNotTestCase extends PatternsTestCase {
 	private void checkSerialization(String string) throws IOException {
 		Pointcut p = makePointcut(string);
 		ByteArrayOutputStream bo = new ByteArrayOutputStream();
-		CompressingDataOutputStream out = new CompressingDataOutputStream(bo);
+		ConstantPoolSimulator cps = new ConstantPoolSimulator();
+		CompressingDataOutputStream out = new CompressingDataOutputStream(bo, cps);
 		p.write(out);
 		out.close();
 
 		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
-		VersionedDataInputStream in = new VersionedDataInputStream(bi);
+		VersionedDataInputStream in = new VersionedDataInputStream(bi, cps);
 		Pointcut newP = Pointcut.read(in, null);
 
 		assertEquals("write/read", p, newP);
@@ -0,0 +1,35 @@
+/*******************************************************************************
+ * Copyright (c) 2010 Contributors
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     Andy Clement (SpringSource) - initial implementation
+ *******************************************************************************/
+package org.aspectj.weaver.patterns;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.aspectj.weaver.ConstantPoolReader;
+import org.aspectj.weaver.ConstantPoolWriter;
+
+public class ConstantPoolSimulator implements ConstantPoolWriter, ConstantPoolReader {
+	List<String> list = new ArrayList<String>();
+
+	public int writeUtf8(String string) {
+		int i = list.indexOf(string);
+		if (i != -1) {
+			return i;
+		}
+		list.add(string);
+		return list.indexOf(string);
+	}
+
+	public String readUtf8(int constantPoolIndex) {
+		return list.get(constantPoolIndex);
+	}
+
+}
\ No newline at end of file
@@ -50,12 +50,13 @@ public class DeclareErrorOrWarningTestCase extends TestCase {
 
 	private void checkSerialization(Declare declare) throws IOException {
 		ByteArrayOutputStream bo = new ByteArrayOutputStream();
-		CompressingDataOutputStream out = new CompressingDataOutputStream(bo);
+		ConstantPoolSimulator cps = new ConstantPoolSimulator();
+		CompressingDataOutputStream out = new CompressingDataOutputStream(bo, cps);
 		declare.write(out);
 		out.close();
 
 		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
-		VersionedDataInputStream in = new VersionedDataInputStream(bi);
+		VersionedDataInputStream in = new VersionedDataInputStream(bi, cps);
 		Declare newDeclare = Declare.read(in, null);
 
 		assertEquals("write/read", declare, newDeclare);
@@ -16,8 +16,12 @@ import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
 
 import org.aspectj.weaver.CompressingDataOutputStream;
+import org.aspectj.weaver.ConstantPoolReader;
+import org.aspectj.weaver.ConstantPoolWriter;
 import org.aspectj.weaver.VersionedDataInputStream;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.reflect.ReflectionWorld;
@@ -91,12 +95,13 @@ public class ModifiersPatternTestCase extends PatternsTestCase {
 	private void checkSerialization(String string) throws IOException {
 		ModifiersPattern p = makeModifiersPattern(string);
 		ByteArrayOutputStream bo = new ByteArrayOutputStream();
-		CompressingDataOutputStream out = new CompressingDataOutputStream(bo);
+		ConstantPoolSimulator cps = new ConstantPoolSimulator();
+		CompressingDataOutputStream out = new CompressingDataOutputStream(bo, cps);
 		p.write(out);
 		out.close();
 
 		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
-		VersionedDataInputStream in = new VersionedDataInputStream(bi);
+		VersionedDataInputStream in = new VersionedDataInputStream(bi, cps);
 		ModifiersPattern newP = ModifiersPattern.read(in);
 
 		assertEquals("write/read", p, newP);
@@ -90,12 +90,13 @@ public class NamePatternTestCase extends TestCase {
 
 	private void checkSerialization(NamePattern p) throws IOException {
 		ByteArrayOutputStream bo = new ByteArrayOutputStream();
-		CompressingDataOutputStream out = new CompressingDataOutputStream(bo);
+		ConstantPoolSimulator cps = new ConstantPoolSimulator();
+		CompressingDataOutputStream out = new CompressingDataOutputStream(bo, cps);
 		p.write(out);
 		out.close();
 
 		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
-		VersionedDataInputStream in = new VersionedDataInputStream(bi);
+		VersionedDataInputStream in = new VersionedDataInputStream(bi, cps);
 		NamePattern newP = NamePattern.read(in);
 
 		assertEquals("write/read", p, newP);
@@ -152,12 +152,13 @@ public class SignaturePatternMatchSpeedTestCase extends PatternsTestCase {
 
 	private void checkSerialization(SignaturePattern p) throws IOException {
 		ByteArrayOutputStream bo = new ByteArrayOutputStream();
-		CompressingDataOutputStream out = new CompressingDataOutputStream(bo);
+		ConstantPoolSimulator cps = new ConstantPoolSimulator();
+		CompressingDataOutputStream out = new CompressingDataOutputStream(bo, cps);
 		p.write(out);
 		out.close();
 
 		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
-		VersionedDataInputStream in = new VersionedDataInputStream(bi);
+		VersionedDataInputStream in = new VersionedDataInputStream(bi, cps);
 		SignaturePattern newP = SignaturePattern.read(in, null);
 
 		assertEquals("write/read", p, newP);
@@ -16,7 +16,6 @@ package org.aspectj.weaver.patterns;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-
 import org.aspectj.weaver.CompressingDataOutputStream;
 import org.aspectj.weaver.Member;
 import org.aspectj.weaver.TestUtils;
@@ -171,12 +170,13 @@ public class SignaturePatternTestCase extends PatternsTestCase {
 
 	private void checkSerialization(SignaturePattern p) throws IOException {
 		ByteArrayOutputStream bo = new ByteArrayOutputStream();
-		CompressingDataOutputStream out = new CompressingDataOutputStream(bo);
+		ConstantPoolSimulator cps = new ConstantPoolSimulator();
+		CompressingDataOutputStream out = new CompressingDataOutputStream(bo, cps);
 		p.write(out);
 		out.close();
 
 		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
-		VersionedDataInputStream in = new VersionedDataInputStream(bi);
+		VersionedDataInputStream in = new VersionedDataInputStream(bi, cps);
 		SignaturePattern newP = SignaturePattern.read(in, null);
 
 		assertEquals("write/read", p, newP);
@@ -156,12 +156,13 @@ public class TypePatternListTestCase extends PatternsTestCase {
 	private void checkSerialization(String string) throws IOException {
 		TypePatternList p = makeArgumentsPattern(string);
 		ByteArrayOutputStream bo = new ByteArrayOutputStream();
-		CompressingDataOutputStream out = new CompressingDataOutputStream(bo);
+		ConstantPoolSimulator cps = new ConstantPoolSimulator();
+		CompressingDataOutputStream out = new CompressingDataOutputStream(bo, cps);
 		p.write(out);
 		out.close();
 
 		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
-		VersionedDataInputStream in = new VersionedDataInputStream(bi);
+		VersionedDataInputStream in = new VersionedDataInputStream(bi, cps);
 		TypePatternList newP = TypePatternList.read(in, null);
 
 		assertEquals("write/read", p, newP);
@@ -248,12 +248,13 @@ public class TypePatternTestCase extends PatternsTestCase {
 	private void checkSerialization(String string) throws IOException {
 		TypePattern p = makeTypePattern(string);
 		ByteArrayOutputStream bo = new ByteArrayOutputStream();
-		CompressingDataOutputStream out = new CompressingDataOutputStream(bo);
+		ConstantPoolSimulator cps = new ConstantPoolSimulator();
+		CompressingDataOutputStream out = new CompressingDataOutputStream(bo, cps);
 		p.write(out);
 		out.close();
 
 		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
-		VersionedDataInputStream in = new VersionedDataInputStream(bi);
+		VersionedDataInputStream in = new VersionedDataInputStream(bi, cps);
 		TypePattern newP = TypePattern.read(in, null);
 
 		assertEquals("write/read", p, newP);
@@ -15,7 +15,6 @@ package org.aspectj.weaver.patterns;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-
 import org.aspectj.util.FuzzyBoolean;
 import org.aspectj.weaver.CompressingDataOutputStream;
 import org.aspectj.weaver.IntMap;
@@ -107,12 +106,13 @@ public class WithinTestCase extends PatternsTestCase {
 
 	private void checkSerialization(Pointcut p) throws IOException {
 		ByteArrayOutputStream bo = new ByteArrayOutputStream();
-		CompressingDataOutputStream out = new CompressingDataOutputStream(bo);
+		ConstantPoolSimulator cps = new ConstantPoolSimulator();
+		CompressingDataOutputStream out = new CompressingDataOutputStream(bo, cps);
 		p.write(out);
 		out.close();
 
 		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
-		VersionedDataInputStream in = new VersionedDataInputStream(bi);
+		VersionedDataInputStream in = new VersionedDataInputStream(bi, cps);
 		Pointcut newP = Pointcut.read(in, null);
 
 		assertEquals("write/read", p, newP);
@@ -366,12 +366,33 @@ public abstract class AjAttribute {
 
 		@Override
 		public void write(CompressingDataOutputStream s) throws IOException {
-			s.writeUTF(sourceFileName);
-			FileUtil.writeIntArray(lineBreaks, s);
+			if (s.canCompress()) {
+				s.writeCompressedPath(sourceFileName);
+			} else {
+				s.writeUTF(sourceFileName);
+			}
+			s.writeInt(lineBreaks.length);
+			int previous = 0;
+			for (int i = 0, max = lineBreaks.length; i < max; i++) {
+				s.writeShort(lineBreaks[i] - previous);
+				previous = lineBreaks[i];
+			}
 		}
 
 		public static SourceContextAttribute read(VersionedDataInputStream s) throws IOException {
-			return new SourceContextAttribute(s.readUTF(), FileUtil.readIntArray(s));
+			String sourceFileName = s.isAtLeast169() ? s.readPath() : s.readUTF();
+			int lineBreaks = s.readInt();
+			int[] lines = new int[lineBreaks];
+			int previous = 0;
+			for (int i = 0; i < lineBreaks; i++) {
+				if (s.isAtLeast169()) {
+					lines[i] = s.readShort() + previous;
+					previous = lines[i];
+				} else {
+					lines[i] = s.readInt();
+				}
+			}
+			return new SourceContextAttribute(sourceFileName, lines);
 		}
 
 		public int[] getLineBreaks() {
@@ -32,10 +32,6 @@ public class CompressingDataOutputStream extends DataOutputStream {
 		this.constantPoolWriter = constantPoolWriter;
 	}
 
-	public CompressingDataOutputStream(ByteArrayOutputStream baos) {
-		super(baos);
-	}
-
 	public CompressingDataOutputStream(FileOutputStream fos) {
 		super(fos);
 	}
@@ -380,10 +380,28 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 
 	public void write(CompressingDataOutputStream s) throws IOException {
 		getKind().write(s);
-		getDeclaringType().write(s);
+		s.writeBoolean(s.canCompress()); // boolean indicates if parts of this are compressed references
+
+		// write out the signature of the declaring type of this member
+		if (s.canCompress()) {
+			s.writeCompressedSignature(getDeclaringType().getSignature());
+		} else {
+			getDeclaringType().write(s);
+		}
+
+		// write out the modifiers
 		s.writeInt(modifiers);
-		s.writeUTF(getName());
-		s.writeUTF(getSignature());
+
+		// write out the name and the signature of this member
+		if (s.canCompress()) {
+			s.writeCompressedName(getName());
+			s.writeCompressedSignature(getSignature());
+		} else {
+			s.writeUTF(getName());
+			s.writeUTF(getSignature());
+		}
+
+		// write out the array clauses
 		UnresolvedType.writeArray(getExceptions(), s);
 
 		s.writeInt(getStart());
@@ -392,24 +410,33 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 
 		// Write out any type variables...
 		if (typeVariables == null) {
-			s.writeInt(0);
+			s.writeByte(0);
 		} else {
-			s.writeInt(typeVariables.length);
+			s.writeByte(typeVariables.length);
 			for (int i = 0; i < typeVariables.length; i++) {
 				typeVariables[i].write(s);
 			}
 		}
 		String gsig = getGenericSignature();
+
+		// change this to a byte: 255=false 0>254 means true and encodes the number of parameters
 		if (getSignature().equals(gsig)) {
-			s.writeBoolean(false);
+			s.writeByte(0xff);
 		} else {
-			s.writeBoolean(true);
-			s.writeInt(parameterTypes.length);
+			s.writeByte(parameterTypes.length);
 			for (int i = 0; i < parameterTypes.length; i++) {
-				UnresolvedType array_element = parameterTypes[i];
-				array_element.write(s);
+				if (s.canCompress()) {
+					s.writeCompressedSignature(parameterTypes[i].getSignature());
+				} else {
+					UnresolvedType array_element = parameterTypes[i];
+					array_element.write(s);
+				}
+			}
+			if (s.canCompress()) {
+				s.writeCompressedSignature(returnType.getSignature());
+			} else {
+				returnType.write(s);
 			}
-			returnType.write(s);
 		}
 	}
 
@@ -469,8 +496,13 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 	public static ResolvedMemberImpl readResolvedMember(VersionedDataInputStream s, ISourceContext sourceContext)
 			throws IOException {
 
-		ResolvedMemberImpl m = new ResolvedMemberImpl(MemberKind.read(s), UnresolvedType.read(s), s.readInt(), s.readUTF(), s
-				.readUTF());
+		MemberKind mk = MemberKind.read(s);
+		boolean compressed = (s.isAtLeast169() ? s.readBoolean() : false);
+		UnresolvedType declaringType = compressed ? UnresolvedType.forSignature(s.readUtf8(s.readShort())) : UnresolvedType.read(s);
+		int modifiers = s.readInt();
+		String name = compressed ? s.readUtf8(s.readShort()) : s.readUTF();
+		String signature = compressed ? s.readUtf8(s.readShort()) : s.readUTF();
+		ResolvedMemberImpl m = new ResolvedMemberImpl(mk, declaringType, modifiers, name, signature);
 		m.checkedExceptions = UnresolvedType.readArray(s);
 
 		m.start = s.readInt();
@@ -486,7 +518,7 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 				}
 			}
 
-			int tvcount = s.readInt();
+			int tvcount = s.isAtLeast169() ? s.readByte() : s.readInt();
 			if (tvcount != 0) {
 				m.typeVariables = new TypeVariable[tvcount];
 				for (int i = 0; i < tvcount; i++) {
@@ -495,14 +527,26 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 				}
 			}
 			if (s.getMajorVersion() >= AjAttribute.WeaverVersionInfo.WEAVER_VERSION_MAJOR_AJ150M4) {
-				boolean hasAGenericSignature = s.readBoolean();
+				int pcount = -1;
+				boolean hasAGenericSignature = false;
+				if (s.isAtLeast169()) {
+					pcount = s.readByte();
+					hasAGenericSignature = (pcount >= 0 && pcount < 255);
+				} else {
+					hasAGenericSignature = s.readBoolean();
+				}
 				if (hasAGenericSignature) {
-					int ps = s.readInt();
+					int ps = (s.isAtLeast169() ? pcount : s.readInt());
 					UnresolvedType[] params = new UnresolvedType[ps];
 					for (int i = 0; i < params.length; i++) {
-						params[i] = TypeFactory.createTypeFromSignature(s.readUTF());
+						if (compressed) {
+							params[i] = TypeFactory.createTypeFromSignature(s.readSignature());
+						} else {
+							params[i] = TypeFactory.createTypeFromSignature(s.readUTF());
+						}
 					}
-					UnresolvedType rt = TypeFactory.createTypeFromSignature(s.readUTF());
+					UnresolvedType rt = compressed ? TypeFactory.createTypeFromSignature(s.readSignature()) : TypeFactory
+							.createTypeFromSignature(s.readUTF());
 					m.parameterTypes = params;
 					m.returnType = rt;
 				}
@@ -167,7 +167,12 @@ public abstract class ResolvedTypeMunger {
 
 	protected static Set<ResolvedMember> readSuperMethodsCalled(VersionedDataInputStream s) throws IOException {
 		Set<ResolvedMember> ret = new HashSet<ResolvedMember>();
-		int n = s.readInt();
+		int n = -1;
+		if (s.isAtLeast169()) {
+			n = s.readByte();
+		} else {
+			n = s.readInt();
+		}
 		if (n < 0) {
 			throw new BCException("Problem deserializing type munger");
 		}
@@ -177,21 +182,18 @@ public abstract class ResolvedTypeMunger {
 		return ret;
 	}
 
-	protected void writeSuperMethodsCalled(CompressingDataOutputStream s) throws IOException {
-
+	protected final void writeSuperMethodsCalled(CompressingDataOutputStream s) throws IOException {
 		if (superMethodsCalled == null || superMethodsCalled.size() == 0) {
-			s.writeInt(0);
+			s.writeByte(0);
 			return;
 		}
-
 		List<ResolvedMember> ret = new ArrayList<ResolvedMember>(superMethodsCalled);
 		Collections.sort(ret);
 		int n = ret.size();
-		s.writeInt(n);
+		s.writeByte(n);
 		for (ResolvedMember m : ret) {
 			m.write(s);
 		}
-
 	}
 
 	protected static ISourceLocation readSourceLocation(VersionedDataInputStream s) throws IOException {
@@ -204,15 +206,29 @@ public abstract class ResolvedTypeMunger {
 		try {
 			// This logic copes with the location missing from the attribute - an EOFException will
 			// occur on the next line and we ignore it.
-			ois = new ObjectInputStream(s);
-			Boolean validLocation = (Boolean) ois.readObject();
-			if (validLocation.booleanValue()) {
-				File f = (File) ois.readObject();
-				Integer ii = (Integer) ois.readObject();
-				Integer offset = (Integer) ois.readObject();
-				ret = new SourceLocation(f, ii.intValue());
-				ret.setOffset(offset.intValue());
+			byte b = 0;
+			// if we aren't on 1.6.9 or we are on 1.6.9 but not compressed, then read as object stream
+			if (!s.isAtLeast169() || (b = s.readByte()) == 0) {
+				ois = new ObjectInputStream(s);
+				boolean validLocation = (Boolean) ois.readObject();
+				if (validLocation) {
+					File f = (File) ois.readObject();
+					Integer ii = (Integer) ois.readObject();
+					Integer offset = (Integer) ois.readObject();
+					ret = new SourceLocation(f, ii.intValue());
+					ret.setOffset(offset.intValue());
+				}
+			} else {
+				boolean validLocation = b == 2;
+				if (validLocation) {
+					String path = s.readUtf8(s.readShort());
+					File f = new File(path);
+					ret = new SourceLocation(f, s.readInt());
+					int offset = s.readInt();
+					ret.setOffset(offset);
+				}
 			}
+
 		} catch (EOFException eof) {
 			return null; // This exception occurs if processing an 'old style' file where the
 			// type munger attributes don't include the source location.
@@ -230,17 +246,26 @@ public abstract class ResolvedTypeMunger {
 		return ret;
 	}
 
-	protected void writeSourceLocation(DataOutputStream s) throws IOException {
-		ObjectOutputStream oos = new ObjectOutputStream(s);
-		// oos.writeObject(location);
-		oos.writeObject(new Boolean(location != null));
-		if (location != null) {
-			oos.writeObject(location.getSourceFile());
-			oos.writeObject(new Integer(location.getLine()));
-			oos.writeObject(new Integer(location.getOffset()));
+	protected final void writeSourceLocation(CompressingDataOutputStream s) throws IOException {
+		if (s.canCompress()) {
+			s.writeByte(1 + (location == null ? 0 : 1)); // 1==compressed no location 2==compressed with location
+			if (location != null) {
+				s.writeCompressedPath(location.getSourceFile().getPath());
+				s.writeInt(location.getLine());
+				s.writeInt(location.getOffset());
+			}
+		} else {
+			s.writeByte(0);
+			ObjectOutputStream oos = new ObjectOutputStream(s);
+			oos.writeObject(new Boolean(location != null));
+			if (location != null) {
+				oos.writeObject(location.getSourceFile());
+				oos.writeObject(new Integer(location.getLine()));
+				oos.writeObject(new Integer(location.getOffset()));
+			}
+			oos.flush();
+			oos.close();
 		}
-		oos.flush();
-		oos.close();
 	}
 
 	public abstract void write(CompressingDataOutputStream s) throws IOException;
@@ -346,7 +371,12 @@ public abstract class ResolvedTypeMunger {
 
 	protected static List<String> readInTypeAliases(VersionedDataInputStream s) throws IOException {
 		if (s.getMajorVersion() >= AjAttribute.WeaverVersionInfo.WEAVER_VERSION_MAJOR_AJ150) {
-			int count = s.readInt();
+			int count = -1;
+			if (s.isAtLeast169()) {
+				count = s.readByte();
+			} else {
+				count = s.readInt();
+			}
 			if (count != 0) {
 				List<String> aliases = new ArrayList<String>();
 				for (int i = 0; i < count; i++) {
@@ -358,12 +388,12 @@ public abstract class ResolvedTypeMunger {
 		return null;
 	}
 
-	protected void writeOutTypeAliases(DataOutputStream s) throws IOException {
+	protected final void writeOutTypeAliases(DataOutputStream s) throws IOException {
 		// Write any type variable aliases
 		if (typeVariableAliases == null || typeVariableAliases.size() == 0) {
-			s.writeInt(0);
+			s.writeByte(0);
 		} else {
-			s.writeInt(typeVariableAliases.size());
+			s.writeByte(typeVariableAliases.size());
 			for (String element : typeVariableAliases) {
 				s.writeUTF(element);
 			}
@@ -30,10 +30,6 @@ public class VersionedDataInputStream extends DataInputStream {
 
 	private ConstantPoolReader constantPoolReader;
 
-	public VersionedDataInputStream(InputStream is) {
-		super(is);
-	}
-
 	public VersionedDataInputStream(InputStream is, ConstantPoolReader constantPoolReader) {
 		super(is);
 		this.constantPoolReader = constantPoolReader;
@@ -80,4 +76,8 @@ public class VersionedDataInputStream extends DataInputStream {
 	public String readSignature() throws IOException {
 		return readUtf8(readShort());
 	}
+
+	public UnresolvedType readSignatureAsUnresolvedType() throws IOException {
+		return UnresolvedType.forSignature(readUtf8(readShort()));
+	}
 }
\ No newline at end of file
@@ -246,7 +246,7 @@ public class ExactTypePattern extends TypePattern {
 	public void write(CompressingDataOutputStream out) throws IOException {
 		out.writeByte(TypePattern.EXACT);
 		out.writeByte(EXACT_VERSION);
-		type.write(out);
+		out.writeCompressedSignature(type.getSignature());
 		out.writeBoolean(includeSubtypes);
 		out.writeBoolean(isVarArgs);
 		annotationPattern.write(out);
@@ -267,7 +267,8 @@ public class ExactTypePattern extends TypePattern {
 		if (version > EXACT_VERSION) {
 			throw new BCException("ExactTypePattern was written by a more recent version of AspectJ");
 		}
-		TypePattern ret = new ExactTypePattern(UnresolvedType.read(s), s.readBoolean(), s.readBoolean());
+		TypePattern ret = new ExactTypePattern(s.isAtLeast169() ? s.readSignatureAsUnresolvedType() : UnresolvedType.read(s), s
+				.readBoolean(), s.readBoolean());
 		ret.setAnnotationTypePattern(AnnotationTypePattern.read(s, context));
 		ret.setTypeParameters(TypePatternList.read(s, context));
 		ret.readLocation(context, s);
@@ -18,6 +18,7 @@ import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 
+import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.util.FuzzyBoolean;
 import org.aspectj.weaver.CompressingDataOutputStream;
 import org.aspectj.weaver.ISourceContext;
@@ -492,17 +493,39 @@ public class TypePatternList extends PatternNode {
 			arguments[i] = TypePattern.read(s, context);
 		}
 		TypePatternList ret = new TypePatternList(arguments);
-		ret.readLocation(context, s);
+		if (!s.isAtLeast169()) {
+			ret.readLocation(context, s);
+		}
 		return ret;
 	}
 
 	@Override
+	public int getEnd() {
+		throw new IllegalStateException();
+	}
+
+	@Override
+	public ISourceContext getSourceContext() {
+		throw new IllegalStateException();
+	}
+
+	@Override
+	public ISourceLocation getSourceLocation() {
+		throw new IllegalStateException();
+	}
+
+	@Override
+	public int getStart() {
+		throw new IllegalStateException();
+	}
+
+	@Override
 	public void write(CompressingDataOutputStream s) throws IOException {
 		s.writeShort(typePatterns.length);
 		for (int i = 0; i < typePatterns.length; i++) {
 			typePatterns[i].write(s);
 		}
-		writeLocation(s);
+		// writeLocation(s);
 	}
 
 	public TypePattern[] getTypePatterns() {
@@ -434,7 +434,7 @@ class BcelClassWeaver implements IClassWeaver {
 			if (typeMungerAffectedType) {
 				isChanged = true;
 				if (inReweavableMode || clazz.getType().isAspect()) {
-					aspectsAffectingType.add(munger.getAspectType().getName());
+					aspectsAffectingType.add(munger.getAspectType().getSignature());
 				}
 			}
 		}
@@ -510,7 +510,7 @@ class BcelClassWeaver implements IClassWeaver {
 					if (typeMungerAffectedType) {
 						isChanged = true;
 						if (inReweavableMode || clazz.getType().isAspect()) {
-							aspectsAffectingType.add(munger.getAspectType().getName());
+							aspectsAffectingType.add(munger.getAspectType().getSignature());
 						}
 					}
 				}
@@ -1512,7 +1512,7 @@ class BcelClassWeaver implements IClassWeaver {
 				if (munger instanceof BcelAdvice) {
 					BcelAdvice bcelAdvice = (BcelAdvice) munger;
 					if (bcelAdvice.getConcreteAspect() != null) {
-						aspectsAffectingType.add(bcelAdvice.getConcreteAspect().getName());
+						aspectsAffectingType.add(bcelAdvice.getConcreteAspect().getSignature());
 					}
 				} else {
 					// It is a 'Checker' - we don't need to remember aspects
@@ -1319,42 +1319,40 @@ public class BcelWeaver {
 			// are around!
 			world.showMessage(IMessage.INFO, WeaverMessages.format(WeaverMessages.PROCESSING_REWEAVABLE, className, classType
 					.getSourceLocation().getSourceFile()), null, null);
-			Set aspectsPreviouslyInWorld = wsi.getAspectsAffectingType();
-			if (aspectsPreviouslyInWorld != null) {
-				// keep track of them just to ensure unique missing aspect error
-				// reporting
-				Set<String> alreadyConfirmedReweavableState = new HashSet<String>();
-				for (Iterator iter = aspectsPreviouslyInWorld.iterator(); iter.hasNext();) {
-					String requiredTypeName = (String) iter.next();
-					if (!alreadyConfirmedReweavableState.contains(requiredTypeName)) {
-						ResolvedType rtx = world.resolve(UnresolvedType.forName(requiredTypeName), true);
-						boolean exists = !rtx.isMissing();
-						if (!exists) {
-							world.getLint().missingAspectForReweaving.signal(new String[] { requiredTypeName, className },
-									classType.getSourceLocation(), null);
-							// world.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.MISSING_REWEAVABLE_TYPE,
-							// requiredTypeName, className), classType.getSourceLocation(), null);
+			Set<String> aspectsPreviouslyInWorld = wsi.getAspectsAffectingType();
+			// keep track of them just to ensure unique missing aspect error
+			// reporting
+			Set<String> alreadyConfirmedReweavableState = new HashSet<String>();
+			for (String requiredTypeSignature : aspectsPreviouslyInWorld) {
+				// for (Iterator iter = aspectsPreviouslyInWorld.iterator(); iter.hasNext();) {
+				// String requiredTypeName = (String) iter.next();
+				if (!alreadyConfirmedReweavableState.contains(requiredTypeSignature)) {
+					ResolvedType rtx = world.resolve(UnresolvedType.forSignature(requiredTypeSignature), true);
+					boolean exists = !rtx.isMissing();
+					if (!exists) {
+						world.getLint().missingAspectForReweaving.signal(new String[] { rtx.getName(), className }, classType
+								.getSourceLocation(), null);
+						// world.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.MISSING_REWEAVABLE_TYPE,
+						// requiredTypeName, className), classType.getSourceLocation(), null);
+					} else {
+						if (world.isOverWeaving()) {
+							// System.out.println(">> Removing " + requiredTypeName + " from weaving process: "
+							// + xcutSet.deleteAspect(rtx));
 						} else {
-							if (world.isOverWeaving()) {
-								// System.out.println(">> Removing " + requiredTypeName + " from weaving process: "
-								// + xcutSet.deleteAspect(rtx));
-							} else {
-								// weaved in aspect that are not declared in aop.xml
-								// trigger an error for now
-								// may cause headhache for LTW and packaged lib
-								// without aop.xml in
-								// see #104218
-								if (!xcutSet.containsAspect(rtx)) {
-									world.showMessage(IMessage.ERROR, WeaverMessages.format(
-											WeaverMessages.REWEAVABLE_ASPECT_NOT_REGISTERED, requiredTypeName, className), null,
-											null);
-								} else if (!world.getMessageHandler().isIgnoring(IMessage.INFO)) {
-									world.showMessage(IMessage.INFO, WeaverMessages.format(WeaverMessages.VERIFIED_REWEAVABLE_TYPE,
-											requiredTypeName, rtx.getSourceLocation().getSourceFile()), null, null);
-								}
+							// weaved in aspect that are not declared in aop.xml
+							// trigger an error for now
+							// may cause headhache for LTW and packaged lib
+							// without aop.xml in
+							// see #104218
+							if (!xcutSet.containsAspect(rtx)) {
+								world.showMessage(IMessage.ERROR, WeaverMessages.format(
+										WeaverMessages.REWEAVABLE_ASPECT_NOT_REGISTERED, rtx.getName(), className), null, null);
+							} else if (!world.getMessageHandler().isIgnoring(IMessage.INFO)) {
+								world.showMessage(IMessage.INFO, WeaverMessages.format(WeaverMessages.VERIFIED_REWEAVABLE_TYPE, rtx
+										.getName(), rtx.getSourceLocation().getSourceFile()), null, null);
 							}
-							alreadyConfirmedReweavableState.add(requiredTypeName);
 						}
+						alreadyConfirmedReweavableState.add(requiredTypeSignature);
 					}
 				}
 			}
@@ -21,7 +21,6 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 import java.util.zip.ZipEntry;
@@ -39,16 +38,18 @@ import org.aspectj.bridge.IMessage;
  * previously woven <String> The fully qualified name of each type Int: Length of class file data (i.e. the unwovenclassfile)
  * Byte[]: The class file data, compressed if REWEAVABLE_COMPRESSION_BIT set.
  */
-
 public class WeaverStateInfo {
-	private List/* Entry */typeMungers;
+	private List<Entry> typeMungers;
 	private boolean oldStyle;
 
 	private boolean reweavable;
 	private boolean reweavableCompressedMode; // If true, unwovenClassFile is uncompressed on read
 	private boolean reweavableDiffMode; // if true, unwovenClassFile is written and read as a diff
 
-	private Set<String> aspectsAffectingType; // These must exist in the world for reweaving to be valid
+	// These must exist in the world for reweaving to be valid.
+	// It is a set of signatures 'La/b/c/D;'
+	private Set<String> aspectsAffectingType;
+
 	private byte[] unwovenClassFile; // Original 'untouched' class file
 	private static boolean reweavableDefault = true; // ajh02: changed from false;
 	private static boolean reweavableCompressedModeDefault = false;
@@ -67,17 +68,17 @@ public class WeaverStateInfo {
 	}
 
 	public WeaverStateInfo(boolean reweavable) {
-		this(new ArrayList(), false, reweavable, reweavableCompressedModeDefault, reweavableDiffModeDefault);
+		this(new ArrayList<Entry>(), false, reweavable, reweavableCompressedModeDefault, reweavableDiffModeDefault);
 	}
 
-	private WeaverStateInfo(List typeMungers, boolean oldStyle, boolean reweavableMode, boolean reweavableCompressedMode,
+	private WeaverStateInfo(List<Entry> typeMungers, boolean oldStyle, boolean reweavableMode, boolean reweavableCompressedMode,
 			boolean reweavableDiffMode) {
 		this.typeMungers = typeMungers;
 		this.oldStyle = oldStyle;
 		this.reweavable = reweavableMode;
 		this.reweavableCompressedMode = reweavableCompressedMode;
 		this.reweavableDiffMode = reweavableMode ? reweavableDiffMode : false;
-		this.aspectsAffectingType = new HashSet();
+		this.aspectsAffectingType = new HashSet<String>();
 		this.unwovenClassFile = null;
 	}
 
@@ -119,15 +120,32 @@ public class WeaverStateInfo {
 		case WOVEN:
 			return new WeaverStateInfo(Collections.EMPTY_LIST, true, isReweavable, isReweavableCompressed, isReweavableDiff);
 		case EXTENDED:
+			boolean isCompressed = false;
+			if (s.isAtLeast169()) {
+				isCompressed = s.readBoolean();
+			}
+
 			int n = s.readShort();
 			List l = new ArrayList();
 			for (int i = 0; i < n; i++) {
-				UnresolvedType aspectType = UnresolvedType.read(s);
+				// conditional on version
+				UnresolvedType aspectType = null;
+				if (isCompressed) {
+					int cpIndex = s.readShort();
+					String signature = s.readUtf8(cpIndex);
+					if (signature.charAt(0) == '@') { // '@missing@'
+						aspectType = ResolvedType.MISSING;
+					} else {
+						aspectType = UnresolvedType.forSignature(signature);
+					}
+				} else {
+					aspectType = UnresolvedType.read(s);
+				}
 				ResolvedTypeMunger typeMunger = ResolvedTypeMunger.read(s, context);
 				l.add(new Entry(aspectType, typeMunger));
 			}
 			WeaverStateInfo wsi = new WeaverStateInfo(l, false, isReweavable, isReweavableCompressed, isReweavableDiff);
-			readAnyReweavableData(wsi, s);
+			readAnyReweavableData(wsi, s, isCompressed);
 			return wsi;
 		}
 		throw new RuntimeException("bad WeaverState.Kind: " + b + ".  File was :"
@@ -171,14 +189,20 @@ public class WeaverStateInfo {
 
 		s.writeByte(weaverStateInfoKind);
 
+		// Tag whether the remainder of the data is subject to cp compression
+		s.writeBoolean(s.canCompress());
+
 		int n = typeMungers.size();
 		s.writeShort(n);
-		for (int i = 0; i < n; i++) {
-			Entry e = (Entry) typeMungers.get(i);
-			e.aspectType.write(s);
+		for (Entry e : typeMungers) {
+			if (s.canCompress()) {
+				s.writeCompressedSignature(e.aspectType.getSignature());
+			} else {
+				e.aspectType.write(s);
+			}
 			e.typeMunger.write(s);
 		}
-		writeAnyReweavableData(this, s);
+		writeAnyReweavableData(this, s, s.canCompress());
 	}
 
 	public void addConcreteMunger(ConcreteTypeMunger munger) {
@@ -192,8 +216,7 @@ public class WeaverStateInfo {
 	public List getTypeMungers(ResolvedType onType) {
 		World world = onType.getWorld();
 		List ret = new ArrayList();
-		for (Iterator i = typeMungers.iterator(); i.hasNext();) {
-			Entry entry = (Entry) i.next();
+		for (Entry entry : typeMungers) {
 			ResolvedType aspectType = world.resolve(entry.aspectType, true);
 			if (aspectType.isMissing()) {
 				world.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.ASPECT_NEEDED, entry.aspectType, onType),
@@ -230,24 +253,34 @@ public class WeaverStateInfo {
 		reweavable = rw;
 	}
 
-	public void addAspectsAffectingType(Collection /* String */aspects) {
+	public void addAspectsAffectingType(Collection<String> aspects) {
 		aspectsAffectingType.addAll(aspects);
 	}
 
-	public void addAspectAffectingType(String aspectType) {
-		aspectsAffectingType.add(aspectType);
+	public void addAspectAffectingType(String aspectSignature) {
+		aspectsAffectingType.add(aspectSignature);
 	}
 
-	public Set /* String */getAspectsAffectingType() {
+	public Set<String> getAspectsAffectingType() {
 		return this.aspectsAffectingType;
 	}
 
-	private static void readAnyReweavableData(WeaverStateInfo wsi, DataInputStream s) throws IOException {
+	private static void readAnyReweavableData(WeaverStateInfo wsi, VersionedDataInputStream s, boolean compressed)
+			throws IOException {
 		if (wsi.isReweavable()) {
 			// Load list of aspects that need to exist in the world for reweaving to be 'legal'
 			int numberAspectsAffectingType = s.readShort();
 			for (int i = 0; i < numberAspectsAffectingType; i++) {
-				wsi.addAspectAffectingType(s.readUTF());
+				String str = null;
+				if (compressed) {
+					str = s.readSignature();
+				} else {
+					str = s.readUTF();
+					StringBuilder sb = new StringBuilder();
+					sb.append("L").append(str.replace('.', '/')).append(";");
+					str = sb.toString();
+				}
+				wsi.addAspectAffectingType(str);
 			}
 
 			int unwovenClassFileSize = s.readInt();
@@ -457,18 +490,19 @@ public class WeaverStateInfo {
 		return bos.toByteArray();
 	}
 
-	private static void writeAnyReweavableData(WeaverStateInfo wsi, DataOutputStream s) throws IOException {
+	private static void writeAnyReweavableData(WeaverStateInfo wsi, CompressingDataOutputStream s, boolean compress)
+			throws IOException {
 		if (wsi.isReweavable()) {
 			// Write out list of aspects that must exist next time we try and weave this class
 			s.writeShort(wsi.aspectsAffectingType.size());
-			if (wsi.aspectsAffectingType.size() > 0) {
-				for (Iterator iter = wsi.aspectsAffectingType.iterator(); iter.hasNext();) {
-					String type = (String) iter.next();
+			for (String type : wsi.aspectsAffectingType) {
+				if (compress) {
+					s.writeCompressedSignature(type);
+				} else {
 					s.writeUTF(type);
 				}
 			}
 			byte[] data = wsi.unwovenClassFile;
-
 			// if we're not in diffMode, write the unwovenClassFile now,
 			// otherwise we'll insert it as a diff later
 			if (!wsi.reweavableDiffMode) {
@@ -482,9 +516,9 @@ public class WeaverStateInfo {
 	 * @return true if the supplied aspect is already in the list of those affecting this type
 	 */
 	public boolean isAspectAlreadyApplied(ResolvedType someAspect) {
-		String someAspectName = someAspect.getName();
-		for (String aspect : aspectsAffectingType) {
-			if (aspect.equals(someAspectName)) {
+		String someAspectSignature = someAspect.getSignature();
+		for (String aspectSignature : aspectsAffectingType) {
+			if (aspectSignature.equals(someAspectSignature)) {
 				return true;
 			}
 		}
@@ -55,7 +55,7 @@ public class VersionedDataInputStream extends DataInputStream {
 		this.version = version;
 	}
 
-	public String accessUtf8(int cpIndex) {
+	public String readUtf8(int cpIndex) {
 		if (constantPoolReader == null) {
 			throw new IllegalStateException();
 		}
@@ -74,10 +74,10 @@ public class VersionedDataInputStream extends DataInputStream {
 	}
 
 	public String readPath() throws IOException {
-		return accessUtf8(readShort());
+		return readUtf8(readShort());
 	}
-	
+
 	public String readSignature() throws IOException {
-		return accessUtf8(readShort());
+		return readUtf8(readShort());
 	}
 }
\ No newline at end of file
Binary files differ
Binary files differ
@@ -0,0 +1,101 @@
+/* *******************************************************************
+ * Copyright (c) 2010 Contributors
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ * 
+ * Contributors:
+ * Andy Clement (SpringSource)
+ * ******************************************************************/
+package org.aspectj.weaver;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+
+/**
+ * A variation of a DataOutputStream that is linked to a constant pool writer. The linked constant pool can be used to compress
+ * objects into to simple index references into the constant pool. The corresponding decompression is done in the
+ * VersionedDataInputStream.
+ * 
+ * @author Andy Clement
+ */
+public class CompressingDataOutputStream extends DataOutputStream {
+
+	private ConstantPoolWriter constantPoolWriter;
+
+	public CompressingDataOutputStream(ByteArrayOutputStream baos, ConstantPoolWriter constantPoolWriter) {
+		super(baos);
+		this.constantPoolWriter = constantPoolWriter;
+	}
+
+	public CompressingDataOutputStream(ByteArrayOutputStream baos) {
+		super(baos);
+	}
+
+	public CompressingDataOutputStream(FileOutputStream fos) {
+		super(fos);
+	}
+
+	public boolean canCompress() {
+		return constantPoolWriter != null;
+	}
+
+	/**
+	 * @param signature of the form 'La/b/c/d;'
+	 * @return the constant pool index
+	 */
+	public int compressSignature(String signature) {
+		if (constantPoolWriter == null) {
+			throw new IllegalStateException();
+		}
+		return constantPoolWriter.writeUtf8(signature);
+	}
+
+	/**
+	 * @param filepath a file system path 'c:\a\b\c.txt' or '/a/b/c.txt'
+	 * @return the constant pool index
+	 */
+	public int compressFilepath(String filepath) {
+		if (constantPoolWriter == null) {
+			throw new IllegalStateException();
+		}
+		return constantPoolWriter.writeUtf8(filepath);
+	}
+
+	/**
+	 * @param name a simple name (for example a method or field name)
+	 * @return the constant pool index
+	 */
+	public int compressName(String name) {
+		if (constantPoolWriter == null) {
+			throw new IllegalStateException();
+		}
+		return constantPoolWriter.writeUtf8(name);
+	}
+
+	/**
+	 * @param name a simple name (for example a method or field name)
+	 */
+	public void writeCompressedName(String name) throws IOException {
+		writeShort(compressName(name));
+	}
+
+	/**
+	 * @param signature of the form 'La/b/c/d;'
+	 */
+	public void writeCompressedSignature(String signature) throws IOException {
+		writeShort(compressSignature(signature));
+	}
+
+	/**
+	 * @param path a file system path 'c:\a\b\c.txt' or '/a/b/c.txt'
+	 */
+	public void writeCompressedPath(String path) throws IOException {
+		writeShort(compressFilepath(path));
+	}
+
+}
\ No newline at end of file
@@ -0,0 +1,34 @@
+/* *******************************************************************
+ * Copyright (c) 2010 Contributors
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ * 
+ * Contributors:
+ * Andy Clement (SpringSource)
+ * ******************************************************************/
+package org.aspectj.ajdt.internal.compiler.ast;
+
+import org.aspectj.org.eclipse.jdt.internal.compiler.codegen.ConstantPool;
+import org.aspectj.weaver.ConstantPoolWriter;
+
+/**
+ * An implementation of the constant pool writer that speaks Eclipse.
+ * 
+ * @author Andy Clement
+ */
+public class EclipseConstantPoolWriter implements ConstantPoolWriter {
+
+	private ConstantPool constantPool;
+
+	public EclipseConstantPoolWriter(ConstantPool constantPool) {
+		this.constantPool = constantPool;
+	}
+
+	public int writeUtf8(String name) {
+		return constantPool.literalIndex(name.toCharArray());
+	}
+
+}
@@ -0,0 +1,34 @@
+/* *******************************************************************
+ * Copyright (c) 2010 Contributors
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ * 
+ * Contributors:
+ * Andy Clement (SpringSource)
+ * ******************************************************************/
+package org.aspectj.weaver.bcel;
+
+import org.aspectj.apache.bcel.classfile.ConstantPool;
+import org.aspectj.weaver.ConstantPoolReader;
+
+/**
+ * An implementation of the constant pool reader that speaks Bcel.
+ * 
+ * @author Andy Clement
+ */
+public class BcelConstantPoolReader implements ConstantPoolReader {
+
+	private ConstantPool constantPool;
+
+	public BcelConstantPoolReader(ConstantPool constantPool) {
+		this.constantPool = constantPool;
+	}
+
+	public String readUtf8(int cpIndex) {
+		return constantPool.getConstantUtf8(cpIndex).getValue();
+	}
+
+}
@@ -0,0 +1,34 @@
+/* *******************************************************************
+ * Copyright (c) 2010 Contributors
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ * 
+ * Contributors:
+ * Andy Clement (SpringSource)
+ * ******************************************************************/
+package org.aspectj.weaver.bcel;
+
+import org.aspectj.apache.bcel.classfile.ConstantPool;
+import org.aspectj.weaver.ConstantPoolWriter;
+
+/**
+ * An implementation of the constant pool writer that speaks Bcel.
+ * 
+ * @author Andy Clement
+ */
+class BcelConstantPoolWriter implements ConstantPoolWriter {
+
+	ConstantPool pool;
+
+	public BcelConstantPoolWriter(ConstantPool pool) {
+		this.pool = pool;
+	}
+
+	public int writeUtf8(String name) {
+		return pool.addUtf8(name);
+	}
+
+}
\ No newline at end of file
@@ -0,0 +1,23 @@
+/* *******************************************************************
+ * Copyright (c) 2010 Contributors
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ *
+ * Contributors:
+ * Andy Clement (SpringSource)
+ * ******************************************************************/
+package org.aspectj.weaver;
+
+/**
+ * Used during attribute reading to decode constant pool references.
+ * 
+ * @author Andy Clement
+ */
+public interface ConstantPoolReader {
+
+	String readUtf8(int constantPoolIndex);
+
+}
@@ -0,0 +1,23 @@
+/* *******************************************************************
+ * Copyright (c) 2010 Contributors
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ * 
+ * Contributors:
+ * Andy Clement (SpringSource)
+ * ******************************************************************/
+package org.aspectj.weaver;
+
+/**
+ * Used during attribute writing to encode common strings/etc as constant pool references.
+ * 
+ * @author Andy Clement
+ */
+public interface ConstantPoolWriter {
+
+	int writeUtf8(String string);
+
+}
