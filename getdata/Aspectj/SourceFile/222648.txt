@@ -642,7 +642,13 @@ public class ReferenceType extends ResolvedType {
 	}
 
 	public ResolvedType getSuperclass() {
-		ResolvedType ret = delegate.getSuperclass();
+		ResolvedType ret = null;
+    	try {
+			world.setTypeVariableLookupScope(this);
+			ret = delegate.getSuperclass();
+    	} finally {
+    		world.setTypeVariableLookupScope(null);
+    	}
 		if (this.isParameterizedType() && ret.isParameterizedType()) {
 			ret = ret.parameterize(getMemberParameterizationMap()).resolve(getWorld());
 		}
@@ -2120,34 +2120,41 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 		throw new RuntimeException("Cannot ask this type "+this+" for a generic sig attribute");
 	}
 
-	private FuzzyBoolean parameterizedWithAMemberTypeVariable = FuzzyBoolean.MAYBE;
+	private FuzzyBoolean parameterizedWithTypeVariable = FuzzyBoolean.MAYBE;
 
 	/**
 	 * return true if the parameterization of this type includes a member type variable.  Member
 	 * type variables occur in generic methods/ctors.
 	 */
-	public boolean isParameterizedWithAMemberTypeVariable() {
+	public boolean isParameterizedWithTypeVariable() {
 		// MAYBE means we haven't worked it out yet...
-		if (parameterizedWithAMemberTypeVariable==FuzzyBoolean.MAYBE) {
+		if (parameterizedWithTypeVariable==FuzzyBoolean.MAYBE) {
 
 			// if there are no type parameters then we cant be...
 			if (typeParameters==null || typeParameters.length==0) {
-				parameterizedWithAMemberTypeVariable = FuzzyBoolean.NO;
+				parameterizedWithTypeVariable = FuzzyBoolean.NO;
 				return false;
 			}
 
 			for (int i = 0; i < typeParameters.length; i++) {
 				ResolvedType aType = (ResolvedType)typeParameters[i];
-				if (aType.isTypeVariableReference()  && 
-				// assume the worst - if its definetly not a type declared one, it could be anything
-						((TypeVariableReference)aType).getTypeVariable().getDeclaringElementKind()!=TypeVariable.TYPE) {
-					parameterizedWithAMemberTypeVariable = FuzzyBoolean.YES;
+				if (aType.isTypeVariableReference()  
+					// Changed according to the problems covered in bug 222648
+					// Don't care what kind of type variable - the fact that there is one
+					// at all means we can't risk caching it against we get confused later
+					// by another variation of the parameterization that just happens to
+					// use the same type variable name
+					
+					// assume the worst - if its definetly not a type declared one, it could be anything
+					// && ((TypeVariableReference)aType).getTypeVariable().getDeclaringElementKind()!=TypeVariable.TYPE
+					) {
+					parameterizedWithTypeVariable = FuzzyBoolean.YES;
 					return true;
 				}
 				if (aType.isParameterizedType()) {
-					boolean b = aType.isParameterizedWithAMemberTypeVariable();
+					boolean b = aType.isParameterizedWithTypeVariable();
 					if (b) {
-						parameterizedWithAMemberTypeVariable = FuzzyBoolean.YES;
+						parameterizedWithTypeVariable = FuzzyBoolean.YES;
 						return true;
 					}
 				}
@@ -2157,12 +2164,12 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 						boolean b = false;
 						UnresolvedType upperBound = boundedRT.getUpperBound();
 						if (upperBound.isParameterizedType()) {
-							b = ((ResolvedType)upperBound).isParameterizedWithAMemberTypeVariable();
+							b = ((ResolvedType)upperBound).isParameterizedWithTypeVariable();
 						} else if (upperBound.isTypeVariableReference() && ((TypeVariableReference)upperBound).getTypeVariable().getDeclaringElementKind()==TypeVariable.METHOD) {
 							b = true;
 						}
 						if (b) {
-							parameterizedWithAMemberTypeVariable = FuzzyBoolean.YES;
+							parameterizedWithTypeVariable = FuzzyBoolean.YES;
 							return true;
 						}
 						// FIXME asc need to check additional interface bounds
@@ -2171,20 +2178,20 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 						boolean b = false;
 						UnresolvedType lowerBound = boundedRT.getLowerBound();
 						if (lowerBound.isParameterizedType()) {
-							b = ((ResolvedType)lowerBound).isParameterizedWithAMemberTypeVariable();
+							b = ((ResolvedType)lowerBound).isParameterizedWithTypeVariable();
 						} else if (lowerBound.isTypeVariableReference() && ((TypeVariableReference)lowerBound).getTypeVariable().getDeclaringElementKind()==TypeVariable.METHOD) {
 							b = true;
 						}
 						if (b) {
-							parameterizedWithAMemberTypeVariable = FuzzyBoolean.YES;
+							parameterizedWithTypeVariable = FuzzyBoolean.YES;
 							return true;
 						}
 					}
 				}
 			}
-			parameterizedWithAMemberTypeVariable=FuzzyBoolean.NO;
+			parameterizedWithTypeVariable=FuzzyBoolean.NO;
 		}
-		return parameterizedWithAMemberTypeVariable.alwaysTrue();
+		return parameterizedWithTypeVariable.alwaysTrue();
 	}
 
 	protected boolean ajMembersNeedParameterization() {
@@ -905,7 +905,7 @@ public abstract class World implements Dump.INode {
 		 * method/ctor as opposed to those you see declared on a generic type.
 		 */
 		public ResolvedType put(String key, ResolvedType type) { 
-			if (type.isParameterizedType() && type.isParameterizedWithAMemberTypeVariable()) {
+			if (type.isParameterizedType() && type.isParameterizedWithTypeVariable()) {
 				if (debug) 
 					System.err.println("Not putting a parameterized type that utilises member declared type variables into the typemap: key="+key+" type="+type);
 				return type;
@@ -200,8 +200,9 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
     		if (superclassName==null) superclassName = javaClass.getSuperclassName();
     		superclassSignature = getResolvedTypeX().getWorld().resolve(UnresolvedType.forName(superclassName)).getSignature();
     	}
-        ResolvedType res = 	getResolvedTypeX().getWorld().resolve(UnresolvedType.forSignature(superclassSignature));
-    	return res;
+    	World world = getResolvedTypeX().getWorld();
+	    ResolvedType res = 	world.resolve(UnresolvedType.forSignature(superclassSignature));
+	    return res;
     }
 
     public World getWorld() {
@@ -0,0 +1,11 @@
+package test;
+
+public aspect DataAspect
+{
+	
+	public CONTENT Marker<CONTENT>.getContent()
+	{
+		return null;
+	}
+
+}
@@ -0,0 +1,9 @@
+package test;
+
+public interface DataInterface<CONTENT> 
+{
+	
+	public CONTENT getContent();
+	
+		
+}
@@ -0,0 +1,12 @@
+package test;
+
+
+
+abstract public class Foo
+<	CONTENT extends Resource<CONTENT>, 
+	DATA 	extends	DataInterface<CONTENT>
+>
+ extends
+	test.FooBase<DATA>
+{
+}
@@ -0,0 +1,9 @@
+package test;
+
+
+
+abstract public class FooBase<A>
+{
+}
+
+
@@ -0,0 +1,7 @@
+package test;
+
+
+
+public interface Marker<CONTENT> extends DataInterface<CONTENT>
+{
+}
@@ -0,0 +1,5 @@
+package test;
+
+public interface Resource<RESOURCE> 
+{
+}
@@ -0,0 +1,46 @@
+
+abstract class FooBase<A> { }
+
+// Existence of this line causes the exception
+abstract class Foo <CC extends Resource, DD extends DataInterface<CC>> extends FooBase<DD> { }
+
+interface DataInterface<CC> {
+  public CC getContent(); // ERR
+}
+
+interface Marker<CC> extends DataInterface<CC> { }
+
+interface Resource { }
+
+aspect DataAspect {
+  // Intertype declaration onto Marker that shares the variable
+  public C Marker<C>.getContent() { // ERR
+    return null;
+  }
+}
+
+/*
+X.java:7 [error] can't override CC DataInterface<CC>.getContent() with CC Marker.getContent() return types don't match
+public CC getContent();
+          ^^^^^^^^^
+
+X.java:16 [error] can't override CC DataInterface<CC>.getContent() with CC Marker.getContent() return types don't match
+public C Marker<C>.getContent() {
+                   ^^^^^^^^^
+
+1. Two errors because both source locations reported (stupid code)
+
+
+when failing:
+parent: CC DataInterface<CC>.getContent()
+child : CC Marker.getContent()
+Both return types are type variable reference types (different ones though)
+parent: TypeVar CC extends Resource
+child : CC
+
+So parent discovered the wrong type variable (the wrong CC).  
+parent is a ResolvedMemberImpl
+it is considered an 'existingmember' of the type DataInterface<CC>
+
+*/
+
@@ -19,6 +19,8 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 public class Ajc162Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
 	// AspectJ1.6.2	
+	public void testGenericItdsOverrides_pr222648() { runTest("generic itds - overrides"); }
+	public void testGenericItdsOverrides_pr222648_2() { runTest("generic itds - overrides - 2"); }
     public void testItdCallingGenericMethod_pr145391() { runTest("itd calling generic method");}
     public void testItdCallingGenericMethod_pr145391_2() { runTest("itd calling generic method - 2");}
 	public void testPublicPointcut_pr239539() { runTest("public pointcut"); }
@@ -3,6 +3,14 @@
 <!-- AspectJ v1.6.2 Tests -->
 <suite>
 
+	<ajc-test dir="bugs162/pr222648" title="generic itds - overrides">
+	  <compile files="DataAspect.aj DataInterface.java Foo.java FooBase.java Marker.java Resource.java" options="-1.5"/>
+	</ajc-test>
+
+	<ajc-test dir="bugs162/pr222648" title="generic itds - overrides - 2">
+	  <compile files="X.java" options="-1.5"/>
+	</ajc-test>
+	
  	<ajc-test dir="bugs162/pr145391" title="itd calling generic method">
      <compile files="GenericType.java" options="-1.5"/>
      <run class="GenericType"/>
