@@ -59,7 +59,7 @@ class BcelAdvice extends Advice {
 	private ExposedState exposedState;
 
 	public BcelAdvice(AjAttribute.AdviceAttribute attribute, Pointcut pointcut, Member signature, ResolvedType concreteAspect) {
-		super(attribute, pointcut, shrink(attribute.getKind(), concreteAspect, signature));//(signature==null?null:signature.slimline
+		super(attribute, pointcut, shrink(attribute.getKind(), concreteAspect, signature));// (signature==null?null:signature.slimline
 		// ()));
 		this.concreteAspect = concreteAspect;
 	}
@@ -82,7 +82,7 @@ class BcelAdvice extends Advice {
 				if (bm.getMethod() != null && bm.getMethod().getAnnotations() != null)
 					return m;
 				ResolvedMemberImpl simplermember = new ResolvedMemberImpl(bm.getKind(), bm.getDeclaringType(), bm.getModifiers(),
-						bm.getReturnType(), bm.getName(), bm.getParameterTypes());//,bm.getExceptions(),bm.getBackingGenericMember()
+						bm.getReturnType(), bm.getName(), bm.getParameterTypes());// ,bm.getExceptions(),bm.getBackingGenericMember()
 				// );
 				simplermember.setParameterNames(bm.getParameterNames());
 				return simplermember;
@@ -212,7 +212,7 @@ class BcelAdvice extends Advice {
 		return BcelWorld.getBcelObjectType(concreteAspect).getLazyClassGen().isWoven();
 	}
 
-	public void implementOn(Shadow s) {
+	public boolean implementOn(Shadow s) {
 		hasMatchedAtLeastOnce = true;
 		BcelShadow shadow = (BcelShadow) s;
 
@@ -284,6 +284,13 @@ class BcelAdvice extends Advice {
 			// It might be dangerous to change that especially for @AJ aspect non compiled with AJC since if those
 			// are not weaved (f.e. use of some limiteed LTW etc) then they cannot be prepared for inlining.
 			// One solution would be to flag @AJ aspect with an annotation as "prepared" and query that one.
+			LazyClassGen enclosingClass = shadow.getEnclosingClass();
+			if (enclosingClass != null && enclosingClass.isInterface() && shadow.getEnclosingMethod().getName().charAt(0) == '<') {
+				// Do not add methods with bodies to an interface (252198, 163005)
+				shadow.getWorld().getLint().cannotAdviseJoinpointInInterfaceWithAroundAdvice.signal(shadow.toString(), shadow
+						.getSourceLocation());
+				return false;
+			}
 			if (!canInline(s)) {
 				shadow.weaveAroundClosure(this, hasDynamicTests());
 			} else {
@@ -305,6 +312,7 @@ class BcelAdvice extends Advice {
 		} else {
 			throw new BCException("unimplemented kind: " + getKind());
 		}
+		return true;
 	}
 
 	private void removeUnnecessaryProblems(BcelMethod method, int problemLineNumber) {
@@ -2044,7 +2044,6 @@ public class BcelShadow extends Shadow {
 	 * method-execution, then the new method for the advice can also be re-lined. We are not doing that presently.
 	 */
 	public void weaveAroundInline(BcelAdvice munger, boolean hasDynamicTest) {
-
 		// !!! THIS BLOCK OF CODE SHOULD BE IN A METHOD CALLED weaveAround(...);
 		Member mungerSig = munger.getSignature();
 		// Member originalSig = mungerSig; // If mungerSig is on a parameterized type, originalSig is the member on the generic type
@@ -10,13 +10,14 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.weaver.bcel;
 
 import java.io.IOException;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.List;
 
-import org.aspectj.weaver.*;
+import org.aspectj.weaver.Shadow;
+import org.aspectj.weaver.World;
 import org.aspectj.weaver.patterns.Pointcut;
 
 public class IdWeaveTestCase extends WeaveTestCase {
@@ -27,81 +28,74 @@ public class IdWeaveTestCase extends WeaveTestCase {
 	public IdWeaveTestCase(String name) {
 		super(name);
 	}
-    
-    public void testFancyId() throws IOException {
-        final List l = new ArrayList();
+
+	public void testFancyId() throws IOException {
+		final List l = new ArrayList();
 		Pointcut pointcut2 = makePointcutAll();
-        BcelAdvice p = 
-        	new BcelAdvice(null, pointcut2, null, 0, -1, -1, null, null) {
-	            public boolean match(Shadow shadow, World world) {
-	            	if (super.match(shadow, world)) {
-	            		l.add(shadow);
-	            	} 
-	            	return false;
-	            }
-	        };
-        weaveTest(new String[] {"FancyHelloWorld"}, "Id2", p);
-        
-        checkShadowSet(l, new String[] {
-            "method-call(void java.io.PrintStream.println(java.lang.Object))",
-            "method-call(void java.io.PrintStream.println(java.lang.String))",
-            "method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))",
-            "method-call(java.lang.String java.lang.StringBuffer.toString())",
-            "method-execution(java.lang.String FancyHelloWorld.getName())",
-            "field-get(java.io.PrintStream java.lang.System.out)", 
-            "method-call(void java.io.PrintStream.println(java.lang.String))", 
-            "method-execution(void FancyHelloWorld.main(java.lang.String[]))",
-            "method-call(int java.lang.String.hashCode())",
-			"constructor-execution(void FancyHelloWorld.<init>())",
-			"constructor-call(void java.lang.StringBuffer.<init>(java.lang.String))"
-        });
-    }   
+		BcelAdvice p = new BcelAdvice(null, pointcut2, null, 0, -1, -1, null, null) {
+			public boolean match(Shadow shadow, World world) {
+				if (super.match(shadow, world)) {
+					l.add(shadow);
+				}
+				return false;
+			}
+		};
+		weaveTest(new String[] { "FancyHelloWorld" }, "Id2", p);
+
+		checkShadowSet(l, new String[] { "method-call(void java.io.PrintStream.println(java.lang.Object))",
+				"method-call(void java.io.PrintStream.println(java.lang.String))",
+				"method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))",
+				"method-call(java.lang.String java.lang.StringBuffer.toString())",
+				"method-execution(java.lang.String FancyHelloWorld.getName())",
+				"field-get(java.io.PrintStream java.lang.System.out)",
+				"method-call(void java.io.PrintStream.println(java.lang.String))",
+				"method-execution(void FancyHelloWorld.main(java.lang.String[]))", "method-call(int java.lang.String.hashCode())",
+				"constructor-execution(void FancyHelloWorld.<init>())",
+				"constructor-call(void java.lang.StringBuffer.<init>(java.lang.String))" });
+	}
+
+	public void testId() throws IOException {
+		final List l = new ArrayList();
+		BcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {
+			public boolean implementOn(Shadow shadow) {
+				l.add(shadow);
+				return true;
+			}
+		};
+		weaveTest(new String[] { "HelloWorld" }, "Id2", p);
 
+		checkShadowSet(l, new String[] { "method-execution(void HelloWorld.main(java.lang.String[]))",
+				"method-call(void java.io.PrintStream.println(java.lang.String))",
+				"field-get(java.io.PrintStream java.lang.System.out)", "constructor-execution(void HelloWorld.<init>())", });
+	}
 
-    public void testId() throws IOException {
-        final List l = new ArrayList();
-        BcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {
-            public void implementOn(Shadow shadow) {
-                l.add(shadow);
-            }
-        };
-        weaveTest(new String[] {"HelloWorld"}, "Id2", p);
-        
-        checkShadowSet(l, new String[] {
-            "method-execution(void HelloWorld.main(java.lang.String[]))",
-            "method-call(void java.io.PrintStream.println(java.lang.String))",
-            "field-get(java.io.PrintStream java.lang.System.out)", 
-			"constructor-execution(void HelloWorld.<init>())",
-        });
-    }
-    
-    // this test requires that Trace has been unzipped and placed in the correct place
-//    public void testTraceId() throws IOException {
-//    	String saveClassDir = classDir;
-//    	try {
-//	    	classDir = "testdata/dummyAspect.jar";
-//	    	
-//	    	
-//	    	
-//	        final List l = new ArrayList();
-//	        BcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {
-//	            public void implementOn(Shadow shadow) {
-//	                l.add(shadow);
-//	            }
-//	        };
-//	        boolean tempRunTests = runTests;
-//	        runTests = false;
-//	        weaveTest(new String[] {"DummyAspect"}, "Id", p);
-//	        runTests = tempRunTests;
-//	        
-//	        checkShadowSet(l, new String[] {
-//	            "constructor-execution(void DummyAspect.<init>())",
-//				// XXX waiting on parser stuff
-//	            //"advice-execution(void DummyAspect.ajc_before_1(java.lang.Object))",
-//	            });
-//    	} finally {
-//        	classDir = saveClassDir;
-//    	}
-//    }
+	// this test requires that Trace has been unzipped and placed in the correct place
+	// public void testTraceId() throws IOException {
+	// String saveClassDir = classDir;
+	// try {
+	// classDir = "testdata/dummyAspect.jar";
+	//	    	
+	//	    	
+	//	    	
+	// final List l = new ArrayList();
+	// BcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {
+	// public void implementOn(Shadow shadow) {
+	// l.add(shadow);
+	// }
+	// };
+	// boolean tempRunTests = runTests;
+	// runTests = false;
+	// weaveTest(new String[] {"DummyAspect"}, "Id", p);
+	// runTests = tempRunTests;
+	//	        
+	// checkShadowSet(l, new String[] {
+	// "constructor-execution(void DummyAspect.<init>())",
+	// // XXX waiting on parser stuff
+	// //"advice-execution(void DummyAspect.ajc_before_1(java.lang.Object))",
+	// });
+	// } finally {
+	// classDir = saveClassDir;
+	// }
+	// }
 
 }
@@ -10,13 +10,13 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.weaver.bcel;
 
-import java.io.*;
+import java.io.IOException;
 
 import org.aspectj.apache.bcel.generic.InstructionFactory;
-import org.aspectj.weaver.*;
+import org.aspectj.weaver.NameMangler;
+import org.aspectj.weaver.Shadow;
 
 public class MoveInstructionsWeaveTestCase extends WeaveTestCase {
 	{
@@ -26,48 +26,51 @@ public class MoveInstructionsWeaveTestCase extends WeaveTestCase {
 	public MoveInstructionsWeaveTestCase(String name) {
 		super(name);
 	}
-    public void testHello() throws IOException {
-        BcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {
-            public void specializeOn(Shadow s) {
-            	super.specializeOn(s);
-                ((BcelShadow) s).initializeForAroundClosure();
-            }
-			public void implementOn(Shadow s) {
+
+	public void testHello() throws IOException {
+		BcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {
+			public void specializeOn(Shadow s) {
+				super.specializeOn(s);
+				((BcelShadow) s).initializeForAroundClosure();
+			}
+
+			public boolean implementOn(Shadow s) {
 				BcelShadow shadow = (BcelShadow) s;
-				LazyMethodGen newMethod =
-					shadow.extractMethod(
-						NameMangler.getExtractableName(shadow.getSignature()) + "_extracted",
-						0,
-						this);
+				LazyMethodGen newMethod = shadow.extractMethod(
+						NameMangler.getExtractableName(shadow.getSignature()) + "_extracted", 0, this);
 				shadow.getRange().append(shadow.makeCallToCallback(newMethod));
 
 				if (!shadow.isFallsThrough()) {
-					shadow.getRange().append(
-						InstructionFactory.createReturn(newMethod.getReturnType()));
+					shadow.getRange().append(InstructionFactory.createReturn(newMethod.getReturnType()));
 				}
+				return true;
 			}
-        };
+		};
+
+		weaveTest("HelloWorld", "ExtractedHelloWorld", p);
+	}
+
+	static int counter = 0;
 
-        weaveTest("HelloWorld", "ExtractedHelloWorld", p);
-    }  
-   
-    static int counter = 0;
 	public void testFancyHello() throws IOException {
 		BcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {
-            public void specializeOn(Shadow s) {
-            	super.specializeOn(s);
-                ((BcelShadow) s).initializeForAroundClosure();
-            }
-            public void implementOn(Shadow s) {
-                BcelShadow shadow = (BcelShadow) s;
-                LazyMethodGen newMethod = shadow.extractMethod(NameMangler.getExtractableName(shadow.getSignature()) + "_extracted" + counter++, 0, this);
-                shadow.getRange().append(shadow.makeCallToCallback(newMethod));
+			public void specializeOn(Shadow s) {
+				super.specializeOn(s);
+				((BcelShadow) s).initializeForAroundClosure();
+			}
+
+			public boolean implementOn(Shadow s) {
+				BcelShadow shadow = (BcelShadow) s;
+				LazyMethodGen newMethod = shadow.extractMethod(NameMangler.getExtractableName(shadow.getSignature()) + "_extracted"
+						+ counter++, 0, this);
+				shadow.getRange().append(shadow.makeCallToCallback(newMethod));
 
-                if (! shadow.isFallsThrough()) {
-                    shadow.getRange().append(InstructionFactory.createReturn(newMethod.getReturnType()));
-                }
-            }
-  		};
+				if (!shadow.isFallsThrough()) {
+					shadow.getRange().append(InstructionFactory.createReturn(newMethod.getReturnType()));
+				}
+				return true;
+			}
+		};
 
 		weaveTest("FancyHelloWorld", "ExtractedFancyHelloWorld", p);
 	}
@@ -10,109 +10,111 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.weaver.bcel;
 
-import java.io.*;
-import java.util.*;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 
-import org.aspectj.weaver.*;
-import org.aspectj.weaver.patterns.*;
+import org.aspectj.weaver.ResolvedType;
+import org.aspectj.weaver.Shadow;
+import org.aspectj.weaver.VersionedDataInputStream;
+import org.aspectj.weaver.patterns.FormalBinding;
+import org.aspectj.weaver.patterns.Pointcut;
+import org.aspectj.weaver.patterns.SimpleScope;
 
 public class PatternWeaveTestCase extends WeaveTestCase {
 	{
 		regenerate = false;
 	}
-	
+
 	public PatternWeaveTestCase(String name) {
 		super(name);
 	}
-		
-    String[] none = new String[0];
 
-	//XXX this test is incompatible with optimizations made to weaver
+	String[] none = new String[0];
+
+	// XXX this test is incompatible with optimizations made to weaver
 
 	public void testPublic() throws IOException {
-		String[] publicHello = new String[] {
-			"method-execution(void HelloWorld.main(java.lang.String[]))",
-		};
-		String[] publicFancyHello = new String[] {
-			"method-execution(void FancyHelloWorld.main(java.lang.String[]))",
-			"method-execution(java.lang.String FancyHelloWorld.getName())",
-		};
+		String[] publicHello = new String[] { "method-execution(void HelloWorld.main(java.lang.String[]))", };
+		String[] publicFancyHello = new String[] { "method-execution(void FancyHelloWorld.main(java.lang.String[]))",
+				"method-execution(java.lang.String FancyHelloWorld.getName())", };
 		checkPointcut("execution(public * *(..))", publicHello, publicFancyHello);
 	}
-//	
-//	public void testPrintln() throws IOException {
-//		String[] callPrintlnHello = new String[] {
-//			"method-call(void java.io.PrintStream.println(java.lang.String))",
-//		};
-//		String[] callPrintlnFancyHello = new String[] {
-//			"method-call(void java.io.PrintStream.println(java.lang.String))",
-//			"method-call(void java.io.PrintStream.println(java.lang.String))",
-//			"method-call(void java.io.PrintStream.println(java.lang.Object))",
-//		};
-//		checkPointcut("call(* println(*))", callPrintlnHello, callPrintlnFancyHello);
-//	}
-//	
-//	public void testMumble() throws IOException {
-//		checkPointcut("call(* mumble(*))", none, none);
-//	}
-//	
-//	public void testFooBar() throws IOException {
-//		checkPointcut("call(FooBar *(..))", none, none);
-//	}
-//	
-//	public void testGetOut() throws IOException {
-//		String[] getOutHello = new String[] {
-//			"field-get(java.io.PrintStream java.lang.System.out)",
-//		};
-//		
-//		checkPointcut("get(* java.lang.System.out)", getOutHello, getOutHello);
-//	}	
-//	
-////	private Pointcut makePointcut(String s) {
-////		return new PatternParser(s).parsePointcut();
-////	}
-//		
-    private void checkPointcut(String pointcutSource, String[] expectedHelloShadows, 
-                                String[] expectedFancyShadows) throws IOException
-    {
-        Pointcut sp = Pointcut.fromString(pointcutSource);
-        Pointcut rp = sp.resolve(new SimpleScope(world, FormalBinding.NONE));
-        Pointcut cp = rp.concretize(ResolvedType.MISSING, ResolvedType.MISSING, 0);
-        
-        final List l = new ArrayList();
-        BcelAdvice p = new BcelAdvice(null, cp, null, 0, -1, -1, null, null) {
-            public void implementOn(Shadow shadow) {
-                l.add(shadow);
-            }
-        };
-        weaveTest(new String[] {"HelloWorld"}, "PatternWeave", p);
-        
-        checkShadowSet(l, expectedHelloShadows);
-        
-        
-        l.clear();
-        weaveTest(new String[] {"FancyHelloWorld"}, "PatternWeave", p);
-        
-        checkShadowSet(l, expectedFancyShadows);
-        
-        checkSerialize(rp);
-    }
-    
+
+	//	
+	// public void testPrintln() throws IOException {
+	// String[] callPrintlnHello = new String[] {
+	// "method-call(void java.io.PrintStream.println(java.lang.String))",
+	// };
+	// String[] callPrintlnFancyHello = new String[] {
+	// "method-call(void java.io.PrintStream.println(java.lang.String))",
+	// "method-call(void java.io.PrintStream.println(java.lang.String))",
+	// "method-call(void java.io.PrintStream.println(java.lang.Object))",
+	// };
+	// checkPointcut("call(* println(*))", callPrintlnHello, callPrintlnFancyHello);
+	// }
+	//	
+	// public void testMumble() throws IOException {
+	// checkPointcut("call(* mumble(*))", none, none);
+	// }
+	//	
+	// public void testFooBar() throws IOException {
+	// checkPointcut("call(FooBar *(..))", none, none);
+	// }
+	//	
+	// public void testGetOut() throws IOException {
+	// String[] getOutHello = new String[] {
+	// "field-get(java.io.PrintStream java.lang.System.out)",
+	// };
+	//		
+	// checkPointcut("get(* java.lang.System.out)", getOutHello, getOutHello);
+	// }
+	//	
+	// // private Pointcut makePointcut(String s) {
+	// // return new PatternParser(s).parsePointcut();
+	// // }
+	//		
+	private void checkPointcut(String pointcutSource, String[] expectedHelloShadows, String[] expectedFancyShadows)
+			throws IOException {
+		Pointcut sp = Pointcut.fromString(pointcutSource);
+		Pointcut rp = sp.resolve(new SimpleScope(world, FormalBinding.NONE));
+		Pointcut cp = rp.concretize(ResolvedType.MISSING, ResolvedType.MISSING, 0);
+
+		final List l = new ArrayList();
+		BcelAdvice p = new BcelAdvice(null, cp, null, 0, -1, -1, null, null) {
+			public boolean implementOn(Shadow shadow) {
+				l.add(shadow);
+				return true;
+			}
+		};
+		weaveTest(new String[] { "HelloWorld" }, "PatternWeave", p);
+
+		checkShadowSet(l, expectedHelloShadows);
+
+		l.clear();
+		weaveTest(new String[] { "FancyHelloWorld" }, "PatternWeave", p);
+
+		checkShadowSet(l, expectedFancyShadows);
+
+		checkSerialize(rp);
+	}
+
 	public void checkSerialize(Pointcut p) throws IOException {
 		ByteArrayOutputStream bo = new ByteArrayOutputStream();
 		DataOutputStream out = new DataOutputStream(bo);
 		p.write(out);
 		out.close();
-		
+
 		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
 		VersionedDataInputStream in = new VersionedDataInputStream(bi);
 		Pointcut newP = Pointcut.read(in, null);
-		
-		assertEquals("write/read", p, newP);	
-	}
 
+		assertEquals("write/read", p, newP);
+	}
 
 }
@@ -72,7 +72,7 @@ public class Checker extends ShadowMunger {
 	/**
 	 * Not supported for a Checker
 	 */
-	public void implementOn(Shadow shadow) {
+	public boolean implementOn(Shadow shadow) {
 		throw new RuntimeException("illegal state");
 	}
 
@@ -126,6 +126,10 @@ public class Lint {
 			"mustWeaveXmlDefinedAspects",
 			"XML Defined aspects must be woven in cases where cflow pointcuts are involved. Currently the include/exclude patterns exclude ''{0}''");
 
+	public final Kind cannotAdviseJoinpointInInterfaceWithAroundAdvice = new Kind(
+			"cannotAdviseJoinpointInInterfaceWithAroundAdvice",
+			"The joinpoint ''{0}'' cannot be advised and is being skipped as the compiler implementation will lead to creation of methods with bodies in an interface (compiler limitation)");
+
 	/**
 	 * Indicates an aspect could not be found when attempting reweaving.
 	 */
@@ -610,8 +610,9 @@ public abstract class Shadow {
 		World world = getIWorld();
 		for (Iterator iter = mungers.iterator(); iter.hasNext();) {
 			ShadowMunger munger = (ShadowMunger) iter.next();
-			munger.implementOn(this);
-			world.reportMatch(munger, this);
+			if (munger.implementOn(this)) {
+				world.reportMatch(munger, this);
+			}
 		}
 	}
 
@@ -54,7 +54,13 @@ public abstract class ShadowMunger implements PartialOrder.PartialComparable, IH
 
 	public abstract void specializeOn(Shadow shadow);
 
-	public abstract void implementOn(Shadow shadow);
+	/**
+	 * Implement this munger at the specified shadow, returning a boolean to indicate success.
+	 * 
+	 * @param shadow the shadow where this munger should be applied
+	 * @return true if the munger was successful
+	 */
+	public abstract boolean implementOn(Shadow shadow);
 
 	/**
 	 * All overriding methods should call super
@@ -44,4 +44,5 @@ calculatingSerialVersionUID=ignore
 advisingSynchronizedMethods=warning
 mustWeaveXmlDefinedAspects=warning
 
-missingAspectForReweaving=error
\ No newline at end of file
+missingAspectForReweaving=error
+cannotAdviseJoinpointInInterfaceWithAroundAdvice=warning
\ No newline at end of file
@@ -0,0 +1,13 @@
+public aspect ProblemAspect {
+
+        pointcut init(): initialization(Object+.new(..));
+
+        pointcut staticinit(): staticinitialization(Object+);
+
+        Class around(String className): cflowbelow(init() || staticinit()) &&
+call(Class Class.forName(String)) && args(className) {
+                System.out.println("Test");
+                return proceed(className);
+
+        }
+}
@@ -0,0 +1,4 @@
+public class SomeClass implements SomeInterface {
+  public static void main(String []argv) {}
+}
+
@@ -0,0 +1,4 @@
+public interface SomeInterface {
+        Class ADAPTER = SomeInterface.class;
+}
+
