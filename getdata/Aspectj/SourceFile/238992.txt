@@ -0,0 +1,36 @@
+import java.lang.annotation.*;
+import java.io.*;
+
+@Entity(s="xxx")
+public class Foo5 {
+  public static void main(String []argv) {
+    Foo5 f = new Foo5();
+    Goo g = new Goo();
+    if (f instanceof Serializable) {
+       throw new RuntimeException("Foo5 should not implement it");        
+    }
+    if (!(g instanceof Serializable)) {
+       throw new RuntimeException("Goo should implement it");        
+    }
+    if (!(new Hoo() instanceof Serializable)) {
+       throw new RuntimeException("Hoo should implement it");        
+    }
+  }
+}
+
+@Entity(s="yyy")
+class Goo {
+}
+
+@Entity // default is "yyy"
+class Hoo {
+}
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Entity {
+  String s() default "yyy";
+}
+
+aspect X {
+  declare parents: (@Entity(s="yyy") *) implements java.io.Serializable;
+}
@@ -23,10 +23,11 @@ public class Ajc162Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 //	public void testParamAnnoInner_pr241861() { runTest("param annotation inner class"); }
 	public void testAnnotationDecp_pr239441() { runTest("annotation decp"); }
 	public void testAtAspectJPerTarget_pr198181() { runTest("ataspectj ltw pertarget"); }
-//	public void testAnnotationValueDecp_pr238992() { runTest("annotation value decp"); }
-//	public void testAnnotationValueDecp_pr238992_2() { runTest("annotation value decp - 2"); }
-//	public void testAnnotationValueDecp_pr238992_3() { runTest("annotation value decp - 3"); }
-//	public void testAnnotationValueDecp_pr238992_4() { runTest("annotation value decp - 4"); }
+	public void testAnnotationValueDecp_pr238992() { runTest("annotation value decp"); }
+	public void testAnnotationValueDecp_pr238992_2() { runTest("annotation value decp - 2"); }
+	public void testAnnotationValueDecp_pr238992_3() { runTest("annotation value decp - 3"); }
+	public void testAnnotationValueDecp_pr238992_4() { runTest("annotation value decp - 4"); }
+	public void testAnnotationValueDecp_pr238992_5() { runTest("annotation value decp - 5"); }
 
 	/*
 	 * test plan
@@ -50,6 +50,14 @@
     	<run class="Foo4"/>
     </ajc-test>    
 
+	<ajc-test dir="bugs162/pr238992" title="annotation value decp - 5">
+    	<compile files="Foo5.java" options="-1.5 -showWeaveInfo">
+    	  <message kind="weave" text="Extending interface set for type 'Goo'"/>
+    	  <message kind="weave" text="Extending interface set for type 'Hoo'"/>
+    	</compile>
+    	<run class="Foo5"/>
+    </ajc-test>    
+    
     <ajc-test dir="bugs162/pr233718" title="parameter subsetting - matching">
         <compile files="Matching.java" options="-1.5 -showWeaveInfo">
           <message kind="weave" text="Join point 'method-execution(void Matching.m(java.lang.String))' in Type 'Matching' (Matching.java:3) advised by before advice from 'Matching' (Matching.java:8)"/>
@@ -23,6 +23,7 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.ast.SingleNameReference;
 import org.aspectj.org.eclipse.jdt.internal.compiler.impl.BooleanConstant;
 import org.aspectj.org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.aspectj.org.eclipse.jdt.internal.compiler.impl.IntConstant;
+import org.aspectj.org.eclipse.jdt.internal.compiler.impl.StringConstant;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.TagBits;
@@ -147,6 +148,9 @@ public class EclipseAnnotationConvertor {
 			} else if (c instanceof BooleanConstant) {
 				BooleanConstant iConstant = (BooleanConstant)c;
 				return new SimpleAnnotationValue(ElementValueGen.PRIMITIVE_BOOLEAN,new Boolean(iConstant.booleanValue()));
+			} else if (c instanceof StringConstant) {
+				StringConstant sConstant = (StringConstant)c;
+				return new SimpleAnnotationValue(ElementValueGen.STRING,sConstant.stringValue());
 			}
 		}
 		return null;
@@ -20,6 +20,7 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.ast.FalseLiteral;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.IntLiteral;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.StringLiteral;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TrueLiteral;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.impl.IntConstant;
@@ -123,6 +124,8 @@ public class EclipseResolvedMember extends ResolvedMemberImpl {
 					return "true";
 				} else if (e instanceof FalseLiteral) {
 					return "false";
+				} else if (e instanceof StringLiteral) {
+					return new String(((StringLiteral)e).source());
 				} else if (e instanceof IntLiteral) {
 					return Integer.toString(((IntConstant)e.constant).intValue());
 				} else {
@@ -138,7 +138,7 @@ public class EclipseAnnotationConvertor {
 		}
 	}
 
-	private static AnnotationValue generateElementValueForConstantExpression(Expression defaultValue, TypeBinding defaultValueBinding) {
+	public static AnnotationValue generateElementValueForConstantExpression(Expression defaultValue, TypeBinding defaultValueBinding) {
 		if (defaultValueBinding != null) {
 			Constant c = defaultValue.constant;
 			if (c instanceof IntConstant) {
@@ -16,14 +16,19 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Expression;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.FalseLiteral;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.IntLiteral;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TrueLiteral;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
+import org.aspectj.org.eclipse.jdt.internal.compiler.impl.IntConstant;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
 import org.aspectj.weaver.AnnotationX;
+import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.MemberKind;
 import org.aspectj.weaver.ResolvedMemberImpl;
 import org.aspectj.weaver.ResolvedType;
@@ -114,6 +119,14 @@ public class EclipseResolvedMember extends ResolvedMemberImpl {
 						sb.append(fb.name);
 						return sb.toString();
 					}
+				} else if (e instanceof TrueLiteral) {
+					return "true";
+				} else if (e instanceof FalseLiteral) {
+					return "false";
+				} else if (e instanceof IntLiteral) {
+					return Integer.toString(((IntConstant)e.constant).intValue());
+				} else {
+					throw new BCException("EclipseResolvedMember.getAnnotationDefaultValue() not implemented for value of type '"+e.getClass()+"' - raise an AspectJ bug !");
 				}
 			}
 		}
@@ -35,6 +35,7 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Expression;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.NameReference;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.NormalAnnotation;
@@ -161,7 +162,7 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
             }
         }
         return false;
-    }
+    } 
 
     /** Returns "" if there is a problem */
     private String getPointcutStringFromAnnotationStylePointcut(AbstractMethodDeclaration amd) {
@@ -631,8 +632,10 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 				annotationAJ.addNameValuePair(
 						new AnnotationNameValuePair(new String(singleMemberAnnotation.memberValuePairs()[0].name),av));
 			}
+		} else if (annotation instanceof MarkerAnnotation) {
+			return;
 		} else {
-			// this is a marker annotation (no member value pairs)
+			// this is something else...
 			throw new MissingImplementationException(
 				    "Please raise an AspectJ bug.  AspectJ does not know how to convert this annotation ["+annotation+"]");
 		}
@@ -656,8 +659,12 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 				}
 			} else {
 				if (constant != null && constant != Constant.NotAConstant) {
-					throw new MissingImplementationException(
-						    "Please raise an AspectJ bug.  AspectJ does not know how to convert this annotation value ["+defaultValue+"]");
+					AnnotationValue av = EclipseAnnotationConvertor.generateElementValueForConstantExpression(defaultValue,defaultValueBinding);
+					if (av==null) {
+						throw new MissingImplementationException(
+								"Please raise an AspectJ bug.  AspectJ does not know how to convert this annotation value ["+defaultValue+"]");						
+					}
+					return av;
 //	   				generateElementValue(attributeOffset, defaultValue, constant, memberValuePairReturnType.leafComponentType());
 				} else {
 					AnnotationValue av = generateElementValueForNonConstantExpression(defaultValue, defaultValueBinding);
@@ -708,6 +715,15 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 					throw new MissingImplementationException(
 						    "Please raise an AspectJ bug.  AspectJ does not know how to convert this annotation value ["+defaultValue+"]");
 				}
+//			} else if (defaultValue instanceof MagicLiteral) {
+//				if (defaultValue instanceof FalseLiteral) {
+//					new AnnotationValue
+//				} else if (defaultValue instanceof TrueLiteral) {
+//					
+//				} else {					
+//					throw new MissingImplementationException(
+//						    "Please raise an AspectJ bug.  AspectJ does not know how to convert this annotation value ["+defaultValue+"]");
+//				}
 			} else {
 				// class type
 				throw new MissingImplementationException(
@@ -0,0 +1,36 @@
+import java.lang.annotation.*;
+import java.io.*;
+
+@Entity(indexed=false)
+public class Foo {
+  public static void main(String []argv) {
+    Foo f = new Foo();
+    Goo g = new Goo();
+    if (f instanceof Serializable) {
+       throw new RuntimeException("Foo should not implement it");        
+    }
+    if (!(g instanceof Serializable)) {
+       throw new RuntimeException("Goo should implement it");        
+    }
+    if (new Hoo() instanceof Serializable) {
+       throw new RuntimeException("Hoo should not implement it");        
+    }
+  }
+}
+
+@Entity(indexed=true)
+class Goo {
+}
+
+@Entity // default is false
+class Hoo {
+}
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Entity {
+  boolean indexed() default false;
+}
+
+aspect X {
+  declare parents: (@Entity(indexed=true) *) implements java.io.Serializable;
+}
@@ -0,0 +1,36 @@
+import java.lang.annotation.*;
+import java.io.*;
+
+@Entity(indexed=false)
+public class Foo2 {
+  public static void main(String []argv) {
+    Foo2 f = new Foo2();
+    Goo g = new Goo();
+    if (f instanceof Serializable) {
+       throw new RuntimeException("Foo2 should not implement it");        
+    }
+    if (!(g instanceof Serializable)) {
+       throw new RuntimeException("Goo should implement it");        
+    }
+    if (!(new Hoo() instanceof Serializable)) {
+       throw new RuntimeException("Hoo should implement it");        
+    }
+  }
+}
+
+@Entity(indexed=true)
+class Goo {
+}
+
+@Entity // default is true
+class Hoo {
+}
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Entity {
+  boolean indexed() default true;
+}
+
+aspect X {
+  declare parents: (@Entity(indexed=true) *) implements java.io.Serializable;
+}
@@ -0,0 +1,36 @@
+import java.lang.annotation.*;
+import java.io.*;
+
+@Entity(i=1)
+public class Foo3 {
+  public static void main(String []argv) {
+    Foo3 f = new Foo3();
+    Goo g = new Goo();
+    if (f instanceof Serializable) {
+       throw new RuntimeException("Foo3 should not implement it");        
+    }
+    if (!(g instanceof Serializable)) {
+       throw new RuntimeException("Goo should implement it");        
+    }
+    if (new Hoo() instanceof Serializable) {
+       throw new RuntimeException("Hoo should not implement it");        
+    }
+  }
+}
+
+@Entity(i=2)
+class Goo {
+}
+
+@Entity // default is 1
+class Hoo {
+}
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Entity {
+  int i() default 1;
+}
+
+aspect X {
+  declare parents: (@Entity(i=2) *) implements java.io.Serializable;
+}
@@ -0,0 +1,36 @@
+import java.lang.annotation.*;
+import java.io.*;
+
+@Entity(i=1)
+public class Foo4 {
+  public static void main(String []argv) {
+    Foo4 f = new Foo4();
+    Goo g = new Goo();
+    if (f instanceof Serializable) {
+       throw new RuntimeException("Foo4 should not implement it");        
+    }
+    if (!(g instanceof Serializable)) {
+       throw new RuntimeException("Goo should implement it");        
+    }
+    if (!(new Hoo() instanceof Serializable)) {
+       throw new RuntimeException("Hoo should implement it");        
+    }
+  }
+}
+
+@Entity(i=2)
+class Goo {
+}
+
+@Entity // default is 2
+class Hoo {
+}
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Entity {
+  int i() default 2;
+}
+
+aspect X {
+  declare parents: (@Entity(i=2) *) implements java.io.Serializable;
+}
@@ -19,8 +19,12 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 public class Ajc162Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
 	// AspectJ1.6.2	
-	public void testAnnotationDecp_pr239441() { runTest("annotation decp"); }
-
+//	public void testAnnotationDecp_pr239441() { runTest("annotation decp"); }
+	public void testAnnotationValueDecp_pr238992() { runTest("annotation value decp"); }
+	public void testAnnotationValueDecp_pr238992_2() { runTest("annotation value decp - 2"); }
+	public void testAnnotationValueDecp_pr238992_3() { runTest("annotation value decp - 3"); }
+	public void testAnnotationValueDecp_pr238992_4() { runTest("annotation value decp - 4"); }
+	
 	public static Test suite() {
       return XMLBasedAjcTestCase.loadSuite(Ajc162Tests.class);
     }
@@ -7,5 +7,35 @@
     	<compile files="Test3.java SampleAspect.java" options="-1.5 -showWeaveInfo -XhasMember">
     	</compile>
     </ajc-test>    
+    
+	<ajc-test dir="bugs162/pr238992" title="annotation value decp">
+    	<compile files="Foo.java" options="-1.5 -showWeaveInfo">
+    	  <message kind="weave" text="Extending interface set for type 'Goo'"/>
+    	</compile>
+    	<run class="Foo"/>
+    </ajc-test>    
+    
+	<ajc-test dir="bugs162/pr238992" title="annotation value decp - 2">
+    	<compile files="Foo2.java" options="-1.5 -showWeaveInfo">
+    	  <message kind="weave" text="Extending interface set for type 'Goo'"/>
+    	  <message kind="weave" text="Extending interface set for type 'Hoo'"/>
+    	</compile>
+    	<run class="Foo2"/>
+    </ajc-test>    
+    
+	<ajc-test dir="bugs162/pr238992" title="annotation value decp - 3">
+    	<compile files="Foo3.java" options="-1.5 -showWeaveInfo">
+    	  <message kind="weave" text="Extending interface set for type 'Goo'"/>
+    	</compile>
+    	<run class="Foo3"/>
+    </ajc-test>    
+    
+	<ajc-test dir="bugs162/pr238992" title="annotation value decp - 4">
+    	<compile files="Foo4.java" options="-1.5 -showWeaveInfo">
+    	  <message kind="weave" text="Extending interface set for type 'Goo'"/>
+    	  <message kind="weave" text="Extending interface set for type 'Hoo'"/>
+    	</compile>
+    	<run class="Foo4"/>
+    </ajc-test>    
 
 </suite>
\ No newline at end of file
@@ -156,7 +156,18 @@ public class ReferenceType extends ResolvedType {
     	return delegate.getAnnotationTypes(); 
     }
 
-    public boolean isAspect() {
+	public AnnotationX getAnnotationOfType(UnresolvedType ofType) {
+		AnnotationX[] axs = delegate.getAnnotations();
+		if (axs==null) return null;
+		for (int i=0;i<axs.length;i++) {
+			if (axs[i].getSignature().equals(ofType)) {
+				return axs[i];
+			}
+		}
+		return null;
+	}
+
+	public boolean isAspect() {
     	return delegate.isAspect();
     }
 
