@@ -0,0 +1,28 @@
+import java.lang.reflect.Method;
+import java.net.URLClassLoader;
+import java.net.URL;
+import java.io.File;
+import org.aspectj.weaver.loadtime.WeavingURLClassLoader;
+
+public class HierMain {
+
+  public static void main(String []argv) {
+	  try {
+		  System.out.println("into:main");
+		  ClassLoader baseLoader = HierMain.class.getClassLoader(); 
+		  URL base = baseLoader.getResource("HierMain.class");
+		  String urlstr = base.toExternalForm();
+		  int idx = urlstr.indexOf("classes.jar!");
+		  String sub = urlstr.substring("jar:".length(), idx)+"/sub.hiddenjar";
+		  URL subUrls[] = new URL[] { new URL(sub) };
+		  WeavingURLClassLoader loader = new WeavingURLClassLoader(subUrls, baseLoader);
+		  Class clazzA = Class.forName("A", false, loader);
+		  Method clazzAMethod = clazzA.getMethod("method",null);
+		  clazzAMethod.invoke(clazzA.newInstance(),null);
+		  System.out.println("leave:main");
+	  } catch (Throwable t) {
+		  t.printStackTrace();
+	  }
+  }
+  
+}
@@ -130,8 +130,8 @@ public class LTWTests extends org.aspectj.testing.XMLBasedAjcTestCase {
   	  runTest("aggressive ltw - decp - 2");
     }
 
-    public void testWeavingTargetOfCallAggressivelyInLTW_DeclareAnnotation_pr133770() {
-  	  runTest("aggressive ltw - deca");
+    public void testWeavingTargetOfCallAggressivelyInLTW_DeclareParents_Hierarchy_pr133770() {
+      runTest("aggressive ltw - hierarchy");
     }
 
   	public void testSeparateCompilationDeclareParentsCall_pr133770() {
@@ -156,6 +156,21 @@
       </run>
     </ajc-test>  
 
+    <ajc-test dir="ltw/callMunging/case1" title="aggressive ltw - hierarchy">
+      <compile files="T.java,HierMain.java" outjar="classes.jar"/>
+      <compile files="A.java" outjar="sub.hiddenjar" classpath="classes.jar"/>
+      <compile files="X.java" outjar="aspects.jar" classpath="classes.jar" options="-Xlint:ignore"/>
+      <run class="HierMain" ltw="aop.xml">
+        <stdout>
+          <line text="into:main"/>
+          <line text="A.method() running"/>
+          <line text="advice running"/>
+          <line text="T.m1() running"/>
+          <line text="leave:main"/>
+        </stdout>
+      </run>
+    </ajc-test>  
+    
     <ajc-test dir="ltw/callMunging/case3" title="aggressive ltw - decp - 2">
       <compile files="A.java,T.java,S.java,Main.java" outjar="classes.jar"/>
       <compile files="X.java" outjar="aspects.jar" classpath="classes.jar" options="-Xlint:ignore"/>
@@ -268,23 +268,8 @@ public abstract class World implements Dump.INode {
             if (!allowMissing && ret.isMissing()) {
                 ret = handleRequiredMissingTypeDuringResolution(ty);
             }
-            
-            if (completeBinaryTypes && needsCompletion() && isLocallyDefined(ret.getName())) {
-            	if (typeCompletionInProgress) {
-            		typesForCompletion.add(ret);
-            	} else {                	
-            		try {
-            			typeCompletionInProgress=true;
-                		completeType(ret);
-            		} finally {
-            			typeCompletionInProgress=false;
-            		}
-	            	while (typesForCompletion.size()!=0) {
-	            		ResolvedType rt = (ResolvedType)typesForCompletion.get(0);
-	            		completeType(rt);
-	            		typesForCompletion.remove(0);
-	            	}
-            	}
+            if (completeBinaryTypes) {
+            	completeBinaryType(ret);
             }
         }        
 
@@ -294,25 +279,12 @@ public abstract class World implements Dump.INode {
 		}
         return ret;
     }
-    
-    // --- these methods are for supporting loadtime weaving with inter type declarations
-    // the idea is that when types are resolved, we give the world a chance to say whether
-    // it needs to 'finish them off' - ie. attach type mungers for ITDs.  These types won't
-    // actually get woven at this time, they will merely have type mungers attached to them
-    // for the purposes of answering questions like 'what is your supertype?' correctly.
-
-    /**
-     * return true if types need completing when getting resolved - overridden by subtypes.
-     */
-    protected boolean needsCompletion() {
-		return false;
-	}
-    
+        
 	/**
      * Called when a type is resolved - enables its type hierarchy to be finished off before we
      * proceed
      */
-    protected void completeType(ResolvedType ret) {}
+    protected void completeBinaryType(ResolvedType ret) {}
 
 
     /**
@@ -322,14 +294,7 @@ public abstract class World implements Dump.INode {
     public boolean isLocallyDefined(String classname) {
     	return false;
     }
-
-    // One type is completed at a time, if multiple need doing then they
-    // are queued up
-	private boolean typeCompletionInProgress = false;
-    private List/*ResolvedType*/typesForCompletion = new ArrayList();
-    
-    // ---
-    
+        
     /**
      * We tried to resolve a type and couldn't find it...
      */
@@ -13,8 +13,10 @@ package org.aspectj.weaver.ltw;
 
 import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 
 import org.aspectj.bridge.IMessageHandler;
@@ -46,7 +48,8 @@ import org.aspectj.weaver.reflect.ReflectionWorld;
  */
 public class LTWWorld extends BcelWorld implements IReflectionWorld {
 
-    private AnnotationFinder annotationFinder;
+
+	private AnnotationFinder annotationFinder;
     private ClassLoader loader; // weavingContext?
     private IWeavingContext weavingContext;
 
@@ -186,8 +189,38 @@ public class LTWWorld extends BcelWorld implements IReflectionWorld {
     public boolean isRunMinimalMemory() {
 	     return true;
     }
+
+
+    // One type is completed at a time, if multiple need doing then they
+    // are queued up
+	private boolean typeCompletionInProgress = false;
+    private List/*ResolvedType*/typesForCompletion = new ArrayList();
 
-	protected void completeType(ResolvedType ret) {
+	protected void completeBinaryType(ResolvedType ret) {
+		if (isLocallyDefined(ret.getName())) {
+        	if (typeCompletionInProgress) {
+        		typesForCompletion.add(ret);
+        	} else {                	
+        		try {
+        			typeCompletionInProgress=true;
+            		completeHierarchyForType(ret);
+        		} finally {
+        			typeCompletionInProgress=false;
+        		}
+            	while (typesForCompletion.size()!=0) {
+            		ResolvedType rt = (ResolvedType)typesForCompletion.get(0);
+            		completeHierarchyForType(rt);
+            		typesForCompletion.remove(0);
+            	}
+        	}
+    	} else {
+    		if (!ret.needsModifiableDelegate()) {
+    			ret = completeNonLocalType(ret);
+    		}
+    	}
+	}
+	
+	private void completeHierarchyForType(ResolvedType ret) {
     	getLint().typeNotExposedToWeaver.setSuppressed(true);
     	weaveInterTypeDeclarations(ret);
     	getLint().typeNotExposedToWeaver.setSuppressed(false);
@@ -200,5 +233,16 @@ public class LTWWorld extends BcelWorld implements IReflectionWorld {
 	public boolean isLocallyDefined(String classname) {
 		return weavingContext.isLocallyDefined(classname);
 	}
+
+	protected ResolvedType completeNonLocalType(ResolvedType ret) {
+		if (ret.isMissing()) return ret; // who knows ?!?
+		ResolvedType toResolve = ret;
+		if (ret.isParameterizedType() || ret.isGenericType()) {
+			toResolve = toResolve.getGenericType();
+		}
+		ReferenceTypeDelegate rtd = resolveReflectionTypeDelegate((ReferenceType)toResolve,loader);
+		((ReferenceType)ret).setDelegate(rtd);
+		return ret;
+	}
 
 }
@@ -130,7 +130,8 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
         }
 
         bcelWorld = new LTWWorld(
-                classLoader, getMessageHandler(), new ICrossReferenceHandler() {
+        		classLoader, weavingContext, // TODO when the world works in terms of the context, we can remove the loader...
+        		getMessageHandler(), new ICrossReferenceHandler() {
                     public void addCrossReference(ISourceLocation from, ISourceLocation to, IRelationship.Kind kind, boolean runtimeTest) {
                         ;// for tools only
                     }
@@ -78,4 +78,19 @@ public class DefaultWeavingContext implements IWeavingContext {
 	public String getSuffix () {
 		return getClassLoaderName();
 	}
+
+	public boolean isLocallyDefined(String classname) {
+        String asResource = classname.replace('.', '/').concat(".class");
+
+        URL localURL = loader.getResource(asResource);
+        if (localURL == null) return false;
+
+		boolean isLocallyDefined = true;
+        ClassLoader parent = loader.getParent();
+        if (parent != null) {
+            URL parentURL = parent.getResource(asResource);
+            if (localURL.equals(parentURL)) isLocallyDefined =  false;
+        } 
+        return isLocallyDefined;
+	}
 }
@@ -142,7 +142,21 @@ public class WeavingContextTest extends TestCase {
 		public Enumeration getResources(String name) throws IOException {
 			return loader.getResources(name);
 		}
-		
+
+		public boolean isLocallyDefined(String classname) {
+	        String asResource = classname.replace('.', '/').concat(".class");
+
+	        URL localURL = loader.getResource(asResource);
+	        if (localURL == null) return false;
+
+			boolean isLocallyDefined = true;
+	        ClassLoader parent = loader.getParent();
+	        if (parent != null) {
+	            URL parentURL = parent.getResource(asResource);
+	            if (localURL.equals(parentURL)) isLocallyDefined =  false;
+	        } 
+	        return isLocallyDefined;
+		}
 	}
 
 	protected void setUp() throws Exception {
@@ -29,6 +29,7 @@ public class LTWTests extends org.aspectj.testing.XMLBasedAjcTestCase {
   protected File getSpecFile() {
     return new File("../tests/src/org/aspectj/systemtest/ajc150/ltw/ltw.xml");
   }
+  
 
 
   	public void test001(){
@@ -112,17 +113,31 @@ public class LTWTests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		runTest("JDK14 LTW with ASPECTPATH");  		
   	}
 
-  	// separate bugzilla patch has this one... commented out
-//  	public void testSeparateCompilationDeclareParentsCall() {
-//  		runTest("Separate compilation with ltw: declare parents and call");
-//  	}
-//  	
-//  	public void testChildAspectDoesntWeaveParentDeclareParentsCall() {
-//		setSystemProperty(WeavingAdaptor.WEAVING_ADAPTOR_VERBOSE,"true");
-//		setSystemProperty(WeavingAdaptor.SHOW_WEAVE_INFO_PROPERTY,"true");
-//  		runTest("Child loader aspect won't weave parent loader: declare parents and call");
-//  	}
-  	
+
+    //public void testDiscardingWovenTypes() { 
+    //  runTest("discarding woven types - 1");
+    //}
+      
+    public void testWeavingTargetOfCallAggressivelyInLTW_DeclareParents_pr133770() {
+	  runTest("aggressive ltw - decp");
+    }
+
+    public void testWeavingTargetOfCallAggressivelyInLTW_DeclareParents_pr133770_Deactivate() {
+	  runTest("aggressive ltw - decp - deactivate");
+    }
+
+    public void testWeavingTargetOfCallAggressivelyInLTW_DeclareParents_Nested_pr133770() {
+  	  runTest("aggressive ltw - decp - 2");
+    }
+    
+    public void testWeavingTargetOfCallAggressivelyInLTW_DeclareAnnotation_pr133770() {
+  	  runTest("aggressive ltw - deca");
+    }
+    
+  	public void testSeparateCompilationDeclareParentsCall_pr133770() {
+  		runTest("separate compilation with ltw: declare parents and call");
+  	}
+  	  	
   	/*
   	 * Allow system properties to be set and restored
   	 * TODO maw move to XMLBasedAjcTestCase or RunSpec
@@ -159,5 +174,4 @@ public class LTWTests extends org.aspectj.testing.XMLBasedAjcTestCase {
 			else systemProperties.setProperty(key,value);
 		}
 	}
-}
-
+}
\ No newline at end of file
@@ -109,7 +109,84 @@
             </stderr>
         </run>
     </ajc-test>
+    
+    <!-- type discarding tests, investigating call munging -->
+    
+    <ajc-test dir="ltw/callMunging" title="discarding woven types - 1">
+      <compile files="A.java,B.java,T.java,Main.java" outjar="classes.jar"/>
+      <compile files="X.java" outjar="aspects.jar" classpath="classes.jar" options="-Xlint:ignore"/>
+      <run class="Main" ltw="aop.xml">
+        <stdout>
+          <line text="into:main"/>
+          <line text="A.method() running"/>
+          <line text="advice running"/>
+          <line text="T.m1() running"/>
+          <line text="B.method() running"/>
+          <line text="advice running"/>
+          <line text="T.m2() running"/>
+          <line text="leave:main"/>
+        </stdout>
+      </run>
+    </ajc-test>
+    
+    <ajc-test dir="ltw/callMunging/case1" title="aggressive ltw - decp">
+      <compile files="A.java,T.java,Main.java" outjar="classes.jar"/>
+      <compile files="X.java" outjar="aspects.jar" classpath="classes.jar" options="-Xlint:ignore"/>
+      <run class="Main" ltw="aop.xml">
+        <stdout>
+          <line text="into:main"/>
+          <line text="A.method() running"/>
+          <line text="advice running"/>
+          <line text="T.m1() running"/>
+          <line text="leave:main"/>
+        </stdout>
+      </run>
+    </ajc-test>  
+    
+    <ajc-test dir="ltw/callMunging/case1" title="aggressive ltw - decp - deactivate">
+      <compile files="A.java,T.java,Main.java" outjar="classes.jar"/>
+      <compile files="X.java" outjar="aspects.jar" classpath="classes.jar" options="-Xlint:ignore"/>
+      <run class="Main" ltw="aop2.xml">
+        <stdout>
+          <line text="into:main"/>
+          <line text="A.method() running"/>
+          <line text="T.m1() running"/>
+          <line text="leave:main"/>
+        </stdout>
+      </run>
+    </ajc-test>  
+      
+    <ajc-test dir="ltw/callMunging/case3" title="aggressive ltw - decp - 2">
+      <compile files="A.java,T.java,S.java,Main.java" outjar="classes.jar"/>
+      <compile files="X.java" outjar="aspects.jar" classpath="classes.jar" options="-Xlint:ignore"/>
+      <run class="Main" ltw="aop.xml">
+        <stdout>
+          <line text="into:main"/>
+          <line text="A.method() running"/>
+          <line text="advice running"/>
+          <line text="T.m1() running"/>
+          <line text="leave:main"/>
+        </stdout>
+      </run>
+    </ajc-test>
+    
+    <ajc-test dir="ltw/callMunging/case2" title="aggressive ltw - deca">
+      <compile files="A.java,T.java,Main.java,MarkerAnnotation.java" outjar="classes.jar" options="-1.5"/>
+      <compile files="X.java" outjar="aspects.jar" classpath="classes.jar" options="-1.5 -Xlint:ignore"/>
+      <run class="Main" ltw="aop.xml">
+        <stdout>
+          <line text="into:main"/>
+          <line text="A.method() running"/>
+          <line text="advice running"/>
+          <line text="T.m1() running"/>
+          <line text="leave:main"/>
+        </stdout>
+      </run>
+    </ajc-test>
+    
+    
 
+    <!-- end of discarding type tests -->
 
 	<ajc-test dir="ltw"
       title="Define concrete sub-aspect using aop.xml"
@@ -270,6 +347,23 @@
         </run>
     </ajc-test>
 
+	<ajc-test dir="ltw/hier" title="separate compilation with ltw: declare parents and call" keywords="ltw">
+        <compile files="util/A.aj,util/T.aj"/>
+        <compile files="child/Executor.aj,child/Advisor.aj,top/SimpleMain.aj">
+        	<message kind="warning" text="this affected type is not exposed to the weaver: util.A"/>
+		</compile>        
+        <run class="top.SimpleMain" ltw="aop-single.xml">
+        	<stdout>
+                <line text="T call"/>
+        	</stdout>
+        	<stderr>
+				<line text="weaveinfo Join point 'method-call(void util.A.foo())' in Type 'child.Executor' (Executor.aj:18) advised by before advice from 'child.Advisor' (Advisor.aj:20)"/>
+        	    <line text="weaveinfo Extending interface set for type 'util.A' (A.aj) to include 'util.T' (Advisor.aj)"/>
+        	    <line text="weaveinfo Extending interface set for type 'child.Advisor' (Advisor.aj) to include 'util.T' (Advisor.aj)"/>
+        	</stderr>
+        </run>
+    </ajc-test>
+    
 	<ajc-test dir="ltw"
       title="Warning when advice doesn't match suppressed for LTW"
       keywords="xlint, ltw">
@@ -427,71 +521,6 @@
         </run>
     </ajc-test>
 
-<!--    
-commented out: reported in another bugzilla bug...
-
-	<ajc-test dir="ltw/hier"
-      title="Separate compilation with ltw: declare parents and call"
-      keywords="ltw">
-        <compile
-        	files="util/A.aj,util/T.aj"
-        />
-        <compile
-        	files="child/Executor.aj,child/Advisor.aj,top/SimpleMain.aj"
-        >
-        	<message kind="warning" text="this affected type is not exposed to the weaver: util.A"/>
-		</compile>        
-        <run class="top.SimpleMain" ltw="aop-single.xml">
-        	<stdout>
-                <line text="T call"/>
-        	</stdout>
-        	<stderr>
-        	    <line text="weaveinfo Extending interface set for type 'util.A' (A.aj) to include 'util.T' (Advisor.aj)"/>
-	        	< - - TODO: fix up any errors in the expected output when the join point actually matches - - >
-				<line text="weaveinfo Join point 'method-call(void A.foo())' in Type 'child.Executor' (Executor.aj:19) advised by before advice from 'child.Advisor' (Advisor.aj:20)"/>
-        	</stderr>
-        </run>
-    </ajc-test>
-
-	<ajc-test dir="ltw/hier"
-      title="Child loader aspect won't weave parent loader: declare parents and call"
-      keywords="ltw">
-        <compile
-        	files="top/HierMain.aj"
-        />
-        <compile
-        	files="util/A.aj,util/T.aj"
-			outjar="util.jar"
-        />
-        <compile
-        	files="child/Executor.aj,child/Advisor.aj"
-        	classpath="util.jar"
-            options="-outxml"
-            outjar="child.zip"
-        >
-        	<message kind="warning" text="this affected type is not exposed to the weaver: util.A"/>
-		</compile>        
-		< - - limitation: to turn on load-time weaving we HAVE to have a top-level aop.xml file
-		   since we don't want any top-level aspects, we deploy an empty one! 
-		   the important aop.xml file in this test was created with -outxml and lives in child.jar - - >
-        <run class="top.HierMain" ltw="null-aop.xml">
-        	<stdout/>
-        	<stderr>
-                <line text="info AspectJ Weaver Version"/>
-                <line text="info register classloader"/>
-                <line text="info using"/>
-	        	<line text="info weaving 'top.HierMain'"/>
-                <line text="info AspectJ Weaver Version"/>
-                <line text="info register classloader"/>
-                <line text="info using"/>
-                <line text="info using file:"/>
-                <line text="info register aspect child.Advisor"/>
-                <line text="info weaving 'child.Executor'"/>
-                <line text="info weaving 'util.A'"/>
-        	</stderr>
-        </run>
-    </ajc-test>
--->
 	<ajc-test dir="ltw" title="JDK14 LTW with XML" keywords="ltw">
         <compile files="HelloWorld.java" options="-outjar hello.jar"/>
         <compile files="ExceptionHandler.aj" options="-outxml -outjar handler.jar"/>
@@ -109,6 +109,7 @@ public abstract class World implements Dump.INode {
     private boolean fastDelegateSupportEnabled = isASMAround;
 	private boolean runMinimalMemory = false;
 	private boolean shouldPipelineCompilation = true;
+	private boolean completeBinaryTypes = true;
 	public boolean forDEBUG_structuralChangesCode = false;
 	public boolean forDEBUG_bridgingCode = false;
 
@@ -267,6 +268,24 @@ public abstract class World implements Dump.INode {
             if (!allowMissing && ret.isMissing()) {
                 ret = handleRequiredMissingTypeDuringResolution(ty);
             }
+            
+            if (completeBinaryTypes && needsCompletion() && isLocallyDefined(ret.getName())) {
+            	if (typeCompletionInProgress) {
+            		typesForCompletion.add(ret);
+            	} else {                	
+            		try {
+            			typeCompletionInProgress=true;
+                		completeType(ret);
+            		} finally {
+            			typeCompletionInProgress=false;
+            		}
+	            	while (typesForCompletion.size()!=0) {
+	            		ResolvedType rt = (ResolvedType)typesForCompletion.get(0);
+	            		completeType(rt);
+	            		typesForCompletion.remove(0);
+	            	}
+            	}
+            }
         }        
 
 		// Pulling in the type may have already put the right entry in the map
@@ -275,7 +294,42 @@ public abstract class World implements Dump.INode {
 		}
         return ret;
     }
+    
+    // --- these methods are for supporting loadtime weaving with inter type declarations
+    // the idea is that when types are resolved, we give the world a chance to say whether
+    // it needs to 'finish them off' - ie. attach type mungers for ITDs.  These types won't
+    // actually get woven at this time, they will merely have type mungers attached to them
+    // for the purposes of answering questions like 'what is your supertype?' correctly.
+
+    /**
+     * return true if types need completing when getting resolved - overridden by subtypes.
+     */
+    protected boolean needsCompletion() {
+		return false;
+	}
+    
+	/**
+     * Called when a type is resolved - enables its type hierarchy to be finished off before we
+     * proceed
+     */
+    protected void completeType(ResolvedType ret) {}
+    
+    
+    /**
+     * Return true if the classloader relating to this world is definetly the one that will
+     * define the specified class.  Return false otherwise or we don't know for certain.
+     */
+    public boolean isLocallyDefined(String classname) {
+    	return false;
+    }
 
+    // One type is completed at a time, if multiple need doing then they
+    // are queued up
+	private boolean typeCompletionInProgress = false;
+    private List/*ResolvedType*/typesForCompletion = new ArrayList();
+    
+    // ---
+    
     /**
      * We tried to resolve a type and couldn't find it...
      */
@@ -765,8 +819,10 @@ public abstract class World implements Dump.INode {
 	public final static String xsetRUN_MINIMAL_MEMORY ="runMinimalMemory"; // default true
 	public final static String xsetDEBUG_STRUCTURAL_CHANGES_CODE = "debugStructuralChangesCode"; // default false
 	public final static String xsetDEBUG_BRIDGING = "debugBridging"; // default false
-	public final static String xsetPIPELINE_COMPILATION = "pipelineCompilation"; // default true
+	public final static String xsetPIPELINE_COMPILATION = "pipelineCompilation";
 	public final static String xsetPIPELINE_COMPILATION_DEFAULT = "true"; 
+	public final static String xsetCOMPLETE_BINARY_TYPES = "completeBinaryTypes";
+	public final static String xsetCOMPLETE_BINARY_TYPES_DEFAULT = "true"; 
 
 	public boolean isInJava5Mode() {
 		return behaveInJava5Way;
@@ -1153,6 +1209,12 @@ public abstract class World implements Dump.INode {
 
 				String s = p.getProperty(xsetPIPELINE_COMPILATION,xsetPIPELINE_COMPILATION_DEFAULT);
 				shouldPipelineCompilation = s.equalsIgnoreCase("true");
+
+				s = p.getProperty(xsetCOMPLETE_BINARY_TYPES,xsetCOMPLETE_BINARY_TYPES_DEFAULT);
+				completeBinaryTypes = s.equalsIgnoreCase("true");
+				if (!completeBinaryTypes) {
+					getMessageHandler().handleMessage(MessageUtil.info("[completeBinaryTypes=false] Completion of binary types deactivated"));
+				}
 
 				s = p.getProperty(xsetRUN_MINIMAL_MEMORY,"false");
         		runMinimalMemory = s.equalsIgnoreCase("true");
@@ -1206,4 +1268,4 @@ public abstract class World implements Dump.INode {
 	    public boolean isASMAround() { 
 	    	return isASMAround;
 	    }
-}
+}
\ No newline at end of file
@@ -53,11 +53,14 @@ import org.aspectj.bridge.IMessageHandler;
 import org.aspectj.weaver.Advice;
 import org.aspectj.weaver.AdviceKind;
 import org.aspectj.weaver.AjAttribute;
+import org.aspectj.weaver.AnnotationOnTypeMunger;
+import org.aspectj.weaver.AnnotationX;
 import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.ConcreteTypeMunger;
 import org.aspectj.weaver.ICrossReferenceHandler;
 import org.aspectj.weaver.Member;
 import org.aspectj.weaver.MemberImpl;
+import org.aspectj.weaver.NewParentTypeMunger;
 import org.aspectj.weaver.ReferenceType;
 import org.aspectj.weaver.ReferenceTypeDelegate;
 import org.aspectj.weaver.ResolvedMember;
@@ -68,6 +71,8 @@ import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.AjAttribute.Aspect;
 import org.aspectj.weaver.asm.AsmDelegate;
+import org.aspectj.weaver.patterns.DeclareAnnotation;
+import org.aspectj.weaver.patterns.DeclareParents;
 import org.aspectj.weaver.patterns.FormalBinding;
 import org.aspectj.weaver.patterns.PerClause;
 import org.aspectj.weaver.patterns.Pointcut;
@@ -719,4 +724,127 @@ public class BcelWorld extends World implements Repository {
             return true;
         }
     }
+
+    /**
+	 * Apply a single declare parents - return true if we change the type
+	 */
+	private boolean applyDeclareParents(DeclareParents p, ResolvedType onType) {
+		boolean didSomething = false;
+		List newParents = p.findMatchingNewParents(onType,true);
+		if (!newParents.isEmpty()) {
+			didSomething=true;
+			BcelObjectType classType = BcelWorld.getBcelObjectType(onType);
+			//System.err.println("need to do declare parents for: " + onType);
+			for (Iterator j = newParents.iterator(); j.hasNext(); ) {
+				ResolvedType newParent = (ResolvedType)j.next();
+				                                        
+				// We set it here so that the imminent matching for ITDs can succeed - we 
+		        // still haven't done the necessary changes to the class file itself 
+		        // (like transform super calls) - that is done in BcelTypeMunger.mungeNewParent()
+				classType.addParent(newParent);
+				ResolvedTypeMunger newParentMunger = new NewParentTypeMunger(newParent);
+		        newParentMunger.setSourceLocation(p.getSourceLocation());
+				onType.addInterTypeMunger(new BcelTypeMunger(newParentMunger, getCrosscuttingMembersSet().findAspectDeclaringParents(p)));
+			}
+		}
+		return didSomething;
+	}
+    
+	/**
+	 * Apply a declare @type - return true if we change the type
+	 */
+	private boolean applyDeclareAtType(DeclareAnnotation decA, ResolvedType onType,boolean reportProblems) {
+		boolean didSomething = false;
+		if (decA.matches(onType)) {
+			
+		    if (onType.hasAnnotation(decA.getAnnotationX().getSignature())) {
+		      // already has it
+		      return false;
+		    }
+			
+			AnnotationX annoX = decA.getAnnotationX();
+			
+			// check the annotation is suitable for the target
+			boolean isOK = checkTargetOK(decA,onType,annoX);
+
+			if (isOK) {
+				didSomething = true;
+				ResolvedTypeMunger newAnnotationTM = new AnnotationOnTypeMunger(annoX);
+				newAnnotationTM.setSourceLocation(decA.getSourceLocation());
+				onType.addInterTypeMunger(new BcelTypeMunger(newAnnotationTM,decA.getAspect().resolve(this)));
+				decA.copyAnnotationTo(onType);
+			}
+		}
+		return didSomething;
+	}
+
+	/**
+	 * Checks for an @target() on the annotation and if found ensures it allows the annotation
+	 * to be attached to the target type that matched.
+	 */
+	private boolean checkTargetOK(DeclareAnnotation decA, ResolvedType onType, AnnotationX annoX) {
+		if (annoX.specifiesTarget()) {
+		  if (  (onType.isAnnotation() && !annoX.allowedOnAnnotationType()) ||
+		  		(!annoX.allowedOnRegularType())) {
+			  return false;
+		  }
+		}
+		return true;
+	}
+	
+	// Hmmm - very similar to the code in BcelWeaver.weaveParentTypeMungers - this code
+	// doesn't need to produce errors/warnings though as it won't really be weaving.
+	protected void weaveInterTypeDeclarations(ResolvedType onType) {
+		
+		List declareParentsList = getCrosscuttingMembersSet().getDeclareParents();
+		if (onType.isRawType()) onType = onType.getGenericType();
+		onType.clearInterTypeMungers(); 
+		
+		List decpToRepeat = new ArrayList();
+
+		boolean aParentChangeOccurred      = false;
+		boolean anAnnotationChangeOccurred = false;
+		// First pass - apply all decp mungers
+		for (Iterator i = declareParentsList.iterator(); i.hasNext(); ) {
+			DeclareParents decp = (DeclareParents)i.next();
+			boolean typeChanged = applyDeclareParents(decp,onType);
+			if (typeChanged) {
+				aParentChangeOccurred = true;
+			} else { // Perhaps it would have matched if a 'dec @type' had modified the type
+				if (!decp.getChild().isStarAnnotation()) decpToRepeat.add(decp);
+			}
+		}
+
+		// Still first pass - apply all dec @type mungers
+		for (Iterator i = getCrosscuttingMembersSet().getDeclareAnnotationOnTypes().iterator();i.hasNext();) {
+			DeclareAnnotation decA = (DeclareAnnotation)i.next();
+			boolean typeChanged = applyDeclareAtType(decA,onType,true);
+			if (typeChanged) {
+				anAnnotationChangeOccurred = true;
+			}
+		}
+		
+		while ((aParentChangeOccurred || anAnnotationChangeOccurred) && !decpToRepeat.isEmpty()) {
+			anAnnotationChangeOccurred = aParentChangeOccurred = false;
+			List decpToRepeatNextTime = new ArrayList();
+			for (Iterator iter = decpToRepeat.iterator(); iter.hasNext();) {
+				DeclareParents decp = (DeclareParents) iter.next();
+				boolean typeChanged = applyDeclareParents(decp,onType);
+				if (typeChanged) {
+					aParentChangeOccurred = true;
+				} else {
+					decpToRepeatNextTime.add(decp);
+				}
+			}
+			
+			for (Iterator iter = getCrosscuttingMembersSet().getDeclareAnnotationOnTypes().iterator(); iter.hasNext();) {
+				DeclareAnnotation decA = (DeclareAnnotation) iter.next();
+				boolean typeChanged = applyDeclareAtType(decA,onType,false);
+				if (typeChanged) {
+					anAnnotationChangeOccurred = true;
+				}
+			}
+			decpToRepeat = decpToRepeatNextTime;
+		}
+    }
 }
\ No newline at end of file
@@ -24,6 +24,7 @@ import org.aspectj.weaver.ReferenceType;
 import org.aspectj.weaver.ReferenceTypeDelegate;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.bcel.BcelWorld;
+import org.aspectj.weaver.loadtime.IWeavingContext;
 import org.aspectj.weaver.reflect.AnnotationFinder;
 import org.aspectj.weaver.reflect.IReflectionWorld;
 import org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory;
@@ -47,6 +48,7 @@ public class LTWWorld extends BcelWorld implements IReflectionWorld {
 
     private AnnotationFinder annotationFinder;
     private ClassLoader loader; // weavingContext?
+    private IWeavingContext weavingContext;
 
     protected final static Class concurrentMapClass = makeConcurrentMapClass();
     protected static Map/*<String, WeakReference<ReflectionBasedReferenceTypeDelegate>>*/ bootstrapTypes = makeConcurrentMap();
@@ -54,9 +56,10 @@ public class LTWWorld extends BcelWorld implements IReflectionWorld {
     /**
      * Build a World from a ClassLoader, for LTW support
      */
-    public LTWWorld(ClassLoader loader, IMessageHandler handler, ICrossReferenceHandler xrefHandler) {
+    public LTWWorld(ClassLoader loader, IWeavingContext weavingContext, IMessageHandler handler, ICrossReferenceHandler xrefHandler) {
         super(loader, handler, xrefHandler);
         this.loader = loader;
+        this.weavingContext = weavingContext;
 
         setBehaveInJava5Way(LangUtil.is15VMOrGreater());
         annotationFinder = ReflectionWorld.makeAnnotationFinderIfAny(loader, this);
@@ -184,4 +187,18 @@ public class LTWWorld extends BcelWorld implements IReflectionWorld {
 	     return true;
     }
 
+	protected void completeType(ResolvedType ret) {
+    	getLint().typeNotExposedToWeaver.setSuppressed(true);
+    	weaveInterTypeDeclarations(ret);
+    	getLint().typeNotExposedToWeaver.setSuppressed(false);
+	}
+
+	protected boolean needsCompletion() {
+		return true;
+	}
+
+	public boolean isLocallyDefined(String classname) {
+		return weavingContext.isLocallyDefined(classname);
+	}
+    
 }
@@ -62,5 +62,15 @@ public interface IWeavingContext {
 	 * @return short name 
 	 */
 	public String getId ();
+	
+	/**
+	 * Return true if the classloader associated with this weaving context
+	 * is the one that will define the class with the specified name.
+	 * In a delegating classloader hierarchy this might check the parent won't
+	 * define it and the child will - in OSGi it will do something else.
+	 * @param classname name of the class, eg. "java.lang.String"
+	 * @return true if the associated classloader will define the class
+	 */
+	public boolean isLocallyDefined(String classname);
 
 }
@@ -0,0 +1,7 @@
+<aspectj>
+<weaver options="-showWeaveInfo -verbose -Xset:completeBinaryTypes=false"/>
+<aspects>
+<aspect name="X"/>
+</aspects>
+</aspectj>
+
@@ -0,0 +1,7 @@
+public class A {
+  S s = new S();
+  public void method() {
+	System.out.println("A.method() running");
+    s.m1();
+  }
+}
@@ -0,0 +1,7 @@
+public class B {
+  T t = new T();
+  public void method() {
+	System.out.println("B.method() running");
+    t.m2();
+  }
+}
@@ -0,0 +1,21 @@
+import java.lang.reflect.Method;
+
+public class Main {
+
+  public static void main(String []argv) {
+	  try {
+		  System.out.println("into:main");
+		  Class clazzA = Class.forName("A");
+		  Method clazzAMethod = clazzA.getMethod("method",null);
+		  clazzAMethod.invoke(clazzA.newInstance(),null);
+		  
+		  Class clazzB= Class.forName("B");
+		  Method clazzBMethod = clazzB.getMethod("method",null);
+		  clazzBMethod.invoke(clazzB.newInstance(),null);
+		  System.out.println("leave:main");
+	  } catch (Throwable t) {
+		  t.printStackTrace();
+	  }
+  }
+  
+}
@@ -0,0 +1,6 @@
+public class T {
+
+  public void m1() {System.out.println("T.m1() running");}
+  public void m2() {System.out.println("T.m2() running");}
+
+}
@@ -0,0 +1,9 @@
+import java.io.Serializable;
+
+public aspect X {
+  declare parents: T implements Serializable;
+
+  before(): call(* Serializable+.m*(..)) {
+	 System.out.println("advice running");
+  }
+}
@@ -0,0 +1,7 @@
+<aspectj>
+<weaver options="-showWeaveInfo -verbose"/>
+<aspects>
+<aspect name="X"/>
+</aspects>
+</aspectj>
+
@@ -0,0 +1,7 @@
+public class A {
+  T t = new T();
+  public void method() {
+	System.out.println("A.method() running");
+    t.m1();
+  }
+}
@@ -0,0 +1,17 @@
+import java.lang.reflect.Method;
+
+public class Main {
+
+  public static void main(String []argv) {
+	  try {
+		  System.out.println("into:main");
+		  Class clazzA = Class.forName("A");
+		  Method clazzAMethod = clazzA.getMethod("method",null);
+		  clazzAMethod.invoke(clazzA.newInstance(),null);
+		  System.out.println("leave:main");
+	  } catch (Throwable t) {
+		  t.printStackTrace();
+	  }
+  }
+  
+}
@@ -0,0 +1,3 @@
+public class T {
+  public void m1() {System.out.println("T.m1() running");}
+}
@@ -0,0 +1,9 @@
+import java.io.Serializable;
+
+public aspect X {
+  declare parents: T implements Serializable;
+
+  before(): call(* Serializable+.m*(..)) {
+	 System.out.println("advice running");
+  }
+}
@@ -0,0 +1,7 @@
+<aspectj>
+<weaver options="-showWeaveInfo -verbose"/>
+<aspects>
+<aspect name="X"/>
+</aspects>
+</aspectj>
+
@@ -0,0 +1 @@
+Basic case, where type T needs munging with a declare parents before the join point in A.method() are matched.
\ No newline at end of file
@@ -0,0 +1,7 @@
+public class A {
+  T t = new T();
+  public void method() {
+	System.out.println("A.method() running");
+    t.m1();
+  }
+}
@@ -0,0 +1,17 @@
+import java.lang.reflect.Method;
+
+public class Main {
+
+  public static void main(String []argv) {
+	  try {
+		  System.out.println("into:main");
+		  Class clazzA = Class.forName("A");
+		  Method clazzAMethod = clazzA.getMethod("method",null);
+		  clazzAMethod.invoke(clazzA.newInstance(),null);
+		  System.out.println("leave:main");
+	  } catch (Throwable t) {
+		  t.printStackTrace();
+	  }
+  }
+  
+}
@@ -0,0 +1,3 @@
+import java.lang.annotation.*;
+
+public @interface MarkerAnnotation {}
\ No newline at end of file
@@ -0,0 +1,3 @@
+public class T {
+  public void m1() {System.out.println("T.m1() running");}
+}
@@ -0,0 +1,9 @@
+import java.io.Serializable;
+
+public aspect X {
+  declare @type: T: @MarkerAnnotation;
+
+  before(): call(* (@MarkerAnnotation *).m*(..)) {
+	 System.out.println("advice running");
+  }
+}
@@ -0,0 +1,7 @@
+<aspectj>
+<weaver options="-showWeaveInfo -verbose"/>
+<aspects>
+<aspect name="X"/>
+</aspects>
+</aspectj>
+
@@ -0,0 +1 @@
+Now type T needs munging with a declare annotation 
\ No newline at end of file
@@ -0,0 +1,7 @@
+public class A {
+  S s = new S();
+  public void method() {
+	System.out.println("A.method() running");
+    s.m1();
+  }
+}
@@ -0,0 +1,17 @@
+import java.lang.reflect.Method;
+
+public class Main {
+
+  public static void main(String []argv) {
+	  try {
+		  System.out.println("into:main");
+		  Class clazzA = Class.forName("A");
+		  Method clazzAMethod = clazzA.getMethod("method",null);
+		  clazzAMethod.invoke(clazzA.newInstance(),null);
+		  System.out.println("leave:main");
+	  } catch (Throwable t) {
+		  t.printStackTrace();
+	  }
+  }
+  
+}
@@ -0,0 +1,2 @@
+public class S extends T {
+}
@@ -0,0 +1,3 @@
+public class T {
+  public void m1() {System.out.println("T.m1() running");}
+}
@@ -0,0 +1,9 @@
+import java.io.Serializable;
+
+public aspect X {
+  declare parents: T implements Serializable;
+
+  before(): call(* Serializable+.m*(..)) {
+	 System.out.println("advice running");
+  }
+}
@@ -0,0 +1,7 @@
+<aspectj>
+<weaver options="-showWeaveInfo -verbose"/>
+<aspects>
+<aspect name="X"/>
+</aspects>
+</aspectj>
+
@@ -0,0 +1 @@
+declare parents, but this time there is an extra layer in the hierarchy, A calls S but S extends T and T is decp targeted
\ No newline at end of file
@@ -0,0 +1,7 @@
+<aspectj>
+  <weaver options="-showWeaveInfo"/>
+  <aspects>
+    <aspect name="child.Advisor"/>
+  </aspects>
+</aspectj>
+
@@ -0,0 +1,23 @@
+/*******************************************************************************
+ * Copyright (c) 2006 Contributors.
+ * All rights reserved.
+ * This program and the accompanying materials are made available
+ * under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution and is available at
+ * http://eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ * Ron Bodkin
+ */
+package child;
+
+import util.A;
+import util.T;
+
+aspect Advisor {
+	declare parents: A* implements T;
+
+	before() : call(* T+.*(..)) {
+		System.out.println("T call");
+	}
+}
@@ -0,0 +1,20 @@
+/*******************************************************************************
+ * Copyright (c) 2006 Contributors.
+ * All rights reserved.
+ * This program and the accompanying materials are made available
+ * under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution and is available at
+ * http://eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ * Ron Bodkin
+ */
+package child;
+
+import util.A;
+
+public class Executor implements Runnable {
+   public void run() {
+      new A().foo();
+   }
+}
@@ -0,0 +1,2 @@
+<!-- empty aop.xml file. Used to turn on load-time weaving with no aspects defined at top-level -->
+<aspectj/>
@@ -0,0 +1,18 @@
+/*******************************************************************************
+ * Copyright (c) 2006 Contributors.
+ * All rights reserved.
+ * This program and the accompanying materials are made available
+ * under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution and is available at
+ * http://eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ * Ron Bodkin
+ */
+package top;
+
+public class SimpleMain {
+   public static void main(String args[]) throws Exception {
+      new child.Executor().run();
+   }
+}
@@ -0,0 +1,16 @@
+/*******************************************************************************
+ * Copyright (c) 2006 Contributors.
+ * All rights reserved.
+ * This program and the accompanying materials are made available
+ * under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution and is available at
+ * http://eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ * Ron Bodkin
+ */
+package util;
+
+public class A {
+    public void foo() {}
+}
@@ -0,0 +1,14 @@
+/*******************************************************************************
+ * Copyright (c) 2006 Contributors.
+ * All rights reserved.
+ * This program and the accompanying materials are made available
+ * under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution and is available at
+ * http://eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ * Ron Bodkin
+ */
+package util;
+
+public interface T {}
