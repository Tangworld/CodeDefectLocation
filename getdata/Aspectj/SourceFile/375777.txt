@@ -639,7 +639,7 @@ public class ReferenceType extends ResolvedType {
 		}
 		ResolvedType[] delegateInterfaces = getDelegate().getDeclaredInterfaces();
 		if (isRawType()) {
-			if (newInterfaces != null) {
+			if (newInterfaces != null) {// debug 375777
 				throw new IllegalStateException(
 						"The raw type should never be accumulating new interfaces, they should be on the generic type.  Type is "
 								+ this.getName());
@@ -976,6 +976,11 @@ public class ReferenceType extends ResolvedType {
 		if (typeKind == TypeKind.SIMPLE) {
 			typeKind = TypeKind.RAW;
 			signatureErasure = signature;
+			if (newInterfaces != null) { // debug 375777
+				throw new IllegalStateException(
+						"Simple type promoted to raw, but simple type had new interfaces/superclass.  Type is "
+								+ this.getName());
+			}
 		}
 		if (typeKind == TypeKind.RAW) {
 			genericType.addDependentType(this);
@@ -1131,4 +1136,8 @@ public class ReferenceType extends ResolvedType {
 		return null;
 	}
 
+	public boolean hasNewInterfaces() {
+		return newInterfaces!=null;
+	}
+
 }
\ No newline at end of file
@@ -487,6 +487,11 @@ public abstract class World implements Dump.INode {
 			if (delegate.isGeneric() && behaveInJava5Way) {
 				// ======== raw type ===========
 				simpleOrRawType.typeKind = TypeKind.RAW;
+				if (simpleOrRawType.hasNewInterfaces()) { // debug 375777
+					throw new IllegalStateException(
+							"Simple type promoted forced to raw, but it had new interfaces/superclass.  Type is "
+									+ simpleOrRawType.getName());
+				}
 				ReferenceType genericType = makeGenericTypeFrom(delegate, simpleOrRawType);
 				// name =
 				// ReferenceType.fromTypeX(UnresolvedType.forRawTypeNames(
@@ -567,14 +567,19 @@ public abstract class World implements Dump.INode {
 	 */
 	private ReferenceType resolveGenericWildcardFor(WildcardedUnresolvedType aType) {
 		BoundedReferenceType ret = null;
-		// FIXME asc doesnt take account of additional interface bounds (e.g. ?
-		// super R & Serializable - can you do that?)
+		// FIXME asc doesnt take account of additional interface bounds (e.g. ? super R & Serializable - can you do that?)
 		if (aType.isExtends()) {
-			ReferenceType upperBound = (ReferenceType) resolve(aType.getUpperBound());
-			ret = new BoundedReferenceType(upperBound, true, this);
+			ResolvedType resolvedUpperBound = resolve(aType.getUpperBound());
+			if (resolvedUpperBound.isMissing()) {
+				return getWildcard();
+			}
+			ret = new BoundedReferenceType((ReferenceType)resolvedUpperBound, true, this);
 		} else if (aType.isSuper()) {
-			ReferenceType lowerBound = (ReferenceType) resolve(aType.getLowerBound());
-			ret = new BoundedReferenceType(lowerBound, false, this);
+			ResolvedType resolvedLowerBound = resolve(aType.getLowerBound());
+			if (resolvedLowerBound.isMissing()) {
+				return getWildcard();
+			}
+			ret = new BoundedReferenceType((ReferenceType)resolvedLowerBound, false, this);
 		} else {
 			// must be ? on its own!
 			ret = getWildcard();
@@ -1371,6 +1371,9 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 			ReferenceType rt = (ReferenceType) onType;
 			ReferenceTypeDelegate rtd = rt.getDelegate();
 			if (rtd instanceof BcelObjectType) {
+				if (rt.isRawType()) {
+					rt = (ReferenceType)rt.getGenericType();
+				}
 				rt.addParent(parent);
 				// ((BcelObjectType) rtd).addParent(parent);
 			}
@@ -993,7 +993,7 @@ public class ReferenceType extends ResolvedType {
 	}
 
 	@Override
-	public ResolvedType getGenericType() {
+	public ReferenceType getGenericType() {
 		if (isGenericType()) {
 			return this;
 		}
@@ -1053,6 +1053,11 @@ public class ReferenceType extends ResolvedType {
 
 	@Override
 	public void addParent(ResolvedType newParent) {
+		if (this.isRawType()) {
+			throw new IllegalStateException(
+					"The raw type should never be accumulating new interfaces, they should be on the generic type.  Type is "
+							+ this.getName());
+		}
 		if (newParent.isClass()) {
 			newSuperclass = newParent;
 			superclassReference = new WeakReference<ResolvedType>(null);
@@ -2383,7 +2383,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 	 * 
 	 * @return
 	 */
-	public ResolvedType getGenericType() {
+	public ReferenceType getGenericType() {
 		// if (!(isParameterizedType() || isRawType()))
 		// throw new BCException("The type " + getBaseName() + " is not parameterized or raw - it has no generic type");
 		return null;
@@ -567,14 +567,19 @@ public abstract class World implements Dump.INode {
 	 */
 	private ReferenceType resolveGenericWildcardFor(WildcardedUnresolvedType aType) {
 		BoundedReferenceType ret = null;
-		// FIXME asc doesnt take account of additional interface bounds (e.g. ?
-		// super R & Serializable - can you do that?)
+		// FIXME asc doesnt take account of additional interface bounds (e.g. ? super R & Serializable - can you do that?)
 		if (aType.isExtends()) {
-			ReferenceType upperBound = (ReferenceType) resolve(aType.getUpperBound());
-			ret = new BoundedReferenceType(upperBound, true, this);
+			ResolvedType resolvedUpperBound = resolve(aType.getUpperBound());
+			if (resolvedUpperBound.isMissing()) {
+				return getWildcard();
+			}
+			ret = new BoundedReferenceType((ReferenceType)resolvedUpperBound, true, this);
 		} else if (aType.isSuper()) {
-			ReferenceType lowerBound = (ReferenceType) resolve(aType.getLowerBound());
-			ret = new BoundedReferenceType(lowerBound, false, this);
+			ResolvedType resolvedLowerBound = resolve(aType.getLowerBound());
+			if (resolvedLowerBound.isMissing()) {
+				return getWildcard();
+			}
+			ret = new BoundedReferenceType((ReferenceType)resolvedLowerBound, false, this);
 		} else {
 			// must be ? on its own!
 			ret = getWildcard();
@@ -1371,6 +1371,9 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 			ReferenceType rt = (ReferenceType) onType;
 			ReferenceTypeDelegate rtd = rt.getDelegate();
 			if (rtd instanceof BcelObjectType) {
+				if (rt.isRawType()) {
+					rt = (ReferenceType)rt.getGenericType();
+				}
 				rt.addParent(parent);
 				// ((BcelObjectType) rtd).addParent(parent);
 			}
@@ -993,7 +993,7 @@ public class ReferenceType extends ResolvedType {
 	}
 
 	@Override
-	public ResolvedType getGenericType() {
+	public ReferenceType getGenericType() {
 		if (isGenericType()) {
 			return this;
 		}
@@ -1053,6 +1053,11 @@ public class ReferenceType extends ResolvedType {
 
 	@Override
 	public void addParent(ResolvedType newParent) {
+		if (this.isRawType()) {
+			throw new IllegalStateException(
+					"The raw type should never be accumulating new interfaces, they should be on the generic type.  Type is "
+							+ this.getName());
+		}
 		if (newParent.isClass()) {
 			newSuperclass = newParent;
 			superclassReference = new WeakReference<ResolvedType>(null);
@@ -2383,7 +2383,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 	 * 
 	 * @return
 	 */
-	public ResolvedType getGenericType() {
+	public ReferenceType getGenericType() {
 		// if (!(isParameterizedType() || isRawType()))
 		// throw new BCException("The type " + getBaseName() + " is not parameterized or raw - it has no generic type");
 		return null;
