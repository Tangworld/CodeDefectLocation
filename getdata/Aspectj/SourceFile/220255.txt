@@ -819,9 +819,10 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 			// on the weaver type temporarily
 			ResolvedType theTargetType = factory.fromEclipse(sourceType);
 			TypeBinding theAnnotationType = toAdd[0].resolvedType;
-			String name = new String(theAnnotationType.qualifiedPackageName())+"."+new String(theAnnotationType.sourceName());
 			String sig = new String(theAnnotationType.signature());
-			if (theTargetType.hasAnnotation(UnresolvedType.forSignature(sig))) {
+			UnresolvedType bcelAnnotationType = UnresolvedType.forSignature(sig);
+			String name = bcelAnnotationType.getName();
+			if (theTargetType.hasAnnotation(bcelAnnotationType)) {
 				CompilationAndWeavingContext.leavingPhase(tok);
 				return false;
 			}
@@ -665,6 +665,18 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		build("PR115251");
 		checkWasFullBuild();  // back to the source
 	}
+	
+
+	public void testPr220255_InfiniteBuildHasMember() {
+		AjdeInteractionTestbed.VERBOSE=true;
+		initialiseProject("pr220255");
+		configureNonStandardCompileOptions("pr220255","-XhasMember");
+		build("pr220255");
+		checkWasFullBuild();
+		alter("pr220255","inc1");
+		build("pr220255");
+		checkWasntFullBuild(); 
+	}
 
 	public void testPr157054() {
 		initialiseProject("PR157054");
@@ -0,0 +1,5 @@
+
+
+public @interface BussFacade {
+
+}
@@ -0,0 +1,30 @@
+
+
+
+
+@NeedsXYZ
+public class ClientCode
+{
+
+    MyInterface __Interface__ = null;
+    
+    ClientProxy specialConfigProxy = new ClientProxy();
+    
+    
+    void doIt() {
+        System.out.println("hold onto your hat...");
+        System.out.println("the answer is:"+ __Interface__.doB(42));   // direct Call is intercepted here
+        
+        System.out.println("and now, "
+                          + specialConfigProxy.additionalValueServiceForTheCustomer()
+                          );                                         //   indirect call is intercepted in the proxy
+    }
+    
+    
+    
+    public static void main(String[] args) {
+        
+        new ClientCode().doIt();
+    
+    }
+}
@@ -0,0 +1,18 @@
+
+
+public class ClientProxy extends MyServiceImpl
+{
+    
+    // just for this demo here; this cast allows
+    // us to call to the interface (without the cast
+    // we'd get a class cast exception)
+    MyInterface this_in_disguise = this;
+    
+    
+    @Clientside
+    public String additionalValueServiceForTheCustomer() {
+        return "if you don't know what to ask, then you " 
+             + this_in_disguise.doA(42); // call through to the server side
+    }
+
+}
@@ -0,0 +1,6 @@
+
+
+public @interface Clientside {
+
+    
+}
@@ -0,0 +1,5 @@
+
+
+public @interface Factory {
+
+}
@@ -0,0 +1,23 @@
+
+
+
+// NOTE: the presence of this Aspect, together with ServiceCall.aj
+// seems to trigger the infinite loop on the second or third re-build.
+//
+// Sometimes it triggered even if the @NeedsXYZ isn't used at all
+
+public aspect FactoryMarker
+{
+    
+    public interface BootSpringKontext { };
+    
+    declare parents : @NeedsXYZ * implements BootSpringKontext;
+    
+    public Object[] BootSpringKontext.loadXYZ() {
+        return new Object[] {"load it"};
+    }
+    
+    
+    declare @method : Object[] loadXYZ*() : @Factory;
+
+}
@@ -0,0 +1,10 @@
+
+@BussFacade
+public interface MyInterface
+{ 
+    
+    String doA(int lo);
+    
+    String doB(int lolo);
+    
+}
@@ -0,0 +1,15 @@
+
+public class MyServiceImpl implements MyInterface
+{
+
+    public String doA(int lololo) {
+        System.out.println("really did it "+lololo);
+        return "really got it: "+lololo;
+    }
+
+
+    public String doB(int lala) {
+        return doA(lala);
+    }
+
+}
@@ -0,0 +1,4 @@
+
+public @interface NeedsXYZ {
+
+}
@@ -0,0 +1,59 @@
+import org.aspectj.lang.JoinPoint;
+import org.aspectj.lang.Signature;
+
+
+@Clientside
+public aspect ServiceCall
+{
+    
+    public pointcut ServicePoint()
+        : call( * (@BussFacade *).*(..) )
+          && !@within(Clientside)
+          && !@annotation(Clientside)
+          && ( !@within(ServiceImplementation)
+             || @withincode(Clientside)
+             )
+          ;
+   
+    declare @type 
+        : hasmethod(* (@BussFacade *).*(..)) : @ServiceImplementation
+        ;
+        
+    public @interface ServiceImplementation {  }
+        
+        
+    private pointcut call_Service(Object businessFacade)
+        : ServicePoint()
+          && target(businessFacade);
+        
+    
+    protected Object findImpl(Object bussFacade, JoinPoint.StaticPart location) 
+    {
+        Class dienstID;
+        if ( null!=bussFacade )
+            dienstID = bussFacade.getClass();
+        else {
+            Signature sig = location.getSignature();
+            dienstID = sig.getDeclaringType();
+        }
+        Object impl = new MyServiceImpl();  // call ServiceLocator here
+        return impl;
+    }
+
+
+    
+    Object around(Object bussFacade)
+        : call_Service(bussFacade) 
+     {
+        try {
+                Object umgelenkt = findImpl(bussFacade, thisJoinPointStaticPart);
+                Object res = proceed(umgelenkt);
+                return res;
+            }
+            catch(Throwable T) {
+                System.out.println("oh my");
+                throw new RuntimeException(T);
+            }
+     }    
+    
+}
@@ -0,0 +1,8 @@
+
+
+
+@NeedsXYZ
+public class YetAnotherClass
+{
+    
+}
@@ -0,0 +1,15 @@
+
+public class MyServiceImpl implements MyInterface
+{
+ 
+    public String doA(int lololo) {
+        System.out.println("really did it  "+lololo);
+        return "really got it: "+lololo;
+    }
+
+
+    public String doB(int lala) {
+        return doA(lala);
+    }
+
+}
