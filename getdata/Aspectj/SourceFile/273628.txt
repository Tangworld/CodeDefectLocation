@@ -0,0 +1,31 @@
+package p;
+
+import org.aspectj.lang.ProceedingJoinPoint;
+import org.aspectj.lang.annotation.Around;
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.annotation.Pointcut;
+
+@Aspect
+public class AnnotationAspect
+{
+    @Pointcut("if() && execution(@MonitorableMethod public * p..*(..)) && @annotation(MonitorableMethod(api))")
+    public static boolean adviseIfMonitoringPartialAnnotation(ApiDescriptor api) {
+    	return true;
+    }
+
+    @Around("adviseIfMonitoringPartialAnnotation(api)")
+    public Object monitorMethodPerformancePartialAnnotation(ProceedingJoinPoint pjp, ApiDescriptor api)
+	    throws Throwable {
+		System.out.println("Descriptor value: " + api.number);
+		return pjp.proceed();
+    } 
+    
+//	
+//  pointcut p(ApiDescriptor api): if(true) && execution(@MonitorableMethod public * p..*(..)) && @annotation(MonitorableMethod(api));
+//
+//  Object around(ApiDescriptor api): p(api) {
+//		System.out.println("Descriptor value: " + api.number);
+//		return proceed();
+//  }
+	
+}
@@ -0,0 +1,11 @@
+package p;
+
+public enum ApiDescriptor {
+    TARGET_CLASS_TARGET_METHOD(999);
+
+    ApiDescriptor(int number) {
+    	this.number = number;
+    }
+
+    public final int number;
+}
@@ -0,0 +1,11 @@
+package p;
+
+
+public class AspectTargetClass
+{
+    @MonitorableMethod(ApiDescriptor.TARGET_CLASS_TARGET_METHOD)
+    public void aspectTargetMethod()
+    {
+	System.out.println("In target method");
+    }
+}
@@ -0,0 +1,15 @@
+package p;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Inherited
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.METHOD})
+public @interface MonitorableMethod
+{
+    ApiDescriptor value();
+}
@@ -0,0 +1,18 @@
+package p;
+
+public class TestPointcutAnnotationAspect
+{
+    public static void main(String[] args)
+    {
+	AspectTargetClass c = new AspectTargetClass();
+	try
+	{
+	    c.aspectTargetMethod();
+	}
+	catch ( Exception e )
+	{
+	    e.printStackTrace();
+	}
+//	System.exit(0);
+    }
+}
@@ -20,6 +20,10 @@ import org.aspectj.weaver.LintMessage;
 
 public class Ajc165Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testVerifyOnAnnoBind_pr273628() {
+		runTest("verifyerror on anno bind");
+	}
+
 	public void testFunkyPointcut_pr272233() {
 		runTest("funky pointcut");
 	}
@@ -26,5 +26,10 @@
    <ajc-test dir="bugs165/pr271169" title="around call npe">
      <compile files="HypChecksums.java" options="-1.5"/>
    </ajc-test>
+   
+   <ajc-test dir="bugs165/pr273628" title="verifyerror on anno bind">
+     <compile files="AnnotationAspect.java ApiDescriptor.java AspectTargetClass.java MonitorableMethod.java TestPointcutAnnotationAspect.java" options="-1.5"/>
+     <run class="p.TestPointcutAnnotationAspect"/>
+   </ajc-test>
 
 </suite>
\ No newline at end of file
@@ -91,6 +91,15 @@ class AnnotationAccessFieldVar extends BcelVar {
 		}
 	}
 
+	public void insertLoad(InstructionList il, InstructionFactory fact) {
+		// Only possible to do annotation field value extraction at
+		// MethodExecution
+		if (annoAccessor.getKind() != Shadow.MethodExecution) {
+			return;
+		}
+		appendLoadAndConvert(il, fact, annoFieldOfInterest);
+	}
+
 	public String toString() {
 		return super.toString();
 	}
