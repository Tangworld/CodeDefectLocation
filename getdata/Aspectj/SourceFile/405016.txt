@@ -32,6 +32,7 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclarati
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Literal;
@@ -66,6 +67,7 @@ import org.aspectj.weaver.AnnotationTargetKind;
 import org.aspectj.weaver.AnnotationValue;
 import org.aspectj.weaver.ArrayAnnotationValue;
 import org.aspectj.weaver.BCException;
+import org.aspectj.weaver.ClassAnnotationValue;
 import org.aspectj.weaver.EnumAnnotationValue;
 import org.aspectj.weaver.ReferenceType;
 import org.aspectj.weaver.ResolvedMember;
@@ -794,14 +796,28 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 		} else if (annotation instanceof SingleMemberAnnotation) {
 			// this is a single member annotation (one member value)
 			SingleMemberAnnotation singleMemberAnnotation = (SingleMemberAnnotation) annotation;
-			MethodBinding methodBinding = singleMemberAnnotation.memberValuePairs()[0].binding;
-			if (methodBinding == null) {
-				throw new MissingImplementationException(
-						"Please raise an AspectJ bug.  AspectJ does not know how to convert this annotation [" + annotation + "]");
+			MemberValuePair mvp = singleMemberAnnotation.memberValuePairs()[0];
+			if (mvp.value instanceof ArrayInitializer) {
+				ArrayInitializer arrayInitializer = (ArrayInitializer) mvp.value;
+				Expression[] expressions = arrayInitializer.expressions;
+				AnnotationValue[] arrayValues = new AnnotationValue[expressions.length];
+				for (int e = 0; e < expressions.length; e++) {
+					arrayValues[e] = generateElementValue(expressions[e],
+							((ArrayBinding) arrayInitializer.resolvedType).leafComponentType);
+				}
+				AnnotationValue array = new ArrayAnnotationValue(arrayValues);
+				AnnotationNameValuePair anvp = new AnnotationNameValuePair(new String(mvp.name), array);
+				annotationAJ.addNameValuePair(anvp);
 			} else {
-				AnnotationValue av = generateElementValue(singleMemberAnnotation.memberValue, methodBinding.returnType);
-				annotationAJ.addNameValuePair(new AnnotationNameValuePair(new String(
-						singleMemberAnnotation.memberValuePairs()[0].name), av));
+				MethodBinding methodBinding = mvp.binding;
+				if (methodBinding == null) {
+					throw new MissingImplementationException(
+							"Please raise an AspectJ bug.  AspectJ does not know how to convert this annotation [" + annotation + "]");
+				} else {
+					AnnotationValue av = generateElementValue(singleMemberAnnotation.memberValue, methodBinding.returnType);
+					annotationAJ.addNameValuePair(new AnnotationNameValuePair(new String(
+							singleMemberAnnotation.memberValuePairs()[0].name), av));
+				}
 			}
 		} else if (annotation instanceof MarkerAnnotation) {
 			return;
@@ -873,6 +889,13 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 				throw new MissingImplementationException(
 						"Please raise an AspectJ bug.  AspectJ does not know how to convert this annotation value [" + defaultValue
 								+ "]");
+			} else if (defaultValue instanceof ClassLiteralAccess) {
+				ClassLiteralAccess cla = (ClassLiteralAccess)defaultValue;
+				TypeBinding claTargetType = cla.targetType;
+//				ResolvedType classLiteralType = factory.fromTypeBindingToRTX(defaultValueBinding);
+				String classLiteralSig = new String(claTargetType.signature());
+				AnnotationValue classValue = new ClassAnnotationValue(classLiteralSig);
+				return classValue;
 			} else if (defaultValueBinding.isAnnotationType()) {
 				if (defaultValue instanceof MarkerAnnotation) {
 					ResolvedType ajAnnotationType = factory.fromTypeBindingToRTX(defaultValueBinding);
@@ -201,7 +201,7 @@ public class WildAnnotationTypePattern extends AnnotationTypePattern {
 						}
 					} else if (t.equals(ResolvedType.JL_STRING)) {
 						// nothing to do, it will be OK
-					} else if (t.equals(ResolvedType.JL_CLASS)) {
+					} else if (t.equals(ResolvedType.JL_CLASS) || (t.isParameterizedOrGenericType() && t.getRawType().equals(ResolvedType.JL_CLASS))) {
 						String typename = v.substring(0, v.lastIndexOf('.')); // strip off '.class'
 						ResolvedType rt = scope.lookupType(typename, this).resolve(scope.getWorld());
 						if (rt.isMissing()) {
@@ -227,6 +227,17 @@ public class WildAnnotationTypePattern extends AnnotationTypePattern {
 							}
 							replacementValues.put(k, rt.getSignature());
 							break;
+//						} else if (t.isArray()) {
+							// Looks like {} aren't pseudotokens in the parser so they don't get through for our pointcut parser
+//							// @Foo(value=[Foo.class])
+//							String typename = v.substring(0, v.lastIndexOf('.')); // strip off '.class'
+//							ResolvedType rt = scope.lookupType(typename, this).resolve(scope.getWorld());
+//							if (rt.isMissing()) {
+//								IMessage m = MessageUtil.error("Unable to resolve type '" + v + "' specified for value '" + k + "'",
+//										getSourceLocation());
+//								scope.getWorld().getMessageHandler().handleMessage(m);
+//							}
+//							replacementValues.put(k, rt.getSignature());
 						} else {
 							scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.UNSUPPORTED_ANNOTATION_VALUE_TYPE,t), getSourceLocation()));
 							replacementValues.put(k,"");
@@ -0,0 +1,6 @@
+import java.lang.annotation.*;
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Gimme {
+  Class<?>[] value();
+}
+
@@ -0,0 +1,13 @@
+import java.io.Serializable;
+
+@Gimme({Cloneable.class,java.io.Serializable.class})
+public class Thingy {
+  public static void main(String[] argv) {
+    System.out.println("I am serializable? "+(new Thingy() instanceof Serializable));
+  }
+}
+
+aspect X {
+	//declare parents: Thingy implements Serializable;
+	declare parents: (@Gimme(value = {Cloneable.class, Serializable.class}) *) implements Serializable;
+}
@@ -0,0 +1,6 @@
+import java.lang.annotation.*;
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Gimme {
+  Class<?> value();
+}
+
@@ -0,0 +1,13 @@
+import java.io.Serializable;
+
+@Gimme(Serializable.class)
+public class Thingy {
+  public static void main(String[] argv) {
+    System.out.println("I am serializable? "+(new Thingy() instanceof Serializable));
+  }
+}
+
+aspect X {
+	//declare parents: Thingy implements Serializable;
+	declare parents: (@Gimme(value = Serializable.class) *) implements Serializable;
+}
@@ -24,6 +24,15 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
  */
 public class Ajc173Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testClassAnnoValue_405016_1() throws Exception {
+		// test that class literals allowed
+		runTest("class anno value 1");
+	}
+
+//	public void testClassAnnoValue_405016() throws Exception {
+//		runTest("class anno value");
+//	}
+
 	public void testAbstractMethodError_404601() throws Exception {
 		runTest("abstract method error");
 	}
@@ -2,6 +2,28 @@
 
 <suite>
 
+	<ajc-test dir="bugs173/pr405016/one" title="class anno value 1">
+		<compile files="Gimme.java Thingy.java" options="-1.5 -showWeaveInfo">
+			<message kind="weave" text="Extending interface set for type 'Thingy' (Thingy.java) to include 'java.io.Serializable' (Thingy.java)"/>
+		</compile>
+		<run class="Thingy">
+			<stdout>
+				<line text="I am serializable? true"/>
+			</stdout>
+		</run>
+	</ajc-test>
+	
+	<ajc-test dir="bugs173/pr405016" title="class anno value">
+		<compile files="Gimme.java Thingy.java" options="-1.5 -showWeaveInfo">
+			<message kind="weave" text="Extending interface set for type 'Thingy' (Thingy.java) to include 'java.io.Serializable' (Thingy.java)"/>
+		</compile>
+		<run class="Thingy">
+			<stdout>
+				<line text="I am serializable? true"/>
+			</stdout>
+		</run>
+	</ajc-test>
+	
 	<ajc-test dir="bugs173/pr404601" title="abstract method error">
 		<compile files="user/IUser.java user/Test.java user/UserTrait.java user/Youser.java" options="-1.5">
 			<message kind="error" text="private intertype declaration 'void UserTrait$I.testSetUsername(java.lang.String)' clashes with public member 'void Youser.testSetUsername(java.lang.String)'"/>
