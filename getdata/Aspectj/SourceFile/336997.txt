@@ -41,7 +41,7 @@ public class TypeVariable {
 	private int declaringElementKind = UNKNOWN;
 	private TypeVariableDeclaringElement declaringElement;
 	// whether or not the bounds of this type variable have been resolved
-	private boolean isResolved = false;
+	public boolean isResolved = false;
 	// Is this type variable in the process of being resolved (allows for something self-referential like Enum)
 	private boolean beingResolved = false;
 
@@ -212,9 +212,9 @@ public class TypeVariable {
 
 	// only used when resolving
 	public void setAdditionalInterfaceBounds(UnresolvedType[] superInterfaces) {
-		if (isResolved) {
-			throw new IllegalStateException("Why set this late?");
-		}
+		// if (isResolved) {
+		// throw new IllegalStateException("Why set this late?");
+		// }
 		this.firstbound = null;
 		this.superInterfaces = superInterfaces;
 	}
@@ -68,7 +68,8 @@ public class TypeVariableReferenceType extends ReferenceType implements TypeVari
 	}
 
 	public TypeVariable getTypeVariable() {
-		// if (!fixedUp) throw new BCException("ARGH"); // fix it up now?
+		// if (!fixedUp)
+		// throw new BCException("ARGH"); // fix it up now?
 		return typeVariable;
 	}
 
@@ -132,4 +133,20 @@ public class TypeVariableReferenceType extends ReferenceType implements TypeVari
 		return (ReferenceType) typeVariable.resolve(world).getUpperBound();
 	}
 
+	/**
+	 * resolve the type variable we are managing and then return this object. 'this' is already a ResolvedType but the type variable
+	 * may transition from a not-resolved to a resolved state.
+	 */
+	public ResolvedType resolve(World world) {
+		typeVariable.resolve(world);
+		return this;
+	}
+
+	/**
+	 * @return true if the type variable this reference is managing is resolved
+	 */
+	public boolean isTypeVariableResolved() {
+		return typeVariable.isResolved;
+	}
+
 }
@@ -264,7 +264,11 @@ public abstract class World implements Dump.INode {
 		if (ty instanceof ResolvedType) {
 			ResolvedType rty = (ResolvedType) ty;
 			rty = resolve(rty);
-			return rty;
+			// A TypeVariableReferenceType may look like it is resolved (it extends ResolvedType) but the internal
+			// type variable may not yet have been resolved
+			if (!rty.isTypeVariableReference() || ((TypeVariableReferenceType) rty).isTypeVariableResolved()) {
+				return rty;
+			}
 		}
 
 		// dispatch back to the type variable reference to resolve its
