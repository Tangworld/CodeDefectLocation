@@ -17,44 +17,44 @@ import java.security.ProtectionDomain;
 
 /**
  * Java 1.5 adapter for class pre processor
- *
+ * 
  * @author <a href="mailto:alex@gnilux.com">Alexandre Vasseur</a>
  */
 public class ClassPreProcessorAgentAdapter implements ClassFileTransformer {
 
-    /**
-     * Concrete preprocessor.
-     */
-    private static ClassPreProcessor s_preProcessor;
+	/**
+	 * Concrete preprocessor.
+	 */
+	private static ClassPreProcessor s_preProcessor;
 
-    static {
-        try {
-            s_preProcessor = new Aj();
-            s_preProcessor.initialize();
-        } catch (Exception e) {
-            throw new ExceptionInInitializerError("could not initialize JSR163 preprocessor due to: " + e.toString());
-        }
-    }
+	static {
+		try {
+			s_preProcessor = new Aj();
+			s_preProcessor.initialize();
+		} catch (Exception e) {
+			throw new ExceptionInInitializerError("could not initialize JSR163 preprocessor due to: " + e.toString());
+		}
+	}
 
-    /**
-     * Weaving delegation
-     *
-     * @param loader              the defining class loader
-     * @param className           the name of class beeing loaded
-     * @param classBeingRedefined when hotswap is called
-     * @param protectionDomain
-     * @param bytes               the bytecode before weaving
-     * @return the weaved bytecode
-     */
-    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,
-                            ProtectionDomain protectionDomain, byte[] bytes) throws IllegalClassFormatException {
-        if (classBeingRedefined == null) {
-            return s_preProcessor.preProcess(className, bytes, loader);
-        } else {
-            //FIXME av for now we skip hotswap. We should think more about that
-            new Exception("AspectJ5 does not weave hotswapped class (" + className + ")").printStackTrace();
-            return bytes;
-        }
-    }
+	/**
+	 * Weaving delegation
+	 * 
+	 * @param loader the defining class loader
+	 * @param className the name of class beeing loaded
+	 * @param classBeingRedefined when hotswap is called
+	 * @param protectionDomain
+	 * @param bytes the bytecode before weaving
+	 * @return the weaved bytecode
+	 */
+	public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain,
+			byte[] bytes) throws IllegalClassFormatException {
+		if (classBeingRedefined == null) {
+			return s_preProcessor.preProcess(className, bytes, loader);
+		} else {
+			// FIXME av for now we skip hotswap. We should think more about that
+			new Exception("AspectJ5 does not weave hotswapped class (" + className + ")").printStackTrace();
+			return bytes;
+		}
+	}
 
 }
@@ -63,6 +63,8 @@ public class Aj implements ClassPreProcessor {
 
 	}
 
+	private final static String deleLoader = "sun.reflect.DelegatingClassLoader";
+
 	/**
 	 * Weave
 	 * 
@@ -72,10 +74,9 @@ public class Aj implements ClassPreProcessor {
 	 * @return weaved bytes
 	 */
 	public byte[] preProcess(String className, byte[] bytes, ClassLoader loader) {
-
 		// TODO AV needs to doc that
-		if (loader == null || className == null) {
-			// skip boot loader or null classes (hibernate)
+		if (loader == null || className == null || loader.getClass().getName().equals(deleLoader)) {
+			// skip boot loader, null classes (hibernate), or those from a reflection loader
 			return bytes;
 		}
 
@@ -220,6 +221,11 @@ public class Aj implements ClassPreProcessor {
 		}
 	}
 
+	static {
+		// pr271840 - touch the types early and outside the locks
+		new ExplicitlyInitializedClassLoaderWeavingAdaptor(new ClassLoaderWeavingAdaptor());
+	}
+
 	/**
 	 * Cache of weaver There is one weaver per classloader
 	 */
@@ -231,21 +237,17 @@ public class Aj implements ClassPreProcessor {
 			ExplicitlyInitializedClassLoaderWeavingAdaptor adaptor = null;
 			AdaptorKey adaptorKey = new AdaptorKey(loader);
 
+			String loaderClassName = loader.getClass().getName();
+
 			synchronized (weavingAdaptors) {
 				checkQ();
 				adaptor = (ExplicitlyInitializedClassLoaderWeavingAdaptor) weavingAdaptors.get(adaptorKey);
 				if (adaptor == null) {
-					String loaderClassName = loader.getClass().getName();
-					if (loaderClassName.equals("sun.reflect.DelegatingClassLoader")) {
-						// we don't weave reflection generated types at all!
-						return null;
-					} else {
-						// create it and put it back in the weavingAdaptors map but avoid any kind of instantiation
-						// within the synchronized block
-						ClassLoaderWeavingAdaptor weavingAdaptor = new ClassLoaderWeavingAdaptor();
-						adaptor = new ExplicitlyInitializedClassLoaderWeavingAdaptor(weavingAdaptor);
-						weavingAdaptors.put(adaptorKey, adaptor);
-					}
+					// create it and put it back in the weavingAdaptors map but avoid any kind of instantiation
+					// within the synchronized block
+					ClassLoaderWeavingAdaptor weavingAdaptor = new ClassLoaderWeavingAdaptor();
+					adaptor = new ExplicitlyInitializedClassLoaderWeavingAdaptor(weavingAdaptor);
+					weavingAdaptors.put(adaptorKey, adaptor);
 				}
 			}
 			// perform the initialization
@@ -37,10 +37,10 @@ import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.Lint.Kind;
+import org.aspectj.weaver.bcel.BcelWeakClassLoaderReference;
 import org.aspectj.weaver.bcel.BcelWeaver;
 import org.aspectj.weaver.bcel.BcelWorld;
 import org.aspectj.weaver.bcel.Utility;
-import org.aspectj.weaver.bcel.BcelWeakClassLoaderReference;
 import org.aspectj.weaver.loadtime.definition.Definition;
 import org.aspectj.weaver.loadtime.definition.DocumentParser;
 import org.aspectj.weaver.ltw.LTWWorld;
@@ -741,12 +741,11 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 			return super.getDumpDir();
 		}
 	}
-	
+
 	/*
 	 * shared classes methods
 	 */
 
-
 	/**
 	 * @return Returns the key.
 	 */
