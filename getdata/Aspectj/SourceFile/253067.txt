@@ -1144,6 +1144,28 @@ public class BcelShadow extends Shadow {
 		}
 	}
 
+	 public Member getRealEnclosingCodeSignature() {
+			return enclosingMethod.getMemberView();
+	 }
+
+	// public Member getEnclosingCodeSignatureForModel() {
+	// if (getKind().isEnclosingKind()) {
+	// return getSignature();
+	// } else if (getKind() == Shadow.PreInitialization) {
+	// // PreInit doesn't enclose code but its signature
+	// // is correctly the signature of the ctor.
+	// return getSignature();
+	// } else if (enclosingShadow == null) {
+	// return getEnclosingMethod().getMemberView();
+	// } else {
+	// if (enclosingShadow.getKind() == Shadow.MethodExecution && enclosingMethod.getEffectiveSignature() != null) {
+	//
+	// } else {
+	// return enclosingShadow.getSignature();
+	// }
+	// }
+	// }
+
 	private InstructionList makeArgsObjectArray() {
 		InstructionFactory fact = getFactory();
 		BcelVar arrayVar = genTempVar(UnresolvedType.OBJECTARRAY);
@@ -38,6 +38,7 @@ import org.aspectj.weaver.Shadow;
 import org.aspectj.weaver.ShadowMunger;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.World;
+import org.aspectj.weaver.bcel.BcelShadow;
 import org.aspectj.weaver.patterns.DeclareErrorOrWarning;
 import org.aspectj.weaver.patterns.Pointcut;
 
@@ -419,8 +420,32 @@ public class AsmRelationshipProvider {
 
 	protected static IProgramElement getNode(AsmManager model, Shadow shadow) {
 		Member enclosingMember = shadow.getEnclosingCodeSignature();
+		// This variant will not be tricked by ITDs that would report they are in the target type already.
+		// This enables us to discover the ITD declaration (in the aspect) and advise it appropriately.
+
+		// Have to be smart here, for a code node within an ITD we want to lookup the declaration of the
+		// ITD in the aspect in order to add the code node at the right place - and not lookup the
+		// ITD as it applies in some target type. Due to the use of effectiveSignature we will find
+		// that shadow.getEnclosingCodeSignature() will return a member representing the ITD as it will
+		// appear in the target type. So here, we do an extra bit of analysis to make sure we
+		// do the right thing in the ITD case.
+		IProgramElement enclosingNode = null;
+		if (shadow instanceof BcelShadow) {
+			Member actualEnclosingMember = ((BcelShadow) shadow).getRealEnclosingCodeSignature();
+
+			UnresolvedType type = enclosingMember.getDeclaringType();
+			UnresolvedType actualType = actualEnclosingMember.getDeclaringType();
+
+			// if these are not the same, it is an ITD and we need to use the latter to lookup
+			if (type.equals(actualType)) {
+				enclosingNode = lookupMember(model.getHierarchy(), shadow.getEnclosingType(), enclosingMember);
+			} else {
+				enclosingNode = lookupMember(model.getHierarchy(), shadow.getEnclosingType(), actualEnclosingMember);
+			}
+		} else {
+			enclosingNode = lookupMember(model.getHierarchy(), shadow.getEnclosingType(), enclosingMember);
+		}
 
-		IProgramElement enclosingNode = lookupMember(model.getHierarchy(), enclosingMember);
 		if (enclosingNode == null) {
 			Lint.Kind err = shadow.getIWorld().getLint().shadowNotInStructure;
 			if (err.isEnabled()) {
@@ -501,6 +526,11 @@ public class AsmRelationshipProvider {
 		return findMemberInClass(classNode, member);
 	}
 
+	protected static IProgramElement lookupMember(IHierarchy model, UnresolvedType declaringType, Member member) {
+		IProgramElement classNode = model.findElementForType(declaringType.getPackageName(), declaringType.getClassName());
+		return findMemberInClass(classNode, member);
+	}
+
 	protected static IProgramElement findMemberInClass(IProgramElement classNode, Member member) {
 		if (classNode == null)
 			return null; // XXX remove this check
@@ -0,0 +1,11 @@
+package aa;
+
+public aspect AdvisesC {
+    int C.nothing() {
+        return nothing();
+    }
+    
+    before() : call(int C.nothing()) {
+        
+    }
+}
@@ -0,0 +1,13 @@
+package aa;
+
+
+public class C {
+    public C() {
+        super();
+        System.out.println("init C");
+    }
+    
+//    int nothing() {
+//        return nothing();
+//    }
+ }
@@ -199,6 +199,19 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		// incomplete
 	}
 
+	public void testAdvisingCallJoinpointsInITDS_pr253067() {
+		String p = "pr253067";
+		initialiseProject(p);
+		build(p);
+		// Check for a code node at line 5 - if there is one then we created it correctly when building
+		// the advice relationship
+		IProgramElement root = getModelFor(p).getHierarchy().getRoot();
+		IProgramElement code = findElementAtLine(root, 5);
+		assertEquals("=pr253067<aa*AdvisesC.aj}AdvisesC)C.nothing?method-call(int aa.C.nothing())", code.getHandleIdentifier());
+		// dumptree(getModelFor(p).getHierarchy().getRoot(), 0);
+		// Ajc.dumpAJDEStructureModel(getModelFor("pr253067"), "after inc build where first advised line is gone");
+	}
+
 	public void testNullDelegateBrokenCode_pr251940() {
 		String p = "pr251940";
 		initialiseProject(p);
