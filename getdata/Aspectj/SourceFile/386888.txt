@@ -1977,8 +1977,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 	 *         an additional source location.
 	 */
 	public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child, int transformerPosition, ResolvedType aspectType) {
-		// System.err.println("check: " + child.getDeclaringType() +
-		// " overrides " + parent.getDeclaringType());
+		// System.err.println("check: " + child.getDeclaringType() + " overrides " + parent.getDeclaringType());
 		if (Modifier.isFinal(parent.getModifiers())) {
 			// If the ITD matching is occurring due to pulling in a BinaryTypeBinding then this check can incorrectly
 			// signal an error because the ITD transformer being examined here will exactly match the member it added
@@ -1993,10 +1992,8 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 					List<ConcreteTypeMunger> transformersOnThisType = wsi.getTypeMungers(nonItdDeclaringType);
 					if (transformersOnThisType != null) {
 						for (ConcreteTypeMunger transformer : transformersOnThisType) {
-							// relatively crude check - is the ITD
-							// for the same as the existingmember
-							// and does it come
-							// from the same aspect
+							// relatively crude check - is the ITD for the same as the existingmember
+							// and does it come from the same aspect
 							if (transformer.aspectType.equals(aspectType)) {
 								if (parent.equalsApartFromDeclaringType(transformer.getSignature())) {
 									return true;
@@ -2027,7 +2024,10 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 			// !rtParentReturnType.isAssignableFrom(rtChildReturnType);
 			// }
 		} else {
-			incompatibleReturnTypes = !parent.getReturnType().equals(child.getReturnType());
+			ResolvedType rtParentReturnType = parent.resolve(world).getGenericReturnType().resolve(world);
+			ResolvedType rtChildReturnType = child.resolve(world).getGenericReturnType().resolve(world);
+			
+			incompatibleReturnTypes = !rtParentReturnType.equals(rtChildReturnType);
 		}
 
 		if (incompatibleReturnTypes) {
@@ -1931,6 +1931,17 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 						fg.addAnnotation(ag);
 					}
 				}
+
+				if (weaver.getWorld().isInJava5Mode()) {
+					String basicSignature = field.getSignature();
+					String genericSignature = field.getReturnType().resolve(weaver.getWorld()).getSignatureForAttribute();
+					// String genericSignature =
+					// ((ResolvedMemberImpl)field).getSignatureForAttribute();
+					if (!basicSignature.equals(genericSignature)) {
+						// Add a signature attribute to it
+						fg.addAttribute(createSignatureAttribute(gen.getConstantPool(), genericSignature));
+					}
+				}
 				gen.addField(fg, getSourceLocation());
 			}
 			// this uses a shadow munger to add init method to constructors
@@ -426,8 +426,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 	}
 
 	private void doPendingWeaves() {
-		for (Iterator i = pendingTypesToWeave.iterator(); i.hasNext();) {
-			SourceTypeBinding t = (SourceTypeBinding) i.next();
+		for (SourceTypeBinding t: pendingTypesToWeave) {
 			ContextToken tok = CompilationAndWeavingContext.enteringPhase(
 					CompilationAndWeavingContext.WEAVING_INTERTYPE_DECLARATIONS, t.sourceName);
 			weaveInterTypeDeclarations(t);
@@ -862,10 +861,10 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 	 * sourceType and onType are the 'same type' - the former is the 'Eclipse' version and the latter is the 'Weaver' version.
 	 */
 	private void processTypeMungersFromExistingWeaverState(SourceTypeBinding sourceType, ResolvedType onType) {
-		Collection previouslyAppliedMungers = onType.getWeaverState().getTypeMungers(onType);
+		List<ConcreteTypeMunger> previouslyAppliedMungers = onType.getWeaverState().getTypeMungers(onType);
 
-		for (Iterator i = previouslyAppliedMungers.iterator(); i.hasNext();) {
-			ConcreteTypeMunger m = (ConcreteTypeMunger) i.next();
+		for (Iterator<ConcreteTypeMunger> i = previouslyAppliedMungers.iterator(); i.hasNext();) {
+			ConcreteTypeMunger m = i.next();
 			EclipseTypeMunger munger = factory.makeEclipseTypeMunger(m);
 			if (munger.munge(sourceType, onType)) {
 				if (onType.isInterface() && munger.getMunger().needsAccessToTopmostImplementor()) {
@@ -885,8 +884,8 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		ResolvedType resolvedSourceType = factory.fromEclipse(sourceType);
 		List<ResolvedType> newParents = declareParents.findMatchingNewParents(resolvedSourceType, false);
 		if (!newParents.isEmpty()) {
-			for (Iterator i = newParents.iterator(); i.hasNext();) {
-				ResolvedType parent = (ResolvedType) i.next();
+			for (Iterator<ResolvedType> i = newParents.iterator(); i.hasNext();) {
+				ResolvedType parent = i.next();
 				if (dangerousInterfaces.containsKey(parent)) {
 					ResolvedType onType = factory.fromEclipse(sourceType);
 					factory.showMessage(IMessage.ERROR, onType + ": " + dangerousInterfaces.get(parent),
@@ -919,7 +918,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		if ((bits & TagBits.AnnotationTargetMASK) == 0) {
 			return "";
 		}
-		Set s = new HashSet();
+		Set<String> s = new HashSet<String>();
 		if ((bits & TagBits.AnnotationForAnnotationType) != 0) {
 			s.add("ANNOTATION_TYPE");
 		}
@@ -946,8 +945,8 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		}
 		StringBuffer sb = new StringBuffer();
 		sb.append("{");
-		for (Iterator iter = s.iterator(); iter.hasNext();) {
-			String element = (String) iter.next();
+		for (Iterator<String> iter = s.iterator(); iter.hasNext();) {
+			String element = iter.next();
 			sb.append(element);
 			if (iter.hasNext()) {
 				sb.append(",");
@@ -1288,33 +1287,33 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		return (abits & (TagBits.AnnotationForAnnotationType | TagBits.AnnotationForType)) == 0;
 	}
 
-	private void reportDeclareParentsMessage(WeaveMessage.WeaveMessageKind wmk, SourceTypeBinding sourceType, ResolvedType parent) {
-		if (!factory.getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {
-			String filename = new String(sourceType.getFileName());
-
-			int takefrom = filename.lastIndexOf('/');
-			if (takefrom == -1) {
-				takefrom = filename.lastIndexOf('\\');
-			}
-			filename = filename.substring(takefrom + 1);
-
-			factory.getWorld()
-					.getMessageHandler()
-					.handleMessage(
-							WeaveMessage.constructWeavingMessage(wmk,
-									new String[] { CharOperation.toString(sourceType.compoundName), filename,
-											parent.getClassName(),
-											getShortname(parent.getSourceLocation().getSourceFile().getPath()) }));
-		}
-	}
-
-	private String getShortname(String path) {
-		int takefrom = path.lastIndexOf('/');
-		if (takefrom == -1) {
-			takefrom = path.lastIndexOf('\\');
-		}
-		return path.substring(takefrom + 1);
-	}
+//	private void reportDeclareParentsMessage(WeaveMessage.WeaveMessageKind wmk, SourceTypeBinding sourceType, ResolvedType parent) {
+//		if (!factory.getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {
+//			String filename = new String(sourceType.getFileName());
+//
+//			int takefrom = filename.lastIndexOf('/');
+//			if (takefrom == -1) {
+//				takefrom = filename.lastIndexOf('\\');
+//			}
+//			filename = filename.substring(takefrom + 1);
+//
+//			factory.getWorld()
+//					.getMessageHandler()
+//					.handleMessage(
+//							WeaveMessage.constructWeavingMessage(wmk,
+//									new String[] { CharOperation.toString(sourceType.compoundName), filename,
+//											parent.getClassName(),
+//											getShortname(parent.getSourceLocation().getSourceFile().getPath()) }));
+//		}
+//	}
+
+//	private String getShortname(String path) {
+//		int takefrom = path.lastIndexOf('/');
+//		if (takefrom == -1) {
+//			takefrom = path.lastIndexOf('\\');
+//		}
+//		return path.substring(takefrom + 1);
+//	}
 
 	private void addParent(SourceTypeBinding sourceType, ResolvedType parent) {
 		ReferenceBinding parentBinding = (ReferenceBinding) factory.makeTypeBinding(parent);
@@ -482,6 +482,12 @@ public class EclipseFactory {
 				}
 			}
 		}
+		for (ConcreteTypeMunger ctm: ret) {
+			ResolvedMember rm = ctm.getSignature();
+			if (rm!=null) {
+				rm.resolve(this.getWorld());
+			}
+		}
 		finishedTypeMungers = ret;
 	}
 
@@ -30,6 +30,7 @@ import org.aspectj.bridge.ISourceLocation;
 public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, ResolvedMember {
 
 	private String[] parameterNames = null;
+	private boolean isResolved = false;
 	protected UnresolvedType[] checkedExceptions = UnresolvedType.NONE;
 
 	/**
@@ -568,6 +569,9 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Reso
 	// something different to world.resolve(member)
 	@Override
 	public ResolvedMember resolve(World world) {
+		if (isResolved) {
+			return this;
+		}
 		// make sure all the pieces of a resolvedmember really are resolved
 		try {
 			if (typeVariables != null && typeVariables.length > 0) {
@@ -601,6 +605,7 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Reso
 		} finally {
 			world.setTypeVariableLookupScope(null);
 		}
+		isResolved = true;
 		return this;
 	}
 
