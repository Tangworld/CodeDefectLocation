@@ -151,8 +151,9 @@ public class ReferencePointcut extends Pointcut {
 		if (pointcutDef == null && onType == null) {
 			while (true) {
 				UnresolvedType declaringType = searchType.getDeclaringType();
-				if (declaringType == null)
+				if (declaringType == null) {
 					break;
+				}
 				searchType = declaringType.resolve(scope.getWorld());
 				pointcutDef = searchType.findPointcut(name);
 				if (pointcutDef != null) {
@@ -291,8 +292,9 @@ public class ReferencePointcut extends Pointcut {
 
 			}
 
-			if (declaringType == null)
+			if (declaringType == null) {
 				declaringType = searchStart;
+			}
 			pointcutDec = declaringType.findPointcut(name);
 			boolean foundMatchingPointcut = (pointcutDec != null && pointcutDec.isPrivate());
 			if (!foundMatchingPointcut) {
@@ -323,8 +325,9 @@ public class ReferencePointcut extends Pointcut {
 			IntMap newBindings = new IntMap();
 			for (int i = 0, len = arguments.size(); i < len; i++) {
 				TypePattern p = arguments.get(i);
-				if (p == TypePattern.NO)
+				if (p == TypePattern.NO) {
 					continue;
+				}
 				// we are allowed to bind to pointcuts which use subtypes as this is type safe
 				// this will be checked in ReferencePointcut.resolveBindings(). Can't check it here
 				// as we don't know about any new parents added via decp.
@@ -381,10 +384,12 @@ public class ReferencePointcut extends Pointcut {
 	}
 
 	public boolean equals(Object other) {
-		if (!(other instanceof ReferencePointcut))
+		if (!(other instanceof ReferencePointcut)) {
 			return false;
-		if (this == other)
+		}
+		if (this == other) {
 			return true;
+		}
 		ReferencePointcut o = (ReferencePointcut) other;
 		return o.name.equals(name) && o.arguments.equals(arguments)
 				&& ((o.onType == null) ? (onType == null) : o.onType.equals(onType));
@@ -32,8 +32,8 @@ import org.aspectj.apache.bcel.classfile.Method;
 import org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;
 import org.aspectj.apache.bcel.classfile.annotation.ArrayElementValue;
 import org.aspectj.apache.bcel.classfile.annotation.ClassElementValue;
-import org.aspectj.apache.bcel.classfile.annotation.NameValuePair;
 import org.aspectj.apache.bcel.classfile.annotation.ElementValue;
+import org.aspectj.apache.bcel.classfile.annotation.NameValuePair;
 import org.aspectj.apache.bcel.classfile.annotation.RuntimeAnnos;
 import org.aspectj.apache.bcel.classfile.annotation.RuntimeVisAnnos;
 import org.aspectj.apache.bcel.generic.Type;
@@ -215,8 +215,9 @@ public class AtAjAttributes {
 				}
 			}
 		}
-		if (!containsAnnotationClassReference)
+		if (!containsAnnotationClassReference) {
 			return NO_ATTRIBUTES;
+		}
 
 		AjAttributeStruct struct = new AjAttributeStruct(type, context, msgHandler);
 		Attribute[] attributes = javaClass.getAttributes();
@@ -292,8 +293,9 @@ public class AtAjAttributes {
 
 		for (int i = 0; i < javaClass.getMethods().length; i++) {
 			Method method = javaClass.getMethods()[i];
-			if (method.getName().startsWith(NameMangler.PREFIX))
+			if (method.getName().startsWith(NameMangler.PREFIX)) {
 				continue; // already dealt with by ajc...
+			}
 			// FIXME alex optimize, this method struct will gets recreated for
 			// advice extraction
 			AjAttributeMethodStruct mstruct = null;
@@ -327,8 +329,9 @@ public class AtAjAttributes {
 		Field[] fs = javaClass.getFields();
 		for (int i = 0; i < fs.length; i++) {
 			Field field = fs[i];
-			if (field.getName().startsWith(NameMangler.PREFIX))
+			if (field.getName().startsWith(NameMangler.PREFIX)) {
 				continue; // already dealt with by ajc...
+			}
 			// FIXME alex optimize, this method struct will gets recreated for
 			// advice extraction
 			AjAttributeFieldStruct fstruct = new AjAttributeFieldStruct(field, null, type, context, msgHandler);
@@ -369,8 +372,9 @@ public class AtAjAttributes {
 	 */
 	public static List<AjAttribute> readAj5MethodAttributes(Method method, BcelMethod bMethod, ResolvedType type,
 			ResolvedPointcutDefinition preResolvedPointcut, ISourceContext context, IMessageHandler msgHandler) {
-		if (method.getName().startsWith(NameMangler.PREFIX))
+		if (method.getName().startsWith(NameMangler.PREFIX)) {
 			return Collections.emptyList(); // already dealt with by ajc...
+		}
 
 		AjAttributeMethodStruct struct = new AjAttributeMethodStruct(method, bMethod, type, context, msgHandler);
 		Attribute[] attributes = method.getAttributes();
@@ -1023,8 +1027,9 @@ public class AtAjAttributes {
 					// pc.resolve(binding);
 				} else {
 					pc = parsePointcut(beforeAdvice.getValue().stringifyValue(), struct, false);
-					if (pc == null)
+					if (pc == null) {
 						return false;// parse error
+					}
 					pc = pc.resolve(binding);
 				}
 				setIgnoreUnboundBindingNames(pc, bindings);
@@ -1074,8 +1079,9 @@ public class AtAjAttributes {
 					pc = preResolvedPointcut.getPointcut();
 				} else {
 					pc = parsePointcut(afterAdvice.getValue().stringifyValue(), struct, false);
-					if (pc == null)
+					if (pc == null) {
 						return false;// parse error
+					}
 					pc.resolve(binding);
 				}
 				setIgnoreUnboundBindingNames(pc, bindings);
@@ -1164,8 +1170,9 @@ public class AtAjAttributes {
 				pc = preResolvedPointcut.getPointcut();
 			} else {
 				pc = parsePointcut(pointcut, struct, false);
-				if (pc == null)
+				if (pc == null) {
 					return false;// parse error
+				}
 				pc.resolve(binding);
 			}
 			setIgnoreUnboundBindingNames(pc, bindings);
@@ -1253,8 +1260,9 @@ public class AtAjAttributes {
 				pc = preResolvedPointcut.getPointcut();
 			} else {
 				pc = parsePointcut(pointcut, struct, false);
-				if (pc == null)
+				if (pc == null) {
 					return false;// parse error
+				}
 				pc.resolve(binding);
 			}
 			setIgnoreUnboundBindingNames(pc, bindings);
@@ -1302,8 +1310,9 @@ public class AtAjAttributes {
 					pc = preResolvedPointcut.getPointcut();
 				} else {
 					pc = parsePointcut(aroundAdvice.getValue().stringifyValue(), struct, false);
-					if (pc == null)
+					if (pc == null) {
 						return false;// parse error
+					}
 					pc.resolve(binding);
 				}
 				setIgnoreUnboundBindingNames(pc, bindings);
@@ -1328,8 +1337,9 @@ public class AtAjAttributes {
 	 */
 	private static boolean handlePointcutAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct) {
 		AnnotationGen pointcut = getAnnotation(runtimeAnnotations, AjcMemberMaker.POINTCUT_ANNOTATION);
-		if (pointcut == null)
+		if (pointcut == null) {
 			return false;
+		}
 		NameValuePair pointcutExpr = getAnnotationElement(pointcut, VALUE);
 
 		// semantic check: the method must return void, or be
@@ -1387,8 +1397,9 @@ public class AtAjAttributes {
 				// since for it to be resolved, we will need other pointcuts to
 				// be registered as well
 				pc = parsePointcut(pointcutExpr.getValue().stringifyValue(), struct, true);
-				if (pc == null)
+				if (pc == null) {
 					return false;// parse error
+				}
 				pc.setLocation(struct.context, -1, -1);// FIXME AVASM !! bMethod
 				// is null here..
 				// } else {
@@ -1669,10 +1680,11 @@ public class AtAjAttributes {
 
 	private static String lastbit(String fqname) {
 		int i = fqname.lastIndexOf(".");
-		if (i == -1)
+		if (i == -1) {
 			return fqname;
-		else
+		} else {
 			return fqname.substring(i + 1);
+		}
 	}
 
 	/**
@@ -1718,8 +1730,9 @@ public class AtAjAttributes {
 						shortString.append("(");
 						for (int i = 0; i < method.getArgumentTypes().length; i++) {
 							shortString.append(lastbit(method.getArgumentTypes()[i].toString()));
-							if ((i + 1) < method.getArgumentTypes().length)
+							if ((i + 1) < method.getArgumentTypes().length) {
 								shortString.append(",");
+							}
 
 						}
 						shortString.append(")");
@@ -1795,6 +1808,9 @@ public class AtAjAttributes {
 
 		@Override
 		public Pointcut getPointcut() {
+			if (m_lazyPointcut == null && m_pointcutUnresolved == null) {
+				m_lazyPointcut = Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
+			}
 			if (m_lazyPointcut == null && m_pointcutUnresolved != null) {
 				m_lazyPointcut = m_pointcutUnresolved.resolve(m_binding);
 				m_lazyPointcut.copyLocationFrom(m_pointcutUnresolved);
@@ -0,0 +1,39 @@
+package aspects;
+
+import org.aspectj.lang.JoinPoint;
+import org.aspectj.lang.ProceedingJoinPoint;
+import org.aspectj.lang.annotation.Around;
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.annotation.Before;
+import org.aspectj.lang.annotation.Pointcut;
+
+@ Aspect
+public abstract class AbstractTimingAnnotatedAspect {
+
+	@Pointcut("within(*..AbstractJPivotPortlet+) " +
+			"&& (execution(* do*(..))" +
+			"|| execution(* processAction*(..))" +
+			"|| execution(* serveResource*(..)) )")
+	protected final void portletEntryMethods() {}
+
+	@Pointcut("execution(* eu.ibacz.pbns..*.*(..)) || execution(* com.tonbeller..*.*(..))")
+	protected final void tracedMethods() {}
+
+	@Pointcut("within(aspects.*) || within(aspects..*)")
+	protected final void thisAspectClasses() {}
+
+	@Pointcut("cflow(execution(* TimingAnnotatedAspect.processInvocationFinished(..)))")
+	protected final void thisAspectExecution() {}
+
+	@Pointcut
+	protected abstract void scope();
+
+	@Before("scope() && portletEntryMethods() && !thisAspectClasses() && !thisAspectExecution()")
+	public void logStackTrace(final JoinPoint thisJoinPoint) throws Throwable {
+		System.out.println("logStackTrace: Logging the current stack trace prior to " +
+				"the execution of " +
+				thisJoinPoint.getSignature().toShortString()
+				+ new Exception("Current stack trace print out."));
+	} /* logStackTrace */
+
+}
@@ -0,0 +1,13 @@
+package aspects;
+
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.annotation.Pointcut;
+
+@ Aspect
+public class TimingAnnotatedAspect extends AbstractTimingAnnotatedAspect {
+
+	@Pointcut("")
+	protected void scope() {}
+
+
+}
Binary files differ
@@ -18,6 +18,10 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc166Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testNpeForJavacBuilt_290227() {
+		runTest("npe for javac built");
+	}
+
 	public void testBinaryDecpSuperRewrite_290087() {
 		runTest("binary decp super rewrite");
 	}
@@ -2,6 +2,10 @@
 
 <suite>
 
+  <ajc-test dir="bugs166/pr290227" title="npe for javac built">
+    <compile files="" inpath="javacCode.jar" options="-1.5 -Xlint:ignore"/>
+  </ajc-test>
+  
   <ajc-test dir="bugs166/pr288049" title="itd decanno">
      <compile files="org/othtests/MyClass.java org/othtests/MySubClass.java org/othtests/AddSomeAnnotation.java" options="-1.5 -showWeaveInfo">
      <message kind="weave" text="'public java.lang.String org.othtests.MySubClass.doOne()' (MySubClass.java:5) is annotated with"/>
