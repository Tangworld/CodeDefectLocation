@@ -132,6 +132,11 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 	public boolean isNested() {
 		return ((declaration.modifiers & ASTNode.IsMemberTypeMASK) != 0);
 	}
+	
+	public ResolvedType getOuterClass() {
+		if (declaration.enclosingType==null) return null;
+		return eclipseWorld().fromEclipse(declaration.enclosingType.binding);
+	}
 
     public boolean isAnnotationStyleAspect() {
         if (declaration.annotations == null) {
@@ -19,6 +19,9 @@ import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 
+import org.aspectj.apache.bcel.classfile.GenericSignatureParser;
+import org.aspectj.apache.bcel.classfile.Signature;
+import org.aspectj.apache.bcel.classfile.Signature.ClassSignature;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.weaver.patterns.Declare;
 
@@ -30,6 +33,7 @@ public abstract class AbstractReferenceTypeDelegate implements ReferenceTypeDele
 	protected boolean exposedToWeaver;
 	protected ReferenceType resolvedTypeX;
 	private ISourceContext sourceContext = SourceContextImpl.UNKNOWN_SOURCE_CONTEXT;
+	protected ClassSignature cachedGenericClassTypeSignature;
 
     public AbstractReferenceTypeDelegate(ReferenceType resolvedTypeX, boolean exposedToWeaver) {
         this.resolvedTypeX = resolvedTypeX;
@@ -268,5 +272,39 @@ public abstract class AbstractReferenceTypeDelegate implements ReferenceTypeDele
 		this.sourceContext = isc;
 	}
 
+	public Signature.ClassSignature getGenericClassTypeSignature() {
+		if (cachedGenericClassTypeSignature==null) {
+			String sig = getDeclaredGenericSignature();
+			if (sig!=null) {
+				GenericSignatureParser parser = new GenericSignatureParser();
+				cachedGenericClassTypeSignature = parser.parseAsClassSignature(sig);
+			}
+		}
+		return cachedGenericClassTypeSignature;
+	}
+	
+	protected Signature.FormalTypeParameter[] getFormalTypeParametersFromOuterClass() {
+		List typeParameters = new ArrayList();
+		ReferenceType outer = (ReferenceType)getOuterClass();
+		ReferenceTypeDelegate outerDelegate = outer.getDelegate();
+		AbstractReferenceTypeDelegate outerObjectType = (AbstractReferenceTypeDelegate) outerDelegate;
+		if (outerObjectType.isNested()) {
+			Signature.FormalTypeParameter[] parentParams = outerObjectType.getFormalTypeParametersFromOuterClass();
+			for (int i = 0; i < parentParams.length; i++) {
+				typeParameters.add(parentParams[i]);
+			}
+		}
+		Signature.ClassSignature outerSig = outerObjectType.getGenericClassTypeSignature();
+		if (outerSig != null) {
+			for (int i = 0; i < outerSig.formalTypeParameters .length; i++) {
+				typeParameters.add(outerSig.formalTypeParameters[i]);
+			}
+		} 
+		
+		Signature.FormalTypeParameter[] ret = new Signature.FormalTypeParameter[typeParameters.size()];
+		typeParameters.toArray(ret);
+		return ret;
+	}
+
 
 }
\ No newline at end of file
@@ -185,6 +185,10 @@ public class BoundedReferenceType extends ReferenceType {
 			return resolvedTypeX.isNested();
 		}
 
+		public ResolvedType getOuterClass() {
+			return resolvedTypeX.getOuterClass();
+		}
+		
 		public String getRetentionPolicy() {
 			return resolvedTypeX.getRetentionPolicy();
 		}
@@ -172,11 +172,15 @@ public class ReferenceType extends ResolvedType {
     }
 
     public boolean isAnonymous() {
-    		return delegate.isAnonymous();
+    	return delegate.isAnonymous();
     }
 
     public boolean isNested() {
-    		return delegate.isNested();
+    	return delegate.isNested();
+    }
+    
+    public ResolvedType getOuterClass() {
+    	return delegate.getOuterClass();
     }
 
     public String getRetentionPolicy() {
@@ -66,5 +66,6 @@ public interface ReferenceTypeDelegate {
 	public String getSourcefilename();
 
 	public String getDeclaredGenericSignature();
+	public ResolvedType getOuterClass();
 
 }
\ No newline at end of file
@@ -21,6 +21,9 @@ import java.util.List;
 
 import org.aspectj.apache.bcel.classfile.GenericSignatureParser;
 import org.aspectj.apache.bcel.classfile.Signature;
+import org.aspectj.org.objectweb.asm.Attribute;
+import org.aspectj.org.objectweb.asm.ClassReader;
+import org.aspectj.org.objectweb.asm.Opcodes;
 import org.aspectj.weaver.AbstractReferenceTypeDelegate;
 import org.aspectj.weaver.AjAttribute;
 import org.aspectj.weaver.AnnotationAJ;
@@ -28,7 +31,6 @@ import org.aspectj.weaver.AnnotationTargetKind;
 import org.aspectj.weaver.AnnotationX;
 import org.aspectj.weaver.ISourceContext;
 import org.aspectj.weaver.ReferenceType;
-import org.aspectj.weaver.ReferenceTypeDelegate;
 import org.aspectj.weaver.ResolvedMember;
 import org.aspectj.weaver.ResolvedMemberImpl;
 import org.aspectj.weaver.ResolvedPointcutDefinition;
@@ -48,9 +50,6 @@ import org.aspectj.weaver.AjAttribute.WeaverVersionInfo;
 import org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter;
 import org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.GenericSignatureFormatException;
 import org.aspectj.weaver.patterns.PerClause;
-import org.aspectj.org.objectweb.asm.Attribute;
-import org.aspectj.org.objectweb.asm.ClassReader;
-import org.aspectj.org.objectweb.asm.Opcodes;
 
 /**
  * A lightweight fast delegate that is an alternative to a BCEL delegate.
@@ -315,6 +314,7 @@ public class AsmDelegate extends AbstractReferenceTypeDelegate {
 	public String getDeclaredGenericSignature() {
 		return declaredSignature;
 	}
+
 
 	public Collection getTypeMungers() {
 		if ((bitflag&DISCOVERED_TYPEMUNGERS)==0) {
@@ -449,7 +449,7 @@ public class AsmDelegate extends AbstractReferenceTypeDelegate {
 	}
 
 
-	private ReferenceType getOuterClass() {
+	public ResolvedType getOuterClass() {
 		if (!isNested()) throw new IllegalStateException("Can't get the outer class of a non-nested type");
 		int lastDollar = getResolvedTypeX().getName().lastIndexOf('$');
 		String superClassName = getResolvedTypeX().getName().substring(0,lastDollar);
@@ -457,36 +457,7 @@ public class AsmDelegate extends AbstractReferenceTypeDelegate {
 		return (ReferenceType) outer.resolve(getResolvedTypeX().getWorld());
 	}
 
-	private Signature.FormalTypeParameter[] getFormalTypeParametersFromOuterClass() {
-		List typeParameters = new ArrayList();
-		ReferenceType outer = getOuterClass();
-		ReferenceTypeDelegate outerDelegate = outer.getDelegate();
-		if (!(outerDelegate instanceof AsmDelegate)) {
-			throw new IllegalStateException("How come we're in AsmObjectType resolving an inner type of something that is NOT a AsmObjectType??");
-		}
-		AsmDelegate outerObjectType = (AsmDelegate) outerDelegate;
-		if (outerObjectType.isNested()) {
-			Signature.FormalTypeParameter[] parentParams = outerObjectType.getFormalTypeParametersFromOuterClass();
-			for (int i = 0; i < parentParams.length; i++) {
-				typeParameters.add(parentParams[i]);
-			}
-		}
-		  GenericSignatureParser parser = new GenericSignatureParser();
-		  String sig = outerObjectType.getDeclaredGenericSignature();
-		  if (sig!=null) {
-		  Signature.ClassSignature outerSig = parser.parseAsClassSignature(sig);
-		if (outerSig != null) {
-			for (int i = 0; i < outerSig.formalTypeParameters .length; i++) {
-				typeParameters.add(outerSig.formalTypeParameters[i]);
-			}
-		} 
-	  }
-		
-		Signature.FormalTypeParameter[] ret = new Signature.FormalTypeParameter[typeParameters.size()];
-		typeParameters.toArray(ret);
-		return ret;
-	}
-	// ---
+
 
 	public boolean isInterface() {
 		return (classModifiers & Opcodes.ACC_INTERFACE)!=0;
@@ -26,7 +26,6 @@ import org.aspectj.apache.bcel.classfile.Field;
 import org.aspectj.apache.bcel.classfile.JavaClass;
 import org.aspectj.apache.bcel.classfile.Method;
 import org.aspectj.apache.bcel.classfile.Signature;
-import org.aspectj.apache.bcel.classfile.Signature.ClassSignature;
 import org.aspectj.apache.bcel.classfile.annotation.Annotation;
 import org.aspectj.apache.bcel.classfile.annotation.ArrayElementValue;
 import org.aspectj.apache.bcel.classfile.annotation.ElementNameValuePair;
@@ -39,7 +38,6 @@ import org.aspectj.weaver.AnnotationTargetKind;
 import org.aspectj.weaver.AnnotationX;
 import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.ReferenceType;
-import org.aspectj.weaver.ReferenceTypeDelegate;
 import org.aspectj.weaver.ResolvedMember;
 import org.aspectj.weaver.ResolvedPointcutDefinition;
 import org.aspectj.weaver.ResolvedType;
@@ -86,7 +84,6 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 	private List declares = Collections.EMPTY_LIST;
 
 	private Signature.FormalTypeParameter[] formalsForResolution = null;
-	private ClassSignature cachedGenericClassTypeSignature;
 	private String declaredSignature = null;
 
 
@@ -162,7 +159,7 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 		modifiers           = javaClass.getAccessFlags();
 		superclassName      = javaClass.getSuperclassName();
 		className           = javaClass.getClassName();
-		cachedGenericClassTypeSignature = javaClass.getGenericClassTypeSignature();
+		cachedGenericClassTypeSignature = null;
     }
 
 
@@ -250,7 +247,7 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
     	if (!isGeneric()) return TypeVariable.NONE;
 
     	if (typeVars == null) {
-	    	Signature.ClassSignature classSig = cachedGenericClassTypeSignature;//javaClass.getGenericClassTypeSignature();
+	    	Signature.ClassSignature classSig = getGenericClassTypeSignature();//cachedGenericClassTypeSignature;//javaClass.getGenericClassTypeSignature();
 	    	typeVars = new TypeVariable[classSig.formalTypeParameters.length];
 	    	for (int i = 0; i < typeVars.length; i++) {
 				Signature.FormalTypeParameter ftp = classSig.formalTypeParameters[i];
@@ -656,10 +653,6 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 		return declaredSignature;
 	}
 
-	Signature.ClassSignature getGenericClassTypeSignature() {
-		return cachedGenericClassTypeSignature;
-	}
-	
 
 	private void ensureGenericSignatureUnpacked() {
 		if ((bitflag&UNPACKED_GENERIC_SIGNATURE)!=0) return;
@@ -668,7 +661,7 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 		Signature.ClassSignature cSig = getGenericClassTypeSignature();
 		if (cSig != null) {
 			formalsForResolution = cSig.formalTypeParameters;
-			if (isNestedClass()) {
+			if (isNested()) {
 				// we have to find any type variables from the outer type before proceeding with resolution.
 				Signature.FormalTypeParameter[] extraFormals = getFormalTypeParametersFromOuterClass();
 				if (extraFormals.length > 0) {
@@ -743,43 +736,15 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 		}
 	}
 
-	private boolean isNestedClass() {
-		return className.indexOf('$') != -1;
-	}
 
-	private ReferenceType getOuterClass() {
-		if (!isNestedClass()) throw new IllegalStateException("Can't get the outer class of a non-nested type");
+	public ResolvedType getOuterClass() {
+		if (!isNested()) throw new IllegalStateException("Can't get the outer class of a non-nested type");
 		int lastDollar = className.lastIndexOf('$');
 		String superClassName = className.substring(0,lastDollar);
 		UnresolvedType outer = UnresolvedType.forName(superClassName);
 		return (ReferenceType) outer.resolve(getResolvedTypeX().getWorld());
 	}
 
-	private Signature.FormalTypeParameter[] getFormalTypeParametersFromOuterClass() {
-		List typeParameters = new ArrayList();
-		ReferenceType outer = getOuterClass();
-		ReferenceTypeDelegate outerDelegate = outer.getDelegate();
-		if (!(outerDelegate instanceof BcelObjectType)) {
-			throw new IllegalStateException("How come we're in BcelObjectType resolving an inner type of something that is NOT a BcelObjectType??");
-		}
-		BcelObjectType outerObjectType = (BcelObjectType) outerDelegate;
-		if (outerObjectType.isNestedClass()) {
-			Signature.FormalTypeParameter[] parentParams = outerObjectType.getFormalTypeParametersFromOuterClass();
-			for (int i = 0; i < parentParams.length; i++) {
-				typeParameters.add(parentParams[i]);
-			}
-		}
-		Signature.ClassSignature outerSig = outerObjectType.getGenericClassTypeSignature();
-		if (outerSig != null) {
-			for (int i = 0; i < outerSig.formalTypeParameters .length; i++) {
-				typeParameters.add(outerSig.formalTypeParameters[i]);
-			}
-		} 
-		
-		Signature.FormalTypeParameter[] ret = new Signature.FormalTypeParameter[typeParameters.size()];
-		typeParameters.toArray(ret);
-		return ret;
-	}
 
 	private void ensureGenericInfoProcessed() { 
 		if ((bitflag & DISCOVERED_DECLARED_SIGNATURE)!=0) return;
@@ -170,6 +170,12 @@ public class ReflectionBasedReferenceTypeDelegate implements ReferenceTypeDelega
 //		boolean member = this.myClass.isMemberClass();
 //		return member;
 	}
+	
+	public ResolvedType getOuterClass() {
+		// FIXME getEnclosingClass() is Java5 ... dammit
+//		return ReflectionBasedReferenceTypeDelegateFactory.resolveTypeInWorld(myClass.getEnclosingClass(),world);
+		return null;
+	}
 
 	/* (non-Javadoc)
 	 * @see org.aspectj.weaver.ReferenceTypeDelegate#isExposedToWeaver()
@@ -27,6 +27,10 @@ public class Ajc153Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   // public void testArgnamesAndJavac_pr148381() { runTest("argNames and javac");}
   // public void testCFlowXMLAspectLTW_pr149096() { runTest("cflow xml concrete aspect"); }
   // public void testAmbiguousBinding_pr121805() { runTest("ambiguous binding");}
+	 
+  public void testNoIllegalStateExceptionFromAsmDelegate_pr153490_1() { runTest("no illegal state exception from AsmDelegate - 1");}
+  public void testNoIllegalStateExceptionFromAsmDelegate_pr153490_2() { runTest("no illegal state exception from AsmDelegate - 2");}
+  public void testNoIllegalStateExceptionFromAsmDelegate_pr153490_3() { runTest("no illegal state exception from AsmDelegate - 3");}
   public void testAnnotMethod_pr156962() { runTest("Test Annot Method");}
   public void testAnnotMethodHasMember_pr156962() { runTest("Test Annot Method Has Member"); }
   public void testMixingGenerics_pr152848()  { runTest("mixing generics"); }
@@ -3,6 +3,18 @@
 <!-- AspectJ v1.5.3 Tests -->
 <suite>
 
+    <ajc-test dir="bugs153/pr153490" title="no illegal state exception from AsmDelegate - 1">
+      <compile files="Foo.java" options="-1.5" classpath="jarForFoo.jar" />
+    </ajc-test>
+
+    <ajc-test dir="bugs153/pr153490" title="no illegal state exception from AsmDelegate - 2">
+      <compile files="Bar.java" options="-1.5" classpath="jarForBar.jar" />
+    </ajc-test>
+
+    <ajc-test dir="bugs153/pr153490" title="no illegal state exception from AsmDelegate - 3">
+      <compile files="Goo.java" options="-1.5" classpath="jarForGoo.jar" />
+    </ajc-test>
+
     <ajc-test dir="bugs153/pr156962" title="Test Annot Method">
       <compile files="Sample.java, WarnDeprecatedMethod.aj" options="-1.5">
         <message kind="warning" line="2" text="deprecated method"/>      
@@ -0,0 +1,4 @@
+public aspect A {
+	public enum TestType {Pre};
+}
+
@@ -0,0 +1,7 @@
+public aspect A2 {
+
+	public static class C {
+		public enum TestType {Pre};		
+	}
+	
+}
@@ -0,0 +1,7 @@
+public class Bar {
+
+	public static void main(String[] args) {
+		A2.C.TestType pre = A2.C.TestType.Pre;
+    }
+
+}
@@ -0,0 +1,7 @@
+public class C {
+
+	static aspect A {
+		public enum TestType {Pre};
+	}
+
+}
@@ -0,0 +1,7 @@
+public class Foo {
+
+	public static void main(String[] args) {
+		A.TestType pre = A.TestType.Pre;
+    }
+
+}
@@ -0,0 +1,6 @@
+public class Goo {
+
+	public static void main(String[] args) {
+		C.A.TestType pre = C.A.TestType.Pre;
+	}
+}
Binary files differ
Binary files differ
Binary files differ
@@ -0,0 +1,5 @@
+to regenerate jarForFoo.jar: ajc A.aj -outjar required.jar -1.5 -noExit
+
+to regenerate jarForBar.jar: ajc A2.aj -outjar jarForBar.jar -1.5 -noExit
+
+to regenerate jarForGoo.jar: ajc C.java -outjar jarForGoo.jar -1.5 -noExit
Binary files differ
