@@ -1074,6 +1074,15 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 				  decisions.indexOf(expect)!=-1);
 	}
 
+	public void testPr133532_3() {
+		initialiseProject("PR133532_3");
+		build("PR133532_3");
+		alter("PR133532_3","inc1");
+		build("PR133532_3");
+		assertTrue("There should be no errors reported:\n"+MyTaskListManager.getErrorMessages(),
+				MyTaskListManager.getErrorMessages().isEmpty());			
+	}
+	
 	public void testPr134541() {
 		initialiseProject("PR134541");
 		build("PR134541");
@@ -26,6 +26,7 @@ import java.util.Set;
 import org.aspectj.org.eclipse.jdt.core.compiler.CharOperation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.aspectj.org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
+import org.aspectj.org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.aspectj.org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.aspectj.org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
 import org.aspectj.util.FileUtil;
@@ -35,12 +36,14 @@ public class StatefulNameEnvironment implements INameEnvironment {
 	private Map classesFromName;
 	private Map inflatedClassFilesCache;
 	private Set packageNames;
+	private AjState state;
 	private INameEnvironment baseEnvironment;
 
-	public StatefulNameEnvironment(INameEnvironment baseEnvironment, Map classesFromName) {
+	public StatefulNameEnvironment(INameEnvironment baseEnvironment, Map classesFromName, AjState state) {
 		this.classesFromName = classesFromName;
 		this.inflatedClassFilesCache = new HashMap();
 		this.baseEnvironment = baseEnvironment;
+		this.state= state;
 
 		packageNames = new HashSet();
 		for (Iterator i = classesFromName.keySet().iterator(); i.hasNext(); ) {
@@ -65,6 +68,11 @@ public class StatefulNameEnvironment implements INameEnvironment {
 	}
 
 	private NameEnvironmentAnswer findType(String name) {
+	    // pr133532 - ask the state for the type first
+		IBinaryType seenOnPreviousBuild = state.checkPreviousBuild(name);
+		if (seenOnPreviousBuild!=null) {
+			return new NameEnvironmentAnswer(seenOnPreviousBuild,null);
+		}
 		if (this.inflatedClassFilesCache.containsKey(name)) {
 			return (NameEnvironmentAnswer) this.inflatedClassFilesCache.get(name);
 		}
@@ -0,0 +1,150 @@
+/* *******************************************************************
+ * Copyright (c) 2005 Contributors
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *     Andy Clement   promoted member type from AjState
+ * ******************************************************************/
+package org.aspectj.ajdt.internal.core.builder;
+
+import org.aspectj.org.eclipse.jdt.core.compiler.CharOperation;
+import org.aspectj.org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
+import org.aspectj.org.eclipse.jdt.internal.compiler.env.IBinaryField;
+import org.aspectj.org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
+import org.aspectj.org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
+import org.aspectj.org.eclipse.jdt.internal.compiler.env.IBinaryType;
+
+/**
+ * Used to determine if a type has structurally changed during incremental
+ * compilation.  At the end of compilation we create one of these objects
+ * using the bytes for the class about to be woven.  On a subsequent
+ * incremental compile we compare the new form of the class with a previously
+ * stored CompactTypeStructureRepresentation instance.  A structural change
+ * will indicate we need to do recompile other dependent types.
+ */
+public class CompactTypeStructureRepresentation implements IBinaryType {
+		static char[][] NoInterface = CharOperation.NO_CHAR_CHAR;
+		static IBinaryNestedType[] NoNestedType = new IBinaryNestedType[0];
+		static IBinaryField[] NoField = new IBinaryField[0];
+		static IBinaryMethod[] NoMethod = new IBinaryMethod[0];
+	
+	    // this is the core state for comparison
+		char[] className;
+		int modifiers;
+		char[] genericSignature;
+		char[] superclassName;
+		char[][] interfaces;
+
+		// this is the extra state that enables us to be an IBinaryType
+		char[] enclosingTypeName;
+		boolean isLocal, isAnonymous, isMember;
+		char[] sourceFileName;
+		char[] fileName;
+		int kind;
+		long tagBits;
+		boolean isBinaryType;
+		IBinaryField[] binFields;
+		IBinaryMethod[] binMethods;
+		IBinaryNestedType[] memberTypes;
+		
+		public CompactTypeStructureRepresentation(ClassFileReader cfr) {
+			
+			this.enclosingTypeName = cfr.getEnclosingTypeName();
+			this.isLocal = cfr.isLocal();
+			this.isAnonymous = cfr.isAnonymous();
+			this.isMember = cfr.isMember();
+			this.sourceFileName = cfr.sourceFileName();
+			this.fileName = cfr.getFileName();
+			this.kind = cfr.getKind();
+			this.tagBits = cfr.getTagBits();
+			this.isBinaryType = cfr.isBinaryType();
+			this.binFields = cfr.getFields(); if (binFields==null) binFields = NoField;
+			this.binMethods = cfr.getMethods();if (binMethods==null) binMethods = NoMethod;
+			this.memberTypes = cfr.getMemberTypes();
+			
+			
+			this.className = cfr.getName();  // slashes...
+			this.modifiers = cfr.getModifiers();
+			this.genericSignature = cfr.getGenericSignature();
+//			if (this.genericSignature.length == 0) {
+//				this.genericSignature = null;
+//			}
+			this.superclassName = cfr.getSuperclassName(); // slashes...
+			interfaces = cfr.getInterfaceNames();
+
+		}
+
+		public char[] getEnclosingTypeName() {
+			return enclosingTypeName;
+		}
+		
+		public int getModifiers() {
+			return modifiers;
+		}
+
+		public char[] getGenericSignature() {
+			return genericSignature;
+		}
+
+		public char[][] getInterfaceNames() {
+			return interfaces;
+		}
+
+		public boolean isAnonymous() {
+			return isAnonymous;
+		}
+
+		public char[] sourceFileName() {
+			return sourceFileName;
+		}
+
+		public boolean isLocal() {
+			return isLocal;
+		}
+
+		public boolean isMember() {
+			return isMember;
+		}
+		
+		public char[] getSuperclassName() {
+			return superclassName;
+		}
+
+		public int getKind() {
+			return kind;
+		}
+		
+		public char[] getFileName() {
+			return fileName;
+		}
+
+		public char[] getName() {
+			return className;
+		}
+		
+		public long getTagBits() {
+			return tagBits;
+		}
+
+		public boolean isBinaryType() {
+			return isBinaryType;
+		}
+		
+		public IBinaryField[] getFields() {
+			return binFields;
+		}
+		
+		public IBinaryMethod[] getMethods() {
+			return binMethods;
+		}
+		
+		public IBinaryNestedType[] getMemberTypes() {
+			return memberTypes;
+		}
+
+
+}
\ No newline at end of file
@@ -40,15 +40,14 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.aspectj.org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.aspectj.org.eclipse.jdt.internal.compiler.env.IBinaryField;
 import org.aspectj.org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
+import org.aspectj.org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilerModifiers;
 import org.aspectj.org.eclipse.jdt.internal.core.builder.ReferenceCollection;
 import org.aspectj.org.eclipse.jdt.internal.core.builder.StringSet;
 import org.aspectj.util.FileUtil;
 import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.IWeaver;
-import org.aspectj.weaver.ResolvedMember;
 import org.aspectj.weaver.ResolvedType;
-import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.bcel.BcelWeaver;
 import org.aspectj.weaver.bcel.BcelWorld;
 import org.aspectj.weaver.bcel.UnwovenClassFile;
@@ -162,6 +161,9 @@ public class AjState {
 	private List/*String*/ resources = new ArrayList();
 	private List/*String*/ aspectNames;
 
+	// these are references created on a particular compile run - when looping round in 
+	// addAffectedSourceFiles(), if some have been created then we look at which source files
+	// touch upon those and get them recompiled.
 	private ArrayList/*<String>*/ qualifiedStrings;
 	private ArrayList/*<String>*/ simpleStrings;
 
@@ -278,6 +280,13 @@ public class AjState {
 				if (stateListener!=null) stateListener.detectedAspectDeleted(aDeletedFile);
 				return false;				
 			}
+			List/*ClassFile*/ classes = (List)fullyQualifiedTypeNamesResultingFromCompilationUnit.get(aDeletedFile);
+			if (classes!=null) {
+				for (Iterator iterator = classes.iterator(); iterator.hasNext();) {
+					ClassFile element = (ClassFile) iterator.next();
+					resolvedTypeStructuresFromLastBuild.remove(element.fullyQualifiedTypeName);
+				}
+			}			
 		}
 		return true;
     }
@@ -617,6 +626,7 @@ public class AjState {
 		return ucf;
 	}
 
+	
 	public void noteResult(InterimCompilationResult result) {
 		if (!maybeIncremental()) {
 			return;
@@ -770,7 +780,7 @@ public class AjState {
 			if (!rType.isMissing()) {
 				try {
 					ClassFileReader reader = new ClassFileReader(thisTime.getBytes(), null);
-					this.resolvedTypeStructuresFromLastBuild.put(thisTime.getClassName(),new CompactStructureRepresentation(reader));
+					this.resolvedTypeStructuresFromLastBuild.put(thisTime.getClassName(),new CompactTypeStructureRepresentation(reader));
 				} catch (ClassFormatException cfe) {
 					throw new BCException("Unexpected problem processing class",cfe);
 				}
@@ -778,12 +788,12 @@ public class AjState {
 			return;
 		}
 
-		CompactStructureRepresentation existingStructure = (CompactStructureRepresentation) this.resolvedTypeStructuresFromLastBuild.get(thisTime.getClassName());
+		CompactTypeStructureRepresentation existingStructure = (CompactTypeStructureRepresentation) this.resolvedTypeStructuresFromLastBuild.get(thisTime.getClassName());
 		ResolvedType newResolvedType = world.resolve(thisTime.getClassName());
 		if (!newResolvedType.isMissing()) {
 			try {
 				ClassFileReader reader = new ClassFileReader(thisTime.getBytes(), null);
-				this.resolvedTypeStructuresFromLastBuild.put(thisTime.getClassName(),new CompactStructureRepresentation(reader));
+				this.resolvedTypeStructuresFromLastBuild.put(thisTime.getClassName(),new CompactTypeStructureRepresentation(reader));
 			} catch (ClassFormatException cfe) {
 				throw new BCException("Unexpected problem processing class",cfe);
 			}
@@ -833,7 +843,7 @@ public class AjState {
 	 * @param existingType
 	 * @return
 	 */
-	private boolean hasStructuralChanges(ClassFileReader reader, CompactStructureRepresentation existingType) {
+	private boolean hasStructuralChanges(ClassFileReader reader, CompactTypeStructureRepresentation existingType) {
 		if (existingType == null) {
 			return true;
 		}
@@ -869,9 +879,9 @@ public class AjState {
 		}
 
 		// fields
-		MemberStructure[] existingFields = existingType.fields;
+//		CompactMemberStructureRepresentation[] existingFields = existingType.fields;
 		IBinaryField[] newFields = reader.getFields();
-		if (newFields == null) { newFields = new IBinaryField[0]; }
+		if (newFields == null) { newFields = CompactTypeStructureRepresentation.NoField; }
 
 		// all redundant for now ... could be an optimization at some point...
 		// remove any ajc$XXX fields from those we compare with
@@ -884,17 +894,18 @@ public class AjState {
 //			nonGenFields.add(field);
 //			//}
 //		}
-		if (newFields.length != existingFields.length) return true;
+		IBinaryField[] existingFs = existingType.binFields;
+		if (newFields.length != existingFs.length) return true;
 		new_field_loop: 
 			for (int i = 0; i < newFields.length; i++) {
 				IBinaryField field = newFields[i];
 				char[] fieldName = field.getName();
-				for (int j = 0; j < existingFields.length; j++) {
-					if (CharOperation.equals(existingFields[j].name,fieldName)) {
-						if (!modifiersEqual(field.getModifiers(),existingFields[j].modifiers)) {
+				for (int j = 0; j < existingFs.length; j++) {
+					if (CharOperation.equals(existingFs[j].getName(),fieldName)) {
+						if (!modifiersEqual(field.getModifiers(),existingFs[j].getModifiers())) {
 							return true;
 						}
-						if (!CharOperation.equals(existingFields[j].signature,field.getTypeName())) {
+						if (!CharOperation.equals(existingFs[j].getTypeName(),field.getTypeName())) {
 							return true;
 						}
 						continue new_field_loop;
@@ -904,9 +915,9 @@ public class AjState {
 			}
 
 		// methods
-		MemberStructure[] existingMethods = existingType.methods;
+//		CompactMemberStructureRepresentation[] existingMethods = existingType.methods;
 		IBinaryMethod[] newMethods = reader.getMethods();
-		if (newMethods == null) { newMethods = new IBinaryMethod[0]; }
+		if (newMethods == null) { newMethods = CompactTypeStructureRepresentation.NoMethod; }
 
 		// all redundant for now ... could be an optimization at some point...
 
@@ -944,15 +955,16 @@ public class AjState {
 //				  nonGenMethods.add(method);
 ////			}
 //		}
-		if (newMethods.length != existingMethods.length) return true;
+		IBinaryMethod[] existingMs = existingType.binMethods;
+		if (newMethods.length != existingMs.length) return true;
 		new_method_loop: 
 			for (int i = 0; i < newMethods.length; i++) {
 				IBinaryMethod method = newMethods[i];
 				char[] methodName = method.getSelector();
-				for (int j = 0; j < existingMethods.length; j++) {
-					if (CharOperation.equals(existingMethods[j].name,methodName)) {
+				for (int j = 0; j < existingMs.length; j++) {
+					if (CharOperation.equals(existingMs[j].getSelector(),methodName)) {
 						// candidate match
-						if (!CharOperation.equals(method.getMethodDescriptor(),existingMethods[j].signature)) {
+						if (!CharOperation.equals(method.getMethodDescriptor(),existingMs[j].getMethodDescriptor())) {
 						// ok, the descriptors don't match, but is this a funky ctor on a non-static inner
 						// type?
 //						boolean mightBeOK = 
@@ -973,7 +985,7 @@ public class AjState {
 							continue; // might be overloading
 						} else {
 							// matching sigs
-							if (!modifiersEqual(method.getModifiers(),existingMethods[j].modifiers)) {
+							if (!modifiersEqual(method.getModifiers(),existingMs[j].getModifiers())) {
 								return true;
 							}
 							continue new_method_loop;
@@ -1230,105 +1242,6 @@ public class AjState {
 		}
 	}
 
-	private static class CompactStructureRepresentation {
-		
-		char[] className;
-		int modifiers;
-		char[] genericSignature;
-		char[] superclassName;
-		char[][] interfaces;
-		MemberStructure[] fields;
-		MemberStructure[] methods;
-		
-		public CompactStructureRepresentation(ClassFileReader cfr) {
-			this.className = cfr.getName();  // slashes...
-			this.modifiers = cfr.getModifiers();
-			this.genericSignature = cfr.getGenericSignature();
-//			if (this.genericSignature.length == 0) {
-//				this.genericSignature = null;
-//			}
-			this.superclassName = cfr.getSuperclassName(); // slashes...
-			interfaces = cfr.getInterfaceNames();
-			
-			
-
-			IBinaryField[] rFields = cfr.getFields();
-			this.fields = new MemberStructure[rFields==null?0:rFields.length];
-			if (rFields!=null) {
-				for (int i = 0; i < rFields.length; i++) {
-					this.fields[i] = new MemberStructure();
-					this.fields[i].name = rFields[i].getName();
-					this.fields[i].modifiers = rFields[i].getModifiers();
-					this.fields[i].signature = rFields[i].getTypeName();
-				}
-			}
-			
-			IBinaryMethod[] rMethods = cfr.getMethods();
-			this.methods = new MemberStructure[rMethods==null?0:rMethods.length];
-			if (rMethods!=null) {
-				for (int i = 0; i < rMethods.length; i++) {
-					this.methods[i] = new MemberStructure();
-					this.methods[i].name = rMethods[i].getSelector();
-					this.methods[i].modifiers = rMethods[i].getModifiers();
-	//				StringBuffer sig = new StringBuffer();
-	//				sig.append("(");
-	//				UnresolvedType[] pTypes = rMethods[i].getMethodDescriptor();
-	//				for (int j = 0; j < pTypes.length; j++) {
-	//					sig.append(pTypes[j].getSignature());
-	//				}
-	//				sig.append(")");
-	//				sig.append(rMethods[i].getReturnType().getSignature());
-					this.methods[i].signature =rMethods[i].getMethodDescriptor();// sig.toString().toCharArray();
-				}
-			}
-		}
-		
-		public CompactStructureRepresentation(ResolvedType forType) {
-			this.className = forType.getName().replace('.','/').toCharArray();
-			this.modifiers = forType.getModifiers();
-			this.genericSignature = forType.getGenericSignature().toCharArray();
-			if (this.genericSignature.length == 0) {
-				this.genericSignature = null;
-			}
-			this.superclassName = forType.getSuperclass().getName().replace('.','/').toCharArray();
-			ResolvedType[] rTypes = forType.getDeclaredInterfaces();
-			this.interfaces = new char[rTypes.length][];
-			for (int i = 0; i < rTypes.length; i++) {
-				this.interfaces[i] = rTypes[i].getName().replace('.','/').toCharArray();
-			}
-			ResolvedMember[] rFields = forType.getDeclaredFields();
-			this.fields = new MemberStructure[rFields.length];
-			for (int i = 0; i < rFields.length; i++) {
-				this.fields[i] = new MemberStructure();
-				this.fields[i].name = rFields[i].getName().toCharArray();
-				this.fields[i].modifiers = rFields[i].getModifiers();
-				this.fields[i].signature = rFields[i].getReturnType().getSignature().toCharArray();
-			}
-			ResolvedMember[] rMethods = forType.getDeclaredMethods();
-			this.methods = new MemberStructure[rMethods.length];
-			for (int i = 0; i < rMethods.length; i++) {
-				this.methods[i] = new MemberStructure();
-				this.methods[i].name = rMethods[i].getName().toCharArray();
-				this.methods[i].modifiers = rMethods[i].getModifiers();
-				StringBuffer sig = new StringBuffer();
-				sig.append("(");
-				UnresolvedType[] pTypes = rMethods[i].getParameterTypes();
-				for (int j = 0; j < pTypes.length; j++) {
-					sig.append(pTypes[j].getSignature());
-				}
-				sig.append(")");
-				sig.append(rMethods[i].getReturnType().getSignature());
-				this.methods[i].signature = sig.toString().toCharArray();
-			}
-		}
-	}
-	
-	private static class MemberStructure {
-		char[] name;
-		int modifiers;
-		char[] signature;
-	}
-	
 	public void wipeAllKnowledge() {
 		buildManager.state = null;
 		buildManager.setStructureModel(null);
@@ -1350,4 +1263,8 @@ public class AjState {
 	public IStateListener getListener() {
 		return stateListener;
 	}
+
+	public IBinaryType checkPreviousBuild(String name) {
+		return (IBinaryType)resolvedTypeStructuresFromLastBuild.get(name);
+	}
 }
@@ -886,9 +886,9 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 		//System.out.println("compiling");
 		environment = getLibraryAccess(classpaths, filenames);
 
-		if (!state.getClassNameToFileMap().isEmpty()) {
-			environment = new StatefulNameEnvironment(environment, state.getClassNameToFileMap());
-		}
+		//if (!state.getClassNameToFileMap().isEmpty()) { // see pr133532 (disabled to state can be used to answer questions)
+		environment = new StatefulNameEnvironment(environment, state.getClassNameToFileMap(),state);
+		//}
 
 		org.aspectj.ajdt.internal.compiler.CompilerAdapter.setCompilerAdapterFactory(this);
 		org.aspectj.org.eclipse.jdt.internal.compiler.Compiler compiler = 
@@ -0,0 +1,20 @@
+package pkg;
+
+public aspect ANewTypeWizardPage {
+
+	public static int NewTypeWizardPage.F_PRIVILEGED = 1;
+	
+	after() : execution(* NewTypeWizardPage.setModifiers(..)) {
+		if(NewTypeWizardPage.F_PRIVILEGED != 0) {
+			
+		}
+	}
+	
+	before() : execution(int NewTypeWizardPage.getModifiers()) {
+		int i = 0;
+		if (((NewTypeWizardPage)thisJoinPoint.getThis()).isTrue()) {
+			i = NewTypeWizardPage.F_PRIVILEGED;
+		}
+	}
+	
+}
@@ -0,0 +1,18 @@
+package pkg;
+
+public class NewTypeWizardPage {
+
+	public int getModifiers() {
+		return 1;
+	}
+	
+	public boolean isTrue() {
+		return true;
+	}
+	
+	public void setModifiers(int modifiers, 
+			boolean canBeModified) {
+		
+	}
+	
+}
@@ -0,0 +1,20 @@
+package pkg;
+
+public aspect ANewTypeWizardPage {
+
+	public static int NewTypeWizardPage.F_PRIVILEGED = 2;
+	
+	after() : execution(* NewTypeWizardPage.setModifiers(..)) {
+		if(NewTypeWizardPage.F_PRIVILEGED != 0) {
+			
+		}
+	}
+	
+	before() : execution(int NewTypeWizardPage.getModifiers()) {
+		int i = 0;
+		if (((NewTypeWizardPage)thisJoinPoint.getThis()).isTrue()) {
+			i = NewTypeWizardPage.F_PRIVILEGED;
+		}
+	}
+	
+}
