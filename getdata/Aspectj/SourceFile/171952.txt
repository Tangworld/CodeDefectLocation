@@ -21,6 +21,8 @@ import junit.framework.Test;
  */
 public class Ajc160Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+  public void testGenericMethodsAndItds_pr171952() { runTest("generic methods and ITDs");}
+  //public void testUsingDecpAnnotationWithoutAspectAnnotation_pr169428() { runTest("using decp annotation without aspect annotation");}
   public void testItdsParameterizedParameters_pr170467() { runTest("itds and parameterized parameters");}
   public void testComplexGenerics_pr168044() { runTest("complex generics - 1");}
   public void testIncorrectlyMarkingFieldTransient_pr168063() { runTest("incorrectly marking field transient");}
@@ -5,12 +5,21 @@
 
  <!-- first section - dont need a 1.6 vm but fixed in the 1.6 branch of AspectJ -->
 
+    <ajc-test dir="bugs160/pr171952" title="generic methods and ITDs">
+      <compile files="Foo.java,FooAspect.java" options="-1.5"/>
+    </ajc-test>
+    
+    <ajc-test dir="bugs160/pr169428" title="using decp annotation without aspect annotation">
+      <compile files="AnAspect.java" options="-1.5">
+        <message kind="error" text="Found @AspectJ annotations in a non @Aspect type 'AnAspect'"/>
+      </compile>
+    </ajc-test>
+    
     <ajc-test dir="bugs160/pr170467" title="itds and parameterized parameters">
       <compile files="Bug.aj" options="-1.5"/>
       <compile files="Bug2.aj" options="-1.5"/>
     </ajc-test>
 
-    
     <ajc-test dir="bugs160/pr169706" title="inherited annotations">
       <compile files="A.java,B.java,C.java,MyAspect.java,MyAnnotation.java,Test.java" options="-1.5 -showWeaveInfo">
         <message kind="weave" text="Join point 'method-call(void C.foo())' in Type 'Test' (Test.java:5) advised by before advice from 'MyAspect' (MyAspect.java:4)"/>
@@ -314,6 +314,9 @@ public class ReferenceType extends ResolvedType {
        			if (myParameters.length == theirParameters.length) {
        				for (int i = 0; i < myParameters.length; i++) {
 						if (myParameters[i] == theirParameters[i]) continue;
+						if (myParameters[i].isAssignableFrom(theirParameters[i],allowMissing)) {
+							continue;
+						}
 						if (!myParameters[i].isGenericWildcard()) {
 							parametersAssignable = false;
 							break;
@@ -340,7 +343,8 @@ public class ReferenceType extends ResolvedType {
        	if (other.isTypeVariableReference()) {
        		TypeVariableReferenceType otherType = (TypeVariableReferenceType) other;
        		if (this instanceof TypeVariableReference) {
-       			return ((TypeVariableReference)this).getTypeVariable()==otherType.getTypeVariable();
+       			return ((TypeVariableReference)this).getTypeVariable().canBeBoundTo(otherType.getTypeVariable().getFirstBound().resolve(world));// pr171952
+//       			return ((TypeVariableReference)this).getTypeVariable()==otherType.getTypeVariable();
        		} else {
        		    // FIXME asc should this say canBeBoundTo??
        			return this.isAssignableFrom(otherType.getTypeVariable().getFirstBound().resolve(world));
@@ -0,0 +1,6 @@
+import java.util.List;
+
+public interface Foo {
+
+        <T> List<T> createList();
+}
\ No newline at end of file
@@ -0,0 +1,10 @@
+import java.util.ArrayList;
+import java.util.List;
+
+public aspect FooAspect {
+
+
+        public <T> List<T> Foo.createList() {
+                return new ArrayList<T>();
+        }
+}
\ No newline at end of file
