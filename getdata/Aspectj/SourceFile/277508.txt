@@ -10,16 +10,10 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.ajdt.internal.compiler.ast;
 
 import java.lang.reflect.Modifier;
 
-import org.aspectj.weaver.Member;
-import org.aspectj.weaver.ResolvedMemberImpl;
-import org.aspectj.weaver.UnresolvedType;
-import org.aspectj.weaver.patterns.IfPointcut;
-import org.aspectj.weaver.patterns.Pointcut;
 import org.aspectj.org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Expression;
@@ -32,79 +26,89 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.parser.Parser;
-
+import org.aspectj.weaver.Member;
+import org.aspectj.weaver.ResolvedMemberImpl;
+import org.aspectj.weaver.UnresolvedType;
+import org.aspectj.weaver.patterns.IfPointcut;
+import org.aspectj.weaver.patterns.Pointcut;
 
 /**
  * (formals*): ... if(expr) ...
  * 
- * generates the following:
- * public static final boolean ajc$if_N(formals*, [thisJoinPoints as needed]) {
- *     return expr;
- * }
+ * generates the following: public static final boolean ajc$if_N(formals*, [thisJoinPoints as needed]) { return expr; }
  * 
- * Here's the complicated bit, it deals with cflow:
- * 	(a): ... this(a) && cflow(if (a == foo)) is an error.
- * The way we capture this is:
- *  We generate the ajc$if method with an (a) parameter, we let eclipse do the proper
- * name binding.  We then, as a post pass (that we need to do anyway) look for the
- * used parameters.  If a is used, we signal an error because a was not one of the 
- * cflow variables. 
- * XXX we'll do this part after we do cflow
+ * Here's the complicated bit, it deals with cflow: (a): ... this(a) && cflow(if (a == foo)) is an error. The way we capture this
+ * is: We generate the ajc$if method with an (a) parameter, we let eclipse do the proper name binding. We then, as a post pass (that
+ * we need to do anyway) look for the used parameters. If a is used, we signal an error because a was not one of the cflow
+ * variables. XXX we'll do this part after we do cflow
  * 
- * The IfPointcut pcd then generates itself always as a dynamic test, it has to
- * get the right parameters through any named pointcut references...
+ * The IfPointcut pcd then generates itself always as a dynamic test, it has to get the right parameters through any named pointcut
+ * references...
  */
 public class IfPseudoToken extends PseudoToken {
-    public Expression expr;
-    public MethodDeclaration testMethod;
-    private IfPointcut pointcut;
-    
-	public IfPseudoToken(
-		Parser parser,
-		Expression expr) {
+	public Expression expr;
+	public MethodDeclaration testMethod;
+	private IfPointcut pointcut;
+
+	public IfPseudoToken(Parser parser, Expression expr) {
 		super(parser, "if", false);
 		this.expr = expr;
 	}
-	
+
 	public Pointcut maybeGetParsedPointcut() {
 		if (expr instanceof FalseLiteral) {
 			return IfPointcut.makeIfFalsePointcut(Pointcut.SYMBOLIC);
 		} else if (expr instanceof TrueLiteral) {
 			return IfPointcut.makeIfTruePointcut(Pointcut.SYMBOLIC);
 		} else {
-		  pointcut = new IfPointcut(new ResolvedMemberImpl(Member.METHOD, UnresolvedType.OBJECT, 0, "if_", "()V"), 0);
+			pointcut = new IfPointcut(new ResolvedMemberImpl(Member.METHOD, UnresolvedType.OBJECT, 0, "if_", "()V"), 0);
 		}
 		return pointcut;
-		
-	}
 
+	}
 
 	/**
 	 * enclosingDec is either AdviceDeclaration or PointcutDeclaration
 	 */
 	public void postParse(TypeDeclaration typeDec, MethodDeclaration enclosingDec) {
-//		typeDec.scope.problemReporter().signalError(sourceStart, sourceEnd,
-//			"if pcd is not implemented in 1.1alpha1");
-		//XXX need to implement correctly
-		if (pointcut == null) return;
+		// typeDec.scope.problemReporter().signalError(sourceStart, sourceEnd,
+		// "if pcd is not implemented in 1.1alpha1");
+		// XXX need to implement correctly
+		if (pointcut == null)
+			return;
+
 		testMethod = makeMethod(enclosingDec.compilationResult, enclosingDec);
 		AstUtil.addMethodDeclaration(typeDec, testMethod);
 	}
 
-
-	//XXX static state bad
-	private static int counter = 0;
-
-	//XXX todo: make sure that errors in Arguments only get displayed once
+	// XXX todo: make sure that errors in Arguments only get displayed once
 	private MethodDeclaration makeMethod(CompilationResult result, MethodDeclaration enclosingDec) {
 		MethodDeclaration ret = new IfMethodDeclaration(result, pointcut);
 		ret.modifiers = ClassFileConstants.AccStatic | ClassFileConstants.AccFinal | ClassFileConstants.AccPublic;
 		ret.returnType = AstUtil.makeTypeReference(TypeBinding.BOOLEAN);
-		ret.selector = ("ajc$if_" + counter++).toCharArray();
+		// create a more stable name 277508
+		StringBuffer ifSelector = new StringBuffer();
+		ifSelector.append("ajc$if$");
+		ifSelector.append(Integer.toHexString(expr.sourceStart));
+
+		// possibly even better logic for more reliable name:
+		// if (enclosingDec instanceof AdviceDeclaration) {
+		// // name is ajc$if$<adviceSequenceNumber>$<hashcodeOfIfExpressionInHex>
+		// ifSelector.append("ajc$if$");
+		// ifSelector.append(((AdviceDeclaration) enclosingDec).adviceSequenceNumberInType);
+		// ifSelector.append("$").append(Integer.toHexString(expr.toString().hashCode()));
+		// } else if (enclosingDec instanceof PointcutDeclaration) {
+		// // name is pointcut selector then $if$<hashcodeOfIfExpressionInHex>
+		// ifSelector.append(((PointcutDeclaration) enclosingDec).selector);
+		// ifSelector.append("$if$");
+		// ifSelector.append(Integer.toHexString(expr.toString().hashCode()));
+		// } else {
+		// throw new BCException("Unexpected enclosing declaration of " + enclosingDec + " for if pointcut designator");
+		// }
+		// hashcode of expression
+		ret.selector = ifSelector.toString().toCharArray();
 		ret.arguments = makeArguments(enclosingDec);
-		ret.statements = new Statement[] {
-			new ReturnStatement(expr, expr.sourceStart, expr.sourceEnd)
-		};
+		ret.statements = new Statement[] { new ReturnStatement(expr, expr.sourceStart, expr.sourceEnd) };
 		return ret;
 	}
 
@@ -112,17 +116,16 @@ public class IfPseudoToken extends PseudoToken {
 		Argument[] baseArguments = enclosingDec.arguments;
 		int len = baseArguments.length;
 		if (enclosingDec instanceof AdviceDeclaration) {
-			len = ((AdviceDeclaration)enclosingDec).baseArgumentCount;
+			len = ((AdviceDeclaration) enclosingDec).baseArgumentCount;
 		}
-		
+
 		Argument[] ret = new Argument[len];
-		for (int i=0; i < len; i ++) {
+		for (int i = 0; i < len; i++) {
 			Argument a = baseArguments[i];
-			ret[i] = new Argument(a.name, AstUtil.makeLongPos(a.sourceStart, a.sourceEnd),
-								a.type, Modifier.FINAL);
+			ret[i] = new Argument(a.name, AstUtil.makeLongPos(a.sourceStart, a.sourceEnd), a.type, Modifier.FINAL);
 		}
 		ret = AdviceDeclaration.addTjpArguments(ret);
-		
+
 		return ret;
 	}
 
@@ -0,0 +1,20 @@
+import java.lang.reflect.Method;
+
+public class Basic {
+ public static void main(String[] args) {
+	Method[] ms = X.class.getMethods();
+	for (int i = 0; i < ms.length; i++) {
+		if (ms[i].getName().indexOf("if$")!=-1) {
+			System.out.println("if method: "+ms[i]);
+		}
+	}
+}
+  public void m() {}
+}
+
+aspect X {
+  before(): execution(* m(..)) && if(true==true) && if(true==(true || true)) {
+  }
+  before(): execution(* m(..)) && if(true==true) {
+  }
+}
@@ -0,0 +1,20 @@
+import java.lang.reflect.Method;
+
+public class Basic2 {
+	
+ public static void main(String[] args) {
+	Method[] ms = X.class.getMethods();
+	for (int i = 0; i < ms.length; i++) {
+		if (ms[i].getName().indexOf("if$")!=-1) {
+			System.out.println("if method: "+ms[i]);
+		}
+	}
+}
+  public void m() {}
+}
+
+aspect X {
+  pointcut p(): execution(* m(..)) && if(true==true) && if(true==(true || true));
+  pointcut q(): execution(* m(..)) && if(true==true);
+  
+}
@@ -20,6 +20,14 @@ import org.aspectj.weaver.LintMessage;
 
 public class Ajc165Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testIfNames_pr277508() {
+		runTest("if method names");
+	}
+
+	public void testIfNames_pr277508_2() {
+		runTest("if method names - 2");
+	}
+
 	public void testDecAnnoMethod_pr275625() {
 		runTest("dec anno method");
 	}
@@ -2,6 +2,28 @@
 
 <suite>
 
+   <ajc-test dir="bugs165/pr277508" title="if method names">
+     <compile files="Basic.java" options="-1.5"/>
+     <run class="Basic">
+       <stdout>
+         <line text="if method: public static final boolean X.ajc$if$1ba()"/>
+         <line text="if method: public static final boolean X.ajc$if$177()"/>
+         <line text="if method: public static final boolean X.ajc$if$165()"/>
+       </stdout>
+     </run>
+   </ajc-test>
+   
+   <ajc-test dir="bugs165/pr277508" title="if method names - 2">
+     <compile files="Basic2.java" options="-1.5"/>
+     <run class="Basic2">
+       <stdout>
+         <line text="if method: public static final boolean X.ajc$if$16d()"/>
+         <line text="if method: public static final boolean X.ajc$if$17f()"/>
+         <line text="if method: public static final boolean X.ajc$if$1c0()"/>
+       </stdout>
+     </run>
+   </ajc-test>
+   
    <ajc-test dir="bugs165/pr275625" title="dec anno method">
      <compile files="A.java" options="-1.5"/>
    </ajc-test>
