@@ -0,0 +1,11 @@
+package test;
+
+import test.Test;
+
+public privileged aspect ITDAspect {
+	public void Test.itdFunction() {
+		System.out.println("ITD function");
+		privateMethod();
+		publicMethod();
+	}
+}
@@ -0,0 +1,28 @@
+package test;
+
+public class Test {
+
+	public Test() {
+	}
+	
+	public static void main(String[] args) {
+		Test t = new Test();
+		t.function();
+		t.itdFunction();
+	}
+	
+	public void function() {
+		System.out.println("Normal function");
+		privateMethod();
+		publicMethod();
+	}
+	
+	private void privateMethod() {
+		System.out.println("private method");
+	}
+	
+	public void publicMethod() {
+		System.out.println("public method");
+	}
+
+}
@@ -0,0 +1,8 @@
+package test;
+
+public aspect TestAspect {
+	Object around(): call(* Test.*(..)) {
+		System.out.println("Around " + thisJoinPoint.toString());
+		return proceed();
+	}
+}
@@ -0,0 +1,10 @@
+package test;
+
+import test.Test;
+
+public privileged aspect ITDAspect {
+	public void Test.itdFunction() {
+		System.out.println("ITD function");
+		privateMethod("Foo");
+	}
+}
@@ -0,0 +1,16 @@
+package test;
+
+public class Test {
+
+	public Test() {
+	}
+	
+	public static void main(String[] args) {
+		Test t = new Test();
+		t.itdFunction();
+	}
+	
+	private void privateMethod(String xxx) {
+		System.out.println("hello "+xxx);
+	}
+}
@@ -0,0 +1,9 @@
+package test;
+
+public aspect TestAspect {
+	Object around(String s): call(* Test.*(..)) && args(s) {
+		System.out.println("Around " + thisJoinPoint.toString());
+		System.out.println("Captured "+s);
+		return proceed(s.toUpperCase());
+	}
+}
@@ -24,6 +24,14 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
  */
 public class Ajc187Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testMissingJoinpoint_307147() throws Exception {
+		runTest("missing joinpoint");
+	}
+
+	public void testMissingJoinpoint_307147_2() throws Exception {
+		runTest("missing joinpoint 2");
+	}
+	
 	public void testInfiniteLoop_475152() throws Exception {
 		runTest("infinite loop");
 	}
@@ -2,6 +2,36 @@
 
 <suite>
 
+<ajc-test dir="bugs187/307147" title="missing joinpoint">
+<compile files="Test.java TestAspect.aj ITDAspect.aj" options="-1.8"/>
+<run class="test.Test">
+<stdout>
+<line text="Around call(void test.Test.function())"/>
+<line text="Normal function"/>
+<line text="Around call(void test.Test.privateMethod())"/>
+<line text="private method"/>
+<line text="Around call(void test.Test.publicMethod())"/>
+<line text="public method"/>
+<line text="Around call(void test.Test.itdFunction())"/>
+<line text="ITD function"/>
+<line text="Around call(void test.Test.privateMethod())"/>
+<line text="private method"/>
+<line text="Around call(void test.Test.publicMethod())"/>
+<line text="public method"/>
+</stdout></run>
+</ajc-test>
+
+<ajc-test dir="bugs187/307147_2" title="missing joinpoint 2">
+<compile files="Test.java TestAspect.aj ITDAspect.aj" options="-1.8"/>
+<run class="test.Test">
+<stdout>
+<line text="ITD function"/>
+<line text="Around call(void test.Test.privateMethod(String))"/>
+<line text="Captured Foo"/>
+<line text="hello FOO"/>
+</stdout></run>
+</ajc-test>
+
 <ajc-test dir="bugs187/475152" title="infinite loop">
 <compile files="AbstractAspect.aj, BaseAspect.aj, TestClass.java, AjTarget.java, TestAspect.aj" options="-1.8"/>
 </ajc-test>
@@ -3209,6 +3209,13 @@ class BcelClassWeaver implements IClassWeaver {
 				if (canMatch(Shadow.FieldGet) || canMatch(Shadow.FieldSet)) {
 					match(BcelShadow.makeShadowForMethodCall(world, mg, ih, enclosingShadow, kind, declaredSig), shadowAccumulator);
 				}
+			} else if (!declaredSig.getName().startsWith(NameMangler.PREFIX)) {
+				// 307147 - resolution above may have found the real method directly rather
+				// than needing to go through the effective signature attribute
+				if (canMatch(Shadow.MethodCall)) {
+					match(BcelShadow.makeShadowForMethodCall(world, mg, ih, enclosingShadow, Shadow.MethodCall, declaredSig),
+							shadowAccumulator);
+				}
 			} else {
 				AjAttribute.EffectiveSignatureAttribute effectiveSig = declaredSig.getEffectiveSignature();
 				if (effectiveSig == null) {
@@ -44,6 +44,7 @@ import org.aspectj.bridge.MessageUtil;
 import org.aspectj.bridge.WeaveMessage;
 import org.aspectj.bridge.context.CompilationAndWeavingContext;
 import org.aspectj.bridge.context.ContextToken;
+import org.aspectj.weaver.AjAttribute;
 import org.aspectj.weaver.AjcMemberMaker;
 import org.aspectj.weaver.AnnotationAJ;
 import org.aspectj.weaver.AnnotationOnTypeMunger;
@@ -630,6 +630,32 @@ public class BcelWorld extends World implements Repository {
 		UnresolvedType declaringType = null;
 
 		String signature = ii.getSignature(cpg);
+		
+		// 307147
+		if (name.startsWith("ajc$privMethod$")) {
+			// The invoke is on a privileged accessor. These may be created for different
+			// kinds of target, not necessarily just private methods. In bug 307147 it is
+			// for a private method. This code is identifying the particular case in 307147
+			try {
+				declaringType = UnresolvedType.forName(declaring);
+				String typeNameAsFoundInAccessorName = declaringType.getName().replace('.', '_');
+				int indexInAccessorName = name.lastIndexOf(typeNameAsFoundInAccessorName);
+				if (indexInAccessorName != -1) {
+					String methodName = name.substring(indexInAccessorName+typeNameAsFoundInAccessorName.length()+1);
+					ResolvedType resolvedDeclaringType = declaringType.resolve(this);
+					ResolvedMember[] methods = resolvedDeclaringType.getDeclaredMethods();
+					for (ResolvedMember method: methods) {
+						if (method.getName().equals(methodName) && method.getSignature().equals(signature) && Modifier.isPrivate(method.getModifiers())) {
+							return method;
+						}
+					}
+				}
+			} catch (Exception e) {
+				// Remove this once confident above code isn't having unexpected side effects
+				// Added 1.8.7
+				e.printStackTrace();
+			}
+		}
 
 		int modifier = (ii instanceof INVOKEINTERFACE) ? Modifier.INTERFACE
 				: (ii.opcode == Constants.INVOKESTATIC) ? Modifier.STATIC : (ii.opcode == Constants.INVOKESPECIAL && !name
@@ -2,6 +2,13 @@
 
 <suite>
 
+   <ajc-test dir="bugs169/pr307147" title="advising privileged access method">
+     <compile files="B.java Test2.java" options="-showWeaveInfo">
+       <message kind="weave" text="Type 'B' (B.java) has intertyped method from 'Test'"/>
+       <message kind="weave" text="Join point 'field-get(int A.goo)' in Type 'Test'"/>
+     </compile>
+  </ajc-test>
+  
    <ajc-test dir="bugs169/pr307120" title="advising privileged access member">
      <compile files="A.java Test.java" options="-showWeaveInfo">
        <message kind="weave" text="Type 'A' (A.java) has intertyped method from 'Test'"/> <!-- getFoo and getGoo -->
@@ -0,0 +1,3 @@
+public class B {
+  private void m() {}
+}
@@ -0,0 +1,10 @@
+privileged
+aspect Test {
+	
+	before(): call(* m(..)) {}
+	
+	public void B.getFoo() {
+          m();
+        }
+
+}
