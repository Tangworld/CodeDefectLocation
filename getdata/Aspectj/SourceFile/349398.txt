@@ -0,0 +1,35 @@
+//package info.unterstein.hagen.moderne.ea6.a3;
+
+import java.util.HashMap;
+
+/**
+ * Enables a more complex and generic caching aspect which can be extended to
+be
+ * used in several use cases.
+ * 
+ * @author <a href="mailto:unterstein@me.com">Johannes Unterstein</a>
+ * @param <k>
+ *            the class of the keys
+ * @param <V>
+ *            the class of the cached values
+ */
+public abstract aspect CacheAspect<V> {
+    private HashMap<Object, V> cache;
+
+    public abstract pointcut cachePoint(Object key);
+
+    V around(Object key) : cachePoint(key) {
+        if (this.cache == null) {
+            this.cache = new HashMap<Object, V>();
+        }
+        V result;
+        if (this.cache.containsKey(key)) {
+            result = this.cache.get(key);
+        } else {
+            result = proceed(key);
+            this.cache.put(key, result);
+        }
+Object o = this.cache;
+        return result;
+    }
+}
@@ -0,0 +1,14 @@
+//package info.unterstein.hagen.moderne.ea6.a3;
+
+public class DataGenerator {
+
+    private static final int MAGIC_NUMBER = 23;
+
+    public Integer getData(Integer i) {
+        try {
+            Thread.sleep(100);
+        } catch (InterruptedException ex) {
+        }
+        return new Integer(i * MAGIC_NUMBER);
+    }
+}
@@ -0,0 +1,13 @@
+//package info.unterstein.hagen.moderne.ea6.a3;
+
+/**
+ * An extension of the generic cache for the concrete use case of caching the
+ * {@link DataGenerator}.
+ * 
+ * @author <a href="mailto:unterstein@me.com">Johannes Unterstein</a>
+ */
+public aspect DataGeneratorCacheAspect extends CacheAspect<Integer> {
+
+    public pointcut cachePoint(Object key) : call(Integer
+DataGenerator.getData(Integer)) && args(key);
+}
@@ -0,0 +1,41 @@
+//package info.unterstein.hagen.moderne.ea6.a3;
+
+public class DataGeneratorTest  {
+  public static void main(String []argv) {
+    new DataGeneratorTest().testGetData();
+    new DataGeneratorTest().testGetDataSpeedUp();
+  }
+
+    public void testGetData() {
+        DataGenerator generator = new DataGenerator();
+        assertEquals(new Integer(0), generator.getData(0));
+        assertEquals(new Integer(23), generator.getData(1));
+        assertEquals(new Integer(2 * 23), generator.getData(2));
+    }
+
+    public void assertEquals(Object o, Object p) {
+      if (!o.equals(p)) {
+        throw new IllegalStateException();
+      }
+    }
+
+    public void assertTrue(boolean b) {
+      if (!b) {
+        throw new IllegalStateException();
+      }
+    }
+
+    public void testGetDataSpeedUp() {
+        DataGenerator generator = new DataGenerator();
+        long before = System.currentTimeMillis();
+        for (int i = 0; i < 5; i++) {
+            generator.getData(i);
+        }
+        for (int i = 0; i < 5; i++) {
+            generator.getData(0);
+        }
+        long after = System.currentTimeMillis();
+        assertTrue((after - before) < 600);
+    }
+}
+
@@ -25,6 +25,10 @@ public class Ajc1612Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	// runTest("anno copying");
 	// }
 
+	public void testDuplicateMethods_349398() {
+		runTest("duplicate methods");
+	}
+
 	public void testBindingInts_347684() {
 		runTest("binding ints");
 	}
@@ -2,6 +2,13 @@
 
 <suite>
 
+<ajc-test dir="bugs1612/pr349398" title="duplicate methods">
+<compile files="DataGenerator.java CacheAspect.java DataGeneratorCacheAspect.java DataGeneratorTest.java" options="-1.5"/>
+<run class="DataGeneratorTest">
+</run>
+</ajc-test>
+
+
 <ajc-test dir="bugs1612/pr347684" title="binding ints">
 <compile files="BindingInts.java" options="-1.5"/>
 <run class="BindingInts">
@@ -14,6 +14,9 @@ package org.aspectj.ajdt.internal.compiler.ast;
 
 //import java.util.Arrays;
 
+import java.util.HashMap;
+import java.util.Map;
+
 import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.ajdt.internal.compiler.lookup.InlineAccessFieldBinding;
 import org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding;
@@ -60,6 +63,7 @@ public class AccessForInlineVisitor extends ASTVisitor {
 	PrivilegedHandler handler;
 	AspectDeclaration inAspect;
 	EclipseFactory world; // alias for inAspect.world
+	private Map<TypeBinding, Map<FieldBinding, ResolvedMember>> alreadyProcessedReceivers = new HashMap<TypeBinding, Map<FieldBinding, ResolvedMember>>();
 
 	// set to true for ClassLiteralAccess and AssertStatement
 	// ??? A better answer would be to transform these into inlinable forms
@@ -159,13 +163,22 @@ public class AccessForInlineVisitor extends ASTVisitor {
 			binding.modifiers = AstUtil.makePackageVisible(binding.modifiers);
 		}
 
-		ResolvedMember m = world.makeResolvedMember(binding, receiverType);
-		if (inAspect.accessForInline.containsKey(m))
+		// Avoid repeatedly building ResolvedMembers by using info on any done previously in this visitor
+		Map<FieldBinding, ResolvedMember> alreadyResolvedMembers = alreadyProcessedReceivers.get(receiverType);
+		if (alreadyResolvedMembers == null) {
+			alreadyResolvedMembers = new HashMap<FieldBinding, ResolvedMember>();
+			alreadyProcessedReceivers.put(receiverType, alreadyResolvedMembers);
+		}
+		ResolvedMember m = alreadyResolvedMembers.get(binding);
+		if (m == null) {
+			m = world.makeResolvedMember(binding, receiverType);
+			alreadyResolvedMembers.put(binding, m);
+		}
+
+		if (inAspect.accessForInline.containsKey(m)) {
 			return (FieldBinding) inAspect.accessForInline.get(m);
+		}
 		FieldBinding ret = new InlineAccessFieldBinding(inAspect, binding, m);
-
-		// System.err.println("   made accessor: " + ret);
-
 		inAspect.accessForInline.put(m, ret);
 		return ret;
 	}
