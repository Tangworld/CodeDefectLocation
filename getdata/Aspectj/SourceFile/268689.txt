@@ -0,0 +1,12 @@
+/**
+ * 
+ */
+package none;
+
+/**
+ * @author Dawid Pytel
+ *
+ */
+public aspect ConcreteAspect extends GenericAspect<String> {
+
+}
@@ -0,0 +1,16 @@
+/**
+ * 
+ */
+package none;
+
+/**
+ * @author Dawid Pytel
+ * 
+ */
+public abstract aspect GenericAspect<T> {
+
+	interface SomeInterface {
+	}
+
+	pointcut SomeConstructor(SomeInterface var) : execution(* SomeInterface(..)) && this(var);
+}
@@ -34,6 +34,10 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testGenericAspectsNpe_pr268689() {
+		runTest("generics aspects npe");
+	}
+
 	public void testGenericsItdNpe_pr267559() {
 		runTest("generics and itd npe");
 	}
@@ -1,6 +1,12 @@
 <!DOCTYPE suite SYSTEM "../tests/ajcTestSuite.dtd"[]>
 
 <suite>
+
+   <ajc-test dir="bugs164/pr268689" title="generics aspects npe">
+     <compile files="GenericAspect.aj ConcreteAspect.aj" options="-1.5">
+       <message kind="error" line="15" text="parameterized types not supported for this and target pointcuts (erasure limitation)"/>
+     </compile>
+   </ajc-test>
 
    <ajc-test dir="bugs164/pr267559" title="generics and itd npe">
      <compile files="IMarker.java ClassB.java Aspect.java ClassA.java" options="-1.5"/>
@@ -694,11 +694,13 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 			}
 		}
 
-		UnresolvedType parameterizedReturnType = parameterize(getGenericReturnType(), typeMap, isParameterized);
+		UnresolvedType parameterizedReturnType = parameterize(getGenericReturnType(), typeMap, isParameterized, newDeclaringType
+				.getWorld());
 		UnresolvedType[] parameterizedParameterTypes = new UnresolvedType[getGenericParameterTypes().length];
 		UnresolvedType[] genericParameterTypes = getGenericParameterTypes();
 		for (int i = 0; i < parameterizedParameterTypes.length; i++) {
-			parameterizedParameterTypes[i] = parameterize(genericParameterTypes[i], typeMap, isParameterized);
+			parameterizedParameterTypes[i] = parameterize(genericParameterTypes[i], typeMap, isParameterized, newDeclaringType
+					.getWorld());
 		}
 		ResolvedMemberImpl ret = new ResolvedMemberImpl(getKind(), newDeclaringType, getModifiers(), parameterizedReturnType,
 				getName(), parameterizedParameterTypes, getExceptions(), this);
@@ -782,10 +784,6 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 		return typeVariables;
 	}
 
-	protected UnresolvedType parameterize(UnresolvedType aType, Map typeVariableMap, boolean inParameterizedType) {
-		return parameterize(aType, typeVariableMap, inParameterizedType, null);
-	}
-
 	protected UnresolvedType parameterize(UnresolvedType aType, Map typeVariableMap, boolean inParameterizedType, World w) {
 		if (aType instanceof TypeVariableReference) {
 			String variableName = ((TypeVariableReference) aType).getTypeVariable().getName();
@@ -796,16 +794,12 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 			return (UnresolvedType) typeVariableMap.get(variableName);
 		} else if (aType.isParameterizedType()) {
 			if (inParameterizedType) {
-				// if (!(getDeclaringType() instanceof ResolvedType)) {
-				// int stop = 1;
-				// }
-				// if (aType!=null) {// instanceof UnresolvedType) {
 				if (w != null)
 					aType = aType.resolve(w);
 				else {
-					aType = aType.resolve(((ResolvedType) getDeclaringType()).getWorld());
+					UnresolvedType dType = getDeclaringType();
+					aType = aType.resolve(((ResolvedType) dType).getWorld());
 				}
-				// }
 				return aType.parameterize(typeVariableMap);
 			} else {
 				return aType.getRawType();
@@ -818,7 +812,7 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 			// dims++;
 			UnresolvedType arrayType = null;
 			UnresolvedType componentSig = UnresolvedType.forSignature(sig.substring(dims));
-			UnresolvedType parameterizedComponentSig = parameterize(componentSig, typeVariableMap, inParameterizedType);
+			UnresolvedType parameterizedComponentSig = parameterize(componentSig, typeVariableMap, inParameterizedType, w);
 			if (parameterizedComponentSig.isTypeVariableReference()
 					&& parameterizedComponentSig instanceof UnresolvedTypeVariableReferenceType
 					&& typeVariableMap.containsKey(((UnresolvedTypeVariableReferenceType) parameterizedComponentSig)
@@ -10,7 +10,6 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.weaver;
 
 import java.io.DataOutputStream;
@@ -20,50 +19,32 @@ import java.util.Map;
 
 import org.aspectj.weaver.patterns.Pointcut;
 
-
 public class ResolvedPointcutDefinition extends ResolvedMemberImpl {
 	private Pointcut pointcut;
 
-    public ResolvedPointcutDefinition(
-        UnresolvedType declaringType,
-        int modifiers,
-        String name,
-        UnresolvedType[] parameterTypes,
-        Pointcut pointcut)
-    {
-        this(declaringType, modifiers, name, parameterTypes, ResolvedType.VOID, pointcut);
-    }
-
-    /**
-     * An instance which can be given a specific returnType, used f.e. in if() pointcut for @AJ
-     * 
-     * @param declaringType
-     * @param modifiers
-     * @param name
-     * @param parameterTypes
-     * @param returnType
-     * @param pointcut
-     */
-    public ResolvedPointcutDefinition(
-		UnresolvedType declaringType,
-		int modifiers,
-		String name,
-		UnresolvedType[] parameterTypes,
-        UnresolvedType returnType,
-		Pointcut pointcut)
-    {
-		super(
-			POINTCUT,
-			declaringType,
-			modifiers,
-			returnType,
-			name,
-			parameterTypes);
+	public ResolvedPointcutDefinition(UnresolvedType declaringType, int modifiers, String name, UnresolvedType[] parameterTypes,
+			Pointcut pointcut) {
+		this(declaringType, modifiers, name, parameterTypes, ResolvedType.VOID, pointcut);
+	}
+
+	/**
+	 * An instance which can be given a specific returnType, used f.e. in if() pointcut for @AJ
+	 * 
+	 * @param declaringType
+	 * @param modifiers
+	 * @param name
+	 * @param parameterTypes
+	 * @param returnType
+	 * @param pointcut
+	 */
+	public ResolvedPointcutDefinition(UnresolvedType declaringType, int modifiers, String name, UnresolvedType[] parameterTypes,
+			UnresolvedType returnType, Pointcut pointcut) {
+		super(POINTCUT, declaringType, modifiers, returnType, name, parameterTypes);
 		this.pointcut = pointcut;
-		//XXXpointcut.assertState(Pointcut.RESOLVED);
+		// XXXpointcut.assertState(Pointcut.RESOLVED);
 		checkedExceptions = UnresolvedType.NONE;
 	}
-	
+
 	// ----
 
 	public void write(DataOutputStream s) throws IOException {
@@ -73,90 +54,82 @@ public class ResolvedPointcutDefinition extends ResolvedMemberImpl {
 		UnresolvedType.writeArray(getParameterTypes(), s);
 		pointcut.write(s);
 	}
-	
+
 	public static ResolvedPointcutDefinition read(VersionedDataInputStream s, ISourceContext context) throws IOException {
-		ResolvedPointcutDefinition rpd =
-		  new ResolvedPointcutDefinition(
-			UnresolvedType.read(s),
-			s.readInt(),
-			s.readUTF(),
-			UnresolvedType.readArray(s),
-			Pointcut.read(s, context));
+		ResolvedPointcutDefinition rpd = new ResolvedPointcutDefinition(UnresolvedType.read(s), s.readInt(), s.readUTF(),
+				UnresolvedType.readArray(s), Pointcut.read(s, context));
 		rpd.setSourceContext(context); // whilst we have a source context, let's remember it
 		return rpd;
 	}
-	
+
 	public String toString() {
 		StringBuffer buf = new StringBuffer();
 		buf.append("pointcut ");
-		buf.append((getDeclaringType()==null?"<nullDeclaringType>":getDeclaringType().getName()));
+		buf.append((getDeclaringType() == null ? "<nullDeclaringType>" : getDeclaringType().getName()));
 		buf.append(".");
 		buf.append(getName());
 		buf.append("(");
-		for (int i=0; i < getParameterTypes().length; i++) {
-			if (i > 0) buf.append(", ");
+		for (int i = 0; i < getParameterTypes().length; i++) {
+			if (i > 0)
+				buf.append(", ");
 			buf.append(getParameterTypes()[i].toString());
 		}
 		buf.append(")");
-		//buf.append(pointcut);
-		
+		// buf.append(pointcut);
+
 		return buf.toString();
 	}
-	
+
 	public Pointcut getPointcut() {
 		return pointcut;
 	}
-	
+
 	public boolean isAjSynthetic() {
 		return true;
 	}
-	
+
 	/**
 	 * Called when asking a parameterized super-aspect for its pointcuts.
 	 */
-	public ResolvedMemberImpl parameterizedWith(UnresolvedType[] typeParameters, ResolvedType newDeclaringType, boolean isParameterized) {
+	public ResolvedMemberImpl parameterizedWith(UnresolvedType[] typeParameters, ResolvedType newDeclaringType,
+			boolean isParameterized) {
 		TypeVariable[] typeVariables = getDeclaringType().resolve(newDeclaringType.getWorld()).getTypeVariables();
 		if (isParameterized && (typeVariables.length != typeParameters.length)) {
 			throw new IllegalStateException("Wrong number of type parameters supplied");
 		}
 		Map typeMap = new HashMap();
-		boolean typeParametersSupplied = typeParameters!=null && typeParameters.length>0;
-		if (typeVariables!=null) {
+		boolean typeParametersSupplied = typeParameters != null && typeParameters.length > 0;
+		if (typeVariables != null) {
 			// If no 'replacements' were supplied in the typeParameters array then collapse
 			// type variables to their first bound.
 			for (int i = 0; i < typeVariables.length; i++) {
-				UnresolvedType ut = (!typeParametersSupplied?typeVariables[i].getFirstBound():typeParameters[i]);
-				typeMap.put(typeVariables[i].getName(),ut);
+				UnresolvedType ut = (!typeParametersSupplied ? typeVariables[i].getFirstBound() : typeParameters[i]);
+				typeMap.put(typeVariables[i].getName(), ut);
 			}
 		}
-		UnresolvedType parameterizedReturnType = parameterize(getGenericReturnType(),typeMap,isParameterized);
+		UnresolvedType parameterizedReturnType = parameterize(getGenericReturnType(), typeMap, isParameterized, newDeclaringType
+				.getWorld());
 		UnresolvedType[] parameterizedParameterTypes = new UnresolvedType[getGenericParameterTypes().length];
 		for (int i = 0; i < parameterizedParameterTypes.length; i++) {
-			parameterizedParameterTypes[i] = 
-				parameterize(getGenericParameterTypes()[i], typeMap,isParameterized);
+			parameterizedParameterTypes[i] = parameterize(getGenericParameterTypes()[i], typeMap, isParameterized, newDeclaringType
+					.getWorld());
 		}
-		ResolvedPointcutDefinition ret = new ResolvedPointcutDefinition(
-					newDeclaringType,
-					getModifiers(),
-					getName(),
-					parameterizedParameterTypes,
-					parameterizedReturnType,
-					pointcut.parameterizeWith(typeMap,newDeclaringType.getWorld())
-				);
+		ResolvedPointcutDefinition ret = new ResolvedPointcutDefinition(newDeclaringType, getModifiers(), getName(),
+				parameterizedParameterTypes, parameterizedReturnType, pointcut.parameterizeWith(typeMap, newDeclaringType
+						.getWorld()));
 		ret.setTypeVariables(getTypeVariables());
 		ret.setSourceContext(getSourceContext());
-		ret.setPosition(getStart(),getEnd());
+		ret.setPosition(getStart(), getEnd());
 		ret.setParameterNames(getParameterNames());
 		return ret;
-		//return this;
+		// return this;
 	}
-	
+
 	// for testing
-	public static final ResolvedPointcutDefinition DUMMY =
-	    new ResolvedPointcutDefinition(UnresolvedType.OBJECT, 0, "missing", 
-	    				UnresolvedType.NONE, Pointcut.makeMatchesNothing(Pointcut.RESOLVED));
-	
-	public static final ResolvedPointcutDefinition[] NO_POINTCUTS = new ResolvedPointcutDefinition[]{};
+	public static final ResolvedPointcutDefinition DUMMY = new ResolvedPointcutDefinition(UnresolvedType.OBJECT, 0, "missing",
+			UnresolvedType.NONE, Pointcut.makeMatchesNothing(Pointcut.RESOLVED));
+
+	public static final ResolvedPointcutDefinition[] NO_POINTCUTS = new ResolvedPointcutDefinition[] {};
 
 	public void setPointcut(Pointcut pointcut) {
 		this.pointcut = pointcut;
