@@ -462,7 +462,9 @@
 		</compile>	        
       	<compile files="Aspect1.aj" options="-Xlint:warning -showWeaveInfo -inpath .">
 	        <message kind="weave" text="void Interface.interfaceMethod()"/>
+	        <!--
 	        <message kind="warning" text="can't determine superclass of missing type Missing"/>
+	        -->
 		</compile>	        
       	<run class="TestWithMissing">
 			<stdout>
@@ -13,287 +13,286 @@ import java.util.Iterator;
 import java.util.Set;
 import java.util.StringTokenizer;
 
-import org.aspectj.weaver.Shadow;
-import org.aspectj.weaver.patterns.AndPointcut;
-import org.aspectj.weaver.patterns.IfPointcut;
-import org.aspectj.weaver.patterns.NotPointcut;
-import org.aspectj.weaver.patterns.OrPointcut;
-import org.aspectj.weaver.patterns.PatternParser;
-import org.aspectj.weaver.patterns.Pointcut;
-import org.aspectj.weaver.patterns.PointcutRewriter;
-
 import junit.framework.TestCase;
 
+import org.aspectj.weaver.Shadow;
+
 /**
  * @author colyer
- *
- * TODO To change the template for this generated type comment go to
- * Window - Preferences - Java - Code Style - Code Templates
+ * 
+ *         TODO To change the template for this generated type comment go to Window - Preferences - Java - Code Style - Code
+ *         Templates
  */
 public class PointcutRewriterTest extends TestCase {
 
 	private PointcutRewriter prw;
-	
+
 	public void testDistributeNot() {
 		Pointcut plain = getPointcut("this(Foo)");
-		assertEquals("Unchanged",plain,prw.rewrite(plain));
+		assertEquals("Unchanged", plain, prw.rewrite(plain));
 		Pointcut not = getPointcut("!this(Foo)");
-		assertEquals("Unchanged",not,prw.rewrite(not));
+		assertEquals("Unchanged", not, prw.rewrite(not));
 		Pointcut notNot = getPointcut("!!this(Foo)");
-		assertEquals("this(Foo)",prw.rewrite(notNot).toString());
+		assertEquals("this(Foo)", prw.rewrite(notNot).toString());
 		Pointcut notNotNOT = getPointcut("!!!this(Foo)");
-		assertEquals("!this(Foo)",prw.rewrite(notNotNOT).toString());
+		assertEquals("!this(Foo)", prw.rewrite(notNotNOT).toString());
 		Pointcut and = getPointcut("!(this(Foo) && this(Goo))");
-		assertEquals("(!this(Foo) || !this(Goo))",prw.rewrite(and,true).toString());
+		assertEquals("(!this(Foo) || !this(Goo))", prw.rewrite(and, true).toString());
 		Pointcut or = getPointcut("!(this(Foo) || this(Goo))");
-		assertEquals("(!this(Foo) && !this(Goo))",prw.rewrite(or,true).toString());
+		assertEquals("(!this(Foo) && !this(Goo))", prw.rewrite(or, true).toString());
 		Pointcut nestedNot = getPointcut("!(this(Foo) && !this(Goo))");
-		assertEquals("(!this(Foo) || this(Goo))",prw.rewrite(nestedNot,true).toString());
+		assertEquals("(!this(Foo) || this(Goo))", prw.rewrite(nestedNot, true).toString());
 	}
-	
+
 	public void testPullUpDisjunctions() {
 		Pointcut aAndb = getPointcut("this(Foo) && this(Goo)");
-		assertEquals("Unchanged",aAndb,prw.rewrite(aAndb));
+		assertEquals("Unchanged", aAndb, prw.rewrite(aAndb));
 		Pointcut aOrb = getPointcut("this(Foo) || this(Moo)");
-		assertEquals("Unchanged",aOrb,prw.rewrite(aOrb));
+		assertEquals("Unchanged", aOrb, prw.rewrite(aOrb));
 
 		Pointcut leftOr = getPointcut("this(Foo) || (this(Goo) && this(Boo))");
-		assertEquals("or%anyorder%this(Foo)%and%anyorder%this(Boo)%this(Goo)",prw.rewrite(leftOr));
-		//assertEquals("(this(Foo) || (this(Boo) && this(Goo)))",prw.rewrite(leftOr).toString());
-		
+		assertEquals("or%anyorder%this(Foo)%and%anyorder%this(Boo)%this(Goo)", prw.rewrite(leftOr));
+		// assertEquals("(this(Foo) || (this(Boo) && this(Goo)))",prw.rewrite(leftOr).toString());
+
 		Pointcut rightOr = getPointcut("(this(Goo) && this(Boo)) || this(Foo)");
-//		assertEquals("(this(Foo) || (this(Boo) && this(Goo)))",prw.rewrite(rightOr).toString());
-		assertEquals("or%anyorder%this(Foo)%and%anyorder%this(Goo)%this(Boo)",prw.rewrite(rightOr));
-		
+		// assertEquals("(this(Foo) || (this(Boo) && this(Goo)))",prw.rewrite(rightOr).toString());
+		assertEquals("or%anyorder%this(Foo)%and%anyorder%this(Goo)%this(Boo)", prw.rewrite(rightOr));
+
 		Pointcut leftAnd = getPointcut("this(Foo) && (this(Goo) || this(Boo))");
-//		assertEquals("((this(Boo) && this(Foo)) || (this(Foo) && this(Goo)))",prw.rewrite(leftAnd).toString());
-		assertEquals("or%anyorder%and%anyorder%this(Boo)%this(Foo)%and%anyorder%this(Foo)%this(Goo)",prw.rewrite(leftAnd));
-		
+		// assertEquals("((this(Boo) && this(Foo)) || (this(Foo) && this(Goo)))",prw.rewrite(leftAnd).toString());
+		assertEquals("or%anyorder%and%anyorder%this(Boo)%this(Foo)%and%anyorder%this(Foo)%this(Goo)", prw.rewrite(leftAnd));
+
 		Pointcut rightAnd = getPointcut("(this(Goo) || this(Boo)) && this(Foo)");
-//		assertEquals("((this(Boo) && this(Foo)) || (this(Foo) && this(Goo)))",prw.rewrite(rightAnd).toString());
-		assertEquals("or%anyorder%and%anyorder%this(Boo)%this(Foo)%and%anyorder%this(Foo)%this(Goo)",prw.rewrite(rightAnd));
-		
+		// assertEquals("((this(Boo) && this(Foo)) || (this(Foo) && this(Goo)))",prw.rewrite(rightAnd).toString());
+		assertEquals("or%anyorder%and%anyorder%this(Boo)%this(Foo)%and%anyorder%this(Foo)%this(Goo)", prw.rewrite(rightAnd));
+
 		Pointcut nestedOrs = getPointcut("this(Foo) || this(Goo) || this(Boo)");
-//		assertEquals("((this(Boo) || this(Foo)) || this(Goo))",prw.rewrite(nestedOrs).toString());
-		assertEquals("or%anyorder%this(Goo)%or%anyorder%this(Boo)%this(Foo)",prw.rewrite(nestedOrs));
-		
+		// assertEquals("((this(Boo) || this(Foo)) || this(Goo))",prw.rewrite(nestedOrs).toString());
+		assertEquals("or%anyorder%this(Goo)%or%anyorder%this(Boo)%this(Foo)", prw.rewrite(nestedOrs));
+
 		Pointcut nestedAnds = getPointcut("(this(Foo) && (this(Boo) && (this(Goo) || this(Moo))))");
 		// t(F) && (t(B) && (t(G) || t(M)))
 		// ==> t(F) && ((t(B) && t(G)) || (t(B) && t(M)))
 		// ==> (t(F) && (t(B) && t(G))) || (t(F) && (t(B) && t(M)))
-//		assertEquals("(((this(Boo) && this(Foo)) && this(Goo)) || ((this(Boo) && this(Foo)) && this(Moo)))",
-//				prw.rewrite(nestedAnds).toString());
-		assertEquals("or%anyorder%and%anyorder%and%anyorder%this(Boo)%this(Foo)%this(Goo)%and%anyorder%and%anyorder%this(Boo)%this(Foo)%this(Moo)",prw.rewrite(nestedAnds));
+		// assertEquals("(((this(Boo) && this(Foo)) && this(Goo)) || ((this(Boo) && this(Foo)) && this(Moo)))",
+		// prw.rewrite(nestedAnds).toString());
+		assertEquals(
+				"or%anyorder%and%anyorder%and%anyorder%this(Boo)%this(Foo)%this(Goo)%and%anyorder%and%anyorder%this(Boo)%this(Foo)%this(Moo)",
+				prw.rewrite(nestedAnds));
 	}
-		
+
 	/**
-	 * spec is reverse polish notation with operators and, or , not, anyorder,
-	 * delimiter is "%" (not whitespace).
+	 * spec is reverse polish notation with operators and, or , not, anyorder, delimiter is "%" (not whitespace).
+	 * 
 	 * @param spec
 	 * @param pc
 	 */
 	private void assertEquals(String spec, Pointcut pc) {
-	    StringTokenizer strTok = new StringTokenizer(spec,"%");
-	    String[] tokens = new String[strTok.countTokens()];
-	    for (int i = 0; i < tokens.length; i++) {
-            tokens[i] = strTok.nextToken();
-        }
-	    tokenIndex = 0;
-	    assertTrue(spec,equals(pc,tokens));
-	}
-	
+		StringTokenizer strTok = new StringTokenizer(spec, "%");
+		String[] tokens = new String[strTok.countTokens()];
+		for (int i = 0; i < tokens.length; i++) {
+			tokens[i] = strTok.nextToken();
+		}
+		tokenIndex = 0;
+		assertTrue(spec, equals(pc, tokens));
+	}
+
 	private int tokenIndex = 0;
+
 	private boolean equals(Pointcut pc, String[] tokens) {
-	    if (tokens[tokenIndex].equals("and")) {
-	        tokenIndex++;
-	        if (!(pc instanceof AndPointcut)) return false;
-	        AndPointcut apc = (AndPointcut) pc;
-	        Pointcut left = apc.getLeft();
-	        Pointcut right = apc.getRight();
-	        if (tokens[tokenIndex].equals("anyorder")) {
-	            tokenIndex++;
-	            int restorePoint = tokenIndex;
-	            boolean leftMatchFirst = equals(left,tokens) &&
-	                                     equals(right,tokens);
-	            if (leftMatchFirst) return true;
-                tokenIndex = restorePoint;
-	            boolean rightMatchFirst = equals(right,tokens) &&
-	            						 equals(left,tokens);
-	            return rightMatchFirst;
-	        } else {
-	            return equals(left,tokens) &&
-                	   equals(right,tokens);
-	        }
-	    } else if (tokens[tokenIndex].equals("or")) {
-	        tokenIndex++;
-	        if (!(pc instanceof OrPointcut)) return false;
-	        OrPointcut opc = (OrPointcut) pc;
-	        Pointcut left = opc.getLeft();
-	        Pointcut right = opc.getRight();
-	        if (tokens[tokenIndex].equals("anyorder")) {
-	            tokenIndex++;
-	            int restorePoint = tokenIndex;
-	            boolean leftMatchFirst = equals(left,tokens) &&
-	                                     equals(right,tokens);
-	            if (leftMatchFirst) return true;
-	            tokenIndex = restorePoint;
-	            boolean rightMatchFirst = equals(right,tokens) &&
-	            						 equals(left,tokens);
-	            return rightMatchFirst;
-	        } else {
-	            return equals(left,tokens) &&
-                	   equals(right,tokens);
-	        }
-	        
-	    } else if (tokens[tokenIndex].equals("not")) {
-	        if (!(pc instanceof NotPointcut)) return false;
-	        tokenIndex++;
-	        NotPointcut np = (NotPointcut) pc;
-	        return equals(np.getNegatedPointcut(),tokens);
-	    } else {
-	        return tokens[tokenIndex++].equals(pc.toString());
-	    }
-	}
-	
-//	public void testSplitOutWithins() {
-//		Pointcut simpleExecution = getPointcut("execution(* *.*(..))");
-//		assertEquals("Unchanged",simpleExecution,prw.rewrite(simpleExecution));
-//		Pointcut simpleWithinCode = getPointcut("withincode(* *.*(..))");
-//		assertEquals("Unchanged",simpleWithinCode,prw.rewrite(simpleWithinCode));
-//		Pointcut execution = getPointcut("execution(@Foo Foo (@Goo org.xyz..*).m*(Foo,Boo))");
-//		assertEquals("(within((@(Goo) org.xyz..*)) && execution(@(Foo) Foo m*(Foo, Boo)))",
-//				 prw.rewrite(execution).toString());
-//		Pointcut withincode = getPointcut("withincode(@Foo Foo (@Goo org.xyz..*).m*(Foo,Boo))");
-//		assertEquals("(within((@(Goo) org.xyz..*)) && withincode(@(Foo) Foo m*(Foo, Boo)))",
-//				 prw.rewrite(withincode).toString());
-//		Pointcut notExecution = getPointcut("!execution(Foo BankAccount+.*(..))");
-//		assertEquals("(!within(BankAccount+) || !execution(Foo *(..)))",
-//				prw.rewrite(notExecution).toString());
-//		Pointcut andWithincode = getPointcut("withincode(Foo.new(..)) && this(Foo)");
-//		assertEquals("((within(Foo) && withincode(new(..))) && this(Foo))",
-//				prw.rewrite(andWithincode).toString());
-//		Pointcut orExecution = getPointcut("this(Foo) || execution(Goo Foo.moo(Baa))");
-//		assertEquals("((within(Foo) && execution(Goo moo(Baa))) || this(Foo))",
-//				prw.rewrite(orExecution).toString());
-//	}
-	
+		if (tokens[tokenIndex].equals("and")) {
+			tokenIndex++;
+			if (!(pc instanceof AndPointcut)) {
+				return false;
+			}
+			AndPointcut apc = (AndPointcut) pc;
+			Pointcut left = apc.getLeft();
+			Pointcut right = apc.getRight();
+			if (tokens[tokenIndex].equals("anyorder")) {
+				tokenIndex++;
+				int restorePoint = tokenIndex;
+				boolean leftMatchFirst = equals(left, tokens) && equals(right, tokens);
+				if (leftMatchFirst) {
+					return true;
+				}
+				tokenIndex = restorePoint;
+				boolean rightMatchFirst = equals(right, tokens) && equals(left, tokens);
+				return rightMatchFirst;
+			} else {
+				return equals(left, tokens) && equals(right, tokens);
+			}
+		} else if (tokens[tokenIndex].equals("or")) {
+			tokenIndex++;
+			if (!(pc instanceof OrPointcut)) {
+				return false;
+			}
+			OrPointcut opc = (OrPointcut) pc;
+			Pointcut left = opc.getLeft();
+			Pointcut right = opc.getRight();
+			if (tokens[tokenIndex].equals("anyorder")) {
+				tokenIndex++;
+				int restorePoint = tokenIndex;
+				boolean leftMatchFirst = equals(left, tokens) && equals(right, tokens);
+				if (leftMatchFirst) {
+					return true;
+				}
+				tokenIndex = restorePoint;
+				boolean rightMatchFirst = equals(right, tokens) && equals(left, tokens);
+				return rightMatchFirst;
+			} else {
+				return equals(left, tokens) && equals(right, tokens);
+			}
+
+		} else if (tokens[tokenIndex].equals("not")) {
+			if (!(pc instanceof NotPointcut)) {
+				return false;
+			}
+			tokenIndex++;
+			NotPointcut np = (NotPointcut) pc;
+			return equals(np.getNegatedPointcut(), tokens);
+		} else {
+			return tokens[tokenIndex++].equals(pc.toString());
+		}
+	}
+
+	// public void testSplitOutWithins() {
+	// Pointcut simpleExecution = getPointcut("execution(* *.*(..))");
+	// assertEquals("Unchanged",simpleExecution,prw.rewrite(simpleExecution));
+	// Pointcut simpleWithinCode = getPointcut("withincode(* *.*(..))");
+	// assertEquals("Unchanged",simpleWithinCode,prw.rewrite(simpleWithinCode));
+	// Pointcut execution = getPointcut("execution(@Foo Foo (@Goo org.xyz..*).m*(Foo,Boo))");
+	// assertEquals("(within((@(Goo) org.xyz..*)) && execution(@(Foo) Foo m*(Foo, Boo)))",
+	// prw.rewrite(execution).toString());
+	// Pointcut withincode = getPointcut("withincode(@Foo Foo (@Goo org.xyz..*).m*(Foo,Boo))");
+	// assertEquals("(within((@(Goo) org.xyz..*)) && withincode(@(Foo) Foo m*(Foo, Boo)))",
+	// prw.rewrite(withincode).toString());
+	// Pointcut notExecution = getPointcut("!execution(Foo BankAccount+.*(..))");
+	// assertEquals("(!within(BankAccount+) || !execution(Foo *(..)))",
+	// prw.rewrite(notExecution).toString());
+	// Pointcut andWithincode = getPointcut("withincode(Foo.new(..)) && this(Foo)");
+	// assertEquals("((within(Foo) && withincode(new(..))) && this(Foo))",
+	// prw.rewrite(andWithincode).toString());
+	// Pointcut orExecution = getPointcut("this(Foo) || execution(Goo Foo.moo(Baa))");
+	// assertEquals("((within(Foo) && execution(Goo moo(Baa))) || this(Foo))",
+	// prw.rewrite(orExecution).toString());
+	// }
 
 	public void testRemoveDuplicatesInAnd() {
 		Pointcut dupAnd = getPointcut("this(Foo) && this(Foo)");
-		assertEquals("this(Foo)",prw.rewrite(dupAnd).toString());
+		assertEquals("this(Foo)", prw.rewrite(dupAnd).toString());
 		Pointcut splitdupAnd = getPointcut("(this(Foo) && target(Boo)) && this(Foo)");
-		assertEquals("(target(Boo) && this(Foo))",prw.rewrite(splitdupAnd).toString());
+		assertEquals("(target(Boo) && this(Foo))", prw.rewrite(splitdupAnd).toString());
 	}
-	
+
 	public void testNotRemoveNearlyDuplicatesInAnd() {
 		Pointcut toAndto = getPointcut("this(Object+) && this(Object)");
-//		Pointcut rewritten = 
-			prw.rewrite(toAndto);
+		// Pointcut rewritten =
+		prw.rewrite(toAndto);
 	}
-	
+
 	public void testAAndNotAinAnd() {
 		Pointcut aAndNota = getPointcut("this(Foo)&& !this(Foo)");
-		assertEquals("Matches nothing","",prw.rewrite(aAndNota).toString());
+		assertEquals("Matches nothing", "", prw.rewrite(aAndNota).toString());
 		Pointcut aAndBAndNota = getPointcut("this(Foo) && execution(* *.*(..)) && !this(Foo)");
-		assertEquals("Matches nothing","",prw.rewrite(aAndBAndNota).toString());
+		assertEquals("Matches nothing", "", prw.rewrite(aAndBAndNota).toString());
 	}
-	
+
 	public void testIfFalseInAnd() {
 		Pointcut ifFalse = IfPointcut.makeIfFalsePointcut(Pointcut.CONCRETE);
 		Pointcut p = getPointcut("this(A)");
-		assertEquals("Matches nothing","",prw.rewrite(new AndPointcut(ifFalse,p)).toString());
+		assertEquals("Matches nothing", "", prw.rewrite(new AndPointcut(ifFalse, p)).toString());
 	}
 
 	public void testMatchesNothinginAnd() {
 		Pointcut nothing = Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
 		Pointcut p = getPointcut("this(A)");
-		assertEquals("Matches nothing","",prw.rewrite(new AndPointcut(nothing,p)).toString());		
+		assertEquals("Matches nothing", "", prw.rewrite(new AndPointcut(nothing, p)).toString());
 	}
-	
+
 	public void testMixedKindsInAnd() {
 		Pointcut mixedKinds = getPointcut("call(* *(..)) && execution(* *(..))");
-		assertEquals("Matches nothing","",prw.rewrite(mixedKinds).toString());
-		Pointcut ok = getPointcut("call(* *(..)) && this(Foo)");
-		assertEquals(ok,prw.rewrite(ok));
+		assertEquals("Matches nothing", "", prw.rewrite(mixedKinds).toString());
+		Pointcut ok = getPointcut("this(Foo) && call(* *(..))");
+		assertEquals(ok, prw.rewrite(ok));
 	}
-	
+
 	public void testDetermineKindSetOfAnd() {
 		Pointcut oneKind = getPointcut("execution(* foo(..)) && this(Boo)");
 		AndPointcut rewritten = (AndPointcut) prw.rewrite(oneKind);
-		assertEquals("Only one kind",1,Shadow.howMany(rewritten.couldMatchKinds()));
-		assertTrue("It's Shadow.MethodExecution",Shadow.MethodExecution.isSet(rewritten.couldMatchKinds()));
+		assertEquals("Only one kind", 1, Shadow.howMany(rewritten.couldMatchKinds()));
+		assertTrue("It's Shadow.MethodExecution", Shadow.MethodExecution.isSet(rewritten.couldMatchKinds()));
 	}
-	
+
 	public void testKindSetOfExecution() {
 		Pointcut p = getPointcut("execution(* foo(..))");
-		assertEquals("Only one kind",1,Shadow.howMany(p.couldMatchKinds()));
-		assertTrue("It's Shadow.MethodExecution",Shadow.MethodExecution.isSet(p.couldMatchKinds()));
+		assertEquals("Only one kind", 1, Shadow.howMany(p.couldMatchKinds()));
+		assertTrue("It's Shadow.MethodExecution", Shadow.MethodExecution.isSet(p.couldMatchKinds()));
 		p = getPointcut("execution(new(..))");
-		assertEquals("Only one kind",1,Shadow.howMany(p.couldMatchKinds()));
-		assertTrue("It's Shadow.ConstructorExecution",Shadow.ConstructorExecution.isSet(p.couldMatchKinds()));		
+		assertEquals("Only one kind", 1, Shadow.howMany(p.couldMatchKinds()));
+		assertTrue("It's Shadow.ConstructorExecution", Shadow.ConstructorExecution.isSet(p.couldMatchKinds()));
 	}
-	
+
 	public void testKindSetOfCall() {
 		Pointcut p = getPointcut("call(* foo(..))");
-		assertEquals("Only one kind",1,Shadow.howMany(p.couldMatchKinds()));
-		assertTrue("It's Shadow.MethodCall",Shadow.MethodCall.isSet(p.couldMatchKinds()));
+		assertEquals("Only one kind", 1, Shadow.howMany(p.couldMatchKinds()));
+		assertTrue("It's Shadow.MethodCall", Shadow.MethodCall.isSet(p.couldMatchKinds()));
 		p = getPointcut("call(new(..))");
-		assertEquals("Only one kind",1,Shadow.howMany(p.couldMatchKinds()));
-		assertTrue("It's Shadow.ConstructorCall",Shadow.ConstructorCall.isSet(p.couldMatchKinds()));		
+		assertEquals("Only one kind", 1, Shadow.howMany(p.couldMatchKinds()));
+		assertTrue("It's Shadow.ConstructorCall", Shadow.ConstructorCall.isSet(p.couldMatchKinds()));
 	}
-	
+
 	public void testKindSetOfAdviceExecution() {
 		Pointcut p = getPointcut("adviceexecution()");
-		assertEquals("Only one kind",1,Shadow.howMany(p.couldMatchKinds()));
-		assertTrue("It's Shadow.AdviceExecution",Shadow.AdviceExecution.isSet(p.couldMatchKinds()));		
+		assertEquals("Only one kind", 1, Shadow.howMany(p.couldMatchKinds()));
+		assertTrue("It's Shadow.AdviceExecution", Shadow.AdviceExecution.isSet(p.couldMatchKinds()));
 	}
-	
+
 	public void testKindSetOfGet() {
 		Pointcut p = getPointcut("get(* *)");
-		assertEquals("Only one kind",1,Shadow.howMany(p.couldMatchKinds()));
-		assertTrue("It's Shadow.FieldGet",Shadow.FieldGet.isSet(p.couldMatchKinds()));
+		assertEquals("Only one kind", 1, Shadow.howMany(p.couldMatchKinds()));
+		assertTrue("It's Shadow.FieldGet", Shadow.FieldGet.isSet(p.couldMatchKinds()));
 	}
-	
+
 	public void testKindSetOfSet() {
 		Pointcut p = getPointcut("set(* *)");
-		assertEquals("Only one kind",1,Shadow.howMany(p.couldMatchKinds()));
-		assertTrue("It's Shadow.FieldSet",Shadow.FieldSet.isSet(p.couldMatchKinds()));						
+		assertEquals("Only one kind", 1, Shadow.howMany(p.couldMatchKinds()));
+		assertTrue("It's Shadow.FieldSet", Shadow.FieldSet.isSet(p.couldMatchKinds()));
 	}
-	
+
 	public void testKindSetOfHandler() {
 		Pointcut p = getPointcut("handler(*)");
-		assertEquals("Only one kind",1,Shadow.howMany(p.couldMatchKinds()));
-		assertTrue("It's Shadow.ExceptionHandler",Shadow.ExceptionHandler.isSet(p.couldMatchKinds()));								
+		assertEquals("Only one kind", 1, Shadow.howMany(p.couldMatchKinds()));
+		assertTrue("It's Shadow.ExceptionHandler", Shadow.ExceptionHandler.isSet(p.couldMatchKinds()));
 	}
-	
+
 	public void testKindSetOfInitialization() {
 		Pointcut p = getPointcut("initialization(new (..))");
-		assertEquals("Only one kind",1,Shadow.howMany(p.couldMatchKinds()));
-		assertTrue("It's Shadow.Initialization",Shadow.Initialization.isSet(p.couldMatchKinds()));							
+		assertEquals("Only one kind", 1, Shadow.howMany(p.couldMatchKinds()));
+		assertTrue("It's Shadow.Initialization", Shadow.Initialization.isSet(p.couldMatchKinds()));
 	}
-	
+
 	public void testKindSetOfPreInitialization() {
 		Pointcut p = getPointcut("preinitialization(new (..))");
-		assertEquals("Only one kind",1,Shadow.howMany(p.couldMatchKinds()));
-		assertTrue("It's Shadow.PreInitialization",Shadow.PreInitialization.isSet(p.couldMatchKinds()));									
+		assertEquals("Only one kind", 1, Shadow.howMany(p.couldMatchKinds()));
+		assertTrue("It's Shadow.PreInitialization", Shadow.PreInitialization.isSet(p.couldMatchKinds()));
 	}
-	
+
 	public void testKindSetOfStaticInitialization() {
 		Pointcut p = getPointcut("staticinitialization(*)");
-		assertEquals("Only one kind",1,Shadow.howMany(p.couldMatchKinds()));
-		assertTrue("It's Shadow.StaticInitialization",Shadow.StaticInitialization.isSet(p.couldMatchKinds()));							
+		assertEquals("Only one kind", 1, Shadow.howMany(p.couldMatchKinds()));
+		assertTrue("It's Shadow.StaticInitialization", Shadow.StaticInitialization.isSet(p.couldMatchKinds()));
 	}
-	
+
 	public void testKindSetOfThis() {
 		Pointcut p = getPointcut("this(Foo)");
 		Set matches = Shadow.toSet(p.couldMatchKinds());
 		for (Iterator iter = matches.iterator(); iter.hasNext();) {
 			Shadow.Kind kind = (Shadow.Kind) iter.next();
-			assertFalse("No kinds that don't have a this",kind.neverHasThis());
+			assertFalse("No kinds that don't have a this", kind.neverHasThis());
 		}
 		for (int i = 0; i < Shadow.SHADOW_KINDS.length; i++) {
 			if (!Shadow.SHADOW_KINDS[i].neverHasThis()) {
-				assertTrue("All kinds that do have this",matches.contains(Shadow.SHADOW_KINDS[i]));
+				assertTrue("All kinds that do have this", matches.contains(Shadow.SHADOW_KINDS[i]));
 			}
 		}
 		// + @
@@ -301,25 +300,25 @@ public class PointcutRewriterTest extends TestCase {
 		matches = Shadow.toSet(p.couldMatchKinds());
 		for (Iterator iter = matches.iterator(); iter.hasNext();) {
 			Shadow.Kind kind = (Shadow.Kind) iter.next();
-			assertFalse("No kinds that don't have a this",kind.neverHasThis());
+			assertFalse("No kinds that don't have a this", kind.neverHasThis());
 		}
 		for (int i = 0; i < Shadow.SHADOW_KINDS.length; i++) {
 			if (!Shadow.SHADOW_KINDS[i].neverHasThis()) {
-				assertTrue("All kinds that do have this",matches.contains(Shadow.SHADOW_KINDS[i]));
+				assertTrue("All kinds that do have this", matches.contains(Shadow.SHADOW_KINDS[i]));
 			}
 		}
 	}
-	
+
 	public void testKindSetOfTarget() {
 		Pointcut p = getPointcut("target(Foo)");
 		Set matches = Shadow.toSet(p.couldMatchKinds());
 		for (Iterator iter = matches.iterator(); iter.hasNext();) {
 			Shadow.Kind kind = (Shadow.Kind) iter.next();
-			assertFalse("No kinds that don't have a target",kind.neverHasTarget());
+			assertFalse("No kinds that don't have a target", kind.neverHasTarget());
 		}
 		for (int i = 0; i < Shadow.SHADOW_KINDS.length; i++) {
 			if (!Shadow.SHADOW_KINDS[i].neverHasTarget()) {
-				assertTrue("All kinds that do have target",matches.contains(Shadow.SHADOW_KINDS[i]));
+				assertTrue("All kinds that do have target", matches.contains(Shadow.SHADOW_KINDS[i]));
 			}
 		}
 		// + @
@@ -327,36 +326,36 @@ public class PointcutRewriterTest extends TestCase {
 		matches = Shadow.toSet(p.couldMatchKinds());
 		for (Iterator iter = matches.iterator(); iter.hasNext();) {
 			Shadow.Kind kind = (Shadow.Kind) iter.next();
-			assertFalse("No kinds that don't have a target",kind.neverHasTarget());
+			assertFalse("No kinds that don't have a target", kind.neverHasTarget());
 		}
 		for (int i = 0; i < Shadow.SHADOW_KINDS.length; i++) {
 			if (!Shadow.SHADOW_KINDS[i].neverHasTarget()) {
-				assertTrue("All kinds that do have target",matches.contains(Shadow.SHADOW_KINDS[i]));
+				assertTrue("All kinds that do have target", matches.contains(Shadow.SHADOW_KINDS[i]));
 			}
 		}
 	}
-	
+
 	public void testKindSetOfArgs() {
 		Pointcut p = getPointcut("args(..)");
-		assertTrue("All kinds",p.couldMatchKinds()==Shadow.ALL_SHADOW_KINDS_BITS);
+		assertTrue("All kinds", p.couldMatchKinds() == Shadow.ALL_SHADOW_KINDS_BITS);
 		// + @
 		p = getPointcut("@args(..)");
-		assertTrue("All kinds",p.couldMatchKinds()==Shadow.ALL_SHADOW_KINDS_BITS);
+		assertTrue("All kinds", p.couldMatchKinds() == Shadow.ALL_SHADOW_KINDS_BITS);
 	}
-	
+
 	public void testKindSetOfAnnotation() {
 		Pointcut p = getPointcut("@annotation(Foo)");
-		assertTrue("All kinds",p.couldMatchKinds()==Shadow.ALL_SHADOW_KINDS_BITS);		
+		assertTrue("All kinds", p.couldMatchKinds() == Shadow.ALL_SHADOW_KINDS_BITS);
 	}
-	
+
 	public void testKindSetOfWithin() {
 		Pointcut p = getPointcut("within(*)");
-		assertTrue("All kinds",p.couldMatchKinds()==Shadow.ALL_SHADOW_KINDS_BITS);
+		assertTrue("All kinds", p.couldMatchKinds() == Shadow.ALL_SHADOW_KINDS_BITS);
 		// + @
 		p = getPointcut("@within(Foo)");
-		assertTrue("All kinds",p.couldMatchKinds()==Shadow.ALL_SHADOW_KINDS_BITS);
+		assertTrue("All kinds", p.couldMatchKinds() == Shadow.ALL_SHADOW_KINDS_BITS);
 	}
-	
+
 	public void testKindSetOfWithinCode() {
 		Pointcut p = getPointcut("withincode(* foo(..))");
 		Set matches = Shadow.toSet(p.couldMatchKinds());
@@ -367,82 +366,82 @@ public class PointcutRewriterTest extends TestCase {
 		}
 		for (int i = 0; i < Shadow.SHADOW_KINDS.length; i++) {
 			if (!Shadow.SHADOW_KINDS[i].isEnclosingKind()) {
-				assertTrue("All kinds that are not enclosing",matches.contains(Shadow.SHADOW_KINDS[i]));
+				assertTrue("All kinds that are not enclosing", matches.contains(Shadow.SHADOW_KINDS[i]));
 			}
-		}	
-		assertTrue("Need cons-exe for inlined field inits",matches.contains(Shadow.ConstructorExecution));
-		assertTrue("Need init for inlined field inits",matches.contains(Shadow.Initialization));
+		}
+		assertTrue("Need cons-exe for inlined field inits", matches.contains(Shadow.ConstructorExecution));
+		assertTrue("Need init for inlined field inits", matches.contains(Shadow.Initialization));
 		// + @
 		p = getPointcut("@withincode(Foo)");
 		matches = Shadow.toSet(p.couldMatchKinds());
 		for (Iterator iter = matches.iterator(); iter.hasNext();) {
 			Shadow.Kind kind = (Shadow.Kind) iter.next();
-			assertFalse("No kinds that are themselves enclosing",kind.isEnclosingKind());
+			assertFalse("No kinds that are themselves enclosing", kind.isEnclosingKind());
 		}
 		for (int i = 0; i < Shadow.SHADOW_KINDS.length; i++) {
 			if (!Shadow.SHADOW_KINDS[i].isEnclosingKind()) {
-				assertTrue("All kinds that are not enclosing",matches.contains(Shadow.SHADOW_KINDS[i]));
+				assertTrue("All kinds that are not enclosing", matches.contains(Shadow.SHADOW_KINDS[i]));
 			}
-		}		
+		}
 	}
-	
+
 	public void testKindSetOfIf() {
-		Pointcut p = new IfPointcut(null,0);
-		assertTrue("All kinds",p.couldMatchKinds()==Shadow.ALL_SHADOW_KINDS_BITS);
+		Pointcut p = new IfPointcut(null, 0);
+		assertTrue("All kinds", p.couldMatchKinds() == Shadow.ALL_SHADOW_KINDS_BITS);
 		p = IfPointcut.makeIfTruePointcut(Pointcut.CONCRETE);
-		assertTrue("All kinds",p.couldMatchKinds()==Shadow.ALL_SHADOW_KINDS_BITS);
+		assertTrue("All kinds", p.couldMatchKinds() == Shadow.ALL_SHADOW_KINDS_BITS);
 		p = IfPointcut.makeIfFalsePointcut(Pointcut.CONCRETE);
-		assertTrue("Nothing",p.couldMatchKinds()==Shadow.NO_SHADOW_KINDS_BITS);
+		assertTrue("Nothing", p.couldMatchKinds() == Shadow.NO_SHADOW_KINDS_BITS);
 	}
-	
+
 	public void testKindSetOfCflow() {
 		Pointcut p = getPointcut("cflow(this(Foo))");
-		assertTrue("All kinds",p.couldMatchKinds()==Shadow.ALL_SHADOW_KINDS_BITS);
+		assertTrue("All kinds", p.couldMatchKinds() == Shadow.ALL_SHADOW_KINDS_BITS);
 		// [below]
 		p = getPointcut("cflowbelow(this(Foo))");
-		assertTrue("All kinds",p.couldMatchKinds()==Shadow.ALL_SHADOW_KINDS_BITS);
+		assertTrue("All kinds", p.couldMatchKinds() == Shadow.ALL_SHADOW_KINDS_BITS);
 	}
-	
+
 	public void testKindSetInNegation() {
 		Pointcut p = getPointcut("!execution(new(..))");
-		assertTrue("All kinds",p.couldMatchKinds()==Shadow.ALL_SHADOW_KINDS_BITS);		
+		assertTrue("All kinds", p.couldMatchKinds() == Shadow.ALL_SHADOW_KINDS_BITS);
 	}
-	
+
 	public void testKindSetOfOr() {
 		Pointcut p = getPointcut("execution(new(..)) || get(* *)");
 		Set matches = Shadow.toSet(p.couldMatchKinds());
-		assertEquals("2 kinds",2,matches.size());
-		assertTrue("ConstructorExecution",matches.contains(Shadow.ConstructorExecution));
-		assertTrue("FieldGet",matches.contains(Shadow.FieldGet));
+		assertEquals("2 kinds", 2, matches.size());
+		assertTrue("ConstructorExecution", matches.contains(Shadow.ConstructorExecution));
+		assertTrue("FieldGet", matches.contains(Shadow.FieldGet));
 	}
-	
+
 	public void testOrderingInAnd() {
 		Pointcut bigLongPC = getPointcut("cflow(this(Foo)) && @args(X) && args(X) && @this(Foo) && @target(Boo) && this(Moo) && target(Boo) && @annotation(Moo) && @withincode(Boo) && withincode(new(..)) && set(* *)&& @within(Foo) && within(Foo)");
 		Pointcut rewritten = prw.rewrite(bigLongPC);
-		assertEquals("((((((((((((within(Foo) && @within(Foo)) && set(* *)) && withincode(new(..))) && @withincode(Boo)) && @annotation(Moo)) && target(Boo)) && this(Moo)) && @target(Boo)) && @this(Foo)) && args(X)) && @args(X)) && cflow(this(Foo)))",rewritten.toString());
+		assertEquals(
+				"((((((((((((within(Foo) && @within(Foo)) && set(* *)) && withincode(new(..))) && @withincode(Boo)) && target(Boo)) && this(Moo)) && @annotation(Moo)) && @target(Boo)) && @this(Foo)) && args(X)) && @args(X)) && cflow(this(Foo)))",
+				rewritten.toString());
 	}
-	
+
 	public void testOrderingInSimpleOr() {
 		OrPointcut opc = (OrPointcut) getPointcut("execution(new(..)) || get(* *)");
-		assertEquals("reordered","(get(* *) || execution(new(..)))",prw.rewrite(opc).toString());
+		assertEquals("reordered", "(get(* *) || execution(new(..)))", prw.rewrite(opc).toString());
 	}
-	
+
 	public void testOrderingInNestedOrs() {
 		OrPointcut opc = (OrPointcut) getPointcut("(execution(new(..)) || get(* *)) || within(abc)");
-		assertEquals("reordered","((within(abc) || get(* *)) || execution(new(..)))",
-				prw.rewrite(opc).toString());
+		assertEquals("reordered", "((within(abc) || get(* *)) || execution(new(..)))", prw.rewrite(opc).toString());
 	}
-	
+
 	public void testOrderingInOrsWithNestedAnds() {
 		OrPointcut opc = (OrPointcut) getPointcut("get(* *) || (execution(new(..)) && within(abc))");
-		assertEquals("reordered","((within(abc) && execution(new(..))) || get(* *))",
-				prw.rewrite(opc).toString());
+		assertEquals("reordered", "((within(abc) && execution(new(..))) || get(* *))", prw.rewrite(opc).toString());
 	}
-		
+
 	private Pointcut getPointcut(String s) {
 		return new PatternParser(s).parsePointcut();
 	}
-	
+
 	/*
 	 * @see TestCase#setUp()
 	 */
@@ -25,59 +25,58 @@ public class PointcutEvaluationExpenseComparator implements Comparator {
 	private static final int WITHINCODE = 7;
 	private static final int ATWITHINCODE = 8;
 	private static final int EXE_INIT_PREINIT = 9;
-	private static final int CALL = 10;
-	private static final int ANNOTATION = 11;
-	private static final int THIS_OR_TARGET = 12;
+	private static final int THIS_OR_TARGET = 10;
+	private static final int CALL = 11;
+	private static final int ANNOTATION = 12;
 	private static final int AT_THIS_OR_TARGET = 13;
 	private static final int ARGS = 14;
 	private static final int AT_ARGS = 15;
 	private static final int CFLOW = 16;
 	private static final int IF = 17;
 	private static final int OTHER = 20;
-	
+
 	/**
-	 * Compare 2 pointcuts based on an estimate of how expensive they may be
-	 * to evaluate.
+	 * Compare 2 pointcuts based on an estimate of how expensive they may be to evaluate.
 	 * 
 	 * within
-	 * @within
-	 * staticinitialization  [make sure this has a fast match method]
-	 * adviceexecution
-	 * handler
-	 * get, set
-	 * withincode
-	 * @withincode
-	 * execution, initialization, preinitialization
-	 * call
-	 * @annotation
-	 * this, target
-	 * @this, @target
-	 * args
-	 * @args
-	 * cflow, cflowbelow
-	 * if
+	 * 
+	 * @within staticinitialization [make sure this has a fast match method] adviceexecution handler get, set withincode
+	 * @withincode execution, initialization, preinitialization call
+	 * @annotation this, target
+	 * @this, @target args
+	 * @args cflow, cflowbelow if
 	 */
 	public int compare(Object o1, Object o2) {
 		Pointcut p1 = (Pointcut) o1;
 		Pointcut p2 = (Pointcut) o2;
-		
+
 		// important property for a well-defined comparator
-		if (p1.equals(p2)) return 0;		
+		if (p1.equals(p2)) {
+			return 0;
+		}
 		int result = getScore(p1) - getScore(p2);
 		if (result == 0) {
 			// they have the same evaluation expense, but are not 'equal'
 			// sort by hashCode
 			result = p1.hashCode() - p2.hashCode();
-			if (result == 0) /*not allowed if ne*/ return -1;
+			if (result == 0) {
+				/* not allowed if ne */return -1;
+			}
 		}
 		return result;
 	}
 
 	// a higher score means a more expensive evaluation
 	private int getScore(Pointcut p) {
-		if (p.couldMatchKinds()==Shadow.NO_SHADOW_KINDS_BITS) return MATCHES_NOTHING;
-		if (p instanceof WithinPointcut) return WITHIN;
-		if (p instanceof WithinAnnotationPointcut) return ATWITHIN;
+		if (p.couldMatchKinds() == Shadow.NO_SHADOW_KINDS_BITS) {
+			return MATCHES_NOTHING;
+		}
+		if (p instanceof WithinPointcut) {
+			return WITHIN;
+		}
+		if (p instanceof WithinAnnotationPointcut) {
+			return ATWITHIN;
+		}
 		if (p instanceof KindedPointcut) {
 			KindedPointcut kp = (KindedPointcut) p;
 			Shadow.Kind kind = kp.getKind();
@@ -85,8 +84,8 @@ public class PointcutEvaluationExpenseComparator implements Comparator {
 				return ADVICEEXECUTION;
 			} else if ((kind == Shadow.ConstructorCall) || (kind == Shadow.MethodCall)) {
 				return CALL;
-			} else if ((kind == Shadow.ConstructorExecution) || (kind == Shadow.MethodExecution) ||
-					   (kind == Shadow.Initialization) || (kind == Shadow.PreInitialization)) {
+			} else if ((kind == Shadow.ConstructorExecution) || (kind == Shadow.MethodExecution) || (kind == Shadow.Initialization)
+					|| (kind == Shadow.PreInitialization)) {
 				return EXE_INIT_PREINIT;
 			} else if (kind == Shadow.ExceptionHandler) {
 				return HANDLER;
@@ -94,21 +93,49 @@ public class PointcutEvaluationExpenseComparator implements Comparator {
 				return GET_OR_SET;
 			} else if (kind == Shadow.StaticInitialization) {
 				return STATICINIT;
-			} else return OTHER;
- 		}
-		if (p instanceof AnnotationPointcut) return ANNOTATION;
-		if (p instanceof ArgsPointcut) return ARGS;
-		if (p instanceof ArgsAnnotationPointcut) return AT_ARGS;
-		if (p instanceof CflowPointcut) return CFLOW;
-		if (p instanceof HandlerPointcut) return HANDLER;
-		if (p instanceof IfPointcut) return IF;
-		if (p instanceof ThisOrTargetPointcut) return THIS_OR_TARGET;
-		if (p instanceof ThisOrTargetAnnotationPointcut) return AT_THIS_OR_TARGET;
-		if (p instanceof WithincodePointcut) return WITHINCODE;
-		if (p instanceof WithinCodeAnnotationPointcut) return ATWITHINCODE;
-		if (p instanceof NotPointcut) return getScore(((NotPointcut)p).getNegatedPointcut());
-		if (p instanceof AndPointcut) return getScore(((AndPointcut)p).getLeft());
-		if (p instanceof OrPointcut) return getScore(((OrPointcut)p).getLeft());
-		return OTHER;		
+			} else {
+				return OTHER;
+			}
+		}
+		if (p instanceof AnnotationPointcut) {
+			return ANNOTATION;
+		}
+		if (p instanceof ArgsPointcut) {
+			return ARGS;
+		}
+		if (p instanceof ArgsAnnotationPointcut) {
+			return AT_ARGS;
+		}
+		if (p instanceof CflowPointcut) {
+			return CFLOW;
+		}
+		if (p instanceof HandlerPointcut) {
+			return HANDLER;
+		}
+		if (p instanceof IfPointcut) {
+			return IF;
+		}
+		if (p instanceof ThisOrTargetPointcut) {
+			return THIS_OR_TARGET;
+		}
+		if (p instanceof ThisOrTargetAnnotationPointcut) {
+			return AT_THIS_OR_TARGET;
+		}
+		if (p instanceof WithincodePointcut) {
+			return WITHINCODE;
+		}
+		if (p instanceof WithinCodeAnnotationPointcut) {
+			return ATWITHINCODE;
+		}
+		if (p instanceof NotPointcut) {
+			return getScore(((NotPointcut) p).getNegatedPointcut());
+		}
+		if (p instanceof AndPointcut) {
+			return getScore(((AndPointcut) p).getLeft());
+		}
+		if (p instanceof OrPointcut) {
+			return getScore(((OrPointcut) p).getLeft());
+		}
+		return OTHER;
 	}
 }
