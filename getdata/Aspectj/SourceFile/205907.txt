@@ -11,13 +11,13 @@
  * ******************************************************************/
 package org.aspectj.weaver.tools;
 
-import org.aspectj.util.LangUtil;
-
 import junit.framework.TestCase;
 
+import org.aspectj.util.LangUtil;
+
 /**
- * @author Adrian
- *
+ * @author Adrian Colyer
+ * 
  */
 public class PointcutDesignatorHandlerTests extends TestCase {
 
@@ -60,9 +60,64 @@ public class PointcutDesignatorHandlerTests extends TestCase {
 		assertEquals("service.*",beanHandler.getExpressionLastAskedToParse());
 	}
 
-	public void testParseWithHandlerAndMultipleSegments() { 
-		if (needToSkip) return;
-		PointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();
+    
+	/*
+     * Bug 205907 - the registered pointcut designator does not also get registered with the
+     * InternalUseOnlyPointcutParser inside the Java15ReflectionBasedReferenceTypeDelegate code. First test checks
+     * parsing is OK
+     */
+    public void testParsingBeanInReferencePointcut01() throws Exception {
+        if (needToSkip) return;
+        PointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();
+        BeanDesignatorHandler beanHandler = new BeanDesignatorHandler();
+        parser.registerPointcutDesignatorHandler(beanHandler);
+        // The pointcut in CounterAspect look as follows:
+        //
+        // @Pointcut("execution(* setAge(..)) && bean(testBean1)")
+        // public void testBean1SetAge() { }
+
+        // This should be found and resolved
+        PointcutExpression pc = parser.parsePointcutExpression("CounterAspect.testBean1SetAge()");
+
+    }
+
+    /*
+     * Bug 205907 - the registered pointcut designator does not also get registered with the
+     * InternalUseOnlyPointcutParser inside the Java15ReflectionBasedReferenceTypeDelegate code. This test checks the
+     * actual matching.
+     */
+    public void testParsingBeanInReferencePointcut02() throws Exception {
+        if (needToSkip) return;
+        PointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();
+        BeanDesignatorHandler beanHandler = new BeanDesignatorHandler();
+        parser.registerPointcutDesignatorHandler(beanHandler);
+        // The pointcut in CounterAspect look as follows:
+        //
+        // @Pointcut("execution(* toString(..)) && bean(testBean1)")
+        // public void testBean1toString() { }
+        
+        // This should be found and resolved
+        PointcutExpression pc = parser.parsePointcutExpression("CounterAspect.testBean1toString()");
+
+        DefaultMatchingContext context = new DefaultMatchingContext();
+        context.addContextBinding("beanName", "testBean1");
+        pc.setMatchingContext(context);
+        ShadowMatch sm = pc.matchesMethodExecution(Object.class.getMethod("toString", new Class[0]));
+        assertTrue(sm.alwaysMatches());
+        
+        sm = pc.matchesMethodExecution(Object.class.getMethod("hashCode", new Class[0]));
+        assertTrue(sm.neverMatches());
+        
+        context = new DefaultMatchingContext();
+        context.addContextBinding("beanName", "testBean2");
+        pc.setMatchingContext(context);
+        sm = pc.matchesMethodExecution(Object.class.getMethod("toString", new Class[0]));
+        assertTrue(sm.neverMatches());
+    }
+
+    public void testParseWithHandlerAndMultipleSegments() {
+        if (needToSkip) return;
+        PointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();
 		BeanDesignatorHandler beanHandler = new BeanDesignatorHandler();
 		parser.registerPointcutDesignatorHandler(beanHandler);
 		parser.parsePointcutExpression("bean(org.xyz.someapp..*)");
@@ -192,4 +247,4 @@ public class PointcutDesignatorHandlerTests extends TestCase {
 			return this.beanNamePattern.equals(matchContext.getBinding("beanName"));
 		}
 	}		
-}
\ No newline at end of file
+}
@@ -0,0 +1,52 @@
+/* *******************************************************************
+ * Copyright (c) 2008 Contributors.
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *   Andy Clement         initial implementation
+ * ******************************************************************/
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.annotation.Before;
+import org.aspectj.lang.annotation.Pointcut;
+
+/**
+ * Created to enable PointcutDesignatorHandlerTests.testParsingBeanInReferencePointcut01 and 02 to run
+ * 
+ * @author Andy Clement
+ */
+@Aspect
+public class CounterAspect {
+
+    int count;
+
+    @Before("execution(* set*(..)) && bean(testBean1)")
+    public void increment1ForAnonymousPointcut() {
+        count++;
+    }
+
+    @Pointcut("execution(* toString(..)) && bean(testBean1)")
+    public void testBean1toString() {
+    }
+    
+    @Pointcut("execution(* setAge(..)) && bean(testBean1)")
+    public void testBean1SetAge() {
+    }
+
+    @Pointcut("execution(* setAge(..)) && bean(testBean2)")
+    public void testBean2SetAge() {
+    }
+
+    @Before("testBean1SetAge()")
+    public void increment1() {
+        count++;
+    }
+
+    @Before("testBean2SetAge()")
+    public void increment2() {
+        count++;
+    }
+}
\ No newline at end of file
@@ -17,6 +17,8 @@ import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
+import java.util.Iterator;
+import java.util.Set;
 
 import org.aspectj.lang.annotation.Aspect;
 import org.aspectj.lang.reflect.AjType;
@@ -31,6 +33,7 @@ import org.aspectj.weaver.TypeVariable;
 import org.aspectj.weaver.TypeVariableReferenceType;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.World;
+import org.aspectj.weaver.tools.PointcutDesignatorHandler;
 import org.aspectj.weaver.tools.PointcutParameter;
 
 /**
@@ -251,6 +254,11 @@ public class Java15ReflectionBasedReferenceTypeDelegate extends
 			} else {
 				parser = new InternalUseOnlyPointcutParser(classLoader);
 			}
+			Set additionalPointcutHandlers = world.getRegisteredPointcutHandlers();
+            for (Iterator handlerIterator = additionalPointcutHandlers.iterator(); handlerIterator.hasNext();) {
+                PointcutDesignatorHandler handler = (PointcutDesignatorHandler) handlerIterator.next();
+                parser.registerPointcutDesignatorHandler(handler);
+            }
 
 			// phase 1, create legitimate entries in pointcuts[] before we attempt to resolve *any* of the pointcuts
 			// resolution can sometimes cause us to recurse, and this two stage process allows us to cope with that
@@ -260,6 +260,7 @@ public class PointcutParser {
      */
     public void registerPointcutDesignatorHandler(PointcutDesignatorHandler designatorHandler) {
     	this.pointcutDesignators.add(designatorHandler);
+    	if (world != null) world.registerPointcutHandler(designatorHandler);
     }
 
     /**
@@ -20,10 +20,12 @@ import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
+import java.util.Set;
 import java.util.WeakHashMap;
 
 import org.aspectj.asm.IHierarchy;
@@ -39,6 +41,7 @@ import org.aspectj.weaver.patterns.DeclarePrecedence;
 import org.aspectj.weaver.patterns.PerClause;
 import org.aspectj.weaver.patterns.Pointcut;
 import org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegate;
+import org.aspectj.weaver.tools.PointcutDesignatorHandler;
 import org.aspectj.weaver.tools.Trace;
 import org.aspectj.weaver.tools.TraceFactory;
 
@@ -58,6 +61,9 @@ public abstract class World implements Dump.INode {
 	/** The heart of the world, a map from type signatures to resolved types */
     protected TypeMap typeMap = new TypeMap(this); // Signature to ResolvedType
 
+    /** New pointcut designators this world supports */
+    private Set pointcutDesignators;
+
     // see pr145963
     /** Should we create the hierarchy for binary classes and aspects*/
     public static boolean createInjarHierarchy = true;
@@ -1277,4 +1283,20 @@ public abstract class World implements Dump.INode {
 			return typeMap.getAllTypes();
 		}
 
+        /**
+         * Register a new pointcut designator handler with the world - this can be used by any pointcut parsers attached
+         * to the world.
+         * 
+         * @param designatorHandler handler for the new pointcut
+         */
+        public void registerPointcutHandler(PointcutDesignatorHandler designatorHandler) {
+            if (pointcutDesignators == null) pointcutDesignators = new HashSet();
+            pointcutDesignators.add(designatorHandler);
+        }
+        
+        public Set getRegisteredPointcutHandlers() {
+            if (pointcutDesignators == null) return Collections.EMPTY_SET;
+            return pointcutDesignators;
+        }
+        
 }
\ No newline at end of file
