Binary files differ
Binary files differ
@@ -156,6 +156,11 @@ public class JDTLikeHandleProvider implements IElementHandleProvider {
 			int count = 1;
 			List kids = ipe.getParent().getChildren();
 			String ipeSig = ipe.getBytecodeSignature();
+			// remove return type from the signature - it should not be included in the comparison
+			int idx = 0;
+			if (ipeSig != null && ((idx = ipeSig.indexOf(")")) != -1)) {
+				ipeSig = ipeSig.substring(0, idx);
+			}
 			for (Iterator iterator = kids.iterator(); iterator.hasNext();) {
 				IProgramElement object = (IProgramElement) iterator.next();
 				if (object.equals(ipe)) {
@@ -164,6 +169,9 @@ public class JDTLikeHandleProvider implements IElementHandleProvider {
 				if (object.getKind() == ipe.getKind()) {
 					if (object.getName().equals(ipe.getName())) {
 						String sig1 = object.getBytecodeSignature();
+						if (sig1 != null && (idx = sig1.indexOf(")")) != -1) {
+							sig1 = sig1.substring(0, idx);
+						}
 						if (sig1 == null && ipeSig == null || (sig1 != null && sig1.equals(ipeSig))) {
 							String existingHandle = object.getHandleIdentifier();
 							int suffixPosition = existingHandle.indexOf('!');
@@ -204,7 +212,7 @@ public class JDTLikeHandleProvider implements IElementHandleProvider {
 							String existingHandle = object.getHandleIdentifier();
 							int suffixPosition = existingHandle.lastIndexOf('!');
 							int lastSquareBracket = existingHandle.lastIndexOf('['); // type delimiter
-							if (suffixPosition != -1 && lastSquareBracket<suffixPosition) { // pr260384
+							if (suffixPosition != -1 && lastSquareBracket < suffixPosition) { // pr260384
 								count = new Integer(existingHandle.substring(suffixPosition + 1)).intValue() + 1;
 							} else {
 								if (count == 1) {
@@ -225,7 +233,7 @@ public class JDTLikeHandleProvider implements IElementHandleProvider {
 							String existingHandle = object.getHandleIdentifier();
 							int suffixPosition = existingHandle.lastIndexOf('!');
 							int lastSquareBracket = existingHandle.lastIndexOf('['); // type delimiter
-							if (suffixPosition != -1 && lastSquareBracket<suffixPosition) { // pr260384
+							if (suffixPosition != -1 && lastSquareBracket < suffixPosition) { // pr260384
 								count = new Integer(existingHandle.substring(suffixPosition + 1)).intValue() + 1;
 							} else {
 								if (count == 1) {
@@ -0,0 +1,7 @@
+package x;
+
+public class A {
+	public boolean a() {
+		return false;
+	}
+}
@@ -0,0 +1,13 @@
+package x;
+
+public class B {
+	private int b() {
+		return b();
+	}
+
+	@Override
+	protected Object clone() throws CloneNotSupportedException {
+		b();
+		return super.clone();
+	}
+}
@@ -0,0 +1,32 @@
+package x;
+public aspect OverrideOptions
+{
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+   /**
+    * Comment A
+    */
+   boolean around() : execution( public boolean A.a() ) && this( A )
+   {
+       return false;
+   }
+   /**
+    * Comment B
+    */
+   int around() : execution(private int B.b(..)) && this(B){
+       return 0;
+   }
+}  
\ No newline at end of file
@@ -11,6 +11,8 @@
 package org.aspectj.systemtest.ajc164;
 
 import java.io.File;
+import java.util.Iterator;
+import java.util.List;
 
 import junit.framework.Test;
 
@@ -20,10 +22,33 @@ import org.aspectj.apache.bcel.classfile.LocalVariableTable;
 import org.aspectj.apache.bcel.classfile.Method;
 import org.aspectj.apache.bcel.util.ClassPath;
 import org.aspectj.apache.bcel.util.SyntheticRepository;
+import org.aspectj.asm.AsmManager;
+import org.aspectj.asm.IHierarchy;
+import org.aspectj.asm.IProgramElement;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testHandles_pr263666() {
+		runTest("around advice handles");
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
+		IProgramElement ipe = null;
+		ipe = findElementAtLine(top.getRoot(), 22);// public java.util.List<String> Ship.i(List<String>[][] u)
+		assertEquals("<x*OverrideOptions.aj}OverrideOptions&around", ipe.getHandleIdentifier());
+		ipe = findElementAtLine(top.getRoot(), 29);// public java.util.List<String> Ship.i(List<String>[][] u)
+		assertEquals("<x*OverrideOptions.aj}OverrideOptions&around!2", ipe.getHandleIdentifier());
+	}
+/*
+	// Only one of two aspects named
+	public void testAopConfig1() {
+		runTest("aop config - 1");
+	}
+
+	// Only one of two aspects named - and named one is scoped to only affect one type
+	public void testAopConfig2() {
+		runTest("aop config - 2");
+	}
+*/
 	public void testAjcThisNotRead() {
 		runTest("ajcthis not read");
 	}
@@ -32,10 +57,6 @@ public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		runTest("recursive cflow");
 	}
 
-	// public void testAopConfig1() {
-	// runTest("aop config - 1");
-	// }
-
 	public void testAnnoDecprecedence_pr256779() {
 		runTest("anno decprecedence");
 	}
@@ -261,4 +282,25 @@ public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
 		return sb.toString();
 	}
+
+	private IProgramElement findElementAtLine(IProgramElement whereToLook, int line) {
+		if (whereToLook == null) {
+			return null;
+		}
+		if (whereToLook.getSourceLocation() != null && whereToLook.getSourceLocation().getLine() == line) {
+			return whereToLook;
+		}
+		List kids = whereToLook.getChildren();
+		for (Iterator iterator = kids.iterator(); iterator.hasNext();) {
+			IProgramElement object = (IProgramElement) iterator.next();
+			if (object.getSourceLocation() != null && object.getSourceLocation().getLine() == line) {
+				return object;
+			}
+			IProgramElement gotSomething = findElementAtLine(object, line);
+			if (gotSomething != null) {
+				return gotSomething;
+			}
+		}
+		return null;
+	}
 }
\ No newline at end of file
@@ -2,9 +2,22 @@
 
 <suite>
 
+    <ajc-test dir="bugs164/pr263666" title="around advice handles">
+      <compile files="x/A.java x/B.java x/OverrideOptions.aj" options="-1.5 -emacssym"/>
+    </ajc-test>
+    
+    
     <ajc-test dir="features164/aopconfig/one" title="aop config - 1">
       <compile files="A.java A2.java B.java foo.xml" options="-1.5 -showWeaveInfo">
-        <message kind="weave" text="goo"/>
+        <message kind="weave" text="Join point 'staticinitialization(void A.&lt;clinit&gt;())' in Type 'A' (A.java:1) advised by before advice from 'A' (A.java:2)"/>
+        <message kind="weave" text="Join point 'staticinitialization(void A2.&lt;clinit&gt;())' in Type 'A2' (A2.java:1) advised by before advice from 'A' (A.java:2)"/>
+        <message kind="weave" text="Join point 'staticinitialization(void B.&lt;clinit&gt;())' in Type 'B' (B.java:1) advised by before advice from 'A' (A.java:2)"/>
+      </compile>
+    </ajc-test>
+    
+    <ajc-test dir="features164/aopconfig/one" title="aop config - 2">
+      <compile files="A.java A2.java B.java B2.java foo2.xml" options="-1.5 -showWeaveInfo">
+        <message kind="weave" text="Join point 'staticinitialization(void B.&lt;clinit&gt;())' in Type 'B' (B.java:1) advised by before advice from 'A' (A.java:2)"/>
       </compile>
     </ajc-test>
 
