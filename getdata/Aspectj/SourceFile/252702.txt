@@ -15,8 +15,8 @@
 === RELATIONSHIPS REPORT ========= After a batch build
 (targets=1) <*pr131932.aj}Slide74)Bar.children (declared on) <*pr131932.aj}Slide74[Bar
 (targets=1) <*pr131932.aj}Slide74)Bar.getFirst (declared on) <*pr131932.aj}Slide74[Bar
-(targets=1) <*pr131932.aj[Foo (aspect declarations) <*pr131932.aj}Slide74)Foo.Foo)QList\<TT;>;
-(targets=1) <*pr131932.aj}Slide74)Foo.Foo)QList\<TT;>; (declared on) <*pr131932.aj[Foo
+(targets=1) <*pr131932.aj[Foo (aspect declarations) <*pr131932.aj}Slide74)Foo.Foo_new)QList\<TT;>;
+(targets=1) <*pr131932.aj}Slide74)Foo.Foo_new)QList\<TT;>; (declared on) <*pr131932.aj[Foo
 (targets=2) <*pr131932.aj}Slide74[Bar (aspect declarations) <*pr131932.aj}Slide74)Bar.getFirst
 (targets=2) <*pr131932.aj}Slide74[Bar (aspect declarations) <*pr131932.aj}Slide74)Bar.children
 === END OF RELATIONSHIPS REPORT ==
@@ -67,6 +67,10 @@ public interface IProgramElement extends Serializable {
 
 	public void setParent(IProgramElement parent);
 
+	public void setParentTypes(List parentTypes);
+
+	public List getParentTypes();
+
 	public String getName();
 
 	public void setName(String name);
@@ -90,8 +94,7 @@ public interface IProgramElement extends Serializable {
 	public String getPackageName();
 
 	/**
-	 * @param method
-	 *            return types or field types
+	 * @param method return types or field types
 	 */
 	public void setCorrespondingType(String returnType);
 
@@ -129,8 +132,7 @@ public interface IProgramElement extends Serializable {
 	public String toString();
 
 	/**
-	 * @return the javadoc comment for this program element, null if not
-	 *         available
+	 * @return the javadoc comment for this program element, null if not available
 	 */
 	public String getFormalComment();
 
@@ -161,8 +163,7 @@ public interface IProgramElement extends Serializable {
 	public List getParameterTypes();
 
 	/**
-	 * The format of the string handle is not specified, but is stable across
-	 * compilation sessions.
+	 * The format of the string handle is not specified, but is stable across compilation sessions.
 	 * 
 	 * @return a string representation of this element
 	 */
@@ -173,8 +174,7 @@ public interface IProgramElement extends Serializable {
 	public void setHandleIdentifier(String handle);
 
 	/**
-	 * @return a string representation of this node and all of its children
-	 *         (recursive)
+	 * @return a string representation of this node and all of its children (recursive)
 	 */
 	public String toLongString();
 
@@ -206,19 +206,13 @@ public interface IProgramElement extends Serializable {
 
 		public static final Modifiers STATIC = new Modifiers("static", 0x0008);
 		public static final Modifiers FINAL = new Modifiers("final", 0x0010);
-		public static final Modifiers ABSTRACT = new Modifiers("abstract",
-				0x0400);
-		public static final Modifiers SYNCHRONIZED = new Modifiers(
-				"synchronized", 0x0020);
-		public static final Modifiers VOLATILE = new Modifiers("volatile",
-				0x0040);
-		public static final Modifiers STRICTFP = new Modifiers("strictfp",
-				0x0800);
-		public static final Modifiers TRANSIENT = new Modifiers("transient",
-				0x0080);
+		public static final Modifiers ABSTRACT = new Modifiers("abstract", 0x0400);
+		public static final Modifiers SYNCHRONIZED = new Modifiers("synchronized", 0x0020);
+		public static final Modifiers VOLATILE = new Modifiers("volatile", 0x0040);
+		public static final Modifiers STRICTFP = new Modifiers("strictfp", 0x0800);
+		public static final Modifiers TRANSIENT = new Modifiers("transient", 0x0080);
 		public static final Modifiers NATIVE = new Modifiers("native", 0x0100);
-		public static final Modifiers[] ALL = { STATIC, FINAL, ABSTRACT,
-				SYNCHRONIZED, VOLATILE, STRICTFP, TRANSIENT, NATIVE };
+		public static final Modifiers[] ALL = { STATIC, FINAL, ABSTRACT, SYNCHRONIZED, VOLATILE, STRICTFP, TRANSIENT, NATIVE };
 		private final String name;
 		private final int bit;
 
@@ -253,13 +247,10 @@ public interface IProgramElement extends Serializable {
 
 		public static final Accessibility PUBLIC = new Accessibility("public");
 		public static final Accessibility PACKAGE = new Accessibility("package");
-		public static final Accessibility PROTECTED = new Accessibility(
-				"protected");
+		public static final Accessibility PROTECTED = new Accessibility("protected");
 		public static final Accessibility PRIVATE = new Accessibility("private");
-		public static final Accessibility PRIVILEGED = new Accessibility(
-				"privileged");
-		public static final Accessibility[] ALL = { PUBLIC, PACKAGE, PROTECTED,
-				PRIVATE, PRIVILEGED };
+		public static final Accessibility PRIVILEGED = new Accessibility("privileged");
+		public static final Accessibility[] ALL = { PUBLIC, PACKAGE, PROTECTED, PRIVATE, PRIVILEGED };
 		private final String name;
 
 		private Accessibility(String name) {
@@ -301,12 +292,9 @@ public interface IProgramElement extends Serializable {
 		public static final Kind ANNOTATION = new Kind("annotation");
 		public static final Kind INITIALIZER = new Kind("initializer");
 		public static final Kind INTER_TYPE_FIELD = new Kind("inter-type field");
-		public static final Kind INTER_TYPE_METHOD = new Kind(
-				"inter-type method");
-		public static final Kind INTER_TYPE_CONSTRUCTOR = new Kind(
-				"inter-type constructor");
-		public static final Kind INTER_TYPE_PARENT = new Kind(
-				"inter-type parent");
+		public static final Kind INTER_TYPE_METHOD = new Kind("inter-type method");
+		public static final Kind INTER_TYPE_CONSTRUCTOR = new Kind("inter-type constructor");
+		public static final Kind INTER_TYPE_PARENT = new Kind("inter-type parent");
 		public static final Kind CONSTRUCTOR = new Kind("constructor");
 		public static final Kind METHOD = new Kind("method");
 		public static final Kind FIELD = new Kind("field");
@@ -316,30 +304,20 @@ public interface IProgramElement extends Serializable {
 		public static final Kind DECLARE_WARNING = new Kind("declare warning");
 		public static final Kind DECLARE_ERROR = new Kind("declare error");
 		public static final Kind DECLARE_SOFT = new Kind("declare soft");
-		public static final Kind DECLARE_PRECEDENCE = new Kind(
-				"declare precedence");
+		public static final Kind DECLARE_PRECEDENCE = new Kind("declare precedence");
 		public static final Kind CODE = new Kind("code");
 		public static final Kind ERROR = new Kind("error");
-		public static final Kind DECLARE_ANNOTATION_AT_CONSTRUCTOR = new Kind(
-				"declare @constructor");
-		public static final Kind DECLARE_ANNOTATION_AT_FIELD = new Kind(
-				"declare @field");
-		public static final Kind DECLARE_ANNOTATION_AT_METHOD = new Kind(
-				"declare @method");
-		public static final Kind DECLARE_ANNOTATION_AT_TYPE = new Kind(
-				"declare @type");
+		public static final Kind DECLARE_ANNOTATION_AT_CONSTRUCTOR = new Kind("declare @constructor");
+		public static final Kind DECLARE_ANNOTATION_AT_FIELD = new Kind("declare @field");
+		public static final Kind DECLARE_ANNOTATION_AT_METHOD = new Kind("declare @method");
+		public static final Kind DECLARE_ANNOTATION_AT_TYPE = new Kind("declare @type");
 		public static final Kind SOURCE_FOLDER = new Kind("source folder");
 
-		public static final Kind[] ALL = { PROJECT, PACKAGE, FILE, FILE_JAVA,
-				FILE_ASPECTJ, FILE_LST, IMPORT_REFERENCE, CLASS, INTERFACE,
-				ASPECT, ENUM, ENUM_VALUE, ANNOTATION, INITIALIZER,
-				INTER_TYPE_FIELD, INTER_TYPE_METHOD, INTER_TYPE_CONSTRUCTOR,
-				INTER_TYPE_PARENT, CONSTRUCTOR, METHOD, FIELD, POINTCUT,
-				ADVICE, DECLARE_PARENTS, DECLARE_WARNING, DECLARE_ERROR,
-				DECLARE_SOFT, DECLARE_PRECEDENCE, CODE, ERROR,
-				DECLARE_ANNOTATION_AT_CONSTRUCTOR, DECLARE_ANNOTATION_AT_FIELD,
-				DECLARE_ANNOTATION_AT_METHOD, DECLARE_ANNOTATION_AT_TYPE,
-				SOURCE_FOLDER
+		public static final Kind[] ALL = { PROJECT, PACKAGE, FILE, FILE_JAVA, FILE_ASPECTJ, FILE_LST, IMPORT_REFERENCE, CLASS,
+				INTERFACE, ASPECT, ENUM, ENUM_VALUE, ANNOTATION, INITIALIZER, INTER_TYPE_FIELD, INTER_TYPE_METHOD,
+				INTER_TYPE_CONSTRUCTOR, INTER_TYPE_PARENT, CONSTRUCTOR, METHOD, FIELD, POINTCUT, ADVICE, DECLARE_PARENTS,
+				DECLARE_WARNING, DECLARE_ERROR, DECLARE_SOFT, DECLARE_PRECEDENCE, CODE, ERROR, DECLARE_ANNOTATION_AT_CONSTRUCTOR,
+				DECLARE_ANNOTATION_AT_FIELD, DECLARE_ANNOTATION_AT_METHOD, DECLARE_ANNOTATION_AT_TYPE, SOURCE_FOLDER
 
 		};
 
@@ -371,18 +349,16 @@ public interface IProgramElement extends Serializable {
 		}
 
 		public boolean isMember() {
-			return this == FIELD || this == METHOD || this == CONSTRUCTOR
-					|| this == POINTCUT || this == ADVICE || this == ENUM_VALUE;
+			return this == FIELD || this == METHOD || this == CONSTRUCTOR || this == POINTCUT || this == ADVICE
+					|| this == ENUM_VALUE;
 		}
 
 		public boolean isInterTypeMember() {
-			return this == INTER_TYPE_CONSTRUCTOR || this == INTER_TYPE_FIELD
-					|| this == INTER_TYPE_METHOD;
+			return this == INTER_TYPE_CONSTRUCTOR || this == INTER_TYPE_FIELD || this == INTER_TYPE_METHOD;
 		}
 
 		public boolean isType() {
-			return this == CLASS || this == INTERFACE || this == ASPECT
-					|| this == ANNOTATION || this == ENUM;
+			return this == CLASS || this == INTERFACE || this == ASPECT || this == ANNOTATION || this == ENUM;
 		}
 
 		public boolean isSourceFile() {
@@ -341,6 +341,16 @@ public class ProgramElement implements IProgramElement {
 		// this.returnType = s;
 	}
 
+	public void setParentTypes(List ps) {
+		if (kvpairs == Collections.EMPTY_MAP)
+			kvpairs = new HashMap();
+		kvpairs.put("parentTypes", ps);
+	}
+
+	public List getParentTypes() {
+		return (List) (kvpairs == null ? null : kvpairs.get("parentTypes"));
+	}
+
 	public String getCorrespondingType() {
 		return getCorrespondingType(false);
 	}
@@ -0,0 +1,8 @@
+package a;
+import java.io.*;
+
+public aspect A {
+  declare parents: p.C implements Serializable,Goo;
+}
+
+interface Goo {}
@@ -0,0 +1,4 @@
+package p;
+
+class C {
+}
@@ -48,6 +48,27 @@ import org.aspectj.util.FileUtil;
  */
 public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementalAjdeInteractionTestbed {
 
+	public void testDeclareParentsInModel() {
+		String p = "decps";
+		initialiseProject(p);
+		build(p);
+		IProgramElement decp = getModelFor(p).getHierarchy().findElementForHandle("=decps<a{A.java}A`declare parents");
+		List ps = decp.getParentTypes();
+		assertNotNull(ps);
+		assertEquals(2, ps.size());
+		int count = 0;
+		for (Iterator iterator = ps.iterator(); iterator.hasNext();) {
+			String type = (String) iterator.next();
+			if (type.equals("java.io.Serializable")) {
+				count++;
+			}
+			if (type.equals("a.Goo")) {
+				count++;
+			}
+		}
+		assertEquals("Should have found the two types in: " + ps, 2, count);
+	}
+
 	/*
 	 * A.aj package pack; public aspect A { pointcut p() : call( C.method before() : p() { // line 7 } }
 	 * 
@@ -378,6 +399,17 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 			for (int i = 0; i < indent; i++)
 				System.out.print(" ");
 			System.out.println("  hid is " + node.getHandleIdentifier());
+			// Map m = ((ProgramElement) node).kvpairs;
+			// if (m != null) {
+			// Set keys = m.keySet();
+			// for (Iterator iterator = keys.iterator(); iterator.hasNext();) {
+			// Object object = (Object) iterator.next();
+			//
+			// for (int i = 0; i < indent; i++)
+			// System.out.print(" ");
+			// System.out.println("kvp: " + object + " = " + m.get(object));
+			// }
+			// }
 			for (Iterator i = node.getChildren().iterator(); i.hasNext();) {
 				dumptree((IProgramElement) i.next(), indent + 2);
 			}
@@ -27,6 +27,7 @@ import java.util.StringTokenizer;
 import org.aspectj.ajdt.internal.compiler.CompilationResultDestinationManager;
 import org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration;
 import org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration;
+import org.aspectj.ajdt.internal.compiler.ast.DeclareDeclaration;
 import org.aspectj.ajdt.internal.compiler.ast.InterTypeDeclaration;
 import org.aspectj.ajdt.internal.compiler.ast.PointcutDeclaration;
 import org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment;
@@ -65,9 +66,12 @@ import org.aspectj.weaver.ResolvedMember;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.patterns.AndPointcut;
+import org.aspectj.weaver.patterns.Declare;
+import org.aspectj.weaver.patterns.DeclareParents;
 import org.aspectj.weaver.patterns.OrPointcut;
 import org.aspectj.weaver.patterns.Pointcut;
 import org.aspectj.weaver.patterns.ReferencePointcut;
+import org.aspectj.weaver.patterns.TypePatternList;
 
 /**
  * At each iteration of <CODE>processCompilationUnit</CODE> the declarations for a particular compilation unit are added to the
@@ -484,6 +488,18 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 		// if (shouldAddUsesPointcut)
 		// addUsesPointcutRelationsForNode(peNode, namedPointcuts, methodDeclaration);
 
+		if (methodDeclaration instanceof DeclareDeclaration) {
+			DeclareDeclaration dDeclaration = (DeclareDeclaration) methodDeclaration;
+			Declare decl = dDeclaration.declareDecl;
+			if (decl instanceof DeclareParents) {
+				TypePatternList tpl = ((DeclareParents) decl).getParents();
+				List parents = new ArrayList();
+				for (int i = 0; i < tpl.size(); i++) {
+					parents.add(tpl.get(i).getExactType().getName());
+				}
+				peNode.setParentTypes(parents);
+			}
+		}
 		if (methodDeclaration.returnType != null) {
 			// if we don't make the distinction between ITD fields and other
 			// methods, then we loose the type, for example int, for the field
