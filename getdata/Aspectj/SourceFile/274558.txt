@@ -165,7 +165,7 @@ public class AsmRelationshipProvider {
 			IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARED_BY, false,
 					true);
 			back.addTarget(sourceHandle);
-			if (sourceNode!=null && sourceNode.getSourceLocation() != null) {
+			if (sourceNode != null && sourceNode.getSourceLocation() != null) {
 				// May have been a bug in the compiled aspect - so it didn't get put in the model
 				model.addAspectInEffectThisBuild(sourceNode.getSourceLocation().getSourceFile());
 			}
@@ -176,35 +176,36 @@ public class AsmRelationshipProvider {
 		IHierarchy hierarchy = model.getHierarchy();
 		ISourceLocation sourceLocation = onType.getSourceLocation();
 		String canonicalFilePath = model.getCanonicalFilePath(sourceLocation.getSourceFile());
-		int lineNumber = sourceLocation.getLine(); 
+		int lineNumber = sourceLocation.getLine();
 		// Find the relevant source file node first
 		IProgramElement node = hierarchy.findNodeForSourceFile(hierarchy.getRoot(), canonicalFilePath);
 		if (node == null) {
-			// Does not exist in the model - probably an inpath 
+			// Does not exist in the model - probably an inpath
 			String bpath = onType.getBinaryPath();
-			if (bpath==null) {
-				return model.getHandleProvider().createHandleIdentifier(createFileStructureNode(model,canonicalFilePath));
+			if (bpath == null) {
+				return model.getHandleProvider().createHandleIdentifier(createFileStructureNode(model, canonicalFilePath));
 			} else {
 				IProgramElement programElement = model.getHierarchy().getRoot();
 				// =Foo/,<g(G.class[G
 				StringBuffer phantomHandle = new StringBuffer();
-				
+
 				// =Foo
 				phantomHandle.append(programElement.getHandleIdentifier());
-				
+
 				// /, - the comma is a 'well defined char' that means inpath
-				phantomHandle.append(HandleProviderDelimiter.PACKAGEFRAGMENTROOT.getDelimiter()).append(HandleProviderDelimiter.PHANTOM.getDelimiter());
-				
+				phantomHandle.append(HandleProviderDelimiter.PACKAGEFRAGMENTROOT.getDelimiter()).append(
+						HandleProviderDelimiter.PHANTOM.getDelimiter());
+
 				int pos = bpath.indexOf('!');
 				if (pos != -1) {
 					// jar or dir
-					String jarPath = bpath.substring(0,pos);
+					String jarPath = bpath.substring(0, pos);
 					String element = model.getHandleElementForInpath(jarPath);
-					if (element!=null) {
-						phantomHandle.append(element);						
+					if (element != null) {
+						phantomHandle.append(element);
 					}
 				}
-				
+
 				// <g
 				String packageName = onType.getPackageName();
 				phantomHandle.append(HandleProviderDelimiter.PACKAGEFRAGMENT.getDelimiter()).append(packageName);
@@ -212,21 +213,21 @@ public class AsmRelationshipProvider {
 				// (G.class
 				// could fix the binary path to only be blah.class bit
 				int dotClassPosition = bpath.lastIndexOf(".class");// what to do if -1
-				if (dotClassPosition==-1) {
+				if (dotClassPosition == -1) {
 					phantomHandle.append(HandleProviderDelimiter.CLASSFILE.getDelimiter()).append("UNKNOWN.class");
 				} else {
 					int startPosition = dotClassPosition;
 					char ch;
-					while (startPosition>0 && ((ch=bpath.charAt(startPosition))!='/' && ch!='\\' && ch!='!')) {
+					while (startPosition > 0 && ((ch = bpath.charAt(startPosition)) != '/' && ch != '\\' && ch != '!')) {
 						startPosition--;
 					}
-					String classFile = bpath.substring(startPosition+1,dotClassPosition+6);
+					String classFile = bpath.substring(startPosition + 1, dotClassPosition + 6);
 					phantomHandle.append(HandleProviderDelimiter.CLASSFILE.getDelimiter()).append(classFile);
 				}
-				
+
 				// [G
 				phantomHandle.append(HandleProviderDelimiter.TYPE.getDelimiter()).append(onType.getClassName());
-				
+
 				return phantomHandle.toString();
 			}
 		} else {
@@ -238,9 +239,9 @@ public class AsmRelationshipProvider {
 				return model.getHandleProvider().createHandleIdentifier(closernode);
 			}
 		}
-		
+
 	}
-	
+
 	public static IProgramElement createFileStructureNode(AsmManager asm, String sourceFilePath) {
 		// SourceFilePath might have originated on windows on linux...
 		int lastSlash = sourceFilePath.lastIndexOf('\\');
@@ -353,8 +354,9 @@ public class AsmRelationshipProvider {
 		}
 
 		// create the class file node
-		IProgramElement classFileNode = new ProgramElement(model, filenode.getName(), IProgramElement.Kind.FILE,
-				getBinarySourceLocation(aspect, aspect.getSourceLocation()), 0, null, null);
+		ISourceLocation binLocation = getBinarySourceLocation(aspect, aspect.getSourceLocation());
+		String f = getBinaryFile(aspect).getName();
+		IProgramElement classFileNode = new ProgramElement(model, f, IProgramElement.Kind.FILE, binLocation, 0, null, null);
 
 		// create package ipe if one exists....
 		IProgramElement root = model.getHierarchy().getRoot();
@@ -0,0 +1,7 @@
+package p;
+
+import r.InterfaceForITD;
+
+public class HasITDs1 implements InterfaceForITD {
+
+}
@@ -0,0 +1,15 @@
+package q;
+
+import p.HasITDs1;
+import r.HasITDs2;
+
+public class UsesITDs1 {
+
+	void nothing() {
+		new HasITDs1().x++; 
+		new HasITDs2().x++;
+		new HasITDs1().nothing(1, 1, 1);
+		new HasITDs2().nothing(1, 1, 1);
+	}
+	
+}
\ No newline at end of file
@@ -0,0 +1,9 @@
+package r;
+
+public aspect DeclaresITD {
+	public int InterfaceForITD.x = 9;
+	
+	public void InterfaceForITD.nothing(int x, int y, int z) {
+		
+	}
+}
\ No newline at end of file
@@ -0,0 +1,5 @@
+package r;
+
+public class HasITDs2 implements InterfaceForITD {
+
+}
@@ -0,0 +1,5 @@
+package r;
+
+public interface InterfaceForITD {
+
+}
@@ -71,6 +71,9 @@ public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	 * was available as source. There are two compile steps in the xml for the test - commenting out the first will allow the source
 	 * handles to be seen, leaving it in will switch to binary. Effectively the only difference should be that in the binary case
 	 * the handles are prefixed 'binaries'.
+	 * 
+	 * Change due to bug 274558: now AJDT wants (blah.class as the 'source file' for the ITD so that is another difference when
+	 * switching.
 	 */
 	public void testItdsAspectPathModel_pr265729_1() {
 		runTest("aspectpath model");
@@ -88,7 +91,8 @@ public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		IRelationship ir = (IRelationship) model.getRelationshipMap().get(ipe).get(0);
 		String itdMethodHandle = (String) ir.getTargets().get(0);
 		// handle when all source: <{Aspect.java}Aspect)Orange.getColor
-		assertEquals("/binaries<{Aspect.java}Aspect)Orange.getColor", itdMethodHandle);
+		// assertEquals("/binaries<{Aspect.java}Aspect)Orange.getColor", itdMethodHandle);
+		assertEquals("/binaries<(Aspect.class}Aspect)Orange.getColor", itdMethodHandle);
 		IProgramElement itdpe = model.getHierarchy().findElementForHandle(itdMethodHandle);
 		assertEquals("java.awt.Color", itdpe.getCorrespondingType(true));
 
@@ -101,7 +105,8 @@ public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		ir = (IRelationship) model.getRelationshipMap().get(ipe).get(0);
 		String itdFieldHandle = (String) ir.getTargets().get(0);
 		// source handle <{Aspect.java}Aspect)Strawberry.color
-		assertEquals("/binaries<{Aspect.java}Aspect)Strawberry.color", itdFieldHandle);
+		// assertEquals("/binaries<{Aspect.java}Aspect)Strawberry.color", itdFieldHandle);
+		assertEquals("/binaries<(Aspect.class}Aspect)Strawberry.color", itdFieldHandle);
 		IProgramElement itdfpe = model.getHierarchy().findElementForHandle(itdMethodHandle);
 		assertEquals("java.awt.Color", itdfpe.getCorrespondingType(true));
 
@@ -113,7 +118,8 @@ public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		ir = (IRelationship) model.getRelationshipMap().get(ipe).get(0);
 		String itdCtorHandle = (String) ir.getTargets().get(0);
 		// source handle <{Aspect.java}Aspect)Fruit.Fruit_new)QColor;)QString;
-		assertEquals("/binaries<{Aspect.java}Aspect)Fruit.Fruit_new)QColor;)QString;", itdCtorHandle);
+		// assertEquals("/binaries<{Aspect.java}Aspect)Fruit.Fruit_new)QColor;)QString;", itdCtorHandle);
+		assertEquals("/binaries<(Aspect.class}Aspect)Fruit.Fruit_new)QColor;)QString;", itdCtorHandle);
 		IProgramElement itdcpe = model.getHierarchy().findElementForHandle(itdCtorHandle);
 		List ptypes = itdcpe.getParameterTypes();
 		assertEquals("java.awt.Color", new String((char[]) ptypes.get(0)));
@@ -214,9 +214,9 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		}
 		// ITD from the test program:
 		// public String InterTypeAspectInterface.foo(int i,List list,App a) {
-		assertEquals("=pr265729_client/binaries<be.cronos.aop.aspects*InterTypeAspect.aj}InterTypeAspect`declare parents", h1);
+		assertEquals("=pr265729_client/binaries<be.cronos.aop.aspects(InterTypeAspect.class}InterTypeAspect`declare parents", h1);
 		assertEquals(
-				"=pr265729_client/binaries<be.cronos.aop.aspects*InterTypeAspect.aj}InterTypeAspect)InterTypeAspectInterface.foo)I)QList;)QSerializable;",
+				"=pr265729_client/binaries<be.cronos.aop.aspects(InterTypeAspect.class}InterTypeAspect)InterTypeAspectInterface.foo)I)QList;)QSerializable;",
 				h2);
 		IProgramElement binaryDecp = getModelFor(cli).getHierarchy().getElement(h1);
 		assertNotNull(binaryDecp);
@@ -924,13 +924,15 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		String loc = "";
 		if (node != null) {
 			if (node.getSourceLocation() != null)
-				loc = node.getSourceLocation().toString();
+				loc = Integer.toString(node.getSourceLocation().getLine());
 		}
-		System.out.println(node + "  [" + (node == null ? "null" : node.getKind().toString()) + "] " + loc);
+		// System.out.println(node + "  [" + (node == null ? "null" : node.getKind().toString()) + "] " + loc);
+		System.out.println(node + "  [" + (node == null ? "null" : node.getKind().toString()) + "] " + loc
+				+ (node == null ? "" : " hid:" + node.getHandleIdentifier()));
 		if (node != null) {
-			for (int i = 0; i < indent; i++)
-				System.out.print(" ");
-			System.out.println("  hid is " + node.getHandleIdentifier());
+			// for (int i = 0; i < indent; i++)
+			// System.out.print(" ");
+			// System.out.println("  hid is " + node.getHandleIdentifier());
 			// Map m = ((ProgramElement) node).kvpairs;
 			// if (m != null) {
 			// Set keys = m.keySet();
@@ -1006,6 +1008,30 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		assertEquals("=AspectPathTwo/binaries<(Asp2.class}Asp2&before", findElementAtLine(root, 16).getHandleIdentifier());
 	}
 
+	public void testAspectPath_pr274558() throws Exception {
+		AjdeInteractionTestbed.VERBOSE = true;
+		String base = "bug274558depending";
+		String depending = "bug274558base";
+		// addSourceFolderForSourceFile(bug2, getProjectRelativePath(bug2, "src/C.java"), "src");
+		initialiseProject(base);
+		initialiseProject(depending);
+		configureAspectPath(depending, getProjectRelativePath(base, "bin"));
+		build(base);
+		build(depending);
+		printModel(depending);
+		IProgramElement root = getModelFor(depending).getHierarchy().getRoot();
+		assertEquals("=bug274558base/binaries<r(DeclaresITD.class}DeclaresITD)InterfaceForITD.x", findElementAtLine(root, 4)
+				.getHandleIdentifier());
+		// assertEquals("=AspectPathTwo/binaries<(Asp2.class}Asp2&before", findElementAtLine(root, 16).getHandleIdentifier());
+	}
+
+	private void printModel(String projectName) throws Exception {
+		dumptree(getModelFor(projectName).getHierarchy().getRoot(), 0);
+		PrintWriter pw = new PrintWriter(System.out);
+		getModelFor(projectName).dumprels(pw);
+		pw.flush();
+	}
+
 	public void testAspectPath_pr265693() throws IOException {
 		String bug = "AspectPath3";
 		String bug2 = "AspectPath4";
