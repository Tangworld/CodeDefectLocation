@@ -2,7 +2,7 @@
 :
                     INVOKESTATIC Two.aspectOf ()LTwo;   (line 15)
                     INVOKEVIRTUAL Two.ajc$before$Two$1$8d8821ee ()V
-                    ALOAD_0
+                    ALOAD_0     // LC; this
                     DUP
                     ASTORE_1
                     MONITORENTER
@@ -19,11 +19,14 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.Map;
 
+import org.aspectj.apache.bcel.classfile.LocalVariable;
+import org.aspectj.apache.bcel.classfile.LocalVariableTable;
 import org.aspectj.apache.bcel.generic.InstructionConstants;
 import org.aspectj.apache.bcel.generic.InstructionFactory;
 import org.aspectj.apache.bcel.generic.InstructionHandle;
 import org.aspectj.apache.bcel.generic.InstructionList;
 import org.aspectj.apache.bcel.generic.LineNumberTag;
+import org.aspectj.apache.bcel.generic.LocalVariableTag;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.bridge.Message;
 import org.aspectj.weaver.Advice;
@@ -41,7 +44,6 @@ import org.aspectj.weaver.ShadowMunger;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.WeaverMessages;
 import org.aspectj.weaver.World;
-import org.aspectj.weaver.Shadow.Kind;
 import org.aspectj.weaver.ast.Literal;
 import org.aspectj.weaver.ast.Test;
 import org.aspectj.weaver.patterns.ExactTypePattern;
@@ -267,12 +269,12 @@ class BcelAdvice extends Advice {
 		// }
 		if (pointcutTest == Literal.FALSE) { // not usually allowed, except in one case (260384)
 			Member sig = shadow.getSignature();
-			if (sig.getArity() == 0 && shadow.getKind() == Shadow.MethodCall && sig.getName().charAt(0) == 'c' 
-				&& sig.getReturnType().equals(ResolvedType.OBJECT) && sig.getName().equals("clone")) {
+			if (sig.getArity() == 0 && shadow.getKind() == Shadow.MethodCall && sig.getName().charAt(0) == 'c'
+					&& sig.getReturnType().equals(ResolvedType.OBJECT) && sig.getName().equals("clone")) {
 				return false;
 			}
 		}
-		
+
 		if (getKind() == AdviceKind.Before) {
 			shadow.weaveBefore(this);
 		} else if (getKind() == AdviceKind.AfterReturning) {
@@ -447,8 +449,21 @@ class BcelAdvice extends Advice {
 			// } else { // If it wasn't, the best we can do is the line number of the first instruction in the method
 			lineNumber = shadow.getEnclosingMethod().getMemberView().getLineNumberOfFirstInstruction();
 			// }
-			if (lineNumber > 0)
-				il.getStart().addTargeter(new LineNumberTag(lineNumber));
+			InstructionHandle start = il.getStart();
+			if (lineNumber > 0) {
+				start.addTargeter(new LineNumberTag(lineNumber));
+			}
+			// Fix up the local variables: find any that have a startPC of 0 and ensure they target the new start of the method
+			LocalVariableTable lvt = shadow.getEnclosingMethod().getMemberView().getMethod().getLocalVariableTable();
+			if (lvt != null) {
+				LocalVariable[] lvTable = lvt.getLocalVariableTable();
+				for (int i = 0; i < lvTable.length; i++) {
+					LocalVariable lv = lvTable[i];
+					if (lv.getStartPC() == 0) {
+						start.addTargeter(new LocalVariableTag(lv.getSignature(), lv.getName(), lv.getIndex(), 0));
+					}
+				}
+			}
 		}
 
 		return il;
@@ -14,18 +14,56 @@ import java.io.File;
 
 import junit.framework.Test;
 
+import org.aspectj.apache.bcel.classfile.JavaClass;
+import org.aspectj.apache.bcel.classfile.LocalVariable;
+import org.aspectj.apache.bcel.classfile.LocalVariableTable;
+import org.aspectj.apache.bcel.classfile.Method;
+import org.aspectj.apache.bcel.util.ClassPath;
+import org.aspectj.apache.bcel.util.SyntheticRepository;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	// Single piece of advice on before execution of a method with a this and a parameter
+	public void testDebuggingBeforeAdvice_pr262509() {
+		runTest("debugging before advice");
+		Method method = getMethodFromClass(getClassFrom(ajc.getSandboxDirectory(), "Foo"), "foo");
+		assertEquals("LFoo; this(0) start=0 len=13", stringify(method.getLocalVariableTable(), 0));
+		assertEquals("LBar; bar(1) start=0 len=13", stringify(method.getLocalVariableTable(), 1));
+	}
+
+	// Single piece of advice on before execution of a method with a this and a parameter and other various locals within it
+	public void testDebuggingBeforeAdvice_pr262509_2() {
+		// Compile with -preserveAllLocals
+		runTest("debugging before advice - 2");
+		Method method = getMethodFromClass(getClassFrom(ajc.getSandboxDirectory(), "Foo2"), "foo");
+		System.out.println(stringify(method.getLocalVariableTable()));
+		assertEquals("LFoo2; this(0) start=0 len=34", stringify(method.getLocalVariableTable(), 0));
+		assertEquals("LBar; bar(1) start=0 len=34", stringify(method.getLocalVariableTable(), 1));
+		assertEquals("Ljava/lang/String; s(2) start=15 len=19", stringify(method.getLocalVariableTable(), 2));
+		assertEquals("Ljava/lang/String; s2(3) start=18 len=10", stringify(method.getLocalVariableTable(), 3));
+		assertEquals("Ljava/lang/Exception; e(3) start=29 len=4", stringify(method.getLocalVariableTable(), 4));
+	}
+
+	// Two pieces of advice on before execution of a method with a this and a parameter and another local within it
+	public void testDebuggingBeforeAdvice_pr262509_3() {
+		// Compile with -preserveAllLocals
+		runTest("debugging before advice - 3");
+		Method method = getMethodFromClass(getClassFrom(ajc.getSandboxDirectory(), "Foo3"), "foo");
+		System.out.println(stringify(method.getLocalVariableTable()));
+		assertEquals("LFoo3; this(0) start=0 len=35", stringify(method.getLocalVariableTable(), 0));
+		assertEquals("LBar; bar(1) start=0 len=35", stringify(method.getLocalVariableTable(), 1));
+		assertEquals("Ljava/lang/Exception; e(2) start=30 len=4", stringify(method.getLocalVariableTable(), 2));
+	}
+
 	public void testRogueErrors_pr246393_1() {
 		runTest("rogue errors - 1");
 	}
 
-//	public void testNameClash_pr262257() {
-//		runTest("name clash");
-//		fail("incomplete");
-//	}
+	// public void testNameClash_pr262257() {
+	// runTest("name clash");
+	// fail("incomplete");
+	// }
 
 	public void testCompilingSpring_pr260384() {
 		runTest("compiling spring");
@@ -51,6 +89,8 @@ public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		runTest("ataspectj decp 258788");
 	}
 
+	// ---
+
 	public static Test suite() {
 		return XMLBasedAjcTestCase.loadSuite(Ajc164Tests.class);
 	}
@@ -59,4 +99,50 @@ public class Ajc164Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		return new File("../tests/src/org/aspectj/systemtest/ajc164/ajc164.xml");
 	}
 
+	private SyntheticRepository createRepos(File cpentry) {
+		ClassPath cp = new ClassPath(cpentry + File.pathSeparator + System.getProperty("java.class.path"));
+		return SyntheticRepository.getInstance(cp);
+	}
+
+	private JavaClass getClassFrom(File where, String clazzname) {
+		try {
+			SyntheticRepository repos = createRepos(where);
+			return repos.loadClass(clazzname);
+		} catch (ClassNotFoundException cnfe) {
+			throw new RuntimeException("Failed to find class " + clazzname + " at " + where.toString());
+		}
+	}
+
+	private Method getMethodFromClass(JavaClass clazz, String methodName) {
+		Method[] meths = clazz.getMethods();
+		for (int i = 0; i < meths.length; i++) {
+			Method method = meths[i];
+			if (method.getName().equals(methodName)) {
+				return meths[i];
+			}
+		}
+		return null;
+	}
+
+	private String stringify(LocalVariableTable lvt, int slotIndex) {
+		LocalVariable lv[] = lvt.getLocalVariableTable();
+		LocalVariable lvEntry = lv[slotIndex];
+		StringBuffer sb = new StringBuffer();
+		sb.append(lvEntry.getSignature()).append(" ").append(lvEntry.getName()).append("(").append(lvEntry.getIndex()).append(
+				") start=").append(lvEntry.getStartPC()).append(" len=").append(lvEntry.getLength());
+		return sb.toString();
+	}
+
+	private String stringify(LocalVariableTable lvt) {
+		StringBuffer sb = new StringBuffer();
+		sb.append("LocalVariableTable.  Entries=#" + lvt.getTableLength()).append("\n");
+		LocalVariable lv[] = lvt.getLocalVariableTable();
+		for (int i = 0; i < lv.length; i++) {
+			LocalVariable lvEntry = lv[i];
+			sb.append(lvEntry.getSignature()).append(" ").append(lvEntry.getName()).append("(").append(lvEntry.getIndex()).append(
+					") start=").append(lvEntry.getStartPC()).append(" len=").append(lvEntry.getLength()).append("\n");
+		}
+
+		return sb.toString();
+	}
 }
\ No newline at end of file
@@ -2,6 +2,18 @@
 
 <suite>
 
+    <ajc-test dir="bugs164/pr262509" title="debugging before advice">
+      <compile files="Foo.java" options="-1.5"/>
+    </ajc-test> 
+    
+    <ajc-test dir="bugs164/pr262509" title="debugging before advice - 2">
+      <compile files="Foo2.java" options="-1.5 -preserveAllLocals"/>
+    </ajc-test> 
+    
+    <ajc-test dir="bugs164/pr262509" title="debugging before advice - 3">
+      <compile files="Foo3.java" options="-1.5 -preserveAllLocals"/>
+    </ajc-test> 
+       
     <ajc-test dir="bugs164/pr246393" title="rogue errors - 1">
       <compile files="D.java" options="-1.5">
         <message kind="error" line="2" text="error on token"/>
@@ -0,0 +1,20 @@
+
+public class Foo {
+	int i=3;
+	
+	// Need local variable table for this code to be OK and not lose the fact that this/etc are setup from
+	// instruction 0 to the end of the method
+	void foo(Bar bar) {
+		i = 33;
+		
+	}
+	public static void main(String[] args) {
+		new Foo().foo(null);
+	}
+}
+
+class Bar {}
+
+aspect FooAspect {
+	before(): execution(* *(..)) {}
+}
@@ -0,0 +1,26 @@
+
+public class Foo2 {
+	int i=3;
+	
+	// Need local variable table for this code to be OK and not lose the fact that this/etc are setup from
+	// instruction 0 to the end of the method
+	void foo(Bar bar) {
+		i = 33;
+        String s = "hello";
+        try {
+          String s2 = "hello2";
+          System.out.println(s2);
+        } catch (Exception e) {
+          e.printStackTrace();
+        }		
+	}
+	public static void main(String[] args) {
+		new Foo2().foo(null);
+	}
+}
+
+class Bar {}
+
+aspect FooAspect {
+	before(): execution(* *(..)) {}
+}
@@ -0,0 +1,25 @@
+
+public class Foo3 {
+	int i=3;
+	
+	// Need local variable table for this code to be OK and not lose the fact that this/etc are setup from
+	// instruction 0 to the end of the method
+	void foo(Bar bar) {
+		i = 33;
+        try {
+System.out.println("x");
+        } catch (Exception e) {
+          e.printStackTrace();
+        }
+	}
+	public static void main(String[] args) {
+		new Foo3().foo(null);
+	}
+}
+
+class Bar {}
+
+aspect FooAspect {
+	before(): execution(* *(..)) {}
+	before(): execution(* *(..)) {}
+}
