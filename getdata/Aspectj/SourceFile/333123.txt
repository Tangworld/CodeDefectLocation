@@ -0,0 +1,20 @@
+package a.b;
+import java.util.*;
+
+public class Code {
+  public void method(String s) {}
+
+  public int getInt() { return 1; }
+
+  public Code transform(Code code,String s, long l) { return code; }
+
+  public List<Code> transform2(List<String> listOfString) { return null; }
+
+  int fieldInt;
+
+  String fieldString;
+
+  Code fieldCode;
+  
+  List<a.b.Code> fieldList;
+}
@@ -117,7 +117,8 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 	 * 
 	 * @param cuDeclaration
 	 * @param buildConfig
-	 * @param structureModel hiearchy to add this unit's declarations to
+	 * @param structureModel
+	 *            hiearchy to add this unit's declarations to
 	 */
 	public void buildStructureForCompilationUnit(CompilationUnitDeclaration cuDeclaration, AsmManager structureModel,
 			AjBuildConfig buildConfig) {
@@ -667,7 +668,8 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 
 	/**
 	 * @param left
-	 * @param pointcuts accumulator for named pointcuts
+	 * @param pointcuts
+	 *            accumulator for named pointcuts
 	 */
 	private void addAllNamed(Pointcut pointcut, List pointcuts) {
 		if (pointcut == null) {
@@ -834,10 +836,19 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 		} else {
 			peNode = new ProgramElement(activeStructureModel, new String(fieldDeclaration.name), IProgramElement.Kind.FIELD,
 					makeLocation(fieldDeclaration), fieldDeclaration.modifiers, null, null);
-			peNode.setCorrespondingType(fieldDeclaration.type.toString());
+
+			if (fieldDeclaration.type.resolvedType != null) {
+				char[] cs = fieldDeclaration.type.resolvedType.readableName();
+				// fieldDeclaration.type.resolvedType.genericTypeSignature()
+				peNode.setCorrespondingType(new String(cs));
+			} else {
+				// peNode.setCorrespondingType(null);
+				peNode.setCorrespondingType(fieldDeclaration.type.toString());
+			}
 		}
 		peNode.setSourceSignature(genSourceSignature(fieldDeclaration));
 		peNode.setFormalComment(generateJavadocComment(fieldDeclaration));
+		// peNode.setBytecodeSignature(new String(fieldDeclaration.binding.type.signature()));
 
 		((IProgramElement) stack.peek()).addChild(peNode);
 		stack.push(peNode);
@@ -95,7 +95,8 @@ public interface IProgramElement extends Serializable {
 	public String getPackageName();
 
 	/**
-	 * @param method return types or field types
+	 * @param method
+	 *            return types or field types
 	 */
 	public void setCorrespondingType(String returnType);
 
@@ -424,7 +425,8 @@ public interface IProgramElement extends Serializable {
 	public boolean isAnnotationStyleDeclaration();
 
 	/**
-	 * @param fullyQualifiedannotationType the annotation type, eg. p.q.r.Foo
+	 * @param fullyQualifiedannotationType
+	 *            the annotation type, eg. p.q.r.Foo
 	 */
 	public void setAnnotationType(String fullyQualifiedannotationType);
 
@@ -446,4 +448,9 @@ public interface IProgramElement extends Serializable {
 	public void setAnnotationRemover(boolean isRemover);
 
 	public boolean isAnnotationRemover();
+
+	/**
+	 * @return the return type of a method or type of a field in signature form (e.g. Ljava/lang/String;)
+	 */
+	public String getCorrespondingTypeSignature();
 }
\ No newline at end of file
@@ -383,6 +383,108 @@ public class ProgramElement implements IProgramElement {
 		return getCorrespondingType(false);
 	}
 
+	public String getCorrespondingTypeSignature() {
+		String typename = (String) kvpairs.get("returnType");
+		if (typename == null) {
+			return null;
+		}
+		return nameToSignature(typename);
+	}
+
+	public static String nameToSignature(String name) {
+		int len = name.length();
+		if (len < 8) {
+			if (name.equals("byte")) {
+				return "B";
+			}
+			if (name.equals("char")) {
+				return "C";
+			}
+			if (name.equals("double")) {
+				return "D";
+			}
+			if (name.equals("float")) {
+				return "F";
+			}
+			if (name.equals("int")) {
+				return "I";
+			}
+			if (name.equals("long")) {
+				return "J";
+			}
+			if (name.equals("short")) {
+				return "S";
+			}
+			if (name.equals("boolean")) {
+				return "Z";
+			}
+			if (name.equals("void")) {
+				return "V";
+			}
+			if (name.equals("?")) {
+				return name;
+			}
+		}
+		if (name.endsWith("[]")) {
+			return "[" + nameToSignature(name.substring(0, name.length() - 2));
+		}
+		if (len != 0) {
+			// check if someone is calling us with something that is a signature already
+			assert name.charAt(0) != '[';
+
+			if (name.indexOf("<") == -1) {
+				// not parameterized
+				return new StringBuilder("L").append(name.replace('.', '/')).append(';').toString();
+			} else {
+				StringBuffer nameBuff = new StringBuffer();
+				int nestLevel = 0;
+				nameBuff.append("L");
+				for (int i = 0; i < name.length(); i++) {
+					char c = name.charAt(i);
+					switch (c) {
+					case '.':
+						nameBuff.append('/');
+						break;
+					case '<':
+						nameBuff.append("<");
+						nestLevel++;
+						StringBuffer innerBuff = new StringBuffer();
+						while (nestLevel > 0) {
+							c = name.charAt(++i);
+							if (c == '<') {
+								nestLevel++;
+							}
+							if (c == '>') {
+								nestLevel--;
+							}
+							if (c == ',' && nestLevel == 1) {
+								nameBuff.append(nameToSignature(innerBuff.toString()));
+								innerBuff = new StringBuffer();
+							} else {
+								if (nestLevel > 0) {
+									innerBuff.append(c);
+								}
+							}
+						}
+						nameBuff.append(nameToSignature(innerBuff.toString()));
+						nameBuff.append('>');
+						break;
+					case '>':
+						throw new IllegalStateException("Should by matched by <");
+					case ',':
+						throw new IllegalStateException("Should only happen inside <...>");
+					default:
+						nameBuff.append(c);
+					}
+				}
+				nameBuff.append(";");
+				return nameBuff.toString();
+			}
+		} else {
+			throw new IllegalArgumentException("Bad type name: " + name);
+		}
+	}
+
 	public String getCorrespondingType(boolean getFullyQualifiedType) {
 		String returnType = (String) kvpairs.get("returnType");
 		if (returnType == null) {
