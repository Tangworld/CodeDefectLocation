@@ -13,13 +13,17 @@ import java.util.HashSet;
 import java.util.Properties;
 import java.util.Set;
 
+import junit.framework.Assert;
+import junit.framework.TestCase;
+
 import org.aspectj.bridge.AbortException;
 import org.aspectj.bridge.IMessage;
-import org.aspectj.bridge.IMessageHandler;
 import org.aspectj.bridge.IMessage.Kind;
+import org.aspectj.bridge.IMessageHandler;
 import org.aspectj.util.LangUtil;
-
-import junit.framework.TestCase;
+import org.aspectj.weaver.patterns.PatternParser;
+import org.aspectj.weaver.patterns.Pointcut;
+import org.aspectj.weaver.patterns.PointcutRewriter;
 
 /**
  * Test cases for the PointcutParser class
@@ -27,285 +31,353 @@ import junit.framework.TestCase;
 public class PointcutParserTest extends TestCase {
 
 	private boolean needToSkip = false;
-	
+
 	/** this condition can occur on the build machine only, and is way too complex to fix right now... */
 	private boolean needToSkipPointcutParserTests() {
-		if (!LangUtil.is15VMOrGreater()) return false;
+		if (!LangUtil.is15VMOrGreater()) {
+			return false;
+		}
 		try {
-			Class.forName("org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate",false,this.getClass().getClassLoader());//ReflectionBasedReferenceTypeDelegate.class.getClassLoader()); 
+			Class.forName("org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate", false, this.getClass()
+					.getClassLoader());// ReflectionBasedReferenceTypeDelegate.class.getClassLoader());
 		} catch (ClassNotFoundException cnfEx) {
 			return true;
 		}
 		return false;
 	}
-	
+
 	protected void setUp() throws Exception {
 		super.setUp();
 		needToSkip = needToSkipPointcutParserTests();
 	}
-	
+
 	public void testGetAllSupportedPointcutPrimitives() {
-		if (needToSkip) return;
-		
+		if (needToSkip) {
+			return;
+		}
+
 		Set s = PointcutParser.getAllSupportedPointcutPrimitives();
-		assertEquals("Should be 21 elements in the set",21,s.size());
-		assertFalse("Should not contain if pcd",s.contains(PointcutPrimitive.IF));
-		assertFalse("Should not contain cflow pcd",s.contains(PointcutPrimitive.CFLOW));
-		assertFalse("Should not contain cflowbelow pcd",s.contains(PointcutPrimitive.CFLOW_BELOW));
+		assertEquals("Should be 21 elements in the set", 21, s.size());
+		assertFalse("Should not contain if pcd", s.contains(PointcutPrimitive.IF));
+		assertFalse("Should not contain cflow pcd", s.contains(PointcutPrimitive.CFLOW));
+		assertFalse("Should not contain cflowbelow pcd", s.contains(PointcutPrimitive.CFLOW_BELOW));
 	}
-	
+
 	public void testEmptyConstructor() {
-		if (needToSkip) return;
+		if (needToSkip) {
+			return;
+		}
 
-		PointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());
+		PointcutParser parser = PointcutParser
+				.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());
 		Set s = parser.getSupportedPrimitives();
-		assertEquals("Should be 21 elements in the set",21,s.size());
-		assertFalse("Should not contain if pcd",s.contains(PointcutPrimitive.IF));
-		assertFalse("Should not contain cflow pcd",s.contains(PointcutPrimitive.CFLOW));
-		assertFalse("Should not contain cflowbelow pcd",s.contains(PointcutPrimitive.CFLOW_BELOW));
+		assertEquals("Should be 21 elements in the set", 21, s.size());
+		assertFalse("Should not contain if pcd", s.contains(PointcutPrimitive.IF));
+		assertFalse("Should not contain cflow pcd", s.contains(PointcutPrimitive.CFLOW));
+		assertFalse("Should not contain cflowbelow pcd", s.contains(PointcutPrimitive.CFLOW_BELOW));
 	}
-	
+
 	public void testSetConstructor() {
-		if (needToSkip) return;
+		if (needToSkip) {
+			return;
+		}
 
 		Set p = PointcutParser.getAllSupportedPointcutPrimitives();
-		PointcutParser parser = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(p,this.getClass().getClassLoader());
-		assertEquals("Should use the set we pass in",p,parser.getSupportedPrimitives());
+		PointcutParser parser = PointcutParser
+				.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(p, this.getClass()
+						.getClassLoader());
+		assertEquals("Should use the set we pass in", p, parser.getSupportedPrimitives());
 		Set q = new HashSet();
 		q.add(PointcutPrimitive.ARGS);
-		parser = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(q,this.getClass().getClassLoader());
-		assertEquals("Should have only one element in set",1,parser.getSupportedPrimitives().size());
-		assertEquals("Should only have ARGS pcd",PointcutPrimitive.ARGS,
-				parser.getSupportedPrimitives().iterator().next());
+		parser = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(q, this
+				.getClass().getClassLoader());
+		assertEquals("Should have only one element in set", 1, parser.getSupportedPrimitives().size());
+		assertEquals("Should only have ARGS pcd", PointcutPrimitive.ARGS, parser.getSupportedPrimitives().iterator().next());
 	}
-	
+
 	public void testParsePointcutExpression() {
-		if (needToSkip) return;
+		if (needToSkip) {
+			return;
+		}
 
-		PointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());
+		PointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this
+				.getClass().getClassLoader());
 		IMessageHandler current = p.setCustomMessageHandler(new IgnoreWarningsMessageHandler());
-		try {			
-			p.parsePointcutExpression(
-					"(adviceexecution() || execution(* *.*(..)) || handler(Exception) || " +
-					"call(Foo Bar+.*(Goo)) || get(* foo) || set(Foo+ (Goo||Moo).s*) || " +
-					"initialization(Foo.new(..)) || preinitialization(*.new(Foo,..)) || " +
-					"staticinitialization(org.xzy.abc..*)) && (this(Foo) || target(Boo) ||" +
-					"args(A,B,C)) && !handler(X)");
+		try {
+			p.parsePointcutExpression("(adviceexecution() || execution(* *.*(..)) || handler(Exception) || "
+					+ "call(Foo Bar+.*(Goo)) || get(* foo) || set(Foo+ (Goo||Moo).s*) || "
+					+ "initialization(Foo.new(..)) || preinitialization(*.new(Foo,..)) || "
+					+ "staticinitialization(org.xzy.abc..*)) && (this(Foo) || target(Boo) ||" + "args(A,B,C)) && !handler(X)");
 		} finally {
 			p.setCustomMessageHandler(current);
 		}
 		try {
 			p.parsePointcutExpression("gobble-de-gook()");
 			fail("Expected IllegalArgumentException");
-		} catch (IllegalArgumentException ex) {}
+		} catch (IllegalArgumentException ex) {
+		}
 	}
-	
+
 	public void testParseExceptionErrorMessages() {
-		if (needToSkip) return;
+		if (needToSkip) {
+			return;
+		}
 
-		PointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());
+		PointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this
+				.getClass().getClassLoader());
 		try {
 			p.parsePointcutExpression("execution(int Foo.*(..) && args(Double)");
 			fail("Expected IllegalArgumentException");
 		} catch (IllegalArgumentException ex) {
-			assertTrue("Pointcut is not well-formed message",ex.getMessage().startsWith("Pointcut is not well-formed: expecting ')' at character position 24"));
-		}		
+			assertTrue("Pointcut is not well-formed message",
+					ex.getMessage().startsWith("Pointcut is not well-formed: expecting ')' at character position 24"));
+		}
 	}
-	
+
+	public void testOperatorPrecedence_319190() throws Exception {
+		if (needToSkip) {
+			return;
+		}
+
+		String s = null;
+		Pointcut p = null;
+
+		s = "(execution(* A.credit(float)) || execution(* A.debit(float))) && this(acc) && args(am)  || execution(* C.*(Account, float)) && args(acc, am)";
+		p = new PatternParser(s).parsePointcut();
+		Assert.assertEquals(
+				"(((execution(* A.credit(float)) || execution(* A.debit(float))) && (this(acc) && args(am))) || (execution(* C.*(Account, float)) && args(acc, am)))",
+				p.toString());
+
+		s = "(if(true) || if(false)) && this(acc) && args(am)  || if(true) && args(acc, am)";
+		p = new PatternParser(s).parsePointcut();
+		// bugged was: ((if(true) || if(false)) && (this(acc) && (args(am) || (if(true) && args(acc, am)))))
+		Assert.assertEquals("(((if(true) || if(false)) && (this(acc) && args(am))) || (if(true) && args(acc, am)))", p.toString());
+		p = new PointcutRewriter().rewrite(p);
+		Assert.assertEquals("(((this(acc) && args(am)) && if(true)) || (args(acc, am) && if(true)))", p.toString());
+
+		s = "if(true) && if(false) || if(true)";
+		p = new PatternParser(s).parsePointcut();
+		assertEquals("((if(true) && if(false)) || if(true))", p.toString());
+		p = new PointcutRewriter().rewrite(p);
+		Assert.assertEquals("if(true)", p.toString());
+	}
+
 	public void testParseIfPCD() {
-		if (needToSkip) return;
+		if (needToSkip) {
+			return;
+		}
 
-		PointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());
+		PointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this
+				.getClass().getClassLoader());
 		try {
 			p.parsePointcutExpression("if(true)");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("Should not support IF",PointcutPrimitive.IF,ex.getUnsupportedPrimitive());
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("Should not support IF", PointcutPrimitive.IF, ex.getUnsupportedPrimitive());
 		}
 	}
-	
+
 	public void testParseCflowPCDs() {
-		if (needToSkip) return;
+		if (needToSkip) {
+			return;
+		}
 
-		PointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());
+		PointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this
+				.getClass().getClassLoader());
 		try {
 			p.parsePointcutExpression("cflow(this(t))");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("Should not support CFLOW",PointcutPrimitive.CFLOW,ex.getUnsupportedPrimitive());
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("Should not support CFLOW", PointcutPrimitive.CFLOW, ex.getUnsupportedPrimitive());
 		}
 		try {
 			p.parsePointcutExpression("cflowbelow(this(t))");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("Should not support CFLOW_BELOW",PointcutPrimitive.CFLOW_BELOW,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("Should not support CFLOW_BELOW", PointcutPrimitive.CFLOW_BELOW, ex.getUnsupportedPrimitive());
+		}
 	}
-	
+
 	public void testParseReferencePCDs() {
-		if (needToSkip) return;
+		if (needToSkip) {
+			return;
+		}
 
 		Set pcKinds = PointcutParser.getAllSupportedPointcutPrimitives();
 		pcKinds.remove(PointcutPrimitive.REFERENCE);
-		PointcutParser p = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(pcKinds,this.getClass().getClassLoader());
+		PointcutParser p = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(
+				pcKinds, this.getClass().getClassLoader());
 		try {
 			p.parsePointcutExpression("bananas(String)");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
+		} catch (UnsupportedPointcutPrimitiveException ex) {
 			assertTrue(ex.getUnsupportedPrimitive() == PointcutPrimitive.REFERENCE);
-		}	
+		}
 	}
 
 	public void testParseUnsupportedPCDs() {
-		if (needToSkip) return;
+		if (needToSkip) {
+			return;
+		}
 
 		Set s = new HashSet();
-		PointcutParser p = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(s,this.getClass().getClassLoader());
+		PointcutParser p = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(
+				s, this.getClass().getClassLoader());
 		try {
 			p.parsePointcutExpression("args(x)");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("Args",PointcutPrimitive.ARGS,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("Args", PointcutPrimitive.ARGS, ex.getUnsupportedPrimitive());
+		}
 		try {
 			p.parsePointcutExpression("within(x)");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("Within",PointcutPrimitive.WITHIN,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("Within", PointcutPrimitive.WITHIN, ex.getUnsupportedPrimitive());
+		}
 		try {
 			p.parsePointcutExpression("withincode(new(..))");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("Withincode",PointcutPrimitive.WITHIN_CODE,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("Withincode", PointcutPrimitive.WITHIN_CODE, ex.getUnsupportedPrimitive());
+		}
 		try {
 			p.parsePointcutExpression("handler(Exception)");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("handler",PointcutPrimitive.HANDLER,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("handler", PointcutPrimitive.HANDLER, ex.getUnsupportedPrimitive());
+		}
 		try {
 			p.parsePointcutExpression("this(X)");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("this",PointcutPrimitive.THIS,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("this", PointcutPrimitive.THIS, ex.getUnsupportedPrimitive());
+		}
 		try {
 			p.parsePointcutExpression("target(X)");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("target",PointcutPrimitive.TARGET,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("target", PointcutPrimitive.TARGET, ex.getUnsupportedPrimitive());
+		}
 		try {
 			p.parsePointcutExpression("this(X) && target(Y)");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("This",PointcutPrimitive.THIS,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("This", PointcutPrimitive.THIS, ex.getUnsupportedPrimitive());
+		}
 		try {
 			p.parsePointcutExpression("this(X) || target(Y)");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("This",PointcutPrimitive.THIS,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("This", PointcutPrimitive.THIS, ex.getUnsupportedPrimitive());
+		}
 		try {
 			p.parsePointcutExpression("!this(X)");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("This",PointcutPrimitive.THIS,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("This", PointcutPrimitive.THIS, ex.getUnsupportedPrimitive());
+		}
 		try {
 			p.parsePointcutExpression("call(* *.*(..))");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("Call",PointcutPrimitive.CALL,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("Call", PointcutPrimitive.CALL, ex.getUnsupportedPrimitive());
+		}
 		try {
 			p.parsePointcutExpression("execution(* *.*(..))");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("Execution",PointcutPrimitive.EXECUTION,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("Execution", PointcutPrimitive.EXECUTION, ex.getUnsupportedPrimitive());
+		}
 		try {
 			p.parsePointcutExpression("get(* *)");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("Get",PointcutPrimitive.GET,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("Get", PointcutPrimitive.GET, ex.getUnsupportedPrimitive());
+		}
 		try {
 			p.parsePointcutExpression("set(* *)");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("Set",PointcutPrimitive.SET,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("Set", PointcutPrimitive.SET, ex.getUnsupportedPrimitive());
+		}
 		try {
 			p.parsePointcutExpression("initialization(new(..))");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("Initialization",PointcutPrimitive.INITIALIZATION,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("Initialization", PointcutPrimitive.INITIALIZATION, ex.getUnsupportedPrimitive());
+		}
 		try {
 			p.parsePointcutExpression("preinitialization(new(..))");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("Prc-init",PointcutPrimitive.PRE_INITIALIZATION,ex.getUnsupportedPrimitive());
-		}	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("Prc-init", PointcutPrimitive.PRE_INITIALIZATION, ex.getUnsupportedPrimitive());
+		}
 		try {
 			p.parsePointcutExpression("staticinitialization(T)");
 			fail("Expected UnsupportedPointcutPrimitiveException");
-		} catch(UnsupportedPointcutPrimitiveException ex) {
-			assertEquals("Staticinit",PointcutPrimitive.STATIC_INITIALIZATION,ex.getUnsupportedPrimitive());
-		}	
-	}	
-	
+		} catch (UnsupportedPointcutPrimitiveException ex) {
+			assertEquals("Staticinit", PointcutPrimitive.STATIC_INITIALIZATION, ex.getUnsupportedPrimitive());
+		}
+	}
+
 	public void testFormals() {
-		if (needToSkip) return;
+		if (needToSkip) {
+			return;
+		}
+
+		PointcutParser parser = PointcutParser
+				.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());
+		PointcutParameter param = parser.createPointcutParameter("x", String.class);
+		PointcutExpression pc = parser.parsePointcutExpression("args(x)", null, new PointcutParameter[] { param });
+		assertEquals("args(x)", pc.getPointcutExpression());
 
-		PointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());
-		PointcutParameter param = parser.createPointcutParameter("x",String.class);
-		PointcutExpression pc = parser.parsePointcutExpression("args(x)", null, new PointcutParameter[] {param} );
-		assertEquals("args(x)",pc.getPointcutExpression());
-		
 		try {
-			pc = parser.parsePointcutExpression("args(String)", null, new PointcutParameter[] {param} );
+			pc = parser.parsePointcutExpression("args(String)", null, new PointcutParameter[] { param });
 			fail("Expecting IllegalArgumentException");
 		} catch (IllegalArgumentException ex) {
-			assertTrue("formal unbound",ex.getMessage().indexOf("formal unbound") != -1);
+			assertTrue("formal unbound", ex.getMessage().indexOf("formal unbound") != -1);
 		}
-		
+
 		try {
 			pc = parser.parsePointcutExpression("args(y)");
 			fail("Expecting IllegalArgumentException");
-		} catch(IllegalArgumentException ex) {
-			assertTrue("no match for type name",ex.getMessage().indexOf("warning no match for this type name: y") != -1);
+		} catch (IllegalArgumentException ex) {
+			assertTrue("no match for type name", ex.getMessage().indexOf("warning no match for this type name: y") != -1);
 		}
 	}
-	
+
 	public void testXLintConfiguration() {
-		if (needToSkip) return;
+		if (needToSkip) {
+			return;
+		}
 
-		PointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());
+		PointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this
+				.getClass().getClassLoader());
 		try {
 			p.parsePointcutExpression("this(FooBar)");
-		} catch(IllegalArgumentException ex) {
-			assertTrue("should have xlint:invalidAbsoluteTypeName",ex.getMessage().indexOf("Xlint:invalidAbsoluteTypeName") != -1);
+		} catch (IllegalArgumentException ex) {
+			assertTrue("should have xlint:invalidAbsoluteTypeName", ex.getMessage().indexOf("Xlint:invalidAbsoluteTypeName") != -1);
 		}
 		Properties props = new Properties();
-		props.put("invalidAbsoluteTypeName","ignore");
+		props.put("invalidAbsoluteTypeName", "ignore");
 		p.setLintProperties(props);
 		p.parsePointcutExpression("this(FooBar)");
 	}
-	
+
 	private static class IgnoreWarningsMessageHandler implements IMessageHandler {
 
 		public boolean handleMessage(IMessage message) throws AbortException {
-			if (message.getKind() != IMessage.WARNING) throw new RuntimeException("unexpected message: " + message.toString());
+			if (message.getKind() != IMessage.WARNING) {
+				throw new RuntimeException("unexpected message: " + message.toString());
+			}
 			return true;
 		}
 
 		public boolean isIgnoring(Kind kind) {
-			if (kind != IMessage.ERROR) return true;
+			if (kind != IMessage.ERROR) {
+				return true;
+			}
 			return false;
 		}
 
@@ -314,6 +386,6 @@ public class PointcutParserTest extends TestCase {
 
 		public void ignore(Kind kind) {
 		}
-		
+
 	}
 }
@@ -1,6 +1,5 @@
 /* *******************************************************************
- * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
- *               2005 Contributors
+ * Copyright (c) 2002,2010
  * All rights reserved. 
  * This program and the accompanying materials are made available 
  * under the terms of the Eclipse Public License v1.0 
@@ -9,7 +8,8 @@
  *  
  * Contributors: 
  *     PARC     initial implementation
- *     Adrian Colyer many updates since.... 
+ *     Adrian Colyer, IBM
+ *     Andy Clement, IBM, SpringSource
  * ******************************************************************/
 
 package org.aspectj.weaver.patterns;
@@ -31,7 +31,12 @@ import org.aspectj.weaver.internal.tools.PointcutDesignatorHandlerBasedPointcut;
 import org.aspectj.weaver.tools.ContextBasedMatcher;
 import org.aspectj.weaver.tools.PointcutDesignatorHandler;
 
-//XXX doesn't handle errors for extra tokens very well (sometimes ignores)
+/**
+ * @author PARC
+ * @author Adrian Colyer
+ * @author Andy Clement
+ */
+// XXX doesn't handle errors for extra tokens very well (sometimes ignores)
 public class PatternParser {
 
 	private ITokenSource tokenSource;
@@ -140,8 +145,8 @@ public class PatternParser {
 			ret = parseSoft();
 		} else {
 			throw new ParserException(
-					"expected one of error, warning, parents, soft, precedence, @type, @method, @constructor, @field", tokenSource
-							.peek(-1));
+					"expected one of error, warning, parents, soft, precedence, @type, @method, @constructor, @field",
+					tokenSource.peek(-1));
 		}
 		int endPos = tokenSource.peek(-1).getEnd();
 		ret.setLocation(sourceContext, startPos, endPos);
@@ -326,7 +331,7 @@ public class PatternParser {
 	private Pointcut parseNotOrPointcut() {
 		Pointcut p = parseAtomicPointcut();
 		if (maybeEat("&&")) {
-			p = new AndPointcut(p, parsePointcut());
+			p = new AndPointcut(p, parseNotOrPointcut());
 		}
 		return p;
 	}
@@ -1108,7 +1113,7 @@ public class PatternParser {
 	// if (maybeEat("&&")) {
 	// ap = new AndAnnotationTypePattern(ap, parseNotOrAnnotationPattern());
 	// }
-	//		
+	//
 	// if (maybeEat("||")) {
 	// ap = new OrAnnotationTypePattern(ap, parseAnnotationTypePattern());
 	// }
@@ -28,6 +28,7 @@ import org.aspectj.weaver.PoliceExtensionUse;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.Shadow;
 import org.aspectj.weaver.ShadowMunger;
+import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.VersionedDataInputStream;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.ast.Literal;
@@ -411,7 +412,7 @@ public abstract class Pointcut extends PatternNode {
 		}
 
 		@Override
-		public Pointcut parameterizeWith(Map typeVariableMap, World w) {
+		public Pointcut parameterizeWith(Map<String, UnresolvedType> typeVariableMap, World w) {
 			return this;
 		}
 	}
@@ -430,6 +431,6 @@ public abstract class Pointcut extends PatternNode {
 		}
 	}
 
-	public abstract Pointcut parameterizeWith(Map typeVariableMap, World w);
+	public abstract Pointcut parameterizeWith(Map<String, UnresolvedType> typeVariableMap, World w);
 
 }
@@ -37,7 +37,6 @@ import org.aspectj.weaver.ast.Test;
 
 /**
  */
-
 // XXX needs check that arguments contains no WildTypePatterns
 public class ReferencePointcut extends Pointcut {
 	public UnresolvedType onType;
@@ -48,7 +47,7 @@ public class ReferencePointcut extends Pointcut {
 	/**
 	 * if this is non-null then when the pointcut is concretized the result will be parameterized too.
 	 */
-	private Map typeVariableMap;
+	private Map<String, UnresolvedType> typeVariableMap;
 
 	// public ResolvedPointcut binding;
 
@@ -198,7 +197,7 @@ public class ReferencePointcut extends Pointcut {
 			if (onType.isParameterizedType()) {
 				// build a type map mapping type variable names in the generic type to
 				// the type parameters presented
-				typeVariableMap = new HashMap();
+				typeVariableMap = new HashMap<String, UnresolvedType>();
 				ResolvedType underlyingGenericType = ((ResolvedType) onType).getGenericType();
 				TypeVariable[] tVars = underlyingGenericType.getTypeVariables();
 				ResolvedType[] typeParams = ((ResolvedType) onType).getResolvedTypeParameters();
@@ -256,8 +255,11 @@ public class ReferencePointcut extends Pointcut {
 	public Pointcut concretize1(ResolvedType searchStart, ResolvedType declaringType, IntMap bindings) {
 		if (concretizing) {
 			// Thread.currentThread().dumpStack();
-			searchStart.getWorld().getMessageHandler().handleMessage(
-					MessageUtil.error(WeaverMessages.format(WeaverMessages.CIRCULAR_POINTCUT, this), getSourceLocation()));
+			searchStart
+					.getWorld()
+					.getMessageHandler()
+					.handleMessage(
+							MessageUtil.error(WeaverMessages.format(WeaverMessages.CIRCULAR_POINTCUT, this), getSourceLocation()));
 			Pointcut p = Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
 			p.sourceContext = sourceContext;
 			return p;
@@ -300,10 +302,13 @@ public class ReferencePointcut extends Pointcut {
 			if (!foundMatchingPointcut) {
 				pointcutDec = searchStart.findPointcut(name);
 				if (pointcutDec == null) {
-					searchStart.getWorld().getMessageHandler().handleMessage(
-							MessageUtil.error(
-									WeaverMessages.format(WeaverMessages.CANT_FIND_POINTCUT, name, searchStart.getName()),
-									getSourceLocation()));
+					searchStart
+							.getWorld()
+							.getMessageHandler()
+							.handleMessage(
+									MessageUtil.error(
+											WeaverMessages.format(WeaverMessages.CANT_FIND_POINTCUT, name, searchStart.getName()),
+											getSourceLocation()));
 					return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
 				}
 			}
@@ -339,7 +344,7 @@ public class ReferencePointcut extends Pointcut {
 			if (searchStart.isParameterizedType()) {
 				// build a type map mapping type variable names in the generic type to
 				// the type parameters presented
-				typeVariableMap = new HashMap();
+				typeVariableMap = new HashMap<String, UnresolvedType>();
 				ResolvedType underlyingGenericType = searchStart.getGenericType();
 				TypeVariable[] tVars = underlyingGenericType.getTypeVariables();
 				ResolvedType[] typeParams = searchStart.getResolvedTypeParameters();
@@ -371,7 +376,7 @@ public class ReferencePointcut extends Pointcut {
 	 * do this at the point in time this method will be called, so we make a version that will parameterize the pointcut it
 	 * ultimately resolves to.
 	 */
-	public Pointcut parameterizeWith(Map typeVariableMap, World w) {
+	public Pointcut parameterizeWith(Map<String, UnresolvedType> typeVariableMap, World w) {
 		ReferencePointcut ret = new ReferencePointcut(onType, name, arguments);
 		ret.onTypeSymbolic = onTypeSymbolic;
 		ret.typeVariableMap = typeVariableMap;
