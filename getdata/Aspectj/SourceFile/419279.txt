@@ -23,6 +23,7 @@ import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.StringTokenizer;
 
 import org.aspectj.ajdt.internal.compiler.CompilationResultDestinationManager;
 import org.aspectj.util.FileUtil;
@@ -59,6 +60,7 @@ public class AjBuildConfig implements CompilerConfigurationChangeFlags {
 
 	private File configFile;
 	private String lintMode = AJLINT_DEFAULT;
+	private Map<String,String> lintOptionsMap = null;
 	private File lintSpecFile = null;
 
 	private int changes = EVERYTHING; // bitflags, see CompilerConfigurationChangeFlags
@@ -443,35 +445,71 @@ public class AjBuildConfig implements CompilerConfigurationChangeFlags {
 	public String getLintMode() {
 		return lintMode;
 	}
+	
+	public Map<String,String> getLintOptionsMap() {
+		return lintOptionsMap;
+	}
 
 	// options...
 
 	public void setLintMode(String lintMode) {
-		this.lintMode = lintMode;
 		String lintValue = null;
+		this.lintMode = lintMode;
 		if (AJLINT_IGNORE.equals(lintMode)) {
 			lintValue = AjCompilerOptions.IGNORE;
 		} else if (AJLINT_WARN.equals(lintMode)) {
 			lintValue = AjCompilerOptions.WARNING;
 		} else if (AJLINT_ERROR.equals(lintMode)) {
 			lintValue = AjCompilerOptions.ERROR;
+		} else {
+			// Possibly a name=value comma separated list of configurations
+			if (lintMode.indexOf("=")!=-1) {
+				this.lintMode = AJLINT_DEFAULT;
+				lintOptionsMap = new HashMap<String,String>();
+				StringTokenizer tokenizer = new StringTokenizer(lintMode,",");
+				while (tokenizer.hasMoreElements()) {
+					String option = tokenizer.nextToken();
+					int equals = option.indexOf("=");
+					if (equals!=-1) {
+						String key = option.substring(0,equals);
+						String value = option.substring(equals+1);
+						lintOptionsMap.put(key,value);
+					}
+				}
+			}
 		}
 
-		if (lintValue != null) {
+		if (lintValue != null || lintOptionsMap != null ) {
 			Map<String, String> lintOptions = new HashMap<String, String>();
-			lintOptions.put(AjCompilerOptions.OPTION_ReportInvalidAbsoluteTypeName, lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportInvalidWildcardTypeName, lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportUnresolvableMember, lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportTypeNotExposedToWeaver, lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportShadowNotInStructure, lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportUnmatchedSuperTypeInCall, lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportCannotImplementLazyTJP, lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportNeedSerialVersionUIDField, lintValue);
-			lintOptions.put(AjCompilerOptions.OPTION_ReportIncompatibleSerialVersion, lintValue);
+			setOption(AjCompilerOptions.OPTION_ReportInvalidAbsoluteTypeName, lintValue, lintOptions);
+			setOption(AjCompilerOptions.OPTION_ReportInvalidWildcardTypeName, lintValue, lintOptions);
+			setOption(AjCompilerOptions.OPTION_ReportUnresolvableMember, lintValue, lintOptions);
+			setOption(AjCompilerOptions.OPTION_ReportTypeNotExposedToWeaver, lintValue, lintOptions);
+			setOption(AjCompilerOptions.OPTION_ReportShadowNotInStructure, lintValue, lintOptions);
+			setOption(AjCompilerOptions.OPTION_ReportUnmatchedSuperTypeInCall, lintValue, lintOptions);
+			setOption(AjCompilerOptions.OPTION_ReportCannotImplementLazyTJP, lintValue, lintOptions);
+			setOption(AjCompilerOptions.OPTION_ReportNeedSerialVersionUIDField, lintValue, lintOptions);
+			setOption(AjCompilerOptions.OPTION_ReportIncompatibleSerialVersion, lintValue, lintOptions);
 			options.set(lintOptions);
 		}
 	}
 
+	private void setOption(String optionKey, String lintValue, Map<String,String> lintOptionsAccumulator) {
+		if (lintOptionsMap!=null && lintOptionsMap.containsKey(optionKey)) {
+			String v = lintOptionsMap.get(lintOptionsMap);
+			if (AJLINT_IGNORE.equals(v)) {
+				lintValue = AjCompilerOptions.IGNORE;
+			} else if (AJLINT_WARN.equals(v)) {
+				lintValue = AjCompilerOptions.WARNING;
+			} else if (AJLINT_ERROR.equals(v)) {
+				lintValue = AjCompilerOptions.ERROR;
+			}
+		}
+		if (lintValue != null) {
+			lintOptionsAccumulator.put(optionKey,lintValue);
+		}
+	}
+
 	public boolean isTerminateAfterCompilation() {
 		return options.terminateAfterCompilation;
 	}
@@ -858,6 +858,9 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 		} else {
 			bcelWorld.getLint().setAll(buildConfig.getLintMode());
 		}
+		if (buildConfig.getLintOptionsMap() != null) {
+			bcelWorld.getLint().setFromMap(buildConfig.getLintOptionsMap());
+		}
 		if (buildConfig.getLintSpecFile() != null) {
 			bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
 		}
@@ -166,6 +166,18 @@ public class Lint {
 			kind.setKind(messageKind);
 		}
 	}
+	
+	public void setFromMap(Map<String,String> lintOptionsMap) {
+		for (String key: lintOptionsMap.keySet()) {
+			String value = lintOptionsMap.get(key);
+			Kind kind = kinds.get(key);
+			if (kind == null) {
+				MessageUtil.error(world.getMessageHandler(), WeaverMessages.format(WeaverMessages.XLINT_KEY_ERROR, key));
+			} else {
+				kind.setKind(getMessageKind(value));
+			}
+		}
+	}
 
 	public void setFromProperties(File file) {
 		if (trace.isTraceEnabled()) {
@@ -234,7 +234,8 @@ public class CompileSpec implements ITestStep {
 		if (getOptions() != null) {
 			StringTokenizer strTok = new StringTokenizer(getOptions(),",");
 			while (strTok.hasMoreTokens()) {
-				args.append(strTok.nextToken());
+				// For an option containing a comma, pass in a { in its place
+				args.append(strTok.nextToken().replace('{', ','));
 				args.append(" ");
 			}
 		}
@@ -0,0 +1,10 @@
+public aspect Code {
+  before(): execution(* *(String)) { }
+  before(): call(* someMethod(..)) {
+		System.out.println(thisJoinPoint);
+  }
+  public void foo() {
+    someMethod();
+  }
+  public void someMethod(){}
+}
@@ -21,6 +21,10 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
  */
 public class Ajc174Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testMoreConfigurableLint_419279() throws Exception {
+		runTest("more configurable lint");
+	}
+	
 	public void testAnnotatedItd_418129() throws Exception {
 		runTest("annotated itd");
 	}
@@ -2,6 +2,30 @@
 
 <suite>
 
+	<ajc-test dir="bugs174/pr419279" title="more configurable lint">
+		<compile files="Code.java" options="-1.5">
+			<message kind="warning" text="advice defined in Code has not been applied [Xlint:adviceDidNotMatch]"/>
+		</compile>
+		<compile files="Code.java" options="-1.5 -Xlint:adviceDidNotMatch=ignore">
+		</compile>
+		<compile files="Code.java" options="-1.5 -Xlint:adviceDidNotMatch=error">
+			<message kind="error" text="advice defined in Code has not been applied [Xlint:adviceDidNotMatch]"/>
+		</compile>
+		<compile files="Code.java" options="-1.5 -Xlint:foo=bar">
+			<message kind="error" text="invalid Xlint key: foo"/>
+		</compile>
+		<compile files="Code.java" options="-1.5 -Xlint:adviceDidNotMatch=wibble">
+			<message kind="error" text="invalid Xlint message kind (must be one of ignore, warning, error): wibble"/>
+		</compile>
+		<compile files="Code.java" options="-1.5 -Xlint:adviceDidNotMatch=ignore{adviceDidNotMatch=error">
+			<message kind="error" text="advice defined in Code has not been applied [Xlint:adviceDidNotMatch]"/>
+		</compile>
+		<compile files="Code.java" options="-1.5 -Xlint:adviceDidNotMatch=error{noGuardForLazyTjp=error">
+			<message kind="error" text="advice defined in Code has not been applied [Xlint:adviceDidNotMatch]"/>
+			<message kind="error" text="can not build thisJoinPoint lazily for this advice since it has no suitable guard [Xlint:noGuardForLazyTjp]"/>
+		</compile>
+	</ajc-test>
+
 	<ajc-test dir="bugs174/pr418129" title="annotated itd">
 		<compile files="Target.java" options="-1.5 -showWeaveInfo">
 			<message kind="weave" text="Type 'Behavior' (Target.java) has intertyped method from 'Trait' (Target.java:'java.lang.String Behavior.hello()')"/>
