@@ -273,7 +273,17 @@ public class EclipseFactory {
 				// pr168044 - sometimes (whilst resolving types) we are working with 'half finished' types and so (for example) the
 				// underlying generic type for a raw type hasnt been set yet
 				// if (!baseType.isGenericType() && arguments!=null) baseType = baseType.getGenericType();
-				baseTypeSignature = baseType.getErasureSignature();
+// pr384398 - secondary testcase in 1.7.1 tests - this needs work as this code
+// currently discards the parameterization on the outer type, which is important info
+//				ReferenceBinding enclosingTypeBinding = ptb.enclosingType();
+//				if (enclosingTypeBinding!=null) {
+//					UnresolvedType ttt = fromBinding(enclosingTypeBinding);
+//					baseTypeSignature = ttt.getSignature();
+//					baseTypeSignature= baseTypeSignature.substring(0,baseTypeSignature.length()-1);
+//					baseTypeSignature = baseTypeSignature + "."+new String(ptb.sourceName)+";";
+//				} else {			
+					baseTypeSignature = baseType.getErasureSignature();
+//				}
 			} else {
 				baseTypeSignature = UnresolvedType.forName(getName(binding)).getSignature();
 			}
@@ -283,6 +293,10 @@ public class EclipseFactory {
 			// be type variables that we haven't fixed up yet.
 			if (arguments == null) {
 				arguments = new UnresolvedType[0];
+				// for pr384398
+				if (!hasAnyArguments(ptb)) {
+					return UnresolvedType.forRawTypeName(getName(binding));
+				}
 			}
 			// StringBuffer parameterizedSig = new StringBuffer();
 			// parameterizedSig.append(ResolvedType.PARAMETERIZED_TYPE_IDENTIFIER);
@@ -331,6 +345,21 @@ public class EclipseFactory {
 	}
 
 	/**
+	 * Search up a parameterized type binding for any arguments at any level.
+	 */
+	private boolean hasAnyArguments(ParameterizedTypeBinding ptb) {
+		if (ptb.arguments!=null && ptb.arguments.length>0) {
+			return true;
+		}
+		ReferenceBinding enclosingType = ptb.enclosingType();
+		if (enclosingType instanceof ParameterizedTypeBinding) {
+			return hasAnyArguments((ParameterizedTypeBinding)enclosingType);
+		} else {
+			return false;
+		}
+	}
+
+	/**
 	 * Some type variables refer to themselves recursively, this enables us to avoid recursion problems.
 	 */
 	private static Map typeVariableBindingsInProgress = new HashMap();
@@ -0,0 +1,9 @@
+package de.example;
+
+public class A<T> {
+	public static class InnerA{
+		
+	}
+	
+
+}
@@ -0,0 +1,13 @@
+package de.example;
+
+public class B extends A<String> {
+/*
+	InnerA someMethod(){
+		return new InnerA();
+	}
+
+	InnerA someOtherMethod(){
+		return someMethod();
+	}
+*/
+}
@@ -0,0 +1,15 @@
+package de.example;
+
+import de.example.A.InnerA;
+
+public aspect BAspect {
+
+	InnerA B.someMethod(){
+		return new InnerA();
+	}
+
+	InnerA B.someOtherMethod(){
+		return someMethod();
+	}
+
+}
@@ -0,0 +1,9 @@
+package de.example;
+
+public class A<T> {
+	public class InnerA {
+      T aaa;
+	}
+	
+
+}
@@ -0,0 +1,14 @@
+package de.example;
+
+public class B extends A<String> {
+/*
+    InnerA someMethod(){
+        A<String> as = new A<String>();
+        return as.new InnerA();
+    }
+
+    InnerA someOtherMethod() {
+        return someMethod();
+    }
+*/
+}
@@ -0,0 +1,16 @@
+package de.example;
+
+import de.example.A.InnerA;
+
+public aspect BAspect {
+
+	InnerA B.someMethod(){
+		A<String> as = new A<String>();
+		return as.new InnerA();
+	}
+
+	InnerA B.someOtherMethod(){
+		return someMethod();
+	}
+
+}
@@ -7,12 +7,14 @@ import junit.framework.Test;
 import junit.framework.TestSuite;
 
 import org.aspectj.systemtest.ajc170.AllTestsAspectJ170;
+import org.aspectj.systemtest.ajc171.AllTestsAspectJ171;
 
 public class AllTests17 {
 
 	public static Test suite() {
 		TestSuite suite = new TestSuite("AspectJ System Test Suite - JDK 1.7");
 		// $JUnit-BEGIN$
+		suite.addTest(AllTestsAspectJ171.suite());
 		suite.addTest(AllTestsAspectJ170.suite());
 		suite.addTest(AllTests16.suite());
 		suite.addTest(AllTests15.suite());
@@ -0,0 +1,43 @@
+/*******************************************************************************
+ * Copyright (c) 2012 Contributors
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *    Andy Clement - initial API and implementation
+ *******************************************************************************/
+package org.aspectj.systemtest.ajc171;
+
+import java.io.File;
+
+import junit.framework.Test;
+
+import org.aspectj.testing.XMLBasedAjcTestCase;
+
+/**
+ * @author Andy Clement
+ */ 
+public class Ajc171Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
+
+	public void testGenerics_384398() {
+		runTest("generics itds");
+	}
+	
+//	public void testGenerics_384398_2() {
+//		runTest("generics itds 2");
+//	}
+
+	// ---
+
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(Ajc171Tests.class);
+	}
+
+	@Override
+	protected File getSpecFile() {
+		return new File("../tests/src/org/aspectj/systemtest/ajc171/ajc171.xml");
+	}
+
+}
@@ -0,0 +1,25 @@
+/*******************************************************************************
+ * Copyright (c) 2008 Contributors
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *    Andy Clement - initial API and implementation
+ *******************************************************************************/
+package org.aspectj.systemtest.ajc171;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+
+public class AllTestsAspectJ171 {
+
+	public static Test suite() {
+		TestSuite suite = new TestSuite("AspectJ 1.7.1 tests");
+		// $JUnit-BEGIN$
+		suite.addTest(Ajc171Tests.suite());
+		// $JUnit-END$
+		return suite;
+	}
+}
@@ -0,0 +1,37 @@
+<!DOCTYPE suite SYSTEM "../tests/ajcTestSuite.dtd"[]>
+
+<suite>
+	
+	<ajc-test dir="bugs171/pr384398" title="generics itds">
+		<compile files="A.java B.java BAspect.aj" options="-1.5">
+		<!-- 
+			<message kind="weave" text="Join point 'constructor-call(void java.util.LinkedList.&lt;init&gt;())' in Type 'Foo' (Foo.java:41) advised by around advice from 'Bar' (Foo.java:14)"/>
+		-->
+		</compile>
+		<!-- 
+		<run class="Foo">
+			<stdout>
+				<line text="superaspect getNumber returns -2"/>
+				<line text="Bar.method() running"/>
+				<line text="abstract method returns []"/>
+			</stdout>
+		</run> -->
+	</ajc-test>
+	
+	<ajc-test dir="bugs171/pr384398_2" title="generics itds 2">
+		<compile files="A.java B.java BAspect.aj" options="-1.5">
+		<!-- 
+			<message kind="weave" text="Join point 'constructor-call(void java.util.LinkedList.&lt;init&gt;())' in Type 'Foo' (Foo.java:41) advised by around advice from 'Bar' (Foo.java:14)"/>
+		-->
+		</compile>
+		<!-- 
+		<run class="Foo">
+			<stdout>
+				<line text="superaspect getNumber returns -2"/>
+				<line text="Bar.method() running"/>
+				<line text="abstract method returns []"/>
+			</stdout>
+		</run> -->
+	</ajc-test>
+   
+</suite>
