@@ -0,0 +1,4 @@
+
+public aspect Aspy {
+	before(): call(* *(..)) {	}
+}
@@ -0,0 +1,3 @@
+public abstract class Middle<E> extends Top<E> {
+    class IteratorImpl extends TopInner { }
+}
@@ -0,0 +1,5 @@
+public class Top<K> {
+	class TopInner {
+        public void hhh() { }		
+	}
+}
@@ -0,0 +1,6 @@
+public abstract class Zzz<E> extends Middle<E> {
+    void removeAll() {  
+        IteratorImpl it = new IteratorImpl();
+        it.hhh();
+    }
+}
@@ -29,6 +29,10 @@ public class Ajc169Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	// public void testAdvisingPrivilegedAccessMethod_307147() {
 	// runTest("advising privileged access method");
 	// }
+	
+	public void testSubtleGenericsIssue_308773() {
+		runTest("subtle generics problem");
+	}
 
 	public void testAdvisingPrivilegedAccessMember_307120() {
 		runTest("advising privileged access member");
@@ -2,6 +2,10 @@
 
 <suite>
 
+   <ajc-test dir="bugs169/pr308773" title="subtle generics problem">
+     <compile files="Aspy.aj Zzz.java Top.java Middle.java" options="-1.5"/>
+  </ajc-test>
+  
    <ajc-test dir="bugs169/pr307147" title="advising privileged access method">
      <compile files="B.java Test2.java" options="-showWeaveInfo">
        <message kind="weave" text="Type 'B' (B.java) has intertyped method from 'Test'"/>
@@ -671,8 +671,13 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 	 */
 	public ResolvedMemberImpl parameterizedWith(UnresolvedType[] typeParameters, ResolvedType newDeclaringType,
 			boolean isParameterized, List aliases) {
+		// PR308773
+		// this check had problems for the inner type of a generic type because the inner type can be represented
+		// by a 'simple type' if it is only sharing type variables with the outer and has none of its own.  To avoid the
+		// check going bang in this case we check for $ (crap...) - we can't check the outer because the declaring type
+		// is considered unresolved...		
 		if (// isParameterized && <-- might need this bit...
-		!getDeclaringType().isGenericType()) {
+		!getDeclaringType().isGenericType()  && getDeclaringType().getName().indexOf("$")==-1) {
 			throw new IllegalStateException("Can't ask to parameterize a member of non-generic type: " + getDeclaringType()
 					+ "  kind(" + getDeclaringType().typeKind + ")");
 		}
