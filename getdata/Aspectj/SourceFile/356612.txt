@@ -0,0 +1,68 @@
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+import org.aspectj.lang.reflect.FieldSignature;
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Marker {
+	String message();
+}
+
+public class AnnoBinding {
+	public static void main(String[] argv) {
+		long stime = System.currentTimeMillis();
+		for (int i = 0; i < 10000; i++) {
+			runOne();
+		}
+		long etime = System.currentTimeMillis();
+		long manual = (etime - stime);
+		stime = System.currentTimeMillis();
+		for (int i = 0; i < 10000; i++) {
+			runTwo();
+		}
+		etime = System.currentTimeMillis();
+		long woven = (etime - stime);
+		System.out.println("woven=" + woven + " manual=" + manual);
+		if (woven > manual) {
+			throw new RuntimeException("woven=" + woven + " manual=" + manual);
+		}
+		if (X.a != X.b) {
+			throw new RuntimeException("a=" + X.a + " b=" + X.b);
+		}
+	}
+
+	@Marker(message = "string")
+	static int field1;
+
+	@Marker(message = "string")
+	static int field2;
+
+	public static void runOne() {
+		field1 = field1 * 2; // set and get jps
+	}
+
+	public static void runTwo() {
+		field1 = field1 * 2; // set and get jps
+	}
+
+}
+
+aspect X {
+	  pointcut pManual(): withincode(* runOne(..)) && get(@Marker * *);
+	  pointcut pWoven(Marker l): withincode(* runTwo(..)) && get(@Marker * * ) && @annotation(l);
+
+	   public static int a,b;
+
+	   before(): pManual() {
+	     Marker marker = (Marker) ((FieldSignature) thisJoinPointStaticPart.getSignature()).getField().getAnnotation(Marker.class);
+	     String s = marker.message();
+	     a+=s.length();
+	   }
+
+	   before(Marker l): pWoven(l) {
+	     String s = l.message();
+	     b+=s.length();
+	   }
+
+
+}
@@ -0,0 +1,48 @@
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+import org.aspectj.lang.reflect.FieldSignature;
+
+import com.sun.org.apache.bcel.internal.classfile.Field;
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Marker {
+	String message();
+}
+
+public class AnnoBinding2 {
+	public static void main(String[] argv) {
+		runOne();
+		runTwo();
+		java.lang.reflect.Field[] fs = AnnoBinding2.class.getDeclaredFields();
+		int count = 0;
+		for (java.lang.reflect.Field f: fs) {
+			if (f.getName().startsWith("ajc$anno")) {
+				count++;
+			}
+		}
+		System.out.println(count+" ajc$anno$NNN fields");
+	}
+
+	@Marker(message = "foo")
+	static int field1;
+
+	@Marker(message = "bar")
+	static int field2;
+
+	public static void runOne() {
+		field1 = field1 * 2; // set and get jps
+	}
+
+	public static void runTwo() {
+		field2 = field2 * 2; // set and get jps
+	}
+}
+
+aspect X {
+	pointcut pWoven(Marker l): withincode(* run*(..)) && get(@Marker * * ) && @annotation(l);
+
+	before(Marker l): pWoven(l) {
+	    System.out.println(thisJoinPointStaticPart+" "+l);
+	}
+}
@@ -35,6 +35,14 @@ public class Ajc1612Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	// runTest("itd split compilation");
 	// }
 
+	public void testAnnotationFieldBindingOptimization_356612() throws Exception {
+		runTest("annotation field binding optimization");
+	}
+
+	public void testAnnotationFieldBindingOptimization_356612_2() throws Exception {
+		runTest("annotation field binding optimization - 2");
+	}
+
 	public void testThisAspectInstance_239649_1() throws Exception {
 		// simple case
 		runTest("thisAspectInstance - 1");
@@ -2,6 +2,24 @@
 
 <suite>
 
+<ajc-test dir="bugs1612/pr356612" title="annotation field binding optimization">
+<compile files="AnnoBinding.java" options="-1.5"/>
+<run class="AnnoBinding">
+</run>
+</ajc-test>
+
+
+<ajc-test dir="bugs1612/pr356612" title="annotation field binding optimization - 2">
+<compile files="AnnoBinding2.java" options="-1.5"/>
+<run class="AnnoBinding2">
+<stdout>
+<line text="get(int AnnoBinding2.field1) @Marker(message=foo)"/>
+<line text="get(int AnnoBinding2.field2) @Marker(message=bar)"/>
+<line text="2 ajc$anno$NNN fields"/>
+</stdout>
+</run>
+</ajc-test>
+
 <ajc-test dir="bugs1612/pr354683" title="itd split compilation">
 <compile files="util/CommonData.java util/CommonDataImpl.java util/CommonDataImplementation.aj util/DerivedCommonDataInterface.java util/DerivedCommonDataInterfaceImpl.java util/DerivedCommonDataInterfaceImplementation.aj" options="-1.5" outjar="code.jar"/>
 <compile files="main/AbstractBaseClass.java main/DerivedClass.java main/Whatever.java " options="-1.5" aspectpath="code.jar"/>
Binary files differ
Binary files differ
Binary files differ
Binary files differ
@@ -39,14 +39,16 @@ public class AnnotationAccessVar extends BcelVar {
 	private Kind kind; // What kind of shadow are we at?
 	private UnresolvedType containingType; // The type upon which we want to ask for 'member'
 	private Member member; // Holds the member that has the annotations (for method/field join points)
+	private boolean isWithin; // implies @within() or @withincode(). If false, that implies @annotation()
 
 	public AnnotationAccessVar(BcelShadow shadow, Kind kind, ResolvedType annotationType, UnresolvedType theTargetIsStoredHere,
-			Member sig) {
+			Member sig, boolean isWithin) {
 		super(annotationType, 0);
 		this.shadow = shadow;
 		this.kind = kind;
 		this.containingType = theTargetIsStoredHere;
 		this.member = sig;
+		this.isWithin = isWithin;
 	}
 
 	public Kind getKind() {
@@ -120,7 +122,7 @@ public class AnnotationAccessVar extends BcelVar {
 					|| ((kind == Shadow.ConstructorCall || kind == Shadow.ConstructorExecution) && member.getKind() == Member.METHOD)) {
 
 				// Need to look at the cached annotation before going to fetch it again
-				Field annotationCachingField = shadow.getEnclosingClass().getAnnotationCachingField(shadow, toType);
+				Field annotationCachingField = shadow.getEnclosingClass().getAnnotationCachingField(shadow, toType, isWithin);
 
 				// Basic idea here is to check if the cached field is null, if it is then initialize it, otherwise use it
 				il.append(fact.createGetStatic(shadow.getEnclosingClass().getName(), annotationCachingField.getName(), jlAnnotation));
@@ -156,14 +158,7 @@ public class AnnotationAccessVar extends BcelVar {
 						new Type[] { jlClass }, Constants.INVOKEVIRTUAL));
 			}
 		} else if (kind == Shadow.FieldSet || kind == Shadow.FieldGet) {
-			Type jlrField = BcelWorld.makeBcelType(UnresolvedType.JAVA_LANG_REFLECT_FIELD);
-			il.append(fact.createConstant(BcelWorld.makeBcelType(containingType))); // Stick the target on the stack
-			il.append(fact.createConstant(member.getName())); // Stick what we are after on the stack
-			il.append(fact.createInvoke("java/lang/Class", "getDeclaredField", jlrField, new Type[] { jlString },
-					Constants.INVOKEVIRTUAL));
-			il.append(pushConstant);
-			il.append(fact.createInvoke("java/lang/reflect/Field", "getAnnotation", jlaAnnotation, new Type[] { jlClass },
-					Constants.INVOKEVIRTUAL));
+			generateBytecodeToAccessAnnotationAtFieldGetSetShadow(toType, fact, il, pushConstant);
 		} else if (kind == Shadow.StaticInitialization || kind == Shadow.ExceptionHandler) {
 			il.append(fact.createConstant(BcelWorld.makeBcelType(containingType)));
 			il.append(pushConstant);
@@ -176,6 +171,44 @@ public class AnnotationAccessVar extends BcelVar {
 		return il;
 	}
 
+	/**
+	 * At a FieldGet or FieldSet shadow, generate the bytecode to access the annotation for that field. The annotation is cached so
+	 * the code checks that cached value before proceeding.
+	 */
+	private void generateBytecodeToAccessAnnotationAtFieldGetSetShadow(ResolvedType toType, InstructionFactory fact,
+			InstructionList il, Instruction pushConstantAnnotationType) {
+		Type jlClass = BcelWorld.makeBcelType(UnresolvedType.JL_CLASS);
+		Type jlString = BcelWorld.makeBcelType(UnresolvedType.JL_STRING);
+		Type jlaAnnotation = BcelWorld.makeBcelType(UnresolvedType.JAVA_LANG_ANNOTATION);
+		Type jlrField = BcelWorld.makeBcelType(UnresolvedType.JAVA_LANG_REFLECT_FIELD);
+
+		LazyClassGen shadowEnclosingClass = shadow.getEnclosingClass();
+
+		// The annotation for the field of interest is cached, check cached value before fetching it
+		Field annotationCachingField = shadowEnclosingClass.getAnnotationCachingField(shadow, toType, isWithin);
+		String annotationCachingFieldName = annotationCachingField.getName();
+
+		// Basic idea here is to check if the cached field is null, if it is then initialize it, otherwise use it
+		il.append(fact.createGetStatic(shadowEnclosingClass.getName(), annotationCachingFieldName, jlaAnnotation));
+		il.appendDUP();
+		InstructionBranch ifNonNull = new InstructionBranch(Constants.IFNONNULL, null);
+		il.append(ifNonNull);
+		il.appendPOP();
+
+		// get the field of interest
+		il.append(fact.createConstant(BcelWorld.makeBcelType(containingType)));
+		il.append(fact.createConstant(member.getName()));
+		il.append(fact.createInvoke("java/lang/Class", "getDeclaredField", jlrField, new Type[] { jlString },
+				Constants.INVOKEVIRTUAL));
+		il.append(pushConstantAnnotationType);
+		il.append(fact.createInvoke("java/lang/reflect/Field", "getAnnotation", jlaAnnotation, new Type[] { jlClass },
+				Constants.INVOKEVIRTUAL));
+		il.appendDUP();
+		il.append(fact.createPutStatic(shadowEnclosingClass.getName(), annotationCachingFieldName, jlaAnnotation));
+		InstructionHandle ifNullElse = il.appendNOP();
+		ifNonNull.setTarget(ifNullElse);
+	}
+
 	private void buildArray(InstructionList il, InstructionFactory fact, Type arrayElementType, Type[] arrayEntries, int dim) {
 		il.append(fact.createConstant(Integer.valueOf(arrayEntries == null ? 0 : arrayEntries.length)));
 		il.append(fact.createNewArray(arrayElementType, (short) dim));
@@ -1612,7 +1612,7 @@ public class BcelShadow extends Shadow {
 
 		for (ResolvedType annotationType : annotations) {
 			AnnotationAccessVar accessVar = new AnnotationAccessVar(this, getKind(), annotationType.resolve(world), relevantType,
-					annotationHolder);
+					annotationHolder, false);
 			kindedAnnotationVars.put(annotationType, accessVar);
 		}
 	}
@@ -1659,7 +1659,7 @@ public class BcelShadow extends Shadow {
 		for (int i = 0; i < annotations.length; i++) {
 			ResolvedType ann = annotations[i];
 			Kind k = Shadow.StaticInitialization;
-			withinAnnotationVars.put(ann, new AnnotationAccessVar(this, k, ann, getEnclosingType(), null));
+			withinAnnotationVars.put(ann, new AnnotationAccessVar(this, k, ann, getEnclosingType(), null, true));
 		}
 	}
 
@@ -1675,8 +1675,8 @@ public class BcelShadow extends Shadow {
 			ResolvedType ann = annotations[i];
 			Kind k = (getEnclosingMethod().getMemberView().getKind() == Member.CONSTRUCTOR ? Shadow.ConstructorExecution
 					: Shadow.MethodExecution);
-			withincodeAnnotationVars.put(ann,
-					new AnnotationAccessVar(this, k, ann, getEnclosingType(), getEnclosingCodeSignature()));
+			withincodeAnnotationVars.put(ann, new AnnotationAccessVar(this, k, ann, getEnclosingType(),
+					getEnclosingCodeSignature(), true));
 		}
 	}
 
@@ -1048,10 +1048,11 @@ public final class LazyClassGen {
 	 * @param shadow the shadow at which the @annotation result is being cached
 	 * @return a field
 	 */
-	public Field getAnnotationCachingField(BcelShadow shadow, ResolvedType toType) {
+	public Field getAnnotationCachingField(BcelShadow shadow, ResolvedType toType, boolean isWithin) {
 		// Multiple annotation types at a shadow. A different field would be required for each
-		CacheKey cacheKey = new CacheKey(shadow, toType);
+		CacheKey cacheKey = new CacheKey(shadow, toType, isWithin);
 		Field field = annotationCachingFieldCache.get(cacheKey);
+		// System.out.println(field + " for shadow " + shadow);
 		if (field == null) {
 			// private static Annotation ajc$anno$<nnn>
 			StringBuilder sb = new StringBuilder();
@@ -1066,17 +1067,20 @@ public final class LazyClassGen {
 	}
 
 	static class CacheKey {
-		private BcelShadow shadow;
+		private Object key;
 		private ResolvedType annotationType;
 
-		CacheKey(BcelShadow shadow, ResolvedType annotationType) {
-			this.shadow = shadow;
+		// If the annotation is being accessed via @annotation on a shadow then we can use the shadows toString() (so two shadows
+		// the same share a variable), but if it is @withincode() or @within() we can't share them (as the shadows may look the same
+		// but be occurring 'within' different things). In the within cases we continue to use the shadow itself as the key.
+		CacheKey(BcelShadow shadow, ResolvedType annotationType, boolean isWithin) {
+			this.key = isWithin ? shadow : shadow.toString();
 			this.annotationType = annotationType;
 		}
 
 		@Override
 		public int hashCode() {
-			return shadow.hashCode() * 37 + annotationType.hashCode();
+			return key.hashCode() * 37 + annotationType.hashCode();
 		}
 
 		@Override
@@ -1085,7 +1089,7 @@ public final class LazyClassGen {
 				return false;
 			}
 			CacheKey oCacheKey = (CacheKey) other;
-			return shadow.equals(oCacheKey.shadow) && annotationType.equals(oCacheKey.annotationType);
+			return key.equals(oCacheKey.key) && annotationType.equals(oCacheKey.annotationType);
 		}
 	}
 
@@ -76,7 +76,7 @@ import org.aspectj.apache.bcel.util.ByteSequence;
  * 
  * A list is finally dumped to a byte code array with <a href="#getByteCode()">getByteCode</a>.
  * 
- * @version $Id: InstructionList.java,v 1.11 2010/09/15 18:18:01 aclement Exp $
+ * @version $Id: InstructionList.java,v 1.12 2011/09/02 22:33:04 aclement Exp $
  * @author <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
  * @author Abraham Nevado
  * @see Instruction
@@ -355,6 +355,24 @@ public class InstructionList implements Serializable {
 		return ih;
 	}
 
+	public InstructionHandle appendDUP() {
+		InstructionHandle ih = InstructionHandle.getInstructionHandle(InstructionConstants.DUP);
+		append(ih);
+		return ih;
+	}
+
+	public InstructionHandle appendNOP() {
+		InstructionHandle ih = InstructionHandle.getInstructionHandle(InstructionConstants.NOP);
+		append(ih);
+		return ih;
+	}
+
+	public InstructionHandle appendPOP() {
+		InstructionHandle ih = InstructionHandle.getInstructionHandle(InstructionConstants.POP);
+		append(ih);
+		return ih;
+	}
+
 	/**
 	 * Append a branch instruction to the end of this list.
 	 * 
