@@ -26,17 +26,25 @@ public abstract class ConcreteTypeMunger implements PartialOrder.PartialComparab
 		this.aspectType = aspectType;
 	}
 
-    /**
-     * Equivalence can be true for an EclipseTypeMunger and a BcelTypeMunger that represent the
-     * same transformation (just at different points in the pipeline).
-    */
+	/**
+	 * Equivalence can be true for an EclipseTypeMunger and a BcelTypeMunger that represent the same transformation (just at
+	 * different points in the pipeline).
+	 */
 	public boolean equivalentTo(Object other) {
 		if (!(other instanceof ConcreteTypeMunger)) {
 			return false;
 		}
 		ConcreteTypeMunger o = (ConcreteTypeMunger) other;
-		return ((o.getMunger() == null) ? (getMunger() == null) : o.getMunger().equals(getMunger()))
-				&& ((o.getAspectType() == null) ? (getAspectType() == null) : o.getAspectType().equals(getAspectType()));
+		ResolvedTypeMunger otherTypeMunger = o.getMunger();
+		ResolvedTypeMunger thisTypeMunger = getMunger();
+		if (thisTypeMunger instanceof NewConstructorTypeMunger && otherTypeMunger instanceof NewConstructorTypeMunger) {
+			return ((otherTypeMunger == null) ? (thisTypeMunger == null) : ((NewConstructorTypeMunger) otherTypeMunger)
+					.equivalentTo(thisTypeMunger))
+					&& ((o.getAspectType() == null) ? (getAspectType() == null) : o.getAspectType().equals(getAspectType()));
+		} else {
+			return ((otherTypeMunger == null) ? (thisTypeMunger == null) : otherTypeMunger.equals(thisTypeMunger))
+					&& ((o.getAspectType() == null) ? (getAspectType() == null) : o.getAspectType().equals(getAspectType()));
+		}
 	}
 
 	// public abstract boolean munge(LazyClassGen gen);
@@ -52,13 +52,13 @@ public class CrosscuttingMembers {
 	private List lateTypeMungers = new ArrayList(0);
 
 	private Set declareParents = new HashSet();
-	private List declareSofts = new ArrayList(0);
+	private Set declareSofts = new HashSet();
 	private List declareDominates = new ArrayList(4);
 
 	// These are like declare parents type mungers
 	private Set declareAnnotationsOnType = new HashSet();
 	private Set declareAnnotationsOnField = new HashSet();
-	private Set declareAnnotationsOnMethods = new HashSet(); 
+	private Set declareAnnotationsOnMethods = new HashSet();
 	// declareAnnotationsOnMethods includes constructors too
 
 	private boolean shouldConcretizeIfNeeded = true;
@@ -460,7 +460,7 @@ public class CrosscuttingMembers {
 		Pointcut p = munger.getPointcut();
 		Pointcut newP = pr.rewrite(p);
 		if (p.m_ignoreUnboundBindingForNames.length != 0) {
-  			// *sigh* dirty fix for dirty hacky implementation pr149305
+			// *sigh* dirty fix for dirty hacky implementation pr149305
 			newP.m_ignoreUnboundBindingForNames = p.m_ignoreUnboundBindingForNames;
 		}
 		munger.setPointcut(newP);
@@ -483,7 +483,7 @@ public class CrosscuttingMembers {
 		return declareParents;
 	}
 
-	public List getDeclareSofts() {
+	public Collection getDeclareSofts() {
 		return declareSofts;
 	}
 
@@ -10,7 +10,6 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.weaver;
 
 import java.io.DataOutputStream;
@@ -25,13 +24,8 @@ public class NewConstructorTypeMunger extends ResolvedTypeMunger {
 	private ResolvedMember syntheticConstructor;
 	private ResolvedMember explicitConstructor;
 
-
-	public NewConstructorTypeMunger(
-		ResolvedMember signature,
-		ResolvedMember syntheticConstructor,
-		ResolvedMember explicitConstructor,
-		Set superMethodsCalled,
-		List typeVariableAliases) {
+	public NewConstructorTypeMunger(ResolvedMember signature, ResolvedMember syntheticConstructor,
+			ResolvedMember explicitConstructor, Set superMethodsCalled, List typeVariableAliases) {
 		super(Constructor, signature);
 		this.syntheticConstructor = syntheticConstructor;
 		this.typeVariableAliases = typeVariableAliases;
@@ -39,31 +33,42 @@ public class NewConstructorTypeMunger extends ResolvedTypeMunger {
 		this.setSuperMethodsCalled(superMethodsCalled);
 
 	}
-	
-    public boolean equals(Object other) {
-    	if (!(other instanceof NewConstructorTypeMunger)) return false;
-    	NewConstructorTypeMunger o = (NewConstructorTypeMunger)other;	
-    	return ((o.syntheticConstructor == null) ? (syntheticConstructor == null ) 
-    				: syntheticConstructor.equals(o.syntheticConstructor))
-    			& ((o.explicitConstructor == null) ? (explicitConstructor == null ) 
-    				: explicitConstructor.equals(o.explicitConstructor));
-    }
-
-    private volatile int hashCode = 0;
-    public int hashCode() {
-    	if (hashCode == 0) {
-    	 	int result = 17;
-    	    result = 37*result + ((syntheticConstructor == null) ? 0 : syntheticConstructor.hashCode());
-    	    result = 37*result + ((explicitConstructor == null) ? 0 : explicitConstructor.hashCode());
-    	    hashCode = result;
+
+	public boolean equals(Object other) {
+		if (!(other instanceof NewConstructorTypeMunger))
+			return false;
+		NewConstructorTypeMunger o = (NewConstructorTypeMunger) other;
+		return ((syntheticConstructor == null) ? (o.syntheticConstructor == null) : syntheticConstructor
+				.equals(o.syntheticConstructor))
+				& ((explicitConstructor == null) ? (o.explicitConstructor == null) : explicitConstructor
+						.equals(o.explicitConstructor));
+	}
+
+	// pr262218 - equivalence ignores the explicit constructor since that won't have yet been set for an EclipseTypeMunger
+	public boolean equivalentTo(Object other) {
+		if (!(other instanceof NewConstructorTypeMunger))
+			return false;
+		NewConstructorTypeMunger o = (NewConstructorTypeMunger) other;
+		return ((syntheticConstructor == null) ? (o.syntheticConstructor == null) : syntheticConstructor
+				.equals(o.syntheticConstructor));
+	}
+
+	private volatile int hashCode = 0;
+
+	public int hashCode() {
+		if (hashCode == 0) {
+			int result = 17;
+			result = 37 * result + ((syntheticConstructor == null) ? 0 : syntheticConstructor.hashCode());
+			result = 37 * result + ((explicitConstructor == null) ? 0 : explicitConstructor.hashCode());
+			hashCode = result;
 		}
-	    return hashCode;
-    }
-	
+		return hashCode;
+	}
+
 	// doesnt seem required....
-//	public ResolvedMember getDispatchMethod(UnresolvedType aspectType) {
-//		return AjcMemberMaker.interMethodBody(signature, aspectType);
-//	}
+	// public ResolvedMember getDispatchMethod(UnresolvedType aspectType) {
+	// return AjcMemberMaker.interMethodBody(signature, aspectType);
+	// }
 
 	public void write(DataOutputStream s) throws IOException {
 		kind.write(s);
@@ -74,17 +79,19 @@ public class NewConstructorTypeMunger extends ResolvedTypeMunger {
 		writeSourceLocation(s);
 		writeOutTypeAliases(s);
 	}
-	
+
 	public static ResolvedTypeMunger readConstructor(VersionedDataInputStream s, ISourceContext context) throws IOException {
 		ISourceLocation sloc = null;
-		ResolvedMember sig           = ResolvedMemberImpl.readResolvedMember(s, context);
+		ResolvedMember sig = ResolvedMemberImpl.readResolvedMember(s, context);
 		ResolvedMember syntheticCtor = ResolvedMemberImpl.readResolvedMember(s, context);
-		ResolvedMember explicitCtor  = ResolvedMemberImpl.readResolvedMember(s, context);
-		Set superMethodsCalled       = readSuperMethodsCalled(s);
-		sloc                         = readSourceLocation(s);
-		List typeVarAliases          = readInTypeAliases(s);
-		ResolvedTypeMunger munger = new NewConstructorTypeMunger(sig,syntheticCtor,explicitCtor,superMethodsCalled,typeVarAliases);
-		if (sloc!=null) munger.setSourceLocation(sloc);
+		ResolvedMember explicitCtor = ResolvedMemberImpl.readResolvedMember(s, context);
+		Set superMethodsCalled = readSuperMethodsCalled(s);
+		sloc = readSourceLocation(s);
+		List typeVarAliases = readInTypeAliases(s);
+		ResolvedTypeMunger munger = new NewConstructorTypeMunger(sig, syntheticCtor, explicitCtor, superMethodsCalled,
+				typeVarAliases);
+		if (sloc != null)
+			munger.setSourceLocation(sloc);
 		return munger;
 	}
 
@@ -101,29 +108,30 @@ public class NewConstructorTypeMunger extends ResolvedTypeMunger {
 		// reset hashCode so that its recalculated with new value
 		hashCode = 0;
 	}
-	
+
 	public ResolvedMember getMatchingSyntheticMember(Member member, ResolvedType aspectType) {
 		ResolvedMember ret = getSyntheticConstructor();
-		if (ResolvedType.matches(ret, member)) return getSignature();
+		if (ResolvedType.matches(ret, member))
+			return getSignature();
 		return super.getMatchingSyntheticMember(member, aspectType);
 	}
-	
+
 	public void check(World world) {
 		if (getSignature().getDeclaringType().resolve(world).isAspect()) {
-			world.showMessage(IMessage.ERROR, 
-					WeaverMessages.format(WeaverMessages.ITD_CONS_ON_ASPECT),
-					getSignature().getSourceLocation(), null);
+			world.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.ITD_CONS_ON_ASPECT), getSignature()
+					.getSourceLocation(), null);
 		}
 	}
 
 	/**
-     * see ResolvedTypeMunger.parameterizedFor(ResolvedType)
-     */
+	 * see ResolvedTypeMunger.parameterizedFor(ResolvedType)
+	 */
 	public ResolvedTypeMunger parameterizedFor(ResolvedType target) {
 		ResolvedType genericType = target;
-		if (target.isRawType() || target.isParameterizedType()) genericType = genericType.getGenericType();
+		if (target.isRawType() || target.isParameterizedType())
+			genericType = genericType.getGenericType();
 		ResolvedMember parameterizedSignature = null;
-		// If we are parameterizing it for a generic type, we just need to 'swap the letters' from the ones used 
+		// If we are parameterizing it for a generic type, we just need to 'swap the letters' from the ones used
 		// in the original ITD declaration to the ones used in the actual target type declaration.
 		if (target.isGenericType()) {
 			TypeVariable vars[] = target.getTypeVariables();
@@ -131,12 +139,14 @@ public class NewConstructorTypeMunger extends ResolvedTypeMunger {
 			for (int i = 0; i < vars.length; i++) {
 				varRefs[i] = new UnresolvedTypeVariableReferenceType(vars[i]);
 			}
-			parameterizedSignature = getSignature().parameterizedWith(varRefs,genericType,true,typeVariableAliases);
+			parameterizedSignature = getSignature().parameterizedWith(varRefs, genericType, true, typeVariableAliases);
 		} else {
-		  // For raw and 'normal' parameterized targets  (e.g. Interface, Interface<String>)
-		  parameterizedSignature = getSignature().parameterizedWith(target.getTypeParameters(),genericType,target.isParameterizedType(),typeVariableAliases);
+			// For raw and 'normal' parameterized targets (e.g. Interface, Interface<String>)
+			parameterizedSignature = getSignature().parameterizedWith(target.getTypeParameters(), genericType,
+					target.isParameterizedType(), typeVariableAliases);
 		}
-		NewConstructorTypeMunger nctm = new NewConstructorTypeMunger(parameterizedSignature,syntheticConstructor,explicitConstructor,getSuperMethodsCalled(),typeVariableAliases);
+		NewConstructorTypeMunger nctm = new NewConstructorTypeMunger(parameterizedSignature, syntheticConstructor,
+				explicitConstructor, getSuperMethodsCalled(), typeVariableAliases);
 		nctm.setSourceLocation(getSourceLocation());
 		return nctm;
 	}
@@ -10,7 +10,6 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.weaver.patterns;
 
 import java.io.DataOutputStream;
@@ -34,20 +33,18 @@ public class DeclareSoft extends Declare {
 		this.exception = exception;
 		this.pointcut = pointcut;
 	}
-	
+
 	public Object accept(PatternNodeVisitor visitor, Object data) {
-		return visitor.visit(this,data);
+		return visitor.visit(this, data);
 	}
-	
-	public Declare parameterizeWith(Map typeVariableBindingMap,World w) {
-		DeclareSoft ret = 
-			new DeclareSoft(
-					exception.parameterizeWith(typeVariableBindingMap,w),
-					pointcut.parameterizeWith(typeVariableBindingMap,w));
+
+	public Declare parameterizeWith(Map typeVariableBindingMap, World w) {
+		DeclareSoft ret = new DeclareSoft(exception.parameterizeWith(typeVariableBindingMap, w), pointcut.parameterizeWith(
+				typeVariableBindingMap, w));
 		ret.copyLocationFrom(this);
 		return ret;
 	}
-	
+
 	public String toString() {
 		StringBuffer buf = new StringBuffer();
 		buf.append("declare soft: ");
@@ -57,22 +54,20 @@ public class DeclareSoft extends Declare {
 		buf.append(";");
 		return buf.toString();
 	}
-	
-	public boolean equals(Object other) { 
-		if (!(other instanceof DeclareSoft)) return false;
-		DeclareSoft o = (DeclareSoft)other;
-		return
-			o.pointcut.equals(pointcut) &&
-			o.exception.equals(exception);
+
+	public boolean equals(Object other) {
+		if (!(other instanceof DeclareSoft))
+			return false;
+		DeclareSoft o = (DeclareSoft) other;
+		return o.pointcut.equals(pointcut) && o.exception.equals(exception);
 	}
-    
-    public int hashCode() {
-        int result = 19;
-        result = 37*result + pointcut.hashCode();
-        result = 37*result + exception.hashCode();
-        return result;
-    }
 
+	public int hashCode() {
+		int result = 19;
+		result = 37 * result + pointcut.hashCode();
+		result = 37 * result + exception.hashCode();
+		return result;
+	}
 
 	public void write(DataOutputStream s) throws IOException {
 		s.writeByte(Declare.SOFT);
@@ -82,10 +77,7 @@ public class DeclareSoft extends Declare {
 	}
 
 	public static Declare read(VersionedDataInputStream s, ISourceContext context) throws IOException {
-		Declare ret = new DeclareSoft(
-			TypePattern.read(s, context),
-			Pointcut.read(s, context)
-		);
+		Declare ret = new DeclareSoft(TypePattern.read(s, context), Pointcut.read(s, context));
 		ret.readLocation(context, s);
 		return ret;
 	}
@@ -93,44 +85,43 @@ public class DeclareSoft extends Declare {
 	public Pointcut getPointcut() {
 		return pointcut;
 	}
-	
+
 	public TypePattern getException() {
 		return exception;
 	}
 
-    public void resolve(IScope scope) {
-    	exception = exception.resolveBindings(scope, null, false, true);
-    	ResolvedType excType = exception.getExactType().resolve(scope.getWorld());
-    	if (!excType.isMissing()) {
-    		if (excType.isTypeVariableReference()) {
-    		    TypeVariableReferenceType typeVariableRT = (TypeVariableReferenceType) excType;
-    			// a declare soft in a generic abstract aspect, we need to check the upper bound
-    			excType = typeVariableRT.getUpperBound().resolve(scope.getWorld());
-    		}
-    		if (!scope.getWorld().getCoreType(UnresolvedType.THROWABLE).isAssignableFrom(excType)) {
-    			scope.getWorld().showMessage(IMessage.ERROR,
-    					WeaverMessages.format(WeaverMessages.NOT_THROWABLE,excType.getName()),
-    					exception.getSourceLocation(), null);
-    			pointcut = Pointcut.makeMatchesNothing(Pointcut.RESOLVED);
-    			return;
-    		}
-	        // ENH 42743 suggests that we don't soften runtime exceptions.
+	public void resolve(IScope scope) {
+		exception = exception.resolveBindings(scope, null, false, true);
+		ResolvedType excType = exception.getExactType().resolve(scope.getWorld());
+		if (!excType.isMissing()) {
+			if (excType.isTypeVariableReference()) {
+				TypeVariableReferenceType typeVariableRT = (TypeVariableReferenceType) excType;
+				// a declare soft in a generic abstract aspect, we need to check the upper bound
+				excType = typeVariableRT.getUpperBound().resolve(scope.getWorld());
+			}
+			if (!scope.getWorld().getCoreType(UnresolvedType.THROWABLE).isAssignableFrom(excType)) {
+				scope.getWorld()
+						.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.NOT_THROWABLE, excType.getName()),
+								exception.getSourceLocation(), null);
+				pointcut = Pointcut.makeMatchesNothing(Pointcut.RESOLVED);
+				return;
+			}
+			// ENH 42743 suggests that we don't soften runtime exceptions.
 			if (scope.getWorld().getCoreType(UnresolvedType.RUNTIME_EXCEPTION).isAssignableFrom(excType)) {
-			    scope.getWorld().getLint().runtimeExceptionNotSoftened.signal(
-			      		new String[]{excType.getName()},
-			      		exception.getSourceLocation(),null);
+				scope.getWorld().getLint().runtimeExceptionNotSoftened.signal(new String[] { excType.getName() }, exception
+						.getSourceLocation(), null);
 				pointcut = Pointcut.makeMatchesNothing(Pointcut.RESOLVED);
 				return;
-			}			
-    	}
-    	
-    	pointcut = pointcut.resolve(scope); 	
-    }
-    
-    public boolean isAdviceLike() {
-		return true;
+			}
+		}
+
+		pointcut = pointcut.resolve(scope);
 	}
-	
+
+	public boolean isAdviceLike() {
+		return false;
+	}
+
 	public String getNameSuffix() {
 		return "soft";
 	}
@@ -0,0 +1,18 @@
+package generics;
+
+public class ActionExecutor {
+	public static void main(String[] args) {
+		DeleteAction<String> d = new DeleteAction<String>() {
+			public String getSelected() {
+				throw new RuntimeException();
+			}
+			
+		};
+		d.delete2++; 
+		d.delete3.add(null);
+	}
+	
+	void nothing2(DeleteAction<String> g) {
+		g.delete2++;
+	}
+} 
\ No newline at end of file
@@ -0,0 +1,12 @@
+package generics;
+import java.util.List;
+
+
+public interface DeleteAction<T extends Object>{
+
+    public void delete();
+    
+    public T getSelected(); 
+
+} 
+ 
\ No newline at end of file
@@ -0,0 +1,30 @@
+package generics;
+
+import java.util.List;
+
+
+public aspect DeleteActionAspect {
+
+    public void DeleteAction<T extends Object>.delete() {
+            Object selected = getSelected();
+            selected.toString();
+            delete3.add("");
+    } 
+	 
+	public int DeleteAction<T extends Object>.delete2;
+	
+	public List<String> DeleteAction.delete3;
+	
+	
+	public static void main(String[] args) {
+		DeleteAction<String> d = new DeleteAction<String>() {
+			public String getSelected() {
+				throw new RuntimeException();
+			}
+			
+		};
+		d.delete2++; 
+		d.delete3.add(null);
+	}
+
+} 
\ No newline at end of file
@@ -0,0 +1,14 @@
+package test;
+
+import java.util.List;
+ 
+public class Demo {
+    
+    void g() {
+        new Demo(7).foo(null);
+        x++;	
+        this.x++;
+        MyAspect.aspectOf();
+        MyAspect.hasAspect();
+    }
+}  
\ No newline at end of file
@@ -0,0 +1,50 @@
+package test;
+import java.util.List;
+
+public aspect MyAspect {
+	List<String> Demo.list = null;
+	declare @type : Demo : @Deprecated;  
+	int Demo.x = 5;
+	
+	void Demo.foo(List<String> x) {
+		MyAspect.hasAspect();
+	}
+	 
+	public Demo.new(int x) { 
+		this(); 
+	}  
+	
+    declare warning : execution(* *.nothing(..)) : "blah";
+    
+    declare error : execution(* *.nothing(..)) : "blah";
+    
+	declare soft : Exception : execution(* *.nothing(..));
+	
+	
+    protected pointcut s():
+        call(String Demo.toString(..));
+
+    before (): s() {
+    }
+    after (): s() {
+    }
+    void around (): s() {
+        proceed();
+        return;
+    }
+    after () returning(): s() {
+    }
+    after () throwing(): s() {
+    	thisEnclosingJoinPointStaticPart.getClass();
+    	thisJoinPoint.getClass();
+    	thisJoinPointStaticPart.getClass();  
+    }
+    
+    @interface MyAnnotation { }
+
+    // try out declare annotation
+    declare @field: int Demo.x: @MyAnnotation;
+    declare @method: void Demo.foo(..): @MyAnnotation;
+    declare @constructor: public Demo.new(int): @MyAnnotation; 
+
+}
@@ -0,0 +1,10 @@
+package test;
+
+
+public class OtherClass {
+    void x() {
+        Demo d = new Demo(4);
+        d.foo(null);
+        d.x ++; 
+    } 
+}
\ No newline at end of file
@@ -0,0 +1,29 @@
+package test2;
+
+import test.Demo;
+import test2.MyAspect2;
+
+public aspect MyAspect2 {
+    
+    static interface Bar {
+        
+    }
+    declare parents : Demo implements Bar, Cloneable;
+    
+    public int Bar.bar() { 
+        return 7;
+    }
+
+    
+    static class Foo {
+        public Foo() {
+             
+        } 
+    }
+    declare parents : Demo extends Foo;
+    
+    public int Foo.baz() {
+    	return 7;
+    } 
+
+}
@@ -0,0 +1,15 @@
+package test2;
+
+import test.Demo;
+
+public class OtherClass2 {
+    void x() {
+        Demo d = new Demo(4); 
+        d.bar(); 
+        d.baz();
+        // causes error for now see note at end of AJCompilationUnitProblemFinder.isARealProblem
+//        ((MyAspect2.Bar) d).bar();
+        ((MyAspect2.Foo) d).baz();
+        ((Cloneable) d).toString();
+    } 
+}        
\ No newline at end of file
@@ -0,0 +1,51 @@
+package test;
+import java.util.List;
+
+
+public aspect MyAspect {
+	List<String> Demo.list = null;
+	declare @type : Demo : @Deprecated;  
+	int Demo.x = 5;
+	
+	void Demo.foo(List<String> x) {
+		MyAspect.hasAspect();
+	}
+	 
+	public Demo.new(int x) { 
+		this(); 
+	}  
+	
+    declare warning : execution(* *.nothing(..)) : "blah";
+    
+    declare error : execution(* *.nothing(..)) : "blah";
+    
+	declare soft : Exception : execution(* *.nothing(..));
+	
+	
+    protected pointcut s():
+        call(String Demo.toString(..));
+
+    before (): s() {
+    }
+    after (): s() {
+    }
+    void around (): s() {
+        proceed();
+        return;
+    }
+    after () returning(): s() {
+    }
+    after () throwing(): s() {
+    	thisEnclosingJoinPointStaticPart.getClass();
+    	thisJoinPoint.getClass();
+    	thisJoinPointStaticPart.getClass();  
+    }
+    
+    @interface MyAnnotation { }
+
+    // try out declare annotation
+    declare @field: int Demo.x: @MyAnnotation;
+    declare @method: void Demo.foo(..): @MyAnnotation;
+    declare @constructor: public Demo.new(int): @MyAnnotation; 
+
+}
@@ -70,18 +70,19 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		}
 		assertEquals("Should have found the two types in: " + ps, 2, count);
 	}
-	
+
 	public void testConstructorAdvice_pr261380() throws Exception {
 		String p = "261380";
 		initialiseProject(p);
 		build(p);
 		IRelationshipMap irm = getModelFor(p).getRelationshipMap();
-		IRelationship ir = (IRelationship)irm.get("=261380<test{C.java}X&before").get(0);
+		IRelationship ir = (IRelationship) irm.get("=261380<test{C.java}X&before").get(0);
 		List targets = ir.getTargets();
-		assertEquals(1,targets.size());
+		assertEquals(1, targets.size());
 		System.out.println(targets.get(0));
 		String handle = (String) targets.get(0);
-		assertEquals("Expected the handle for the code node inside the constructor decl","=261380<test{C.java[C~C?constructor-call(void test.C.<init>())",handle);
+		assertEquals("Expected the handle for the code node inside the constructor decl",
+				"=261380<test{C.java[C~C?constructor-call(void test.C.<init>())", handle);
 	}
 
 	/*
@@ -244,6 +245,19 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		assertEquals("=BrokenHandles<p{GetInfo.java}GetInfo`declare parents!3", ipe.getHandleIdentifier());
 	}
 
+	public void testNPEIncremental_pr262218() {
+		AjdeInteractionTestbed.VERBOSE = true;
+		String p = "pr262218";
+		initialiseProject(p);
+		build(p);
+		checkWasFullBuild();
+		alter(p, "inc1");
+		build(p);
+		checkWasntFullBuild();
+		List l = getCompilerErrorMessages(p);
+		assertEquals("Unexpected compiler error", 0, l.size());
+	}
+
 	public void testAnnotations_pr262154() {
 		String p = "pr262154";
 		initialiseProject(p);
