@@ -11,6 +11,7 @@
  *******************************************************************************/
 package org.aspectj.weaver.bcel;
 
+import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -52,7 +53,6 @@ import org.aspectj.weaver.MethodDelegateTypeMunger;
 import org.aspectj.weaver.NameMangler;
 import org.aspectj.weaver.ReferenceType;
 import org.aspectj.weaver.ResolvedMember;
-import org.aspectj.weaver.ResolvedMemberImpl;
 import org.aspectj.weaver.ResolvedPointcutDefinition;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
@@ -672,13 +672,30 @@ public class AtAjAttributes {
 							// check public no arg ctor
 							ResolvedType impl = struct.enclosingType.getWorld().resolve(defaultImplClassName, false);
 							ResolvedMember[] mm = impl.getDeclaredMethods();
+							int implModifiers = impl.getModifiers();
+							boolean defaultVisibilityImpl = !(Modifier.isPrivate(implModifiers)
+									|| Modifier.isProtected(implModifiers) || Modifier.isPublic(implModifiers));
 							boolean hasNoCtorOrANoArgOne = true;
+							ResolvedMember foundOneOfIncorrectVisibility = null;
 							for (int i = 0; i < mm.length; i++) {
 								ResolvedMember resolvedMember = mm[i];
 								if (resolvedMember.getName().equals("<init>")) {
 									hasNoCtorOrANoArgOne = false;
-									if (resolvedMember.getParameterTypes().length == 0 && resolvedMember.isPublic()) {
-										hasNoCtorOrANoArgOne = true;
+
+									if (resolvedMember.getParameterTypes().length == 0) {
+										if (defaultVisibilityImpl) { // default visibility implementation
+											if (resolvedMember.isPublic() || resolvedMember.isDefault()) {
+												hasNoCtorOrANoArgOne = true;
+											} else {
+												foundOneOfIncorrectVisibility = resolvedMember;
+											}
+										} else if (Modifier.isPublic(implModifiers)) { // public implementation
+											if (resolvedMember.isPublic()) {
+												hasNoCtorOrANoArgOne = true;
+											} else {
+												foundOneOfIncorrectVisibility = resolvedMember;
+											}
+										}
 									}
 								}
 								if (hasNoCtorOrANoArgOne) {
@@ -686,8 +703,16 @@ public class AtAjAttributes {
 								}
 							}
 							if (!hasNoCtorOrANoArgOne) {
-								reportError("@DeclareParents: defaultImpl=\"" + defaultImplClassName
-										+ "\" has no public no-arg constructor", struct);
+								if (foundOneOfIncorrectVisibility != null) {
+									reportError(
+											"@DeclareParents: defaultImpl=\""
+													+ defaultImplClassName
+													+ "\" has a no argument constructor, but it is of incorrect visibility.  It must be at least as visible as the type.",
+											struct);
+								} else {
+									reportError("@DeclareParents: defaultImpl=\"" + defaultImplClassName
+											+ "\" has no public no-arg constructor", struct);
+								}
 							}
 							if (!fieldType.isAssignableFrom(impl)) {
 								reportError("@DeclareParents: defaultImpl=\"" + defaultImplClassName
@@ -720,13 +745,13 @@ public class AtAjAttributes {
 							// munger is what is used to determine the type of the field that hosts the delegate instance.
 							// So here we create a modified method with an alternative declaring type so that we lookup
 							// the right field. See pr164016. Generics will probably break this horribly
-/*
-							ResolvedMemberImpl methodWithAlteredDeclaringType = new ResolvedMemberImpl(method.getKind(), fieldType,
-									method.getModifiers(), method.getReturnType(), method.getName(), method.getParameterTypes(),
-									method.getExceptions());
-*/
-							MethodDelegateTypeMunger mdtm = new MethodDelegateTypeMunger(method,
-									struct.enclosingType, defaultImplClassName, typePattern);
+							/*
+							 * ResolvedMemberImpl methodWithAlteredDeclaringType = new ResolvedMemberImpl(method.getKind(),
+							 * fieldType, method.getModifiers(), method.getReturnType(), method.getName(),
+							 * method.getParameterTypes(), method.getExceptions());
+							 */
+							MethodDelegateTypeMunger mdtm = new MethodDelegateTypeMunger(method, struct.enclosingType,
+									defaultImplClassName, typePattern);
 							mdtm.setSourceLocation(struct.enclosingType.getSourceLocation());
 							struct.ajAttributes.add(new AjAttribute.TypeMunger(mdtm));
 						}
@@ -1019,8 +1044,7 @@ public class AtAjAttributes {
 			ISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(), struct.bMethod
 					.getDeclarationOffset());
 			struct.ajAttributes.add(new AjAttribute.AdviceAttribute(AdviceKind.AfterThrowing, pc, extraArgument, sl.getOffset(), sl
-					.getOffset() + 1,// FIXME AVASM
-					struct.context));
+					.getOffset() + 1, struct.context));
 			return true;
 		}
 		return false;
@@ -194,7 +194,7 @@
 
     <ajc-test dir="java5/decps" title="decps - 3c">
      <compile files="Basic3c.java" options="-1.5">
-       <message kind="error" text="@DeclareParents: defaultImpl=&quot;X$IImpl&quot; has no public no-arg constructor"/>
+       <message kind="error" text="@DeclareParents: defaultImpl=&quot;X$IImpl&quot; has a no argument constructor, but it is of incorrect visibility"/>
 	 </compile>
     </ajc-test>  
 
@@ -1086,7 +1086,9 @@
     </ajc-test>
 
     <ajc-test dir="bugs150" title="(@Foo *)+ type pattern parse error">
-        <compile files="AnnotationPlusPatternParseError.aj" options="-1.5"/>
+        <compile files="AnnotationPlusPatternParseError.aj" options="-1.5">
+          <message kind="warning" line="19"/>
+        </compile>
     </ajc-test>
 
     <ajc-test dir="bugs150" pr="80571" title="around advice on interface initializer">
@@ -54,9 +54,13 @@ public class Ajc163Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 		runTest("incorrect arg ordering anno style - 5");
 	}
 
-	// public void testDecpAnnoStyle_pr257754() {
-	// runTest("decp anno style");
-	// }
+	public void testDecpAnnoStyle_pr257754() {
+		runTest("decp anno style");
+	}
+
+	public void testDecpAnnoStyle_pr257754_2() {
+		runTest("decp anno style - 2");
+	}
 
 	public void testPoorAtAjIfMessage_pr256458() {
 		runTest("poor ataj if message - 1");
@@ -35,7 +35,18 @@
 
     <ajc-test dir="bugs163/pr257754" title="decp anno style">
    	  <compile files="Main.java" options="-1.5"/>
-   	  <run class="example.Main"/>
+   	  <run class="example.Main">
+   	  <stdout>
+   	  <line text="In doFoo class example.DefaultFoo"/>
+   	  <line text="Bar"/>
+   	  </stdout>
+   	  </run>
+    </ajc-test>
+    
+    <ajc-test dir="bugs163/pr257754" title="decp anno style - 2">
+   	  <compile files="Main2.java Foo.java DefaultFoo.java" options="-1.5">
+   	  <message kind="error" text="but it is of incorrect visibility"/>
+   	  </compile>
     </ajc-test>
 
     <ajc-test dir="bugs163/pr219419" title="incorrect arg ordering anno style">
@@ -0,0 +1,13 @@
+package impl;
+
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.annotation.DeclareParents;
+
+public class DefaultFoo implements Foo {
+//    Uncommenting the following fixes the error    
+    DefaultFoo() {
+    }
+    public void doFoo() {
+        System.out.println("In doFoo " + this.getClass());
+    }
+}
@@ -0,0 +1,6 @@
+package impl;
+
+public interface Foo {
+    public void doFoo();
+}
+
@@ -0,0 +1,38 @@
+package example;
+
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.annotation.DeclareParents;
+
+public class Main {
+    public static void main(String[] args) {
+        Bar bar = new Bar();
+        ((Foo)bar).doFoo();
+	bar.doBar();
+    }
+}
+
+interface Foo {
+    public void doFoo();
+}
+
+class DefaultFoo implements Foo {
+//    Uncommenting the following fixes the error    
+//    public DefaultFoo() {
+//    }
+    public void doFoo() {
+        System.out.println("In doFoo " + this.getClass());
+    }
+}
+
+class Bar {
+    public void doBar() {
+        System.out.println("Bar");
+    }
+}
+
+@Aspect
+class Introduce {
+    @DeclareParents(value="example.Bar", defaultImpl=DefaultFoo.class)
+    private Foo mixin;
+}
+
@@ -0,0 +1,26 @@
+package example;
+import impl.*;
+
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.annotation.DeclareParents;
+
+public class Main2 {
+    public static void main(String[] args) {
+        Bar bar = new Bar();
+        ((Foo)bar).doFoo();
+	bar.doBar();
+    }
+}
+
+class Bar {
+    public void doBar() {
+        System.out.println("Bar");
+    }
+}
+
+@Aspect
+class Introduce {
+    @DeclareParents(value="example.Bar", defaultImpl=impl.DefaultFoo.class)
+    private Foo mixin;
+}
+
