@@ -19,6 +19,7 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 public class Ajc161Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
 	// AspectJ1.6.1
+	public void testLtwInheritedCflow_pr230134() { runTest("ltw inherited cflow"); }
     public void testAroundAdviceOnFieldSet_pr229910() { runTest("around advice on field set"); }
     public void testPipelineCompilationGenericReturnType_pr226567() { runTest("pipeline compilation and generic return type"); }
 
@@ -3,15 +3,24 @@
 <!-- AspectJ v1.6.1 Tests -->
 <suite>
 
+    <ajc-test dir="bugs161/pr230134" title="ltw inherited cflow">
+      <compile files="HW.java"/>
+      <compile files="SimpleTracing.java Tracing.java HelloWorldTracing.java" outjar="foo.jar"/>
+      <run class="hello.HW" classpath="$sandbox/foo.jar" ltw="aop.xml">
+        <stdout>
+          <line text="Hello World"/>
+ 	    </stdout>
+      </run>
+    </ajc-test>
+    
     <ajc-test dir="bugs161/pr229910" title="around advice on field set">
         <compile files="Test.java" options="-1.5"/>
         <run class="Test"/>
-    </ajc-test>
+    </ajc-test> 
 
     <ajc-test dir="bugs161/pr226567" title="pipeline compilation and generic return type">
         <compile files="BarAspect.aj Foo.java Bar.java" options="-1.5"/>
         <compile files="BarAspect.aj Bar.java Foo.java" options="-1.5"/>
-    </ajc-test>
-    
+    </ajc-test> 
 
 </suite>
\ No newline at end of file
@@ -14,8 +14,10 @@ package org.aspectj.weaver;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
+import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 import org.aspectj.weaver.bcel.BcelAdvice;
@@ -71,6 +73,10 @@ public class CrosscuttingMembers {
 		this.shouldConcretizeIfNeeded = shouldConcretizeIfNeeded;
 	}
 
+
+	private Hashtable cflowFields = new Hashtable();
+	private Hashtable cflowBelowFields = new Hashtable();
+	
 //	public void addConcreteShadowMungers(Collection c) {
 //		shadowMungers.addAll(c);
 //	}
@@ -502,4 +508,17 @@ public class CrosscuttingMembers {
 		return declareAnnotationsOnMethods;
 	}
 
+	public Map getCflowBelowFields() {
+		return cflowBelowFields;
+	}
+
+	public Map getCflowFields() {
+		return cflowFields;
+	}
+	
+	public void clearCaches() {
+		cflowFields.clear();
+		cflowBelowFields.clear();
+	}
+
 }
@@ -78,13 +78,10 @@ public class CrosscuttingMembersSet {
 		if (xcut == null) {
 			members.put(aspectType, aspectType.collectCrosscuttingMembers(inWeavingPhase));
 			clearCaches();
-			CflowPointcut.clearCaches(aspectType);
 			change = true;
 		} else {
 			if (xcut.replaceWith(aspectType.collectCrosscuttingMembers(inWeavingPhase),inWeavingPhase)) {
 				clearCaches();
-
-				CflowPointcut.clearCaches(aspectType);
 				change = true;
 			} else {
 				if (!AsmManager.getDefault().getHandleProvider().dependsOnLocation()
@@ -88,5 +88,9 @@ public class BcelCflowCounterFieldAdder extends BcelTypeMunger {
 	public boolean existsToSupportShadowMunging() {
 		return true;
 	}
+	
+	public String toString() {
+		return "(BcelTypeMunger: CflowField "+cflowCounterField.getDeclaringType().getName()+" "+cflowCounterField.getName()+")";
+	}
 
 }
@@ -470,8 +470,6 @@ public class BcelWeaver implements IWeaver {
     public void prepareForWeave() {
     	if (trace.isTraceEnabled()) trace.enter("prepareForWeave",this);
     	needToReweaveWorld = xcutSet.hasChangedSinceLastReset();
-
-    	CflowPointcut.clearCaches();
 
     	// update mungers
     	for (Iterator i = addedClasses.iterator(); i.hasNext(); ) { 
@@ -50,8 +50,6 @@ public class CflowPointcut extends Pointcut {
 	boolean isBelow;// Is this cflowbelow?
 	private int[] freeVars;
 
-	private static Hashtable cflowFields = new Hashtable();
-	private static Hashtable cflowBelowFields = new Hashtable();
 
 	/**
 	 * Used to indicate that we're in the context of a cflow when concretizing if's
@@ -217,7 +215,7 @@ public class CflowPointcut extends Pointcut {
 		if (freeVars==null || freeVars.length == 0) { // No state, so don't use a stack, use a counter.
 		  ResolvedMember localCflowField = null;
 
-		  Object field = getCflowfield(concreteEntry,concreteAspect,"counter");
+		  Object field = getCflowfield(xcut, concreteEntry, concreteAspect, "counter");
 
 		  // Check if we have already got a counter for this cflow pointcut
 		  if (field != null) {
@@ -236,7 +234,7 @@ public class CflowPointcut extends Pointcut {
 		  	concreteAspect.crosscuttingMembers.addConcreteShadowMunger(
 		    Advice.makeCflowEntry(world,concreteEntry,isBelow,localCflowField,freeVars==null?0:freeVars.length,innerCflowEntries,inAspect));
 
-			putCflowfield(concreteEntry,concreteAspect,localCflowField,"counter"); // Remember it
+			putCflowfield(xcut,concreteEntry,concreteAspect,localCflowField,"counter"); // Remember it
 	      }
 
 		  Pointcut ret = new ConcreteCflowPointcut(localCflowField, null,true);
@@ -276,7 +274,7 @@ public class CflowPointcut extends Pointcut {
 				slots.add(slot);
 			}
 			ResolvedMember localCflowField = null;
-			Object field = getCflowfield(concreteEntry,concreteAspect,"stack");
+			Object field = getCflowfield(xcut,concreteEntry,concreteAspect,"stack");
 			if (field != null) {
 				localCflowField = (ResolvedMember)field;
 			} else {
@@ -295,7 +293,7 @@ public class CflowPointcut extends Pointcut {
 
 			  concreteAspect.crosscuttingMembers.addTypeMunger(
 				world.makeCflowStackFieldAdder(localCflowField));
-			  putCflowfield(concreteEntry,concreteAspect,localCflowField,"stack");
+			  putCflowfield(xcut,concreteEntry,concreteAspect,localCflowField,"stack");
 		    }
 			Pointcut ret = new ConcreteCflowPointcut(localCflowField, slots,false);
 			ret.copyLocationFrom(this);
@@ -304,10 +302,6 @@ public class CflowPointcut extends Pointcut {
 
 	}
 
-	public static void clearCaches() {
-		cflowFields.clear();
-		cflowBelowFields.clear();
-	}
 
 	private String getKey(Pointcut p,ResolvedType a,String stackOrCounter) {
 	  StringBuffer sb = new StringBuffer();
@@ -319,22 +313,22 @@ public class CflowPointcut extends Pointcut {
 	  return sb.toString();
 	}
 
-	private Object getCflowfield(Pointcut pcutkey, ResolvedType concreteAspect,String stackOrCounter) {
+	private Object getCflowfield(CrosscuttingMembers xcut, Pointcut pcutkey, ResolvedType concreteAspect,String stackOrCounter) {
 		String key = getKey(pcutkey,concreteAspect,stackOrCounter);
 		Object o =null;
-		if (isBelow) o = cflowBelowFields.get(key);
-		else         o = cflowFields.get(key);
+		if (isBelow) o = xcut.getCflowBelowFields().get(key);
+		else         o = xcut.getCflowFields().get(key);
 		//System.err.println("Retrieving for key "+key+" returning "+o);
 		return o;
 	}
 
-	private void putCflowfield(Pointcut pcutkey,ResolvedType concreteAspect,Object o,String stackOrCounter) {
+	private void putCflowfield(CrosscuttingMembers xcut, Pointcut pcutkey,ResolvedType concreteAspect,Object o,String stackOrCounter) {
 		String key = getKey(pcutkey,concreteAspect,stackOrCounter);
 		//System.err.println("Storing cflow field for key"+key);
 		if (isBelow) {
-			cflowBelowFields.put(key,o);
+			xcut.getCflowBelowFields().put(key,o);
 		} else {
-			cflowFields.put(key,o);
+			xcut.getCflowFields().put(key,o);
 		}
 	}
 
@@ -342,23 +336,4 @@ public class CflowPointcut extends Pointcut {
         return visitor.visit(this, data);
 	}
 
-	public static void clearCaches(ResolvedType aspectType) {
-		//System.err.println("Wiping entries starting "+aspectType.getName());
-		String key = aspectType.getName()+"::";
-		wipeKeys(key,cflowFields);
-		wipeKeys(key,cflowBelowFields);
-	}
-	
-	private static void wipeKeys(String keyPrefix,Hashtable ht) {
-		Enumeration keys = ht.keys();
-		List forRemoval = new ArrayList();
-		while (keys.hasMoreElements()) {
-			String s = (String)keys.nextElement();
-			if (s.startsWith(keyPrefix)) forRemoval.add(s);
-		}
-		for (Iterator iter = forRemoval.iterator(); iter.hasNext();) {
-			String element = (String) iter.next();
-			ht.remove(element);
-		}
-	}
 }
@@ -321,7 +321,6 @@ public class AjCompilerAdapter extends AbstractCompilerAdapter {
 		  weaver.weave(new WeaverAdapter(this,weaverMessageHandler,progressListener));
 		} finally {
 			// ???: is this the right point for this? After weaving has finished clear the caches.
-			CflowPointcut.clearCaches();
 			if (weaverMessageHandler instanceof WeaverMessageHandler)
 				  ((WeaverMessageHandler)weaverMessageHandler).setCurrentResult(null);
 			weaver.allWeavingComplete();
@@ -504,7 +504,6 @@ public class AjPipeliningCompilerAdapter extends AbstractCompilerAdapter {
 		try {
 		  weaver.weave(new WeaverAdapter(this,weaverMessageHandler,progressListener));
 		} finally {
-			CflowPointcut.clearCaches();
 			weaver.tidyUp();
 			IMessageHandler imh = weaver.getWorld().getMessageHandler();
 			if (imh instanceof WeaverMessageHandler)
@@ -516,7 +515,6 @@ public class AjPipeliningCompilerAdapter extends AbstractCompilerAdapter {
 	private void postWeave() {
 		if (debugPipeline)System.err.println("> postWeave()");
 		IMessageHandler imh = weaver.getWorld().getMessageHandler();
-		CflowPointcut.clearCaches();
 		if (imh instanceof WeaverMessageHandler)
 			  ((WeaverMessageHandler)imh).setCurrentResult(null);
 		if (!droppingBackToFullBuild) weaver.allWeavingComplete();
@@ -0,0 +1,14 @@
+package hello;
+
+public class HW {
+  public static void main(String[] argv) {
+    new HW().print("Hello");
+    new HW().print(" ");
+    new HW().print("World");
+    new HW().print("\n");
+  }
+
+  public void print(String msg) {
+    System.out.print(msg);
+  }
+}
@@ -0,0 +1,31 @@
+/*******************************************************************************
+ * Copyright (c) 2006 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *   Matthew Webster           initial implementation      
+ *******************************************************************************/
+
+package demo.hello.tracing;
+
+import org.aspectj.lib.tracing.*;
+
+public aspect HelloWorldTracing extends SimpleTracing {
+
+	protected pointcut tracingScope () :
+		within(hello.*);
+
+	/**
+	 * Template method that allows choice of destination for output
+	 * 
+	 * @param s message to be traced
+	 */
+	protected void println (String s) {
+		System.out.println(s);
+	}
+	
+}
+
@@ -0,0 +1,210 @@
+/*******************************************************************************
+ * Copyright (c) 2005 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Common Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/cpl-v10.html
+ * 
+ * Contributors:
+ *     Matthew Webster - initial implementation
+ *     Sian January
+ *******************************************************************************/
+package org.aspectj.lib.tracing;
+
+import java.io.File;
+import java.lang.reflect.Array;
+import java.net.URL;
+import java.text.SimpleDateFormat;
+import java.util.Collection;
+import java.util.Date;
+
+import org.aspectj.lang.JoinPoint;
+import org.aspectj.lang.reflect.CodeSignature;
+
+/**
+ * This simple abstract aspect is enabled by default and traces method 
+ * signatures as well as arguments to stderr. An abstract scoping pointcut 
+ * is provided for concrete, user-supplied sub-aspect to determine which 
+ * classes should be traced.
+ */
+public abstract aspect SimpleTracing extends Tracing {
+
+	/**
+	 * Sub-aspects <b>must</b> implement this pointcut to determine what to trace
+	 */
+	protected abstract pointcut tracingScope ();
+
+	private static SimpleDateFormat timeFormat;
+	
+	/**
+	 * Enabled or disable tracing
+	 * 
+	 * @param enabled 
+	 */
+	public static void setEnabled (boolean enabled) {
+		tracingEnabled = enabled;
+	}
+	
+	public static boolean getEnabled () {
+		return tracingEnabled;
+	}
+
+	/*
+	 * Tracing pattern 2: Use if() pointcut to efficiently determine when to trace
+	 *
+	 * Tracing pattern 3: Use -XlazyTjp compiler option
+	 */
+	protected pointcut shouldTrace () :
+		if(tracingEnabled) && tracingScope();
+		
+	private static boolean tracingEnabled = getBoolean("org.aspectj.lib.tracing",true);
+
+	private static boolean getBoolean (String name, boolean def) {
+		String defaultValue = String.valueOf(def);
+		String value = System.getProperty(name,defaultValue);
+		return Boolean.valueOf(value).booleanValue();
+	}
+
+	/*
+	 * Tracing template methods
+	 */
+	protected void enter (JoinPoint jp, Object obj) {
+		CodeSignature signature = (CodeSignature)jp.getSignature();
+		println(signature.getDeclaringType(),formatMessage(">",signature.getDeclaringTypeName(),signature.getName(),obj,jp.getArgs()));
+//		println("> " + signature.toShortString() + " " + formatParam("obj",obj) + " " + formatArgs(signature.getParameterNames(),jp.getArgs()));
+	}
+	
+	protected void enter (JoinPoint jp) {
+		CodeSignature signature = (CodeSignature)jp.getSignature();
+		println(signature.getDeclaringType(),formatMessage(">",signature.getDeclaringTypeName(),signature.getName(),null,jp.getArgs()));
+//		println("> " + jp.getSignature().toShortString() + " " + formatArgs(signature.getParameterNames(),jp.getArgs()));
+	}
+	
+	protected void exit (JoinPoint.StaticPart sjp, Object ret) {
+		CodeSignature signature = (CodeSignature)sjp.getSignature();
+		println(signature.getDeclaringType(),formatMessage("<",signature.getDeclaringTypeName(),signature.getName(),ret,null));
+//		println("< " + sjp.getSignature().toShortString() + " " + formatParam("ret",ret));
+	}
+	
+	protected void exit (JoinPoint.StaticPart sjp) {
+		CodeSignature signature = (CodeSignature)sjp.getSignature();
+		println(signature.getDeclaringType(),formatMessage("<",signature.getDeclaringTypeName(),signature.getName(),null,null));
+//		println("< " + sjp.getSignature().toShortString());
+	}
+	
+	protected void exception (JoinPoint.StaticPart sjp, Throwable th) {
+		CodeSignature signature = (CodeSignature)sjp.getSignature();
+		println(signature.getDeclaringType(),formatMessage("E",signature.getName(),th));
+//		println("E " + sjp.getSignature().toShortString() + " " + th.toString());
+	}
+	
+	/*
+	 * Formatting
+	 */
+	protected String formatMessage(String kind, String className, String methodName, Object thiz, Object[] args) {
+		StringBuffer message = new StringBuffer();
+		Date now = new Date();
+		message.append(formatDate(now)).append(" ");
+		message.append(Thread.currentThread().getName()).append(" ");
+		message.append(kind).append(" ");
+		message.append(className);
+		message.append(".").append(methodName);
+		if (thiz != null) message.append(" ").append(formatObj(thiz));
+		if (args != null) message.append(" ").append(formatArgs(args));
+		return message.toString();
+	}
+	
+	protected String formatMessage(String kind, String text, Throwable th) {
+		StringBuffer message = new StringBuffer();
+		Date now = new Date();
+		message.append(formatDate(now)).append(" ");
+		message.append(Thread.currentThread().getName()).append(" ");
+		message.append(kind).append(" ");
+		message.append(text);
+		if (th != null) message.append(" ").append(formatObj(th));
+		return message.toString();
+	}
+
+	/** 
+	 * Format arguments into a comma separated list
+	 * 
+	 * @param names array of argument names
+	 * @param args array of arguments
+	 * @return the formated list
+	 */
+	protected String formatArgs(Object[] args) {
+		StringBuffer sb = new StringBuffer();
+		
+		for (int i = 0; i < args.length; i++) {
+			sb.append(formatObj(args[i]));
+			if (i < args.length-1) sb.append(", ");
+		}
+		
+		return sb.toString();
+	}
+
+	/**
+	 * Format objects safely avoiding toString which can cause recursion,
+	 * NullPointerExceptions or highly verbose results.
+	 *  
+	 * @param obj parameter to be formatted
+	 * @return the formated parameter
+	 */
+	protected Object formatObj(Object obj) {
+		
+		/* These classes have a safe implementation of toString() */
+		if (obj == null
+				|| obj instanceof String
+			    || obj instanceof Number
+			    || obj instanceof Boolean
+			    || obj instanceof Exception
+			    || obj instanceof Character
+			    || obj instanceof Class
+			    || obj instanceof File
+			    || obj instanceof StringBuffer
+			    || obj instanceof URL
+		    ) return obj;
+		else if (obj.getClass().isArray()) {
+			return formatArray(obj);
+		}
+		else if (obj instanceof Collection) {
+			return formatCollection((Collection)obj);
+		}
+		else try {
+			
+			/* Use classname@hashcode */
+			return obj.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(obj));
+		
+		/* Object.hashCode() can be override and may thow an exception */	
+		} catch (Exception ex) {
+			return obj.getClass().getName() + "@FFFFFFFF";
+		}
+	}
+	
+	protected String formatArray (Object obj) {
+		return obj.getClass().getComponentType().getName() + "[" + Array.getLength(obj) + "]"; 
+	}
+	
+	protected String formatCollection (Collection c) {
+		return c.getClass().getName() + "(" + c.size() + ")"; 
+	}
+	
+	private static String formatDate (Date date) {
+		if (timeFormat == null) {
+			timeFormat = new SimpleDateFormat("HH:mm:ss.SSS");
+		}
+		
+		return timeFormat.format(date);
+	}
+
+	/**
+	 * Template method that allows choice of destination for output
+	 * 
+	 * @param s message to be traced
+	 */
+	protected void println (Class clazz, String s) {
+		System.err.println(s);
+	}
+
+}
+
@@ -0,0 +1,226 @@
+/*******************************************************************************
+ * Copyright (c) 2005 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Common Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/cpl-v10.html
+ * 
+ * Contributors:
+ *     Matthew Webster - initial implementation
+ *     Sian January
+ *******************************************************************************/
+package org.aspectj.lib.tracing;
+
+import org.aspectj.lang.*;
+
+/**
+ * This root abstract aspect determines the basic tracing behaviour 
+ * i.e. entry/exit/exception using the method/constructor execution() pointcut 
+ * and before/after returning/after throwing advice. Determining what 
+ * methods and constructors belonging to which classes is delegated to a 
+ * user-supplied concrete aspect using an abstract pointcut. When tracing 
+ * occurs and what is done with the captured data is delegated to an abstract, 
+ * infrastructure-specific sub-aspect through template methods.
+ */
+public abstract aspect Tracing {
+
+	/**
+	 * Sub-aspects <b>must</b> implement this pointcut to determine what and when to 
+	 * trace
+	 */
+	protected abstract pointcut shouldTrace ();
+
+	private pointcut staticContext () : !this(Object);
+    private pointcut nonStaticContext (Object obj) : this(obj);
+    private pointcut voidMethod () : execution(void *(..));
+    
+	public final static pointcut methodExecution () : execution(* *(..));
+	public final static pointcut constructorExecution () : execution(new(..));
+	public final static pointcut objectMethod () : execution(* Object.*(..));
+
+	/** 
+	 * Sub-aspects <b>may</b> override this point to determine which methods if any 
+	 * are traced. By default include only public methods and those not inherited 
+	 * from java.lang.Object e.g. toString().
+	 */
+	protected pointcut includedMethod () :
+		execution(public * *(..))
+		&& !objectMethod();
+
+
+	/** 
+	 * Sub-aspects <b>may</b> override this point to determine which constructors if any 
+	 * are traced. By default include only public constructors.
+	 */
+	protected pointcut includedConstructor () :
+		execution(public new(..));
+	
+	/*
+	 * Exclude methods and constructors in Tracing and sub-aspects as well as 
+	 * those in the control flow of Tracing advice or constructors to avoid recursion.
+	 */
+	private pointcut excluded () : 
+		within(Tracing+)
+//		|| cflow((adviceexecution() || execution(new(..))) && within(Tracing+))
+		|| cflow((adviceexecution() && within(Tracing+)))
+		 ;
+
+	/*
+	 * Trace only method execution included by the user but excluded by the aspect e.g. itself
+	 */
+	private pointcut tracedMethod () :
+		methodExecution()
+		&& includedMethod()
+		&& !excluded()
+		;
+
+	/*
+	 * Trace only constructor execution included by the user but excluded by the aspect e.g. itself
+	 */
+	private pointcut tracedConstructor (Object obj) :
+		constructorExecution()
+		&& includedConstructor()
+		&& !excluded()
+		&& this(obj)
+		;
+	
+	/*
+	 * Trace entry to instance methods
+	 * 
+	 * Tracing pattern 1: Only use thisJoinPoint in before()
+	 */
+	before (Object obj) : tracedMethod() && nonStaticContext(obj) && shouldTrace() {
+		enter(thisJoinPoint,obj);
+	}
+	
+	/*
+	 * Trace entry to static methods
+	 * 
+	 * Tracing pattern 1: Only use thisJoinPoint in before()
+	 */
+	before () : tracedMethod() && staticContext() && shouldTrace() {
+		enter(thisJoinPoint);
+	}
+	
+	/*
+	 * Trace exit from void methods
+	 * 
+	 * Tracing pattern 1: Use thisJoinPointStaticPart in after()
+	 */
+	after() returning() : tracedMethod() && voidMethod() && shouldTrace() {
+		exit(thisJoinPointStaticPart);
+	}
+	
+	/*
+	 * Trace exit from non-void methods including return value
+	 * 
+	 * Tracing pattern 1: Use thisJoinPointStaticPart in after()
+	 */
+	after() returning(Object ret) : tracedMethod() && !voidMethod() && shouldTrace() {
+		exit(thisJoinPointStaticPart,ret);
+	}
+	
+	/*
+	 * Trace exceptions thrown from methods and constructors
+	 * 
+	 * Tracing pattern 1: Use thisJoinPointStaticPart in after()
+	 */
+	after() throwing(Throwable th) : (tracedMethod() || tracedConstructor(Object)) && shouldTrace() {
+		if (shouldTrace(th)) exception(thisJoinPointStaticPart,th);
+	}
+	
+	/*
+	 * Trace entry to constructors
+	 * 
+	 * Tracing pattern 1: Only use thisJoinPoint in before()
+	 */
+	before () : tracedConstructor(Object) && shouldTrace() {
+		enter(thisJoinPoint);
+	}
+	
+	/*
+	 * Trace exit from constructors including new object
+	 * 
+	 * Tracing pattern 1: Only use thisJoinPoint in before()
+	 */
+	after (Object obj) : tracedConstructor(obj) && shouldTrace() {
+		exit(thisJoinPointStaticPart,obj);
+	}
+	
+	/*
+	 * Template methods to log data implemented by infrastructure-specific sub-aspects
+	 * e.g. java.util.logging.Logger 
+	 */
+	protected abstract void enter (JoinPoint jp, Object obj);
+	
+	protected abstract void enter (JoinPoint jp);
+	
+	protected abstract void exit (JoinPoint.StaticPart sjp);
+	
+	protected abstract void exit (JoinPoint.StaticPart sjp, Object ret);
+	
+	protected abstract void exception (JoinPoint.StaticPart sjp, Throwable th);
+
+	/** 
+	 * Format arguments into a comma separated list
+	 * 
+	 * @param names array of argument names
+	 * @param args array of arguments
+	 * @return the formated list
+	 */
+	protected String formatArgs (String[] names, Object[] args) {
+		StringBuffer sb = new StringBuffer();
+		
+		for (int i = 0; i < args.length; i++) {
+			sb.append(formatParam(names[i],args[i]));
+			if (i < args.length-1) sb.append(", ");
+		}
+		
+		return sb.toString();
+	}
+	
+	/**
+	 * Format objects safely avoiding toString which can cause recursion,
+	 * NullPointerExceptions or highly verbose results.
+	 *  
+	 * @param obj parameter to be formatted
+	 * @return the formated parameter
+	 */
+	protected Object formatObj (Object obj) {
+		if (obj == null
+				|| obj instanceof String
+			    || obj instanceof Number
+			    || obj instanceof Boolean
+			    || obj instanceof Character
+			    || obj instanceof Class
+			    || obj instanceof StringBuffer
+		    ) return obj;
+		else try {
+			return obj.getClass().getName() + "@" + Integer.toString(obj.hashCode(),16);
+		} catch (Exception ex) {
+			return obj.getClass().getName();
+		}
+	}
+	
+	/**
+	 * Format parameter into name=value pair
+	 * 
+	 * @param name parameter name
+	 * @param arg parameted to be formatted
+	 * @return the formated parameter
+	 */
+	protected String formatParam (String name, Object arg) {
+		return name + "=" + formatObj(arg);
+	}
+	
+	/**
+	 * By default we do not trace errors e.g. OutOfMemoryError because the 
+	 * system my be in an inconsistent state. However users may override this
+	 * 
+	 * @param th excpeption or error to be traced
+	 * @return whether it should be traced
+	 */
+	protected boolean shouldTrace (Throwable th) {
+		return !(th instanceof Error);
+	}
+}
@@ -0,0 +1,9 @@
+<?xml version="1.0"?>
+<aspectj>
+	<weaver options="-verbose -showWeaveInfo"/>
+	
+	<aspects>
+  	<aspect name="demo.hello.tracing.HelloWorldTracing"/>
+	</aspects>
+</aspectj>
+
