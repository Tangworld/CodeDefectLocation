@@ -12,9 +12,8 @@ package org.aspectj.systemtest.ajc160;
 
 import java.io.File;
 
-import junit.framework.Test;
-
 import org.aspectj.testing.XMLBasedAjcTestCase;
+import junit.framework.Test;
 
 /**
  * These are tests for AspectJ1.6.0
@@ -30,6 +29,9 @@ public class Ajc160Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	public void testBadMessage2() { runTest("incorrect itd error with generics - 2");}
 	public void testHasMethodAnnoValueInt_various() { runTest("hasmethod anno value - I");}
 	public void testHasMethodAnnoValueBoolean_various() { runTest("hasmethod anno value - Z");}
+	public void testGenericTypeParameterizedWithArrayType_pr167197() { runTest("generic type parameterized with array type");}
+	public void testGenericTypeParameterizedWithArrayType_pr167197_2() { runTest("generic type parameterized with array type - 2");}
+
 
 	// AspectJ1.6.0m2 and earlier
 	public void testBoundsCheckShouldFail_pr219298() { runTest("bounds check failure");}
@@ -0,0 +1,186 @@
+/* *******************************************************************
+ * Copyright (c) 2008 Contributors
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *     Andy Clement     initial implementation 
+ * ******************************************************************/
+package org.aspectj.weaver;
+
+import java.lang.reflect.Modifier;
+
+/**
+ * Represents a resolved array type
+ *
+ * @author Andy Clement 
+ */
+public class ArrayReferenceType extends ReferenceType {
+
+	private ResolvedType componentType;
+
+
+    public ArrayReferenceType(String sig, String erasureSig, World world, ResolvedType componentType) {
+        super(sig, erasureSig, world);
+        this.componentType = componentType;
+    }
+
+    // These methods are from the original implementation when Array was a ResolvedType and not a ReferenceType
+    
+    public final ResolvedMember[] getDeclaredFields() {
+        return ResolvedMember.NONE;
+    }
+
+    public final ResolvedMember[] getDeclaredMethods() {
+        // ??? should this return clone? Probably not...
+        // If it ever does, here is the code:
+        // ResolvedMember cloneMethod =
+        // new ResolvedMember(Member.METHOD,this,Modifier.PUBLIC,UnresolvedType.OBJECT,"clone",new UnresolvedType[]{});
+        // return new ResolvedMember[]{cloneMethod};
+        return ResolvedMember.NONE;
+    }
+
+    public final ResolvedType[] getDeclaredInterfaces() {
+        return new ResolvedType[] { world.getCoreType(CLONEABLE), world.getCoreType(SERIALIZABLE) };
+    }
+
+    public final ResolvedMember[] getDeclaredPointcuts() {
+        return ResolvedMember.NONE;
+    }
+
+    public boolean hasAnnotation(UnresolvedType ofType) {
+        return false;
+    }
+
+    public final ResolvedType getSuperclass() {
+        return world.getCoreType(OBJECT);
+    }
+
+    public final boolean isAssignableFrom(ResolvedType o) {
+        if (!o.isArray())
+            return false;
+        if (o.getComponentType().isPrimitiveType()) {
+            return o.equals(this);
+        } else {
+            return getComponentType().resolve(world).isAssignableFrom(o.getComponentType().resolve(world));
+        }
+    }
+
+    public boolean isAssignableFrom(ResolvedType o, boolean allowMissing) {
+        return isAssignableFrom(o);
+    }
+
+    public final boolean isCoerceableFrom(ResolvedType o) {
+        if (o.equals(UnresolvedType.OBJECT) || o.equals(UnresolvedType.SERIALIZABLE) || o.equals(UnresolvedType.CLONEABLE)) {
+            return true;
+        }
+        if (!o.isArray())
+            return false;
+        if (o.getComponentType().isPrimitiveType()) {
+            return o.equals(this);
+        } else {
+            return getComponentType().resolve(world).isCoerceableFrom(o.getComponentType().resolve(world));
+        }
+    }
+
+    public final int getModifiers() {
+        int mask = Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED;
+        return (componentType.getModifiers() & mask) | Modifier.FINAL;
+    }
+
+    public UnresolvedType getComponentType() {
+        return componentType;
+    }
+
+    public ResolvedType getResolvedComponentType() {
+        return componentType;
+    }
+
+    public ISourceContext getSourceContext() {
+        return getResolvedComponentType().getSourceContext();
+    }
+
+
+    // Methods overridden from ReferenceType follow
+
+    public TypeVariable[] getTypeVariables() {
+        if (this.typeVariables == null) {
+            this.typeVariables = componentType.getTypeVariables();
+            for (int i = 0; i < this.typeVariables.length; i++) {
+                this.typeVariables[i].resolve(world);
+            }
+        }
+        return this.typeVariables;
+    }
+
+    public boolean isAnnotation() {
+        return false;
+    }
+
+    public boolean isAnonymous() {
+        return false;
+    }
+
+    public boolean isAnnotationStyleAspect() {
+        return false;
+    }
+
+	public boolean isAspect() {
+        return false;
+    }
+
+    public boolean isPrimitiveType() {
+        return typeKind == TypeKind.PRIMITIVE;
+    }
+
+    public boolean isSimpleType() {
+        return typeKind == TypeKind.SIMPLE;
+    }
+
+    public boolean isRawType() {
+        return typeKind == TypeKind.RAW;
+    }
+
+    public boolean isGenericType() {
+        return typeKind == TypeKind.GENERIC;
+    }
+
+    public boolean isParameterizedType() {
+        return typeKind == TypeKind.PARAMETERIZED;
+    }
+
+    public boolean isTypeVariableReference() {
+        return typeKind == TypeKind.TYPE_VARIABLE;
+    }
+
+    public boolean isGenericWildcard() {
+        return typeKind == TypeKind.WILDCARD;
+    }
+    
+	public boolean isEnum() {
+        return false;
+    }
+
+	public boolean isNested() {
+        return false;
+    }
+
+    public boolean isClass() {
+        return false;
+    }
+
+    public boolean canAnnotationTargetType() {
+        return false;
+    }
+   	
+   	public AnnotationTargetKind[] getAnnotationTargetKinds() {
+        return null;
+    }
+
+    public boolean isAnnotationWithRuntimeRetention() {
+        return false;
+    }
+}
@@ -848,7 +848,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
     // ---- types
     public static ResolvedType makeArray(ResolvedType type, int dim) {
     	if (dim == 0) return type;
-    	ResolvedType array = new Array("[" + type.getSignature(),"["+type.getErasureSignature(),type.getWorld(),type);
+    	ResolvedType array = new ArrayReferenceType("[" + type.getSignature(),"["+type.getErasureSignature(),type.getWorld(),type);
     	return makeArray(array,dim-1);
     }
 
@@ -70,7 +70,7 @@ public class TypeVariableReferenceType extends BoundedReferenceType implements T
 
 	public UnresolvedType parameterize(Map typeBindings) {
 		UnresolvedType ut = (UnresolvedType) typeBindings.get(getName());
-		if (ut!=null) return ut;
+		if (ut!=null) return world.resolve(ut);
 		return this;
 	}
 
@@ -271,7 +271,7 @@ public abstract class World implements Dump.INode {
         if (ty.isArray()) {
         	ResolvedType componentType = resolve(ty.getComponentType(),allowMissing);
         	//String brackets = signature.substring(0,signature.lastIndexOf("[")+1);
-            ret = new ResolvedType.Array(signature, "["+componentType.getErasureSignature(),
+            ret = new ArrayReferenceType(signature, "["+componentType.getErasureSignature(),
             		                     this, 
             		                     componentType);
         } else {
@@ -3,11 +3,20 @@
 <!-- AspectJ v1.6.0 Tests -->
 <suite>
 
+   <ajc-test dir="bugs160/pr167197" title="generic type parameterized with array type">
+     <compile options="-1.5" files="AspectBreaker.java"/>
+   </ajc-test>
+   
    <ajc-test dir="bugs160/pr180264" title="classcastexception on array type">
      <compile options="-warn:+uselessTypeCheck" files="Foo.java,Main.java"/>
    </ajc-test>
 
-   <ajc-test dir="bugs160/pr201748" title="itd with array">
+   <ajc-test dir="bugs160/pr167197" title="generic type parameterized with array type - 2">
+     <compile options="-1.5" files="Breaker2.java"/>
+     <run class="Breaker2"/>
+   </ajc-test>
+   
+	<ajc-test dir="bugs160/pr201748" title="itd with array">
      <compile files="Foo.java">
        <message kind="error" text="Type mismatch: cannot convert from Factory[] to Factory"/>
      </compile>
@@ -128,11 +128,11 @@ public class ReferenceType extends ResolvedType {
 		typeKind=TypeKind.GENERIC;
 	}
 
-    public final boolean isClass() {
+    public boolean isClass() {
     	return delegate.isClass();
     }
 
-    public final boolean isGenericType() {
+    public boolean isGenericType() {
     	return !isParameterizedType() && !isRawType() && delegate.isGeneric();
     }
 
@@ -201,7 +201,7 @@ public class ReferenceType extends ResolvedType {
     }
 
     // true iff the statement "this = (ThisType) other" would compile
-    public final boolean isCoerceableFrom(ResolvedType o) {
+    public boolean isCoerceableFrom(ResolvedType o) {
         ResolvedType other = o.resolve(world);
 
         if (this.isAssignableFrom(other) || other.isAssignableFrom(this)) {
@@ -273,12 +273,12 @@ public class ReferenceType extends ResolvedType {
     	return false;
     }
 
-    public final boolean isAssignableFrom(ResolvedType other) {
+    public boolean isAssignableFrom(ResolvedType other) {
     	return isAssignableFrom(other,false);
     }
 
     // true iff the statement "this = other" would compile.
-    public final boolean isAssignableFrom(ResolvedType other,boolean allowMissing) {
+    public boolean isAssignableFrom(ResolvedType other,boolean allowMissing) {
        	if (other.isPrimitiveType()) {
     		if (!world.isInJava5Mode()) return false;
     		if (ResolvedType.validBoxing.contains(this.getSignature()+other.getSignature())) return true;
@@ -0,0 +1,22 @@
+import java.util.ArrayList;
+
+public class AspectBreaker extends ArrayList<ICounterValue[]> {
+	private static final long serialVersionUID = 1L;
+	
+    public AspectBreaker() {
+    }
+
+    public boolean test(ICounterValue[] obj) {
+        this.size();
+        
+        return false;    	
+    }
+}
+
+interface ICounterValue {
+	
+}
+
+aspect X {
+  before(): call(* *(..)) {}
+}
@@ -45,6 +45,10 @@ public class Ajc154Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 //		runTest("new pointcut designators in a reference pointcut");
 //	}
 
+	//public void testGenericTypeParameterizedWithArrayType_pr167197() { runTest("generic type parameterized with array type");}
+	
+	
+	//public void testWrongNumberOfTypeParameters_pr176991() { runTest("wrong number of type parameters");}
 	public void testItdOnGenericInnerInterface_pr203646() { runTest("npe with itd on inner generic interface");}
 	public void testItdOnGenericInnerInterface_pr203646_A() { runTest("npe with itd on inner generic interface - exampleA");}
 	public void testItdOnGenericInnerInterface_pr203646_B() { runTest("npe with itd on inner generic interface - exampleB");}
@@ -3,6 +3,15 @@
 <!-- AspectJ v1.6.0 Tests -->
 <suite>
 
+   <ajc-test dir="bugs154/pr176991" title="wrong number of type parameters">
+     <compile options="-1.5" files="AspectJBugTestCase.java"/>
+   </ajc-test>
+   
+   <ajc-test dir="bugs154/pr167197" title="generic type parameterized with array type">
+     <compile options="-1.5" files="AspectBreaker.java"/>
+   </ajc-test>
+   
+   
    <ajc-test dir="bugs154/pr203646" title="npe with itd on inner generic interface">
      <compile options="-1.5" files="Bang.java"/>
      <!--compile options="-1.5 -emacssym" files="Bang.java"/-->
