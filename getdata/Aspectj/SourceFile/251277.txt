@@ -13,15 +13,15 @@
 package org.aspectj.ajdt.internal.core.builder;
 
 import java.io.File;
-//import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.PrintWriter;
 
+import junit.framework.AssertionFailedError;
 import junit.framework.TestCase;
 
 import org.aspectj.ajdt.StreamPrintWriter;
-import org.aspectj.ajdt.ajc.*;
-import org.aspectj.asm.AsmManager;
+import org.aspectj.ajdt.ajc.AjdtAjcTests;
+import org.aspectj.ajdt.ajc.BuildArgParser;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.MessageHandler;
 import org.aspectj.bridge.MessageWriter;
@@ -29,350 +29,334 @@ import org.aspectj.tools.ajc.Ajc;
 
 public class AjBuildManagerTest extends TestCase {
 
-	private StreamPrintWriter outputWriter = new StreamPrintWriter(new PrintWriter(System.out));	
-	private MessageWriter messageWriter = new MessageWriter(outputWriter, false);
+	private final StreamPrintWriter outputWriter = new StreamPrintWriter(new PrintWriter(System.out));
+	private final MessageWriter messageWriter = new MessageWriter(outputWriter, false);
 	public static File source1 = new File(AjdtAjcTests.TESTDATA_DIR, "src1/A.java");
 	public static File source2 = new File(AjdtAjcTests.TESTDATA_DIR, "src1/Hello.java");
 	public static File source3 = new File(AjdtAjcTests.TESTDATA_DIR, "src1/X.java");
 
-    
-    /**
-     * @throws AssertionFailedError unless handler has 0 messages
-     * worse than warning, or the one message is 
-     * a warning about aspectjrt.jar
-     */
-    public static void assertCompileMessagesValid(MessageHandler handler) {
-        assertTrue("null handler", null != handler);
-        final int numMessages = handler.numMessages(IMessage.WARNING, true);
-        if (1 == numMessages) { // permit aspectjrt.jar warning
-            IMessage m = handler.getMessages(IMessage.WARNING, true)[0];            
-            if (!(m.isWarning() && (-1 != m.getMessage().indexOf("aspectjrt.jar")))) {
-                assertTrue(handler.toString(), false);
-            }            
-        } else if (0 != numMessages) {
-            assertTrue(handler.toString(), false);
-        }
-    }
+	/**
+	 * @throws AssertionFailedError unless handler has 0 messages worse than warning, or the one message is a warning about
+	 *         aspectjrt.jar
+	 */
+	public static void assertCompileMessagesValid(MessageHandler handler) {
+		assertTrue("null handler", null != handler);
+		final int numMessages = handler.numMessages(IMessage.WARNING, true);
+		if (1 == numMessages) { // permit aspectjrt.jar warning
+			IMessage m = handler.getMessages(IMessage.WARNING, true)[0];
+			if (!(m.isWarning() && (-1 != m.getMessage().indexOf("aspectjrt.jar")))) {
+				assertTrue(handler.toString(), false);
+			}
+		} else if (0 != numMessages) {
+			assertTrue(handler.toString(), false);
+		}
+	}
 
 	public AjBuildManagerTest(String name) {
 		super(name);
 	}
-	
-	public void testSimpleStructure() throws IOException /*, CoreException */ {
-		
+
+	public void testSimpleStructure() throws IOException /* , CoreException */{
+
 		AjBuildManager manager = new AjBuildManager(messageWriter);
 		BuildArgParser parser = new BuildArgParser(messageWriter);
 		String javaClassPath = System.getProperty("java.class.path");
 		String sandboxName = Ajc.createEmptySandbox().getAbsolutePath();
-        AjBuildConfig buildConfig = 
-			parser.genBuildConfig(new String[] { 
-				"-d", sandboxName, 
-				"-classpath",
-				javaClassPath,
-				AjdtAjcTests.TESTDATA_PATH 
-                + "/src1/A.java",
-//				EajcModuleTests.TESTDATA_PATH + "/src1/Hello.java",
-				 });
-        String err = parser.getOtherMessages(true);		
-        assertTrue(err, null == err);
-        manager.setStructureModel(AsmManager.getDefault().getHierarchy());
+		AjBuildConfig buildConfig = parser.genBuildConfig(new String[] { "-d", sandboxName, "-classpath", javaClassPath,
+				AjdtAjcTests.TESTDATA_PATH + "/src1/A.java",
+		// EajcModuleTests.TESTDATA_PATH + "/src1/Hello.java",
+				});
+		String err = parser.getOtherMessages(true);
+		assertTrue(err, null == err);
+		// manager.setStructureModel(AsmManager.getDefault().getHierarchy());
 		MessageHandler handler = new MessageHandler();
-        manager.batchBuild(buildConfig, handler);
-        assertCompileMessagesValid(handler);	
-//		System.out.println(
-//			">> model: \n" + 
-//			StructureModelManager.INSTANCE.getStructureModel().getRoot().toLongString()
-//		);
-//		
-//		System.out.println(
-//			">> children: \n" + 
-//			((StructureNode)StructureModelManager.INSTANCE.getStructureModel().getRoot().getChildren().get(0)).getChildren()
-//		);
+		manager.batchBuild(buildConfig, handler);
+		assertCompileMessagesValid(handler);
+		// System.out.println(
+		// ">> model: \n" +
+		// StructureModelManager.INSTANCE.getStructureModel().getRoot().toLongString()
+		// );
+		//		
+		// System.out.println(
+		// ">> children: \n" +
+		// ((StructureNode)StructureModelManager.INSTANCE.getStructureModel().getRoot().getChildren().get(0)).getChildren()
+		// );
 	}
-		
-	  
-	
 
-	//XXX add test for resource deltas
-//
-//	public void testUpdateBuildConfig() {
-//		final File FILE_1 = new File("testdata/testclasses/Temp1.java");
-//		final File FILE_2 = new File("testdata/testclasses/Temp2.java");
-//		final File FILE_3 = new File("testdata/testclasses/Temp3.java");
-//		List files = new ArrayList();
-//		files.add(FILE_1);
-//		files.add(FILE_2);
-//		
-//		AjBuildManager manager = new AjBuildManager(messageWriter);
-//		AjBuildConfig buildConfig = new AjBuildConfig();
-//		manager.buildConfig = buildConfig;
-//		buildConfig.setFiles(files);
-//		
-//		manager.updateBuildConfig(buildConfig);
-//		assertTrue("no change", manager.deletedFiles.isEmpty());
-//		
-//		AjBuildConfig newConfig = new AjBuildConfig();
-//		newConfig.getFiles().add(FILE_1);
-//		newConfig.getFiles().add(FILE_2);
-//		newConfig.getFiles().add(FILE_3);
-//		manager.updateBuildConfig(newConfig);
-//		assertTrue("added file", manager.deletedFiles.isEmpty());
-//		assertTrue(manager.addedFiles.size() == 1);
-//		assertTrue(manager.addedFiles.contains(FILE_3));
-//		
-//		newConfig = new AjBuildConfig();
-//		newConfig.getFiles().add(FILE_3);
-//		manager.updateBuildConfig(newConfig);
-//		assertTrue("deleted 2 files", manager.addedFiles.isEmpty());
-//		assertTrue(manager.deletedFiles.size() == 2);
-//		assertTrue(manager.deletedFiles.contains(FILE_1));		
-//
-//		newConfig = new AjBuildConfig();
-//		newConfig.getFiles().add(FILE_2);
-//		manager.updateBuildConfig(newConfig);
-//		assertTrue("added file", manager.addedFiles.size() == 1);
-//		assertTrue("deleted file", manager.deletedFiles.size() == 1);
-//		assertTrue(manager.deletedFiles.size() == 1);
-//		assertTrue(manager.addedFiles.contains(FILE_2));	
-//		assertTrue(manager.deletedFiles.contains(FILE_3));
-//	}	
-//
-//	/**
-//	 * Pretends that the files 'have been' modified in the future and waits.  
-//	 * Tests:
-//	 * 1) no change, 
-//	 * 2) added file, 
-//	 * 3) removed file 
-//	 * 
-//	 * XXX should just test modified
-//	 */ 
-//	public void testGetModifiedFiles() throws IOException, InterruptedException {
-//		final File TEMP_1 = new File("testdata/testclasses/TempChanged.java");
-//		final File EXISTS_2 = new File("testdata/testclasses/p1/Foo.java");
-//		final File NEW = new File("testdata/testclasses/TempNew.java");
-//		NEW.delete();
-//		touch(TEMP_1, false);
-//		List files = new ArrayList();
-//		files.add(TEMP_1);
-//		files.add(EXISTS_2);
-//		
-//		assertTrue("input files", TEMP_1.exists() && EXISTS_2.exists());
-//		assertTrue("new file", !NEW.exists());
-//
-//		Thread.sleep(100);
-//		long lastBuildTime = System.currentTimeMillis();
-//		
-//		AjBuildManager manager = new AjBuildManager(messageWriter);
-//		manager.buildConfig = new AjBuildConfig();
-//		manager.buildConfig.setFiles(files);
-//		Collection changedFiles = manager.getModifiedFiles(lastBuildTime);
-//		assertTrue("nothing changed: " + changedFiles, changedFiles.isEmpty());
-//
-//		lastBuildTime = System.currentTimeMillis();
-//		Thread.sleep(100);
-//	
-//		touch(NEW, false);
-//
-//		//NEW.createNewFile();
-//		files.add(NEW);
-//		changedFiles = manager.getModifiedFiles(lastBuildTime);
-//		assertTrue("new file: " + changedFiles, changedFiles.contains(NEW));
-//		  
-//		lastBuildTime = System.currentTimeMillis();
-//		Thread.sleep(100);
-//
-//		files.remove(NEW);
-//		changedFiles = manager.getModifiedFiles(lastBuildTime);
-//		assertTrue("nothing changed", changedFiles.isEmpty());
-//		
-//		lastBuildTime = System.currentTimeMillis();
-//		Thread.sleep(100);
-//		
-//		touch(TEMP_1, true);
-//		changedFiles = manager.getModifiedFiles(lastBuildTime);
-//		assertTrue("touched file: " + changedFiles, changedFiles.contains(TEMP_1));
-//		
-//		lastBuildTime = System.currentTimeMillis();
-//		Thread.sleep(100);
-//
-//		files.remove(NEW);
-//		changedFiles = manager.getModifiedFiles(lastBuildTime);
-//		assertTrue("nothing changed", changedFiles.isEmpty());
-//		
-//		TEMP_1.delete();
-//		NEW.delete();
-//	}
-	
+	// XXX add test for resource deltas
+	//
+	// public void testUpdateBuildConfig() {
+	// final File FILE_1 = new File("testdata/testclasses/Temp1.java");
+	// final File FILE_2 = new File("testdata/testclasses/Temp2.java");
+	// final File FILE_3 = new File("testdata/testclasses/Temp3.java");
+	// List files = new ArrayList();
+	// files.add(FILE_1);
+	// files.add(FILE_2);
+	//		
+	// AjBuildManager manager = new AjBuildManager(messageWriter);
+	// AjBuildConfig buildConfig = new AjBuildConfig();
+	// manager.buildConfig = buildConfig;
+	// buildConfig.setFiles(files);
+	//		
+	// manager.updateBuildConfig(buildConfig);
+	// assertTrue("no change", manager.deletedFiles.isEmpty());
+	//		
+	// AjBuildConfig newConfig = new AjBuildConfig();
+	// newConfig.getFiles().add(FILE_1);
+	// newConfig.getFiles().add(FILE_2);
+	// newConfig.getFiles().add(FILE_3);
+	// manager.updateBuildConfig(newConfig);
+	// assertTrue("added file", manager.deletedFiles.isEmpty());
+	// assertTrue(manager.addedFiles.size() == 1);
+	// assertTrue(manager.addedFiles.contains(FILE_3));
+	//		
+	// newConfig = new AjBuildConfig();
+	// newConfig.getFiles().add(FILE_3);
+	// manager.updateBuildConfig(newConfig);
+	// assertTrue("deleted 2 files", manager.addedFiles.isEmpty());
+	// assertTrue(manager.deletedFiles.size() == 2);
+	// assertTrue(manager.deletedFiles.contains(FILE_1));
+	//
+	// newConfig = new AjBuildConfig();
+	// newConfig.getFiles().add(FILE_2);
+	// manager.updateBuildConfig(newConfig);
+	// assertTrue("added file", manager.addedFiles.size() == 1);
+	// assertTrue("deleted file", manager.deletedFiles.size() == 1);
+	// assertTrue(manager.deletedFiles.size() == 1);
+	// assertTrue(manager.addedFiles.contains(FILE_2));
+	// assertTrue(manager.deletedFiles.contains(FILE_3));
+	// }
+	//
+	// /**
+	// * Pretends that the files 'have been' modified in the future and waits.
+	// * Tests:
+	// * 1) no change,
+	// * 2) added file,
+	// * 3) removed file
+	// *
+	// * XXX should just test modified
+	// */
+	// public void testGetModifiedFiles() throws IOException, InterruptedException {
+	// final File TEMP_1 = new File("testdata/testclasses/TempChanged.java");
+	// final File EXISTS_2 = new File("testdata/testclasses/p1/Foo.java");
+	// final File NEW = new File("testdata/testclasses/TempNew.java");
+	// NEW.delete();
+	// touch(TEMP_1, false);
+	// List files = new ArrayList();
+	// files.add(TEMP_1);
+	// files.add(EXISTS_2);
+	//		
+	// assertTrue("input files", TEMP_1.exists() && EXISTS_2.exists());
+	// assertTrue("new file", !NEW.exists());
+	//
+	// Thread.sleep(100);
+	// long lastBuildTime = System.currentTimeMillis();
+	//		
+	// AjBuildManager manager = new AjBuildManager(messageWriter);
+	// manager.buildConfig = new AjBuildConfig();
+	// manager.buildConfig.setFiles(files);
+	// Collection changedFiles = manager.getModifiedFiles(lastBuildTime);
+	// assertTrue("nothing changed: " + changedFiles, changedFiles.isEmpty());
+	//
+	// lastBuildTime = System.currentTimeMillis();
+	// Thread.sleep(100);
+	//	
+	// touch(NEW, false);
+	//
+	// //NEW.createNewFile();
+	// files.add(NEW);
+	// changedFiles = manager.getModifiedFiles(lastBuildTime);
+	// assertTrue("new file: " + changedFiles, changedFiles.contains(NEW));
+	//		  
+	// lastBuildTime = System.currentTimeMillis();
+	// Thread.sleep(100);
+	//
+	// files.remove(NEW);
+	// changedFiles = manager.getModifiedFiles(lastBuildTime);
+	// assertTrue("nothing changed", changedFiles.isEmpty());
+	//		
+	// lastBuildTime = System.currentTimeMillis();
+	// Thread.sleep(100);
+	//		
+	// touch(TEMP_1, true);
+	// changedFiles = manager.getModifiedFiles(lastBuildTime);
+	// assertTrue("touched file: " + changedFiles, changedFiles.contains(TEMP_1));
+	//		
+	// lastBuildTime = System.currentTimeMillis();
+	// Thread.sleep(100);
+	//
+	// files.remove(NEW);
+	// changedFiles = manager.getModifiedFiles(lastBuildTime);
+	// assertTrue("nothing changed", changedFiles.isEmpty());
+	//		
+	// TEMP_1.delete();
+	// NEW.delete();
+	// }
+
 	// don't do delta's anymore
-//	public void testMakeDeltas() throws IOException, InterruptedException {
-//		AjBuildManager manager = new AjBuildManager(messageWriter);
-//		manager.buildConfig = new AjBuildConfig();
-//		List sourceRoots = new ArrayList();
-//		sourceRoots.add(new File("out"));
-//		manager.buildConfig.setSourceRoots(sourceRoots);
-//		assertTrue(manager.testInit(messageWriter));
-//		List modified = Arrays.asList(new File[] { new File("A.java"), new File("B.java") });
-//		List deleted = Arrays.asList(new File[] { new File("X.java") });
-//		SimpleLookupTable deltas = new SimpleLookupTable();
-//		manager.makeDeltas(
-//			deltas,
-//			modified, 
-//			deleted, 
-//			((File)manager.buildConfig.getSourceRoots().get(0)).getPath());
-//		
-//		ResourceDelta d = (ResourceDelta)deltas.get(manager.getJavaBuilder().currentProject);
-//		assertNotNull(d);
-//		
-//		assertEquals(d.getAffectedChildren().length, 3);
-//		//XXX do more testing of children
-//	}
-//	
-//	// XXX should this be working??
-//	public void testDeleteRealFiles() throws CoreException, IOException {
-//		AjBuildManager manager = new AjBuildManager(messageWriter);
-//		manager.buildConfig = new AjBuildConfig();
-//		List sourceRoots = new ArrayList();
-//		sourceRoots.add(new File("testdata/src1"));
-//		manager.buildConfig.setSourceRoots(sourceRoots);
-//		manager.buildConfig.setOutputDir(new File("out"));
-//		assertTrue(manager.testInit(messageWriter));
-//		
-//		File realClassFile = new File("out/X.class");
-//		touch(realClassFile, false);
-//		
-//		assertTrue(realClassFile.exists());
-//		
-//		IFile classfile = manager.classFileCache.getFile(new Path("X.class"));
-//		classfile.create(FileUtil.getStreamFromZip("testdata/testclasses.jar", "Hello.class"), true, null);
-//		assertTrue(classfile.exists());
-//		
-//		manager.addAspectClassFilesToWeaver();
-//		
-//		classfile.delete(true, false, null);
-//		assertTrue(realClassFile.exists());
-//		
-//		manager.addAspectClassFilesToWeaver();
-//		
-//		assertTrue(!realClassFile.exists());	
-//		
-//	}
-	
-	//!!!
-//	public void testIncrementalCompilerCall() throws IOException, InterruptedException, CoreException {
-//		AjBuildManager manager = new AjBuildManager(messageWriter);
-//
-//		manager.buildConfig = new AjBuildConfig();
-//		List roots = new ArrayList();
-//		roots.add(new File("testdata/src1"));
-//        manager.testInit(messageWriter);
-//		manager.buildConfig.setSourceRoots(roots);
-//		assertTrue(manager.testInit(messageWriter));
-//		List modified = Arrays.asList(new File[] { source1, source2 });
-//		List deleted = Arrays.asList(new File[] { source3 });
-//		SimpleLookupTable deltas = new SimpleLookupTable();
-//		manager.makeDeltas(
-//			deltas,
-//			modified, 
-//			deleted, 
-//			((File)manager.buildConfig.getSourceRoots().get(0)).getAbsolutePath());
-//		
-//		JavaBuilder jbuilder = manager.getJavaBuilder();
-//		jbuilder.lastState = new State(jbuilder);
-//		jbuilder.binaryLocationsPerProject = new SimpleLookupTable();
-//
-//        AjBuildManager.IncrementalBuilder builder 
-//            = manager.getIncrementalBuilder(messageWriter); // XXX trap errors
-//		TestNotifier testNotifier =  new TestNotifier(builder, jbuilder.currentProject);
-//		jbuilder.notifier = testNotifier;
-//                
-//		IContainer[] sourceFolders = new IContainer[] { 
-//			new FilesystemFolder(((File)manager.buildConfig.getSourceRoots().get(0)).getAbsolutePath())
-//		};
-//		builder.setSourceFolders(sourceFolders);
-//		testNotifier.builder = builder;
-//		
-//		IFile classfile = manager.classFileCache.getFile(new Path("X.class"));
-//		classfile.create(new ByteArrayInputStream(new byte[] {1,2,3}), true, null);
-//		
-//		assertTrue(classfile.exists());
-//		
-//		
-//		try {
-//            manager.testSetHandler(messageWriter);
-//			boolean succeeded = builder.build(deltas);
-//		} catch (NonLocalExit nle) {
-//			assertEquals(nle.getExitCode(), 0);
-//		} finally {
-//            manager.testSetHandler(null);
-//        }
-//		
-//		assertTrue(!classfile.exists());
-//	}
-//	
-//	static class TestNotifier extends BuildNotifier {
-//		int state = 0;
-//		AjBuildManager.IncrementalBuilder builder;
-//		
-//		public TestNotifier(AjBuildManager.IncrementalBuilder builder, IProject project) {
-//			super(null, project);
-//			this.builder = builder;
-//		}
-//
-//
-//		public void updateProgressDelta(float percentWorked) {
-//			switch(state) {
-//				case 0:
-//					checkInitialConfig();
-//					break;
-//				case 1:
-//					checkBinaryResources();
-//					break;
-//				case 2:
-//					checkAffectedFiles();
-//					break;
-//			}	
-//			state += 1;
-//		}
-//
-//		private void checkBinaryResources() {
-//		}
-//
-//
-//		private void checkInitialConfig() {
-//			Collection files = builder.getLocations();
-//			//System.out.println("initial: " + files);
-//		}
-//
-//		private void checkAffectedFiles() {
-//			Collection files = builder.getLocations();
-//			TestUtil.assertSetEquals(Arrays.asList(new String[] { 
-//				source1.getAbsolutePath().replace(File.separatorChar, '/'),
-//				source2.getAbsolutePath().replace(File.separatorChar, '/') }), files);
-//			throw new NonLocalExit(0);
-//		}
-//	}
+	// public void testMakeDeltas() throws IOException, InterruptedException {
+	// AjBuildManager manager = new AjBuildManager(messageWriter);
+	// manager.buildConfig = new AjBuildConfig();
+	// List sourceRoots = new ArrayList();
+	// sourceRoots.add(new File("out"));
+	// manager.buildConfig.setSourceRoots(sourceRoots);
+	// assertTrue(manager.testInit(messageWriter));
+	// List modified = Arrays.asList(new File[] { new File("A.java"), new File("B.java") });
+	// List deleted = Arrays.asList(new File[] { new File("X.java") });
+	// SimpleLookupTable deltas = new SimpleLookupTable();
+	// manager.makeDeltas(
+	// deltas,
+	// modified,
+	// deleted,
+	// ((File)manager.buildConfig.getSourceRoots().get(0)).getPath());
+	//		
+	// ResourceDelta d = (ResourceDelta)deltas.get(manager.getJavaBuilder().currentProject);
+	// assertNotNull(d);
+	//		
+	// assertEquals(d.getAffectedChildren().length, 3);
+	// //XXX do more testing of children
+	// }
+	//	
+	// // XXX should this be working??
+	// public void testDeleteRealFiles() throws CoreException, IOException {
+	// AjBuildManager manager = new AjBuildManager(messageWriter);
+	// manager.buildConfig = new AjBuildConfig();
+	// List sourceRoots = new ArrayList();
+	// sourceRoots.add(new File("testdata/src1"));
+	// manager.buildConfig.setSourceRoots(sourceRoots);
+	// manager.buildConfig.setOutputDir(new File("out"));
+	// assertTrue(manager.testInit(messageWriter));
+	//		
+	// File realClassFile = new File("out/X.class");
+	// touch(realClassFile, false);
+	//		
+	// assertTrue(realClassFile.exists());
+	//		
+	// IFile classfile = manager.classFileCache.getFile(new Path("X.class"));
+	// classfile.create(FileUtil.getStreamFromZip("testdata/testclasses.jar", "Hello.class"), true, null);
+	// assertTrue(classfile.exists());
+	//		
+	// manager.addAspectClassFilesToWeaver();
+	//		
+	// classfile.delete(true, false, null);
+	// assertTrue(realClassFile.exists());
+	//		
+	// manager.addAspectClassFilesToWeaver();
+	//		
+	// assertTrue(!realClassFile.exists());
+	//		
+	// }
 
-//	private void touch(File file, boolean isAppend) throws IOException {
-//		FileOutputStream s = new FileOutputStream(file.getAbsolutePath(), isAppend);
-//		s.write(new byte[] {1,2,3});
-//		s.close();
-//	}
+	// !!!
+	// public void testIncrementalCompilerCall() throws IOException, InterruptedException, CoreException {
+	// AjBuildManager manager = new AjBuildManager(messageWriter);
+	//
+	// manager.buildConfig = new AjBuildConfig();
+	// List roots = new ArrayList();
+	// roots.add(new File("testdata/src1"));
+	// manager.testInit(messageWriter);
+	// manager.buildConfig.setSourceRoots(roots);
+	// assertTrue(manager.testInit(messageWriter));
+	// List modified = Arrays.asList(new File[] { source1, source2 });
+	// List deleted = Arrays.asList(new File[] { source3 });
+	// SimpleLookupTable deltas = new SimpleLookupTable();
+	// manager.makeDeltas(
+	// deltas,
+	// modified,
+	// deleted,
+	// ((File)manager.buildConfig.getSourceRoots().get(0)).getAbsolutePath());
+	//		
+	// JavaBuilder jbuilder = manager.getJavaBuilder();
+	// jbuilder.lastState = new State(jbuilder);
+	// jbuilder.binaryLocationsPerProject = new SimpleLookupTable();
+	//
+	// AjBuildManager.IncrementalBuilder builder
+	// = manager.getIncrementalBuilder(messageWriter); // XXX trap errors
+	// TestNotifier testNotifier = new TestNotifier(builder, jbuilder.currentProject);
+	// jbuilder.notifier = testNotifier;
+	//                
+	// IContainer[] sourceFolders = new IContainer[] {
+	// new FilesystemFolder(((File)manager.buildConfig.getSourceRoots().get(0)).getAbsolutePath())
+	// };
+	// builder.setSourceFolders(sourceFolders);
+	// testNotifier.builder = builder;
+	//		
+	// IFile classfile = manager.classFileCache.getFile(new Path("X.class"));
+	// classfile.create(new ByteArrayInputStream(new byte[] {1,2,3}), true, null);
+	//		
+	// assertTrue(classfile.exists());
+	//		
+	//		
+	// try {
+	// manager.testSetHandler(messageWriter);
+	// boolean succeeded = builder.build(deltas);
+	// } catch (NonLocalExit nle) {
+	// assertEquals(nle.getExitCode(), 0);
+	// } finally {
+	// manager.testSetHandler(null);
+	// }
+	//		
+	// assertTrue(!classfile.exists());
+	// }
+	//	
+	// static class TestNotifier extends BuildNotifier {
+	// int state = 0;
+	// AjBuildManager.IncrementalBuilder builder;
+	//		
+	// public TestNotifier(AjBuildManager.IncrementalBuilder builder, IProject project) {
+	// super(null, project);
+	// this.builder = builder;
+	// }
+	//
+	//
+	// public void updateProgressDelta(float percentWorked) {
+	// switch(state) {
+	// case 0:
+	// checkInitialConfig();
+	// break;
+	// case 1:
+	// checkBinaryResources();
+	// break;
+	// case 2:
+	// checkAffectedFiles();
+	// break;
+	// }
+	// state += 1;
+	// }
+	//
+	// private void checkBinaryResources() {
+	// }
+	//
+	//
+	// private void checkInitialConfig() {
+	// Collection files = builder.getLocations();
+	// //System.out.println("initial: " + files);
+	// }
+	//
+	// private void checkAffectedFiles() {
+	// Collection files = builder.getLocations();
+	// TestUtil.assertSetEquals(Arrays.asList(new String[] {
+	// source1.getAbsolutePath().replace(File.separatorChar, '/'),
+	// source2.getAbsolutePath().replace(File.separatorChar, '/') }), files);
+	// throw new NonLocalExit(0);
+	// }
+	// }
 
+	// private void touch(File file, boolean isAppend) throws IOException {
+	// FileOutputStream s = new FileOutputStream(file.getAbsolutePath(), isAppend);
+	// s.write(new byte[] {1,2,3});
+	// s.close();
+	// }
 
 	/*
-	 * jar
-	 * directory
-	 * source directory
-	 * container
+	 * jar directory source directory container
 	 */
-//	public void testMakeClasspathLocations() {
-//		List classpath = new ArrayList();
-//		classpath.add(
-//		
-//		AjBuildConfig config = new AjBuildConfig();
-//		config.setClasspath()
-//	}
-	
-//	private void testClasspathLocation(String loca
-
+	// public void testMakeClasspathLocations() {
+	// List classpath = new ArrayList();
+	// classpath.add(
+	//		
+	// AjBuildConfig config = new AjBuildConfig();
+	// config.setClasspath()
+	// }
+	// private void testClasspathLocation(String loca
 }
@@ -23,7 +23,6 @@ import java.util.StringTokenizer;
 
 import junit.framework.AssertionFailedError;
 
-
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.asm.IRelationshipMap;
@@ -38,103 +37,104 @@ import org.aspectj.bridge.context.CompilationAndWeavingContext;
 import org.aspectj.util.FileUtil;
 
 /**
- * The Ajc class is intended for use as part of a unit-test suite, it drives
- * the AspectJ compiler and lets you check the compilation results. Compilations
- * run in a sandbox that is created in C:\temp\ajcSandbox or /tmp/ajcSandbox
- * depending on your platform.
+ * The Ajc class is intended for use as part of a unit-test suite, it drives the AspectJ compiler and lets you check the compilation
+ * results. Compilations run in a sandbox that is created in C:\temp\ajcSandbox or /tmp/ajcSandbox depending on your platform.
  * <p>
- * The expected usage of Ajc is through the TestCase superclass,
- * AjcTestCase, which provides helper methods that conveniently 
- * drive the base functions exposed by this class.
+ * The expected usage of Ajc is through the TestCase superclass, AjcTestCase, which provides helper methods that conveniently drive
+ * the base functions exposed by this class.
  * </p>
+ * 
  * @see org.aspectj.tools.ajc.AjcTestCase
  */
 public class Ajc {
 
 	private static final String SANDBOX_NAME = "ajcSandbox";
 
-	private static final String TESTER_PATH = 
-		".."+File.separator+"testing-client"+File.separator+"bin"
-	    + File.pathSeparator+".."+File.separator+"runtime"   +File.separator+"bin"
-		+ File.pathSeparator+".."+File.separator+"aspectj5rt"+File.separator+"bin"
-        + File.pathSeparator+".."+File.separator+"lib"       +File.separator+"junit"+File.separator+"junit.jar"
-        + File.pathSeparator+".."+File.separator+"bridge"    +File.separator+"bin" 
-        + File.pathSeparator+".."+File.separator+"loadtime"  +File.separator+"bin"
-        + File.pathSeparator+".."+File.separator+"weaver"    +File.separator+"bin"
-        + File.pathSeparator+".."+File.separator+"weaver5"   +File.separator+"bin"
-        
-        // When the build machine executes the tests, it is using code built into jars rather than code build into
-        // bin directories.  This means for the necessary types to be found we have to put these jars on the classpath:
-		+ File.pathSeparator+".."+File.separator+"aj-build"+File.separator+"jars"+File.separator+"bridge.jar"
-        + File.pathSeparator+".."+File.separator+"aj-build"+File.separator+"jars"+File.separator+"util.jar"
-		+ File.pathSeparator+".."+File.separator+"aj-build"+File.separator+"jars"+File.separator+"loadtime.jar"
-		+ File.pathSeparator+".."+File.separator+"aj-build"+File.separator+"jars"+File.separator+"weaver.jar"
-		+ File.pathSeparator+".."+File.separator+"aj-build"+File.separator+"jars"+File.separator+"weaver5.jar"
-		+ File.pathSeparator+".."+File.separator+"aj-build"+File.separator+"jars"+File.separator+"asm.jar"
-		+ File.pathSeparator+".."+File.separator+"lib"     +File.separator+"test"+File.separator+"testing-client.jar"
-		// hmmm, this next one should perhaps point to an aj-build jar...
-		+ File.pathSeparator+".."+File.separator+"lib"     +File.separator+"test"+File.separator+"aspectjrt.jar"
-		;
-
+	private static final String TESTER_PATH = ".." + File.separator + "testing-client" + File.separator + "bin"
+			+ File.pathSeparator + ".." + File.separator + "runtime" + File.separator + "bin" + File.pathSeparator + ".."
+			+ File.separator + "aspectj5rt" + File.separator + "bin" + File.pathSeparator + ".." + File.separator + "lib"
+			+ File.separator + "junit" + File.separator + "junit.jar" + File.pathSeparator + ".." + File.separator + "bridge"
+			+ File.separator + "bin" + File.pathSeparator + ".." + File.separator + "loadtime" + File.separator
+			+ "bin"
+			+ File.pathSeparator
+			+ ".."
+			+ File.separator
+			+ "weaver"
+			+ File.separator
+			+ "bin"
+			+ File.pathSeparator
+			+ ".."
+			+ File.separator
+			+ "weaver5"
+			+ File.separator
+			+ "bin"
 
+			// When the build machine executes the tests, it is using code built into jars rather than code build into
+			// bin directories. This means for the necessary types to be found we have to put these jars on the classpath:
+			+ File.pathSeparator + ".." + File.separator + "aj-build" + File.separator + "jars" + File.separator + "bridge.jar"
+			+ File.pathSeparator + ".." + File.separator + "aj-build" + File.separator + "jars" + File.separator + "util.jar"
+			+ File.pathSeparator + ".." + File.separator + "aj-build" + File.separator + "jars" + File.separator + "loadtime.jar"
+			+ File.pathSeparator + ".." + File.separator + "aj-build" + File.separator + "jars" + File.separator + "weaver.jar"
+			+ File.pathSeparator + ".." + File.separator + "aj-build" + File.separator + "jars" + File.separator + "weaver5.jar"
+			+ File.pathSeparator + ".." + File.separator + "aj-build" + File.separator + "jars" + File.separator + "asm.jar"
+			+ File.pathSeparator + ".." + File.separator + "lib" + File.separator + "test" + File.separator + "testing-client.jar"
+			// hmmm, this next one should perhaps point to an aj-build jar...
+			+ File.pathSeparator + ".." + File.separator + "lib" + File.separator + "test" + File.separator + "aspectjrt.jar";
 
 	private CompilationResult result;
 	private File sandbox;
 	private File baseDir;
-	private Main main;
+	private final Main main;
 	private String[] ajcArgs;
 	private int incrementalStage = 10;
 	private boolean shouldEmptySandbox = true;
-	private AjcCommandController controller;
-	private static boolean verbose = System.getProperty("org.aspectj.tools.ajc.Ajc.verbose","true").equals("true");
+	private final AjcCommandController controller;
+	private static boolean verbose = System.getProperty("org.aspectj.tools.ajc.Ajc.verbose", "true").equals("true");
 
 	/**
-	 * Constructs a new Ajc instance, with a new AspectJ compiler
-	 * inside. 
+	 * Constructs a new Ajc instance, with a new AspectJ compiler inside.
 	 */
 	public Ajc() {
 		main = new Main();
 		controller = new AjcCommandController();
 		main.setController(controller);
 	}
-	
+
 	/**
-	 * By default, each call to <code>compile</code> creates a new
-	 * sandbox (C:\temp\ajcSandbox\ajtTestxxx.tmp, or /tmp/ajcSandbox/ajcTestxxx.tmp
-	 * depending on your platform). To write a test that performs multiple
-	 * (non-incremental) compiles, building on the results of previous
-	 * compilations, set 'should empty sandbox' to false after the first
-	 * compile, which will cause subsequent compiles in the test to use the
-	 * same directory and contents.
+	 * By default, each call to <code>compile</code> creates a new sandbox (C:\temp\ajcSandbox\ajtTestxxx.tmp, or
+	 * /tmp/ajcSandbox/ajcTestxxx.tmp depending on your platform). To write a test that performs multiple (non-incremental)
+	 * compiles, building on the results of previous compilations, set 'should empty sandbox' to false after the first compile,
+	 * which will cause subsequent compiles in the test to use the same directory and contents.
 	 */
 	public void setShouldEmptySandbox(boolean empty) {
 		this.shouldEmptySandbox = empty;
 	}
-	
+
 	/**
-	 * Call the compiler with the given arguments (args are exactly the same
-	 * as you would pass to ajc on the command-line). The results of the 
-	 * compile are returned in a <code>CompilationResult</code>, which
-	 * provides for easy testing of results.
-	 * <p>The compilation happens in a sandbox (C:\temp\ajcSandbox\ajTestxxx.tmp or
-	 * /tmp/ajcSandbox/ajcTestxxx.tmp depending on platform). Compiler arguments are
-	 * adapted to the sandbox as follows.</p>
-	 * <p>For every file or directory listed in an argument (source file, or component
-	 * of inpath, aspectpath, sourceroots, classpath,...), if the file is specified
-	 * using an absolute path then it is left unchanged, but if the file is specified
-	 * using a relative path, and a base directory (see setBaseDir) has been provided,
-	 * then files/directories are copied from the base directory to the sandbox, and the
-	 * compiler arguments adjusted to reflect their new location. 
+	 * Call the compiler with the given arguments (args are exactly the same as you would pass to ajc on the command-line). The
+	 * results of the compile are returned in a <code>CompilationResult</code>, which provides for easy testing of results.
+	 * <p>
+	 * The compilation happens in a sandbox (C:\temp\ajcSandbox\ajTestxxx.tmp or /tmp/ajcSandbox/ajcTestxxx.tmp depending on
+	 * platform). Compiler arguments are adapted to the sandbox as follows.
 	 * </p>
-	 * <p>For example, given a baseDir of "tests/pr12345" and a compile command: 
-	 * "ajc src/A.java src/B.java", the files in 
+	 * <p>
+	 * For every file or directory listed in an argument (source file, or component of inpath, aspectpath, sourceroots,
+	 * classpath,...), if the file is specified using an absolute path then it is left unchanged, but if the file is specified using
+	 * a relative path, and a base directory (see setBaseDir) has been provided, then files/directories are copied from the base
+	 * directory to the sandbox, and the compiler arguments adjusted to reflect their new location.
+	 * </p>
+	 * <p>
+	 * For example, given a baseDir of "tests/pr12345" and a compile command: "ajc src/A.java src/B.java", the files in
+	 * 
 	 * <pre>
 	 *    tests/pr12345/
 	 *                  src/
 	 *                      A.java
 	 *                      B.java
 	 * </pre>
+	 * 
 	 * are copied to:
+	 * 
 	 * <pre>
 	 *     ajcSandbox/ajcTestxxx.tmp/
 	 *                               src/
@@ -142,34 +142,31 @@ public class Ajc {
 	 *                                   B.java
 	 * </pre>
 	 * <p>
-	 * If no classpath is specified (no -classpath in the arguments) the classpath will
-	 * be set to include the sandbox directory, testing-client/bin (for the Tester class), 
-	 * and runtime/bin (for the AspectJ runtime). If a classpath <i>is</i> specified,
-	 * then any relative directories in it will be made relative to the sandbox, and
-	 * the testing-client and runtime bin directories are also added.
+	 * If no classpath is specified (no -classpath in the arguments) the classpath will be set to include the sandbox directory,
+	 * testing-client/bin (for the Tester class), and runtime/bin (for the AspectJ runtime). If a classpath <i>is</i> specified,
+	 * then any relative directories in it will be made relative to the sandbox, and the testing-client and runtime bin directories
+	 * are also added.
 	 * </p>
 	 * <p>
-	 * If no output directory is specified (no -d in the arguments), the output directory
-	 * is set to the sandbox. If a directory is specified, and the path is relative, it
-	 * will be made relative to the sandbox.
+	 * If no output directory is specified (no -d in the arguments), the output directory is set to the sandbox. If a directory is
+	 * specified, and the path is relative, it will be made relative to the sandbox.
 	 * </p>
 	 * <ul>
 	 * </ul>
 	 * </p>
-	 * @param args The compiler arguments. 
-	 * @return a CompilationResult object with all the messages produced by
-	 * the compiler, a description of the ajc command that was issued,
-	 * and the standard output and error of the compile (excluding messages
-	 * which are provided separately)
+	 * 
+	 * @param args The compiler arguments.
+	 * @return a CompilationResult object with all the messages produced by the compiler, a description of the ajc command that was
+	 *         issued, and the standard output and error of the compile (excluding messages which are provided separately)
 	 * @throws IOException
 	 * @see org.aspectj.tools.ajc.CompilationResult
 	 */
 	public CompilationResult compile(String[] args) throws IOException {
 		incrementalStage = 10;
-		return compile(args,false);
+		return compile(args, false);
 	}
-	
-	private CompilationResult compile(String[] args,boolean isIncremental) throws IOException {
+
+	private CompilationResult compile(String[] args, boolean isIncremental) throws IOException {
 		result = null;
 		ajcArgs = args;
 		ByteArrayOutputStream out = new ByteArrayOutputStream();
@@ -186,32 +183,35 @@ public class Ajc {
 		List warnings = new ArrayList();
 		List infos = new ArrayList();
 		List weaves = new ArrayList();
-		
+
 		try {
 			if (!isIncremental && shouldEmptySandbox) {
 				sandbox = createEmptySandbox();
 			}
-			args = adjustToSandbox(args,!isIncremental);
+			args = adjustToSandbox(args, !isIncremental);
 			MessageHandler holder = new MessageHandler();
 			holder.setInterceptor(new AbortInterceptor());
 			main.setHolder(holder);
-			if (incrementalStage==10 && hasSpecifiedIncremental(args)) {
-			  // important to sleep after preparing the sandbox on first incremental stage (see notes in pr90806)
-			  try { Thread.sleep(1000); } catch (Exception e) {}
+			if (incrementalStage == 10 && hasSpecifiedIncremental(args)) {
+				// important to sleep after preparing the sandbox on first incremental stage (see notes in pr90806)
+				try {
+					Thread.sleep(1000);
+				} catch (Exception e) {
+				}
 			}
 			if (isIncremental) {
 				controller.doIncremental(holder);
 			} else {
-				main.runMain(args,false);
+				main.runMain(args, false);
 			}
-			addMessagesTo(infos,holder.getMessages(IMessage.INFO,false));
-			addMessagesTo(warnings,holder.getWarnings());
-			addMessagesTo(errors,holder.getErrors());
-			addMessagesTo(fails,holder.getMessages(IMessage.FAIL,true));
-			addMessagesTo(weaves,holder.getMessages(IMessage.WEAVEINFO,false));
+			addMessagesTo(infos, holder.getMessages(IMessage.INFO, false));
+			addMessagesTo(warnings, holder.getWarnings());
+			addMessagesTo(errors, holder.getErrors());
+			addMessagesTo(fails, holder.getMessages(IMessage.FAIL, true));
+			addMessagesTo(weaves, holder.getMessages(IMessage.WEAVEINFO, false));
 			String stdOut = new String(out.toByteArray());
 			String stdErr = new String(err.toByteArray());
-			result = new CompilationResult(args,stdOut,stdErr,infos,errors,warnings,fails,weaves);
+			result = new CompilationResult(args, stdOut, stdErr, infos, errors, warnings, fails, weaves);
 		} finally {
 			System.setOut(systemOut);
 			System.setErr(systemErr);
@@ -223,119 +223,126 @@ public class Ajc {
 		}
 		return result;
 	}
-	
+
 	private boolean hasSpecifiedIncremental(String[] args) {
-		if (args==null) return false;
+		if (args == null)
+			return false;
 		for (int i = 0; i < args.length; i++) {
-			if (args[i].equals("-incremental")) return true;
+			if (args[i].equals("-incremental"))
+				return true;
 		}
 		return false;
 	}
 
 	/**
-	 * After compiling for the first time with compile(), if the -incremental option was specified
-	 * you can do as many subsequent incremental compiles as you like by calling this method.
+	 * After compiling for the first time with compile(), if the -incremental option was specified you can do as many subsequent
+	 * incremental compiles as you like by calling this method.
 	 * <p>
-	 * Throws an IllegalStateException if you try and call this method without first doing a compile
-	 * that specified the -incremental option.
+	 * Throws an IllegalStateException if you try and call this method without first doing a compile that specified the -incremental
+	 * option.
 	 * </p>
+	 * 
 	 * @return A CompilationResult giving the results of the most recent increment.
 	 * @throws IOException
 	 */
 	public CompilationResult doIncrementalCompile() throws IOException {
 		if ((ajcArgs == null) || !isIncremental(ajcArgs)) {
-			throw new IllegalStateException("Can't do incremental compile unless -incremental specified and first compile has taken place");
+			throw new IllegalStateException(
+					"Can't do incremental compile unless -incremental specified and first compile has taken place");
 		}
 		incrementalStage += 10;
-		return compile(ajcArgs,true);
+		return compile(ajcArgs, true);
 	}
-	
+
 	/**
-	 * Return the result of the last compile or incremental compile. This is the same as the 
-	 * return value from the compile() or doIncrementalCompile() methods.
+	 * Return the result of the last compile or incremental compile. This is the same as the return value from the compile() or
+	 * doIncrementalCompile() methods.
 	 */
-	public CompilationResult getLastCompilationResult() { 
+	public CompilationResult getLastCompilationResult() {
 		return result;
 	}
-	
+
 	/**
 	 * Get the sandbox directory used for the compilation.
 	 */
 	public File getSandboxDirectory() {
-		if (sandbox == null) {sandbox = createEmptySandbox();}
+		if (sandbox == null) {
+			sandbox = createEmptySandbox();
+		}
 		return sandbox;
 	}
-	
+
 	/**
-	 * Set the base directory relative to which all relative paths specified in the arguments to a compile will be
-	 * interpreted.
+	 * Set the base directory relative to which all relative paths specified in the arguments to a compile will be interpreted.
 	 */
 	public void setBaseDir(File dir) {
-		if ((dir != null) && !dir.isDirectory()) throw new IllegalArgumentException(dir.getPath() + " is not a directory");
+		if ((dir != null) && !dir.isDirectory())
+			throw new IllegalArgumentException(dir.getPath() + " is not a directory");
 		baseDir = dir;
 	}
-	
+
 	private void addMessagesTo(List aList, IMessage[] messages) {
 		for (int i = 0; i < messages.length; i++) {
 			aList.add(messages[i]);
 		}
 	}
-	
+
 	private boolean isIncremental(String[] args) {
 		for (int i = 0; i < args.length; i++) {
-			if (args[i].trim().equals("-incremental")) return true;
+			if (args[i].trim().equals("-incremental"))
+				return true;
 		}
 		return false;
 	}
 
 	public static File createEmptySandbox() {
 		File sandbox;
-		
+
 		String os = System.getProperty("os.name");
 		File tempDir = null;
 		// AMC - I did this rather than use the JDK default as I hate having to go look
 		// in c:\documents and settings\......... for the results of a failed test.
 		if (os.startsWith("Windows")) {
 			tempDir = new File("C:\\temp");
-			if (!tempDir.exists()) {tempDir.mkdir();}
+			if (!tempDir.exists()) {
+				tempDir.mkdir();
+			}
 		} else {
-		 	tempDir = new File("/tmp");
+			tempDir = new File("/tmp");
 		}
-		File sandboxRoot = new File(tempDir,SANDBOX_NAME);
+		File sandboxRoot = new File(tempDir, SANDBOX_NAME);
 		if (!sandboxRoot.exists()) {
 			sandboxRoot.mkdir();
 		}
-	
-	
+
 		try {
 			File workspace = new File(".." + File.separator);
 			String workspaceName = workspace.getCanonicalPath();
 			int index = workspaceName.lastIndexOf(File.separator);
-			workspaceName = workspaceName.substring(index+1);
-	
-			File workspaceRoot = new File(sandboxRoot,workspaceName);
+			workspaceName = workspaceName.substring(index + 1);
+
+			File workspaceRoot = new File(sandboxRoot, workspaceName);
 			if (!workspaceRoot.exists()) {
 				workspaceRoot.mkdir();
 			}
-			
+
 			FileUtil.deleteContents(workspaceRoot);
-	
-			sandbox = File.createTempFile("ajcTest",".tmp",workspaceRoot);
+
+			sandbox = File.createTempFile("ajcTest", ".tmp", workspaceRoot);
 			sandbox.delete();
 			sandbox.mkdir();
-	
+
 		} catch (IOException ioEx) {
 			throw new AssertionFailedError("Unable to create sandbox directory for test");
 		}
-		
+
 		return sandbox;
 	}
 
 	/**
-	 * Make every relative file name and dir be absolute under sandbox
-	 * Add TESTER_PATH to classpath
+	 * Make every relative file name and dir be absolute under sandbox Add TESTER_PATH to classpath
 	 */
-	private String[] adjustToSandbox(String[] args,boolean doCopy) throws IOException {
+	private String[] adjustToSandbox(String[] args, boolean doCopy) throws IOException {
 		String[] newArgs = new String[args.length];
 		boolean hasClasspath = false;
 		boolean hasOutdir = false;
@@ -343,118 +350,114 @@ public class Ajc {
 			newArgs[i] = args[i];
 			if (FileUtil.hasSourceSuffix(args[i])) {
 				File f = new File(args[i]);
-				//newArgs[i] = new File(baseDir,args[i]).getAbsolutePath(); // might be quicker?
-				newArgs[i] = adjustFileOrDir(f,doCopy).getAbsolutePath();
+				// newArgs[i] = new File(baseDir,args[i]).getAbsolutePath(); // might be quicker?
+				newArgs[i] = adjustFileOrDir(f, doCopy).getAbsolutePath();
 			} else {
-				if ((args[i].equals("-aspectpath") ||
-				     args[i].equals("-inpath") ||
-					 args[i].equals("-injars") ||
-					 args[i].equals("-outjar") ||
-					 args[i].equals("-classpath") ||
-					 args[i].equals("-sourceroots") ||
-					 args[i].equals("-Xlintfile") ||
-					 args[i].equals("-extdirs") ||
-					 args[i].equals("-d")) &&
-					args.length > (i+1)) {
+				if ((args[i].equals("-aspectpath") || args[i].equals("-inpath") || args[i].equals("-injars")
+						|| args[i].equals("-outjar") || args[i].equals("-classpath") || args[i].equals("-sourceroots")
+						|| args[i].equals("-Xlintfile") || args[i].equals("-extdirs") || args[i].equals("-d"))
+						&& args.length > (i + 1)) {
 					newArgs[i] = args[i];
 					StringBuffer buff = new StringBuffer();
 					boolean copyThisTime = doCopy;
-					if (args[i].equals("-d")) { 
+					if (args[i].equals("-d")) {
 						copyThisTime = false;
 						hasOutdir = true;
 					}
-				    StringTokenizer strTok = new StringTokenizer(args[++i],File.pathSeparator);
-				    while (strTok.hasMoreTokens()) {
-				    	File f = new File(strTok.nextToken());
-				    	buff.append(adjustFileOrDir(f,copyThisTime).getAbsolutePath());
-				    	if (strTok.hasMoreTokens()) buff.append(File.pathSeparator);
-				    }
-				    newArgs[i] = buff.toString();
-				    if (args[i-1].equals("-classpath")) {
-				    	hasClasspath = true;
-				    	newArgs[i] = newArgs[i] + File.pathSeparator + TESTER_PATH + File.pathSeparator + getSandboxDirectory().getAbsolutePath();
-				    }
+					StringTokenizer strTok = new StringTokenizer(args[++i], File.pathSeparator);
+					while (strTok.hasMoreTokens()) {
+						File f = new File(strTok.nextToken());
+						buff.append(adjustFileOrDir(f, copyThisTime).getAbsolutePath());
+						if (strTok.hasMoreTokens())
+							buff.append(File.pathSeparator);
+					}
+					newArgs[i] = buff.toString();
+					if (args[i - 1].equals("-classpath")) {
+						hasClasspath = true;
+						newArgs[i] = newArgs[i] + File.pathSeparator + TESTER_PATH + File.pathSeparator
+								+ getSandboxDirectory().getAbsolutePath();
+					}
 				} else {
 					// could be resource file
 					File f = new File(args[i]);
 					if (f.exists()) {
-						newArgs[i] = adjustFileOrDir(f,doCopy).getAbsolutePath();
+						newArgs[i] = adjustFileOrDir(f, doCopy).getAbsolutePath();
 					}
 				}
-			} 
+			}
 		}
 		if (!hasClasspath) {
 			String[] oldArgs = newArgs;
 			newArgs = new String[oldArgs.length + 2];
-			System.arraycopy(oldArgs,0,newArgs,0,oldArgs.length);
+			System.arraycopy(oldArgs, 0, newArgs, 0, oldArgs.length);
 			newArgs[oldArgs.length] = "-classpath";
 			newArgs[oldArgs.length + 1] = TESTER_PATH + File.pathSeparator + getSandboxDirectory().getAbsolutePath();
 		}
 		if (!hasOutdir) {
 			String[] oldArgs = newArgs;
 			newArgs = new String[oldArgs.length + 2];
-			System.arraycopy(oldArgs,0,newArgs,0,oldArgs.length);
+			System.arraycopy(oldArgs, 0, newArgs, 0, oldArgs.length);
 			newArgs[oldArgs.length] = "-d";
-			newArgs[oldArgs.length + 1] = getSandboxDirectory().getPath();			
+			newArgs[oldArgs.length + 1] = getSandboxDirectory().getPath();
 		}
 		return newArgs;
 	}
-	
-	private File adjustFileOrDir(File from,boolean doCopy) throws IOException {
+
+	private File adjustFileOrDir(File from, boolean doCopy) throws IOException {
 		File to = from;
 		File ret = from;
 		if (!from.isAbsolute()) {
-			ret = new File(sandbox,from.getPath());
+			ret = new File(sandbox, from.getPath());
 			File fromParent = from.getParentFile();
 			String relativeToPath = (fromParent != null) ? (fromParent.getPath() + File.separator) : "";
 			if (baseDir != null) {
-				from = new File(baseDir,from.getPath());
+				from = new File(baseDir, from.getPath());
 			}
-			if (!from.exists()) return ret;
+			if (!from.exists())
+				return ret;
 			if (doCopy) {
 				// harness requires that any files with the same name, and a different extension,
 				// get copied too (e.g. .out, .err, .event files)
 				if (from.isFile()) {
-					final String prefix = from.getName().substring(0,from.getName().lastIndexOf('.'));
+					final String prefix = from.getName().substring(0, from.getName().lastIndexOf('.'));
 					String[] toCopy = from.getParentFile().list(new FilenameFilter() {
 						public boolean accept(File dir, String name) {
-							if (name.indexOf('.') == -1) return false;
-							String toMatch = name.substring(0,name.lastIndexOf('.'));
+							if (name.indexOf('.') == -1)
+								return false;
+							String toMatch = name.substring(0, name.lastIndexOf('.'));
 							return (toMatch.equals(prefix));
 						}
-						});
+					});
 					for (int i = 0; i < toCopy.length; i++) {
 						String toPath = relativeToPath + toCopy[i];
-						to = new File(sandbox,toPath);
-						FileUtil.copyFile(new File(from.getParentFile(),toCopy[i]),
-								          to);					
+						to = new File(sandbox, toPath);
+						FileUtil.copyFile(new File(from.getParentFile(), toCopy[i]), to);
 					}
 				} else {
-					FileUtil.copyFile(from,ret);
+					FileUtil.copyFile(from, ret);
 				}
 			}
 		}
 		return ret;
 	}
-	
-	public static void dumpAJDEStructureModel(String prefix) {
-		dumpAJDEStructureModel(prefix, false);
+
+	public static void dumpAJDEStructureModel(AsmManager model, String prefix) {
+		dumpAJDEStructureModel(model, prefix, false);
 	}
-	
-	public static void dumpAJDEStructureModel(String prefix, boolean useHandles) {
+
+	public static void dumpAJDEStructureModel(AsmManager model, String prefix, boolean useHandles) {
 		System.out.println("======================================");//$NON-NLS-1$
-		System.out.println("start of AJDE structure model:"+prefix); //$NON-NLS-1$
+		System.out.println("start of AJDE structure model:" + prefix); //$NON-NLS-1$
 
-		IRelationshipMap asmRelMap = AsmManager.getDefault().getRelationshipMap();
+		IRelationshipMap asmRelMap = model.getRelationshipMap();
 		for (Iterator iter = asmRelMap.getEntries().iterator(); iter.hasNext();) {
 			String sourceOfRelationship = (String) iter.next();
-			System.err.println("Examining source relationship handle: "+sourceOfRelationship);
+			System.err.println("Examining source relationship handle: " + sourceOfRelationship);
 			List relationships = null;
 			if (useHandles) {
 				relationships = asmRelMap.get(sourceOfRelationship);
 			} else {
-				IProgramElement ipe = AsmManager.getDefault().getHierarchy()
-										.findElementForHandle(sourceOfRelationship);
+				IProgramElement ipe = model.getHierarchy().findElementForHandle(sourceOfRelationship);
 				relationships = asmRelMap.get(ipe);
 			}
 			if (relationships != null) {
@@ -463,14 +466,14 @@ public class Ajc {
 					List targets = rel.getTargets();
 					for (Iterator iterator2 = targets.iterator(); iterator2.hasNext();) {
 						String t = (String) iterator2.next();
-						IProgramElement link = AsmManager.getDefault().getHierarchy().findElementForHandle(t);
+						IProgramElement link = model.getHierarchy().findElementForHandle(t);
 						System.out.println(""); //$NON-NLS-1$
 						System.out.println("      sourceOfRelationship " + sourceOfRelationship); //$NON-NLS-1$
 						System.out.println("          relationship " + rel.getName()); //$NON-NLS-1$
 						System.out.println("              target " + link.getName()); //$NON-NLS-1$
 					}
 				}
-				
+
 			}
 		}
 		System.out.println("End of AJDE structure model"); //$NON-NLS-1$
@@ -479,30 +482,34 @@ public class Ajc {
 }
 
 /*
- * So that we can drive incremental compilation easily from a unit
- * test.
+ * So that we can drive incremental compilation easily from a unit test.
  */
 class AjcCommandController extends Main.CommandController {
-	
+
 	private ICommand command;
-	
-	/* (non-Javadoc)
+
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.tools.ajc.Main.CommandController#doRepeatCommand()
 	 */
 	boolean doRepeatCommand(ICommand command) {
 		this.command = command;
-		return false;  // ensure that control returns to caller
+		return false; // ensure that control returns to caller
 	}
-	
-	/* (non-Javadoc)
+
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see org.aspectj.tools.ajc.Main.CommandController#running()
 	 */
 	public boolean running() {
-		return false;  // so that we can come back for more...
+		return false; // so that we can come back for more...
 	}
-	
+
 	public void doIncremental(IMessageHandler handler) {
-		if (command == null) throw new IllegalArgumentException("Can't repeat command until it has executed at least once!");
+		if (command == null)
+			throw new IllegalArgumentException("Can't repeat command until it has executed at least once!");
 		command.repeatCommand(handler);
 	}
 }
@@ -517,13 +524,14 @@ class AbortInterceptor implements IMessageHandler {
 			if (message.getThrown() != null) {
 				System.err.println("caused by " + message.getThrown().toString());
 			}
-			
-		}  // allow message to accumulate... 
+
+		} // allow message to accumulate...
 		return false;
 	}
 
 	public boolean isIgnoring(Kind kind) {
-		if (kind != IMessage.ABORT) return true;
+		if (kind != IMessage.ABORT)
+			return true;
 		return false;
 	}
 
@@ -34,17 +34,16 @@ import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.testing.util.TestUtil;
 
 /**
- * A TestCase class that acts as the superclass for all test cases wishing
- * to drive the ajc compiler.
+ * A TestCase class that acts as the superclass for all test cases wishing to drive the ajc compiler.
  * <p>
- * This class provides a number of utility methods that make programmatic 
- * testing of the compiler easy. See AjcTestCaseTest for a couple of simple
- * tests written using this class.
+ * This class provides a number of utility methods that make programmatic testing of the compiler easy. See AjcTestCaseTest for a
+ * couple of simple tests written using this class.
  * </p>
  * <p>
- * See the XMLBasedAjcTestCase subclass for TestCase class that can be 
- * used to drive compiler tests based on an ajcTests.xml format test
- * specification file.</p>
+ * See the XMLBasedAjcTestCase subclass for TestCase class that can be used to drive compiler tests based on an ajcTests.xml format
+ * test specification file.
+ * </p>
+ * 
  * @see org.aspectj.tools.ajc.AjcTestCase.Message
  * @see org.aspectj.tools.ajc.AjcTestCase.MessageSpec
  * @see org.aspectj.tools.ajc.AjcTestCase.RunResult
@@ -52,51 +51,56 @@ import org.aspectj.testing.util.TestUtil;
  * @see org.aspectj.testing.XMLBasedAjcTestCase
  */
 public class AjcTestCase extends TestCase {
-	
+
 	private RunResult lastRunResult;
-	
+
 	/**
-	 * The Ajc (compiler) instance used for thet test. Created afresh
-	 * during the test setup.
+	 * The Ajc (compiler) instance used for the test. Created afresh during the test setup.
 	 */
 	protected Ajc ajc;
-	
-	public static final String DEFAULT_CLASSPATH_ENTRIES = 
-		File.pathSeparator + ".." + File.separator + "bridge" + File.separator + "bin"
-		+ File.pathSeparator + ".." + File.separator + "util" + File.separator + "bin"
-        + File.pathSeparator+ ".."+File.separator+"loadtime"+File.separator+"bin" 
-        + File.pathSeparator+ ".."+File.separator+"weaver"+File.separator+"bin" 
-        + File.pathSeparator+ ".."+File.separator+"weaver5"+File.separator+"bin" 
-        + File.pathSeparator+ ".."+File.separator+"asm"+File.separator+"bin" 
-		+ File.pathSeparator + ".." + File.separator + "testing-client" + File.separator + "bin"
-        + File.pathSeparator + ".." + File.separator + "runtime" + File.separator + "bin"
-		+ File.pathSeparator + ".." + File.separator + "aspectj5rt" + File.separator + "bin"
-		+ File.pathSeparator+ ".."+File.separator+"lib"+File.separator+"junit"+File.separator+"junit.jar"
-        + File.pathSeparator+ ".."+File.separator+"lib"+File.separator+"bcel"+File.separator+"bcel.jar" 
-        + File.pathSeparator+ ".."+File.separator+"lib"+File.separator+"bcel"+File.separator+"bcel-verifier.jar" 
-        
-        // When the build machine executes the tests, it is using code built into jars rather than code build into
-        // bin directories.  This means for the necessary types to be found we have to put these jars on the classpath:
-		+ File.pathSeparator+".."+File.separator+"aj-build"+File.separator+"jars"+File.separator+"bridge.jar"
-        + File.pathSeparator+".."+File.separator+"aj-build"+File.separator+"jars"+File.separator+"util.jar"
-		+ File.pathSeparator+".."+File.separator+"aj-build"+File.separator+"jars"+File.separator+"loadtime.jar"
-		+ File.pathSeparator+".."+File.separator+"aj-build"+File.separator+"jars"+File.separator+"weaver.jar"
-		+ File.pathSeparator+".."+File.separator+"aj-build"+File.separator+"jars"+File.separator+"weaver5.jar"
-		+ File.pathSeparator+".."+File.separator+"aj-build"+File.separator+"jars"+File.separator+"asm.jar"
-		+ File.pathSeparator+".."+File.separator+"lib"     +File.separator+"test"+File.separator+"testing-client.jar"
-		// hmmm, this next one should perhaps point to an aj-build jar...
-		+ File.pathSeparator+".."+File.separator+"lib"     +File.separator+"test"+File.separator+"aspectjrt.jar"
-        ;
-	
-	public static final String JAVA5_CLASSPATH_ENTRIES = 
-		File.pathSeparator + ".." + File.separator + "aspectj5rt" + File.separator + "bin"
-        + File.pathSeparator+ ".."+File.separator+"loadtime5"+File.separator+"bin" 
-        + File.pathSeparator+ ".."+File.separator+"weaver5"+File.separator+"bin" 
-
-		+ File.pathSeparator+".."+File.separator+"aj-build"+File.separator+"jars"+File.separator+"aspectj5rt.jar"
-		+ File.pathSeparator+".."+File.separator+"aj-build"+File.separator+"jars"+File.separator+"loadtime5.jar"
-		+ File.pathSeparator+".."+File.separator+"aj-build"+File.separator+"jars"+File.separator+"weaver5.jar";
-        
+
+	public static final String DEFAULT_CLASSPATH_ENTRIES = File.pathSeparator + ".." + File.separator + "bridge" + File.separator
+			+ "bin" + File.pathSeparator + ".." + File.separator + "util" + File.separator + "bin" + File.pathSeparator + ".."
+			+ File.separator + "loadtime" + File.separator + "bin" + File.pathSeparator + ".." + File.separator + "weaver"
+			+ File.separator + "bin" + File.pathSeparator + ".." + File.separator + "weaver5" + File.separator + "bin"
+			+ File.pathSeparator + ".." + File.separator + "asm" + File.separator + "bin" + File.pathSeparator + ".."
+			+ File.separator + "testing-client" + File.separator + "bin" + File.pathSeparator + ".." + File.separator + "runtime"
+			+ File.separator + "bin" + File.pathSeparator + ".." + File.separator + "aspectj5rt" + File.separator + "bin"
+			+ File.pathSeparator + ".." + File.separator + "lib" + File.separator + "junit" + File.separator + "junit.jar"
+			+ File.pathSeparator + ".." + File.separator + "lib"
+			+ File.separator
+			+ "bcel"
+			+ File.separator
+			+ "bcel.jar"
+			+ File.pathSeparator
+			+ ".."
+			+ File.separator
+			+ "lib"
+			+ File.separator
+			+ "bcel"
+			+ File.separator
+			+ "bcel-verifier.jar"
+
+			// When the build machine executes the tests, it is using code built into jars rather than code build into
+			// bin directories. This means for the necessary types to be found we have to put these jars on the classpath:
+			+ File.pathSeparator + ".." + File.separator + "aj-build" + File.separator + "jars" + File.separator + "bridge.jar"
+			+ File.pathSeparator + ".." + File.separator + "aj-build" + File.separator + "jars" + File.separator + "util.jar"
+			+ File.pathSeparator + ".." + File.separator + "aj-build" + File.separator + "jars" + File.separator + "loadtime.jar"
+			+ File.pathSeparator + ".." + File.separator + "aj-build" + File.separator + "jars" + File.separator + "weaver.jar"
+			+ File.pathSeparator + ".." + File.separator + "aj-build" + File.separator + "jars" + File.separator + "weaver5.jar"
+			+ File.pathSeparator + ".." + File.separator + "aj-build" + File.separator + "jars" + File.separator + "asm.jar"
+			+ File.pathSeparator + ".." + File.separator + "lib" + File.separator + "test" + File.separator + "testing-client.jar"
+			// hmmm, this next one should perhaps point to an aj-build jar...
+			+ File.pathSeparator + ".." + File.separator + "lib" + File.separator + "test" + File.separator + "aspectjrt.jar";
+
+	public static final String JAVA5_CLASSPATH_ENTRIES = File.pathSeparator + ".." + File.separator + "aspectj5rt" + File.separator
+			+ "bin" + File.pathSeparator + ".." + File.separator + "loadtime5" + File.separator + "bin" + File.pathSeparator + ".."
+			+ File.separator + "weaver5" + File.separator + "bin"
+
+			+ File.pathSeparator + ".." + File.separator + "aj-build" + File.separator + "jars" + File.separator + "aspectj5rt.jar"
+			+ File.pathSeparator + ".." + File.separator + "aj-build" + File.separator + "jars" + File.separator + "loadtime5.jar"
+			+ File.pathSeparator + ".." + File.separator + "aj-build" + File.separator + "jars" + File.separator + "weaver5.jar";
+
 	/*
 	 * Save reference to real stderr and stdout before starting redirection
 	 */
@@ -104,16 +108,16 @@ public class AjcTestCase extends TestCase {
 	public final static PrintStream out = System.out;
 	private final static DelegatingOutputStream delegatingErr;
 	private final static DelegatingOutputStream delegatingOut;
-	public final static boolean DEFAULT_VERBOSE = getBoolean("org.aspectj.tools.ajc.AjcTestCase.verbose",true); 
-	public final static boolean DEFAULT_ERR_VERBOSE = getBoolean("org.aspectj.tools.ajc.AjcTestCase.verbose.err",DEFAULT_VERBOSE); 
-	public final static boolean DEFAULT_OUT_VERBOSE = getBoolean("org.aspectj.tools.ajc.AjcTestCase.verbose.out",DEFAULT_VERBOSE); 
+	public final static boolean DEFAULT_VERBOSE = getBoolean("org.aspectj.tools.ajc.AjcTestCase.verbose", true);
+	public final static boolean DEFAULT_ERR_VERBOSE = getBoolean("org.aspectj.tools.ajc.AjcTestCase.verbose.err", DEFAULT_VERBOSE);
+	public final static boolean DEFAULT_OUT_VERBOSE = getBoolean("org.aspectj.tools.ajc.AjcTestCase.verbose.out", DEFAULT_VERBOSE);
 
 	/**
-	 * Helper class that represents the specification of an individual
-	 * message expected to be produced during a compilation run.
+	 * Helper class that represents the specification of an individual message expected to be produced during a compilation run.
 	 * <p>
-	 * Message objects are combined in a MessageSpec which can then be 
-	 * passed to the various assertMessage methods.</p>
+	 * Message objects are combined in a MessageSpec which can then be passed to the various assertMessage methods.
+	 * </p>
+	 * 
 	 * @see org.aspectj.tools.ajc.AjcTestCase.MessageSpec
 	 */
 	public static class Message {
@@ -121,34 +125,32 @@ public class AjcTestCase extends TestCase {
 		private String text;
 		private String sourceFileName;
 		private ISourceLocation[] seeAlsos;
-		
+
 		/**
-		 * Create a message that will match any compiler message on
-		 * the given line.
+		 * Create a message that will match any compiler message on the given line.
 		 */
 		public Message(int line) {
 			this.line = line;
 		}
-		
+
 		/**
-		 * Create a message that will match any compiler message on
-		 * the given line, where the message text contains <code>text</code>.
+		 * Create a message that will match any compiler message on the given line, where the message text contains
+		 * <code>text</code>.
 		 */
 		public Message(int line, String text) {
 			this.line = line;
 			this.text = text;
 		}
-		
+
 		/**
-		 * Create a message that will match any compiler message on
-		 * the given line, where the message text contains <code>text</code>.
+		 * Create a message that will match any compiler message on the given line, where the message text contains
+		 * <code>text</code>.
 		 * <p>
-		 * If srcFile is non-null, the source file location of the message must
-		 * end with <code>srcFile</code>.
+		 * If srcFile is non-null, the source file location of the message must end with <code>srcFile</code>.
 		 * </p>
 		 * <p>
-		 * If <code>seeAlso</code> is non-null, each source location in seeAlso
-		 * must be matched by an extraSourceLocation in the message.
+		 * If <code>seeAlso</code> is non-null, each source location in seeAlso must be matched by an extraSourceLocation in the
+		 * message.
 		 * </p>
 		 */
 		public Message(int line, String srcFile, String text, ISourceLocation[] seeAlso) {
@@ -163,15 +165,14 @@ public class AjcTestCase extends TestCase {
 						srcFileName.append(chars[i]);
 					}
 				}
-				this.sourceFileName = srcFileName.toString();			
+				this.sourceFileName = srcFileName.toString();
 			}
 			this.text = text;
 			this.seeAlsos = seeAlso;
 		}
-		
+
 		/**
-		 * Create a message spec that will match any compiler message where
-		 * the message text includes <code>text</code>.
+		 * Create a message spec that will match any compiler message where the message text includes <code>text</code>.
 		 */
 		public Message(String text) {
 			this.text = text;
@@ -206,22 +207,22 @@ public class AjcTestCase extends TestCase {
 					return false;
 				}
 				for (int i = 0; i < seeAlsos.length; i++) {
-					if (!hasAMatch(extraLocations,seeAlsos[i])) {
+					if (!hasAMatch(extraLocations, seeAlsos[i])) {
 						return false;
 					}
 				}
 			}
 			return true;
 		}
-		
-		private boolean hasAMatch(List srcLocations,ISourceLocation sLoc) {
+
+		private boolean hasAMatch(List srcLocations, ISourceLocation sLoc) {
 			for (Iterator iter = srcLocations.iterator(); iter.hasNext();) {
 				ISourceLocation thisLoc = (ISourceLocation) iter.next();
 				if (thisLoc.getLine() == sLoc.getLine()) {
 					if (thisLoc.getSourceFile().getPath().equals(sLoc.getSourceFile().getPath())) {
 						return true;
 					}
-				}				
+				}
 			}
 			return false;
 		}
@@ -259,60 +260,49 @@ public class AjcTestCase extends TestCase {
 			return buff.toString();
 		}
 	}
-	
+
 	/**
-	 * Helper class that represents the specification of a set of
-	 * messages expected to be produced from a compiler run.
+	 * Helper class that represents the specification of a set of messages expected to be produced from a compiler run.
 	 * <p>
-	 * Instances of MessageSpec are passed to the assertMessage methods
-	 * to validate <code>CompilationResult</code>s.
+	 * Instances of MessageSpec are passed to the assertMessage methods to validate <code>CompilationResult</code>s.
 	 */
 	public static class MessageSpec {
-		
+
 		/**
-		 * Convenience constant that matches a CompilationResult with
-		 * any number of information messages, but no others.
+		 * Convenience constant that matches a CompilationResult with any number of information messages, but no others.
 		 */
-		public static final MessageSpec EMPTY_MESSAGE_SET = 
-			new MessageSpec(
-					null,
-					Collections.EMPTY_LIST,
-					Collections.EMPTY_LIST,
-					Collections.EMPTY_LIST,
-					Collections.EMPTY_LIST);
-		
+		public static final MessageSpec EMPTY_MESSAGE_SET = new MessageSpec(null, Collections.EMPTY_LIST, Collections.EMPTY_LIST,
+				Collections.EMPTY_LIST, Collections.EMPTY_LIST);
+
 		boolean ignoreInfos = true;
 		public List fails;
 		public List infos;
 		public List warnings;
 		public List errors;
 		public List weaves;
-		
+
 		/**
-		 * Set to true to enable or disable comparison of information messages. 
+		 * Set to true to enable or disable comparison of information messages.
 		 */
 		public void setInfoComparison(boolean enabled) {
 			this.ignoreInfos = !enabled;
 		}
-		
+
 		/**
-		 * True if information messages are not being included in matching. 
+		 * True if information messages are not being included in matching.
 		 */
 		public boolean isIgnoringInfoMessages() {
 			return ignoreInfos;
 		}
-		
+
 		/**
-		 * Create a message specification to test a CompilationResult for a 
-		 * given set of info, warning, error, and fail messages.
-		 * @param infos The set of info messages to test for. Specifying a non-null value
-		 * for this parameter enables info message comparison.
-		 * @param warnings The set of warning messages to test for - can pass null to indicate
-		 * empty set.
-		 * @param errors The set of error messages to test for - can pass null to indicate
-		 * empty set.
-		 * @param fails The set of fail or abort messages to test for - can pass null to indicate
-		 * empty set.
+		 * Create a message specification to test a CompilationResult for a given set of info, warning, error, and fail messages.
+		 * 
+		 * @param infos The set of info messages to test for. Specifying a non-null value for this parameter enables info message
+		 *        comparison.
+		 * @param warnings The set of warning messages to test for - can pass null to indicate empty set.
+		 * @param errors The set of error messages to test for - can pass null to indicate empty set.
+		 * @param fails The set of fail or abort messages to test for - can pass null to indicate empty set.
 		 */
 		public MessageSpec(List infos, List warnings, List errors, List fails, List weaves) {
 			if (infos != null) {
@@ -326,96 +316,101 @@ public class AjcTestCase extends TestCase {
 			this.fails = ((fails == null) ? Collections.EMPTY_LIST : fails);
 			this.weaves = ((weaves == null) ? Collections.EMPTY_LIST : weaves);
 		}
-		
+
 		/**
-		 * Create a message specification to test a CompilationResult for a given
-		 * set of info, warning, and error messages. The presence of any fail or
-		 * abort messages in a CompilationResult will be a test failure.
+		 * Create a message specification to test a CompilationResult for a given set of info, warning, and error messages. The
+		 * presence of any fail or abort messages in a CompilationResult will be a test failure.
 		 */
 		public MessageSpec(List infos, List warnings, List errors) {
-			this(infos,warnings,errors,null,null);
+			this(infos, warnings, errors, null, null);
 		}
 
 		/**
-		 * Create a message specification to test a CompilationResult for a given
-		 * set of warning, and error messages. The presence of any fail or
-		 * abort messages in a CompilationResult will be a test failure. Informational
-		 * messages will be ignored.
+		 * Create a message specification to test a CompilationResult for a given set of warning, and error messages. The presence
+		 * of any fail or abort messages in a CompilationResult will be a test failure. Informational messages will be ignored.
 		 */
 		public MessageSpec(List warnings, List errors) {
-			this(null,warnings,errors,null,null);
+			this(null, warnings, errors, null, null);
 		}
 	}
-	
+
 	public static class EmptyMessageSpec extends MessageSpec {
 		public EmptyMessageSpec() {
-			super(null,null);
+			super(null, null);
 		}
 	}
-	
+
 	/**
-	 * Helper class representing the results of running a test program built
-	 * by the compiler. Provides access to the standard out and error of the
-	 * program, and the actual command that was executed.
+	 * Helper class representing the results of running a test program built by the compiler. Provides access to the standard out
+	 * and error of the program, and the actual command that was executed.
 	 */
 	public static class RunResult {
-		private String command;
-		private String stdOut;
-		private String stdErr;
-		
+		private final String command;
+		private final String stdOut;
+		private final String stdErr;
+
 		protected RunResult(String command, String stdOut, String stdErr) {
 			this.command = command;
 			this.stdOut = stdOut;
 			this.stdErr = stdErr;
 		}
-		
+
 		/**
 		 * Return the command that was executed, e.g. "java Driver".
 		 */
-		public String getCommand() { return command; }
+		public String getCommand() {
+			return command;
+		}
+
 		/**
 		 * The standard output from the run.
 		 */
-		public String getStdOut() {return stdOut;}
+		public String getStdOut() {
+			return stdOut;
+		}
+
 		/**
 		 * The standard error from the run.
 		 */
-		public String getStdErr() {return stdErr;}
-		
+		public String getStdErr() {
+			return stdErr;
+		}
+
 		/**
 		 * Returns the command that was executed to produce this result.
 		 */
-		public String toString() { return command; }
+		public String toString() {
+			return command;
+		}
 	}
-	
+
 	/**
 	 * Assert that no (non-informational) messages where produced during a compiler run.
 	 */
 	public void assertNoMessages(CompilationResult result) {
-		assertNoMessages(result,"Not expecting any compiler messages to be produced");
+		assertNoMessages(result, "Not expecting any compiler messages to be produced");
 	}
-	
+
 	/**
 	 * Assert that no (non-informational) messages where produced during a compiler run.
 	 */
 	public void assertNoMessages(CompilationResult result, String message) {
-		assertMessages(result, message,MessageSpec.EMPTY_MESSAGE_SET);
+		assertMessages(result, message, MessageSpec.EMPTY_MESSAGE_SET);
 	}
 
 	/**
-	 * Assert that messages in accordance with the <code>expected</code> message specification
-	 * where produced during a compiler run.
+	 * Assert that messages in accordance with the <code>expected</code> message specification where produced during a compiler run.
 	 */
 	public void assertMessages(CompilationResult result, MessageSpec expected) {
-		assertMessages(result, "Compilation results did not meet expected messages specification",expected);
+		assertMessages(result, "Compilation results did not meet expected messages specification", expected);
 	}
-	
+
 	/**
-	 * Assert that messages in accordance with the <code>expected</code> message specification
-	 * where produced during a compiler run.
+	 * Assert that messages in accordance with the <code>expected</code> message specification where produced during a compiler run.
 	 */
 	public void assertMessages(CompilationResult result, String message, MessageSpec expected) {
-		if (result == null) fail("Attempt to compare null compilation results against expected.");
+		if (result == null)
+			fail("Attempt to compare null compilation results against expected.");
 		List missingFails = copyAll(expected.fails);
 		List missingInfos = copyAll(expected.infos);
 		List missingWarnings = copyAll(expected.warnings);
@@ -426,33 +421,33 @@ public class AjcTestCase extends TestCase {
 		List extraWarnings = copyAll(result.getWarningMessages());
 		List extraErrors = copyAll(result.getErrorMessages());
 		List extraWeaves = copyAll(result.getWeaveMessages());
-		compare(expected.fails,result.getFailMessages(),missingFails,extraFails);
-		compare(expected.warnings,result.getWarningMessages(),missingWarnings,extraWarnings);
-		compare(expected.errors,result.getErrorMessages(),missingErrors,extraErrors);
+		compare(expected.fails, result.getFailMessages(), missingFails, extraFails);
+		compare(expected.warnings, result.getWarningMessages(), missingWarnings, extraWarnings);
+		compare(expected.errors, result.getErrorMessages(), missingErrors, extraErrors);
 		if (!expected.isIgnoringInfoMessages()) {
-			compare(expected.infos,result.getInfoMessages(),missingInfos,extraInfos);
+			compare(expected.infos, result.getInfoMessages(), missingInfos, extraInfos);
 		}
-		compare(expected.weaves,result.getWeaveMessages(),missingWeaves,extraWeaves);
+		compare(expected.weaves, result.getWeaveMessages(), missingWeaves, extraWeaves);
 
-		boolean infosEmpty = expected.isIgnoringInfoMessages() ? true: (missingInfos.isEmpty() && extraInfos.isEmpty());
-		if ( !(missingFails.isEmpty() && missingWarnings.isEmpty() && missingErrors.isEmpty() && missingWeaves.isEmpty() &&
-			   extraFails.isEmpty() && extraWarnings.isEmpty() && extraErrors.isEmpty() && extraWeaves.isEmpty() && infosEmpty)) {
+		boolean infosEmpty = expected.isIgnoringInfoMessages() ? true : (missingInfos.isEmpty() && extraInfos.isEmpty());
+		if (!(missingFails.isEmpty() && missingWarnings.isEmpty() && missingErrors.isEmpty() && missingWeaves.isEmpty()
+				&& extraFails.isEmpty() && extraWarnings.isEmpty() && extraErrors.isEmpty() && extraWeaves.isEmpty() && infosEmpty)) {
 			StringBuffer failureReport = new StringBuffer(message);
 			failureReport.append("\n");
 			if (!expected.isIgnoringInfoMessages()) {
-				addMissing(failureReport,"info",missingInfos);
+				addMissing(failureReport, "info", missingInfos);
 			}
-			addMissing(failureReport,"warning",missingWarnings);
-			addMissing(failureReport,"error",missingErrors);
-			addMissing(failureReport,"fail",missingFails);
-			addMissing(failureReport,"weaveInfo",missingWeaves);
+			addMissing(failureReport, "warning", missingWarnings);
+			addMissing(failureReport, "error", missingErrors);
+			addMissing(failureReport, "fail", missingFails);
+			addMissing(failureReport, "weaveInfo", missingWeaves);
 			if (!expected.isIgnoringInfoMessages()) {
-				addExtra(failureReport,"info",extraInfos);
+				addExtra(failureReport, "info", extraInfos);
 			}
-			addExtra(failureReport,"warning",extraWarnings);
-			addExtra(failureReport,"error",extraErrors);
-			addExtra(failureReport,"fail",extraFails);
-			addExtra(failureReport,"weaveInfo",extraWeaves);
+			addExtra(failureReport, "warning", extraWarnings);
+			addExtra(failureReport, "error", extraErrors);
+			addExtra(failureReport, "fail", extraFails);
+			addExtra(failureReport, "weaveInfo", extraWeaves);
 			failureReport.append("\ncommand was: ajc");
 			String[] args = result.getArgs();
 			for (int i = 0; i < args.length; i++) {
@@ -473,7 +468,7 @@ public class AjcTestCase extends TestCase {
 		ret.add(m1);
 		return ret;
 	}
-	
+
 	/**
 	 * Helper method to build a new message list for passing to a MessageSpec.
 	 */
@@ -481,9 +476,9 @@ public class AjcTestCase extends TestCase {
 		List ret = new ArrayList();
 		ret.add(m1);
 		ret.add(m2);
-		return ret;		
+		return ret;
 	}
-	
+
 	/**
 	 * Helper method to build a new message list for passing to a MessageSpec.
 	 */
@@ -492,9 +487,9 @@ public class AjcTestCase extends TestCase {
 		ret.add(m1);
 		ret.add(m2);
 		ret.add(m3);
-		return ret;				
+		return ret;
 	}
-	
+
 	/**
 	 * Helper method to build a new message list for passing to a MessageSpec.
 	 */
@@ -508,30 +503,30 @@ public class AjcTestCase extends TestCase {
 
 	/**
 	 * Perform a compilation and return the result.
-	 * @param baseDir the base directory relative to which all relative paths and
-	 * directories in the arguments will be interpreted.
-	 * @param args the compiler arguments, as you would specify on the command-line. 
-	 * See the Ajc class for a description of the argument processing done in
-	 * order to run the compilation in a sandbox.
-	 * @see org.aspectj.tools.ajc.Ajc  
+	 * 
+	 * @param baseDir the base directory relative to which all relative paths and directories in the arguments will be interpreted.
+	 * @param args the compiler arguments, as you would specify on the command-line. See the Ajc class for a description of the
+	 *        argument processing done in order to run the compilation in a sandbox.
+	 * @see org.aspectj.tools.ajc.Ajc
 	 */
 	public CompilationResult ajc(File baseDir, String[] args) {
 		try {
 			ajc.setBaseDir(baseDir);
-            args = fixupArgs(args);
+			args = fixupArgs(args);
 			return ajc.compile(args);
-		} catch(IOException ioEx ) {
+		} catch (IOException ioEx) {
 			fail("IOException thrown during compilation: " + ioEx);
 		}
 		return null;
 	}
-	
+
 	public File getSandboxDirectory() {
 		return ajc.getSandboxDirectory();
 	}
-	
+
 	/**
 	 * Indicate whether or not the sandbox should be emptied before the next compile.
+	 * 
 	 * @see org.aspectj.tools.ajc.Ajc#setShouldEmptySandbox(boolean)
 	 */
 	public void setShouldEmptySandbox(boolean empty) {
@@ -541,37 +536,37 @@ public class AjcTestCase extends TestCase {
 	public RunResult getLastRunResult() {
 		return lastRunResult;
 	}
-    public void testNothingForAntJUnit() {}
-    
+
+	public void testNothingForAntJUnit() {
+	}
+
 	/**
-	 * Run the given class (main method), and return the result in a RunResult. The program runs with
-	 * a classpath containing the sandbox directory, runtime, testing-client, bridge, and
-	 * util projects (all used by the Tester class), and any jars in the sandbox.
+	 * Run the given class (main method), and return the result in a RunResult. The program runs with a classpath containing the
+	 * sandbox directory, runtime, testing-client, bridge, and util projects (all used by the Tester class), and any jars in the
+	 * sandbox.
 	 */
-	public RunResult run(String className){
-		return run(className,new String[0],null);
+	public RunResult run(String className) {
+		return run(className, new String[0], null);
 	}
 
-	public RunResult run(String className, String[] args, String classpath)  {
-		return run(className,args,null,false);
+	public RunResult run(String className, String[] args, String classpath) {
+		return run(className, args, null, false);
 	}
 
-	
 	/**
-	 * Run the given class, and return the result in a RunResult. The program runs with
-	 * a classpath containing the sandbox directory, runtime, testing-client, bridge, and
-	 * util projects (all used by the Tester class), and any jars in the sandbox.
+	 * Run the given class, and return the result in a RunResult. The program runs with a classpath containing the sandbox
+	 * directory, runtime, testing-client, bridge, and util projects (all used by the Tester class), and any jars in the sandbox.
+	 * 
 	 * @param args the arguments to pass to the program.
-	 * @param classpath the execution classpath, the sandbox directory, runtime, testing-client,
-	 * bridge, and util projects will all be appended to the classpath, as will any jars in
-	 * the sandbox.
+	 * @param classpath the execution classpath, the sandbox directory, runtime, testing-client, bridge, and util projects will all
+	 *        be appended to the classpath, as will any jars in the sandbox.
 	 */
-	public RunResult run(String className, String[] args, final String classpath, boolean useLTW)  {
-	    if (args != null) {
-            for (int i = 0; i < args.length; i++) {
-                args[i] = substituteSandbox(args[i]);
-            }
-        }
+	public RunResult run(String className, String[] args, final String classpath, boolean useLTW) {
+		if (args != null) {
+			for (int i = 0; i < args.length; i++) {
+				args[i] = substituteSandbox(args[i]);
+			}
+		}
 		lastRunResult = null;
 		StringBuffer cp = new StringBuffer();
 		if (classpath != null) {
@@ -580,36 +575,35 @@ public class AjcTestCase extends TestCase {
 			cp.append(File.pathSeparator);
 		}
 		cp.append(ajc.getSandboxDirectory().getAbsolutePath());
-		getAnyJars(ajc.getSandboxDirectory(),cp);
-		
+		getAnyJars(ajc.getSandboxDirectory(), cp);
+
 		URLClassLoader sandboxLoader;
-		URLClassLoader testLoader = (URLClassLoader)getClass().getClassLoader();
+		URLClassLoader testLoader = (URLClassLoader) getClass().getClassLoader();
 		ClassLoader parentLoader = testLoader.getParent();
-		
+
 		/* Sandbox -> AspectJ -> Extension -> Bootstrap */
 		if (useLTW) {
-			
+
 			/*
-			 * Create a new AspectJ class loader using the existing test CLASSPATH 
-			 * and any missing Java 5 projects 
+			 * Create a new AspectJ class loader using the existing test CLASSPATH and any missing Java 5 projects
 			 */
 			URL[] testUrls = testLoader.getURLs();
 			URL[] java5Urls = getURLs(JAVA5_CLASSPATH_ENTRIES);
 			URL[] urls = new URL[testUrls.length + java5Urls.length];
-			System.arraycopy(testUrls,0,urls,0,testUrls.length);
-			System.arraycopy(java5Urls,0,urls,testUrls.length,java5Urls.length);
-//			ClassLoader aspectjLoader = new URLClassLoader(getURLs(DEFAULT_CLASSPATH_ENTRIES),parent);
-			ClassLoader aspectjLoader = new URLClassLoader(urls,parentLoader);
+			System.arraycopy(testUrls, 0, urls, 0, testUrls.length);
+			System.arraycopy(java5Urls, 0, urls, testUrls.length, java5Urls.length);
+			// ClassLoader aspectjLoader = new URLClassLoader(getURLs(DEFAULT_CLASSPATH_ENTRIES),parent);
+			ClassLoader aspectjLoader = new URLClassLoader(urls, parentLoader);
 			URL[] sandboxUrls = getURLs(cp.toString());
-			sandboxLoader = createWeavingClassLoader(sandboxUrls,aspectjLoader);
-//			sandboxLoader = createWeavingClassLoader(sandboxUrls,testLoader);
+			sandboxLoader = createWeavingClassLoader(sandboxUrls, aspectjLoader);
+			// sandboxLoader = createWeavingClassLoader(sandboxUrls,testLoader);
 		}
 
 		/* Sandbox + AspectJ -> Extension -> Bootstrap */
 		else {
 			cp.append(DEFAULT_CLASSPATH_ENTRIES);
 			URL[] urls = getURLs(cp.toString());
-			sandboxLoader = new URLClassLoader(urls,parentLoader);
+			sandboxLoader = new URLClassLoader(urls, parentLoader);
 		}
 
 		StringBuffer command = new StringBuffer("java -classpath ");
@@ -627,67 +621,64 @@ public class AjcTestCase extends TestCase {
 		try {
 			try {
 				Class testerClass = sandboxLoader.loadClass("org.aspectj.testing.Tester");
-				Method setBaseDir = testerClass.getDeclaredMethod("setBASEDIR",new Class[] {File.class});
-				setBaseDir.invoke(null,new Object[] {ajc.getSandboxDirectory()});
+				Method setBaseDir = testerClass.getDeclaredMethod("setBASEDIR", new Class[] { File.class });
+				setBaseDir.invoke(null, new Object[] { ajc.getSandboxDirectory() });
 			} catch (InvocationTargetException itEx) {
-				fail ("Unable to prepare org.aspectj.testing.Tester for test run: " + itEx.getTargetException());
+				fail("Unable to prepare org.aspectj.testing.Tester for test run: " + itEx.getTargetException());
 			} catch (Exception ex) {
-				fail ("Unable to prepare org.aspectj.testing.Tester for test run: " + ex);
+				fail("Unable to prepare org.aspectj.testing.Tester for test run: " + ex);
 			}
-			startCapture(baosErr,baosOut);
-			
+			startCapture(baosErr, baosOut);
+
 			/* Frameworks like XML use context class loader for dynamic loading */
 			Thread.currentThread().setContextClassLoader(sandboxLoader);
-			
+
 			Class toRun = sandboxLoader.loadClass(className);
-			Method mainMethod = toRun.getMethod("main",new Class[] {String[].class});
-			mainMethod.invoke(null,new Object[] {args});
-		} catch(ClassNotFoundException cnf) {
+			Method mainMethod = toRun.getMethod("main", new Class[] { String[].class });
+			mainMethod.invoke(null, new Object[] { args });
+		} catch (ClassNotFoundException cnf) {
 			fail("Can't find class: " + className);
-		} catch(NoSuchMethodException nsm) {
+		} catch (NoSuchMethodException nsm) {
 			fail(className + " does not have a main method");
 		} catch (IllegalAccessException illEx) {
 			fail("main method in class " + className + " is not public");
 		} catch (InvocationTargetException invTgt) {
 			// the main method threw an exception...
-            fail("Exception thrown by " + className + ".main(String[]) :" + invTgt.getTargetException());
+			fail("Exception thrown by " + className + ".main(String[]) :" + invTgt.getTargetException());
 		} finally {
 			Thread.currentThread().setContextClassLoader(contexClassLoader);
-			stopCapture(baosErr,baosOut);
-			lastRunResult = new RunResult(command.toString(),new String(baosOut.toByteArray()),new String(baosErr.toByteArray()));
+			stopCapture(baosErr, baosOut);
+			lastRunResult = new RunResult(command.toString(), new String(baosOut.toByteArray()), new String(baosErr.toByteArray()));
 		}
 		return lastRunResult;
 	}
-	
-	/* Must create weaving class loader reflectively using new parent so we 
-	 * don't have a reference to a World loaded from CLASSPATH which won't
-	 * be able to resolve Java 5 specific extensions and may cause
-	 * ClassCastExceptions
-	 */  
-	private URLClassLoader createWeavingClassLoader (URL[] urls, ClassLoader parent) {
+
+	/*
+	 * Must create weaving class loader reflectively using new parent so we don't have a reference to a World loaded from CLASSPATH
+	 * which won't be able to resolve Java 5 specific extensions and may cause ClassCastExceptions
+	 */
+	private URLClassLoader createWeavingClassLoader(URL[] urls, ClassLoader parent) {
 		URLClassLoader loader = null;
-		
+
 		try {
-			Class loaderClazz = Class.forName("org.aspectj.weaver.loadtime.WeavingURLClassLoader",false,parent);
+			Class loaderClazz = Class.forName("org.aspectj.weaver.loadtime.WeavingURLClassLoader", false, parent);
 			Class[] parameterTypes = new Class[] { urls.getClass(), ClassLoader.class };
 			Object[] parameters = new Object[] { urls, parent };
 			Constructor constructor = loaderClazz.getConstructor(parameterTypes);
-			loader = (URLClassLoader)constructor.newInstance(parameters);
-		}
-		catch (InvocationTargetException ex) {
+			loader = (URLClassLoader) constructor.newInstance(parameters);
+		} catch (InvocationTargetException ex) {
 			ex.printStackTrace();
 			fail("Cannot create weaving class loader: " + ex.getTargetException());
-		}
-		catch (Exception ex) {
+		} catch (Exception ex) {
 			ex.printStackTrace();
 			fail("Cannot create weaving class loader: " + ex.toString());
 		}
-		
+
 		return loader;
 	}
-	
-	private URL[] getURLs (String classpath) {
-		StringTokenizer strTok = new StringTokenizer(classpath,File.pathSeparator);
+
+	private URL[] getURLs(String classpath) {
+		StringTokenizer strTok = new StringTokenizer(classpath, File.pathSeparator);
 		URL[] urls = new URL[strTok.countTokens()];
 		try {
 			for (int i = 0; i < urls.length; i++) {
@@ -696,84 +687,82 @@ public class AjcTestCase extends TestCase {
 		} catch (Exception malEx) {
 			fail("Bad classpath specification: " + classpath);
 		}
-		
+
 		return urls;
 	}
 
 	private String substituteSandbox(String classpath) {
 		// the longhand form of the non 1.3 API: classpath.replace("$sandbox", ajc.getSandboxDirectory().getAbsolutePath());
-		while (classpath.indexOf("$sandbox")!=-1) {
+		while (classpath.indexOf("$sandbox") != -1) {
 			int pos = classpath.indexOf("$sandbox");
-			String firstbit = classpath.substring(0,pos);
-			String endbit = classpath.substring(pos+8);
-			classpath = firstbit+ ajc.getSandboxDirectory().getAbsolutePath()+endbit;
+			String firstbit = classpath.substring(0, pos);
+			String endbit = classpath.substring(pos + 8);
+			classpath = firstbit + ajc.getSandboxDirectory().getAbsolutePath() + endbit;
 		}
 		return classpath;
 	}
-    
-    /**
-     * Any central pre-processing of args.
-     * This supplies aspectjrt.jar if available and classpath not set.
-     * @param args the String[] args to fix up
-     * @return the String[] args to use
-     */
+
+	/**
+	 * Any central pre-processing of args. This supplies aspectjrt.jar if available and classpath not set.
+	 * 
+	 * @param args the String[] args to fix up
+	 * @return the String[] args to use
+	 */
 	protected String[] fixupArgs(String[] args) {
-        if (null == args) {
-            return null;
-        }
-        int cpIndex = -1;
-        boolean hasruntime = false;      
-        for (int i = 0; i < args.length-1; i++) {
-        		args[i] = adaptToPlatform(args[i]);
-            if ("-classpath".equals(args[i])) {
-                cpIndex = i;
-                args[i+1] = substituteSandbox(args[i+1]);
-                String next = args[i+1];
-                hasruntime = ((null != next) 
-                        && (-1 != next.indexOf("aspectjrt.jar")));
-            }
-        }
-        if (-1 == cpIndex) {
-            String[] newargs = new String[args.length + 2];
-            newargs[0] = "-classpath";
-            newargs[1] = TestUtil.aspectjrtPath().getPath();
-            System.arraycopy(args, 0, newargs, 2, args.length);
-            args = newargs;
-        } else {
-            if (!hasruntime) {
-                cpIndex++;
-                String[] newargs = new String[args.length];
-                System.arraycopy(args, 0, newargs, 0, args.length);
-                newargs[cpIndex] = args[cpIndex] + File.pathSeparator
-                + TestUtil.aspectjrtPath().getPath();
-                args = newargs;
-            }
-        }
-        return args;
-    }
-	
+		if (null == args) {
+			return null;
+		}
+		int cpIndex = -1;
+		boolean hasruntime = false;
+		for (int i = 0; i < args.length - 1; i++) {
+			args[i] = adaptToPlatform(args[i]);
+			if ("-classpath".equals(args[i])) {
+				cpIndex = i;
+				args[i + 1] = substituteSandbox(args[i + 1]);
+				String next = args[i + 1];
+				hasruntime = ((null != next) && (-1 != next.indexOf("aspectjrt.jar")));
+			}
+		}
+		if (-1 == cpIndex) {
+			String[] newargs = new String[args.length + 2];
+			newargs[0] = "-classpath";
+			newargs[1] = TestUtil.aspectjrtPath().getPath();
+			System.arraycopy(args, 0, newargs, 2, args.length);
+			args = newargs;
+		} else {
+			if (!hasruntime) {
+				cpIndex++;
+				String[] newargs = new String[args.length];
+				System.arraycopy(args, 0, newargs, 0, args.length);
+				newargs[cpIndex] = args[cpIndex] + File.pathSeparator + TestUtil.aspectjrtPath().getPath();
+				args = newargs;
+			}
+		}
+		return args;
+	}
+
 	private String adaptToPlatform(String s) {
-		String ret = s.replace(';',File.pathSeparatorChar);
-		//ret = ret.replace(':',File.pathSeparatorChar);
+		String ret = s.replace(';', File.pathSeparatorChar);
+		// ret = ret.replace(':',File.pathSeparatorChar);
 		return ret;
 	}
-    
+
 	private List copyAll(List in) {
-		if (in == Collections.EMPTY_LIST) return in;
-		
+		if (in == Collections.EMPTY_LIST)
+			return in;
+
 		List out = new ArrayList();
 		for (Iterator iter = in.iterator(); iter.hasNext();) {
-			out.add(iter.next());			
+			out.add(iter.next());
 		}
 		return out;
 	}
-	
+
 	/**
-	 * Compare the set of expected messages against the set of actual messages,
-	 * leaving in missingElements the set of messages that were expected but did not
-	 * occur, and in extraElements the set of messages that occured but were not 
-	 * excpected
-	 * @param expected  the expected messages
+	 * Compare the set of expected messages against the set of actual messages, leaving in missingElements the set of messages that
+	 * were expected but did not occur, and in extraElements the set of messages that occured but were not excpected
+	 * 
+	 * @param expected the expected messages
 	 * @param actual the actual messages
 	 * @param missingElements the missing messages, when passed in must contain all of the expected messages
 	 * @param extraElements the additional messages, when passed in must contain all of the actual messages
@@ -791,7 +780,7 @@ public class AjcTestCase extends TestCase {
 		}
 	}
 
-	private void addMissing(StringBuffer buff,String type, List messages) {
+	private void addMissing(StringBuffer buff, String type, List messages) {
 		if (!messages.isEmpty()) {
 			buff.append("Missing expected ");
 			buff.append(type);
@@ -803,7 +792,7 @@ public class AjcTestCase extends TestCase {
 			}
 		}
 	}
-	
+
 	private void addExtra(StringBuffer buff, String type, List messages) {
 		if (!messages.isEmpty()) {
 			buff.append("Unexpected ");
@@ -814,61 +803,66 @@ public class AjcTestCase extends TestCase {
 				buff.append(iter.next().toString());
 				buff.append("\n");
 			}
-		}		
+		}
 	}
-	
+
 	// add any jars in the directory to the classpath
-	private void getAnyJars(File dir,StringBuffer buff) {
+	private void getAnyJars(File dir, StringBuffer buff) {
 		File[] files = dir.listFiles();
 		for (int i = 0; i < files.length; i++) {
 			if (files[i].getName().endsWith(".jar")) {
 				buff.append(File.pathSeparator);
 				buff.append(files[i].getAbsolutePath());
 			} else if (files[i].isDirectory()) {
-				getAnyJars(files[i],buff);
+				getAnyJars(files[i], buff);
 			}
 		}
 	}
-	
-	private static void startCapture (OutputStream errOS, OutputStream outOS) {
+
+	private static void startCapture(OutputStream errOS, OutputStream outOS) {
 		delegatingErr.add(errOS);
 		delegatingOut.add(outOS);
 
 		delegatingErr.setVerbose(DEFAULT_ERR_VERBOSE);
 		delegatingOut.setVerbose(DEFAULT_OUT_VERBOSE);
 	}
-	
-	private static void stopCapture (OutputStream errOS, OutputStream outOS) {
+
+	private static void stopCapture(OutputStream errOS, OutputStream outOS) {
 		delegatingErr.setVerbose(true);
 		delegatingOut.setVerbose(true);
 
 		delegatingErr.remove(errOS);
 		delegatingOut.remove(outOS);
 	}
-	
-	private static boolean getBoolean (String name, boolean def) {
+
+	private static boolean getBoolean(String name, boolean def) {
 		String defaultValue = String.valueOf(def);
-		String value = System.getProperty(name,defaultValue);
+		String value = System.getProperty(name, defaultValue);
 		return Boolean.valueOf(value).booleanValue();
 	}
-	
-	/* (non-Javadoc)
+
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see junit.framework.TestCase#setUp()
 	 */
 	protected void setUp() throws Exception {
 		super.setUp();
 		ajc = new Ajc();
 	}
-	/* (non-Javadoc)
+
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see junit.framework.TestCase#tearDown()
 	 */
 	protected void tearDown() throws Exception {
 		super.tearDown();
-        //ajc = null;
+		// ajc = null;
 	}
-	
+
 	static {
-//		new RuntimeException("*** AjcTestCase.<clinit>()").printStackTrace();
+		// new RuntimeException("*** AjcTestCase.<clinit>()").printStackTrace();
 		delegatingErr = new DelegatingOutputStream(err);
 		System.setErr(new PrintStream(delegatingErr));
 		delegatingOut = new DelegatingOutputStream(out);
@@ -27,751 +27,1018 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 import org.aspectj.util.LangUtil;
 
 public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
-	  
-  public static Test suite() {
-    return XMLBasedAjcTestCase.loadSuite(Ajc150Tests.class);
-  }
-
-  protected File getSpecFile() {
-    return new File("../tests/src/org/aspectj/systemtest/ajc150/ajc150.xml");
-  }
-  public void testMixingCodeStyles_pr121385()  { runTest("mixing aspect styles");}
-  public void testTypeVars_pr121575()  { runTest("different numbers of type vars");}
-  public void testTypeVars_pr121575_2()  { runTest("different numbers of type vars - 2");}
-  public void testTypeVars_pr121575_3()  { runTest("different numbers of type vars - 3");}
-  public void testTypeVars_pr121575_4()  { runTest("different numbers of type vars - 4");}
-  public void testDecps1()  { runTest("decps - 1");  }
-  public void testDecps1b() { runTest("decps - 1b"); }
-  public void testDecps2()  { runTest("decps - 2");  }
-  public void testDecps2b() { runTest("decps - 2b"); }
-  public void testDecps3()  { runTest("decps - 3");  }
-  public void testDecps3b() { runTest("decps - 3b"); }
-  public void testDecps3c() { runTest("decps - 3c"); }
-
-  public void testVarargsNPE_pr120826() { runTest("varargs NPE");}
-  public void testNamedPointcutPertarget_pr120521() { runTest("named pointcut not resolved in pertarget pointcut");}
-  public void testDollarClasses_pr120474() { runTest("Dollar classes");}
-  public void testGenericPTW_pr119539_1() { runTest("generic pertypewithin aspect - 1");}
-  public void testGenericPTW_pr119539_2() { runTest("generic pertypewithin aspect - 2");}
-  public void testGenericPTW_pr119539_3() { runTest("generic pertypewithin aspect - 3");}
-  /*
-  public void testBrokenDispatchByITD_pr72834() { runTest("broken dispatch");}
-  public void testMissingAccessor_pr73856() { runTest("missing accessor");}
-  public void testCunningDeclareParents_pr92311() { runTest("cunning declare parents");}
-  public void testGenericITDsAndAbstractMethodError_pr102357() { runTest("generic itds and abstract method error");}
-  */
-  public void testIncorrectSignatureMatchingWithExceptions_pr119749() { runTest("incorrect exception signature matching");}
-  public void testGeneratingCodeForAnOldRuntime_pr116679_1() { runTest("generating code for a 1.2.1 runtime - 1");}
-  public void testGeneratingCodeForAnOldRuntime_pr116679_2() { runTest("generating code for a 1.2.1 runtime - 2");}
-  public void testAmbiguousMethod_pr118599_1() { runTest("ambiguous method when binary weaving - 1");}
-  public void testAmbiguousMethod_pr118599_2() { runTest("ambiguous method when binary weaving - 2");}
-  public void testAroundAdviceArrayAdviceSigs_pr118781()     { runTest("verify error with around advice array sigs");}
-  public void testAtDeclareParents_pr117681() { runTest("at declare parents");}
-  public void testPrivilegeProblem_pr87525() { runTest("privilege problem with switch");}
-  public void testRangeProblem_pr109614() { runTest("Range problem");}
-  public void testGenericAspects_pr115237() { runTest("aspectOf and generic aspects");}
-  public void testClassFormatError_pr114436() { runTest("ClassFormatError binary weaving perthis");}
-  public void testParserException_pr115788() { runTest("parser exception");}
-  public void testPossibleStaticImports_pr113066_1() { runTest("possible static imports bug - 1");}
-  public void testPossibleStaticImports_pr113066_2() { runTest("possible static imports bug - 2");}
-  public void testPossibleStaticImports_pr113066_3() { runTest("possible static imports bug - 3");}
-  public void testITDCtor_pr112783()                 { runTest("Problem with constructor ITDs");}
-  public void testAnnotatedITDFs_pr114005_1()        { runTest("Annotated ITDFs - 1");}
-  public void testAnnotatedITDFs_pr114005_2()        { runTest("Annotated ITDFs - 2");}
-  public void testCantCallSuperMethods_pr90143() { runTest("cant call super methods");}
-  public void testBrokenDecp_pr112476()       { runTest("binary weaving decp broken");}
-  public void testUnboundFormal_pr112027()    { runTest("unexpected error unboundFormalInPC");}
-  public void testNPEScopeSetup_pr115038()    { runTest("NPE in ensureScopeSetup");}
-  public void testCCEGenerics_pr113445()      { runTest("Generics ClassCastException");}
-  public void testMatthewsAspect_pr113947_1() { runTest("maws generic aspect - 1");}
-  public void testMatthewsAspect_pr113947_2() { runTest("maws generic aspect - 2");}
-  public void testFieldGet_pr114343()         { runTest("field-get, generics and around advice");}
-  public void testFieldGet_pr114343_2()       { runTest("field-get, generics and around advice - 2");}
-  public void testFieldGet_pr114343_3()       { runTest("field-get, generics and around advice - 3");}
-  public void testCaptureBinding_pr114744()   { runTest("capturebinding wildcard problem");}
-  public void testAutoboxingAroundAdvice_pr119210_1()   { runTest("autoboxing around advice - 1");}
-  public void testAutoboxingAroundAdvice_pr119210_2()   { runTest("autoboxing around advice - 2");}
-  public void testAutoboxingAroundAdvice_pr119210_3()   { runTest("autoboxing around advice - 3");}
-  public void testBadDecp_pr110788_1() { runTest("bad generic decp - 1");}
-  public void testBadDecp_pr110788_2() { runTest("bad generic decp - 2");}
-  public void testBadDecp_pr110788_3() { runTest("bad generic decp - 3");}
-  public void testBadDecp_pr110788_4() { runTest("bad generic decp - 4");}
-  
-//  public void testSimplifiedGenericAspectITDTest() { runTest("spurious override method warning - 3");}
-//  public void testSpuriousOverrideMethodWarning_pr119570_1() { runTest("spurious override method warning");}
-//  public void testSpuriousOverrideMethodWarning_pr119570_2() { runTest("spurious override method warning - 2");}
-
-  public void testBrokenSwitch_pr117854() { runTest("broken switch transform");}
-  public void testVarargsITD_pr110906() { runTest("ITD varargs problem");}
-  public void testBadRenderer_pr86903() { runTest("bcelrenderer bad");}
-  //public void testIllegalInitialization_pr118326_1() { runTest("illegal initialization - 1");}
-  //public void testIllegalInitialization_pr118326_2() { runTest("illegal initialization - 2");}
-  public void testLintForAdviceSorting_pr111667() { runTest("lint for advice sorting");}
-  
-  public void testIncompatibleClassChangeError_pr113630_1() {runTest("IncompatibleClassChangeError - errorscenario");}
-  public void testIncompatibleClassChangeError_pr113630_2() {runTest("IncompatibleClassChangeError - workingscenario");}
-  
-  public void testFieldGetProblemWithGenericField_pr113861() {runTest("field-get problems with generic field");}
-  public void testAccesstoPrivateITDInNested_pr118698() { runTest("access to private ITD from nested type");}
-
-  public void testDeclareAnnotationOnNonExistentType_pr99191_1() { runTest("declare annotation on non existent type - 1");}
-  public void testDeclareAnnotationOnNonExistentType_pr99191_2() { runTest("declare annotation on non existent type - 2");}  
-  public void testDeclareAnnotationOnNonExistentType_pr99191_3() { runTest("declare annotation on non existent type - 3");}  
-  public void testDeclareAnnotationOnNonExistentType_pr99191_4() { runTest("declare annotation on non existent type - 4");}  
-  public void testDeclareAnnotationOnNonExistentType_pr99191_5() { runTest("declare annotation on non existent type - 5");}  
-  
-  public void testBadGenericSigAttribute_pr110927() { 
-	runTest("cant create signature attribute");
-	Signature sig = GenericsTests.getClassSignature(ajc,"I");
-	if (sig==null) fail("Couldn't find signature attribute for type I");
-	String sigString = sig.getSignature();
-	if (!(sigString.equals("Ljava/lang/Object;LIE2;LIE1<Ljava/lang/String;>;") ||
-          sigString.equals("Ljava/lang/Object;LIE1<Ljava/lang/String;>;LIE2;"))) {
-		fail("Signature was "+sigString+" when should have been something like Ljava/lang/Object;LIE1<Ljava/lang/String;>;LIE2;");
-	}
-  }
-
-  public void test_typeProcessingOrderWhenDeclareParents() {
-	runTest("Order of types passed to compiler determines weaving behavior");
-  }
-  
-  public void test_aroundMethod() {
-  	runTest("method called around in class");
-  }
- 
-  public void test_aroundMethodAspect() {
-  	runTest("method called around in aspect");
-  }
-  
-  public void test_ambiguousBindingsDetection() {
-  	runTest("Various kinds of ambiguous bindings");
-  }
-  
-  public void test_ambiguousArgsDetection() {
-  	runTest("ambiguous args");
-  }
-  
-  public void testIncorrectExceptionTableWhenBreakInMethod_pr78021() {
-  	runTest("Injecting exception into while loop with break statement causes catch block to be ignored");
-  }
-  
-  
-  public void testIncorrectExceptionTableWhenReturnInMethod_pr79554() {
-  	runTest("Return in try-block disables catch-block if final-block is present");
-  }
-
-  public void testMissingDebugInfoForGeneratedMethods_pr82570() throws ClassNotFoundException {
-  	runTest("Weaved code does not include debug lines");
-  	boolean f = false;
-    JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),"PR82570_1");
-    Method[] meths = jc.getMethods();
-    for (int i = 0; i < meths.length; i++) {
-		Method method = meths[i];
-		if (f) System.err.println("Line number table for "+method.getName()+method.getSignature()+" = "+method.getLineNumberTable());
-		assertTrue("Didn't find a line number table for method "+method.getName()+method.getSignature(),
-				method.getLineNumberTable()!=null);
-    }
-
-    // This test would determine the info isn't there if you pass -g:none ...
-//    cR = ajc(baseDir,new String[]{"PR82570_1.java","-g:none"});
-//    assertTrue("Expected no compile problem:"+cR,!cR.hasErrorMessages());
-//    System.err.println(cR.getStandardError());
-//    jc = getClassFrom(ajc.getSandboxDirectory(),"PR82570_1");
-//    meths = jc.getMethods();
-//    for (int i = 0; i < meths.length; i++) {
-//		Method method = meths[i];
-//		assertTrue("Found a line number table for method "+method.getName(),
-//				method.getLineNumberTable()==null);
-//    }
-  }
-
-  
-  public void testCanOverrideProtectedMethodsViaITDandDecp_pr83303() {
-  	runTest("compiler error when mixing inheritance, overriding and polymorphism");
-  }
-  
-  public void testPerTypeWithin_pr106554() {runTest("Problem in staticinitialization with pertypewithin aspect");}
-  
-  public void testPerTypeWithinMissesNamedInnerTypes() {
-  	runTest("pertypewithin() handing of inner classes (1)");
-  }
-  
-  public void testPerTypeWithinMissesAnonymousInnerTypes() {
-  	runTest("pertypewithin() handing of inner classes (2)");
-  }
-
-  public void testPerTypeWithinIncorrectlyMatchingInterfaces() {
-  	runTest("pertypewithin({interface}) illegal field modifier");
-  }
-  
-  public void test051_arrayCloningInJava5() {
-    runTest("AJC possible bug with static nested classes");
-  }
- 
-  public void testBadASMforEnums() throws IOException {
-  	runTest("bad asm for enums");
-  	
-  	if (LangUtil.is15VMOrGreater()) {
-	  	ByteArrayOutputStream baos = new ByteArrayOutputStream();
-	  	PrintWriter pw = new PrintWriter(baos);
-	  	AsmManager.dumptree(pw,AsmManager.getDefault().getHierarchy().getRoot(),0);
-	  	pw.flush();
-	  	String tree = baos.toString();
-	  	assertTrue("Expected 'Red [enumvalue]' somewhere in here:"+tree,tree.indexOf("Red  [enumvalue]")!=-1);
-  	}
-  }
-  
-  public void npeOnTypeNotFound() {
-	  runTest("structure model npe on type not found");
-  }
- 
-  public void testNoRuntimeExceptionSoftening() {
-	  runTest("declare soft of runtime exception");
-  }
-  
-  public void testRuntimeNoSoftenWithHandler() {
-	  runTest("declare soft w. catch block");
-  }
-  
-  public void testSyntaxError() {
-	  runTest("invalid cons syntax");
-  }
-  
-  public void testVarargsInConsBug() {
-	  runTest("varargs in constructor sig");
-  }
-  
-  public void testAspectpathdirs() {
-	  runTest("dirs on aspectpath");
-  }
-  
-  public void testIntroSample() {
-	  runTest("introduction sample");
-  }
-  
-  public void testPTWInterface() {
-	  runTest("pertypewithin({interface}) illegal field modifier");
-  }
-  
-  public void testEnumCalledEnumEtc() {
-	  runTest("enum called Enum, annotation called Annotation, etc");
-  }
-  
-  public void testInternalCompilerError_pr86832() {
-	  runTest("Internal compiler error");
-  }
-  
-  public void testCloneMethod_pr83311() {
-	  runTest("overriding/polymorphism error on interface method introduction");
-  }
-
-  
-  // IfPointcut.findResidueInternal() was modified to make this test complete in a short amount
-  // of time - if you see it hanging, someone has messed with the optimization.
-  public void testIfEvaluationExplosion_pr94086() {
-	  runTest("Exploding compile time with if() statements in pointcut");
-  }
-  
-  public void testReflectNPE_pr94167() {runTest("NPE in reflect implementation");}
-  
-  public void testStaticImports_pr84260() {runTest("static import failures");} 
-  
-  public void testGenerics_pr99089() {runTest("ArrayIndexOutOfBoundsException - Generics in privileged aspects");}
-  public void testGenerics_pr95993() {runTest("NPE at ClassScope.java:660 when compiling generic class");}
-  
-  public void testItdGenerics_pr99228()  {runTest("ITD of a field into a generic class");}
-  public void testItdGenerics_pr98320()  {runTest("intertype with nested generic type");}
-  public void testItdGenerics_pr100227() {runTest("inner class with generic enclosing class");}
-  public void testItdGenerics_pr100260() {runTest("methods inherited from a generic parent");}
-  
-  public void testSyntaxErrorNPE_pr103266() {runTest("NPE on syntax error");}
-  
-  public void testFinalAbstractClass_pr109486() { runTest("Internal compiler error (ClassParser.java:242)");}
- 
-  public void testComplexBinding_pr102210() { runTest("NullPointerException trying to compile");}
-  
-  public void testIllegalStateExceptionOnNestedParameterizedType_pr106634() { 
-	  runTest("IllegalStateException unpacking signature of nested parameterized type");
-  }
-  
-  public void testParseErrorOnAnnotationStarPlusPattern() {
-	  runTest("(@Foo *)+ type pattern parse error");
-  }
-  
-  public void test_pr106130_tooManyLocals() {
-	  runTest("test weaving with > 256 locals");
-  }
-  
-  public void testMissingNamePattern_pr106461() { runTest("missing name pattern"); }
-  
-  public void testMissingNamePattern_pr107059() {
-	  runTest("parser crashes on call(void (@a *)(..)");
-  }
-  
-  public void testIntermediateAnnotationMatching() {
-	  runTest("intermediate annotation matching");
-  }
-  
-  public void testBadRuntimeTestGeneration() {
-	  runTest("target(@Foo *)");
-  }
-  
-  public void testErrorMessageOnITDWithTypePatterns() {
-	  runTest("clear error message on itd with type pattern");
-  }
-  
-  public void testAjKeywordsAsIdentifiers() {
-	  runTest("before and after are valid identifiers in classes");
-  }
-  
-  public void testAjKeywordsAsIdentifiers2() {
-	  runTest("before and after are valid identifiers in classes, part 2");	  
-  }
-  
-  public void testNoBeforeReturningAdvice() {
-	  runTest("before returning advice not allowed!");
-  }
-  
-  public void testDetectVoidFieldType() {
-	  runTest("void field type in pointcut expression");
-  }
-  
-  public void testPointcutOverriding() {
-	  runTest("overriding final pointcut from super-aspect");
-  }
-  
-  public void testAtSuppressWarnings() {
-	  runTest("@SuppressWarnings should suppress");
-  }
-  
-  public void testDEOWWithBindingPointcut() {
-	  runTest("declare warning : foo(str) : ...;");
-  }
-  
-  public void testAroundAdviceAndInterfaceInitializer() {
-	  runTest("around advice on interface initializer");
-  }
-  
-  public void testGoodErrorMessageOnUnmatchedMemberSyntax() {
-	  runTest("good error message for unmatched member syntax");
-  }
-  
-  public void testITDWithNoExceptionAndIntermediary() {
-	  runTest("itd override with no exception clause");
-  }
-  
-  public void testAnonymousInnerClasses() {
-	  runTest("anonymous inner classes");
-  }
-
-  public void testMultipleAnonymousInnerClasses() {
-	  runTest("multiple anonymous inner classes");
-  }
-  
-  public void testPrivilegedMethodAccessorsGetRightExceptions_pr82989() {
-	  runTest("Compiler error due to a wrong exception check in try blocks");
-  }
-  
-  public void testAnonymousInnerClassWithMethodReturningTypeParameter_pr107898() {
-	  runTest("anonymous inner class with method returning type parameter");
-  }
-  
-  public void testMatchingOfObjectArray() {
-	  runTest("matching against Object[]");
-  }
-  
-  public void testMultipleAnonymousInnerClasses_pr108104() {
-	  runTest("multiple anonymous inner classes 2");
-  }
-  
-  public void testSignatureMatchingInMultipleOverrideScenario() {
-	  runTest("signature matching in override scenario");
-  }
- 
-  public void testWildcardAnnotationMatching_pr108245() {
-	  runTest("wildcard annotation matching - pr108245");
-  }
-  
-  public void testInnerTypesAndTypeVariables() {
-	  runTest("inner types and type variables");
-  }
-  
-  public void testAtAfterThrowingWithNoFormal() {
-	  runTest("@AfterThrowing with no formal specified");
-  }
-  
-  public void testParameterizedVarArgsMatch() {
-	  runTest("varargs with type variable");
-  }
-  
-  public void testFieldAccessInsideITDM() {
-	  runTest("itd field access inside itd method");
-  }
-
-  public void testTypeVarWithTypeVarBound() {
-	  runTest("type variable with type variable bound");
-  }
-  
-  public void testEnumSwitchInITD() {
-	  runTest("switch on enum inside ITD method");
-  }
-  
-  public void testInnerTypeOfGeneric() {
-	  runTest("inner type of generic interface reference from parameterized type");
-  }
-  
-  public void testDeclareParentsIntroducingCovariantReturnType() {
-	  runTest("declare parents introducing override with covariance");
-  }
-  
-  public void testInnerClassPassedToVarargs() {
-	  runTest("inner class passed as argument to varargs method");
-  }
-  
-  public void testInlinedFieldAccessInProceedCall() {
-	  runTest("inlined field access in proceed call");
-  }
-  
-  public void testVisibiltyInSignatureMatchingWithOverridesPart1() {
-	  runTest("visibility in signature matching with overrides - 1");
-  }
-
-  public void testVisibiltyInSignatureMatchingWithOverridesPart2() {
-	  runTest("visibility in signature matching with overrides - 2");
-  }
-
-  public void testVisibiltyInSignatureMatchingWithOverridesPart3() {
-	  runTest("visibility in signature matching with overrides - 3");
-  }
-  
-  public void testArgsGeneratedCorrectlyForAdviceExecution() {
-	  runTest("args generated correctly for advice execution join point");
-  }
-  
-  public void testNoUnusedWarningsOnAspectTypes() {
-	  runTest("no unused warnings on aspect types");
-  }
-  
-  public void testSyntheticArgumentsOnITDConstructorsNotUsedInMatching() {
-	  runTest("synthetic arguments on itd cons are not used in matching");
-  }
-  
-  public void testParsingOfGenericTypeSignature() {
-	  runTest("parse generic type signature with parameterized type in interface");
-  }
-  
-  public void testOverrideAndCovarianceWithDecPRuntime() {
-	  runTest("override and covariance with decp - runtime");
-  }
-  
-  public void testOverrideAndCovarianceWithDecPRuntimeMultiFiles() {
-	  runTest("override and covariance with decp - runtime separate files");
-  }
-
-  public void testOverrideAndCovarianceWithDecPRuntimeMultiFilesBinaryWeaving() {
-	  runTest("override and covariance with decp - binary weaving");
-  }
-  
-  public void testAbstractSynchronizedITDMethods() {
-	  runTest("abstract synchronized itdms not detected");
-  }
-  
-  public void testSynchronizedITDInterfaceMethods() {
-	  runTest("synchronized itd interface methods");
-  }
-  
-  public void testNoWarningOnUnusedPointcut() {
-	  runTest("unused private pointcuts");
-  }
-  
-  public void testITDOnInterfaceWithExistingMember() {
-	  runTest("itd interface method already existing on interface");
-  }
-  
-  public void testFinalITDMOnInterface() {
-	  runTest("final itd methods on interfaces");
-  }
-  
-  public void testPrivatePointcutOverriding() {
-	  runTest("can't override private pointcut in abstract aspect");
-  }
-
-  public void testAdviceOnCflow() {
-	  runTest("advising cflow advice execution");
-  }
-  
-  public void testNoTypeMismatchOnSameGenericTypes() {
-	  runTest("no type mismatch on generic types in itds");
-  }
-  
-  public void testSuperCallInITD() {
-	  runTest("super call in ITD");
-  }
-
-  public void testSuperCallInITDPart2() {
-	  runTest("super call in ITD - part 2");
-  }
-  
-  public void testAtAnnotationBadTest_pr103740() {
-	  runTest("Compiler failure on at_annotation");
-  }
-  
-  public void testNoUnusedParameterWarningsForSyntheticAdviceArgs() {
-	  runTest("no unused parameter warnings for synthetic advice args");
-  }
-  
-  public void testNoVerifyErrorWithSetOnInnerType() {
-	  runTest("no verify error with set on inner type");
-  }
-  
-  public void testCantFindTypeErrorWithGenericReturnTypeOrParameter() {
-	  runTest("cant find type error with generic return type or parameter");
-  }
-
-  public void testNoVerifyErrorOnGenericCollectionMemberAccess() {
-	  runTest("no verify error on generic collection member access");
-  }
-  
-  public void testRawAndGenericTypeConversionITDCons() {
-	  runTest("raw and generic type conversion with itd cons");
-  }
-  
-  public void testAtAnnotationBindingWithAround() {
-	  runTest("@annotation binding with around advice");
-  }
-  
-  public void testUnableToBuildShadows_pr109728() { runTest("Unable to build shadows");}
-
-  public void testMessageOnMissingTypeInDecP() {
-	  runTest("declare parents on a missing type");
-  }
-  
-  public void testParameterizedGenericMethods() {
-	  runTest("parameterized generic methods");
-  }
-  
-  public void testIllegalChangeToPointcutDeclaration_pr111915() {
-	runTest("test illegal change to pointcut declaration");
-  }
-  
-  public void testCantProvideDefaultImplViaITD_pr110307_1() {runTest("Cant provide default implementation via ITD - 1");}
-  public void testCantProvideDefaultImplViaITD_pr110307_2() {runTest("Cant provide default implementation via ITD - 2");}
-  public void testCantProvideDefaultImplViaITD_pr110307_3() {runTest("Cant provide default implementation via ITD - 3");}
-  public void testCantProvideDefaultImplViaITD_pr110307_4() {runTest("Cant provide default implementation via ITD - 4");}
-  public void testCantProvideDefaultImplViaITD_pr110307_5() {runTest("Cant provide default implementation via ITD - 5");}
-  
-  // Needs a change in the compiler so that getType() can be overridden in the intertype scope - thats
-  // where we can police whether a type variable has been used without being specified appropriately.
-  //public void testCantProvideDefaultImplViaITD_pr110307_6() {runTest("Cant provide default implementation via ITD - 6");}
-
-  public void testCantProvideDefaultImplViaITD_pr110307_7() {runTest("Cant provide default implementation via ITD - 7");}
-  
-  public void testCallJoinPointsInAnonymousInnerClasses() {
-	  runTest("call join points in anonymous inner classes");
-  }
-  
-  public void testNoRequirementForUnwovenTypesToBeExposedToWeaver() {
-	  runTest("default impl of Runnable");
-  }
-  
-  public void testArrayCloneCallJoinPoints() {
-	  runTest("array clone call join points in 1.4 vs 1.3");
-  }
-  
-  public void testDebugInfoForAroundAdvice() {
-	  runTest("debug info in around advice inlining");
-  }
-  
-  public void testCCEWithGenericWildcard_pr112602() {
-	  runTest("ClassCastException with generic wildcard");
-  }
-  
-  public void testVarArgsIITDInConstructor() {
-	  runTest("ITD varargs in constructor");
-  }
-   
-  public void testWeaveInfoMessageForDeclareAtMethodOnITDdMethod() {
-	  runTest("weaveinfo message for declare at method on an ITDd method");
-  }
-  
-  public void testITDCWithNoExplicitConsCall() {
-	  runTest("ITDC with no explicit cons call");
-  }
-  
-  public void testJava5SpecificFeaturesUsedAtJava14OrLower() {
-	  runTest("java 5 pointcuts and declares at pre-java 5 compliance levels");
-  }
-  
-  public void testAnonymousTypes() {
-	  runTest("Anonymous types and nome matching");
-  }
-  
-  public void testAdviceExecutionJPToStringForms() {
-	  runTest("adviceexecution join point toString forms");
-  }
-  
-  public void testAssertWithinPointcutExpression() {
-	  runTest("pointcut expression containing 'assert'");
-  }
-  
-  public void testNoVerifyErrorWithTwoThisPCDs_pr113447() {
-	  runTest("no verify error with two this pcds");
-  }
-
-  public void testNoVerifyErrorWithTwoAtThisPCDs_pr113447() {
-	  runTest("no verify error with two at this pcds");
-  }
-  
-  public void testNoVerifyErrorWithAtWithinPCDs_pr113447() {
-	  runTest("no verify error with at within pcds");
-  }
-  
-  public void testNoVerifyErrorWithAtWithincodePCDs_pr113447() {
-	  runTest("no verify error with at withincode pcds");
-  }
-  
-  public void testNoVerifyErrorWithAtAnnotationPCDs_pr113447() {
-	  runTest("no verify error with at annotation pcds");
-  }
-  
-  public void testNoVerifyErrorWithTwoArgsPCDs_pr113447() {
-	  runTest("no verify error with two args pcds");
-  }
-  
-  public void testNoStackOverflowWithCircularPCDInGenericAspect() {
-	  runTest("no StackOverflowError with circular pcd in generic aspect");
-  }
-  
-  public void testNoStackOverflowWithCircularPCDInGenericAspect2() {
-	  runTest("no StackOverflowError with circular pcd in generic aspect - 2");
-  }
-
-  public void testNPEInThisJoinPointStaticPart() {
-	  runTest("thisJoinPointStaticPart in if test");
-  }
-
-  public void testPointcutParsingOfCompiledPointcuts() {
-	  runTest("pointcut parsing with ajc compiled pointcut references");
-  }
-  
-  public void testReflectionOfAbstractITDs() {
-	  runTest("reflection on abstract ITDs (Billing example)");
-  }
-  
-  public void testDeclareSoftWithAdviceExecution() {
-	  runTest("declare soft and adviceexecution");
-  }
-
-  public void testDeclareSoftWithExclusions() {
-	  runTest("declare soft and exclusions");
-  }
-  
-  public void testReturningObjectBinding() {
-	  runTest("returning(Object) binding");
-  }
-  
-  public void testPerTargetAndNegation() {
-	  runTest("pertarget and negated pointcut");
-  }
-  
-  public void testParameterizedPointcutAndAdvice() {
-	  runTest("parameterized pointcut and advice");
-  }
-  
-  public void testDoublyParameterizedAbstractType() {
-	  runTest("double parameter generic abstract type");
-  }
-  
-
-  public void testArgNamesInAdviceAnnotations() {
-	  runTest("arg names in advice annotations");
-  }
-  
-  /*
-   * Load-time weaving bugs
-   */
-  public void testNPEinWeavingAdaptor_pr116626() { runTest("NPE in WeavingAdaptor");}
-  
-  public void testXlintMessageForImproperAnnotationType_pr115252_Exact() {runTest("xlint message for improper exact annotation type");}
-  public void testXlintMessageForImproperAnnotationType_pr115252_OR() {runTest("xlint message for improper annotation type inside OR");}
-  public void testXlintMessageForImproperAnnotationType_pr115252_AND() {runTest("xlint message for improper annotation type inside AND");}
-  public void testXlintMessageForImproperAnnotationType_pr115252_Return() {runTest("xlint message for improper annotated return type");}  
-  public void testXlintMessageForImproperAnnotationType_pr115252_Declaring() {runTest("xlint message for improper annotated declaring type");}  
-  public void testXlintMessageForImproperAnnotationType_pr115252_Parameter() {runTest("xlint message for improper annotated parameter type");}  
-  public void testXlintMessageForImproperAnnotationType_pr115252_Throws() {runTest("xlint message for improper annotated throws pattern");}  
-  public void testXlintMessageForImproperAnnotationType_pr115252_MoreThanOne() {runTest("xlint message for more than one improper annotated parameter type");}  
-  
-  public void testNoNPEWhenInaccessibleMethodIsCalledWithinITD_pr119019() {
-	  runTest("no NPE when inaccessible method is called within itd");
-  }
-  
-  public void testNoNPEWithOrPointcutAndMoreThanOneArgs_pr118149() {
-	  runTest("no NPE with or pointcut and more than one args");
-  }
-  
-  public void testNoSOBWithGenericInnerAspects_pr119543() {
-	  runTest("no StringOutOfBoundsException with generic inner aspects");
-  }
-  
-  public void testIllegalAccessErrorWithAroundAdvice_pr119657() {
-	  runTest("IllegalAccessError with around advice on interface method call");
-  }
-  
-  public void testIllegalAccessErrorWithAroundAdviceNotSelf_pr119657() {
-	  runTest("IllegalAccessError with around advice on interface method call not self");
-  }
-  
-  public void testIllegalAccessErrorWithAroundAdviceTerminateAfterCompilationLTW_pr119657() {
-	  runTest("IllegalAccessError with around advice on interface method call using -XterminateAfterCompilation and LTW");
-  }
-  
-  public void testIllegalAccessErrorWithAroundAdviceLTW_pr119657() {
-	  runTest("IllegalAccessError with around advice on interface method call using LTW");
-  }
-  
-  public void testIllegalAccessErrorWithAroundAdviceNotSelfLTW_pr119657() {
-	  runTest("IllegalAccessError with around advice on interface method call not self using LTW");
-  }
-  
-  public void testIllegalAccessErrorWithAroundAdviceSelfAndNotSelfLTW_pr119657() {
-	  runTest("IllegalAccessError with around advice on interface method call self and not self using LTW");
-  }
-  
-  public void testIllegalAccessErrorWithAroundAdviceLTWNoInline_pr119657() {
-	  runTest("IllegalAccessError with around advice on interface method call using LTW and -XnoInline");
-  }
-  
-  public void testReflectOnCodeStyleITDs() {
-	  runTest("reflection on itds");
-  }
-  
-  public void testReflectOnAtAspectJDecP() {
-	  runTest("reflection on @DeclareParents");
-  }
-  
-  public void testModifierOverrides() {
-	  runTest("modifier overrides");
-  }
-  
-  public void testAbstractPerThisInAtAspectJ() {
-	  runTest("abstract perthis in @AspectJ");
-  }
-  
-  public void testNPEInBcelAdviceWithConcreteAspect_pr121385() {
-	  runTest("override protected pointcut in aop.xml concrete aspect");
-  }
-  
-  
-  // helper methods.....
-  
-  public SyntheticRepository createRepos(File cpentry) {
-	ClassPath cp = new ClassPath(cpentry+File.pathSeparator+System.getProperty("java.class.path"));
-	return SyntheticRepository.getInstance(cp);
-  }
-  
-  protected JavaClass getClassFrom(File where,String clazzname) throws ClassNotFoundException {
-	SyntheticRepository repos = createRepos(where);
-	return repos.loadClass(clazzname);
-  }
+
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(Ajc150Tests.class);
+	}
+
+	protected File getSpecFile() {
+		return new File("../tests/src/org/aspectj/systemtest/ajc150/ajc150.xml");
+	}
+
+	public void testMixingCodeStyles_pr121385() {
+		runTest("mixing aspect styles");
+	}
+
+	public void testTypeVars_pr121575() {
+		runTest("different numbers of type vars");
+	}
+
+	public void testTypeVars_pr121575_2() {
+		runTest("different numbers of type vars - 2");
+	}
+
+	public void testTypeVars_pr121575_3() {
+		runTest("different numbers of type vars - 3");
+	}
+
+	public void testTypeVars_pr121575_4() {
+		runTest("different numbers of type vars - 4");
+	}
+
+	public void testDecps1() {
+		runTest("decps - 1");
+	}
+
+	public void testDecps1b() {
+		runTest("decps - 1b");
+	}
+
+	public void testDecps2() {
+		runTest("decps - 2");
+	}
+
+	public void testDecps2b() {
+		runTest("decps - 2b");
+	}
+
+	public void testDecps3() {
+		runTest("decps - 3");
+	}
+
+	public void testDecps3b() {
+		runTest("decps - 3b");
+	}
+
+	public void testDecps3c() {
+		runTest("decps - 3c");
+	}
+
+	public void testVarargsNPE_pr120826() {
+		runTest("varargs NPE");
+	}
+
+	public void testNamedPointcutPertarget_pr120521() {
+		runTest("named pointcut not resolved in pertarget pointcut");
+	}
+
+	public void testDollarClasses_pr120474() {
+		runTest("Dollar classes");
+	}
+
+	public void testGenericPTW_pr119539_1() {
+		runTest("generic pertypewithin aspect - 1");
+	}
+
+	public void testGenericPTW_pr119539_2() {
+		runTest("generic pertypewithin aspect - 2");
+	}
+
+	public void testGenericPTW_pr119539_3() {
+		runTest("generic pertypewithin aspect - 3");
+	}
+
+	/*
+	 * public void testBrokenDispatchByITD_pr72834() { runTest("broken dispatch");} public void testMissingAccessor_pr73856() {
+	 * runTest("missing accessor");} public void testCunningDeclareParents_pr92311() { runTest("cunning declare parents");} public
+	 * void testGenericITDsAndAbstractMethodError_pr102357() { runTest("generic itds and abstract method error");}
+	 */
+	public void testIncorrectSignatureMatchingWithExceptions_pr119749() {
+		runTest("incorrect exception signature matching");
+	}
+
+	public void testGeneratingCodeForAnOldRuntime_pr116679_1() {
+		runTest("generating code for a 1.2.1 runtime - 1");
+	}
+
+	public void testGeneratingCodeForAnOldRuntime_pr116679_2() {
+		runTest("generating code for a 1.2.1 runtime - 2");
+	}
+
+	public void testAmbiguousMethod_pr118599_1() {
+		runTest("ambiguous method when binary weaving - 1");
+	}
+
+	public void testAmbiguousMethod_pr118599_2() {
+		runTest("ambiguous method when binary weaving - 2");
+	}
+
+	public void testAroundAdviceArrayAdviceSigs_pr118781() {
+		runTest("verify error with around advice array sigs");
+	}
+
+	public void testAtDeclareParents_pr117681() {
+		runTest("at declare parents");
+	}
+
+	public void testPrivilegeProblem_pr87525() {
+		runTest("privilege problem with switch");
+	}
+
+	public void testRangeProblem_pr109614() {
+		runTest("Range problem");
+	}
+
+	public void testGenericAspects_pr115237() {
+		runTest("aspectOf and generic aspects");
+	}
+
+	public void testClassFormatError_pr114436() {
+		runTest("ClassFormatError binary weaving perthis");
+	}
+
+	public void testParserException_pr115788() {
+		runTest("parser exception");
+	}
+
+	public void testPossibleStaticImports_pr113066_1() {
+		runTest("possible static imports bug - 1");
+	}
+
+	public void testPossibleStaticImports_pr113066_2() {
+		runTest("possible static imports bug - 2");
+	}
+
+	public void testPossibleStaticImports_pr113066_3() {
+		runTest("possible static imports bug - 3");
+	}
+
+	public void testITDCtor_pr112783() {
+		runTest("Problem with constructor ITDs");
+	}
+
+	public void testAnnotatedITDFs_pr114005_1() {
+		runTest("Annotated ITDFs - 1");
+	}
+
+	public void testAnnotatedITDFs_pr114005_2() {
+		runTest("Annotated ITDFs - 2");
+	}
+
+	public void testCantCallSuperMethods_pr90143() {
+		runTest("cant call super methods");
+	}
+
+	public void testBrokenDecp_pr112476() {
+		runTest("binary weaving decp broken");
+	}
+
+	public void testUnboundFormal_pr112027() {
+		runTest("unexpected error unboundFormalInPC");
+	}
+
+	public void testNPEScopeSetup_pr115038() {
+		runTest("NPE in ensureScopeSetup");
+	}
+
+	public void testCCEGenerics_pr113445() {
+		runTest("Generics ClassCastException");
+	}
+
+	public void testMatthewsAspect_pr113947_1() {
+		runTest("maws generic aspect - 1");
+	}
+
+	public void testMatthewsAspect_pr113947_2() {
+		runTest("maws generic aspect - 2");
+	}
+
+	public void testFieldGet_pr114343() {
+		runTest("field-get, generics and around advice");
+	}
+
+	public void testFieldGet_pr114343_2() {
+		runTest("field-get, generics and around advice - 2");
+	}
+
+	public void testFieldGet_pr114343_3() {
+		runTest("field-get, generics and around advice - 3");
+	}
+
+	public void testCaptureBinding_pr114744() {
+		runTest("capturebinding wildcard problem");
+	}
+
+	public void testAutoboxingAroundAdvice_pr119210_1() {
+		runTest("autoboxing around advice - 1");
+	}
+
+	public void testAutoboxingAroundAdvice_pr119210_2() {
+		runTest("autoboxing around advice - 2");
+	}
+
+	public void testAutoboxingAroundAdvice_pr119210_3() {
+		runTest("autoboxing around advice - 3");
+	}
+
+	public void testBadDecp_pr110788_1() {
+		runTest("bad generic decp - 1");
+	}
+
+	public void testBadDecp_pr110788_2() {
+		runTest("bad generic decp - 2");
+	}
+
+	public void testBadDecp_pr110788_3() {
+		runTest("bad generic decp - 3");
+	}
+
+	public void testBadDecp_pr110788_4() {
+		runTest("bad generic decp - 4");
+	}
+
+	// public void testSimplifiedGenericAspectITDTest() { runTest("spurious override method warning - 3");}
+	// public void testSpuriousOverrideMethodWarning_pr119570_1() { runTest("spurious override method warning");}
+	// public void testSpuriousOverrideMethodWarning_pr119570_2() { runTest("spurious override method warning - 2");}
+
+	public void testBrokenSwitch_pr117854() {
+		runTest("broken switch transform");
+	}
+
+	public void testVarargsITD_pr110906() {
+		runTest("ITD varargs problem");
+	}
+
+	public void testBadRenderer_pr86903() {
+		runTest("bcelrenderer bad");
+	}
+
+	// public void testIllegalInitialization_pr118326_1() { runTest("illegal initialization - 1");}
+	// public void testIllegalInitialization_pr118326_2() { runTest("illegal initialization - 2");}
+	public void testLintForAdviceSorting_pr111667() {
+		runTest("lint for advice sorting");
+	}
+
+	public void testIncompatibleClassChangeError_pr113630_1() {
+		runTest("IncompatibleClassChangeError - errorscenario");
+	}
+
+	public void testIncompatibleClassChangeError_pr113630_2() {
+		runTest("IncompatibleClassChangeError - workingscenario");
+	}
+
+	public void testFieldGetProblemWithGenericField_pr113861() {
+		runTest("field-get problems with generic field");
+	}
+
+	public void testAccesstoPrivateITDInNested_pr118698() {
+		runTest("access to private ITD from nested type");
+	}
+
+	public void testDeclareAnnotationOnNonExistentType_pr99191_1() {
+		runTest("declare annotation on non existent type - 1");
+	}
+
+	public void testDeclareAnnotationOnNonExistentType_pr99191_2() {
+		runTest("declare annotation on non existent type - 2");
+	}
+
+	public void testDeclareAnnotationOnNonExistentType_pr99191_3() {
+		runTest("declare annotation on non existent type - 3");
+	}
+
+	public void testDeclareAnnotationOnNonExistentType_pr99191_4() {
+		runTest("declare annotation on non existent type - 4");
+	}
+
+	public void testDeclareAnnotationOnNonExistentType_pr99191_5() {
+		runTest("declare annotation on non existent type - 5");
+	}
+
+	public void testBadGenericSigAttribute_pr110927() {
+		runTest("cant create signature attribute");
+		Signature sig = GenericsTests.getClassSignature(ajc, "I");
+		if (sig == null)
+			fail("Couldn't find signature attribute for type I");
+		String sigString = sig.getSignature();
+		if (!(sigString.equals("Ljava/lang/Object;LIE2;LIE1<Ljava/lang/String;>;") || sigString
+				.equals("Ljava/lang/Object;LIE1<Ljava/lang/String;>;LIE2;"))) {
+			fail("Signature was " + sigString
+					+ " when should have been something like Ljava/lang/Object;LIE1<Ljava/lang/String;>;LIE2;");
+		}
+	}
+
+	public void test_typeProcessingOrderWhenDeclareParents() {
+		runTest("Order of types passed to compiler determines weaving behavior");
+	}
+
+	public void test_aroundMethod() {
+		runTest("method called around in class");
+	}
+
+	public void test_aroundMethodAspect() {
+		runTest("method called around in aspect");
+	}
+
+	public void test_ambiguousBindingsDetection() {
+		runTest("Various kinds of ambiguous bindings");
+	}
+
+	public void test_ambiguousArgsDetection() {
+		runTest("ambiguous args");
+	}
+
+	public void testIncorrectExceptionTableWhenBreakInMethod_pr78021() {
+		runTest("Injecting exception into while loop with break statement causes catch block to be ignored");
+	}
+
+	public void testIncorrectExceptionTableWhenReturnInMethod_pr79554() {
+		runTest("Return in try-block disables catch-block if final-block is present");
+	}
+
+	public void testMissingDebugInfoForGeneratedMethods_pr82570() throws ClassNotFoundException {
+		runTest("Weaved code does not include debug lines");
+		boolean f = false;
+		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(), "PR82570_1");
+		Method[] meths = jc.getMethods();
+		for (int i = 0; i < meths.length; i++) {
+			Method method = meths[i];
+			if (f)
+				System.err.println("Line number table for " + method.getName() + method.getSignature() + " = "
+						+ method.getLineNumberTable());
+			assertTrue("Didn't find a line number table for method " + method.getName() + method.getSignature(), method
+					.getLineNumberTable() != null);
+		}
+
+		// This test would determine the info isn't there if you pass -g:none ...
+		// cR = ajc(baseDir,new String[]{"PR82570_1.java","-g:none"});
+		// assertTrue("Expected no compile problem:"+cR,!cR.hasErrorMessages());
+		// System.err.println(cR.getStandardError());
+		// jc = getClassFrom(ajc.getSandboxDirectory(),"PR82570_1");
+		// meths = jc.getMethods();
+		// for (int i = 0; i < meths.length; i++) {
+		// Method method = meths[i];
+		// assertTrue("Found a line number table for method "+method.getName(),
+		// method.getLineNumberTable()==null);
+		// }
+	}
+
+	public void testCanOverrideProtectedMethodsViaITDandDecp_pr83303() {
+		runTest("compiler error when mixing inheritance, overriding and polymorphism");
+	}
+
+	public void testPerTypeWithin_pr106554() {
+		runTest("Problem in staticinitialization with pertypewithin aspect");
+	}
+
+	public void testPerTypeWithinMissesNamedInnerTypes() {
+		runTest("pertypewithin() handing of inner classes (1)");
+	}
+
+	public void testPerTypeWithinMissesAnonymousInnerTypes() {
+		runTest("pertypewithin() handing of inner classes (2)");
+	}
+
+	public void testPerTypeWithinIncorrectlyMatchingInterfaces() {
+		runTest("pertypewithin({interface}) illegal field modifier");
+	}
+
+	public void test051_arrayCloningInJava5() {
+		runTest("AJC possible bug with static nested classes");
+	}
+
+	public void testBadASMforEnums() throws IOException {
+		runTest("bad asm for enums");
+
+		if (LangUtil.is15VMOrGreater()) {
+			ByteArrayOutputStream baos = new ByteArrayOutputStream();
+			PrintWriter pw = new PrintWriter(baos);
+			AsmManager.dumptree(pw, AsmManager.lastActiveStructureModel.getHierarchy().getRoot(), 0);
+			pw.flush();
+			String tree = baos.toString();
+			assertTrue("Expected 'Red [enumvalue]' somewhere in here:" + tree, tree.indexOf("Red  [enumvalue]") != -1);
+		}
+	}
+
+	public void npeOnTypeNotFound() {
+		runTest("structure model npe on type not found");
+	}
+
+	public void testNoRuntimeExceptionSoftening() {
+		runTest("declare soft of runtime exception");
+	}
+
+	public void testRuntimeNoSoftenWithHandler() {
+		runTest("declare soft w. catch block");
+	}
+
+	public void testSyntaxError() {
+		runTest("invalid cons syntax");
+	}
+
+	public void testVarargsInConsBug() {
+		runTest("varargs in constructor sig");
+	}
+
+	public void testAspectpathdirs() {
+		runTest("dirs on aspectpath");
+	}
+
+	public void testIntroSample() {
+		runTest("introduction sample");
+	}
+
+	public void testPTWInterface() {
+		runTest("pertypewithin({interface}) illegal field modifier");
+	}
+
+	public void testEnumCalledEnumEtc() {
+		runTest("enum called Enum, annotation called Annotation, etc");
+	}
+
+	public void testInternalCompilerError_pr86832() {
+		runTest("Internal compiler error");
+	}
+
+	public void testCloneMethod_pr83311() {
+		runTest("overriding/polymorphism error on interface method introduction");
+	}
+
+	// IfPointcut.findResidueInternal() was modified to make this test complete in a short amount
+	// of time - if you see it hanging, someone has messed with the optimization.
+	public void testIfEvaluationExplosion_pr94086() {
+		runTest("Exploding compile time with if() statements in pointcut");
+	}
+
+	public void testReflectNPE_pr94167() {
+		runTest("NPE in reflect implementation");
+	}
+
+	public void testStaticImports_pr84260() {
+		runTest("static import failures");
+	}
+
+	public void testGenerics_pr99089() {
+		runTest("ArrayIndexOutOfBoundsException - Generics in privileged aspects");
+	}
+
+	public void testGenerics_pr95993() {
+		runTest("NPE at ClassScope.java:660 when compiling generic class");
+	}
+
+	public void testItdGenerics_pr99228() {
+		runTest("ITD of a field into a generic class");
+	}
+
+	public void testItdGenerics_pr98320() {
+		runTest("intertype with nested generic type");
+	}
+
+	public void testItdGenerics_pr100227() {
+		runTest("inner class with generic enclosing class");
+	}
+
+	public void testItdGenerics_pr100260() {
+		runTest("methods inherited from a generic parent");
+	}
+
+	public void testSyntaxErrorNPE_pr103266() {
+		runTest("NPE on syntax error");
+	}
+
+	public void testFinalAbstractClass_pr109486() {
+		runTest("Internal compiler error (ClassParser.java:242)");
+	}
+
+	public void testComplexBinding_pr102210() {
+		runTest("NullPointerException trying to compile");
+	}
+
+	public void testIllegalStateExceptionOnNestedParameterizedType_pr106634() {
+		runTest("IllegalStateException unpacking signature of nested parameterized type");
+	}
+
+	public void testParseErrorOnAnnotationStarPlusPattern() {
+		runTest("(@Foo *)+ type pattern parse error");
+	}
+
+	public void test_pr106130_tooManyLocals() {
+		runTest("test weaving with > 256 locals");
+	}
+
+	public void testMissingNamePattern_pr106461() {
+		runTest("missing name pattern");
+	}
+
+	public void testMissingNamePattern_pr107059() {
+		runTest("parser crashes on call(void (@a *)(..)");
+	}
+
+	public void testIntermediateAnnotationMatching() {
+		runTest("intermediate annotation matching");
+	}
+
+	public void testBadRuntimeTestGeneration() {
+		runTest("target(@Foo *)");
+	}
+
+	public void testErrorMessageOnITDWithTypePatterns() {
+		runTest("clear error message on itd with type pattern");
+	}
+
+	public void testAjKeywordsAsIdentifiers() {
+		runTest("before and after are valid identifiers in classes");
+	}
+
+	public void testAjKeywordsAsIdentifiers2() {
+		runTest("before and after are valid identifiers in classes, part 2");
+	}
+
+	public void testNoBeforeReturningAdvice() {
+		runTest("before returning advice not allowed!");
+	}
+
+	public void testDetectVoidFieldType() {
+		runTest("void field type in pointcut expression");
+	}
+
+	public void testPointcutOverriding() {
+		runTest("overriding final pointcut from super-aspect");
+	}
+
+	public void testAtSuppressWarnings() {
+		runTest("@SuppressWarnings should suppress");
+	}
+
+	public void testDEOWWithBindingPointcut() {
+		runTest("declare warning : foo(str) : ...;");
+	}
+
+	public void testAroundAdviceAndInterfaceInitializer() {
+		runTest("around advice on interface initializer");
+	}
+
+	public void testGoodErrorMessageOnUnmatchedMemberSyntax() {
+		runTest("good error message for unmatched member syntax");
+	}
+
+	public void testITDWithNoExceptionAndIntermediary() {
+		runTest("itd override with no exception clause");
+	}
+
+	public void testAnonymousInnerClasses() {
+		runTest("anonymous inner classes");
+	}
+
+	public void testMultipleAnonymousInnerClasses() {
+		runTest("multiple anonymous inner classes");
+	}
+
+	public void testPrivilegedMethodAccessorsGetRightExceptions_pr82989() {
+		runTest("Compiler error due to a wrong exception check in try blocks");
+	}
+
+	public void testAnonymousInnerClassWithMethodReturningTypeParameter_pr107898() {
+		runTest("anonymous inner class with method returning type parameter");
+	}
+
+	public void testMatchingOfObjectArray() {
+		runTest("matching against Object[]");
+	}
+
+	public void testMultipleAnonymousInnerClasses_pr108104() {
+		runTest("multiple anonymous inner classes 2");
+	}
+
+	public void testSignatureMatchingInMultipleOverrideScenario() {
+		runTest("signature matching in override scenario");
+	}
+
+	public void testWildcardAnnotationMatching_pr108245() {
+		runTest("wildcard annotation matching - pr108245");
+	}
+
+	public void testInnerTypesAndTypeVariables() {
+		runTest("inner types and type variables");
+	}
+
+	public void testAtAfterThrowingWithNoFormal() {
+		runTest("@AfterThrowing with no formal specified");
+	}
+
+	public void testParameterizedVarArgsMatch() {
+		runTest("varargs with type variable");
+	}
+
+	public void testFieldAccessInsideITDM() {
+		runTest("itd field access inside itd method");
+	}
+
+	public void testTypeVarWithTypeVarBound() {
+		runTest("type variable with type variable bound");
+	}
+
+	public void testEnumSwitchInITD() {
+		runTest("switch on enum inside ITD method");
+	}
+
+	public void testInnerTypeOfGeneric() {
+		runTest("inner type of generic interface reference from parameterized type");
+	}
+
+	public void testDeclareParentsIntroducingCovariantReturnType() {
+		runTest("declare parents introducing override with covariance");
+	}
+
+	public void testInnerClassPassedToVarargs() {
+		runTest("inner class passed as argument to varargs method");
+	}
+
+	public void testInlinedFieldAccessInProceedCall() {
+		runTest("inlined field access in proceed call");
+	}
+
+	public void testVisibiltyInSignatureMatchingWithOverridesPart1() {
+		runTest("visibility in signature matching with overrides - 1");
+	}
+
+	public void testVisibiltyInSignatureMatchingWithOverridesPart2() {
+		runTest("visibility in signature matching with overrides - 2");
+	}
+
+	public void testVisibiltyInSignatureMatchingWithOverridesPart3() {
+		runTest("visibility in signature matching with overrides - 3");
+	}
+
+	public void testArgsGeneratedCorrectlyForAdviceExecution() {
+		runTest("args generated correctly for advice execution join point");
+	}
+
+	public void testNoUnusedWarningsOnAspectTypes() {
+		runTest("no unused warnings on aspect types");
+	}
+
+	public void testSyntheticArgumentsOnITDConstructorsNotUsedInMatching() {
+		runTest("synthetic arguments on itd cons are not used in matching");
+	}
+
+	public void testParsingOfGenericTypeSignature() {
+		runTest("parse generic type signature with parameterized type in interface");
+	}
+
+	public void testOverrideAndCovarianceWithDecPRuntime() {
+		runTest("override and covariance with decp - runtime");
+	}
+
+	public void testOverrideAndCovarianceWithDecPRuntimeMultiFiles() {
+		runTest("override and covariance with decp - runtime separate files");
+	}
+
+	public void testOverrideAndCovarianceWithDecPRuntimeMultiFilesBinaryWeaving() {
+		runTest("override and covariance with decp - binary weaving");
+	}
+
+	public void testAbstractSynchronizedITDMethods() {
+		runTest("abstract synchronized itdms not detected");
+	}
+
+	public void testSynchronizedITDInterfaceMethods() {
+		runTest("synchronized itd interface methods");
+	}
+
+	public void testNoWarningOnUnusedPointcut() {
+		runTest("unused private pointcuts");
+	}
+
+	public void testITDOnInterfaceWithExistingMember() {
+		runTest("itd interface method already existing on interface");
+	}
+
+	public void testFinalITDMOnInterface() {
+		runTest("final itd methods on interfaces");
+	}
+
+	public void testPrivatePointcutOverriding() {
+		runTest("can't override private pointcut in abstract aspect");
+	}
+
+	public void testAdviceOnCflow() {
+		runTest("advising cflow advice execution");
+	}
+
+	public void testNoTypeMismatchOnSameGenericTypes() {
+		runTest("no type mismatch on generic types in itds");
+	}
+
+	public void testSuperCallInITD() {
+		runTest("super call in ITD");
+	}
+
+	public void testSuperCallInITDPart2() {
+		runTest("super call in ITD - part 2");
+	}
+
+	public void testAtAnnotationBadTest_pr103740() {
+		runTest("Compiler failure on at_annotation");
+	}
+
+	public void testNoUnusedParameterWarningsForSyntheticAdviceArgs() {
+		runTest("no unused parameter warnings for synthetic advice args");
+	}
+
+	public void testNoVerifyErrorWithSetOnInnerType() {
+		runTest("no verify error with set on inner type");
+	}
+
+	public void testCantFindTypeErrorWithGenericReturnTypeOrParameter() {
+		runTest("cant find type error with generic return type or parameter");
+	}
+
+	public void testNoVerifyErrorOnGenericCollectionMemberAccess() {
+		runTest("no verify error on generic collection member access");
+	}
+
+	public void testRawAndGenericTypeConversionITDCons() {
+		runTest("raw and generic type conversion with itd cons");
+	}
+
+	public void testAtAnnotationBindingWithAround() {
+		runTest("@annotation binding with around advice");
+	}
+
+	public void testUnableToBuildShadows_pr109728() {
+		runTest("Unable to build shadows");
+	}
+
+	public void testMessageOnMissingTypeInDecP() {
+		runTest("declare parents on a missing type");
+	}
+
+	public void testParameterizedGenericMethods() {
+		runTest("parameterized generic methods");
+	}
+
+	public void testIllegalChangeToPointcutDeclaration_pr111915() {
+		runTest("test illegal change to pointcut declaration");
+	}
+
+	public void testCantProvideDefaultImplViaITD_pr110307_1() {
+		runTest("Cant provide default implementation via ITD - 1");
+	}
+
+	public void testCantProvideDefaultImplViaITD_pr110307_2() {
+		runTest("Cant provide default implementation via ITD - 2");
+	}
+
+	public void testCantProvideDefaultImplViaITD_pr110307_3() {
+		runTest("Cant provide default implementation via ITD - 3");
+	}
+
+	public void testCantProvideDefaultImplViaITD_pr110307_4() {
+		runTest("Cant provide default implementation via ITD - 4");
+	}
+
+	public void testCantProvideDefaultImplViaITD_pr110307_5() {
+		runTest("Cant provide default implementation via ITD - 5");
+	}
+
+	// Needs a change in the compiler so that getType() can be overridden in the intertype scope - thats
+	// where we can police whether a type variable has been used without being specified appropriately.
+	// public void testCantProvideDefaultImplViaITD_pr110307_6() {runTest("Cant provide default implementation via ITD - 6");}
+
+	public void testCantProvideDefaultImplViaITD_pr110307_7() {
+		runTest("Cant provide default implementation via ITD - 7");
+	}
+
+	public void testCallJoinPointsInAnonymousInnerClasses() {
+		runTest("call join points in anonymous inner classes");
+	}
+
+	public void testNoRequirementForUnwovenTypesToBeExposedToWeaver() {
+		runTest("default impl of Runnable");
+	}
+
+	public void testArrayCloneCallJoinPoints() {
+		runTest("array clone call join points in 1.4 vs 1.3");
+	}
+
+	public void testDebugInfoForAroundAdvice() {
+		runTest("debug info in around advice inlining");
+	}
+
+	public void testCCEWithGenericWildcard_pr112602() {
+		runTest("ClassCastException with generic wildcard");
+	}
+
+	public void testVarArgsIITDInConstructor() {
+		runTest("ITD varargs in constructor");
+	}
+
+	public void testWeaveInfoMessageForDeclareAtMethodOnITDdMethod() {
+		runTest("weaveinfo message for declare at method on an ITDd method");
+	}
+
+	public void testITDCWithNoExplicitConsCall() {
+		runTest("ITDC with no explicit cons call");
+	}
+
+	public void testJava5SpecificFeaturesUsedAtJava14OrLower() {
+		runTest("java 5 pointcuts and declares at pre-java 5 compliance levels");
+	}
+
+	public void testAnonymousTypes() {
+		runTest("Anonymous types and nome matching");
+	}
+
+	public void testAdviceExecutionJPToStringForms() {
+		runTest("adviceexecution join point toString forms");
+	}
+
+	public void testAssertWithinPointcutExpression() {
+		runTest("pointcut expression containing 'assert'");
+	}
+
+	public void testNoVerifyErrorWithTwoThisPCDs_pr113447() {
+		runTest("no verify error with two this pcds");
+	}
+
+	public void testNoVerifyErrorWithTwoAtThisPCDs_pr113447() {
+		runTest("no verify error with two at this pcds");
+	}
+
+	public void testNoVerifyErrorWithAtWithinPCDs_pr113447() {
+		runTest("no verify error with at within pcds");
+	}
+
+	public void testNoVerifyErrorWithAtWithincodePCDs_pr113447() {
+		runTest("no verify error with at withincode pcds");
+	}
+
+	public void testNoVerifyErrorWithAtAnnotationPCDs_pr113447() {
+		runTest("no verify error with at annotation pcds");
+	}
+
+	public void testNoVerifyErrorWithTwoArgsPCDs_pr113447() {
+		runTest("no verify error with two args pcds");
+	}
+
+	public void testNoStackOverflowWithCircularPCDInGenericAspect() {
+		runTest("no StackOverflowError with circular pcd in generic aspect");
+	}
+
+	public void testNoStackOverflowWithCircularPCDInGenericAspect2() {
+		runTest("no StackOverflowError with circular pcd in generic aspect - 2");
+	}
+
+	public void testNPEInThisJoinPointStaticPart() {
+		runTest("thisJoinPointStaticPart in if test");
+	}
+
+	public void testPointcutParsingOfCompiledPointcuts() {
+		runTest("pointcut parsing with ajc compiled pointcut references");
+	}
+
+	public void testReflectionOfAbstractITDs() {
+		runTest("reflection on abstract ITDs (Billing example)");
+	}
+
+	public void testDeclareSoftWithAdviceExecution() {
+		runTest("declare soft and adviceexecution");
+	}
+
+	public void testDeclareSoftWithExclusions() {
+		runTest("declare soft and exclusions");
+	}
+
+	public void testReturningObjectBinding() {
+		runTest("returning(Object) binding");
+	}
+
+	public void testPerTargetAndNegation() {
+		runTest("pertarget and negated pointcut");
+	}
+
+	public void testParameterizedPointcutAndAdvice() {
+		runTest("parameterized pointcut and advice");
+	}
+
+	public void testDoublyParameterizedAbstractType() {
+		runTest("double parameter generic abstract type");
+	}
+
+	public void testArgNamesInAdviceAnnotations() {
+		runTest("arg names in advice annotations");
+	}
+
+	/*
+	 * Load-time weaving bugs
+	 */
+	public void testNPEinWeavingAdaptor_pr116626() {
+		runTest("NPE in WeavingAdaptor");
+	}
+
+	public void testXlintMessageForImproperAnnotationType_pr115252_Exact() {
+		runTest("xlint message for improper exact annotation type");
+	}
+
+	public void testXlintMessageForImproperAnnotationType_pr115252_OR() {
+		runTest("xlint message for improper annotation type inside OR");
+	}
+
+	public void testXlintMessageForImproperAnnotationType_pr115252_AND() {
+		runTest("xlint message for improper annotation type inside AND");
+	}
+
+	public void testXlintMessageForImproperAnnotationType_pr115252_Return() {
+		runTest("xlint message for improper annotated return type");
+	}
+
+	public void testXlintMessageForImproperAnnotationType_pr115252_Declaring() {
+		runTest("xlint message for improper annotated declaring type");
+	}
+
+	public void testXlintMessageForImproperAnnotationType_pr115252_Parameter() {
+		runTest("xlint message for improper annotated parameter type");
+	}
+
+	public void testXlintMessageForImproperAnnotationType_pr115252_Throws() {
+		runTest("xlint message for improper annotated throws pattern");
+	}
+
+	public void testXlintMessageForImproperAnnotationType_pr115252_MoreThanOne() {
+		runTest("xlint message for more than one improper annotated parameter type");
+	}
+
+	public void testNoNPEWhenInaccessibleMethodIsCalledWithinITD_pr119019() {
+		runTest("no NPE when inaccessible method is called within itd");
+	}
+
+	public void testNoNPEWithOrPointcutAndMoreThanOneArgs_pr118149() {
+		runTest("no NPE with or pointcut and more than one args");
+	}
+
+	public void testNoSOBWithGenericInnerAspects_pr119543() {
+		runTest("no StringOutOfBoundsException with generic inner aspects");
+	}
+
+	public void testIllegalAccessErrorWithAroundAdvice_pr119657() {
+		runTest("IllegalAccessError with around advice on interface method call");
+	}
+
+	public void testIllegalAccessErrorWithAroundAdviceNotSelf_pr119657() {
+		runTest("IllegalAccessError with around advice on interface method call not self");
+	}
+
+	public void testIllegalAccessErrorWithAroundAdviceTerminateAfterCompilationLTW_pr119657() {
+		runTest("IllegalAccessError with around advice on interface method call using -XterminateAfterCompilation and LTW");
+	}
+
+	public void testIllegalAccessErrorWithAroundAdviceLTW_pr119657() {
+		runTest("IllegalAccessError with around advice on interface method call using LTW");
+	}
+
+	public void testIllegalAccessErrorWithAroundAdviceNotSelfLTW_pr119657() {
+		runTest("IllegalAccessError with around advice on interface method call not self using LTW");
+	}
+
+	public void testIllegalAccessErrorWithAroundAdviceSelfAndNotSelfLTW_pr119657() {
+		runTest("IllegalAccessError with around advice on interface method call self and not self using LTW");
+	}
+
+	public void testIllegalAccessErrorWithAroundAdviceLTWNoInline_pr119657() {
+		runTest("IllegalAccessError with around advice on interface method call using LTW and -XnoInline");
+	}
+
+	public void testReflectOnCodeStyleITDs() {
+		runTest("reflection on itds");
+	}
+
+	public void testReflectOnAtAspectJDecP() {
+		runTest("reflection on @DeclareParents");
+	}
+
+	public void testModifierOverrides() {
+		runTest("modifier overrides");
+	}
+
+	public void testAbstractPerThisInAtAspectJ() {
+		runTest("abstract perthis in @AspectJ");
+	}
+
+	public void testNPEInBcelAdviceWithConcreteAspect_pr121385() {
+		runTest("override protected pointcut in aop.xml concrete aspect");
+	}
+
+	// helper methods.....
+
+	public SyntheticRepository createRepos(File cpentry) {
+		ClassPath cp = new ClassPath(cpentry + File.pathSeparator + System.getProperty("java.class.path"));
+		return SyntheticRepository.getInstance(cp);
+	}
+
+	protected JavaClass getClassFrom(File where, String clazzname) throws ClassNotFoundException {
+		SyntheticRepository repos = createRepos(where);
+		return repos.loadClass(clazzname);
+	}
 
 }
\ No newline at end of file
@@ -23,384 +23,379 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class AnnotationBinding extends XMLBasedAjcTestCase {
 
-  public static Test suite() {
-    return XMLBasedAjcTestCase.loadSuite(AnnotationBinding.class);
-  }
-
-  protected File getSpecFile() {
-    return new File("../tests/src/org/aspectj/systemtest/ajc150/ajc150.xml");
-  }
-  
-  ///////////////////////////////////// @ANNOTATION and CALL
-  
-  // Very simple annotation binding for 'call() && @annotation()'
-  public void testCallAnnotationBinding1() {
-  	runTest("call annotation binding 1");
-  }
-
-  // 'call() && @annotation()' when the called method has multiple arguments
-  public void testCallAnnotationBinding2() {
- 	runTest("call annotation binding 2");
-  }
-  
-  // 'call() && @annotation()' when the called method takes primitive arguments (YUCK!)
-  public void testCallAnnotationBinding3() {
- 	runTest("call annotation binding 3");
-  }
-  
-  // 'call() && @annotation()' when runtime type will exhibit different annotation (due to interface implementing)
-  public void testCallAnnotationBinding4() {
-  	runTest("call annotation binding 4");
-  }
-  
-  // 'call() && @annotation()' when target doesnt have an annotation !
-  public void testCallAnnotationBinding5() {
-  	runTest("call annotation binding 5");
-  }
-  
-  // 'call() && @annotation()' when runtime type will exhibit different annotation (due to subclassing)
-  public void testCallAnnotationBinding6() {
-  	runTest("call annotation binding 6");
-  }
-  
-  // 'call() && @annotation()' using named pointcut
-  public void testCallAnnotationBinding7() {
-  	runTest("call annotation binding 7");
-  }
-  
-  ///////////////////////////////////// @TARGET
-  
-  // 'call() && @target()'
-  public void testAtTargetAnnotationBinding1() {
-  	runTest("@target annotation binding 1");
-  }
-  
-  // 'call() && @target() && @target'
-  public void testAtTargetAnnotationBinding2() {
-  	runTest("@target annotation binding 2");
-  }
-  
-  // 'call() && @target()' - using a type hierarchy where some levels are missing annotations
-  public void testAtTargetAnnotationBinding3() {
-  	runTest("@target annotation binding 3");
-  }
-  
-  // 'call() && @target()' - using a type hierarchy where some levels are missing annotations 
-  // but the annotation is inherited
-  public void testAtTargetAnnotationBinding4() {
-  	runTest("@target annotation binding 4");
-  }
-  
-  // @target() with an annotation in a package
-  public void testAtTargetAnnotationBinding5() {
-  	runTest("@target annotation binding 5");
-  }
-  
-  
-  ///////////////////////////////////// @THIS
-  
-  // 'call() && @this()'
-  public void testAtThisAnnotationBinding1() {
-  	runTest("@this annotation binding 1");
-  }
-  
-  // 'call() && @this() && @this'
-  public void testAtThisAnnotationBinding2() {
-  	runTest("@this annotation binding 2");
-  }
-  
-  // 'call() && @this()' - using a type hierarchy where some levels are missing annotations
-  public void testAtThisAnnotationBinding3() {
-  	runTest("@this annotation binding 3");
-  }
-  
-  // 'call() && @this()' - using a type hierarchy where some levels are missing annotations 
-  // but the annotation is inherited
-  public void testAtThisAnnotationBinding4() {
-  	runTest("@this annotation binding 4");
-  }
-  
-  // '@this() and @target()' used together
-  public void testAtThisAtTargetAnnotationBinding() {
-  	runTest("@this annotation binding 5");
-  }
-  
-  ///////////////////////////////////// @ARGS
-  
-  // complex case when there are 3 parameters
-  public void testAtArgs1() {
-  	runTest("@args annotation binding 1");
-  }
-  
-  // simple case when there is only one parameter
-  public void testAtArgs2() {
-  	runTest("@args annotation binding 2");
-  }
-  
-  // simple case when there is only one parameter and no binding
-  public void testAtArgs3() {
-  	runTest("@args annotation binding 3");
-  }
-  
-  // complex case binding different annotation kinds
-  public void testAtArgs4() {
-  	runTest("@args annotation binding 4");
-  }
-  
-  // check @args and execution()
-  public void testAtArgs5() {
-  	runTest("@args annotation binding 5");
-  }
-  
-
-  ///////////////////////////////////// @ANNOTATION and EXECUTION
-  
-  // 'execution() && @annotation()' 
-  public void testExecutionAnnotationBinding1() {
-  	runTest("execution and @annotation");
-  }
-  
-  ///////////////////////////////////// @ANNOTATION and SET
-  
-  // 'set() && @annotation()' 
-  public void testFieldAnnotationBinding1() {
-  	runTest("set and @annotation");
-  }
-  
-  // 'get() && @annotation()' 
-  public void testFieldAnnotationBinding2() {
-  	runTest("get and @annotation");
-  }
-  
-  // 'get() && @annotation()' when using array fields
-  public void testFieldAnnotationBinding3() {
-  	runTest("get and @annotation with arrays");
-  }
-  
-  ///////////////////////////////////// @ANNOTATION and CTOR-CALL
-  
-  // 'ctor-call(new) && @annotation()' 
-  public void testCtorCallAnnotationBinding1() {
-  	runTest("cons call and @annotation");
-  }
-  
-  ///////////////////////////////////// @ANNOTATION and CTOR-CALL
-  
-  // 'ctor-execution() && @annotation()' 
-  public void testCtorExecAnnotationBinding1() {
-  	runTest("cons exe and @annotation");
-  }
-    
-  ///////////////////////////////////// @ANNOTATION and STATICINITIALIZATION
-  
-  // 'staticinitialization() && @annotation()' 
-  public void testStaticInitAnnotationBinding1() {
-  	runTest("staticinit and @annotation");
-  }
-  
-  ///////////////////////////////////// @ANNOTATION and PREINITIALIZATION
-  
-  // 'preinitialization() && @annotation()' 
-  public void testPreInitAnnotationBinding1() {
-  	runTest("preinit and @annotation");
-  }
-  
-  ///////////////////////////////////// @ANNOTATION and INITIALIZATION
-  
-  // 'initialization() && @annotation()' 
-  public void testInitAnnotationBinding1() {
-  	runTest("init and @annotation");
-  }
-  
-  ///////////////////////////////////// @ANNOTATION and ADVICEEXECUTION
-  
-  // 'adviceexecution() && @annotation()' 
-  public void testAdviceExecAnnotationBinding1() {
-  	runTest("adviceexecution and @annotation");
-  }
-  
-  ///////////////////////////////////// @ANNOTATION and HANDLER
-  
-  // 'handler() && @annotation()' 
-  public void testHandlerAnnotationBinding1() {
-  	runTest("handler and @annotation");
-  }
-  
-  ///////////////////////////////////// @WITHIN
-
-  // '@within()'
-  public void testWithinBinding1() {
-	runTest("@within");
-  }
-  
-  //'@within()' but multiple types around (some annotated)
-  public void testWithinBinding2() {
-	runTest("@within - multiple types");
-  }
-  
-  ///////////////////////////////////// @WITHINCODE
-  
-  // '@withincode() && call(* println(..))'
-  public void testWithinCodeBinding1() {
-  	runTest("@withincode() and call(* println(..))");
-  }
-  
-
-  ///////////////////////////////////// @ANNOTATION complex tests
-  
-  // Using package names for the types (including the annotation) - NO BINDING
-  public void testPackageNamedTypesNoBinding() {
-  	runTest("packages and no binding");
-  }
-  
-  // Using package names for the types (including the annotation) - INCLUDES BINDING
-  public void testPackageNamedTypesWithBinding() {
-  	runTest("packages and binding");
-  }
-  
-  // declare parents: @Color * implements Serializable
-  public void testDeclareParentsWithAnnotatedAnyPattern() {
-  	runTest("annotated any pattern");
-  }
-  
-  // Should error (in a nice way!) on usage of an annotation that isnt imported
-  public void testAnnotationUsedButNotImported() {
-  	runTest("annotation not imported");
-  }
-  
-  // Binding with calls/executions of static methods
-  public void testCallsAndExecutionsOfStaticMethods() {
-  	runTest("binding with static methods");
-  }
-  
-  /////////////////////////////////////////////////////////////////////////////////
-  // annotation binding with ITDs
-  
-  public void testAnnotationBindingAndITDs1() {
-  	runTest("simple binding annotation values where itd method is annotated");
-  }
-  
-  public void testAnnotationBindingAndITDs2() {
-  	runTest("simple binding annotation values where itd field is annotated");
-  }
- 
-  public void testAnnotationBindingAndITDs3() {
-  	runTest("simple binding annotation values where itd ctor is annotated");
-  }
-  
-  public void testAnnotationBindingAndITDs4() {
-  	runTest("simple binding annotation values where itd method is annotated via declare");
-  }  
-  
-  public void testAnnotationBindingAndITDs5() {
-  	runTest("simple binding annotation values where itd field is annotated via declare");
-  }  
-  
-  public void testAnnotationBindingAndITDs6() {
-  	runTest("simple binding annotation values where itd field is annotated multiple times via declare");
-  }  
-  
-  public void testAnnotationBindingAndITDs7() {
-  	runTest("simple binding annotation values where itd ctor is annotated via declare");
-  }  
-  
-  public void testAnnotationBindingAndITDs4_asmtest() {
-	  //AsmManager.setReporting("c:/debug.txt",true,true,true,true);
-	  runTest("simple binding annotation values where itd method is annotated via declare");  
-		
-	  	if (getCurrentTest().canRunOnThisVM()) {
-		  	IHierarchy top = AsmManager.getDefault().getHierarchy();
-		  	
-		  	IProgramElement ipe = top.findElementForLabel(top.getRoot(),
-		  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD,
-		  		"declare @method: int A.m() : @Fruit(\"orange\")");
-		  	assertTrue("Couldn't find 'declare @method' element in the tree",ipe!=null);
-		  	
-		    List l = AsmManager.getDefault().getRelationshipMap().get(ipe);
-		  	assertTrue("Should have a relationship but does not ",l.size()>0);
-		  	
-		  	ipe = top.findElementForLabel(top.getRoot(),
-		  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD,
-		  		"declare @method: int A.n() : @Fruit(\"banana\")");
-		  	assertTrue("Couldn't find 'declare @method element in the tree",ipe!=null);
-		  	
-		    l = AsmManager.getDefault().getRelationshipMap().get(ipe);
-		  	assertTrue("Should have a relationship but does not ",l.size()>0);
-
-			Relationship rel = (Relationship)l.get(0);
-			assertTrue("Should have 1 target but has "+rel.getTargets().size(),rel.getTargets().size()==1);
-			String tgt = (String)rel.getTargets().get(0);
-			int lineNumber = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(tgt);
-			assertTrue("Should point to line 10 but doesnt: "+lineNumber,lineNumber == 10);
-	  	}
-  }  
- 
-  public void testAnnotationBindingAndITDs5_asmtest() {
-	 // AsmManager.setReporting("c:/debug.txt",true,true,true,true);
-	  runTest("simple binding annotation values where itd field is annotated via declare");  
-		
-	  	if (getCurrentTest().canRunOnThisVM()) {
-		  	IHierarchy top = AsmManager.getDefault().getHierarchy();
-		  	
-		  	IProgramElement ipe = top.findElementForLabel(top.getRoot(),
-		  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_FIELD,
-		  		"declare @field: int A.i : @Fruit(\"orange\")");
-		  	assertTrue("Couldn't find 'declare @type' element in the tree",ipe!=null);
-		  	
-		    List l = AsmManager.getDefault().getRelationshipMap().get(ipe);
-		  	assertTrue("Should have a relationship but does not ",l.size()>0);
-		  	
-		  	ipe = top.findElementForLabel(top.getRoot(),
-		  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_FIELD,
-		  		"declare @field: java.lang.String A.j : @Fruit(\"banana\")");
-		  	assertTrue("Couldn't find 'declare @field element in the tree",ipe!=null);
-		  	
-		    l = AsmManager.getDefault().getRelationshipMap().get(ipe);
-		  	assertTrue("Should have a relationship but does not ",l.size()>0);
-
-			Relationship rel = (Relationship)l.get(0);
-			assertTrue("Should have 1 target but has "+rel.getTargets().size(),rel.getTargets().size()==1);
-			String tgt = (String)rel.getTargets().get(0);
-			int lineNumber = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(tgt);
-			assertTrue("Should point to line 10 but doesnt: "+lineNumber,lineNumber == 10);
-
-	  	}
-  }  
-  
-  public void testAnnotationBindingAndITDs7_asmtest() {
-	 // AsmManager.setReporting("c:/debug.txt",true,true,true,true);
-	  runTest("simple binding annotation values where itd ctor is annotated via declare");  
-		
-	  	if (getCurrentTest().canRunOnThisVM()) {
-		  	IHierarchy top = AsmManager.getDefault().getHierarchy();
-		  	
-		  	IProgramElement ipe = top.findElementForLabel(top.getRoot(),
-		  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR,
-		  		"declare @constructor: A.new(java.lang.String) : @Fruit(\"pear\")");
-		  	assertTrue("Couldn't find 'declare @constructor' element in the tree",ipe!=null);
-
-		    List l = AsmManager.getDefault().getRelationshipMap().get(ipe);
-		  	assertTrue("Should have a relationship but does not ",l.size()>0);
-		  	
-		  	ipe = top.findElementForLabel(top.getRoot(),
-		  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR,
-		  		"declare @constructor: A.new(int) : @Fruit(\"orange\")");
-		  	assertTrue("Couldn't find 'declare @constructor element in the tree",ipe!=null);
-		  	
-		    l = AsmManager.getDefault().getRelationshipMap().get(ipe);
-		  	assertTrue("Should have a relationship but does not ",l.size()>0);
-
-			Relationship rel = (Relationship)l.get(0);
-			assertTrue("Should have 1 target but has "+rel.getTargets().size(),rel.getTargets().size()==1);
-			String tgt = (String)rel.getTargets().get(0);
-			int lineNumber = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(tgt);
-			assertTrue("Should point to line 10 but doesnt: "+lineNumber,lineNumber == 10);
-
-	  	}
-  }  
-  
-  public void testAnnotationBindingArgsVerifyError_pr92053() {
-	runTest("AtArgs causes a VerifyError: Unable to pop operand off an empty stack");
-  }  
- 
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(AnnotationBinding.class);
+	}
+
+	protected File getSpecFile() {
+		return new File("../tests/src/org/aspectj/systemtest/ajc150/ajc150.xml");
+	}
+
+	// /////////////////////////////////// @ANNOTATION and CALL
+
+	// Very simple annotation binding for 'call() && @annotation()'
+	public void testCallAnnotationBinding1() {
+		runTest("call annotation binding 1");
+	}
+
+	// 'call() && @annotation()' when the called method has multiple arguments
+	public void testCallAnnotationBinding2() {
+		runTest("call annotation binding 2");
+	}
+
+	// 'call() && @annotation()' when the called method takes primitive arguments (YUCK!)
+	public void testCallAnnotationBinding3() {
+		runTest("call annotation binding 3");
+	}
+
+	// 'call() && @annotation()' when runtime type will exhibit different annotation (due to interface implementing)
+	public void testCallAnnotationBinding4() {
+		runTest("call annotation binding 4");
+	}
+
+	// 'call() && @annotation()' when target doesnt have an annotation !
+	public void testCallAnnotationBinding5() {
+		runTest("call annotation binding 5");
+	}
+
+	// 'call() && @annotation()' when runtime type will exhibit different annotation (due to subclassing)
+	public void testCallAnnotationBinding6() {
+		runTest("call annotation binding 6");
+	}
+
+	// 'call() && @annotation()' using named pointcut
+	public void testCallAnnotationBinding7() {
+		runTest("call annotation binding 7");
+	}
+
+	// /////////////////////////////////// @TARGET
+
+	// 'call() && @target()'
+	public void testAtTargetAnnotationBinding1() {
+		runTest("@target annotation binding 1");
+	}
+
+	// 'call() && @target() && @target'
+	public void testAtTargetAnnotationBinding2() {
+		runTest("@target annotation binding 2");
+	}
+
+	// 'call() && @target()' - using a type hierarchy where some levels are missing annotations
+	public void testAtTargetAnnotationBinding3() {
+		runTest("@target annotation binding 3");
+	}
+
+	// 'call() && @target()' - using a type hierarchy where some levels are missing annotations
+	// but the annotation is inherited
+	public void testAtTargetAnnotationBinding4() {
+		runTest("@target annotation binding 4");
+	}
+
+	// @target() with an annotation in a package
+	public void testAtTargetAnnotationBinding5() {
+		runTest("@target annotation binding 5");
+	}
+
+	// /////////////////////////////////// @THIS
+
+	// 'call() && @this()'
+	public void testAtThisAnnotationBinding1() {
+		runTest("@this annotation binding 1");
+	}
+
+	// 'call() && @this() && @this'
+	public void testAtThisAnnotationBinding2() {
+		runTest("@this annotation binding 2");
+	}
+
+	// 'call() && @this()' - using a type hierarchy where some levels are missing annotations
+	public void testAtThisAnnotationBinding3() {
+		runTest("@this annotation binding 3");
+	}
+
+	// 'call() && @this()' - using a type hierarchy where some levels are missing annotations
+	// but the annotation is inherited
+	public void testAtThisAnnotationBinding4() {
+		runTest("@this annotation binding 4");
+	}
+
+	// '@this() and @target()' used together
+	public void testAtThisAtTargetAnnotationBinding() {
+		runTest("@this annotation binding 5");
+	}
+
+	// /////////////////////////////////// @ARGS
+
+	// complex case when there are 3 parameters
+	public void testAtArgs1() {
+		runTest("@args annotation binding 1");
+	}
+
+	// simple case when there is only one parameter
+	public void testAtArgs2() {
+		runTest("@args annotation binding 2");
+	}
+
+	// simple case when there is only one parameter and no binding
+	public void testAtArgs3() {
+		runTest("@args annotation binding 3");
+	}
+
+	// complex case binding different annotation kinds
+	public void testAtArgs4() {
+		runTest("@args annotation binding 4");
+	}
+
+	// check @args and execution()
+	public void testAtArgs5() {
+		runTest("@args annotation binding 5");
+	}
+
+	// /////////////////////////////////// @ANNOTATION and EXECUTION
+
+	// 'execution() && @annotation()'
+	public void testExecutionAnnotationBinding1() {
+		runTest("execution and @annotation");
+	}
+
+	// /////////////////////////////////// @ANNOTATION and SET
+
+	// 'set() && @annotation()'
+	public void testFieldAnnotationBinding1() {
+		runTest("set and @annotation");
+	}
+
+	// 'get() && @annotation()'
+	public void testFieldAnnotationBinding2() {
+		runTest("get and @annotation");
+	}
+
+	// 'get() && @annotation()' when using array fields
+	public void testFieldAnnotationBinding3() {
+		runTest("get and @annotation with arrays");
+	}
+
+	// /////////////////////////////////// @ANNOTATION and CTOR-CALL
+
+	// 'ctor-call(new) && @annotation()'
+	public void testCtorCallAnnotationBinding1() {
+		runTest("cons call and @annotation");
+	}
+
+	// /////////////////////////////////// @ANNOTATION and CTOR-CALL
+
+	// 'ctor-execution() && @annotation()'
+	public void testCtorExecAnnotationBinding1() {
+		runTest("cons exe and @annotation");
+	}
+
+	// /////////////////////////////////// @ANNOTATION and STATICINITIALIZATION
+
+	// 'staticinitialization() && @annotation()'
+	public void testStaticInitAnnotationBinding1() {
+		runTest("staticinit and @annotation");
+	}
+
+	// /////////////////////////////////// @ANNOTATION and PREINITIALIZATION
+
+	// 'preinitialization() && @annotation()'
+	public void testPreInitAnnotationBinding1() {
+		runTest("preinit and @annotation");
+	}
+
+	// /////////////////////////////////// @ANNOTATION and INITIALIZATION
+
+	// 'initialization() && @annotation()'
+	public void testInitAnnotationBinding1() {
+		runTest("init and @annotation");
+	}
+
+	// /////////////////////////////////// @ANNOTATION and ADVICEEXECUTION
+
+	// 'adviceexecution() && @annotation()'
+	public void testAdviceExecAnnotationBinding1() {
+		runTest("adviceexecution and @annotation");
+	}
+
+	// /////////////////////////////////// @ANNOTATION and HANDLER
+
+	// 'handler() && @annotation()'
+	public void testHandlerAnnotationBinding1() {
+		runTest("handler and @annotation");
+	}
+
+	// /////////////////////////////////// @WITHIN
+
+	// '@within()'
+	public void testWithinBinding1() {
+		runTest("@within");
+	}
+
+	// '@within()' but multiple types around (some annotated)
+	public void testWithinBinding2() {
+		runTest("@within - multiple types");
+	}
+
+	// /////////////////////////////////// @WITHINCODE
+
+	// '@withincode() && call(* println(..))'
+	public void testWithinCodeBinding1() {
+		runTest("@withincode() and call(* println(..))");
+	}
+
+	// /////////////////////////////////// @ANNOTATION complex tests
+
+	// Using package names for the types (including the annotation) - NO BINDING
+	public void testPackageNamedTypesNoBinding() {
+		runTest("packages and no binding");
+	}
+
+	// Using package names for the types (including the annotation) - INCLUDES BINDING
+	public void testPackageNamedTypesWithBinding() {
+		runTest("packages and binding");
+	}
+
+	// declare parents: @Color * implements Serializable
+	public void testDeclareParentsWithAnnotatedAnyPattern() {
+		runTest("annotated any pattern");
+	}
+
+	// Should error (in a nice way!) on usage of an annotation that isnt imported
+	public void testAnnotationUsedButNotImported() {
+		runTest("annotation not imported");
+	}
+
+	// Binding with calls/executions of static methods
+	public void testCallsAndExecutionsOfStaticMethods() {
+		runTest("binding with static methods");
+	}
+
+	// ///////////////////////////////////////////////////////////////////////////////
+	// annotation binding with ITDs
+
+	public void testAnnotationBindingAndITDs1() {
+		runTest("simple binding annotation values where itd method is annotated");
+	}
+
+	public void testAnnotationBindingAndITDs2() {
+		runTest("simple binding annotation values where itd field is annotated");
+	}
+
+	public void testAnnotationBindingAndITDs3() {
+		runTest("simple binding annotation values where itd ctor is annotated");
+	}
+
+	public void testAnnotationBindingAndITDs4() {
+		runTest("simple binding annotation values where itd method is annotated via declare");
+	}
+
+	public void testAnnotationBindingAndITDs5() {
+		runTest("simple binding annotation values where itd field is annotated via declare");
+	}
+
+	public void testAnnotationBindingAndITDs6() {
+		runTest("simple binding annotation values where itd field is annotated multiple times via declare");
+	}
+
+	public void testAnnotationBindingAndITDs7() {
+		runTest("simple binding annotation values where itd ctor is annotated via declare");
+	}
+
+	public void testAnnotationBindingAndITDs4_asmtest() {
+		// AsmManager.setReporting("c:/debug.txt",true,true,true,true);
+		runTest("simple binding annotation values where itd method is annotated via declare");
+
+		if (getCurrentTest().canRunOnThisVM()) {
+			AsmManager asm = AsmManager.lastActiveStructureModel;
+			IHierarchy top = asm.getHierarchy();
+
+			IProgramElement ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD,
+					"declare @method: int A.m() : @Fruit(\"orange\")");
+			assertTrue("Couldn't find 'declare @method' element in the tree", ipe != null);
+
+			List l = asm.getRelationshipMap().get(ipe);
+			assertTrue("Should have a relationship but does not ", l.size() > 0);
+
+			ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD,
+					"declare @method: int A.n() : @Fruit(\"banana\")");
+			assertTrue("Couldn't find 'declare @method element in the tree", ipe != null);
+
+			l = asm.getRelationshipMap().get(ipe);
+			assertTrue("Should have a relationship but does not ", l.size() > 0);
+
+			Relationship rel = (Relationship) l.get(0);
+			assertTrue("Should have 1 target but has " + rel.getTargets().size(), rel.getTargets().size() == 1);
+			String tgt = (String) rel.getTargets().get(0);
+			int lineNumber = asm.getHandleProvider().getLineNumberForHandle(tgt);
+			assertTrue("Should point to line 10 but doesnt: " + lineNumber, lineNumber == 10);
+		}
+	}
+
+	public void testAnnotationBindingAndITDs5_asmtest() {
+		// AsmManager.setReporting("c:/debug.txt",true,true,true,true);
+		runTest("simple binding annotation values where itd field is annotated via declare");
+
+		if (getCurrentTest().canRunOnThisVM()) {
+			AsmManager asm = AsmManager.lastActiveStructureModel;
+			IHierarchy top = asm.getHierarchy();
+
+			IProgramElement ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.DECLARE_ANNOTATION_AT_FIELD,
+					"declare @field: int A.i : @Fruit(\"orange\")");
+			assertTrue("Couldn't find 'declare @type' element in the tree", ipe != null);
+
+			List l = asm.getRelationshipMap().get(ipe);
+			assertTrue("Should have a relationship but does not ", l.size() > 0);
+
+			ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.DECLARE_ANNOTATION_AT_FIELD,
+					"declare @field: java.lang.String A.j : @Fruit(\"banana\")");
+			assertTrue("Couldn't find 'declare @field element in the tree", ipe != null);
+
+			l = asm.getRelationshipMap().get(ipe);
+			assertTrue("Should have a relationship but does not ", l.size() > 0);
+
+			Relationship rel = (Relationship) l.get(0);
+			assertTrue("Should have 1 target but has " + rel.getTargets().size(), rel.getTargets().size() == 1);
+			String tgt = (String) rel.getTargets().get(0);
+			int lineNumber = asm.getHandleProvider().getLineNumberForHandle(tgt);
+			assertTrue("Should point to line 10 but doesnt: " + lineNumber, lineNumber == 10);
+
+		}
+	}
+
+	public void testAnnotationBindingAndITDs7_asmtest() {
+		// AsmManager.setReporting("c:/debug.txt",true,true,true,true);
+		runTest("simple binding annotation values where itd ctor is annotated via declare");
+
+		if (getCurrentTest().canRunOnThisVM()) {
+
+			AsmManager asm = AsmManager.lastActiveStructureModel;
+			IHierarchy top = asm.getHierarchy();
+
+			IProgramElement ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR,
+					"declare @constructor: A.new(java.lang.String) : @Fruit(\"pear\")");
+			assertTrue("Couldn't find 'declare @constructor' element in the tree", ipe != null);
+
+			List l = asm.getRelationshipMap().get(ipe);
+			assertTrue("Should have a relationship but does not ", l.size() > 0);
+
+			ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR,
+					"declare @constructor: A.new(int) : @Fruit(\"orange\")");
+			assertTrue("Couldn't find 'declare @constructor element in the tree", ipe != null);
+
+			l = asm.getRelationshipMap().get(ipe);
+			assertTrue("Should have a relationship but does not ", l.size() > 0);
+
+			Relationship rel = (Relationship) l.get(0);
+			assertTrue("Should have 1 target but has " + rel.getTargets().size(), rel.getTargets().size() == 1);
+			String tgt = (String) rel.getTargets().get(0);
+			int lineNumber = asm.getHandleProvider().getLineNumberForHandle(tgt);
+			assertTrue("Should point to line 10 but doesnt: " + lineNumber, lineNumber == 10);
+
+		}
+	}
+
+	public void testAnnotationBindingArgsVerifyError_pr92053() {
+		runTest("AtArgs causes a VerifyError: Unable to pop operand off an empty stack");
+	}
+
 }
\ No newline at end of file
@@ -22,309 +22,309 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class DeclareAnnotationTests extends XMLBasedAjcTestCase {
 
-  public static Test suite() {
-	return XMLBasedAjcTestCase.loadSuite(DeclareAnnotationTests.class);
-  }
-
-  protected File getSpecFile() {
-	return new File("../tests/src/org/aspectj/systemtest/ajc150/ajc150.xml");
-  }
-  
-  // parsing the various forms of declare @
-  public void testDeclareAnnotationParsing() {
-  	runTest("basic declare annotation parse test");
-  }
-  
-  // declare @type
-
-  // declare @type for one simple annotation on one specific type
-  public void testAtType_OneAnnotationHittingOneType_Src() {
-  	runTest("declare @type 1");
-  }
-  
-  // declare @type for one simple annotation to multiple types
-  public void testAtType_OneAnnotationHittingMultipleTypes_Src() {
-  	runTest("declare @type 2");
-  }
-
-  // declare @type for one simple annotation and a pointcut that matches on it
-  public void testAtType_PointcutMatchingOnDeclaredAnnotation() {
-  	runTest("declare @type - with matching pointcut");
-  }
-  
-  // binary weaving declare @type, one annotation on one type
-  public void testAtType_OneAnnotationHittingOneType_Bin() {
-  	runTest("declare @type - binary weaving");
-  }
-  
-  // an annotation with multiple values (all the primitives and string)
-  // is declared upon a single type
-  public void testAtType_ComplexAnnotation_BinWeaving() {
-  	runTest("declare @type - complex annotation - binary weaving");
-  }
-  public void testAtType_ComplexAnnotation_SrcWeaving() {
-  	runTest("declare @type - complex annotation - source weaving");
-  }
- 
-  
-  // two annotations are declared on a type  
-  public void testAtType_TwoAnnotationsOnOneType_BinWeaving() {
-  	runTest("declare @type - two annotations hit one type - binary weaving");
-  }
-  public void testAtType_TwoAnnotationsOnOneType_SrcWeaving() {
-  	runTest("declare @type - two annotations hit one type - source weaving");
-  }
-
-  
-  // decp and deca can interact, let's try some variants that should
-  // result in the same thing
-  public void testAtType_InteractingWithDeclareParents1_BinWeaving() {
-  	runTest("declare @type - declare parents interactions (order 1) - binary weaving");
-  }
-  public void testAtType_InteractingWithDeclareParents1_SrcWeaving() {
-  	runTest("declare @type - declare parents interactions (order 1) - source weaving");
-  }
-  public void testAtType_InteractingWithDeclareParents2_BinWeaving() {
-  	runTest("declare @type - declare parents interactions (order 2) - binary weaving");
-  }
-  public void testAtType_InteractingWithDeclareParents2_SrcWeaving() {
-  	runTest("declare @type - declare parents interactions (order 2) - source weaving");
-  }
-  public void testAtType_InteractingWithDeclareParents3_BinWeaving() {
-  	runTest("declare @type - declare parents interactions (order 3) - binary weaving");
-  }
-  public void testAtType_InteractingWithDeclareParents3_SrcWeaving() {
-  	runTest("declare @type - declare parents interactions (order 3) - source weaving");
-  }
-  public void testAtType_InteractingWithDeclareParents4_BinWeaving() {
-  	runTest("declare @type - declare parents interactions (order 4) - binary weaving");
-  }
-  public void testAtType_InteractingWithDeclareParents4_SrcWeaving() {
-  	runTest("declare @type - declare parents interactions (order 4) - source weaving");
-  }
-  
-  
-  
-  public void testAtType_AnnotatingAlreadyAnnotatedType_BinWeaving() {
-  	runTest("declare @type - annotating an already annotated type - binary weaving");
-  }
-  public void testAtType_AnnotatingAlreadyAnnotatedType_SrcWeaving() {
-  	runTest("declare @type - annotating an already annotated type - source weaving");
-  }
-  
-  
-  
-  // testing for error messages when exact type patterns used
-//  public void testAtType_UsingWrongAnnotationOnAType_BinWeaving() 
-//  	runTest("declare @type - annotations with different targets - binary weaving");
-//  }
-  public void testAtType_UsingWrongAnnotationOnAType_SrcWeaving() {
-  	  runTest("declare @type - annotations with different targets - source weaving");
-  }
-
-
-
-  // testing for the lint message when non exact patterns used
-//  public void testAtType_UsingWrongAnnotationOnAType_TypeSpecifiedByPattern_BinWeaving() {
-//  	runTest("declare @type - annotations with different targets (using type patterns) - binary weaving");
-//  }
-  public void testAtType_UsingWrongAnnotationOnAType_TypeSpecifiedByPattern_SrcWeaving() {
-  	runTest("declare @type - annotations with different targets (using type patterns) - source weaving");
-  }
-  
-  
-  
-  // testing how multiple decAtType/decps interact when they rely on each other
-  public void testAtType_ComplexDecpDecAtTypeInteractions_BinWeaving() {
-  	runTest("declare @type - complex decp decAtType interactions - binary weaving");
-  }
-  public void testAtType_ComplexDecpDecAtTypeInteractions_SrcWeaving() {
-  	runTest("declare @type - complex decp decAtType interactions - source weaving");
-  }
-  
-  
-  public void testAtType_PuttingIncorrectAnnosOnTypes_SrcWeaving() {
-  	runTest("declare @type - trying to put annotation targetting annos on normal types - source weaving");
-  }
-  public void testAtType_PuttingIncorrectAnnosOnTypes_BinWeaving() {
-  	runTest("declare @type - trying to put annotation targetting annos on normal types - binary weaving");
-  }
-  public void testAtType_PuttingIncorrectAnnosOnTypesWithPatterns_SrcWeaving() {
-  	runTest("declare @type - trying to put annotation targetting annos on normal types (uses pattern) - source weaving");
-  }
-  public void testAtType_PuttingIncorrectAnnosOnTypesWithPatterns_BinWeaving() {
-  	runTest("declare @type - trying to put annotation targetting annos on normal types (uses pattern) - binary weaving");
-  }
-  
-// I think this fails because of a freaky JDT compiler bug ...
-//  public void testAtType_UsingClassOrEnumElementValuesInAnnotations_SrcWeaving() {
-//  	runTest("declare @type - covering enum and class element values - source weaving");
-//  }
-  
-  public void testAtType_UsingClassOrEnumElementValuesInAnnotations_BinWeaving() {
-  	runTest("declare @type - covering enum and class element values - binary weaving");
-  }
-  
-  /////////////////////////////////////////////////////////////////////////////////
-  // declare @field
-  
-  public void testAtField_SimpleSource() {
-  	runTest("declare @field - simple source weaving");
-  }
-  
-  public void testAtField_SimpleBinary() {
-  	runTest("declare @field - simple binary weaving");
-  }
-  
-  // lint warning
-  public void testAtField_TwoTheSameOnOneSource() {
-  	runTest("declare @field - two the same on one - source weaving");
-  }
-  
-  // lint warning
-  public void testAtField_TwoTheSameOnOneBinary() {
-  	runTest("declare @field - two the same on one - binary weaving");
-  }
-  
-  public void testAtField_TwoDifferentOnOneSource() {
-  	runTest("declare @field - two different on one - source weaving");
-  }
-  
-  public void testAtField_TwoDifferentOnOneBinary() {
-  	runTest("declare @field - two different on one - binary weaving");
-  }
-  
-  public void testAtField_WrongTargetSource() {
-  	runTest("declare @field - wrong target - source weaving");
-  }
-  
-// Can't do a test like this - as verification of the declare @ is 
-// done when the aspect is first compiled.
-//  public void testAtField_WrongTargetBinary() {
-//  	runTest("declare @field - wrong target - binary weaving");
-//  }
-  
-  public void testAtField_RightTargetSource() {
-  	runTest("declare @field - right target - source weaving");
-  }
-  
-  public void testAtField_RightTargetBinary() {
-  	runTest("declare @field - right target - binary weaving");
-  }
-  
-  public void testAtField_RecursiveSource() {
-  	runTest("declare @field - recursive application - source weaving");
-  }
-  
-  public void testAtField_RecursiveBinary() {
-  	runTest("declare @field - recursive application - binary weaving");
-  }
-  
-  public void testAtField_RecursiveOtherOrderSource() {
-  	runTest("declare @field - recursive application (other order) - source weaving");
-  }
-    
-  public void testAtField_RecursiveOtherOrderBinary() {
-   	runTest("declare @field - recursive application (other order) - binary weaving");
-  }
-  /////////////////////////////////////////////////////////////////////////////////
-  // declare @method
-  
-  public void testAtMethod_SimpleSource() {
-  	runTest("declare @method - simple source weaving");
-  }
-  
-  public void testAtMethod_SimpleBinary() {
-  	runTest("declare @method - simple binary weaving");
-  }
-  
-  /////////////////////////////////////////////////////////////////////////////////
-  // declare @constructor
-  
-  public void testAtCtor_SimpleSource() {
-  	runTest("declare @constructor - simple source weaving");
-  }
-  
-  public void testAtCtor_SimpleBinary() {
-  	runTest("declare @constructor - simple binary weaving");
-  }
-
-  /////////////////////////////////////////////////////////////////////////////////
-  // declare @method @constructor
-  
-  public void testAtMethodCtor_WrongTargetSource() {
-  	runTest("declare @method @ctor - wrong target - source weaving");
-  }
-  
-  public void testAtMethodCtor_RightTargetSource() {
-  	runTest("declare @method @ctor - right target - source weaving");
-  }
-  
-  public void testAtMethodCtor_RightTargetBinary() {
-  	runTest("declare @method @ctor - right target - binary weaving");
-  }
-
-  // lint warning
-  public void testAtMethodCtor_TwoTheSameOnOneSource() {
-  	runTest("declare @method @ctor - two the same on one - source weaving");
-  }
-  
-  // lint warning
-  public void testAtMethodCtor_TwoTheSameOnOneBinary() {
-  	runTest("declare @method @ctor - two the same on one - binary weaving");
-  }
-  
-  public void testAtMethodCtor_TwoDifferentOnOneSource() {
-  	runTest("declare @method @ctor - two different on one - source weaving");
-  }
-  
-  public void testAtMethodCtor_TwoDifferentOnOneBinary() {
-  	runTest("declare @method @ctor - two different on one - binary weaving");
-  }
-  
-  // to debug this test, uncomment the first line which will give you a nice
-  // dump of the structure model in c:/debug.txt 
-  public void testStructureModel() {
-    // AsmManager.setReporting("c:/debug.txt",true,true,true,true);
-  	runTest("declare all annotations on one class - source weaving");
-  	
-  	if (getCurrentTest().canRunOnThisVM()) {
-	  	IHierarchy top = AsmManager.getDefault().getHierarchy();
-	  	
-	  	IProgramElement ipe = top.findElementForLabel(top.getRoot(),
-	  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_TYPE,
-	  		"declare @type: p.q.DeathByAnnotations : @Colored(\"red\")");
-	  	assertTrue("Couldn't find 'declare @type' element in the tree",ipe!=null);
-	  	
-	    List l = AsmManager.getDefault().getRelationshipMap().get(ipe);
-	  	assertTrue("Should have a relationship but does not ",l!=null && l.size()>0);
-	  	
-	  	ipe = top.findElementForLabel(top.getRoot(),
-	  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD,
-	  		"declare @method: * m*(..) : @Fruit(\"tomato\")");
-	  	assertTrue("Couldn't find 'declare @method element in the tree",ipe!=null);
-	  	
-	    l = AsmManager.getDefault().getRelationshipMap().get(ipe);
-	  	assertTrue("Should have a relationship but does not ",l.size()>0);
-	  	
-	  	ipe = top.findElementForLabel(top.getRoot(),
-	  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR,
-	  		"declare @constructor: p.q.DeathByAnnotations.new(..) : @Fruit(\"tomato\")");
-	  	assertTrue("Couldn't find 'declare @constructor element in the tree",ipe!=null);
-	    l = AsmManager.getDefault().getRelationshipMap().get(ipe);
-	  	assertTrue("Should have a relationship but does not ",l.size()>0);
-	  	
-	  	ipe = top.findElementForLabel(top.getRoot(),
-	  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_FIELD,
-	  		"declare @field: * p.q.DeathByAnnotations.* : @Material(\"wood\")");
-	  	assertTrue("Couldn't find 'declare @field element in the tree",ipe!=null);
-	    l = AsmManager.getDefault().getRelationshipMap().get(ipe);
-	  	assertTrue("Should have a relationship but does not ",l.size()>0);
-  	}
-  }
-  
-  public void testDeclareTypeMisspelled() {
-	  	runTest("declare @Type (should be @type)");
-  }
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(DeclareAnnotationTests.class);
+	}
+
+	protected File getSpecFile() {
+		return new File("../tests/src/org/aspectj/systemtest/ajc150/ajc150.xml");
+	}
+
+	// parsing the various forms of declare @
+	public void testDeclareAnnotationParsing() {
+		runTest("basic declare annotation parse test");
+	}
+
+	// declare @type
+
+	// declare @type for one simple annotation on one specific type
+	public void testAtType_OneAnnotationHittingOneType_Src() {
+		runTest("declare @type 1");
+	}
+
+	// declare @type for one simple annotation to multiple types
+	public void testAtType_OneAnnotationHittingMultipleTypes_Src() {
+		runTest("declare @type 2");
+	}
+
+	// declare @type for one simple annotation and a pointcut that matches on it
+	public void testAtType_PointcutMatchingOnDeclaredAnnotation() {
+		runTest("declare @type - with matching pointcut");
+	}
+
+	// binary weaving declare @type, one annotation on one type
+	public void testAtType_OneAnnotationHittingOneType_Bin() {
+		runTest("declare @type - binary weaving");
+	}
+
+	// an annotation with multiple values (all the primitives and string)
+	// is declared upon a single type
+	public void testAtType_ComplexAnnotation_BinWeaving() {
+		runTest("declare @type - complex annotation - binary weaving");
+	}
+
+	public void testAtType_ComplexAnnotation_SrcWeaving() {
+		runTest("declare @type - complex annotation - source weaving");
+	}
+
+	// two annotations are declared on a type
+	public void testAtType_TwoAnnotationsOnOneType_BinWeaving() {
+		runTest("declare @type - two annotations hit one type - binary weaving");
+	}
+
+	public void testAtType_TwoAnnotationsOnOneType_SrcWeaving() {
+		runTest("declare @type - two annotations hit one type - source weaving");
+	}
+
+	// decp and deca can interact, let's try some variants that should
+	// result in the same thing
+	public void testAtType_InteractingWithDeclareParents1_BinWeaving() {
+		runTest("declare @type - declare parents interactions (order 1) - binary weaving");
+	}
+
+	public void testAtType_InteractingWithDeclareParents1_SrcWeaving() {
+		runTest("declare @type - declare parents interactions (order 1) - source weaving");
+	}
+
+	public void testAtType_InteractingWithDeclareParents2_BinWeaving() {
+		runTest("declare @type - declare parents interactions (order 2) - binary weaving");
+	}
+
+	public void testAtType_InteractingWithDeclareParents2_SrcWeaving() {
+		runTest("declare @type - declare parents interactions (order 2) - source weaving");
+	}
+
+	public void testAtType_InteractingWithDeclareParents3_BinWeaving() {
+		runTest("declare @type - declare parents interactions (order 3) - binary weaving");
+	}
+
+	public void testAtType_InteractingWithDeclareParents3_SrcWeaving() {
+		runTest("declare @type - declare parents interactions (order 3) - source weaving");
+	}
+
+	public void testAtType_InteractingWithDeclareParents4_BinWeaving() {
+		runTest("declare @type - declare parents interactions (order 4) - binary weaving");
+	}
+
+	public void testAtType_InteractingWithDeclareParents4_SrcWeaving() {
+		runTest("declare @type - declare parents interactions (order 4) - source weaving");
+	}
+
+	public void testAtType_AnnotatingAlreadyAnnotatedType_BinWeaving() {
+		runTest("declare @type - annotating an already annotated type - binary weaving");
+	}
+
+	public void testAtType_AnnotatingAlreadyAnnotatedType_SrcWeaving() {
+		runTest("declare @type - annotating an already annotated type - source weaving");
+	}
+
+	// testing for error messages when exact type patterns used
+	// public void testAtType_UsingWrongAnnotationOnAType_BinWeaving()
+	// runTest("declare @type - annotations with different targets - binary weaving");
+	// }
+	public void testAtType_UsingWrongAnnotationOnAType_SrcWeaving() {
+		runTest("declare @type - annotations with different targets - source weaving");
+	}
+
+	// testing for the lint message when non exact patterns used
+	// public void testAtType_UsingWrongAnnotationOnAType_TypeSpecifiedByPattern_BinWeaving() {
+	// runTest("declare @type - annotations with different targets (using type patterns) - binary weaving");
+	// }
+	public void testAtType_UsingWrongAnnotationOnAType_TypeSpecifiedByPattern_SrcWeaving() {
+		runTest("declare @type - annotations with different targets (using type patterns) - source weaving");
+	}
+
+	// testing how multiple decAtType/decps interact when they rely on each other
+	public void testAtType_ComplexDecpDecAtTypeInteractions_BinWeaving() {
+		runTest("declare @type - complex decp decAtType interactions - binary weaving");
+	}
+
+	public void testAtType_ComplexDecpDecAtTypeInteractions_SrcWeaving() {
+		runTest("declare @type - complex decp decAtType interactions - source weaving");
+	}
+
+	public void testAtType_PuttingIncorrectAnnosOnTypes_SrcWeaving() {
+		runTest("declare @type - trying to put annotation targetting annos on normal types - source weaving");
+	}
+
+	public void testAtType_PuttingIncorrectAnnosOnTypes_BinWeaving() {
+		runTest("declare @type - trying to put annotation targetting annos on normal types - binary weaving");
+	}
+
+	public void testAtType_PuttingIncorrectAnnosOnTypesWithPatterns_SrcWeaving() {
+		runTest("declare @type - trying to put annotation targetting annos on normal types (uses pattern) - source weaving");
+	}
+
+	public void testAtType_PuttingIncorrectAnnosOnTypesWithPatterns_BinWeaving() {
+		runTest("declare @type - trying to put annotation targetting annos on normal types (uses pattern) - binary weaving");
+	}
+
+	// I think this fails because of a freaky JDT compiler bug ...
+	// public void testAtType_UsingClassOrEnumElementValuesInAnnotations_SrcWeaving() {
+	// runTest("declare @type - covering enum and class element values - source weaving");
+	// }
+
+	public void testAtType_UsingClassOrEnumElementValuesInAnnotations_BinWeaving() {
+		runTest("declare @type - covering enum and class element values - binary weaving");
+	}
+
+	// ///////////////////////////////////////////////////////////////////////////////
+	// declare @field
+
+	public void testAtField_SimpleSource() {
+		runTest("declare @field - simple source weaving");
+	}
+
+	public void testAtField_SimpleBinary() {
+		runTest("declare @field - simple binary weaving");
+	}
+
+	// lint warning
+	public void testAtField_TwoTheSameOnOneSource() {
+		runTest("declare @field - two the same on one - source weaving");
+	}
+
+	// lint warning
+	public void testAtField_TwoTheSameOnOneBinary() {
+		runTest("declare @field - two the same on one - binary weaving");
+	}
+
+	public void testAtField_TwoDifferentOnOneSource() {
+		runTest("declare @field - two different on one - source weaving");
+	}
+
+	public void testAtField_TwoDifferentOnOneBinary() {
+		runTest("declare @field - two different on one - binary weaving");
+	}
+
+	public void testAtField_WrongTargetSource() {
+		runTest("declare @field - wrong target - source weaving");
+	}
+
+	// Can't do a test like this - as verification of the declare @ is
+	// done when the aspect is first compiled.
+	// public void testAtField_WrongTargetBinary() {
+	// runTest("declare @field - wrong target - binary weaving");
+	// }
+
+	public void testAtField_RightTargetSource() {
+		runTest("declare @field - right target - source weaving");
+	}
+
+	public void testAtField_RightTargetBinary() {
+		runTest("declare @field - right target - binary weaving");
+	}
+
+	public void testAtField_RecursiveSource() {
+		runTest("declare @field - recursive application - source weaving");
+	}
+
+	public void testAtField_RecursiveBinary() {
+		runTest("declare @field - recursive application - binary weaving");
+	}
+
+	public void testAtField_RecursiveOtherOrderSource() {
+		runTest("declare @field - recursive application (other order) - source weaving");
+	}
+
+	public void testAtField_RecursiveOtherOrderBinary() {
+		runTest("declare @field - recursive application (other order) - binary weaving");
+	}
+
+	// ///////////////////////////////////////////////////////////////////////////////
+	// declare @method
+
+	public void testAtMethod_SimpleSource() {
+		runTest("declare @method - simple source weaving");
+	}
+
+	public void testAtMethod_SimpleBinary() {
+		runTest("declare @method - simple binary weaving");
+	}
+
+	// ///////////////////////////////////////////////////////////////////////////////
+	// declare @constructor
+
+	public void testAtCtor_SimpleSource() {
+		runTest("declare @constructor - simple source weaving");
+	}
+
+	public void testAtCtor_SimpleBinary() {
+		runTest("declare @constructor - simple binary weaving");
+	}
+
+	// ///////////////////////////////////////////////////////////////////////////////
+	// declare @method @constructor
+
+	public void testAtMethodCtor_WrongTargetSource() {
+		runTest("declare @method @ctor - wrong target - source weaving");
+	}
+
+	public void testAtMethodCtor_RightTargetSource() {
+		runTest("declare @method @ctor - right target - source weaving");
+	}
+
+	public void testAtMethodCtor_RightTargetBinary() {
+		runTest("declare @method @ctor - right target - binary weaving");
+	}
+
+	// lint warning
+	public void testAtMethodCtor_TwoTheSameOnOneSource() {
+		runTest("declare @method @ctor - two the same on one - source weaving");
+	}
+
+	// lint warning
+	public void testAtMethodCtor_TwoTheSameOnOneBinary() {
+		runTest("declare @method @ctor - two the same on one - binary weaving");
+	}
+
+	public void testAtMethodCtor_TwoDifferentOnOneSource() {
+		runTest("declare @method @ctor - two different on one - source weaving");
+	}
+
+	public void testAtMethodCtor_TwoDifferentOnOneBinary() {
+		runTest("declare @method @ctor - two different on one - binary weaving");
+	}
+
+	// to debug this test, uncomment the first line which will give you a nice
+	// dump of the structure model in c:/debug.txt
+	public void testStructureModel() {
+		// AsmManager.setReporting("c:/debug.txt",true,true,true,true);
+		runTest("declare all annotations on one class - source weaving");
+
+		if (getCurrentTest().canRunOnThisVM()) {
+			IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
+
+			IProgramElement ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.DECLARE_ANNOTATION_AT_TYPE,
+					"declare @type: p.q.DeathByAnnotations : @Colored(\"red\")");
+			assertTrue("Couldn't find 'declare @type' element in the tree", ipe != null);
+
+			List l = AsmManager.lastActiveStructureModel.getRelationshipMap().get(ipe);
+			assertTrue("Should have a relationship but does not ", l != null && l.size() > 0);
+
+			ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD,
+					"declare @method: * m*(..) : @Fruit(\"tomato\")");
+			assertTrue("Couldn't find 'declare @method element in the tree", ipe != null);
+
+			l = AsmManager.lastActiveStructureModel.getRelationshipMap().get(ipe);
+			assertTrue("Should have a relationship but does not ", l.size() > 0);
+
+			ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR,
+					"declare @constructor: p.q.DeathByAnnotations.new(..) : @Fruit(\"tomato\")");
+			assertTrue("Couldn't find 'declare @constructor element in the tree", ipe != null);
+			l = AsmManager.lastActiveStructureModel.getRelationshipMap().get(ipe);
+			assertTrue("Should have a relationship but does not ", l.size() > 0);
+
+			ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.DECLARE_ANNOTATION_AT_FIELD,
+					"declare @field: * p.q.DeathByAnnotations.* : @Material(\"wood\")");
+			assertTrue("Couldn't find 'declare @field element in the tree", ipe != null);
+			l = AsmManager.lastActiveStructureModel.getRelationshipMap().get(ipe);
+			assertTrue("Should have a relationship but does not ", l.size() > 0);
+		}
+	}
+
+	public void testDeclareTypeMisspelled() {
+		runTest("declare @Type (should be @type)");
+	}
 
 }
\ No newline at end of file
@@ -22,171 +22,258 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc151Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
-  // Some @DeclareParents testing
-  public void testAtDecp_1() { runTest("atDecp - simple");}
-  public void testAtDecp_2() { runTest("atDecp - annotation");}
-  public void testAtDecp_3() { runTest("atDecp - binary interface");}
-  public void testAtDecp_4() { runTest("atDecp - binary interface - 2");}
-
-  public void testAnnotationsAndItds_pr98901() { runTest("annotations and itds");}
-  public void testAnnotationsAndItds_pr98901_2() { runTest("annotations and itds - 2");}
-  public void testCircularGenerics_pr133307() { runTest("circular generics");}
-  public void testDeca() { runTest("doubly annotating a method with declare");}	
-  public void testDeca2() { runTest("doubly annotating a method with declare - 2");}	
-  public void testCrashingWithASM_pr132926_1() { runTest("crashing on annotation type resolving with asm - 1");}
-  public void testCrashingWithASM_pr132926_2() { runTest("crashing on annotation type resolving with asm - 2");}
-  public void testCrashingWithASM_pr132926_3() { runTest("crashing on annotation type resolving with asm - 3");}
-  public void testGenericAdviceParameters_pr123553()    { runTest("generic advice parameters");}
-  public void testMemberTypesInGenericTypes_pr122458()    { runTest("member types in generic types");}
-  public void testMemberTypesInGenericTypes_pr122458_2()  { runTest("member types in generic types - 2");}
-  public void testNPEOnDeclareAnnotation_pr123695() { runTest("Internal nullptr exception with complex declare annotation");}
-  public void testHasMemberPackageProblem_pr124105() { runTest("hasMember problems with packages");}
-  public void testDifferentNumbersofTVars_pr124803() { runTest("generics and different numbers of type variables");}
-  public void testDifferentNumbersofTVars_pr124803_2() { runTest("generics and different numbers of type variables - classes");}
-  public void testParameterizedCollectionFieldMatching_pr124808() { runTest("parameterized collection fields matched via pointcut");}
-  public void testGenericAspectsAndAnnotations_pr124654() { runTest("generic aspects and annotations");}
-  public void testCallInheritedGenericMethod_pr124999() { runTest("calling inherited generic method from around advice");}
-  public void testIncorrectlyReferencingPointcuts_pr122452()    { runTest("incorrectly referencing pointcuts");}
-  public void testIncorrectlyReferencingPointcuts_pr122452_2()    { runTest("incorrectly referencing pointcuts - 2");}
-  public void testInlinevisitorNPE_pr123901() { runTest("inlinevisitor NPE");}
-  //public void testExposingWithintype_enh123423() { runTest("exposing withintype");}
-  //public void testMissingImport_pr127299() { runTest("missing import gives funny message");}
-  public void testUnusedInterfaceMessage_pr120527() { runTest("incorrect unused interface message");}
-  public void testAtAspectInheritsAdviceWithTJPAndThis_pr125699 () { runTest("inherit advice with this() and thisJoinPoint");  }
-  public void testAtAspectInheritsAdviceWithTJPAndThis_pr125699_2 () {runTest("inherit advice with this() and thisJoinPoint - 2");  }
-  public void testBrokenLTW_pr128744() { runTest("broken ltw"); }
-  
-  public void testAtAspectNoInvalidAbsoluteTypeName_pr126560() {
-	  runTest("@AJ deow doesn't throw an invalidAbsoluteTypeName when specify type in the same package");
-  }
-  
-  public void testAtAspectNoInvalidAbsoluteTypeName_pr126560_2() {
-	  runTest("@AJ deow doesn't throw an invalidAbsoluteTypeName when specify type in the same file");
-  }
-  
-  public void testArrayindexoutofbounds_pr129566() { 
-	  runTest("arrayindexoutofbounds");
-	  // public class SkipList<T extends Comparable> extends Object implements Set<T>, Iterable<T>
-	  GenericsTests.verifyClassSignature(ajc,"common.SkipList","<T::Ljava/lang/Comparable;>Ljava/lang/Object;Ljava/util/Set<TT;>;Ljava/lang/Iterable<TT;>;");
-	  // protected class SkipListElement<E> extends Object
-	  GenericsTests.verifyClassSignature(ajc,"common.SkipList$SkipListElement","<E:Ljava/lang/Object;>Ljava/lang/Object;");
-	  // protected class SkipListIterator<E> implements Iterator<T>
-	  GenericsTests.verifyClassSignature(ajc,"common.SkipList$SkipListIterator","<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Iterator<TT;>;");
-  }
-  
-  public void testMixingNumbersOfTypeParameters_pr125080()   { 
-	  runTest("mixing numbers of type parameters");
-	  GenericsTests.verifyClassSignature(ajc,"AspectInterface","<T:Ljava/lang/Object;S:Ljava/lang/Object;>Ljava/lang/Object;");
-	  GenericsTests.verifyClassSignature(ajc,"AbstractAspect","<T:Ljava/lang/Object;>Ljava/lang/Object;LAspectInterface<TT;Ljava/lang/Integer;>;");
-	  GenericsTests.verifyClassSignature(ajc,"ConcreteAspect","LAbstractAspect<Ljava/lang/String;>;");
-  }
-  
-  public void testMixingNumbersOfTypeParameters_pr125080_2() { 
-	  runTest("mixing numbers of type parameters - 2"); 
-	  GenericsTests.verifyClassSignature(ajc,"AspectInterface","<T:Ljava/lang/Object;S:Ljava/lang/Number;>Ljava/lang/Object;");
-	  GenericsTests.verifyClassSignature(ajc,"AbstractAspect","<T:Ljava/lang/Object;>Ljava/lang/Object;LAspectInterface<TT;Ljava/lang/Integer;>;");
-	  GenericsTests.verifyClassSignature(ajc,"ConcreteAspect","LAbstractAspect<LStudent;>;");
-  }
-  
-  public void testIProgramElementMethods_pr125295() {
-	  runTest("new IProgramElement methods");  
-  	  IHierarchy top = AsmManager.getDefault().getHierarchy();
-
-  	  IProgramElement pe = top.findElementForType("pkg","foo");
-  	  assertNotNull("Couldn't find 'foo' element in the tree",pe);
-  	  // check that the defaults return the fully qualified arg
-  	  assertEquals("foo(int,java.lang.Object)",pe.toLabelString());
-  	  assertEquals("C.foo(int,java.lang.Object)",pe.toLinkLabelString());
-  	  assertEquals("foo(int,java.lang.Object)",pe.toSignatureString());
-  	  // check that can get hold of the non qualified args
-  	  assertEquals("foo(int,Object)",pe.toLabelString(false));
-  	  assertEquals("C.foo(int,Object)",pe.toLinkLabelString(false));
-  	  assertEquals("foo(int,Object)",pe.toSignatureString(false));
-
-  	  IProgramElement pe2 = top.findElementForType("pkg","printParameters");
-  	  assertNotNull("Couldn't find 'printParameters' element in the tree",pe2);
-  	  // the argument is org.aspectj.lang.JoinPoint, check that this is added
-  	  assertFalse("printParameters method should have arguments",pe2.getParameterSignatures().isEmpty());	  
-  }
-
-  public void testParameterizedEnum_pr126316() {
-	  runTest("E extends Enum(E) again");
-  }
-  
-  public void testSwallowedException() {
-	  runTest("swallowed exceptions");
-  }
-  
-  public void testAtAspectVerifyErrorWithAfterThrowingAndthisJoinPoint_pr122742() {
-	  runTest("@AJ VerifyError with @AfterThrowing and thisJoinPoint argument");
-  }
-  
-  public void testAtAspectVerifyErrorWithAfterReturningAndthisJoinPoint_pr122742() {
-	  runTest("@AJ VerifyError with @AfterReturning and thisJoinPoint argument");
-  }
-  
-  public void testSwallowedExceptionIgnored() {
-	  runTest("swallowed exceptions with xlint");
-  }
-  
-  public void testGenericAspectWithUnknownType_pr131933() {
-	  runTest("no ClassCastException with generic aspect and unknown type");
-  }
-  
-  /*
-   * @AspectJ bugs and enhancements
-   */
-//  public void testAtAspectInheritsAdviceWithTJPAndThis_pr125699 () {
-//	  runTest("inherit adivce with this() and thisJoinPoint"); 
-//  }
-  
-  public void testAtAspectInheritsAbstractPointcut_pr125810 () {
-	  runTest("warning when inherited pointcut not made concrete"); 
-  }
-  
-  public void testAtAspectWithoutJoinPointImport_pr121616() {
-	  runTest("@AJ without JoinPoint import");
-  }
-  
-  public void testAtAspectDeclareParentsRetainsFieldState_pr122370() {
-	  runTest("@AJ declare parents retains field state");
-  }
-  
-  public void testAtAspectNoNPEWithPcdContainingOrThisAndWildcard_pr128237() {
-	  runTest("@AJ no npe with pointcut containing or, this and a wildcard");
-  }
-  
-  /*
-   * Load-time weaving bugs and enhancements
-   */
-  public void testEmptyPointcutInAtAspectJ_pr125475 () {
-	  runTest("define empty pointcut using an annotation"); 
-  }
-
-  public void testEmptyPointcutInAtAspectJ_pr125475_2() {
-	  runTest("define empty pointcut using an annotation - 2"); 
-  }
-  
-  public void testEmptyPointcutInAtAspectJWithLTW_pr125475 () {
-	  runTest("define empty pointcut using aop.xml"); 
-  }
-
-  public void testGenericAspectsWithAnnotationTypeParameters() {
-	  runTest("Generic aspects with annotation type parameters");
-  }
-  
-  public void testPointcutInterfaces_pr130869() {
-	  runTest("Pointcut interfaces");
-  }
-  
-  /////////////////////////////////////////
-  public static Test suite() {
-    return XMLBasedAjcTestCase.loadSuite(Ajc151Tests.class);
-  }
-
-  protected File getSpecFile() {
-    return new File("../tests/src/org/aspectj/systemtest/ajc151/ajc151.xml");
-  }
-
-  
+	// Some @DeclareParents testing
+	public void testAtDecp_1() {
+		runTest("atDecp - simple");
+	}
+
+	public void testAtDecp_2() {
+		runTest("atDecp - annotation");
+	}
+
+	public void testAtDecp_3() {
+		runTest("atDecp - binary interface");
+	}
+
+	public void testAtDecp_4() {
+		runTest("atDecp - binary interface - 2");
+	}
+
+	public void testAnnotationsAndItds_pr98901() {
+		runTest("annotations and itds");
+	}
+
+	public void testAnnotationsAndItds_pr98901_2() {
+		runTest("annotations and itds - 2");
+	}
+
+	public void testCircularGenerics_pr133307() {
+		runTest("circular generics");
+	}
+
+	public void testDeca() {
+		runTest("doubly annotating a method with declare");
+	}
+
+	public void testDeca2() {
+		runTest("doubly annotating a method with declare - 2");
+	}
+
+	public void testCrashingWithASM_pr132926_1() {
+		runTest("crashing on annotation type resolving with asm - 1");
+	}
+
+	public void testCrashingWithASM_pr132926_2() {
+		runTest("crashing on annotation type resolving with asm - 2");
+	}
+
+	public void testCrashingWithASM_pr132926_3() {
+		runTest("crashing on annotation type resolving with asm - 3");
+	}
+
+	public void testGenericAdviceParameters_pr123553() {
+		runTest("generic advice parameters");
+	}
+
+	public void testMemberTypesInGenericTypes_pr122458() {
+		runTest("member types in generic types");
+	}
+
+	public void testMemberTypesInGenericTypes_pr122458_2() {
+		runTest("member types in generic types - 2");
+	}
+
+	public void testNPEOnDeclareAnnotation_pr123695() {
+		runTest("Internal nullptr exception with complex declare annotation");
+	}
+
+	public void testHasMemberPackageProblem_pr124105() {
+		runTest("hasMember problems with packages");
+	}
+
+	public void testDifferentNumbersofTVars_pr124803() {
+		runTest("generics and different numbers of type variables");
+	}
+
+	public void testDifferentNumbersofTVars_pr124803_2() {
+		runTest("generics and different numbers of type variables - classes");
+	}
+
+	public void testParameterizedCollectionFieldMatching_pr124808() {
+		runTest("parameterized collection fields matched via pointcut");
+	}
+
+	public void testGenericAspectsAndAnnotations_pr124654() {
+		runTest("generic aspects and annotations");
+	}
+
+	public void testCallInheritedGenericMethod_pr124999() {
+		runTest("calling inherited generic method from around advice");
+	}
+
+	public void testIncorrectlyReferencingPointcuts_pr122452() {
+		runTest("incorrectly referencing pointcuts");
+	}
+
+	public void testIncorrectlyReferencingPointcuts_pr122452_2() {
+		runTest("incorrectly referencing pointcuts - 2");
+	}
+
+	public void testInlinevisitorNPE_pr123901() {
+		runTest("inlinevisitor NPE");
+	}
+
+	// public void testExposingWithintype_enh123423() { runTest("exposing withintype");}
+	// public void testMissingImport_pr127299() { runTest("missing import gives funny message");}
+	public void testUnusedInterfaceMessage_pr120527() {
+		runTest("incorrect unused interface message");
+	}
+
+	public void testAtAspectInheritsAdviceWithTJPAndThis_pr125699() {
+		runTest("inherit advice with this() and thisJoinPoint");
+	}
+
+	public void testAtAspectInheritsAdviceWithTJPAndThis_pr125699_2() {
+		runTest("inherit advice with this() and thisJoinPoint - 2");
+	}
+
+	public void testBrokenLTW_pr128744() {
+		runTest("broken ltw");
+	}
+
+	public void testAtAspectNoInvalidAbsoluteTypeName_pr126560() {
+		runTest("@AJ deow doesn't throw an invalidAbsoluteTypeName when specify type in the same package");
+	}
+
+	public void testAtAspectNoInvalidAbsoluteTypeName_pr126560_2() {
+		runTest("@AJ deow doesn't throw an invalidAbsoluteTypeName when specify type in the same file");
+	}
+
+	public void testArrayindexoutofbounds_pr129566() {
+		runTest("arrayindexoutofbounds");
+		// public class SkipList<T extends Comparable> extends Object implements Set<T>, Iterable<T>
+		GenericsTests.verifyClassSignature(ajc, "common.SkipList",
+				"<T::Ljava/lang/Comparable;>Ljava/lang/Object;Ljava/util/Set<TT;>;Ljava/lang/Iterable<TT;>;");
+		// protected class SkipListElement<E> extends Object
+		GenericsTests.verifyClassSignature(ajc, "common.SkipList$SkipListElement", "<E:Ljava/lang/Object;>Ljava/lang/Object;");
+		// protected class SkipListIterator<E> implements Iterator<T>
+		GenericsTests.verifyClassSignature(ajc, "common.SkipList$SkipListIterator",
+				"<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Iterator<TT;>;");
+	}
+
+	public void testMixingNumbersOfTypeParameters_pr125080() {
+		runTest("mixing numbers of type parameters");
+		GenericsTests.verifyClassSignature(ajc, "AspectInterface", "<T:Ljava/lang/Object;S:Ljava/lang/Object;>Ljava/lang/Object;");
+		GenericsTests.verifyClassSignature(ajc, "AbstractAspect",
+				"<T:Ljava/lang/Object;>Ljava/lang/Object;LAspectInterface<TT;Ljava/lang/Integer;>;");
+		GenericsTests.verifyClassSignature(ajc, "ConcreteAspect", "LAbstractAspect<Ljava/lang/String;>;");
+	}
+
+	public void testMixingNumbersOfTypeParameters_pr125080_2() {
+		runTest("mixing numbers of type parameters - 2");
+		GenericsTests.verifyClassSignature(ajc, "AspectInterface", "<T:Ljava/lang/Object;S:Ljava/lang/Number;>Ljava/lang/Object;");
+		GenericsTests.verifyClassSignature(ajc, "AbstractAspect",
+				"<T:Ljava/lang/Object;>Ljava/lang/Object;LAspectInterface<TT;Ljava/lang/Integer;>;");
+		GenericsTests.verifyClassSignature(ajc, "ConcreteAspect", "LAbstractAspect<LStudent;>;");
+	}
+
+	public void testIProgramElementMethods_pr125295() {
+		runTest("new IProgramElement methods");
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
+
+		IProgramElement pe = top.findElementForType("pkg", "foo");
+		assertNotNull("Couldn't find 'foo' element in the tree", pe);
+		// check that the defaults return the fully qualified arg
+		assertEquals("foo(int,java.lang.Object)", pe.toLabelString());
+		assertEquals("C.foo(int,java.lang.Object)", pe.toLinkLabelString());
+		assertEquals("foo(int,java.lang.Object)", pe.toSignatureString());
+		// check that can get hold of the non qualified args
+		assertEquals("foo(int,Object)", pe.toLabelString(false));
+		assertEquals("C.foo(int,Object)", pe.toLinkLabelString(false));
+		assertEquals("foo(int,Object)", pe.toSignatureString(false));
+
+		IProgramElement pe2 = top.findElementForType("pkg", "printParameters");
+		assertNotNull("Couldn't find 'printParameters' element in the tree", pe2);
+		// the argument is org.aspectj.lang.JoinPoint, check that this is added
+		assertFalse("printParameters method should have arguments", pe2.getParameterSignatures().isEmpty());
+	}
+
+	public void testParameterizedEnum_pr126316() {
+		runTest("E extends Enum(E) again");
+	}
+
+	public void testSwallowedException() {
+		runTest("swallowed exceptions");
+	}
+
+	public void testAtAspectVerifyErrorWithAfterThrowingAndthisJoinPoint_pr122742() {
+		runTest("@AJ VerifyError with @AfterThrowing and thisJoinPoint argument");
+	}
+
+	public void testAtAspectVerifyErrorWithAfterReturningAndthisJoinPoint_pr122742() {
+		runTest("@AJ VerifyError with @AfterReturning and thisJoinPoint argument");
+	}
+
+	public void testSwallowedExceptionIgnored() {
+		runTest("swallowed exceptions with xlint");
+	}
+
+	public void testGenericAspectWithUnknownType_pr131933() {
+		runTest("no ClassCastException with generic aspect and unknown type");
+	}
+
+	/*
+	 * @AspectJ bugs and enhancements
+	 */
+	// public void testAtAspectInheritsAdviceWithTJPAndThis_pr125699 () {
+	// runTest("inherit adivce with this() and thisJoinPoint");
+	// }
+	public void testAtAspectInheritsAbstractPointcut_pr125810() {
+		runTest("warning when inherited pointcut not made concrete");
+	}
+
+	public void testAtAspectWithoutJoinPointImport_pr121616() {
+		runTest("@AJ without JoinPoint import");
+	}
+
+	public void testAtAspectDeclareParentsRetainsFieldState_pr122370() {
+		runTest("@AJ declare parents retains field state");
+	}
+
+	public void testAtAspectNoNPEWithPcdContainingOrThisAndWildcard_pr128237() {
+		runTest("@AJ no npe with pointcut containing or, this and a wildcard");
+	}
+
+	/*
+	 * Load-time weaving bugs and enhancements
+	 */
+	public void testEmptyPointcutInAtAspectJ_pr125475() {
+		runTest("define empty pointcut using an annotation");
+	}
+
+	public void testEmptyPointcutInAtAspectJ_pr125475_2() {
+		runTest("define empty pointcut using an annotation - 2");
+	}
+
+	public void testEmptyPointcutInAtAspectJWithLTW_pr125475() {
+		runTest("define empty pointcut using aop.xml");
+	}
+
+	public void testGenericAspectsWithAnnotationTypeParameters() {
+		runTest("Generic aspects with annotation type parameters");
+	}
+
+	public void testPointcutInterfaces_pr130869() {
+		runTest("Pointcut interfaces");
+	}
+
+	// ///////////////////////////////////////
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(Ajc151Tests.class);
+	}
+
+	protected File getSpecFile() {
+		return new File("../tests/src/org/aspectj/systemtest/ajc151/ajc151.xml");
+	}
+
 }
\ No newline at end of file
@@ -37,58 +37,89 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
  * What still needs testing:
  * - structure model
  * 
- */ 
-
+ */
 
 public class NewarrayJoinpointTests extends XMLBasedAjcTestCase {
 
-  // when its the creation of a new 'object' (not a primitive) single dimension array
-  public void testTheBasics_1() { runTest("basics"); }
-  public void testTheBasics_2() { runTest("basics - 2"); }
-  public void testWhatShouldntMatch()    { runTest("shouldnt match"); }
-  public void testThisJoinPoint()        { runTest("thisjoinpoint"); }
-  public void testDifferentAdviceKinds() { runTest("different advice kinds");}
-  public void testArgs() { runTest("args");}
-  
-  // when it is the creation of a new array of primitives
-  public void testBasicWithAPrimitiveArray() { runTest("basic primitive array creation");}
-  
-  
-  // when it is the creation of a new multi-dimensional array
-  public void testBasicWithAMultiDimensionalArray() { runTest("multi dimensional array creation"); }
-  public void testArgsWithAMultiDimensionalArray() { runTest("multi dimensional array args");}
-
-  // various
-  public void testOptionoff() { runTest("option deactivated - no match expected");}
-  public void testUsingTargetAndAfterReturningAdvice() { runTest("using target and after returning");}
-  public void testUsingItForReal() { runTest("using it for real");}
-  public void testDifferentiatingArrayTypes() { runTest("differentiating array types");}
-  
-  public void testStructureModel() {  
-	//AsmManager.setReporting("c:/foo.txt",true,true,true,true);
-	runTest("structure model");
-	IProgramElement ipe = AsmManager.getDefault().getHierarchy().findElementForType("","Five");
-	assertTrue("Couldnt find 'Five' type in the model",ipe!=null);
-	List kids = ipe.getChildren();
-	assertTrue("Couldn't find 'main' method in the 'Five' type",kids!=null && kids.size()==1);
-	List codenodes = ((IProgramElement)kids.get(0)).getChildren();
-	assertTrue("Couldn't find nodes below 'main' method",codenodes!=null && codenodes.size()==1);
-	IProgramElement arrayCtorCallNode = (IProgramElement)codenodes.get(0);
-	String exp = "constructor-call(void java.lang.Integer[].<init>(int))";
-	assertTrue("Expected '"+exp+"' but found "+arrayCtorCallNode.toString(),arrayCtorCallNode.toString().equals(exp));
-	List rels = AsmManager.getDefault().getRelationshipMap().get(arrayCtorCallNode);
-	assertTrue("Should have a relationship from the ctorcall node, but didn't find one?",rels!=null && rels.size()==1);
-  }
-  
-  
-
-  //
-  public static Test suite() {
-    return XMLBasedAjcTestCase.loadSuite(NewarrayJoinpointTests.class);
-  }
-
-  protected File getSpecFile() {
-    return new File("../tests/src/org/aspectj/systemtest/ajc151/newarray_joinpoint.xml");
-  }
-	
+	// when its the creation of a new 'object' (not a primitive) single dimension array
+	public void testTheBasics_1() {
+		runTest("basics");
+	}
+
+	public void testTheBasics_2() {
+		runTest("basics - 2");
+	}
+
+	public void testWhatShouldntMatch() {
+		runTest("shouldnt match");
+	}
+
+	public void testThisJoinPoint() {
+		runTest("thisjoinpoint");
+	}
+
+	public void testDifferentAdviceKinds() {
+		runTest("different advice kinds");
+	}
+
+	public void testArgs() {
+		runTest("args");
+	}
+
+	// when it is the creation of a new array of primitives
+	public void testBasicWithAPrimitiveArray() {
+		runTest("basic primitive array creation");
+	}
+
+	// when it is the creation of a new multi-dimensional array
+	public void testBasicWithAMultiDimensionalArray() {
+		runTest("multi dimensional array creation");
+	}
+
+	public void testArgsWithAMultiDimensionalArray() {
+		runTest("multi dimensional array args");
+	}
+
+	// various
+	public void testOptionoff() {
+		runTest("option deactivated - no match expected");
+	}
+
+	public void testUsingTargetAndAfterReturningAdvice() {
+		runTest("using target and after returning");
+	}
+
+	public void testUsingItForReal() {
+		runTest("using it for real");
+	}
+
+	public void testDifferentiatingArrayTypes() {
+		runTest("differentiating array types");
+	}
+
+	public void testStructureModel() {
+		// AsmManager.setReporting("c:/foo.txt",true,true,true,true);
+		runTest("structure model");
+		IProgramElement ipe = AsmManager.lastActiveStructureModel.getHierarchy().findElementForType("", "Five");
+		assertTrue("Couldnt find 'Five' type in the model", ipe != null);
+		List kids = ipe.getChildren();
+		assertTrue("Couldn't find 'main' method in the 'Five' type", kids != null && kids.size() == 1);
+		List codenodes = ((IProgramElement) kids.get(0)).getChildren();
+		assertTrue("Couldn't find nodes below 'main' method", codenodes != null && codenodes.size() == 1);
+		IProgramElement arrayCtorCallNode = (IProgramElement) codenodes.get(0);
+		String exp = "constructor-call(void java.lang.Integer[].<init>(int))";
+		assertTrue("Expected '" + exp + "' but found " + arrayCtorCallNode.toString(), arrayCtorCallNode.toString().equals(exp));
+		List rels = AsmManager.lastActiveStructureModel.getRelationshipMap().get(arrayCtorCallNode);
+		assertTrue("Should have a relationship from the ctorcall node, but didn't find one?", rels != null && rels.size() == 1);
+	}
+
+	//
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(NewarrayJoinpointTests.class);
+	}
+
+	protected File getSpecFile() {
+		return new File("../tests/src/org/aspectj/systemtest/ajc151/newarray_joinpoint.xml");
+	}
+
 }
@@ -23,151 +23,362 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
-//	public void testCovarianceAndDecp_pr128443_1() { runTest("covariance and decp - 1"); }
-//  public void testSuperITDExplosion_pr134425() { runTest("super ITDs");}
-//  public void testMisbehavingDeclareAnnotation_pr135865() { runTest("misbehaving declare annotation");}
-//  public void testMisbehavingDeclareAnnotation_pr135865_2() { runTest("misbehaving declare annotation - 2");}
-//  public void testClassCastForInvalidAnnotationValue_pr148537() { runTest("classcast annotation value");}
-	
-	
-  // tests added post 152rc1 and before final
-  public void testSeparateCallAspectOf_pr148727() { runTest("separate compilation calling aspectOf and hasAspect"); }
-  public void testIntegratedCallAspectOf_pr148727() { runTest("integrated compilation calling aspectOf and hasAspect"); }
-  public void testFreakyNewArrayJoinpoint_pr148786() { runTest("freaky new array joinpoint"); }
-
-  // tests adding during 152 development
-  public void testPrivilegeGeneric_pr148545() { runTest("nosuchmethoderror for privileged aspect");}
-  public void testPrivilegeGeneric_pr148545_2() { runTest("nosuchmethoderror for privileged aspect - 2");}
-  public void testUnknownAnnotationNPE() { runTest("NPE for unknown annotation");}
-  public void testDuplicateBridgeMethods_pr147801_1() { runTest("duplicate bridge methods");}
-  public void testPackageIgnoredForException_pr147701_1() { runTest("package for exception ignored");}
-  public void testPackageIgnoredForException_pr147701_2() { runTest("package for exception ignored - 2");}
-  public void testPackageIgnoredForException_pr147701_3() { runTest("package for exception ignored - 3");}
-  public void testBrokenAddSerialVersionUID_pr145950() {runTest("fails to discover Serializable");}
-  public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_1() {runTest("no unnecessary declaration of thrown exception warning - 1");}
-  public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_2() {runTest("no unnecessary declaration of thrown exception warning - 2");}
-  public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_3() {runTest("no unnecessary declaration of thrown exception warning - 3");}
-  public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_4() {runTest("no unnecessary declaration of thrown exception warning - 4");}
-  public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_5() {runTest("no unnecessary declaration of thrown exception warning - 5");}
-  public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_6() {runTest("no unnecessary declaration of thrown exception warning - 6");}
-  public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_7() {runTest("no unnecessary declaration of thrown exception warning - 7");}
-  public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_8() {runTest("no unnecessary declaration of thrown exception warning - 8");}
-  public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_9() {runTest("no unnecessary declaration of thrown exception warning - 9");}
-  public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_10() {runTest("no unnecessary declaration of thrown exception warning - 10");}  
-  public void testAtAJVerificationError_pr144602() { runTest("atAJ perthis aspect verification error");}
-  public void testLTWAndGeneratingSUID_pr144465() { runTest("ltw with serialversionUID creation"); }
-  public void testAspects14PerSingleton_pr122253() { runTest("aspects14 - persingleton");}
-  public void testAspects14PerCflow_pr122253() { runTest("aspects14 - percflow");}
-  public void testAspects14PerThis_pr122253() { runTest("aspects14 - perthis");}
-  public void testAspects14PerTypeWithin_pr122253() { runTest("aspects14 - pertypewithin");}
-  public void testFunkyGenericErrorWithITDs_pr126355() { runTest("bizarre generic error with itds");}
-  public void testConcretizingAbstractMethods_pr142466() { runTest("aop.xml aspect inheriting but not concretizing abstract method");}
-  public void testConcretizingAbstractMethods_pr142466_2() { runTest("aop.xml aspect inheriting but not concretizing abstract method - 2");}
-  public void testComplexGenericDecl_pr137568() { runTest("complicated generics declaration");}
-  public void testItdOnInnerTypeOfGenericType_pr132349() { runTest("ITD on inner type of generic type");}
-  public void testItdOnInnerTypeOfGenericType_pr132349_2() { runTest("ITD on inner type of generic type - 2");}
-  public void testItdOnInnerTypeOfGenericType_pr132349_3() { runTest("ITD on inner type of generic type - 3");}
-  public void testLTWGeneratedAspectAbstractMethod_pr125480() { runTest("aop.xml aspect inheriting abstract method ");} 
-  public void testLTWGeneratedAspectAbstractMethod_pr125480_2() { runTest("aop.xml aspect inheriting abstract method - code style");} 
-  public void testCompletelyBrokenAopConcretization_pr142165_1() { runTest("broken concretization");}
-  public void testCompletelyBrokenAopConcretization_pr142165_2() { runTest("broken concretization - 2");}
-  public void testCompletelyBrokenAopConcretization_pr142165_3() { runTest("broken concretization - 3");}
-//  public void testVerifyErrorLTW_pr135068() { runTest("ltw verifyerror");}
-//  public void testVerifyErrorLTW_pr135068_2() { runTest("ltw verifyerror - 2");}
-//  public void testVerifyErrorLTW_pr135068_3() { runTest("ltw verifyerror - 3");}
-  public void testVerifyErrorLTW_pr135068_4() { runTest("ltw verifyerror - 4");}
-  public void testVerifyErrorForComplexCflow_pr136026() { runTest("verifyerror");}
-  public void testVerifyErrorForComplexCflow_pr136026_2() { runTest("verifyerror - 2");}
-  public void testAnnotationsAndGenericsBCException_pr129704() { runTest("annotations and generics leading to BCException");}
-  public void testMethodTooBigAfterWeaving_pr138384() { runTest("method too big"); }
-  public void testNotAtWithincode_pr138158_1() { runTest("not at withincode - 1");}
-  public void testNotAtWithincode_pr138158_2() { runTest("not at withincode - 2");}
-  public void testNotAtWithincode_pr138158_3() { runTest("not at within - 3");}
-  public void testNpeOnDup_pr138143() { runTest("npe on duplicate method with ataj");}
-  public void testPointcutsAndGenerics_pr137496_1() { runTest("pointcuts and generics - B");}
-  public void testPointcutsAndGenerics_pr137496_2() { runTest("pointcuts and generics - D");}
-  public void testPointcutsAndGenerics_pr137496_3() { runTest("pointcuts and generics - E");}
-  public void testPointcutsAndGenerics_pr137496_4() { runTest("pointcuts and generics - F");}
-  public void testPointcutsAndGenerics_pr137496_5() { runTest("pointcuts and generics - G");}
-  public void testPointcutsAndGenerics_pr137496_6() { runTest("pointcuts and generics - H");}
-  public void testAspectLibrariesAndASM_pr135001() { runTest("aspect libraries and asm");}
-  public void testStackOverflow_pr136258() { runTest("stack overflow");}
-  public void testIncorrectOverridesEvaluation13() { runTest("incorrect overrides evaluation - 1.3"); }
-  public void testIncorrectOverridesEvaluation15() { runTest("incorrect overrides evaluation - 1.5"); }
-  public void testAtWithinCodeBug_pr138798() { runTest("atWithinCodeBug"); }
-  public void testReferencePCutInDeclareWarning_pr138215() { runTest("Reference pointcut fails inside @DeclareWarning");}
-  public void testReferencePCutInPerClause_pr138219() { runTest("Can't use a FQ Reference pointcut in any pointcut expression referenced by a per-clause");}
-  public void testReferencePCutInPerClause_pr130722() { runTest("FQ Reference pointcut from perclause ref pc"); }
-  public void testDoubleAnnotationMatching_pr138223() { runTest("Double at annotation matching (no binding)");}
-  public void testSuperCallsInAtAspectJAdvice_pr139749() { runTest("Super calls in @AspectJ advice");}
-  public void testNoClassCastExceptionWithPerThis_pr138286() { runTest("No ClassCastException with perThis");}
-  public void testGenericAspectHierarchyWithBounds_pr147845() { runTest("Generic abstract aspect hierarchy with bounds"); }
-  public void testJRockitBooleanReturn_pr148007() { runTest("jrockit boolean fun");}
-  public void testJRockitBooleanReturn2_pr148007() { runTest("jrockit boolean fun (no aspects)");}
-  public void testSyntheticAjcMembers_pr147711() { runTest("synthetic ajc$ members"); }
-  
-// this next one reported as a bug by Rob Harrop, but I can't reproduce the failure yet...
-//public void testAtAspectWithReferencePCPerClause_pr138220() { runTest("@Aspect with reference pointcut in perclause");}  
-
-  public void testJarChecking_pr137235_1() { runTest("directory with .jar extension: source and outjar"); }	    
-  public void testJarChecking_pr137235_2() { runTest("directory with .jar extension"); }
-  public void testMakePreMethodNPE_pr136393() { runTest("NPE in makePreMethod");}
-
-  public void testGetParameterSignatures_pr141730() {
-	  runTest("new iprogramelement method getParameterSignatures");  
-	  
-	  checkGetParamSigOfMethod("stringMethod(java.lang.String)","Ljava/lang/String;");
-	  checkGetParamSigOfMethod("main(java.lang.String[])","[Ljava/lang/String;");
-	  checkGetParamSigOfMethod("multiMethod(java.lang.String[][])","[[Ljava/lang/String;");
-  }
-  
-  public void testGetParameterSignaturesWithGenerics_pr141730() {
-	  runTest("new iprogramelement method getParameterSignatures with generics");  
-	  
-	  checkGetParamSigOfMethod("genericMethod(java.util.List<java.lang.String>)","Pjava/util/List<Ljava/lang/String;>;");
-	  checkGetParamSigOfMethod("genericMethod2(MyGenericClass<java.lang.String,MyClass>)","PMyGenericClass<Ljava/lang/String;LMyClass;>;");
-  }
-  
-//  public void testFunkyGenericErrorWithITDs_pr126355_2() { 
-//	  runTest("bizarre generic error with itds - 2");
-//	  // public class Pair<F,S> affected by pertarget aspect
-//	  GenericsTests.verifyClassSignature(ajc,"Pair","<F:Ljava/lang/Object;S:Ljava/lang/Object;>Ljava/lang/Object;LIdempotentCache$ajcMightHaveAspect;;");
-//  }
-	
-	public void testNoAspects(){
-//		setSystemProperty(WeavingAdaptor.WEAVING_ADAPTOR_VERBOSE,"true");
+	// public void testCovarianceAndDecp_pr128443_1() { runTest("covariance and decp - 1"); }
+	// public void testSuperITDExplosion_pr134425() { runTest("super ITDs");}
+	// public void testMisbehavingDeclareAnnotation_pr135865() { runTest("misbehaving declare annotation");}
+	// public void testMisbehavingDeclareAnnotation_pr135865_2() { runTest("misbehaving declare annotation - 2");}
+	// public void testClassCastForInvalidAnnotationValue_pr148537() { runTest("classcast annotation value");}
+
+	// tests added post 152rc1 and before final
+	public void testSeparateCallAspectOf_pr148727() {
+		runTest("separate compilation calling aspectOf and hasAspect");
+	}
+
+	public void testIntegratedCallAspectOf_pr148727() {
+		runTest("integrated compilation calling aspectOf and hasAspect");
+	}
+
+	public void testFreakyNewArrayJoinpoint_pr148786() {
+		runTest("freaky new array joinpoint");
+	}
+
+	// tests adding during 152 development
+	public void testPrivilegeGeneric_pr148545() {
+		runTest("nosuchmethoderror for privileged aspect");
+	}
+
+	public void testPrivilegeGeneric_pr148545_2() {
+		runTest("nosuchmethoderror for privileged aspect - 2");
+	}
+
+	public void testUnknownAnnotationNPE() {
+		runTest("NPE for unknown annotation");
+	}
+
+	public void testDuplicateBridgeMethods_pr147801_1() {
+		runTest("duplicate bridge methods");
+	}
+
+	public void testPackageIgnoredForException_pr147701_1() {
+		runTest("package for exception ignored");
+	}
+
+	public void testPackageIgnoredForException_pr147701_2() {
+		runTest("package for exception ignored - 2");
+	}
+
+	public void testPackageIgnoredForException_pr147701_3() {
+		runTest("package for exception ignored - 3");
+	}
+
+	public void testBrokenAddSerialVersionUID_pr145950() {
+		runTest("fails to discover Serializable");
+	}
+
+	public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_1() {
+		runTest("no unnecessary declaration of thrown exception warning - 1");
+	}
+
+	public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_2() {
+		runTest("no unnecessary declaration of thrown exception warning - 2");
+	}
+
+	public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_3() {
+		runTest("no unnecessary declaration of thrown exception warning - 3");
+	}
+
+	public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_4() {
+		runTest("no unnecessary declaration of thrown exception warning - 4");
+	}
+
+	public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_5() {
+		runTest("no unnecessary declaration of thrown exception warning - 5");
+	}
+
+	public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_6() {
+		runTest("no unnecessary declaration of thrown exception warning - 6");
+	}
+
+	public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_7() {
+		runTest("no unnecessary declaration of thrown exception warning - 7");
+	}
+
+	public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_8() {
+		runTest("no unnecessary declaration of thrown exception warning - 8");
+	}
+
+	public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_9() {
+		runTest("no unnecessary declaration of thrown exception warning - 9");
+	}
+
+	public void testNoUnnecessaryDeclarationOfThrownExcp_pr129282_10() {
+		runTest("no unnecessary declaration of thrown exception warning - 10");
+	}
+
+	public void testAtAJVerificationError_pr144602() {
+		runTest("atAJ perthis aspect verification error");
+	}
+
+	public void testLTWAndGeneratingSUID_pr144465() {
+		runTest("ltw with serialversionUID creation");
+	}
+
+	public void testAspects14PerSingleton_pr122253() {
+		runTest("aspects14 - persingleton");
+	}
+
+	public void testAspects14PerCflow_pr122253() {
+		runTest("aspects14 - percflow");
+	}
+
+	public void testAspects14PerThis_pr122253() {
+		runTest("aspects14 - perthis");
+	}
+
+	public void testAspects14PerTypeWithin_pr122253() {
+		runTest("aspects14 - pertypewithin");
+	}
+
+	public void testFunkyGenericErrorWithITDs_pr126355() {
+		runTest("bizarre generic error with itds");
+	}
+
+	public void testConcretizingAbstractMethods_pr142466() {
+		runTest("aop.xml aspect inheriting but not concretizing abstract method");
+	}
+
+	public void testConcretizingAbstractMethods_pr142466_2() {
+		runTest("aop.xml aspect inheriting but not concretizing abstract method - 2");
+	}
+
+	public void testComplexGenericDecl_pr137568() {
+		runTest("complicated generics declaration");
+	}
+
+	public void testItdOnInnerTypeOfGenericType_pr132349() {
+		runTest("ITD on inner type of generic type");
+	}
+
+	public void testItdOnInnerTypeOfGenericType_pr132349_2() {
+		runTest("ITD on inner type of generic type - 2");
+	}
+
+	public void testItdOnInnerTypeOfGenericType_pr132349_3() {
+		runTest("ITD on inner type of generic type - 3");
+	}
+
+	public void testLTWGeneratedAspectAbstractMethod_pr125480() {
+		runTest("aop.xml aspect inheriting abstract method ");
+	}
+
+	public void testLTWGeneratedAspectAbstractMethod_pr125480_2() {
+		runTest("aop.xml aspect inheriting abstract method - code style");
+	}
+
+	public void testCompletelyBrokenAopConcretization_pr142165_1() {
+		runTest("broken concretization");
+	}
+
+	public void testCompletelyBrokenAopConcretization_pr142165_2() {
+		runTest("broken concretization - 2");
+	}
+
+	public void testCompletelyBrokenAopConcretization_pr142165_3() {
+		runTest("broken concretization - 3");
+	}
+
+	// public void testVerifyErrorLTW_pr135068() { runTest("ltw verifyerror");}
+	// public void testVerifyErrorLTW_pr135068_2() { runTest("ltw verifyerror - 2");}
+	// public void testVerifyErrorLTW_pr135068_3() { runTest("ltw verifyerror - 3");}
+	public void testVerifyErrorLTW_pr135068_4() {
+		runTest("ltw verifyerror - 4");
+	}
+
+	public void testVerifyErrorForComplexCflow_pr136026() {
+		runTest("verifyerror");
+	}
+
+	public void testVerifyErrorForComplexCflow_pr136026_2() {
+		runTest("verifyerror - 2");
+	}
+
+	public void testAnnotationsAndGenericsBCException_pr129704() {
+		runTest("annotations and generics leading to BCException");
+	}
+
+	public void testMethodTooBigAfterWeaving_pr138384() {
+		runTest("method too big");
+	}
+
+	public void testNotAtWithincode_pr138158_1() {
+		runTest("not at withincode - 1");
+	}
+
+	public void testNotAtWithincode_pr138158_2() {
+		runTest("not at withincode - 2");
+	}
+
+	public void testNotAtWithincode_pr138158_3() {
+		runTest("not at within - 3");
+	}
+
+	public void testNpeOnDup_pr138143() {
+		runTest("npe on duplicate method with ataj");
+	}
+
+	public void testPointcutsAndGenerics_pr137496_1() {
+		runTest("pointcuts and generics - B");
+	}
+
+	public void testPointcutsAndGenerics_pr137496_2() {
+		runTest("pointcuts and generics - D");
+	}
+
+	public void testPointcutsAndGenerics_pr137496_3() {
+		runTest("pointcuts and generics - E");
+	}
+
+	public void testPointcutsAndGenerics_pr137496_4() {
+		runTest("pointcuts and generics - F");
+	}
+
+	public void testPointcutsAndGenerics_pr137496_5() {
+		runTest("pointcuts and generics - G");
+	}
+
+	public void testPointcutsAndGenerics_pr137496_6() {
+		runTest("pointcuts and generics - H");
+	}
+
+	public void testAspectLibrariesAndASM_pr135001() {
+		runTest("aspect libraries and asm");
+	}
+
+	public void testStackOverflow_pr136258() {
+		runTest("stack overflow");
+	}
+
+	public void testIncorrectOverridesEvaluation13() {
+		runTest("incorrect overrides evaluation - 1.3");
+	}
+
+	public void testIncorrectOverridesEvaluation15() {
+		runTest("incorrect overrides evaluation - 1.5");
+	}
+
+	public void testAtWithinCodeBug_pr138798() {
+		runTest("atWithinCodeBug");
+	}
+
+	public void testReferencePCutInDeclareWarning_pr138215() {
+		runTest("Reference pointcut fails inside @DeclareWarning");
+	}
+
+	public void testReferencePCutInPerClause_pr138219() {
+		runTest("Can't use a FQ Reference pointcut in any pointcut expression referenced by a per-clause");
+	}
+
+	public void testReferencePCutInPerClause_pr130722() {
+		runTest("FQ Reference pointcut from perclause ref pc");
+	}
+
+	public void testDoubleAnnotationMatching_pr138223() {
+		runTest("Double at annotation matching (no binding)");
+	}
+
+	public void testSuperCallsInAtAspectJAdvice_pr139749() {
+		runTest("Super calls in @AspectJ advice");
+	}
+
+	public void testNoClassCastExceptionWithPerThis_pr138286() {
+		runTest("No ClassCastException with perThis");
+	}
+
+	public void testGenericAspectHierarchyWithBounds_pr147845() {
+		runTest("Generic abstract aspect hierarchy with bounds");
+	}
+
+	public void testJRockitBooleanReturn_pr148007() {
+		runTest("jrockit boolean fun");
+	}
+
+	public void testJRockitBooleanReturn2_pr148007() {
+		runTest("jrockit boolean fun (no aspects)");
+	}
+
+	public void testSyntheticAjcMembers_pr147711() {
+		runTest("synthetic ajc$ members");
+	}
+
+	// this next one reported as a bug by Rob Harrop, but I can't reproduce the failure yet...
+	// public void testAtAspectWithReferencePCPerClause_pr138220() { runTest("@Aspect with reference pointcut in perclause");}
+
+	public void testJarChecking_pr137235_1() {
+		runTest("directory with .jar extension: source and outjar");
+	}
+
+	public void testJarChecking_pr137235_2() {
+		runTest("directory with .jar extension");
+	}
+
+	public void testMakePreMethodNPE_pr136393() {
+		runTest("NPE in makePreMethod");
+	}
+
+	public void testGetParameterSignatures_pr141730() {
+		runTest("new iprogramelement method getParameterSignatures");
+
+		checkGetParamSigOfMethod("stringMethod(java.lang.String)", "Ljava/lang/String;");
+		checkGetParamSigOfMethod("main(java.lang.String[])", "[Ljava/lang/String;");
+		checkGetParamSigOfMethod("multiMethod(java.lang.String[][])", "[[Ljava/lang/String;");
+	}
+
+	public void testGetParameterSignaturesWithGenerics_pr141730() {
+		runTest("new iprogramelement method getParameterSignatures with generics");
+
+		checkGetParamSigOfMethod("genericMethod(java.util.List<java.lang.String>)", "Pjava/util/List<Ljava/lang/String;>;");
+		checkGetParamSigOfMethod("genericMethod2(MyGenericClass<java.lang.String,MyClass>)",
+				"PMyGenericClass<Ljava/lang/String;LMyClass;>;");
+	}
+
+	// public void testFunkyGenericErrorWithITDs_pr126355_2() {
+	// runTest("bizarre generic error with itds - 2");
+	// // public class Pair<F,S> affected by pertarget aspect
+	// GenericsTests.verifyClassSignature(ajc,"Pair","<F:Ljava/lang/Object;S:Ljava/lang/Object;>Ljava/lang/Object;LIdempotentCache$ajcMightHaveAspect;;");
+	// }
+
+	public void testNoAspects() {
+		// setSystemProperty(WeavingAdaptor.WEAVING_ADAPTOR_VERBOSE,"true");
 		runTest("Ensure no weaving without included aspects");
 	}
 
-	public void testWeaveinfoMessages (){
+	public void testWeaveinfoMessages() {
 		runTest("weaveinfo messages with include and exclude");
 	}
 
-  // tests that can't be included for some reason
+	// tests that can't be included for some reason
 
-  // Not valid whilst the ajc compiler forces debug on (ignores -g:none) - it will be green but is invalid, trust me
-  // public void testLongWindedMessages_pr129408() { runTest("long winded ataj messages");}
+	// Not valid whilst the ajc compiler forces debug on (ignores -g:none) - it will be green but is invalid, trust me
+	// public void testLongWindedMessages_pr129408() { runTest("long winded ataj messages");}
+
+	// ---------------- helper methods ---------------
 
-  // ---------------- helper methods ---------------
-  
 	private void checkGetParamSigOfMethod(String ipeLabel, String expectedParm) {
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
-		IProgramElement ipe = top.findElementForLabel(top.getRoot(),IProgramElement.Kind.METHOD,ipeLabel);
-	    assertNotNull("Couldn't find '" + ipeLabel + "' element in the tree",ipe);
-	    List l = ipe.getParameterSignatures();
-	    boolean eq = CharOperation.equals(((char[])l.get(0)),expectedParm.toCharArray());
-	    assertTrue("expected parameter to be '" + expectedParm + "' but found '" +
-	      		new String(((char[])l.get(0))) + "'",eq);
-	}
-	
-  /////////////////////////////////////////
-  public static Test suite() {
-    return XMLBasedAjcTestCase.loadSuite(Ajc152Tests.class);
-  }
-
-  protected File getSpecFile() {
-    return new File("../tests/src/org/aspectj/systemtest/ajc152/ajc152.xml");
-  }
-
-  
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
+		IProgramElement ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.METHOD, ipeLabel);
+		assertNotNull("Couldn't find '" + ipeLabel + "' element in the tree", ipe);
+		List l = ipe.getParameterSignatures();
+		boolean eq = CharOperation.equals(((char[]) l.get(0)), expectedParm.toCharArray());
+		assertTrue("expected parameter to be '" + expectedParm + "' but found '" + new String(((char[]) l.get(0))) + "'", eq);
+	}
+
+	// ///////////////////////////////////////
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(Ajc152Tests.class);
+	}
+
+	protected File getSpecFile() {
+		return new File("../tests/src/org/aspectj/systemtest/ajc152/ajc152.xml");
+	}
+
 }
\ No newline at end of file
@@ -11,223 +11,251 @@
 package org.aspectj.systemtest.ajc152;
 
 import java.io.File;
-import java.util.List;
 
 import junit.framework.Test;
 
-import org.aspectj.asm.AsmManager;
-import org.aspectj.asm.IProgramElement;
-import org.aspectj.asm.IRelationship;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 
 /**
- * Work items, phase #1: lock()/unlock()
- * x expose new joinpoints
- * x parse new pcds
- * x fix tjp string
- * x preventing double unlock() messages/markers in structure model
- * x error messages appropriate for attempting to use around advice on synchronization join points
- * x making the use of lock/unlock conditional on an -Xjoinpoints:synchronization
- * x activating the -Xjoinpoints options from LTW configurations rather than through batch/AJDT
- * x ensure the lock/unlock joinpoints only appear when -Xjoinpoints:synchronization specified
- * TAG: Completion of PHASE1
+ * Work items, phase #1: lock()/unlock() x expose new joinpoints x parse new pcds x fix tjp string x preventing double unlock()
+ * messages/markers in structure model x error messages appropriate for attempting to use around advice on synchronization join
+ * points x making the use of lock/unlock conditional on an -Xjoinpoints:synchronization x activating the -Xjoinpoints options from
+ * LTW configurations rather than through batch/AJDT x ensure the lock/unlock joinpoints only appear when
+ * -Xjoinpoints:synchronization specified TAG: Completion of PHASE1
  * 
  * 
  * Work items, phase #2: transformation
  * 
- * Design: transform all synchronized methods:
- *   public synchronized void m() {
- *     ...
- *   }
- *   =>
- *   public void m() {
- *     synchronized (this) {
- *       ...
- *     }
- *   }
- * 
- * x transforming synchronized methods
- * x matching execution(synchronized * *(..)) for transformed code
- * x warning message for execution() hitting a synchronized method
- * x ensure verifier runs over generated code (done by just executing the code as part of the test spec)
- * - Ant task support for -Xjoinpoints
- * TAG: Completion of PHASE2
- * 
- *
+ * Design: transform all synchronized methods: public synchronized void m() { ... } => public void m() { synchronized (this) { ... }
+ * }
+ * 
+ * x transforming synchronized methods x matching execution(synchronized * *(..)) for transformed code x warning message for
+ * execution() hitting a synchronized method x ensure verifier runs over generated code (done by just executing the code as part of
+ * the test spec) - Ant task support for -Xjoinpoints TAG: Completion of PHASE2
+ * 
+ * 
  * TAG: Finished
- *  
- * Future work items:
- * - optimize matching for transformed methods since we *know* the type we are locking on
- * - supporting type pattern in lock() unlock() - this is not entirely trivial as kinded pointcuts do not usually have any residue
- * - weaving messages include 'unusual' strings for the join points, not the 
- *   same as revealed by thisJoinPoint.getSignature() in code - handler is probably similar
- * - documentation
- * - lazy translation of synchronized methods, rather than eager
- * - applying execution(* *(..)) correctly to transformed methods (i.e. inside lock/unlock)
- * - use knowledge of type containing synchronized methods to optimize matching of (un)lock() - not always needing residue
- * - line number table is incorrect for transformed code (lock joinpoint has no line number)
- * 
- * Notes:
- * IllegalMonitorStateException
- * Thrown to indicate that a thread has attempted to wait on an object's monitor or to 
- * notify other threads waiting on an object's monitor without owning the specified monitor.
- *   
- * around advice won't work on SUN VMs (may be a bug that it does work on other VMs) since the monitor
- * instructions are extracted to a separate method for proceed() calls and yet the VM seems to want 
- * them paired inside a single method.
- * 
- * Really we only need to restrict the use of around advice on synchronization join points 
- * if the advice uses proceed() - but policing that is a little tough because (DOH) the
- * AdviceAttribute field 'proceedCallSignatures' is never filled in (which records how many
- * proceeds occur in the advice) - see where it isnt filled in at 
- * AdviceDeclaration.resolveStatements() in the loop that goes over the proceedCalls list.
- * 
- * 
- * Problems:
- * - Can't run it on a 1.2.1 runtime - just not practical
+ * 
+ * Future work items: - optimize matching for transformed methods since we *know* the type we are locking on - supporting type
+ * pattern in lock() unlock() - this is not entirely trivial as kinded pointcuts do not usually have any residue - weaving messages
+ * include 'unusual' strings for the join points, not the same as revealed by thisJoinPoint.getSignature() in code - handler is
+ * probably similar - documentation - lazy translation of synchronized methods, rather than eager - applying execution(* *(..))
+ * correctly to transformed methods (i.e. inside lock/unlock) - use knowledge of type containing synchronized methods to optimize
+ * matching of (un)lock() - not always needing residue - line number table is incorrect for transformed code (lock joinpoint has no
+ * line number)
+ * 
+ * Notes: IllegalMonitorStateException Thrown to indicate that a thread has attempted to wait on an object's monitor or to notify
+ * other threads waiting on an object's monitor without owning the specified monitor.
+ * 
+ * around advice won't work on SUN VMs (may be a bug that it does work on other VMs) since the monitor instructions are extracted to
+ * a separate method for proceed() calls and yet the VM seems to want them paired inside a single method.
+ * 
+ * Really we only need to restrict the use of around advice on synchronization join points if the advice uses proceed() - but
+ * policing that is a little tough because (DOH) the AdviceAttribute field 'proceedCallSignatures' is never filled in (which records
+ * how many proceeds occur in the advice) - see where it isnt filled in at AdviceDeclaration.resolveStatements() in the loop that
+ * goes over the proceedCalls list.
+ * 
+ * 
+ * Problems: - Can't run it on a 1.2.1 runtime - just not practical
  * 
  * 
  * Method transformation, example:
- 
-	public synchronized void m();
-	  Code:
-	   Stack=2, Locals=1, Args_size=1
-	   0:   getstatic       #2; //Field java/lang/System.err:Ljava/io/PrintStream;
-	   3:   ldc     #3; //String hello
-	   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
-	   8:   getstatic       #2; //Field java/lang/System.err:Ljava/io/PrintStream;
-	   11:  ldc     #5; //String world
-	   13:  invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
-	   16:  return
-	  LineNumberTable:
-	   line 4: 0
-	   line 5: 8
-	   line 6: 16
-	
-	public void m2();
-	  Code:
-	   Stack=2, Locals=3, Args_size=1
-	   0:   aload_0
-	   1:   dup
-	   2:   astore_1
-	   3:   monitorenter
-	   4:   getstatic       #2; //Field java/lang/System.err:Ljava/io/PrintStream;
-	   7:   ldc     #3; //String hello
-	   9:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
-	   12:  getstatic       #2; //Field java/lang/System.err:Ljava/io/PrintStream;
-	   15:  ldc     #5; //String world
-	   17:  invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
-	   20:  aload_1
-	   21:  monitorexit
-	   22:  goto    30
-	   25:  astore_2
-	   26:  aload_1
-	   27:  monitorexit
-	   28:  aload_2
-	   29:  athrow
-	   30:  return
-	  Exception table:
-	   from   to  target type
-	     4    22    25   any
-	    25    28    25   any
- *	    
- * Factors affecting transformation:
- * - LDC in Java5 supports referring to a class literal, e.g. Foo.class whereas before Java5, it did not.
- *   This means if generating the synchronized() block for a static method from a preJava5 class then
- *   we have to generate a lot of crap to build the class object for locking and unlocking.  The object
- *   is also stored in a local field of the type (if we follow the pattern of JDT/JAVAC)
+ * 
+ * public synchronized void m(); Code: Stack=2, Locals=1, Args_size=1 0: getstatic #2; //Field
+ * java/lang/System.err:Ljava/io/PrintStream; 3: ldc #3; //String hello 5: invokevirtual #4; //Method
+ * java/io/PrintStream.println:(Ljava/lang/String;)V 8: getstatic #2; //Field java/lang/System.err:Ljava/io/PrintStream; 11: ldc #5;
+ * //String world 13: invokevirtual #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V 16: return LineNumberTable: line
+ * 4: 0 line 5: 8 line 6: 16
+ * 
+ * public void m2(); Code: Stack=2, Locals=3, Args_size=1 0: aload_0 1: dup 2: astore_1 3: monitorenter 4: getstatic #2; //Field
+ * java/lang/System.err:Ljava/io/PrintStream; 7: ldc #3; //String hello 9: invokevirtual #4; //Method
+ * java/io/PrintStream.println:(Ljava/lang/String;)V 12: getstatic #2; //Field java/lang/System.err:Ljava/io/PrintStream; 15: ldc
+ * #5; //String world 17: invokevirtual #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V 20: aload_1 21: monitorexit
+ * 22: goto 30 25: astore_2 26: aload_1 27: monitorexit 28: aload_2 29: athrow 30: return Exception table: from to target type 4 22
+ * 25 any 25 28 25 any
+ * 
+ * Factors affecting transformation: - LDC in Java5 supports referring to a class literal, e.g. Foo.class whereas before Java5, it
+ * did not. This means if generating the synchronized() block for a static method from a preJava5 class then we have to generate a
+ * lot of crap to build the class object for locking and unlocking. The object is also stored in a local field of the type (if we
+ * follow the pattern of JDT/JAVAC)
  */
 
 public class SynchronizationTests extends XMLBasedAjcTestCase {
 
-  // testing the new join points for monitorenter/monitorexit
-  public void testTheBasics_1() { runTest("basic"); }
-  public void testTheBasics_2() { runTest("basic - within"); }
-  public void testTheBasics_3() { runTest("basic - within plus args"); }
-  public void testTheBasics_4() { runTest("basic - within plus this"); } // this null in static context
-  public void testTheBasics_5() { runTest("basic - within plus target"); } // target null in static context?
-  
-  
-  // testing parsing of the new PCDs lock/unlock
-  public void testParsing_1()        { runTest("parsing - lock"); }
-  public void testParsing_2()        { runTest("parsing - unlock"); }
-  public void testParsing_errors_1() { runTest("parsing - error - lock"); }
-  public void testParsing_errors_2() { runTest("parsing - error - unlock"); }
-  
-  // testing parsing and matching with the new PCDs
-  public void testParsingAndMatching_1()   { runTest("parsing and matching - lock and static context"); }
-  public void testParsingAndMatching_2()   { runTest("parsing and matching - unlock and static context"); }
-  public void testParsingAndMatching_3()   { runTest("parsing and matching - lock and non-static context"); }
-  public void testParsingAndMatching_4()   { runTest("parsing and matching - unlock and non-static context"); }
-  public void testParsingAndMatching_5()   { runTest("parsing and matching - lock and non-static context"); }
-  public void testParsingAndMatching_6()   { runTest("parsing and matching - unlock and non-static context"); }
-  
-  // using the new PCDs in a LTW environment
-  public void testUsingWithLTW_MissingFlag_1() { runTest("using lock with LTW - missing flag");}
-  public void testUsingWithLTW_MissingFlag_2() { runTest("using unlock with LTW - missing flag");}
-  public void testUsingWithLTW_1() { runTest("using lock with LTW");}
-  public void testUsingWithLTW_2() { runTest("using unlock with LTW");}
-  
-  // multiple PCDs
-  public void testCombiningPCDs_1() { runTest("combining pcds - lock and this");}
-  public void testCombiningPCDs_2() { runTest("combining pcds - unlock and this");}
-
-  // useful examples
-  public void testUseful_1()      { runTest("a useful program"); } // just uses within/args - matching the (un)lock jps
-  public void testUseful_2()      { runTest("a useful program - with lock"); }  // uses lock/args
-
-  // all the methods of thisJoinPoint
-  public void testThisJoinPoint_1() { runTest("thisjoinpoint - monitor entry");}
-  public void testThisJoinPoint_2() { runTest("thisjoinpoint - monitor exit"); }
-  
-  public void testDoubleMessagesOnUnlock() { 
-	//AsmManager.setReporting("c:/foo.txt",true,true,true,true);
-    runTest("prevent double unlock weaving messages and model contents");
-    //checkModel1();
-  }
-  
-  // targetting 1.2 runtime - signature creation code in LazyClassGen.initializeTjp may not work
-  
-  // different advice kinds
-  public void testBeforeAdvice_1() { runTest("before advice - lock");}
-  public void testBeforeAdvice_2() { runTest("before advice - unlock");}
-  public void testAfterAdvice_1()  { runTest("after advice - lock"); }
-  public void testAfterAdvice_2()  { runTest("after advice - unlock"); }
-  public void testAroundAdvice_1() { runTest("around advice - lock");}
-  public void testAroundAdvice_2() { runTest("around advice - unlock");}
-  
-  
-  public void testLockingTJP() { runTest("obtaining locked object through getArgs");}
-  
-  // binary weaving?
-  
-  // nested locking/unlocking
-  
-  // --- helpers
-  
-  // Half finished - could check there is only one relationship for unlock() rather than two - but
-  // that seems to be the case anyway (peculiar...)
-  private void checkModel1() {
-	  // Verifies only one unlock relationship, not two
-	  IProgramElement unlockNode =  AsmManager.getDefault().getHierarchy().findElementForLabel(AsmManager.getDefault().getHierarchy().getRoot(),
-  			  IProgramElement.Kind.CODE,"unlock(void java.lang.Object.<unlock>(java.lang.Object))");
-	  assertTrue("Couldn't find the unlock node",unlockNode!=null);
-	  List l = AsmManager.getDefault().getRelationshipMap().get(unlockNode);
-	  assertTrue("should be one entry :"+l,l!=null && l.size()==1);
-	  IRelationship ir = (IRelationship)l.get(0);
-	  System.err.println(ir);
-	  List targs = ir.getTargets();
-	  System.err.println(targs.size());
-	  System.err.println(targs.get(0));
-  }
-  
-  // --- 
-  public static Test suite() {
-    return XMLBasedAjcTestCase.loadSuite(SynchronizationTests.class);
-  }
-
-  protected File getSpecFile() {
-    return new File("../tests/src/org/aspectj/systemtest/ajc152/synchronization.xml");
-  }
-	
+	// testing the new join points for monitorenter/monitorexit
+	public void testTheBasics_1() {
+		runTest("basic");
+	}
+
+	public void testTheBasics_2() {
+		runTest("basic - within");
+	}
+
+	public void testTheBasics_3() {
+		runTest("basic - within plus args");
+	}
+
+	public void testTheBasics_4() {
+		runTest("basic - within plus this");
+	} // this null in static context
+
+	public void testTheBasics_5() {
+		runTest("basic - within plus target");
+	} // target null in static context?
+
+	// testing parsing of the new PCDs lock/unlock
+	public void testParsing_1() {
+		runTest("parsing - lock");
+	}
+
+	public void testParsing_2() {
+		runTest("parsing - unlock");
+	}
+
+	public void testParsing_errors_1() {
+		runTest("parsing - error - lock");
+	}
+
+	public void testParsing_errors_2() {
+		runTest("parsing - error - unlock");
+	}
+
+	// testing parsing and matching with the new PCDs
+	public void testParsingAndMatching_1() {
+		runTest("parsing and matching - lock and static context");
+	}
+
+	public void testParsingAndMatching_2() {
+		runTest("parsing and matching - unlock and static context");
+	}
+
+	public void testParsingAndMatching_3() {
+		runTest("parsing and matching - lock and non-static context");
+	}
+
+	public void testParsingAndMatching_4() {
+		runTest("parsing and matching - unlock and non-static context");
+	}
+
+	public void testParsingAndMatching_5() {
+		runTest("parsing and matching - lock and non-static context");
+	}
+
+	public void testParsingAndMatching_6() {
+		runTest("parsing and matching - unlock and non-static context");
+	}
+
+	// using the new PCDs in a LTW environment
+	public void testUsingWithLTW_MissingFlag_1() {
+		runTest("using lock with LTW - missing flag");
+	}
+
+	public void testUsingWithLTW_MissingFlag_2() {
+		runTest("using unlock with LTW - missing flag");
+	}
+
+	public void testUsingWithLTW_1() {
+		runTest("using lock with LTW");
+	}
+
+	public void testUsingWithLTW_2() {
+		runTest("using unlock with LTW");
+	}
+
+	// multiple PCDs
+	public void testCombiningPCDs_1() {
+		runTest("combining pcds - lock and this");
+	}
+
+	public void testCombiningPCDs_2() {
+		runTest("combining pcds - unlock and this");
+	}
+
+	// useful examples
+	public void testUseful_1() {
+		runTest("a useful program");
+	} // just uses within/args - matching the (un)lock jps
+
+	public void testUseful_2() {
+		runTest("a useful program - with lock");
+	} // uses lock/args
+
+	// all the methods of thisJoinPoint
+	public void testThisJoinPoint_1() {
+		runTest("thisjoinpoint - monitor entry");
+	}
+
+	public void testThisJoinPoint_2() {
+		runTest("thisjoinpoint - monitor exit");
+	}
+
+	public void testDoubleMessagesOnUnlock() {
+		// AsmManager.setReporting("c:/foo.txt",true,true,true,true);
+		runTest("prevent double unlock weaving messages and model contents");
+		// checkModel1();
+	}
+
+	// targetting 1.2 runtime - signature creation code in LazyClassGen.initializeTjp may not work
+
+	// different advice kinds
+	public void testBeforeAdvice_1() {
+		runTest("before advice - lock");
+	}
+
+	public void testBeforeAdvice_2() {
+		runTest("before advice - unlock");
+	}
+
+	public void testAfterAdvice_1() {
+		runTest("after advice - lock");
+	}
+
+	public void testAfterAdvice_2() {
+		runTest("after advice - unlock");
+	}
+
+	public void testAroundAdvice_1() {
+		runTest("around advice - lock");
+	}
+
+	public void testAroundAdvice_2() {
+		runTest("around advice - unlock");
+	}
+
+	public void testLockingTJP() {
+		runTest("obtaining locked object through getArgs");
+	}
+
+	// binary weaving?
+
+	// nested locking/unlocking
+
+	// --- helpers
+
+	// Half finished - could check there is only one relationship for unlock() rather than two - but
+	// that seems to be the case anyway (peculiar...)
+	// private void checkModel1() {
+	// // Verifies only one unlock relationship, not two
+	// IProgramElement unlockNode =
+	// AsmManager.getDefault().getHierarchy().findElementForLabel(AsmManager.getDefault().getHierarchy().getRoot(),
+	// IProgramElement.Kind.CODE,"unlock(void java.lang.Object.<unlock>(java.lang.Object))");
+	// assertTrue("Couldn't find the unlock node",unlockNode!=null);
+	// List l = AsmManager.getDefault().getRelationshipMap().get(unlockNode);
+	// assertTrue("should be one entry :"+l,l!=null && l.size()==1);
+	// IRelationship ir = (IRelationship)l.get(0);
+	// System.err.println(ir);
+	// List targs = ir.getTargets();
+	// System.err.println(targs.size());
+	// System.err.println(targs.get(0));
+	// }
+
+	// ---
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(SynchronizationTests.class);
+	}
+
+	protected File getSpecFile() {
+		return new File("../tests/src/org/aspectj/systemtest/ajc152/synchronization.xml");
+	}
+
 }
@@ -24,9 +24,6 @@ import junit.framework.Test;
 
 import org.aspectj.apache.bcel.classfile.JavaClass;
 import org.aspectj.apache.bcel.classfile.Method;
-import org.aspectj.asm.AsmManager;
-import org.aspectj.asm.IProgramElement;
-import org.aspectj.asm.IRelationship;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 import org.aspectj.testing.util.TestUtil;
 import org.aspectj.testing.util.TestUtil.LineStream;
@@ -38,213 +35,179 @@ import org.aspectj.weaver.bcel.BcelWorld;
 import org.aspectj.weaver.bcel.LazyClassGen;
 import org.aspectj.weaver.bcel.LazyMethodGen;
 
-
 /**
  * Method transformation, example:
- 
-	public synchronized void m();
-	  Code:
-	   Stack=2, Locals=1, Args_size=1
-	   0:   getstatic       #2; //Field java/lang/System.err:Ljava/io/PrintStream;
-	   3:   ldc     #3; //String hello
-	   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
-	   8:   getstatic       #2; //Field java/lang/System.err:Ljava/io/PrintStream;
-	   11:  ldc     #5; //String world
-	   13:  invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
-	   16:  return
-	  LineNumberTable:
-	   line 4: 0
-	   line 5: 8
-	   line 6: 16
-	
-	public void m2();
-	  Code:
-	   Stack=2, Locals=3, Args_size=1
-	   0:   aload_0
-	   1:   dup
-	   2:   astore_1
-	   3:   monitorenter
-	   4:   getstatic       #2; //Field java/lang/System.err:Ljava/io/PrintStream;
-	   7:   ldc     #3; //String hello
-	   9:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
-	   12:  getstatic       #2; //Field java/lang/System.err:Ljava/io/PrintStream;
-	   15:  ldc     #5; //String world
-	   17:  invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
-	   20:  aload_1
-	   21:  monitorexit
-	   22:  goto    30
-	   25:  astore_2
-	   26:  aload_1
-	   27:  monitorexit
-	   28:  aload_2
-	   29:  athrow
-	   30:  return
-	  Exception table:
-	   from   to  target type
-	     4    22    25   any
-	    25    28    25   any
+ * 
+ * public synchronized void m(); Code: Stack=2, Locals=1, Args_size=1 0: getstatic #2; //Field
+ * java/lang/System.err:Ljava/io/PrintStream; 3: ldc #3; //String hello 5: invokevirtual #4; //Method
+ * java/io/PrintStream.println:(Ljava/lang/String;)V 8: getstatic #2; //Field java/lang/System.err:Ljava/io/PrintStream; 11: ldc #5;
+ * //String world 13: invokevirtual #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V 16: return LineNumberTable: line
+ * 4: 0 line 5: 8 line 6: 16
+ * 
+ * public void m2(); Code: Stack=2, Locals=3, Args_size=1 0: aload_0 1: dup 2: astore_1 3: monitorenter 4: getstatic #2; //Field
+ * java/lang/System.err:Ljava/io/PrintStream; 7: ldc #3; //String hello 9: invokevirtual #4; //Method
+ * java/io/PrintStream.println:(Ljava/lang/String;)V 12: getstatic #2; //Field java/lang/System.err:Ljava/io/PrintStream; 15: ldc
+ * #5; //String world 17: invokevirtual #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V 20: aload_1 21: monitorexit
+ * 22: goto 30 25: astore_2 26: aload_1 27: monitorexit 28: aload_2 29: athrow 30: return Exception table: from to target type 4 22
+ * 25 any 25 28 25 any
  */
 
 public class SynchronizationTransformTests extends XMLBasedAjcTestCase {
 
 	private static boolean regenerate;
-	
-	static { regenerate = false; }
+
+	static {
+		regenerate = false;
+	}
 
 	private World world;
-	
-    public void testInvestigatingTransforming() { 
-    	  runTest("investigation");
-    	  checkMethod("Investigation","b"); // similar output to One.b
-    	  checkMethod("Investigation","c");
-    	  checkMethod("Investigation","d");
-    	  checkMethod("Investigation","e");
-    	}
-    
-    public void testTransform1() {
-    	  runTest("One");
-    	  checkMethod("One","b");
-    	  checkMethod("One","c");
-    	  checkMethod("One","e");
-    }
-    
-    // before() on execution jp
-    public void testTransform2() {
-    	  runTest("Two");
-    	  checkMethod("C","ma");
-    }
-
-    public void testTransform2XlintOff() {
-    	  runTest("Two - xlintoff");
-    	  checkMethod("C","ma");
-    }
-    
-    // after() returning/after() throwing on execution jp
-    // after() returning -> make all returns go through the same exit point and make
-    // it call the advice
-    // after() throwing -> add a catch block that calls the advice
-    public void testTransform3() {
-  	  runTest("Three");
-	  checkMethod("C","m3");
-	  checkMethod("C","m32");
-	  checkMethod("C","m33"); // like m() but synchronized block
-	  checkMethod("C","m34"); // like m2() but synchronized block
-    }
-    
-    // like testTransform3() but pointcuts explicitly specify synchronized
-    public void testTransform4() {
-    	  runTest("Four");
-  	  checkMethod("C","m");
-  	  checkMethod("C","m2");
-    }
-    
-    
-    
-    // Java5 variant
-    public void testStaticSynchronizedMethodTransformJava5() {
-  	  runTest("Five - Java5");
-	  checkMethod("C","b");
-    }
-    
-    // < Java5 variant
-    public void testStaticSynchronizedMethodTransformPreJava5() {
-    	  runTest("Six - preJava5");
-  	  checkMethod("C","bbb");
-    }
-    
-    public void testLockPcdOnTransformedNonStaticMethod() {
-    	  runTest("lock pcd on transformed non-static method");
-    }
-    
-    public void testUnlockPcdOnTransformedNonStaticMethod() {
-  	  runTest("unlock pcd on transformed non-static method");
-    }
-
-    public void testLockPcdOnTransformedStaticMethod() {
-    	  runTest("lock pcd on transformed static method - J5");
-    }
-    
-    public void testUnlockPcdOnTransformedStaticMethod() {
-  	  runTest("unlock pcd on transformed static method - J5");
-    }
-
-    public void testLockPcdOnTransformedStaticMethodPreJ5() {
-    	  runTest("lock pcd on transformed static method - preJ5");
-    }
-    
-    public void testUnlockPcdOnTransformedStaticMethodPreJ5() {
-  	  runTest("unlock pcd on transformed static method - preJ5");
-    }
-    
-    public void testJoinpointsEnabledButNoLock() {
-    	runTest("joinpoints enabled but no lock");
-    }
-    
-    public void testTransformWithLTW() {
-    	runTest("transform with LTW");
-    }
-    
-
-    public void testTransformStaticMethodPreJava5() {
-    	runTest("transform static method - preJ5");
-    }
-
-    public void testTransformStaticMethodPreJava5_2() {
-    	runTest("transform static method - packages - preJ5");
-    }
-
-    // more complex code sequences...
-    public void testOtherTargeters() {
-  	  runTest("other targeters");
-    }
-    
-    // --- infrastructure below
-    
-    private void checkMethod(String typename,String methodname) {
-    	  LazyMethodGen m = getMethod(typename,methodname);
-    	  File expectedF = new File(".."+File.separator+"tests"+File.separator+"features152"+File.separator+"synchronization"+File.separator+
-    			                    "transformed"+File.separator+"expected"+File.separator+
-    			                    typename+"."+methodname+".txt");
-    	  if (regenerate) {
-    		  saveMethod(expectedF, m);
-    	  } else {
-    		  compareMethod(expectedF, m);
-    	  }
-    }
-
-    
-    
-    private LazyMethodGen getMethod(String typename,String methodname) {
-    	  BcelObjectType type = getBcelObjectFor(typename);
-    	  LazyClassGen lcg = type.getLazyClassGen();
-    	  List /*LazyMethodGen*/ methods = lcg.getMethodGens();
-    	  for (Iterator iter = methods.iterator(); iter.hasNext();) {
+
+	public void testInvestigatingTransforming() {
+		runTest("investigation");
+		checkMethod("Investigation", "b"); // similar output to One.b
+		checkMethod("Investigation", "c");
+		checkMethod("Investigation", "d");
+		checkMethod("Investigation", "e");
+	}
+
+	public void testTransform1() {
+		runTest("One");
+		checkMethod("One", "b");
+		checkMethod("One", "c");
+		checkMethod("One", "e");
+	}
+
+	// before() on execution jp
+	public void testTransform2() {
+		runTest("Two");
+		checkMethod("C", "ma");
+	}
+
+	public void testTransform2XlintOff() {
+		runTest("Two - xlintoff");
+		checkMethod("C", "ma");
+	}
+
+	// after() returning/after() throwing on execution jp
+	// after() returning -> make all returns go through the same exit point and make
+	// it call the advice
+	// after() throwing -> add a catch block that calls the advice
+	public void testTransform3() {
+		runTest("Three");
+		checkMethod("C", "m3");
+		checkMethod("C", "m32");
+		checkMethod("C", "m33"); // like m() but synchronized block
+		checkMethod("C", "m34"); // like m2() but synchronized block
+	}
+
+	// like testTransform3() but pointcuts explicitly specify synchronized
+	public void testTransform4() {
+		runTest("Four");
+		checkMethod("C", "m");
+		checkMethod("C", "m2");
+	}
+
+	// Java5 variant
+	public void testStaticSynchronizedMethodTransformJava5() {
+		runTest("Five - Java5");
+		checkMethod("C", "b");
+	}
+
+	// < Java5 variant
+	public void testStaticSynchronizedMethodTransformPreJava5() {
+		runTest("Six - preJava5");
+		checkMethod("C", "bbb");
+	}
+
+	public void testLockPcdOnTransformedNonStaticMethod() {
+		runTest("lock pcd on transformed non-static method");
+	}
+
+	public void testUnlockPcdOnTransformedNonStaticMethod() {
+		runTest("unlock pcd on transformed non-static method");
+	}
+
+	public void testLockPcdOnTransformedStaticMethod() {
+		runTest("lock pcd on transformed static method - J5");
+	}
+
+	public void testUnlockPcdOnTransformedStaticMethod() {
+		runTest("unlock pcd on transformed static method - J5");
+	}
+
+	public void testLockPcdOnTransformedStaticMethodPreJ5() {
+		runTest("lock pcd on transformed static method - preJ5");
+	}
+
+	public void testUnlockPcdOnTransformedStaticMethodPreJ5() {
+		runTest("unlock pcd on transformed static method - preJ5");
+	}
+
+	public void testJoinpointsEnabledButNoLock() {
+		runTest("joinpoints enabled but no lock");
+	}
+
+	public void testTransformWithLTW() {
+		runTest("transform with LTW");
+	}
+
+	public void testTransformStaticMethodPreJava5() {
+		runTest("transform static method - preJ5");
+	}
+
+	public void testTransformStaticMethodPreJava5_2() {
+		runTest("transform static method - packages - preJ5");
+	}
+
+	// more complex code sequences...
+	public void testOtherTargeters() {
+		runTest("other targeters");
+	}
+
+	// --- infrastructure below
+
+	private void checkMethod(String typename, String methodname) {
+		LazyMethodGen m = getMethod(typename, methodname);
+		File expectedF = new File(".." + File.separator + "tests" + File.separator + "features152" + File.separator
+				+ "synchronization" + File.separator + "transformed" + File.separator + "expected" + File.separator + typename
+				+ "." + methodname + ".txt");
+		if (regenerate) {
+			saveMethod(expectedF, m);
+		} else {
+			compareMethod(expectedF, m);
+		}
+	}
+
+	private LazyMethodGen getMethod(String typename, String methodname) {
+		BcelObjectType type = getBcelObjectFor(typename);
+		LazyClassGen lcg = type.getLazyClassGen();
+		List /* LazyMethodGen */methods = lcg.getMethodGens();
+		for (Iterator iter = methods.iterator(); iter.hasNext();) {
 			LazyMethodGen element = (LazyMethodGen) iter.next();
 			if (element.getName().equals(methodname)) {
 				return element;
 			}
-	  }
-    	  return null;
-    }
-    
-    private BcelObjectType getBcelObjectFor(String clazzname) {
+		}
+		return null;
+	}
+
+	private BcelObjectType getBcelObjectFor(String clazzname) {
 		ensureWorldSetup();
-    		ResolvedType rt = world.resolve(clazzname);
-    		if (rt==null) fail("Couldn't find class "+clazzname);
-    	    ReferenceType rtt = (ReferenceType)rt;
-    	    BcelObjectType bot = (BcelObjectType)rtt.getDelegate();
-    		return bot;
-	}
-    
-    private void ensureWorldSetup() {
-        if (world == null) {
-	    	    world = new BcelWorld(
-	    			  getSandboxDirectory()+File.pathSeparator+
-				  System.getProperty("java.class.path"));
-        }
-	}	
-	
-	protected Method getMethod(JavaClass cl,String methodname) {
+		ResolvedType rt = world.resolve(clazzname);
+		if (rt == null)
+			fail("Couldn't find class " + clazzname);
+		ReferenceType rtt = (ReferenceType) rt;
+		BcelObjectType bot = (BcelObjectType) rtt.getDelegate();
+		return bot;
+	}
+
+	private void ensureWorldSetup() {
+		if (world == null) {
+			world = new BcelWorld(getSandboxDirectory() + File.pathSeparator + System.getProperty("java.class.path"));
+		}
+	}
+
+	protected Method getMethod(JavaClass cl, String methodname) {
 		Method[] methods = cl.getMethods();
 		for (int i = 0; i < methods.length; i++) {
 			Method m = methods[i];
@@ -254,98 +217,95 @@ public class SynchronizationTransformTests extends XMLBasedAjcTestCase {
 		}
 		return null;
 	}
-    
-	public void dump(String title,String[] strs) {
+
+	public void dump(String title, String[] strs) {
 		System.err.println(title);
 		for (int i = 0; i < strs.length; i++) {
-			System.err.println(i+") "+strs[i]);
+			System.err.println(i + ") " + strs[i]);
 		}
 	}
-  
-  private void compareMethod(File f,LazyMethodGen m) {
+
+	private void compareMethod(File f, LazyMethodGen m) {
 		BufferedReader fr;
 		if (!f.exists()) {
-			fail("Can't find expected output file "+f);
+			fail("Can't find expected output file " + f);
 		}
 		try {
 			// Load the file in
 			fr = new BufferedReader(new FileReader(f));
 			String line = null;
 			List originalFileContents = new ArrayList();
-			while ((line=fr.readLine())!=null) originalFileContents.add(line);
-			String[] fileContents = (String[])originalFileContents.toArray(new String[]{});
-			
+			while ((line = fr.readLine()) != null)
+				originalFileContents.add(line);
+			String[] fileContents = (String[]) originalFileContents.toArray(new String[] {});
+
 			LineStream ls = new TestUtil.LineStream();
-			m.print(ls,null);
+			m.print(ls, null);
 			String[] lines = ls.getLines();
 			for (int i = 0; i < lines.length; i++) {
 				String existingLine = lines[i];
-				if (fileContents[i].indexOf("MethodDeclarationLineNumber")==-1 && 
-					!fileContents[i].equals(existingLine)) {
-					dump("File contents:",fileContents);
-					dump("Actual:",lines);
-					fail("\nDifference in method "+m.getName()+" on line "+i+" between the expected:\n"+fileContents[i]+
-							           "\nand the found:\n"+existingLine);
+				if (fileContents[i].indexOf("MethodDeclarationLineNumber") == -1 && !fileContents[i].equals(existingLine)) {
+					dump("File contents:", fileContents);
+					dump("Actual:", lines);
+					fail("\nDifference in method " + m.getName() + " on line " + i + " between the expected:\n" + fileContents[i]
+							+ "\nand the found:\n" + existingLine);
 				}
 			}
 		} catch (Exception e) {
-			fail("Unexpected exception saving weaving messages:"+e);
+			fail("Unexpected exception saving weaving messages:" + e);
 		}
 	}
-	
+
 	private String stringify(List l) {
 		StringBuffer result = new StringBuffer();
 		for (Iterator iter = l.iterator(); iter.hasNext();) {
 			String str = (String) iter.next();
-			result.append(str);result.append("\n");
+			result.append(str);
+			result.append("\n");
 		}
 		return result.toString();
 	}
-	
-	
-	private void saveMethod(File f,LazyMethodGen m) {
-		System.out.println("Saving method into "+f.getName());
+
+	private void saveMethod(File f, LazyMethodGen m) {
+		System.out.println("Saving method into " + f.getName());
 		try {
-			m.print(new PrintStream(new FileOutputStream(f)),null);
+			m.print(new PrintStream(new FileOutputStream(f)), null);
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
-			fail("Couldn't store the method in file "+f);
+			fail("Couldn't store the method in file " + f);
 		}
 	}
-  
-  
-  
-  
-  
-  
-  
-  // --- helpers
-  
-  // Half finished - could check there is only one relationship for unlock() rather than two - but
-  // that seems to be the case anyway (peculiar...)
-  private void checkModel1() {
-	  // Verifies only one unlock relationship, not two
-	  IProgramElement unlockNode =  AsmManager.getDefault().getHierarchy().findElementForLabel(AsmManager.getDefault().getHierarchy().getRoot(),
-  			  IProgramElement.Kind.CODE,"unlock(void java.lang.Object.<unlock>(java.lang.Object))");
-	  assertTrue("Couldn't find the unlock node",unlockNode!=null);
-	  List l = AsmManager.getDefault().getRelationshipMap().get(unlockNode);
-	  assertTrue("should be one entry :"+l,l!=null && l.size()==1);
-	  IRelationship ir = (IRelationship)l.get(0);
-	  System.err.println(ir);
-	  List targs = ir.getTargets();
-	  System.err.println(targs.size());
-	  System.err.println(targs.get(0));
-  }
-  
-  // --- 
-  public static Test suite() {
-    return XMLBasedAjcTestCase.loadSuite(SynchronizationTransformTests.class);
-  }
-
-  protected File getSpecFile() {
-    return new File("../tests/src/org/aspectj/systemtest/ajc152/synchronization.xml");
-  }
-
-  public void tearDown() { world = null; }
-	
+
+	// --- helpers
+
+	// Half finished - could check there is only one relationship for unlock() rather than two - but
+	// that seems to be the case anyway (peculiar...)
+	// private void checkModel1() {
+	// // Verifies only one unlock relationship, not two
+	// IProgramElement unlockNode =
+	// AsmManager.getDefault().getHierarchy().findElementForLabel(AsmManager.getDefault().getHierarchy().getRoot(),
+	// IProgramElement.Kind.CODE,"unlock(void java.lang.Object.<unlock>(java.lang.Object))");
+	// assertTrue("Couldn't find the unlock node",unlockNode!=null);
+	// List l = AsmManager.getDefault().getRelationshipMap().get(unlockNode);
+	// assertTrue("should be one entry :"+l,l!=null && l.size()==1);
+	// IRelationship ir = (IRelationship)l.get(0);
+	// System.err.println(ir);
+	// List targs = ir.getTargets();
+	// System.err.println(targs.size());
+	// System.err.println(targs.get(0));
+	// }
+
+	// ---
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(SynchronizationTransformTests.class);
+	}
+
+	protected File getSpecFile() {
+		return new File("../tests/src/org/aspectj/systemtest/ajc152/synchronization.xml");
+	}
+
+	public void tearDown() {
+		world = null;
+	}
+
 }
@@ -17,280 +17,438 @@ import junit.framework.Test;
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IHierarchy;
 import org.aspectj.asm.IProgramElement;
-import org.aspectj.testing.Utils;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 import org.aspectj.weaver.bcel.Utility;
 
 public class Ajc153Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testFormalCommentsAreSetForConstructorIPEs_pr164340() {
+		runTest("formal comments are set for constructor ipes");
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
+		IProgramElement ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.CONSTRUCTOR, "C()");
+		assertNotNull("expected formal comment to be non null but" + " found that it was null", ipe.getFormalComment());
+	}
 
-  public void testFormalCommentsAreSetForConstructorIPEs_pr164340() {
-	  runTest("formal comments are set for constructor ipes");
-	  IHierarchy top = AsmManager.getDefault().getHierarchy();
-	  IProgramElement ipe = top.findElementForLabel(top.getRoot(),
-			  IProgramElement.Kind.CONSTRUCTOR,"C()");
-	  assertNotNull("expected formal comment to be non null but" +
-		  		" found that it was null",ipe.getFormalComment());
-  }
-  //public void testGenericsProblem_pr151978() { runTest("generics problem");}
-  // public void testArgnamesAndJavac_pr148381() { runTest("argNames and javac");}
-  // public void testCFlowXMLAspectLTW_pr149096() { runTest("cflow xml concrete aspect"); }
-  // public void testAmbiguousBinding_pr121805() { runTest("ambiguous binding");}
-//  public void testNegatedAnnotationMatchingProblem_pr153464() { runTest("negated annotation matching problem");}
-//  public void testAnnotationStyleBcException_pr162135() { runTest("bcexception in annotation style around advice");}
-//  public void testAnnotationStyleBcException_pr162135_2() { runTest("bcexception in annotation style around advice - 2");}
-//  public void testAnnotationStyleBcException_pr162135_3() { runTest("bcexception in annotation style around advice - 3");}
-//  public void testAnnotationStyleBcException_pr162135_4() { runTest("bcexception in annotation style around advice - 4");}
-//  public void testAnnotationStyleBcException_pr162135_5() { runTest("bcexception in annotation style around advice - 5");}
-  public void testIncompatibleClassChangeWithITD_pr164633() { runTest("incompatibleclasschange");}
-  public void testComplexPointcut_pr162657() { runTest("complex pointcut");}
-  public void testGenericsInPointcuts_pr161502() { runTest("generics in pointcuts");}
-  public void testGenericsInPointcuts_pr161502_2() { runTest("generics in pointcuts - 2");}
-  public void testNoNPEDueToMissingType_pr149908() { runTest("ensure no npe due to missing type");}
-  public void testNoNPEDueToMember_pr149908() { runTest("ensure no npe due to missing member");}
-  public void testPTWgetWithinTypeName_pr123423_1() { runTest("basic usage of getWithinTypeName");}
-  public void testPTWgetWithinTypeName_pr123423_2() { runTest("basic usage of getWithinTypeName - multiple types");}
-  public void testPTWgetWithinTypeName_pr123423_3() { runTest("basic usage of getWithinTypeName - non matching types");}
-  public void testPTWgetWithinTypeName_pr123423_4() { runTest("basic usage of getWithinTypeName - types in packages");}
-  public void testPTWgetWithinTypeName_pr123423_5() { runTest("basic usage of getWithinTypeName - annotation style");}
-  public void testTurningOffBcelCaching_pr160674() { runTest("turning off bcel caching");}
-  public void testNoIllegalStateExceptionWithGenericInnerAspect_pr156058() { runTest("no IllegalStateException with generic inner aspect"); }
-  public void testNoIllegalStateExceptionWithGenericInnerAspect_pr156058_2() { runTest("no IllegalStateException with generic inner aspect - 2"); }
-  public void testDeclareMethodAnnotations_pr159143() { runTest("declare method annotations");}
-  public void testVisibilityProblem_pr149071()                 { runTest("visibility problem");}
-  public void testMissingLineNumbersInStacktraceAfter_pr145442() { runTest("missing line numbers in stacktrace after");}
-  public void testMissingLineNumbersInStacktraceAround_pr145442() { runTest("missing line numbers in stacktrace around");}
-  public void testGenericArrays_pr158624() { runTest("generics and arrays"); }
-  public void testMissingLineNumbersInStacktraceBefore_pr145442() { runTest("missing line numbers in stacktrace before");}
-  public void testMissingLineNumbersInStacktraceBefore_pr145442_Binary() { runTest("missing line numbers in stacktrace before - binary");}
-  public void testAnnotationStylePointcutNPE_pr158412() { runTest("annotation style pointcut npe"); }
-  public void testAnnotationStylePointcutNPE_pr158412_2() { runTest("annotation style pointcut npe - 2"); }
-  public void testAnnotationsCallConstructors_pr158126() { runTest("annotations, call and constructors problem");}
-  public void testIllegalStateExceptionGenerics_pr153845() { runTest("IllegalStateException at GenericSignatureParser.java"); }
-  public void testNoIllegalStateExceptionFromAsmDelegate_pr153490_1() { runTest("no illegal state exception from AsmDelegate - 1");}
-  public void testNoIllegalStateExceptionFromAsmDelegate_pr153490_2() { runTest("no illegal state exception from AsmDelegate - 2");}
-  public void testNoIllegalStateExceptionFromAsmDelegate_pr153490_3() { runTest("no illegal state exception from AsmDelegate - 3");}
-  public void testAnnotMethod_pr156962() { runTest("Test Annot Method");}
-  public void testAnnotMethodHasMember_pr156962() { runTest("Test Annot Method Has Member"); }
-  public void testMixingGenerics_pr152848()  { runTest("mixing generics"); }
-  public void testIncorrectStaticinitializationWeaving_pr149560_1() { runTest("incorrect staticinitialization weaving - codestyle");}
-  public void testIncorrectStaticinitializationWeaving_pr149560_2() { runTest("incorrect staticinitialization weaving - annstyle");}
-  public void testIncorrectDeprecatedAnnotationProcessing_pr154332() { runTest("incorrect deprecated annotation processing");}
-  public void testPipeliningProblemWithAnnotationsDecp_pr153380_1() { runTest("pipelining decps");}
-  public void testUnwantedPointcutWarning_pr148219() { runTest("unwanted warning for pointcut");}
-  public void testDecpAndCflowadderMungerClash_pr152631() { runTest("decp and cflowadder munger clash");}
-  public void testGenericInheritanceDecp_pr150095() { runTest("generics, inheritance and decp");}
-  public void testIllegalStateException_pr148737() { runTest("illegalstateexception for non generic type");}
-  public void testAtajInheritance_pr149305_1()     { runTest("ataj inheritance - 1");}
-  public void testAtajInheritance_pr149305_2()     { runTest("ataj inheritance - 2");}
-  public void testAtajInheritance_pr149305_3()     { runTest("ataj inheritance - 3");}
-//  public void testVerificationFailureForAspectOf_pr148693() {
-//	runTest("verification problem");   // build the code
-//	Utils.verifyClass(ajc,"mypackage.MyAspect"); // verify it <<< BRAND NEW VERIFY UTILITY FOR EVERYONE TO TRY ;)
-//  }
-  public void testIncorrectAnnotationValue_pr148537()          { runTest("incorrect annotation value");}
-  public void testVerifyErrNoTypeCflowField_pr145693_1()       { runTest("verifyErrNoTypeCflowField"); }
-  public void testVerifyErrInpathNoTypeCflowField_pr145693_2() { runTest("verifyErrInpathNoTypeCflowField"); }
-  public void testCpathNoTypeCflowField_pr145693_3()           { runTest("cpathNoTypeCflowField"); }
-  // public void testAdviceNotWovenAspectPath_pr147841()          { runTest("advice not woven on aspectpath");}
-  public void testGenericSignatures_pr148409()                 { runTest("generic signature problem"); }
-  public void testCantFindType_pr149322_01() {runTest("can't find type on interface call 1");}
-  public void testCantFindType_pr149322_02() {runTest("can't find type on interface call 2");}
-  public void testCantFindType_pr149322_03() {runTest("can't find type on interface call 3");}
-  public void testParsingBytecodeLess_pr152871() { 
-	  Utility.testingParseCounter=0;
-	  runTest("parsing bytecode less"); 
-	  assertTrue("Should have called parse 2 times, not " + Utility.testingParseCounter + " times", Utility.testingParseCounter == 2);
-        // 5 means: // 3 of these are gone with change to UnwovenClassFileWTPMB to take a classname in ctor
-	  // (1)=registerAspect   
-	  // (2,3)=checkingIfShouldWeave,AcceptingResult for class
-	  // (4,5)=checkingIfShouldWeave,AcceptingResult for aspect
-  }
-  public void testMatchVolatileField_pr150671() {runTest("match volatile field");}
-  public void testDuplicateJVMTIAgents_pr151938() {runTest("Duplicate JVMTI agents");}
-  public void testLTWWorldWithAnnotationMatching_pr153572() { runTest("LTWWorld with annotation matching");}
-  
-  public void testReweavableAspectNotRegistered_pr129525 () {
-	  runTest("reweavableAspectNotRegistered error");
-  }
-  
-  public void testNPEinConstructorSignatureImpl_pr155972 () {
-	  runTest("NPE in ConstructorSignatureImpl");
-  }
-  
-  public void testNPEinFieldSignatureImpl_pr155972 () {
-	  runTest("NPE in FieldSignatureImpl");
-  } 
-  
-  public void testNPEinInitializerSignatureImpl_pr155972 () {
-	  runTest("NPE in InitializerSignatureImpl");
-  }
-  
-  public void testLineNumberTableCorrectWithGenericsForEachAndContinue_pr155763() {
-	  runTest("ensure LineNumberTable correct with generics, for each and continue");
-  }
-  
-  public void testDeclareSoftDoesntAllowUndeclaredExInAnonInnerClass_pr151772() {
-	  runTest("ensure declare soft doesn't allow undeclared exception in anonymous inner class");
-  }
-
-  public void testDeclareSoftDoesntAllowUndeclaredExInAnonInnerClass_pr151772_2() {
-	  runTest("ensure declare soft doesn't allow undeclared exception in anonymous inner class - 2");
-  }
-
-  public void testDeclareSoftAndInnerClasses_pr125981() {
-	  runTest("declare soft and inner classes");
-  }
-  
-  public void testGetSourceSignature_pr148908() {
-	runTest("ensure getSourceSignature correct with static field");
-	IHierarchy top = AsmManager.getDefault().getHierarchy();
-	IProgramElement ipe = top.findElementForLabel(top.getRoot(),
-	IProgramElement.Kind.FIELD,"MY_COMPARATOR");
-	String expected = "static final Comparator MY_COMPARATOR;\n";
-			assertEquals("expected source signature to be " + expected + 
-					" but found " + ipe.getSourceSignature(), 
-					expected, ipe.getSourceSignature());
-     
-	ipe = top.findElementForLabel(top.getRoot(),
-	IProgramElement.Kind.FIELD,"aList");
-	expected = "public List<String> aList;\n";
-			assertEquals("expected source signature to be " + expected + 
-					" but found " + ipe.getSourceSignature(), 
-					expected, ipe.getSourceSignature());
-
-	ipe = top.findElementForLabel(top.getRoot(),
-	IProgramElement.Kind.FIELD,"bList");
-	expected = "public List<String> bList;\n";
-			assertEquals("expected source signature to be " + expected + 
-					" but found " + ipe.getSourceSignature(), 
-					expected, ipe.getSourceSignature());
-  }
-
-//  public void testNPEWithCustomAgent_pr158205() {
-//	  runTest("NPE with custom agent");
-//  }
-
-  public void testWeaveConcreteSubaspectWithAdvice_pr132080() {
-	  runTest("Weave concrete sub-aspect with advice");
-  }
-
-  public void testWeaveConcreteSubaspectWithITD_pr132080() {
-	  runTest("Weave concrete sub-aspect with ITD");
-  }
-
-  public void testWeaveConcreteSubaspectWithAroundClosure_pr132080() {
-	  runTest("Weave concrete sub-aspect with around closure");
-  }
-
-  public void testWeaveConcreteSubaspectWithCflow_pr132080() {
-	  runTest("Weave concrete sub-aspect with cflow");
-  }
-
-  public void testNPEWithLTWPointcutLibraryAndMissingAspectDependency_pr158957 () {
-	  runTest("NPE with LTW, pointcut library and missing aspect dependency");
-  }
-  
-  public void testNoInvalidAbsoluteTypeNameWarning_pr156904_1() {runTest("ensure no invalidAbsoluteTypeName when do match - 1");}
-  public void testNoInvalidAbsoluteTypeNameWarning_pr156904_2() {runTest("ensure no invalidAbsoluteTypeName when do match - 2");}
-  public void testNoInvalidAbsoluteTypeNameWarning_pr156904_3() {runTest("ensure no invalidAbsoluteTypeName when do match - 3");}
-  public void testNoInvalidAbsoluteTypeNameWarning_pr156904_4() {runTest("ensure no invalidAbsoluteTypeName when do match - 4");}
-
-  public void testNoNPEWithThrownExceptionWarningAndAtAspectj_pr161217() {runTest("NPE with thrown exception warning and at aspectj");}
-  
-  public void testJavadocCommentsAreSetIfHaveNormalComments_pr164340() {
-	  runTest("javadoc comments are set if have normal comments");
-	  IHierarchy top = AsmManager.getDefault().getHierarchy();
-	  
-	  IProgramElement ipe = top.findElementForLabel(top.getRoot(),
-			  IProgramElement.Kind.METHOD,"foo()");
-	  assertNotNull("expected formal comment to be non null but" +
-	  		" found that it was null",ipe.getFormalComment());
-	  
-	  ipe = top.findElementForLabel(top.getRoot(),
-			  IProgramElement.Kind.METHOD,"bar()");
-	  assertNotNull("expected formal comment to be non null but" +
-	  		" found that it was null",ipe.getFormalComment());
-	  
-	  ipe = top.findElementForLabel(top.getRoot(),
-			  IProgramElement.Kind.METHOD,"goo()");
-	  assertNull("expected formal comment to be null but" +
-	  		" found that it was " + ipe.getFormalComment(),ipe.getFormalComment());
-
-  }
-  
-  public void testBinaryWeavingIntoJava6Library_pr164384() {runTest("binary weaving into java 6 library");}
-  public void testCompilanceJava6ThrowsUsageError_pr164384() {runTest("compliance java 6 throws usage error");}
-  public void testSourceLevelJava6ThrowsUsageError_pr164384() {runTest("source level java 6 throws usage error");}
-  public void testTargetLevelJava6ThrowsUsageError_pr164384() {runTest("target level java 6 throws usage error");}
-  
-  public void testStaticImport() {
+	// public void testGenericsProblem_pr151978() { runTest("generics problem");}
+	// public void testArgnamesAndJavac_pr148381() { runTest("argNames and javac");}
+	// public void testCFlowXMLAspectLTW_pr149096() { runTest("cflow xml concrete aspect"); }
+	// public void testAmbiguousBinding_pr121805() { runTest("ambiguous binding");}
+	// public void testNegatedAnnotationMatchingProblem_pr153464() { runTest("negated annotation matching problem");}
+	// public void testAnnotationStyleBcException_pr162135() { runTest("bcexception in annotation style around advice");}
+	// public void testAnnotationStyleBcException_pr162135_2() { runTest("bcexception in annotation style around advice - 2");}
+	// public void testAnnotationStyleBcException_pr162135_3() { runTest("bcexception in annotation style around advice - 3");}
+	// public void testAnnotationStyleBcException_pr162135_4() { runTest("bcexception in annotation style around advice - 4");}
+	// public void testAnnotationStyleBcException_pr162135_5() { runTest("bcexception in annotation style around advice - 5");}
+	public void testIncompatibleClassChangeWithITD_pr164633() {
+		runTest("incompatibleclasschange");
+	}
+
+	public void testComplexPointcut_pr162657() {
+		runTest("complex pointcut");
+	}
+
+	public void testGenericsInPointcuts_pr161502() {
+		runTest("generics in pointcuts");
+	}
+
+	public void testGenericsInPointcuts_pr161502_2() {
+		runTest("generics in pointcuts - 2");
+	}
+
+	public void testNoNPEDueToMissingType_pr149908() {
+		runTest("ensure no npe due to missing type");
+	}
+
+	public void testNoNPEDueToMember_pr149908() {
+		runTest("ensure no npe due to missing member");
+	}
+
+	public void testPTWgetWithinTypeName_pr123423_1() {
+		runTest("basic usage of getWithinTypeName");
+	}
+
+	public void testPTWgetWithinTypeName_pr123423_2() {
+		runTest("basic usage of getWithinTypeName - multiple types");
+	}
+
+	public void testPTWgetWithinTypeName_pr123423_3() {
+		runTest("basic usage of getWithinTypeName - non matching types");
+	}
+
+	public void testPTWgetWithinTypeName_pr123423_4() {
+		runTest("basic usage of getWithinTypeName - types in packages");
+	}
+
+	public void testPTWgetWithinTypeName_pr123423_5() {
+		runTest("basic usage of getWithinTypeName - annotation style");
+	}
+
+	public void testTurningOffBcelCaching_pr160674() {
+		runTest("turning off bcel caching");
+	}
+
+	public void testNoIllegalStateExceptionWithGenericInnerAspect_pr156058() {
+		runTest("no IllegalStateException with generic inner aspect");
+	}
+
+	public void testNoIllegalStateExceptionWithGenericInnerAspect_pr156058_2() {
+		runTest("no IllegalStateException with generic inner aspect - 2");
+	}
+
+	public void testDeclareMethodAnnotations_pr159143() {
+		runTest("declare method annotations");
+	}
+
+	public void testVisibilityProblem_pr149071() {
+		runTest("visibility problem");
+	}
+
+	public void testMissingLineNumbersInStacktraceAfter_pr145442() {
+		runTest("missing line numbers in stacktrace after");
+	}
+
+	public void testMissingLineNumbersInStacktraceAround_pr145442() {
+		runTest("missing line numbers in stacktrace around");
+	}
+
+	public void testGenericArrays_pr158624() {
+		runTest("generics and arrays");
+	}
+
+	public void testMissingLineNumbersInStacktraceBefore_pr145442() {
+		runTest("missing line numbers in stacktrace before");
+	}
+
+	public void testMissingLineNumbersInStacktraceBefore_pr145442_Binary() {
+		runTest("missing line numbers in stacktrace before - binary");
+	}
+
+	public void testAnnotationStylePointcutNPE_pr158412() {
+		runTest("annotation style pointcut npe");
+	}
+
+	public void testAnnotationStylePointcutNPE_pr158412_2() {
+		runTest("annotation style pointcut npe - 2");
+	}
+
+	public void testAnnotationsCallConstructors_pr158126() {
+		runTest("annotations, call and constructors problem");
+	}
+
+	public void testIllegalStateExceptionGenerics_pr153845() {
+		runTest("IllegalStateException at GenericSignatureParser.java");
+	}
+
+	public void testNoIllegalStateExceptionFromAsmDelegate_pr153490_1() {
+		runTest("no illegal state exception from AsmDelegate - 1");
+	}
+
+	public void testNoIllegalStateExceptionFromAsmDelegate_pr153490_2() {
+		runTest("no illegal state exception from AsmDelegate - 2");
+	}
+
+	public void testNoIllegalStateExceptionFromAsmDelegate_pr153490_3() {
+		runTest("no illegal state exception from AsmDelegate - 3");
+	}
+
+	public void testAnnotMethod_pr156962() {
+		runTest("Test Annot Method");
+	}
+
+	public void testAnnotMethodHasMember_pr156962() {
+		runTest("Test Annot Method Has Member");
+	}
+
+	public void testMixingGenerics_pr152848() {
+		runTest("mixing generics");
+	}
+
+	public void testIncorrectStaticinitializationWeaving_pr149560_1() {
+		runTest("incorrect staticinitialization weaving - codestyle");
+	}
+
+	public void testIncorrectStaticinitializationWeaving_pr149560_2() {
+		runTest("incorrect staticinitialization weaving - annstyle");
+	}
+
+	public void testIncorrectDeprecatedAnnotationProcessing_pr154332() {
+		runTest("incorrect deprecated annotation processing");
+	}
+
+	public void testPipeliningProblemWithAnnotationsDecp_pr153380_1() {
+		runTest("pipelining decps");
+	}
+
+	public void testUnwantedPointcutWarning_pr148219() {
+		runTest("unwanted warning for pointcut");
+	}
+
+	public void testDecpAndCflowadderMungerClash_pr152631() {
+		runTest("decp and cflowadder munger clash");
+	}
+
+	public void testGenericInheritanceDecp_pr150095() {
+		runTest("generics, inheritance and decp");
+	}
+
+	public void testIllegalStateException_pr148737() {
+		runTest("illegalstateexception for non generic type");
+	}
+
+	public void testAtajInheritance_pr149305_1() {
+		runTest("ataj inheritance - 1");
+	}
+
+	public void testAtajInheritance_pr149305_2() {
+		runTest("ataj inheritance - 2");
+	}
+
+	public void testAtajInheritance_pr149305_3() {
+		runTest("ataj inheritance - 3");
+	}
+
+	// public void testVerificationFailureForAspectOf_pr148693() {
+	// runTest("verification problem"); // build the code
+	// Utils.verifyClass(ajc,"mypackage.MyAspect"); // verify it <<< BRAND NEW VERIFY UTILITY FOR EVERYONE TO TRY ;)
+	// }
+	public void testIncorrectAnnotationValue_pr148537() {
+		runTest("incorrect annotation value");
+	}
+
+	public void testVerifyErrNoTypeCflowField_pr145693_1() {
+		runTest("verifyErrNoTypeCflowField");
+	}
+
+	public void testVerifyErrInpathNoTypeCflowField_pr145693_2() {
+		runTest("verifyErrInpathNoTypeCflowField");
+	}
+
+	public void testCpathNoTypeCflowField_pr145693_3() {
+		runTest("cpathNoTypeCflowField");
+	}
+
+	// public void testAdviceNotWovenAspectPath_pr147841() { runTest("advice not woven on aspectpath");}
+	public void testGenericSignatures_pr148409() {
+		runTest("generic signature problem");
+	}
+
+	public void testCantFindType_pr149322_01() {
+		runTest("can't find type on interface call 1");
+	}
+
+	public void testCantFindType_pr149322_02() {
+		runTest("can't find type on interface call 2");
+	}
+
+	public void testCantFindType_pr149322_03() {
+		runTest("can't find type on interface call 3");
+	}
+
+	public void testParsingBytecodeLess_pr152871() {
+		Utility.testingParseCounter = 0;
+		runTest("parsing bytecode less");
+		assertTrue("Should have called parse 2 times, not " + Utility.testingParseCounter + " times",
+				Utility.testingParseCounter == 2);
+		// 5 means: // 3 of these are gone with change to UnwovenClassFileWTPMB to take a classname in ctor
+		// (1)=registerAspect
+		// (2,3)=checkingIfShouldWeave,AcceptingResult for class
+		// (4,5)=checkingIfShouldWeave,AcceptingResult for aspect
+	}
+
+	public void testMatchVolatileField_pr150671() {
+		runTest("match volatile field");
+	}
+
+	public void testDuplicateJVMTIAgents_pr151938() {
+		runTest("Duplicate JVMTI agents");
+	}
+
+	public void testLTWWorldWithAnnotationMatching_pr153572() {
+		runTest("LTWWorld with annotation matching");
+	}
+
+	public void testReweavableAspectNotRegistered_pr129525() {
+		runTest("reweavableAspectNotRegistered error");
+	}
+
+	public void testNPEinConstructorSignatureImpl_pr155972() {
+		runTest("NPE in ConstructorSignatureImpl");
+	}
+
+	public void testNPEinFieldSignatureImpl_pr155972() {
+		runTest("NPE in FieldSignatureImpl");
+	}
+
+	public void testNPEinInitializerSignatureImpl_pr155972() {
+		runTest("NPE in InitializerSignatureImpl");
+	}
+
+	public void testLineNumberTableCorrectWithGenericsForEachAndContinue_pr155763() {
+		runTest("ensure LineNumberTable correct with generics, for each and continue");
+	}
+
+	public void testDeclareSoftDoesntAllowUndeclaredExInAnonInnerClass_pr151772() {
+		runTest("ensure declare soft doesn't allow undeclared exception in anonymous inner class");
+	}
+
+	public void testDeclareSoftDoesntAllowUndeclaredExInAnonInnerClass_pr151772_2() {
+		runTest("ensure declare soft doesn't allow undeclared exception in anonymous inner class - 2");
+	}
+
+	public void testDeclareSoftAndInnerClasses_pr125981() {
+		runTest("declare soft and inner classes");
+	}
+
+	public void testGetSourceSignature_pr148908() {
+		runTest("ensure getSourceSignature correct with static field");
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
+		IProgramElement ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.FIELD, "MY_COMPARATOR");
+		String expected = "static final Comparator MY_COMPARATOR;\n";
+		assertEquals("expected source signature to be " + expected + " but found " + ipe.getSourceSignature(), expected, ipe
+				.getSourceSignature());
+
+		ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.FIELD, "aList");
+		expected = "public List<String> aList;\n";
+		assertEquals("expected source signature to be " + expected + " but found " + ipe.getSourceSignature(), expected, ipe
+				.getSourceSignature());
+
+		ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.FIELD, "bList");
+		expected = "public List<String> bList;\n";
+		assertEquals("expected source signature to be " + expected + " but found " + ipe.getSourceSignature(), expected, ipe
+				.getSourceSignature());
+	}
+
+	// public void testNPEWithCustomAgent_pr158205() {
+	// runTest("NPE with custom agent");
+	// }
+
+	public void testWeaveConcreteSubaspectWithAdvice_pr132080() {
+		runTest("Weave concrete sub-aspect with advice");
+	}
+
+	public void testWeaveConcreteSubaspectWithITD_pr132080() {
+		runTest("Weave concrete sub-aspect with ITD");
+	}
+
+	public void testWeaveConcreteSubaspectWithAroundClosure_pr132080() {
+		runTest("Weave concrete sub-aspect with around closure");
+	}
+
+	public void testWeaveConcreteSubaspectWithCflow_pr132080() {
+		runTest("Weave concrete sub-aspect with cflow");
+	}
+
+	public void testNPEWithLTWPointcutLibraryAndMissingAspectDependency_pr158957() {
+		runTest("NPE with LTW, pointcut library and missing aspect dependency");
+	}
+
+	public void testNoInvalidAbsoluteTypeNameWarning_pr156904_1() {
+		runTest("ensure no invalidAbsoluteTypeName when do match - 1");
+	}
+
+	public void testNoInvalidAbsoluteTypeNameWarning_pr156904_2() {
+		runTest("ensure no invalidAbsoluteTypeName when do match - 2");
+	}
+
+	public void testNoInvalidAbsoluteTypeNameWarning_pr156904_3() {
+		runTest("ensure no invalidAbsoluteTypeName when do match - 3");
+	}
+
+	public void testNoInvalidAbsoluteTypeNameWarning_pr156904_4() {
+		runTest("ensure no invalidAbsoluteTypeName when do match - 4");
+	}
+
+	public void testNoNPEWithThrownExceptionWarningAndAtAspectj_pr161217() {
+		runTest("NPE with thrown exception warning and at aspectj");
+	}
+
+	public void testJavadocCommentsAreSetIfHaveNormalComments_pr164340() {
+		runTest("javadoc comments are set if have normal comments");
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
+
+		IProgramElement ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.METHOD, "foo()");
+		assertNotNull("expected formal comment to be non null but" + " found that it was null", ipe.getFormalComment());
+
+		ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.METHOD, "bar()");
+		assertNotNull("expected formal comment to be non null but" + " found that it was null", ipe.getFormalComment());
+
+		ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.METHOD, "goo()");
+		assertNull("expected formal comment to be null but" + " found that it was " + ipe.getFormalComment(), ipe
+				.getFormalComment());
+
+	}
+
+	public void testBinaryWeavingIntoJava6Library_pr164384() {
+		runTest("binary weaving into java 6 library");
+	}
+
+	public void testCompilanceJava6ThrowsUsageError_pr164384() {
+		runTest("compliance java 6 throws usage error");
+	}
+
+	public void testSourceLevelJava6ThrowsUsageError_pr164384() {
+		runTest("source level java 6 throws usage error");
+	}
+
+	public void testTargetLevelJava6ThrowsUsageError_pr164384() {
+		runTest("target level java 6 throws usage error");
+	}
+
+	public void testStaticImport() {
 		runTest("ensure static import reference have static modifier set");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
-		
-		IProgramElement ipe = top.findElementForLabel(top.getRoot(),		
-		IProgramElement.Kind.IMPORT_REFERENCE,"ABC.StaticImport.Alphabet.A");
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
+
+		IProgramElement ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.IMPORT_REFERENCE,
+				"ABC.StaticImport.Alphabet.A");
 		String expected = "import static ABC.StaticImport.Alphabet.A;";
-			assertEquals("expected source signature to be " + expected + 
-					" but found " + ipe.getSourceSignature(), 
-					expected, ipe.getSourceSignature());
-  }
-  public void testAspected_Annotation(){
-	  runTest("ensure Annotations are added to import list");
-	  IHierarchy top = AsmManager.getDefault().getHierarchy();
-		
-	  IProgramElement ipe = top.findElementForLabel(top.getRoot(),		
-	  IProgramElement.Kind.IMPORT_REFERENCE,"annotation.A");
-	  String expected = "import annotation.A;";
-			assertEquals("expected source signature to be " + expected + 
-					" but found " + ipe.getSourceSignature(), 
-					expected, ipe.getSourceSignature());
-				
-  }
-
-  public void testGetSourceSignature_GenericMethods(){
-	  runTest("ensure getSourceSignature correct with generic method");
-	  IHierarchy top = AsmManager.getDefault().getHierarchy();
-		
-	  IProgramElement ipe = top.findElementForLabel(top.getRoot(),		
-	  IProgramElement.Kind.METHOD,"returnT(T)");
-	  String expected = "public <T> T returnT(T a)";
-			assertEquals("expected source signature to be " + expected + 
-					" but found " + ipe.getSourceSignature(), 
-					expected, ipe.getSourceSignature());
-				
-	  ipe = top.findElementForLabel(top.getRoot(),
-	  IProgramElement.Kind.METHOD,"returnQ(Q)");
-	  expected = "public <Q extends List> Q returnQ(Q a)";
-		assertEquals("expected source signature to be " + expected + 
-				" but found " + ipe.getSourceSignature(), 
-				expected, ipe.getSourceSignature());
-				
-	  ipe = top.findElementForLabel(top.getRoot(),
-	  IProgramElement.Kind.METHOD,"doubleGeneric(Q,T)");
-	  expected = "public <T, Q> void doubleGeneric(Q a, T b)";
-		assertEquals("expected source signature to be " + expected + 
-				" but found " + ipe.getSourceSignature(), 
-				expected, ipe.getSourceSignature());
-		
+		assertEquals("expected source signature to be " + expected + " but found " + ipe.getSourceSignature(), expected, ipe
+				.getSourceSignature());
+	}
+
+	public void testAspected_Annotation() {
+		runTest("ensure Annotations are added to import list");
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
+
+		IProgramElement ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.IMPORT_REFERENCE, "annotation.A");
+		String expected = "import annotation.A;";
+		assertEquals("expected source signature to be " + expected + " but found " + ipe.getSourceSignature(), expected, ipe
+				.getSourceSignature());
+
+	}
+
+	public void testGetSourceSignature_GenericMethods() {
+		runTest("ensure getSourceSignature correct with generic method");
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
+
+		IProgramElement ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.METHOD, "returnT(T)");
+		String expected = "public <T> T returnT(T a)";
+		assertEquals("expected source signature to be " + expected + " but found " + ipe.getSourceSignature(), expected, ipe
+				.getSourceSignature());
+
+		ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.METHOD, "returnQ(Q)");
+		expected = "public <Q extends List> Q returnQ(Q a)";
+		assertEquals("expected source signature to be " + expected + " but found " + ipe.getSourceSignature(), expected, ipe
+				.getSourceSignature());
+
+		ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.METHOD, "doubleGeneric(Q,T)");
+		expected = "public <T, Q> void doubleGeneric(Q a, T b)";
+		assertEquals("expected source signature to be " + expected + " but found " + ipe.getSourceSignature(), expected, ipe
+				.getSourceSignature());
+
 		// Generic Method Constructor
-	  	ipe = top.findElementForLabel(top.getRoot(),
-	  		  IProgramElement.Kind.CONSTRUCTOR,"C(T)");
-	  		  expected = "public <T> C(T b)";
-	  			assertEquals("expected source signature to be " + expected + 
-	  					" but found " + ipe.getSourceSignature(), 
-	  					expected, ipe.getSourceSignature());
-  }
-
-  
-  /////////////////////////////////////////
-  public static Test suite() {
-    return XMLBasedAjcTestCase.loadSuite(Ajc153Tests.class);
-  }
-
-  protected File getSpecFile() {
-    return new File("../tests/src/org/aspectj/systemtest/ajc153/ajc153.xml");
-  }
-
-  
+		ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.CONSTRUCTOR, "C(T)");
+		expected = "public <T> C(T b)";
+		assertEquals("expected source signature to be " + expected + " but found " + ipe.getSourceSignature(), expected, ipe
+				.getSourceSignature());
+	}
+
+	// ///////////////////////////////////////
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(Ajc153Tests.class);
+	}
+
+	protected File getSpecFile() {
+		return new File("../tests/src/org/aspectj/systemtest/ajc153/ajc153.xml");
+	}
+
 }
\ No newline at end of file
@@ -18,25 +18,23 @@ import java.util.List;
 import junit.framework.Test;
 
 import org.aspectj.asm.AsmManager;
-import org.aspectj.asm.IElementHandleProvider;
 import org.aspectj.asm.IHierarchy;
 import org.aspectj.asm.IProgramElement;
-import org.aspectj.asm.internal.JDTLikeHandleProvider;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 
-	IElementHandleProvider handleProvider;
+	// IElementHandleProvider handleProvider;
 
 	protected void setUp() throws Exception {
 		super.setUp();
-		handleProvider = AsmManager.getDefault().getHandleProvider();
-		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+		// handleProvider = AsmManager.getDefault().getHandleProvider();
+		// AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
 	}
 
 	protected void tearDown() throws Exception {
 		super.tearDown();
-		AsmManager.getDefault().setHandleProvider(handleProvider);
+		// AsmManager.getDefault().setHandleProvider(handleProvider);
 	}
 
 	public void testMoreThanOneNamedPointcut() {
@@ -45,7 +43,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 
 	public void testAspectHandle() {
 		runTest("aspect handle");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		IProgramElement pe = top.findElementForType("pkg", "A1");
 		String expected = "<pkg*A1.aj}A1";
 		String found = pe.getHandleIdentifier();
@@ -64,7 +62,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 
 	public void testGetIPEWithAspectHandle() {
 		runTest("get IProgramElement with aspect handle");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		String handle = "<pkg*A1.aj}A1";
 		IProgramElement ipe = top.getElement(handle);
 		assertNotNull("should have found ipe with handle " + handle, ipe);
@@ -155,7 +153,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 	// signature and the same pointcut
 	public void testTwoPiecesOfAdviceWithSameSignatureAndPointcut() {
 		runTest("two pieces of advice with the same signature and pointcut");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		IProgramElement parent = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.ASPECT, "A5");
 		List children = parent.getChildren();
 		String handle1 = null;
@@ -208,7 +206,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 	// on the end
 	public void testIPEsWithSameNameHaveUniqueHandles_methodCall() {
 		runTest("ipes with same name have unique handles - method-call");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		String handle1 = "<*TwoMethodCalls.aj[Main~main~\\[QString;?method-call("
 				+ "void java.io.PrintStream.println(java.lang.String))";
 		assertNotNull("expected to find node with handle " + handle1 + ", but did not", top.getElement(handle1));
@@ -226,7 +224,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 	// shouldn't have the "2"
 	public void testIPEsWithDiffNamesDontHaveCounter_methodCall() {
 		runTest("ipes with different names do not have counter - method-call");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		String handle1 = "<*TwoDiffMethodCalls.aj[Main~main~\\[QString;?method-call("
 				+ "void java.io.PrintStream.println(java.lang.String))";
 		assertNotNull("expected to find node with handle " + handle1 + ", but did not", top.getElement(handle1));
@@ -238,7 +236,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 
 	public void testIPEsWithSameNameHaveUniqueHandles_handler() {
 		runTest("ipes with same name have unique handles - handler");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		String handle1 = "<*Handler.aj[C~method?exception-handler(void C." + "<catch>(java.io.FileNotFoundException))";
 		assertNotNull("expected to find node with handle " + handle1 + ", but did not", top.getElement(handle1));
 
@@ -248,7 +246,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 
 	public void testIPEsWithSameNameHaveUniqueHandles_get() {
 		runTest("ipes with same name have unique handles - get");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		String handle1 = "<*Get.aj[C1~method1?field-get(int C1.x)";
 		assertNotNull("expected to find node with handle " + handle1 + ", but did not", top.getElement(handle1));
 
@@ -258,7 +256,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 
 	public void testIPEsWithSameNameHaveUniqueHandles_set() {
 		runTest("ipes with same name have unique handles - set");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		String handle1 = "<*Set.aj[C1~method?field-set(int C1.x)";
 		assertNotNull("expected to find node with handle " + handle1 + ", but did not", top.getElement(handle1));
 
@@ -268,13 +266,13 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 
 	public void testTwoPiecesOfBeforeAdviceInInjarAspectHaveUniqueHandles_pr159896() {
 		runTest("advice with same name in injar aspect should have unique handles");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		String handle1 = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.ADVICE, "before(): p..").getHandleIdentifier();
 		String handle2 = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.ADVICE, "before(): exec..")
 				.getHandleIdentifier();
 		assertFalse("expected the two advice nodes to have unique handles but" + " did not", handle1.equals(handle2));
 		try {
-			AsmManager.getDefault().dumptree(AsmManager.getDefault().getHierarchy().getRoot(), 0);
+			AsmManager.lastActiveStructureModel.dumptree(AsmManager.lastActiveStructureModel.getHierarchy().getRoot(), 0);
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
@@ -283,7 +281,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 
 	public void testTwoDeclareWarningsInInjarAspectHaveUniqueHandles_pr159896() {
 		runTest("declare warnings in injar aspect should have unique handles");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		String handle1 = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.DECLARE_WARNING, "declare warning: \"blah\"")
 				.getHandleIdentifier();
 		String handle2 = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.DECLARE_WARNING, "declare warning: \"blah2\"")
@@ -297,7 +295,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 	// their handle
 	public void testOnlyIncrementSameDeclareTypeFromInjar_pr159896() {
 		runTest("dont increment counter for different declares");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		String warning = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.DECLARE_WARNING,
 				"declare warning: \"warning\"").getHandleIdentifier();
 		assertTrue("shouldn't have incremented counter for declare warning handle " + "because only one declare warning statement",
@@ -387,7 +385,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 	public void testTypeSameAsJDT() {
 		// JDT: =TJP Example/src<tjp{Demo.java[Demo
 		runTest("type same as jdt");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		IProgramElement pe = top.findElementForType("tjp", "Demo");
 		String expected = "<tjp{Demo.java[Demo";
 		String found = pe.getHandleIdentifier();
@@ -404,7 +402,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 		// JDT: =TJP Example/src<tjp{Demo.java[Demo|1
 		// and =TJP Example/src<tjp{Demo.java[Demo|2
 		runTest("initialization same as jdt");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		IProgramElement parent = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.CLASS, "Demo");
 		List children = parent.getChildren();
 		String handle1 = null;
@@ -466,7 +464,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 	public void testEnumSameAsJDT() {
 		// JDT: =Java5 Handles/src<pkg{E.java[E
 		runTest("enum same as jdt");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		IProgramElement pe = top.findElementForType("pkg", "E");
 		String expected = "<pkg{E.java[E";
 		String found = pe.getHandleIdentifier();
@@ -482,7 +480,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 	public void testAnnotationSameAsJDT() {
 		// JDT: =Java5 Handles/src<pkg{MyAnnotation.java[MyAnnotation
 		runTest("annotation same as jdt");
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		IProgramElement pe = top.findElementForType("pkg", "MyAnnotation");
 		String expected = "<pkg{MyAnnotation.java[MyAnnotation";
 		String found = pe.getHandleIdentifier();
@@ -534,7 +532,7 @@ public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
 
 	// ----------- helper methods ---------------
 	private void compareHandles(IProgramElement.Kind kind, String ipeName, String expectedHandle) {
-		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IHierarchy top = AsmManager.lastActiveStructureModel.getHierarchy();
 		IProgramElement pe = top.findElementForLabel(top.getRoot(), kind, ipeName);
 		String found = pe.getHandleIdentifier();
 		System.err.println("expected: " + expectedHandle);
@@ -23,90 +23,205 @@ import org.aspectj.asm.IRelationshipMap;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc161Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
-	
-	// AspectJ1.6.1	
-	public void testSignatureProcessing_pr237447() { runTest("signature processing"); }
-	public void testGenericAtAround_pr237419() { runTest("generics ataround"); }
-	public void testGenericMarkerMatch_pr203367() { runTest("generic marker match"); }
-//	public void testSuperItds_pr134425() { runTest("super itds"); }
-	public void testSuperItds_pr198196_1() { runTest("super itds - 2"); }
-	public void testSuperItds_pr198196_2() { runTest("super itds - 3"); }
-	public void testSuperItds_pr198196_3() { runTest("super itds - 4"); }
-	public void testDeow_pr237381_1() { runTest("ataspectj deow - 1"); }
-	public void testDeow_pr237381_2() { runTest("ataspectj deow - 2"); }
-	public void testRunningBrokenCode_pr102733_2() { runTest("running broken code - 2"); }
-	public void testRunningBrokenCode_pr102733() { runTest("running broken code"); }
-	public void testErrorOnNonabstractGenericAtAspectJAspect_pr168982() { runTest("error on non-abstract generic ataspectj aspect");}
-	public void testIgnoringTypeLevelSuppression_pr234933() { runTest("ignoring type level suppress");}
-	public void testDuplicateMethodSignature_pr223226_2() { runTest("duplicate method signature - 2"); }
-	public void testDuplicateMethodSignature_pr223226() { runTest("duplicate method signature"); }
-	public void testProtectedMethodsAroundAdvice_pr197719_2() { runTest("protected methods and around advice - again - 2");}
-	public void testProtectedMethodsAroundAdvice_pr197719() { runTest("protected methods and around advice - again");}
-	public void testProtectedMethodsAroundAdvice_pr230075() { runTest("protected methods and around advice");}
-	public void testFinalStringsAnnotationPointcut_pr174385() { runTest("static strings in annotation pointcuts");}
-	public void testComplexBoundsGenericAspect_pr199130_1() { runTest("complex bounds on generic aspect - 1");}
-	public void testComplexBoundsGenericAspect_pr199130_2() { runTest("complex bounds on generic aspect - 2");}
-	public void testComplexBoundsGenericAspect_pr199130_3() { runTest("complex bounds on generic aspect - 3");}
-	public void testPrivilegedGenericAspect_pr235505() { runTest("privileged generic aspect");}
-	public void testPrivilegedGenericAspect_pr235505_2() { runTest("privileged generic aspect - 2");}
-	public void testParsingAroundNoReturn_pr64222() { runTest("parsing around advice no return");}
-	public void testParsingBeforeArrayRef_pr159268() { runTest("before array name");}
-	public void testGenericAspectAroundAdvice_pr226201() { runTest("generic aspect around advice");}
-	public void testCrazyGenericsInnerTypes_pr235829() { runTest("crazy generics and inner types");}
-	public void testAnnotationExposureGenerics_pr235597() { runTest("annotation exposure and generics");}
-    public void testIncorrectRelationship_pr235204() {
-        runTest("incorrect call relationship");
-        IRelationshipMap irm = AsmManager.getDefault().getRelationshipMap();
-        Set entries = irm.getEntries();
-        boolean gotSomethingValid = false;
-        String expected = "<recursivepackage{RecursiveCatcher.java}RecursiveCatcher~recursiveCall~I?method-call(void recursivepackage.RecursiveCatcher.recursiveCall(int))";
-        for (Iterator iterator = entries.iterator(); iterator.hasNext();) {
-            String str = (String) iterator.next();
-            if (str.indexOf(expected)!=-1) gotSomethingValid = true;
-        }
-        if (!gotSomethingValid) {
-        	fail("Did not find a relationship with the expected data in '"+expected+"'");
-        }
-    }
-
-//	public void testLVTableAround_pr173978() throws Exception { 
-//		runTest("lv table for around");
-//		JavaClass jc = Utils.getClassFrom(ajc.getSandboxDirectory().getAbsolutePath(),"Test");
-//		Method[] ms = jc.getMethods();
-//		Method m = null;
-//		for (int i = 0; i < ms.length; i++) {
-//			if (ms[i].getName().equals("sayHello")) {
-//				m = ms[i];
-//			}
-//		}
-//		if (m.getLocalVariableTable()==null) fail("Local variable table should not be null");
-//		print(m.getLocalVariableTable());
-//	}
-
-    private void print(LocalVariableTable localVariableTable) {
-    	LocalVariable[] lvs = localVariableTable.getLocalVariableTable();
-    	for (int i = 0; i < lvs.length; i++) {
+
+	// AspectJ1.6.1
+	public void testSignatureProcessing_pr237447() {
+		runTest("signature processing");
+	}
+
+	public void testGenericAtAround_pr237419() {
+		runTest("generics ataround");
+	}
+
+	public void testGenericMarkerMatch_pr203367() {
+		runTest("generic marker match");
+	}
+
+	// public void testSuperItds_pr134425() { runTest("super itds"); }
+	public void testSuperItds_pr198196_1() {
+		runTest("super itds - 2");
+	}
+
+	public void testSuperItds_pr198196_2() {
+		runTest("super itds - 3");
+	}
+
+	public void testSuperItds_pr198196_3() {
+		runTest("super itds - 4");
+	}
+
+	public void testDeow_pr237381_1() {
+		runTest("ataspectj deow - 1");
+	}
+
+	public void testDeow_pr237381_2() {
+		runTest("ataspectj deow - 2");
+	}
+
+	public void testRunningBrokenCode_pr102733_2() {
+		runTest("running broken code - 2");
+	}
+
+	public void testRunningBrokenCode_pr102733() {
+		runTest("running broken code");
+	}
+
+	public void testErrorOnNonabstractGenericAtAspectJAspect_pr168982() {
+		runTest("error on non-abstract generic ataspectj aspect");
+	}
+
+	public void testIgnoringTypeLevelSuppression_pr234933() {
+		runTest("ignoring type level suppress");
+	}
+
+	public void testDuplicateMethodSignature_pr223226_2() {
+		runTest("duplicate method signature - 2");
+	}
+
+	public void testDuplicateMethodSignature_pr223226() {
+		runTest("duplicate method signature");
+	}
+
+	public void testProtectedMethodsAroundAdvice_pr197719_2() {
+		runTest("protected methods and around advice - again - 2");
+	}
+
+	public void testProtectedMethodsAroundAdvice_pr197719() {
+		runTest("protected methods and around advice - again");
+	}
+
+	public void testProtectedMethodsAroundAdvice_pr230075() {
+		runTest("protected methods and around advice");
+	}
+
+	public void testFinalStringsAnnotationPointcut_pr174385() {
+		runTest("static strings in annotation pointcuts");
+	}
+
+	public void testComplexBoundsGenericAspect_pr199130_1() {
+		runTest("complex bounds on generic aspect - 1");
+	}
+
+	public void testComplexBoundsGenericAspect_pr199130_2() {
+		runTest("complex bounds on generic aspect - 2");
+	}
+
+	public void testComplexBoundsGenericAspect_pr199130_3() {
+		runTest("complex bounds on generic aspect - 3");
+	}
+
+	public void testPrivilegedGenericAspect_pr235505() {
+		runTest("privileged generic aspect");
+	}
+
+	public void testPrivilegedGenericAspect_pr235505_2() {
+		runTest("privileged generic aspect - 2");
+	}
+
+	public void testParsingAroundNoReturn_pr64222() {
+		runTest("parsing around advice no return");
+	}
+
+	public void testParsingBeforeArrayRef_pr159268() {
+		runTest("before array name");
+	}
+
+	public void testGenericAspectAroundAdvice_pr226201() {
+		runTest("generic aspect around advice");
+	}
+
+	public void testCrazyGenericsInnerTypes_pr235829() {
+		runTest("crazy generics and inner types");
+	}
+
+	public void testAnnotationExposureGenerics_pr235597() {
+		runTest("annotation exposure and generics");
+	}
+
+	public void testIncorrectRelationship_pr235204() {
+		runTest("incorrect call relationship");
+		IRelationshipMap irm = AsmManager.lastActiveStructureModel.getRelationshipMap();
+		Set entries = irm.getEntries();
+		boolean gotSomethingValid = false;
+		String expected = "<recursivepackage{RecursiveCatcher.java}RecursiveCatcher~recursiveCall~I?method-call(void recursivepackage.RecursiveCatcher.recursiveCall(int))";
+		for (Iterator iterator = entries.iterator(); iterator.hasNext();) {
+			String str = (String) iterator.next();
+			if (str.indexOf(expected) != -1)
+				gotSomethingValid = true;
+		}
+		if (!gotSomethingValid) {
+			fail("Did not find a relationship with the expected data in '" + expected + "'");
+		}
+	}
+
+	// public void testLVTableAround_pr173978() throws Exception {
+	// runTest("lv table for around");
+	// JavaClass jc = Utils.getClassFrom(ajc.getSandboxDirectory().getAbsolutePath(),"Test");
+	// Method[] ms = jc.getMethods();
+	// Method m = null;
+	// for (int i = 0; i < ms.length; i++) {
+	// if (ms[i].getName().equals("sayHello")) {
+	// m = ms[i];
+	// }
+	// }
+	// if (m.getLocalVariableTable()==null) fail("Local variable table should not be null");
+	// print(m.getLocalVariableTable());
+	// }
+
+	private void print(LocalVariableTable localVariableTable) {
+		LocalVariable[] lvs = localVariableTable.getLocalVariableTable();
+		for (int i = 0; i < lvs.length; i++) {
 			LocalVariable localVariable = lvs[i];
 			System.out.println(localVariable);
 		}
 	}
-	public void testITDPrecedence_pr233838_1() { runTest("itd precedence - 1"); }
-	public void testITDPrecedence_pr233838_2() { runTest("itd precedence - 2"); }
-	public void testGetFieldGenerics_pr227401() { runTest("getfield problem with generics");}
-	public void testGenericAbstractAspects_pr231478() { runTest("generic abstract aspects"); }
-    public void testFieldJoinpointsAndAnnotationValues_pr227993() { runTest("field jp anno value"); }
-    public void testGenericsBoundsDecp_pr231187() { runTest("generics bounds decp"); }
-    public void testGenericsBoundsDecp_pr231187_2() { runTest("generics bounds decp - 2"); }
-	public void testLtwInheritedCflow_pr230134() { runTest("ltw inherited cflow"); }
-    public void testAroundAdviceOnFieldSet_pr229910() { runTest("around advice on field set"); }
-    public void testPipelineCompilationGenericReturnType_pr226567() { runTest("pipeline compilation and generic return type"); }
-
-    public static Test suite() {
-      return XMLBasedAjcTestCase.loadSuite(Ajc161Tests.class);
-    }
-
-    protected File getSpecFile() {
-      return new File("../tests/src/org/aspectj/systemtest/ajc161/ajc161.xml");
-    }
-  
+
+	public void testITDPrecedence_pr233838_1() {
+		runTest("itd precedence - 1");
+	}
+
+	public void testITDPrecedence_pr233838_2() {
+		runTest("itd precedence - 2");
+	}
+
+	public void testGetFieldGenerics_pr227401() {
+		runTest("getfield problem with generics");
+	}
+
+	public void testGenericAbstractAspects_pr231478() {
+		runTest("generic abstract aspects");
+	}
+
+	public void testFieldJoinpointsAndAnnotationValues_pr227993() {
+		runTest("field jp anno value");
+	}
+
+	public void testGenericsBoundsDecp_pr231187() {
+		runTest("generics bounds decp");
+	}
+
+	public void testGenericsBoundsDecp_pr231187_2() {
+		runTest("generics bounds decp - 2");
+	}
+
+	public void testLtwInheritedCflow_pr230134() {
+		runTest("ltw inherited cflow");
+	}
+
+	public void testAroundAdviceOnFieldSet_pr229910() {
+		runTest("around advice on field set");
+	}
+
+	public void testPipelineCompilationGenericReturnType_pr226567() {
+		runTest("pipeline compilation and generic return type");
+	}
+
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(Ajc161Tests.class);
+	}
+
+	protected File getSpecFile() {
+		return new File("../tests/src/org/aspectj/systemtest/ajc161/ajc161.xml");
+	}
+
 }
\ No newline at end of file
@@ -13,179 +13,175 @@ import java.io.File;
 
 import junit.framework.Test;
 
-import org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder;
 import org.aspectj.asm.AsmManager;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 import org.aspectj.testing.util.StructureModelUtil;
 
 public class IncrementalModelTests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
-  public static Test suite() {
-    return XMLBasedAjcTestCase.loadSuite(IncrementalModelTests.class);
-  }
-
-  protected File getSpecFile() {
-    return new File("../tests/src/org/aspectj/systemtest/incremental/model/incremental-model.xml");
-  }
-
-  // This first test doesnt do a lot currently, but is ready too...
-  public void test001() throws Exception {
-    runTest("Testing incremental structure model: Intertype declarations (and a declare parents)");
-    nextIncrement(true);
-    copyFileAndDoIncrementalBuild("changes/CloneablePoint.20.java","src/introduction/CloneablePoint.java");
-    nextIncrement(true);
-    copyFile("changes/Point.30.java","src/introduction/Point.java");
-    copyFileAndDoIncrementalBuild("changes/HashablePoint.30.java","src/introduction/HashablePoint.java");
-    StructureModelUtil.checkModel("declare parents=2");
-  }
-
-  public void test002() throws Exception {
-     runTest("Testing incremental structure model: Intertype field declarations");
-     
-	 nextIncrement(true);
-	 copyFileAndDoIncrementalBuild("changes/secondary/BetaA.20.java","src/secondary/BetaA.java");
-	 StructureModelUtil.checkModel("inter-type field=2,RelationshipMapSize=3");
-
-	 nextIncrement(true);
-	 copyFileAndDoIncrementalBuild("changes/secondary/BetaA.30.java","src/secondary/BetaA.java");
-// TODO Andy - fix this test, what should the real results be in the model?
-	 // when we go slow it seems to be relmapsize=0
-	// StructureModelUtil.checkModel("inter-type field=1,RelationshipMapSize=2");
-  }
-
-  public void test003() throws Exception{
-    runTest("Testing incremental structure model: Weaving handlers");
-
-    // <!-- BetaA has a new piece of handler advice added -->
-    nextIncrement(true);
-	copyFileAndDoIncrementalBuild("changes/primary/BetaA.20.java","src/primary/BetaA.java");
-	if (AsmHierarchyBuilder.shouldAddUsesPointcut) {
-		StructureModelUtil.checkModel("code=1,advice=1,RelationshipMapSize=3");
-	} else {
-		StructureModelUtil.checkModel("code=1,advice=1,RelationshipMapSize=2");
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(IncrementalModelTests.class);
+	}
+
+	protected File getSpecFile() {
+		return new File("../tests/src/org/aspectj/systemtest/incremental/model/incremental-model.xml");
 	}
 
-    // <!-- secondary.GammaA added, also advises the same handler -->
-    nextIncrement(true);
-	copyFileAndDoIncrementalBuild("changes/secondary/GammaA.30.java","src/secondary/GammaA.java");
-    if (AsmHierarchyBuilder.shouldAddUsesPointcut) {
-        StructureModelUtil.checkModel("code=1,advice=2,RelationshipMapSize=5");		
-	} else {
-	    StructureModelUtil.checkModel("code=1,advice=2,RelationshipMapSize=3");
+	// This first test doesnt do a lot currently, but is ready too...
+	public void test001() throws Exception {
+		runTest("Testing incremental structure model: Intertype declarations (and a declare parents)");
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/CloneablePoint.20.java", "src/introduction/CloneablePoint.java");
+		nextIncrement(true);
+		copyFile("changes/Point.30.java", "src/introduction/Point.java");
+		copyFileAndDoIncrementalBuild("changes/HashablePoint.30.java", "src/introduction/HashablePoint.java");
+		StructureModelUtil.checkModel("declare parents=2");
+	}
+
+	public void test002() throws Exception {
+		runTest("Testing incremental structure model: Intertype field declarations");
+
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/secondary/BetaA.20.java", "src/secondary/BetaA.java");
+		StructureModelUtil.checkModel("inter-type field=2,RelationshipMapSize=3");
+
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/secondary/BetaA.30.java", "src/secondary/BetaA.java");
+		// TODO Andy - fix this test, what should the real results be in the model?
+		// when we go slow it seems to be relmapsize=0
+		// StructureModelUtil.checkModel("inter-type field=1,RelationshipMapSize=2");
+	}
+
+	public void test003() throws Exception {
+		runTest("Testing incremental structure model: Weaving handlers");
+
+		// <!-- BetaA has a new piece of handler advice added -->
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/primary/BetaA.20.java", "src/primary/BetaA.java");
+		// if (AsmHierarchyBuilder.shouldAddUsesPointcut) {
+		// StructureModelUtil.checkModel("code=1,advice=1,RelationshipMapSize=3");
+		// } else {
+		StructureModelUtil.checkModel("code=1,advice=1,RelationshipMapSize=2");
+		// }
+
+		// <!-- secondary.GammaA added, also advises the same handler -->
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/secondary/GammaA.30.java", "src/secondary/GammaA.java");
+		// if (AsmHierarchyBuilder.shouldAddUsesPointcut) {
+		// StructureModelUtil.checkModel("code=1,advice=2,RelationshipMapSize=5");
+		// } else {
+		StructureModelUtil.checkModel("code=1,advice=2,RelationshipMapSize=3");
+		// }
+
+		// <!-- primary.BetaA deleted -->
+		nextIncrement(true);
+		deleteFileAndDoIncrementalBuild("src/primary/BetaA.java");
+		// if (AsmHierarchyBuilder.shouldAddUsesPointcut) {
+		// StructureModelUtil.checkModel("code=1,advice=1,RelationshipMapSize=3");
+		// } else {
+		StructureModelUtil.checkModel("code=1,advice=1,RelationshipMapSize=2");
+		// }
+
 	}
 
-    // <!-- primary.BetaA deleted -->
-    nextIncrement(true);
-    deleteFileAndDoIncrementalBuild("src/primary/BetaA.java");
-    if (AsmHierarchyBuilder.shouldAddUsesPointcut) {
-        StructureModelUtil.checkModel("code=1,advice=1,RelationshipMapSize=3");		
-	} else {
-	    StructureModelUtil.checkModel("code=1,advice=1,RelationshipMapSize=2");
+	public void test004() throws Exception {
+		runTest("Testing incremental structure model: Weaving");
+
+		// <!-- BetaA has a new piece of advice added -->
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/primary/BetaA.20.java", "src/primary/BetaA.java");
+		// if (AsmHierarchyBuilder.shouldAddUsesPointcut) {
+		// StructureModelUtil.checkModel("code=2,advice=2,java source file=3,RelationshipMapSize=6");
+		// } else {
+		StructureModelUtil.checkModel("code=2,advice=2,java source file=3,RelationshipMapSize=4");
+		// }
+
+		// <!-- BetaA has a piece of advice removed -->
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/primary/BetaA.30.java", "src/primary/BetaA.java");
+		// if (AsmHierarchyBuilder.shouldAddUsesPointcut) {
+		// StructureModelUtil.checkModel("code=1,advice=1,RelationshipMapSize=3");
+		// } else {
+		StructureModelUtil.checkModel("code=1,advice=1,RelationshipMapSize=2");
+		// }
+
+		// <!-- BetaA other piece of advice removed (now empty) -->
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/primary/BetaA.40.java", "src/primary/BetaA.java");
+		StructureModelUtil.checkModel("code=0,RelationshipMapSize=0,advice=0");
 	}
 
-  }
-  
-
-  public void test004() throws Exception {
-    runTest("Testing incremental structure model: Weaving");
-    
-    // <!-- BetaA has a new piece of advice added -->
-    nextIncrement(true);
-	copyFileAndDoIncrementalBuild("changes/primary/BetaA.20.java","src/primary/BetaA.java");
-	if (AsmHierarchyBuilder.shouldAddUsesPointcut) {
-		 StructureModelUtil.checkModel("code=2,advice=2,java source file=3,RelationshipMapSize=6");
-	} else {
-		 StructureModelUtil.checkModel("code=2,advice=2,java source file=3,RelationshipMapSize=4");
+	public void test005() throws Exception {
+		runTest("Testing incremental structure model: Updating files");
+
+		// <!-- Beta changed, method added -->
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/primary/Beta.20.java", "src/primary/Beta.java");
+		StructureModelUtil.checkModel("java source file=5,method=4,class=3,FileMapSize=4");
+
+		// <!-- Delta changed, class added -->
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/secondary/Delta.30.java", "src/secondary/Delta.java");
+		StructureModelUtil.checkModel("java source file=5,method=4,class=4,advice=1");
+
+		// <!-- Gamma changed, advice added -->
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/secondary/Gamma.40.java", "src/secondary/Gamma.java");
+		StructureModelUtil.checkModel("advice=2");
+
+		// <!-- Gamma changed, pointcut added -->
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/secondary/Gamma.50.java", "src/secondary/Gamma.java");
+		StructureModelUtil.checkModel("advice=2,pointcut=1");
+
+		// <!-- Gamma changed, both advice removed -->
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/secondary/Gamma.60.java", "src/secondary/Gamma.java");
+		StructureModelUtil.checkModel("advice=0,pointcut=1");
+
 	}
-   
-    
-    // <!-- BetaA has a piece of advice removed -->
-    nextIncrement(true);
-	copyFileAndDoIncrementalBuild("changes/primary/BetaA.30.java","src/primary/BetaA.java");
-	if (AsmHierarchyBuilder.shouldAddUsesPointcut) {
-	    StructureModelUtil.checkModel("code=1,advice=1,RelationshipMapSize=3");
-	} else {
-	    StructureModelUtil.checkModel("code=1,advice=1,RelationshipMapSize=2");
+
+	public void test006() throws Exception {
+		runTest("Testing incremental structure model: Adding and removing files");
+
+		// <!-- Adds primary.Beta class -->
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/primary/Beta.20.java", "src/primary/Beta.java");
+		StructureModelUtil.checkModel("java source file=3,FileMapSize=2");
+
+		// <!-- Adds secondary.Gamma aspect -->
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/secondary/Gamma.30.java", "src/secondary/Gamma.java");
+		StructureModelUtil.checkModel("java source file=4");
+
+		// <!-- Adds secondary.Delta class -->
+		nextIncrement(true);
+		copyFileAndDoIncrementalBuild("changes/secondary/Delta.40.java", "src/secondary/Delta.java");
+		StructureModelUtil.checkModel("java source file=5,package=2,FileMapSize=4");
+
+		// <!-- Deletes Gamma aspect -->
+		nextIncrement(true);
+		deleteFileAndDoIncrementalBuild("src/secondary/Gamma.java");
+		StructureModelUtil.checkModel("java source file=4,package=2");
+
+		// <!-- Deletes Beta and Delta classes -->
+		nextIncrement(true);
+		deleteFile("src/primary/Beta.java");
+		deleteFileAndDoIncrementalBuild("src/secondary/Delta.java");
+		StructureModelUtil.checkModel("java source file=2,FileMapSize=1");
 	}
-    
-    // <!-- BetaA other piece of advice removed (now empty) -->
-    nextIncrement(true);
-	copyFileAndDoIncrementalBuild("changes/primary/BetaA.40.java","src/primary/BetaA.java");
-    StructureModelUtil.checkModel("code=0,RelationshipMapSize=0,advice=0");
-  }
-
-  public void test005() throws Exception {
-    runTest("Testing incremental structure model: Updating files");
-    
-    // <!-- Beta changed, method added -->
-    nextIncrement(true);
-    copyFileAndDoIncrementalBuild("changes/primary/Beta.20.java","src/primary/Beta.java");
-    StructureModelUtil.checkModel("java source file=5,method=4,class=3,FileMapSize=4");
-       
-    // <!-- Delta changed, class added -->
-    nextIncrement(true);
-    copyFileAndDoIncrementalBuild("changes/secondary/Delta.30.java","src/secondary/Delta.java");
-    StructureModelUtil.checkModel("java source file=5,method=4,class=4,advice=1");
-    
-    // <!-- Gamma changed, advice added -->
-    nextIncrement(true);
-    copyFileAndDoIncrementalBuild("changes/secondary/Gamma.40.java","src/secondary/Gamma.java");
-    StructureModelUtil.checkModel("advice=2");
-    
-    // <!-- Gamma changed, pointcut added -->
-    nextIncrement(true);
-    copyFileAndDoIncrementalBuild("changes/secondary/Gamma.50.java","src/secondary/Gamma.java");
-    StructureModelUtil.checkModel("advice=2,pointcut=1");
-    
-    //  <!-- Gamma changed, both advice removed -->
-    nextIncrement(true);
-    copyFileAndDoIncrementalBuild("changes/secondary/Gamma.60.java","src/secondary/Gamma.java");
-    StructureModelUtil.checkModel("advice=0,pointcut=1");
-    
-  }
-
-  public void test006() throws Exception {
-    runTest("Testing incremental structure model: Adding and removing files");
-    
-    // <!-- Adds primary.Beta class -->
-    nextIncrement(true);
-    copyFileAndDoIncrementalBuild("changes/primary/Beta.20.java","src/primary/Beta.java");
-    StructureModelUtil.checkModel("java source file=3,FileMapSize=2");
-    
-    // <!-- Adds secondary.Gamma aspect -->
-    nextIncrement(true);
-    copyFileAndDoIncrementalBuild("changes/secondary/Gamma.30.java","src/secondary/Gamma.java");
-    StructureModelUtil.checkModel("java source file=4");
-    
-    // <!-- Adds secondary.Delta class -->
-    nextIncrement(true);
-    copyFileAndDoIncrementalBuild("changes/secondary/Delta.40.java","src/secondary/Delta.java");
-    StructureModelUtil.checkModel("java source file=5,package=2,FileMapSize=4");
-    
-    // <!-- Deletes Gamma aspect -->    
-    nextIncrement(true);
-    deleteFileAndDoIncrementalBuild("src/secondary/Gamma.java");
-    StructureModelUtil.checkModel("java source file=4,package=2");
-    
-    // <!-- Deletes Beta and Delta classes -->
-    nextIncrement(true);
-    deleteFile("src/primary/Beta.java");
-    deleteFileAndDoIncrementalBuild("src/secondary/Delta.java");
-    StructureModelUtil.checkModel("java source file=2,FileMapSize=1");
-  }
-
-  	protected void setUp() throws Exception {
+
+	protected void setUp() throws Exception {
 		super.setUp();
 		AsmManager.attemptIncrementalModelRepairs = true;
 	}
-  	
+
 	protected void tearDown() throws Exception {
 		// To see the model after a test, uncomment these lines...
-//		AsmManager.ModelInfo mi = AsmManager.ModelInfo.summarizeModel();
-//		System.err.println(mi.toString());
+		// AsmManager.ModelInfo mi = AsmManager.ModelInfo.summarizeModel();
+		// System.err.println(mi.toString());
 		super.tearDown();
-		
+
 		AsmManager.attemptIncrementalModelRepairs = false;
 	}
 }
-
@@ -53,11 +53,12 @@ public class AjdeInteractionTestbed extends TestCase {
 	public void configureNewProjectDependency(String fromProjectName, String projectItDependsOn) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + fromProjectName);
 		((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).addDependancy(projectItDependsOn);
-	} 
-	
+	}
+
 	public void addSourceFolderForSourceFile(String projectName, File f, String sourceFolder) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
-		((MultiProjTestOutputLocationManager)((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration()).getOutputLocationManager()).setSourceFolderFor(f,sourceFolder);
+		((MultiProjTestOutputLocationManager) ((MultiProjTestCompilerConfiguration) compiler.getCompilerConfiguration())
+				.getOutputLocationManager()).setSourceFolderFor(f, sourceFolder);
 	}
 
 	public void setNextChangeResponse(String projName, int flags) {
@@ -167,6 +168,11 @@ public class AjdeInteractionTestbed extends TestCase {
 		return true;
 	}
 
+	// public AsmManager getStructureModelFor(String projectName) {
+	// AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
+	// returnc compiler.getStructureModelFor(projectName)
+	// }
+
 	/** Drives a full build **/
 	public boolean doFullBuild(String projectName) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
@@ -302,11 +308,11 @@ public class AjdeInteractionTestbed extends TestCase {
 		if (getCompiledFiles(projectName).size() == 0 && getWovenClasses(projectName).size() == 0)
 			sb.append("No files were compiled or woven\n");
 		for (Iterator iter = getCompiledFiles(projectName).iterator(); iter.hasNext();) {
-			Object element = (Object) iter.next();
+			Object element = iter.next();
 			sb.append("compiled: " + element + "\n");
 		}
 		for (Iterator iter = getWovenClasses(projectName).iterator(); iter.hasNext();) {
-			Object element = (Object) iter.next();
+			Object element = iter.next();
 			sb.append("woven: " + element + "\n");
 		}
 		return sb.toString();
@@ -369,6 +375,11 @@ public class AjdeInteractionTestbed extends TestCase {
 		return ((MultiProjTestBuildProgressMonitor) compiler.getBuildProgressMonitor()).getCompiledFiles();
 	}
 
+	public AsmManager getModelFor(String projectName) {
+		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
+		return compiler.getModel();
+	}
+
 	public List getWovenClasses(String projectName) {
 		AjCompiler compiler = CompilerFactory.getCompilerForProjectWithDir(sandboxDir + File.separator + projectName);
 		return ((MultiProjTestBuildProgressMonitor) compiler.getBuildProgressMonitor()).getWovenClasses();
@@ -26,12 +26,10 @@ import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.ajdt.internal.core.builder.AjState;
 import org.aspectj.ajdt.internal.core.builder.IncrementalStateManager;
 import org.aspectj.asm.AsmManager;
-import org.aspectj.asm.IElementHandleProvider;
 import org.aspectj.asm.IHierarchy;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.asm.IRelationship;
 import org.aspectj.asm.IRelationshipMap;
-import org.aspectj.asm.internal.JDTLikeHandleProvider;
 import org.aspectj.asm.internal.Relationship;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.tools.ajc.Ajc;
@@ -63,28 +61,28 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 			// see pr148027 AsmHierarchyBuilder.shouldAddUsesPointcut=false;
 			initialiseProject("P4");
 			build("P4");
-			Ajc.dumpAJDEStructureModel("after full build where advice is applying");
+			Ajc.dumpAJDEStructureModel(getModelFor("P4"), "after full build where advice is applying");
 			// should be 4 relationship entries
 
 			// In inc1 the first advised line is 'commented out'
 			alter("P4", "inc1");
 			build("P4");
 			checkWasntFullBuild();
-			Ajc.dumpAJDEStructureModel("after inc build where first advised line is gone");
+			Ajc.dumpAJDEStructureModel(getModelFor("P4"), "after inc build where first advised line is gone");
 			// should now be 2 relationship entries
 
 			// This will be the line 6 entry in C.java
-			IProgramElement codeElement = findCode(checkForNode("pack", "C", true));
+			IProgramElement codeElement = findCode(checkForNode(getModelFor("P4"), "pack", "C", true));
 
 			// This will be the line 7 entry in A.java
-			IProgramElement advice = findAdvice(checkForNode("pack", "A", true));
+			IProgramElement advice = findAdvice(checkForNode(getModelFor("P4"), "pack", "A", true));
 
-			IRelationshipMap asmRelMap = AsmManager.getDefault().getRelationshipMap();
+			IRelationshipMap asmRelMap = getModelFor("P4").getRelationshipMap();
 			assertEquals("There should be two relationships in the relationship map", 2, asmRelMap.getEntries().size());
 
 			for (Iterator iter = asmRelMap.getEntries().iterator(); iter.hasNext();) {
 				String sourceOfRelationship = (String) iter.next();
-				IProgramElement ipe = AsmManager.getDefault().getHierarchy().findElementForHandle(sourceOfRelationship);
+				IProgramElement ipe = getModelFor("P4").getHierarchy().findElementForHandle(sourceOfRelationship);
 				assertNotNull("expected to find IProgramElement with handle " + sourceOfRelationship + " but didn't", ipe);
 				if (ipe.getKind().equals(IProgramElement.Kind.ADVICE)) {
 					assertEquals("expected source of relationship to be " + advice.toString() + " but found " + ipe.toString(),
@@ -104,7 +102,7 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 					List targets = rel.getTargets();
 					for (Iterator iterator2 = targets.iterator(); iterator2.hasNext();) {
 						String t = (String) iterator2.next();
-						IProgramElement link = AsmManager.getDefault().getHierarchy().findElementForHandle(t);
+						IProgramElement link = getModelFor("P4").getHierarchy().findElementForHandle(t);
 						if (ipe.getKind().equals(IProgramElement.Kind.ADVICE)) {
 							assertEquals("expected target of relationship to be " + codeElement.toString() + " but found "
 									+ link.toString(), codeElement, link);
@@ -129,18 +127,19 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		build("Annos");
 		checkWasFullBuild();
 		checkCompileWeaveCount("Annos", 4, 4);
-		assertEquals("Should be 3 relationships ", 3, AsmManager.getDefault().getRelationshipMap().getEntries().size());
+		AsmManager model = getModelFor("Annos");
+		assertEquals("Should be 3 relationships ", 3, model.getRelationshipMap().getEntries().size());
 
 		alter("Annos", "inc1"); // Comment out the annotation on Parent
 		build("Annos");
 		checkWasntFullBuild();
-		assertEquals("Should be no relationships ", 0, AsmManager.getDefault().getRelationshipMap().getEntries().size());
+		assertEquals("Should be no relationships ", 0, model.getRelationshipMap().getEntries().size());
 		checkCompileWeaveCount("Annos", 3, 3);
 
 		alter("Annos", "inc2"); // Add the annotation back onto Parent
 		build("Annos");
 		checkWasntFullBuild();
-		assertEquals("Should be 3 relationships ", 3, AsmManager.getDefault().getRelationshipMap().getEntries().size());
+		assertEquals("Should be 3 relationships ", 3, model.getRelationshipMap().getEntries().size());
 		checkCompileWeaveCount("Annos", 3, 3);
 	}
 
@@ -151,9 +150,10 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		build(p);
 		// alter(p, "inc2");
 		// build(p);
-		dumptree(AsmManager.getDefault().getHierarchy().getRoot(), 0);
+		AsmManager model = getModelFor(p);
+		dumptree(model.getHierarchy().getRoot(), 0);
 
-		IProgramElement root = AsmManager.getDefault().getHierarchy().getRoot();
+		IProgramElement root = model.getHierarchy().getRoot();
 		IProgramElement ipe = findElementAtLine(root, 4);
 		assertEquals("=BrokenHandles<p{GetInfo.java}GetInfo`declare warning", ipe.getHandleIdentifier());
 		ipe = findElementAtLine(root, 5);
@@ -167,7 +167,7 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		String p = "Simpler";
 		initialiseProject(p);
 		build(p);
-		dumptree(AsmManager.getDefault().getHierarchy().getRoot(), 0);
+		dumptree(getModelFor(p).getHierarchy().getRoot(), 0);
 		// incomplete
 	}
 
@@ -175,9 +175,9 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		String p = "BeanExample";
 		initialiseProject(p);
 		build(p);
-		dumptree(AsmManager.getDefault().getHierarchy().getRoot(), 0);
+		dumptree(getModelFor(p).getHierarchy().getRoot(), 0);
 		PrintWriter pw = new PrintWriter(System.out);
-		AsmManager.getDefault().dumprels(pw);
+		getModelFor(p).dumprels(pw);
 		pw.flush();
 		// incomplete
 	}
@@ -239,7 +239,7 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		initialiseProject(p);
 		addSourceFolderForSourceFile(p, getProjectRelativePath(p, "src/Handles.aj"), "src");
 		build(p);
-		IProgramElement root = AsmManager.getDefault().getHierarchy().getRoot();
+		IProgramElement root = getModelFor(p).getHierarchy().getRoot();
 		IProgramElement typeDecl = findElementAtLine(root, 4);
 		assertEquals("=AdviceHandles/src<spacewar*Handles.aj}Handles", typeDecl.getHandleIdentifier());
 
@@ -342,11 +342,11 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		addSourceFolderForSourceFile("MultiSource", getProjectRelativePath("MultiSource", "src2/CodeTwo.java"), "src2");
 		addSourceFolderForSourceFile("MultiSource", getProjectRelativePath("MultiSource", "src3/pkg/CodeThree.java"), "src3");
 		build("MultiSource");
-		IProgramElement srcOne = AsmManager.getDefault().getHierarchy().findElementForHandle("=MultiSource/src1");
-		IProgramElement CodeOneClass = AsmManager.getDefault().getHierarchy().findElementForHandle(
+		IProgramElement srcOne = getModelFor("MultiSource").getHierarchy().findElementForHandle("=MultiSource/src1");
+		IProgramElement CodeOneClass = getModelFor("MultiSource").getHierarchy().findElementForHandle(
 				"=MultiSource/src1{CodeOne.java[CodeOne");
-		IProgramElement srcTwoPackage = AsmManager.getDefault().getHierarchy().findElementForHandle("=MultiSource/src2<pkg");
-		IProgramElement srcThreePackage = AsmManager.getDefault().getHierarchy().findElementForHandle("=MultiSource/src3<pkg");
+		IProgramElement srcTwoPackage = getModelFor("MultiSource").getHierarchy().findElementForHandle("=MultiSource/src2<pkg");
+		IProgramElement srcThreePackage = getModelFor("MultiSource").getHierarchy().findElementForHandle("=MultiSource/src3<pkg");
 		assertNotNull(srcOne);
 		assertNotNull(CodeOneClass);
 		assertNotNull(srcTwoPackage);
@@ -426,11 +426,11 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		configureAspectPath(bug2, getProjectRelativePath(bug, "bin"));
 		build(bug);
 		build(bug2);
-		dumptree(AsmManager.getDefault().getHierarchy().getRoot(), 0);
+		dumptree(getModelFor(bug2).getHierarchy().getRoot(), 0);
 		PrintWriter pw = new PrintWriter(System.out);
-		AsmManager.getDefault().dumprels(pw);
+		getModelFor(bug2).dumprels(pw);
 		pw.flush();
-		IProgramElement root = AsmManager.getDefault().getHierarchy().getRoot();
+		IProgramElement root = getModelFor(bug2).getHierarchy().getRoot();
 		assertEquals("=AspectPathTwo/binaries<pkg(Asp.class}Asp&before", findElementAtLine(root, 5).getHandleIdentifier());
 		assertEquals("=AspectPathTwo/binaries<(Asp2.class}Asp2&before", findElementAtLine(root, 16).getHandleIdentifier());
 	}
@@ -467,7 +467,7 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		alter(p1, "inc1");
 		build(p1); // Modify the aspect Asp2 to include staticinitialization() advice
 		checkWasFullBuild();
-		Set s = AsmManager.getDefault().getModelChangesOnLastBuild();
+		Set s = getModelFor(p1).getModelChangesOnLastBuild();
 		assertTrue("Should be empty as was full build:" + s, s.isEmpty());
 
 		// prod the build of the second project with some extra info to tell it more precisely about the change:
@@ -569,7 +569,7 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		checkCompileWeaveCount("pr240360", 5, 4);
 		assertTrue("There should be an error:\n" + getErrorMessages("pr240360"), !getErrorMessages("pr240360").isEmpty());
 
-		Set s = AsmManager.getDefault().getRelationshipMap().getEntries();
+		Set s = getModelFor("pr240360").getRelationshipMap().getEntries();
 		int relmapLength = s.size();
 
 		// Delete the erroneous type
@@ -579,21 +579,21 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		build("pr240360");
 		checkWasntFullBuild();
 		checkCompileWeaveCount("pr240360", 0, 0);
-		assertEquals(relmapLength, AsmManager.getDefault().getRelationshipMap().getEntries().size());
+		assertEquals(relmapLength, getModelFor("pr240360").getRelationshipMap().getEntries().size());
 
 		// Readd the erroneous type
 		alter("pr240360", "inc1");
 		build("pr240360");
 		checkWasntFullBuild();
 		checkCompileWeaveCount("pr240360", 1, 0);
-		assertEquals(relmapLength, AsmManager.getDefault().getRelationshipMap().getEntries().size());
+		assertEquals(relmapLength, getModelFor("pr240360").getRelationshipMap().getEntries().size());
 
 		// Change the advice
 		alter("pr240360", "inc2");
 		build("pr240360");
 		checkWasFullBuild();
 		checkCompileWeaveCount("pr240360", 6, 4);
-		assertEquals(relmapLength, AsmManager.getDefault().getRelationshipMap().getEntries().size());
+		assertEquals(relmapLength, getModelFor("pr240360").getRelationshipMap().getEntries().size());
 
 	}
 
@@ -681,16 +681,16 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		initialiseProject("P2");
 
 		build("P1");
-		checkForNode("pkg", "C", true);
+		checkForNode(getModelFor("P1"), "pkg", "C", true);
 
 		build("P2");
-		checkForNode("pkg", "C", false);
+		checkForNode(getModelFor("P2"), "pkg", "C", false);
 
 		build("P1");
-		checkForNode("pkg", "C", true);
+		checkForNode(getModelFor("P1"), "pkg", "C", true);
 
 		build("P2");
-		checkForNode("pkg", "C", false);
+		checkForNode(getModelFor("P2"), "pkg", "C", false);
 	}
 
 	// Setup up two simple projects and build them in turn - check the
@@ -700,16 +700,16 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		initialiseProject("P2");
 
 		build("P1");
-		checkForNode("pkg", "C", true);
+		checkForNode(getModelFor("P1"), "pkg", "C", true);
 
 		build("P2");
-		checkForNode("pkg", "C", false);
+		checkForNode(getModelFor("P2"), "pkg", "C", false);
 
 		build("P1");
-		checkForNode("pkg", "C", true);
+		checkForNode(getModelFor("P1"), "pkg", "C", true);
 
 		build("P2");
-		checkForNode("pkg", "C", false);
+		checkForNode(getModelFor("P2"), "pkg", "C", false);
 	}
 
 	/**
@@ -1552,118 +1552,118 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 				.get(0)).getSourceLocation().getLine());
 		alter("PR134541", "inc1");
 		build("PR134541");
-		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
-			checkWasFullBuild(); // the line number has changed... but nothing
-		// structural about the code
-		else
-			checkWasntFullBuild(); // the line number has changed... but nothing
+		// if (getModelFor("PR134541").getHandleProvider().dependsOnLocation())
+		// checkWasFullBuild(); // the line number has changed... but nothing
+		// // structural about the code
+		// else
+		checkWasntFullBuild(); // the line number has changed... but nothing
 		// structural about the code
 		assertEquals("[Xlint:adviceDidNotMatch] should now be associated with line 7", 7,
 				((IMessage) getWarningMessages("PR134541").get(0)).getSourceLocation().getLine());
 	}
 
 	public void testJDTLikeHandleProviderWithLstFile_pr141730() {
-		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
-		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
-		try {
-			// The JDTLike-handles should start with the name
-			// of the buildconfig file
-			initialiseProject("JDTLikeHandleProvider");
-			build("JDTLikeHandleProvider");
-			IHierarchy top = AsmManager.getDefault().getHierarchy();
-			IProgramElement pe = top.findElementForType("pkg", "A");
-			String expectedHandle = "=JDTLikeHandleProvider<pkg*A.aj}A";
-			assertEquals("expected handle to be " + expectedHandle + ", but found " + pe.getHandleIdentifier(), expectedHandle, pe
-					.getHandleIdentifier());
-		} finally {
-			AsmManager.getDefault().setHandleProvider(handleProvider);
-		}
+		// IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
+		// AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+		// try {
+		// The JDTLike-handles should start with the name
+		// of the buildconfig file
+		initialiseProject("JDTLikeHandleProvider");
+		build("JDTLikeHandleProvider");
+		IHierarchy top = getModelFor("JDTLikeHandleProvider").getHierarchy();
+		IProgramElement pe = top.findElementForType("pkg", "A");
+		String expectedHandle = "=JDTLikeHandleProvider<pkg*A.aj}A";
+		assertEquals("expected handle to be " + expectedHandle + ", but found " + pe.getHandleIdentifier(), expectedHandle, pe
+				.getHandleIdentifier());
+		// } finally {
+		// AsmManager.getDefault().setHandleProvider(handleProvider);
+		// }
 	}
 
 	public void testMovingAdviceDoesntChangeHandles_pr141730() {
-		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
-		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
-		try {
-			initialiseProject("JDTLikeHandleProvider");
-			build("JDTLikeHandleProvider");
-			checkWasFullBuild();
-			IHierarchy top = AsmManager.getDefault().getHierarchy();
-			IProgramElement pe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.ADVICE,
-					"before(): <anonymous pointcut>");
-			// add a line which shouldn't change the handle
-			alter("JDTLikeHandleProvider", "inc1");
-			build("JDTLikeHandleProvider");
-			checkWasntFullBuild();
-			IHierarchy top2 = AsmManager.getDefault().getHierarchy();
-			IProgramElement pe2 = top.findElementForLabel(top2.getRoot(), IProgramElement.Kind.ADVICE,
-					"before(): <anonymous pointcut>");
-			assertEquals("expected advice to be on line " + pe.getSourceLocation().getLine() + 1 + " but was on "
-					+ pe2.getSourceLocation().getLine(), pe.getSourceLocation().getLine() + 1, pe2.getSourceLocation().getLine());
-			assertEquals("expected advice to have handle " + pe.getHandleIdentifier() + " but found handle "
-					+ pe2.getHandleIdentifier(), pe.getHandleIdentifier(), pe2.getHandleIdentifier());
-		} finally {
-			AsmManager.getDefault().setHandleProvider(handleProvider);
-		}
+		// IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
+		// AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+		// try {
+		initialiseProject("JDTLikeHandleProvider");
+		build("JDTLikeHandleProvider");
+		checkWasFullBuild();
+		IHierarchy top = getModelFor("JDTLikeHandleProvider").getHierarchy();
+		IProgramElement pe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.ADVICE, "before(): <anonymous pointcut>");
+		// add a line which shouldn't change the handle
+		alter("JDTLikeHandleProvider", "inc1");
+		build("JDTLikeHandleProvider");
+		checkWasntFullBuild();
+		IHierarchy top2 = getModelFor("JDTLikeHandleProvider").getHierarchy();
+		IProgramElement pe2 = top
+				.findElementForLabel(top2.getRoot(), IProgramElement.Kind.ADVICE, "before(): <anonymous pointcut>");
+		assertEquals("expected advice to be on line " + pe.getSourceLocation().getLine() + 1 + " but was on "
+				+ pe2.getSourceLocation().getLine(), pe.getSourceLocation().getLine() + 1, pe2.getSourceLocation().getLine());
+		assertEquals("expected advice to have handle " + pe.getHandleIdentifier() + " but found handle "
+				+ pe2.getHandleIdentifier(), pe.getHandleIdentifier(), pe2.getHandleIdentifier());
+		// } finally {
+		// AsmManager.getDefault().setHandleProvider(handleProvider);
+		// }
 	}
 
 	public void testSwappingAdviceAndHandles_pr141730() {
-		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
-		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
-		try {
-			initialiseProject("JDTLikeHandleProvider");
-			build("JDTLikeHandleProvider");
-			IHierarchy top = AsmManager.getDefault().getHierarchy();
-
-			IProgramElement call = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.ADVICE, "after(): callPCD..");
-			IProgramElement exec = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.ADVICE, "after(): execPCD..");
-			// swap the two after advice statements over. This forces
-			// a full build which means 'after(): callPCD..' will now
-			// be the second after advice in the file and have the same
-			// handle as 'after(): execPCD..' originally did.
-			alter("JDTLikeHandleProvider", "inc2");
-			build("JDTLikeHandleProvider");
-			checkWasFullBuild();
-
-			IHierarchy top2 = AsmManager.getDefault().getHierarchy();
-			IProgramElement newCall = top2.findElementForLabel(top2.getRoot(), IProgramElement.Kind.ADVICE, "after(): callPCD..");
-			IProgramElement newExec = top2.findElementForLabel(top2.getRoot(), IProgramElement.Kind.ADVICE, "after(): execPCD..");
-
-			assertEquals("after swapping places, expected 'after(): callPCD..' " + "to be on line "
-					+ newExec.getSourceLocation().getLine() + " but was on line " + call.getSourceLocation().getLine(), newExec
-					.getSourceLocation().getLine(), call.getSourceLocation().getLine());
-			assertEquals("after swapping places, expected 'after(): callPCD..' " + "to have handle " + exec.getHandleIdentifier()
-					+ " (because was full build) but had " + newCall.getHandleIdentifier(), exec.getHandleIdentifier(), newCall
-					.getHandleIdentifier());
-		} finally {
-			AsmManager.getDefault().setHandleProvider(handleProvider);
-		}
-	}
+		// IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
+		// AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+		// try {
+		initialiseProject("JDTLikeHandleProvider");
+		build("JDTLikeHandleProvider");
+		IHierarchy top = getModelFor("JDTLikeHandleProvider").getHierarchy();
+
+		IProgramElement call = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.ADVICE, "after(): callPCD..");
+		IProgramElement exec = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.ADVICE, "after(): execPCD..");
+		// swap the two after advice statements over. This forces
+		// a full build which means 'after(): callPCD..' will now
+		// be the second after advice in the file and have the same
+		// handle as 'after(): execPCD..' originally did.
+		alter("JDTLikeHandleProvider", "inc2");
+		build("JDTLikeHandleProvider");
+		checkWasFullBuild();
 
-	public void testInitializerCountForJDTLikeHandleProvider_pr141730() {
-		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
-		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
-		try {
-			initialiseProject("JDTLikeHandleProvider");
-			build("JDTLikeHandleProvider");
-			String expected = "=JDTLikeHandleProvider<pkg*A.aj[C|1";
+		IHierarchy top2 = getModelFor("JDTLikeHandleProvider").getHierarchy();
+		IProgramElement newCall = top2.findElementForLabel(top2.getRoot(), IProgramElement.Kind.ADVICE, "after(): callPCD..");
+		IProgramElement newExec = top2.findElementForLabel(top2.getRoot(), IProgramElement.Kind.ADVICE, "after(): execPCD..");
 
-			IHierarchy top = AsmManager.getDefault().getHierarchy();
-			IProgramElement init = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.INITIALIZER, "...");
-			assertEquals("expected initializers handle to be " + expected + "," + " but found " + init.getHandleIdentifier(true),
-					expected, init.getHandleIdentifier(true));
+		assertEquals("after swapping places, expected 'after(): callPCD..' " + "to be on line "
+				+ newExec.getSourceLocation().getLine() + " but was on line " + call.getSourceLocation().getLine(), newExec
+				.getSourceLocation().getLine(), call.getSourceLocation().getLine());
+		assertEquals("after swapping places, expected 'after(): callPCD..' " + "to have handle " + exec.getHandleIdentifier()
+				+ " (because was full build) but had " + newCall.getHandleIdentifier(), exec.getHandleIdentifier(), newCall
+				.getHandleIdentifier());
+		// } finally {
+		// AsmManager.getDefault().setHandleProvider(handleProvider);
+		// }
+	}
 
-			alter("JDTLikeHandleProvider", "inc2");
-			build("JDTLikeHandleProvider");
-			checkWasFullBuild();
+	public void testInitializerCountForJDTLikeHandleProvider_pr141730() {
+		// IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
+		// AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+		// try {
+		initialiseProject("JDTLikeHandleProvider");
+		build("JDTLikeHandleProvider");
+		String expected = "=JDTLikeHandleProvider<pkg*A.aj[C|1";
+
+		IHierarchy top = getModelFor("JDTLikeHandleProvider").getHierarchy();
+		IProgramElement init = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.INITIALIZER, "...");
+		assertEquals("expected initializers handle to be " + expected + "," + " but found " + init.getHandleIdentifier(true),
+				expected, init.getHandleIdentifier(true));
+
+		alter("JDTLikeHandleProvider", "inc2");
+		build("JDTLikeHandleProvider");
+		checkWasFullBuild();
 
-			IHierarchy top2 = AsmManager.getDefault().getHierarchy();
-			IProgramElement init2 = top2.findElementForLabel(top2.getRoot(), IProgramElement.Kind.INITIALIZER, "...");
-			assertEquals("expected initializers handle to still be " + expected + "," + " but found "
-					+ init2.getHandleIdentifier(true), expected, init2.getHandleIdentifier(true));
+		IHierarchy top2 = getModelFor("JDTLikeHandleProvider").getHierarchy();
+		IProgramElement init2 = top2.findElementForLabel(top2.getRoot(), IProgramElement.Kind.INITIALIZER, "...");
+		assertEquals(
+				"expected initializers handle to still be " + expected + "," + " but found " + init2.getHandleIdentifier(true),
+				expected, init2.getHandleIdentifier(true));
 
-		} finally {
-			AsmManager.getDefault().setHandleProvider(handleProvider);
-		}
+		// } finally {
+		// AsmManager.getDefault().setHandleProvider(handleProvider);
+		// }
 	}
 
 	// 134471 related tests perform incremental compilation and verify features
@@ -1677,15 +1677,15 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 			configureNonStandardCompileOptions("PR134471", "-showWeaveInfo -emacssym");
 			configureShowWeaveInfoMessages("PR134471", true);
 			build("PR134471");
-
+			AsmManager model = getModelFor("PR134471");
 			// Step2. Quick check that the advice points to something...
-			IProgramElement nodeForTypeA = checkForNode("pkg", "A", true);
+			IProgramElement nodeForTypeA = checkForNode(model, "pkg", "A", true);
 			IProgramElement nodeForAdvice = findAdvice(nodeForTypeA);
-			List relatedElements = getRelatedElements(nodeForAdvice, 1);
+			List relatedElements = getRelatedElements(model, nodeForAdvice, 1);
 
 			// Step3. Check the advice applying at the first 'code' join point
 			// in pkg.C is from aspect pkg.A, line 7
-			IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true)));
+			IProgramElement programElement = getFirstRelatedElement(model, findCode(checkForNode(model, "pkg", "C", true)));
 			int line = programElement.getSourceLocation().getLine();
 			assertTrue("advice should be at line 7 - but is at line " + line, line == 7);
 
@@ -1693,15 +1693,16 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 			// in it
 			alter("PR134471", "inc1");
 			build("PR134471");
+			model = getModelFor("PR134471");
 
 			// Step5. Quick check that the advice points to something...
-			nodeForTypeA = checkForNode("pkg", "A", true);
+			nodeForTypeA = checkForNode(model, "pkg", "A", true);
 			nodeForAdvice = findAdvice(nodeForTypeA);
-			relatedElements = getRelatedElements(nodeForAdvice, 1);
+			relatedElements = getRelatedElements(model, nodeForAdvice, 1);
 
 			// Step6. Check the advice applying at the first 'code' join point
 			// in pkg.C is from aspect pkg.A, line 7
-			programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true)));
+			programElement = getFirstRelatedElement(model, findCode(checkForNode(model, "pkg", "C", true)));
 			line = programElement.getSourceLocation().getLine();
 			assertTrue("advice should be at line 7 - but is at line " + line, line == 7);
 		} finally {
@@ -1718,9 +1719,9 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		configureNonStandardCompileOptions("PR134471_2", "-showWeaveInfo -emacssym");
 		configureShowWeaveInfoMessages("PR134471_2", true);
 		build("PR134471_2");
-
+		AsmManager model = getModelFor("PR134471_2");
 		// Step2. confirm advice is from correct location
-		IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true)));
+		IProgramElement programElement = getFirstRelatedElement(model, findCode(checkForNode(model, "pkg", "C", true)));
 		int line = programElement.getSourceLocation().getLine();
 		assertTrue("advice should be at line 7 - but is at line " + line, line == 7);
 
@@ -1728,11 +1729,8 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		// down a few lines... (change in source location)
 		alter("PR134471_2", "inc1");
 		build("PR134471_2");
-		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
-			checkWasFullBuild(); // the line number has changed... but nothing
-		// structural about the code
-		else
-			checkWasntFullBuild(); // the line number has changed... but nothing
+		model = getModelFor("PR134471_2");
+		checkWasntFullBuild(); // the line number has changed... but nothing
 		// structural about the code
 
 		// checkWasFullBuild(); // this is true whilst we consider
@@ -1740,7 +1738,7 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		// to until the handles are independent of location
 
 		// Step4. Check we have correctly realised the advice moved to line 11
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true)));
+		programElement = getFirstRelatedElement(model, findCode(checkForNode(model, "pkg", "C", true)));
 		line = programElement.getSourceLocation().getLine();
 		assertTrue("advice should be at line 11 - but is at line " + line, line == 11);
 	}
@@ -1768,29 +1766,30 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 			configureNonStandardCompileOptions("PR134471", "-showWeaveInfo -emacssym");
 			configureShowWeaveInfoMessages("PR134471", true);
 			build("PR134471");
-
+			AsmManager model = getModelFor("PR134471");
 			// Step2. confirm advice is from correct location
-			IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true)));
+			IProgramElement programElement = getFirstRelatedElement(model, findCode(checkForNode(model, "pkg", "C", true)));
 			int line = programElement.getSourceLocation().getLine();
 			assertTrue("advice should be at line 7 - but is at line " + line, line == 7);
 
 			// Step3. No change to the aspect at all
 			alter("PR134471", "inc1");
 			build("PR134471");
-
+			model = getModelFor("PR134471");
 			// Step4. Quick check that the advice points to something...
-			IProgramElement nodeForTypeA = checkForNode("pkg", "A", true);
+			IProgramElement nodeForTypeA = checkForNode(model, "pkg", "A", true);
 			IProgramElement nodeForAdvice = findAdvice(nodeForTypeA);
-			List relatedElements = getRelatedElements(nodeForAdvice, 1);
+			List relatedElements = getRelatedElements(model, nodeForAdvice, 1);
 
 			// Step5. No change to the file C but it should still be advised
 			// afterwards
 			alter("PR134471", "inc2");
 			build("PR134471");
 			checkWasntFullBuild();
+			model = getModelFor("PR134471");
 
 			// Step6. confirm advice is from correct location
-			programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true)));
+			programElement = getFirstRelatedElement(model, findCode(checkForNode(model, "pkg", "C", true)));
 			line = programElement.getSourceLocation().getLine();
 			assertTrue("advice should be at line 7 - but is at line " + line, line == 7);
 		} finally {
@@ -1809,33 +1808,31 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		build("PR134471_3");
 		checkWasFullBuild();
 
+		AsmManager model = getModelFor("PR134471_3");
 		// Step2. confirm declare warning is from correct location, decw matches
 		// line 7 in pkg.C
-		IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 7));
+		IProgramElement programElement = getFirstRelatedElement(model, findCode(checkForNode(model, "pkg", "C", true), 7));
 		int line = programElement.getSourceLocation().getLine();
 		assertTrue("declare warning should be at line 10 - but is at line " + line, line == 10);
 
 		// Step3. confirm advice is from correct location, advice matches line 6
 		// in pkg.C
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 6));
+		programElement = getFirstRelatedElement(model, findCode(checkForNode(model, "pkg", "C", true), 6));
 		line = programElement.getSourceLocation().getLine();
 		assertTrue("advice should be at line 7 - but is at line " + line, line == 7);
 
 		// Step4. Move declare warning in the aspect
 		alter("PR134471_3", "inc1");
 		build("PR134471_3");
-		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
-			checkWasFullBuild(); // the line number has changed... but nothing
-		// structural about the code
-		else
-			checkWasntFullBuild(); // the line number has changed... but nothing
+		model = getModelFor("PR134471_3");
+		checkWasntFullBuild(); // the line number has changed... but nothing
 		// structural about the code
 
 		// checkWasFullBuild();
 
 		// Step5. confirm declare warning is from correct location, decw (now at
 		// line 12) in pkg.A matches line 7 in pkg.C
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 7));
+		programElement = getFirstRelatedElement(model, findCode(checkForNode(model, "pkg", "C", true), 7));
 		line = programElement.getSourceLocation().getLine();
 		assertTrue("declare warning should be at line 12 - but is at line " + line, line == 12);
 
@@ -1843,10 +1840,10 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		alter("PR134471_3", "inc2");
 		build("PR134471_3");
 		checkWasntFullBuild();
-
+		model = getModelFor("PR134471_3");
 		// Step7. confirm declare warning is from correct location, decw (now at
 		// line 12) in pkg.A matches line 7 in pkg.C
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 7));
+		programElement = getFirstRelatedElement(model, findCode(checkForNode(model, "pkg", "C", true), 7));
 		line = programElement.getSourceLocation().getLine();
 		assertTrue("declare warning should be at line 12 - but is at line " + line, line == 12);
 	}
@@ -1860,34 +1857,31 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		configureShowWeaveInfoMessages("PR134471_3", true);
 		build("PR134471_3");
 		checkWasFullBuild();
-
+		AsmManager model = getModelFor("PR134471_3");
 		// Step2. confirm declare warning is from correct location, decw matches
 		// line 7 in pkg.C
-		IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 7));
+		IProgramElement programElement = getFirstRelatedElement(model, findCode(checkForNode(model, "pkg", "C", true), 7));
 		int line = programElement.getSourceLocation().getLine();
 		assertTrue("declare warning should be at line 10 - but is at line " + line, line == 10);
 
 		// Step3. confirm advice is from correct location, advice matches line 6
 		// in pkg.C
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 6));
+		programElement = getFirstRelatedElement(model, findCode(checkForNode(model, "pkg", "C", true), 6));
 		line = programElement.getSourceLocation().getLine();
 		assertTrue("advice should be at line 7 - but is at line " + line, line == 7);
 
 		// Step4. Move declare warning in the aspect
 		alter("PR134471_3", "inc1");
 		build("PR134471_3");
-		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
-			checkWasFullBuild(); // the line number has changed... but nothing
-		// structural about the code
-		else
-			checkWasntFullBuild(); // the line number has changed... but nothing
+		model = getModelFor("PR134471_3");
+		checkWasntFullBuild(); // the line number has changed... but nothing
 		// structural about the code
 
 		// checkWasFullBuild();
 
 		// Step5. confirm declare warning is from correct location, decw (now at
 		// line 12) in pkg.A matches line 7 in pkg.C
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 7));
+		programElement = getFirstRelatedElement(model, findCode(checkForNode(model, "pkg", "C", true), 7));
 		line = programElement.getSourceLocation().getLine();
 		assertTrue("declare warning should be at line 12 - but is at line " + line, line == 12);
 
@@ -1895,10 +1889,10 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		alter("PR134471_3", "inc2");
 		build("PR134471_3");
 		checkWasntFullBuild();
-
+		model = getModelFor("PR134471_3");
 		// Step7. confirm declare warning is from correct location, decw (now at
 		// line 12) in pkg.A matches line 7 in pkg.C
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 7));
+		programElement = getFirstRelatedElement(model, findCode(checkForNode(model, "pkg", "C", true), 7));
 		line = programElement.getSourceLocation().getLine();
 		assertTrue("declare warning should be at line 12 - but is at line " + line, line == 12);
 
@@ -1910,7 +1904,7 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 
 		// Step9. confirm declare warning is from correct location, decw (now at
 		// line 12) in pkg.A matches line 7 in pkg.C
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg", "C", true), 7));
+		programElement = getFirstRelatedElement(model, findCode(checkForNode(model, "pkg", "C", true), 7));
 		line = programElement.getSourceLocation().getLine();
 		assertTrue("declare warning should be at line 12 - but is at line " + line, line == 12);
 	}
@@ -1944,11 +1938,7 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		assertTrue("There should be no warnings:\n" + warnings, warnings.isEmpty());
 		alter("PR152589", "inc1");
 		build("PR152589");
-		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
-			checkWasFullBuild(); // the line number has changed... but nothing
-		// structural about the code
-		else
-			checkWasntFullBuild(); // the line number has changed... but nothing
+		checkWasntFullBuild(); // the line number has changed... but nothing
 		// structural about the code
 
 		// checkWasFullBuild();
@@ -1975,8 +1965,8 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 	}
 
 	public void testPR158573() {
-		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
-		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+		// IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
+		// AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
 		initialiseProject("PR158573");
 		build("PR158573");
 		List warnings = getWarningMessages("PR158573");
@@ -1987,7 +1977,7 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		checkWasntFullBuild();
 		warnings = getWarningMessages("PR158573");
 		assertTrue("There should be no warnings after changing the value of a " + "variable:\n" + warnings, warnings.isEmpty());
-		AsmManager.getDefault().setHandleProvider(handleProvider);
+		// AsmManager.getDefault().setHandleProvider(handleProvider);
 	}
 
 	/**
@@ -2124,14 +2114,13 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 	 * @param programElement Program element whose related elements are to be found
 	 * @param expected the number of expected related elements
 	 */
-	private List/* IProgramElement */getRelatedElements(IProgramElement programElement, int expected) {
-		List relatedElements = getRelatedElements(programElement);
+	private List/* IProgramElement */getRelatedElements(AsmManager model, IProgramElement programElement, int expected) {
+		List relatedElements = getRelatedElements(model, programElement);
 		StringBuffer debugString = new StringBuffer();
 		if (relatedElements != null) {
 			for (Iterator iter = relatedElements.iterator(); iter.hasNext();) {
 				String element = (String) iter.next();
-				debugString.append(AsmManager.getDefault().getHierarchy().findElementForHandle(element).toLabelString()).append(
-						"\n");
+				debugString.append(model.getHierarchy().findElementForHandle(element).toLabelString()).append("\n");
 			}
 		}
 		assertTrue("Should be " + expected + " element" + (expected > 1 ? "s" : "") + " related to this one '" + programElement
@@ -2139,14 +2128,14 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		return relatedElements;
 	}
 
-	private IProgramElement getFirstRelatedElement(IProgramElement programElement) {
-		List rels = getRelatedElements(programElement, 1);
-		return AsmManager.getDefault().getHierarchy().findElementForHandle((String) rels.get(0));
+	private IProgramElement getFirstRelatedElement(AsmManager model, IProgramElement programElement) {
+		List rels = getRelatedElements(model, programElement, 1);
+		return model.getHierarchy().findElementForHandle((String) rels.get(0));
 	}
 
-	private List/* IProgramElement */getRelatedElements(IProgramElement advice) {
+	private List/* IProgramElement */getRelatedElements(AsmManager model, IProgramElement advice) {
 		List output = null;
-		IRelationshipMap map = AsmManager.getDefault().getRelationshipMap();
+		IRelationshipMap map = model.getRelationshipMap();
 		List/* IRelationship */rels = map.get(advice);
 		if (rels == null)
 			fail("Did not find any related elements!");
@@ -2213,23 +2202,23 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 	// --------------------------------------------------------------------------
 	// -------------------------
 
-	private IProgramElement checkForNode(String packageName, String typeName, boolean shouldBeFound) {
-		IProgramElement ipe = AsmManager.getDefault().getHierarchy().findElementForType(packageName, typeName);
+	private IProgramElement checkForNode(AsmManager model, String packageName, String typeName, boolean shouldBeFound) {
+		IProgramElement ipe = model.getHierarchy().findElementForType(packageName, typeName);
 		if (shouldBeFound) {
 			if (ipe == null)
-				printModel();
+				printModel(model);
 			assertTrue("Should have been able to find '" + packageName + "." + typeName + "' in the asm", ipe != null);
 		} else {
 			if (ipe != null)
-				printModel();
+				printModel(model);
 			assertTrue("Should have NOT been able to find '" + packageName + "." + typeName + "' in the asm", ipe == null);
 		}
 		return ipe;
 	}
 
-	private void printModel() {
+	private void printModel(AsmManager model) {
 		try {
-			AsmManager.dumptree(AsmManager.getDefault().getHierarchy().getRoot(), 0);
+			AsmManager.dumptree(model.getHierarchy().getRoot(), 0);
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
@@ -21,56 +21,53 @@ import java.util.List;
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IElementHandleProvider;
 import org.aspectj.asm.IModelFilter;
-import org.aspectj.asm.internal.JDTLikeHandleProvider;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 import org.aspectj.util.FileUtil;
 
 /**
- * This class provides an extension to the XMLBasedAjcTestCase to manage
- * testing the model. It assumes the testdata is in ../tests/model/<testid>
- * and that the expected model against which to do the comparison is in
- * the file ../tests/model/expected/<testid>.txt. One test ensures that both
- * the model and the relationship map are as expected for the given testdata.
+ * This class provides an extension to the XMLBasedAjcTestCase to manage testing the model. It assumes the testdata is in
+ * ../tests/model/<testid> and that the expected model against which to do the comparison is in the file
+ * ../tests/model/expected/<testid>.txt. One test ensures that both the model and the relationship map are as expected for the given
+ * testdata.
  * 
- * To write a testcase, create a testdata directory containing the data
- * for the test run and a file containing the expected model (this can be 
- * generated by setting the regenerate flag to true). Add the required 
- * configuration to model.xml. Finally, create a testcase in either ModelTests 
- * or Model5Tests (depending on whether the testcase has a requirement 
- * on Java5) and call runModelTest(<title of test>,<testid>). 
+ * To write a testcase, create a testdata directory containing the data for the test run and a file containing the expected model
+ * (this can be generated by setting the regenerate flag to true). Add the required configuration to model.xml. Finally, create a
+ * testcase in either ModelTests or Model5Tests (depending on whether the testcase has a requirement on Java5) and call
+ * runModelTest(<title of test>,<testid>).
  */
 public abstract class ModelTestCase extends XMLBasedAjcTestCase {
 
 	protected static boolean regenerate = false;
 	protected static boolean debugTest = false;
 
-	private final String expectedOutDir = "../tests/model/expected" + File.separator;		
+	private final String expectedOutDir = "../tests/model/expected" + File.separator;
 	private String testid;
-	
+
 	private String modelFilename;
-	
+
 	private IElementHandleProvider handleProvider;
-	
-	/* (non-Javadoc)
+
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see junit.framework.TestCase#setUp()
 	 */
 	protected void setUp() throws Exception {
 		super.setUp();
 		// using the JDTLikeHandleProvider because this produces consistent handles
 		// over different compiles
-		handleProvider = AsmManager.getDefault().getHandleProvider();
-		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
 		// We are about to create a sandbox for the model output file, don't let the
 		// following compile wipe it.
 		ajc.setShouldEmptySandbox(false);
 		// report all information - model, relationships delta processing
 		modelFilename = ajc.getSandboxDirectory().getAbsolutePath() + File.separator + "model.txt";
-		AsmManager.setReporting(modelFilename, 
-				true,true,true,false,new TestFilter(ajc.getSandboxDirectory().getCanonicalPath()));
+		AsmManager.setReporting(modelFilename, true, true, true, false,
+				new TestFilter(ajc.getSandboxDirectory().getCanonicalPath()));
 	}
-	
+
 	static class TestFilter implements IModelFilter {
-		String sandboxDirectory ;
+		String sandboxDirectory;
+
 		public TestFilter(String sandboxDirectory) {
 			this.sandboxDirectory = sandboxDirectory;
 		}
@@ -81,15 +78,15 @@ public abstract class ModelTestCase extends XMLBasedAjcTestCase {
 				int forwardSlash = sub.indexOf("/");
 				// replace all "/" with "\" - to ensure platform independence
 				if (forwardSlash != -1) {
-					sub = sub.replace('/','\\');
+					sub = sub.replace('/', '\\');
 				}
 				// don't report the column number since this is sometimes
 				// different on windows and linux
 				int column = sub.lastIndexOf(':');
 				if (column != -1) {
-					return "TEST_SANDBOX" + sub.substring(0,column);
+					return "TEST_SANDBOX" + sub.substring(0, column);
 				}
-				return "TEST_SANDBOX"+sub;
+				return "TEST_SANDBOX" + sub;
 			}
 			return loc;
 		}
@@ -98,32 +95,30 @@ public abstract class ModelTestCase extends XMLBasedAjcTestCase {
 			return false;
 		}
 	}
-	
-	/* (non-Javadoc)
+
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see junit.framework.TestCase#tearDown()
 	 */
 	protected void tearDown() throws Exception {
 		super.tearDown();
-		AsmManager.getDefault().setHandleProvider(handleProvider);
 		AsmManager.setDontReport();
 		ajc.setShouldEmptySandbox(true);
 	}
-	
+
 	/**
-	 * Firstly sets the testid which is both the name of the expected output
-	 * file and the name of the testdata directory. It then
-	 * invokes XMLBasedAjcTestCase.runTest(String) with the given
-	 * title and finally verifies that the model file created from this test
-	 * run is the same as the expected output (includes model information, the
-	 * relationship map and various properties about the model) contained
-	 * in ../tests/model/expected/<testid>.txt
+	 * Firstly sets the testid which is both the name of the expected output file and the name of the testdata directory. It then
+	 * invokes XMLBasedAjcTestCase.runTest(String) with the given title and finally verifies that the model file created from this
+	 * test run is the same as the expected output (includes model information, the relationship map and various properties about
+	 * the model) contained in ../tests/model/expected/<testid>.txt
 	 */
-	protected void runModelTest(String title,String testid) {
+	protected void runModelTest(String title, String testid) {
 		this.testid = testid;
 		runTest(title);
 		verifyModel();
 	}
-	
+
 	private void verifyModel() {
 		File expectedOutput = new File(expectedOutDir + testid + ".txt");
 		if (regenerate) {
@@ -134,88 +129,89 @@ public abstract class ModelTestCase extends XMLBasedAjcTestCase {
 			compareModel(expectedOutput);
 		}
 	}
-	
+
 	private void compareModel(File expectedF) {
-		if (debugTest) System.out.println("comparing with model in file " + expectedF.getAbsolutePath());
+		if (debugTest)
+			System.out.println("comparing with model in file " + expectedF.getAbsolutePath());
 		List fileContents = new ArrayList();
 		try {
 			String sandboxDir = ajc.getSandboxDirectory().getAbsolutePath();
 			String modelOutput = modelFilename;
 			// Load the file with the expected output
 			BufferedReader expect = new BufferedReader(new FileReader(expectedF));
-//			String tempDir = expect.readLine();
+			// String tempDir = expect.readLine();
 			String expectedLine = null;
-			while((expectedLine=expect.readLine())!=null) {
-				fileContents.add(expectedLine);					
+			while ((expectedLine = expect.readLine()) != null) {
+				fileContents.add(expectedLine);
 			}
 			List expectedFileContents = new ArrayList();
 			expectedFileContents.addAll(fileContents);
-			
+
 			// Load the file with the output from this test run
 			BufferedReader found = new BufferedReader(new FileReader(new File(modelOutput)));
 			String foundLine = null;
 			List foundFileContents = new ArrayList();
-			while((foundLine=found.readLine())!=null) {
-//				int i = foundLine.indexOf(sandboxDir);
-//				if (i == -1) {
-//					int j = foundLine.indexOf("(targets=");
-//					if (j == -1) {
-						foundFileContents.add(foundLine);
-//					} else {
-//						foundFileContents.add(foundLine.substring(j));
-//					}
-//				} else {
-//					String newLine = foundLine.substring(0,i) + tempDir 
-//						+ foundLine.substring(i + sandboxDir.length());
-//					foundFileContents.add(newLine);
-//				}
+			while ((foundLine = found.readLine()) != null) {
+				// int i = foundLine.indexOf(sandboxDir);
+				// if (i == -1) {
+				// int j = foundLine.indexOf("(targets=");
+				// if (j == -1) {
+				foundFileContents.add(foundLine);
+				// } else {
+				// foundFileContents.add(foundLine.substring(j));
+				// }
+				// } else {
+				// String newLine = foundLine.substring(0,i) + tempDir
+				// + foundLine.substring(i + sandboxDir.length());
+				// foundFileContents.add(newLine);
+				// }
 			}
-			
+
 			// iterate over what we found
 			for (Iterator iter = foundFileContents.iterator(); iter.hasNext();) {
 				String line = (String) iter.next();
-				if (debugTest) System.err.println("looking at model entry: " + line);
+				if (debugTest)
+					System.err.println("looking at model entry: " + line);
 				if (!fileContents.contains(line)) {
-//			    if (!((String)fileContents.get(lineNumber)).equals(line)) {
-			    	
-					if(debugTest) {
+					// if (!((String)fileContents.get(lineNumber)).equals(line)) {
+
+					if (debugTest) {
 						System.err.println("couldn't find: " + line);
-						for (Iterator iterator = fileContents.iterator(); iterator
-								.hasNext();) {
+						for (Iterator iterator = fileContents.iterator(); iterator.hasNext();) {
 							String element = (String) iterator.next();
 							System.err.println("compared with: " + element);
 						}
 					}
-				
-//					StringBuffer errorData = new StringBuffer();
-//					errorData.append("Problem with comparison at line number: "+)
+
+					// StringBuffer errorData = new StringBuffer();
+					// errorData.append("Problem with comparison at line number: "+)
 					fail("couldn't find model entry '" + line + "' in expected output");
 				} else {
 					fileContents.remove(line);
 				}
 			}
-			
+
 			if (debugTest && !fileContents.isEmpty()) {
-				for (Iterator iter = fileContents.iterator(); iter
-						.hasNext();) {
+				for (Iterator iter = fileContents.iterator(); iter.hasNext();) {
 					String element = (String) iter.next();
 					System.err.println("remaining: " + element);
 				}
 			}
-			assertTrue("should have found all expected model output: " + fileContents,fileContents.isEmpty());
+			assertTrue("should have found all expected model output: " + fileContents, fileContents.isEmpty());
 		} catch (Exception e) {
-			fail("Unexpected exception comparing model files:"+e);
+			fail("Unexpected exception comparing model files:" + e);
 		}
 	}
-	
+
 	private void saveModel(File f) {
-		if (debugTest) System.out.println("Saving model into "+f.getAbsolutePath());
-		File modelFile = new File(modelFilename);	
+		if (debugTest)
+			System.out.println("Saving model into " + f.getAbsolutePath());
+		File modelFile = new File(modelFilename);
 		try {
 			FileUtil.copyFile(modelFile, f);
 		} catch (IOException ioe) {
 			ioe.printStackTrace();
-			fail("Couldn't copy file to "+f.toString());
+			fail("Couldn't copy file to " + f.toString());
 		}
 	}
 
@@ -14,7 +14,6 @@ import java.io.File;
 
 import junit.framework.Test;
 
-import org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 import org.aspectj.weaver.World;
 
@@ -62,17 +61,18 @@ public class ModelTests extends ModelTestCase {
 		}
 	}
 
-	public void testPCDInClassAppearsInModel_pr148027() {
-		boolean b = AsmHierarchyBuilder.shouldAddUsesPointcut;
-		AsmHierarchyBuilder.shouldAddUsesPointcut = true;
-		World.createInjarHierarchy = false;
-		try {
-			runModelTest("ensure pcd declare in class appears in model", "pr148027");
-		} finally {
-			World.createInjarHierarchy = true;
-			AsmHierarchyBuilder.shouldAddUsesPointcut = b;
-		}
-	}
+	//
+	// public void testPCDInClassAppearsInModel_pr148027() {
+	// boolean b = AsmHierarchyBuilder.shouldAddUsesPointcut;
+	// AsmHierarchyBuilder.shouldAddUsesPointcut = true;
+	// World.createInjarHierarchy = false;
+	// try {
+	// runModelTest("ensure pcd declare in class appears in model", "pr148027");
+	// } finally {
+	// World.createInjarHierarchy = true;
+	// AsmHierarchyBuilder.shouldAddUsesPointcut = b;
+	// }
+	// }
 
 	// public void testInpathAdvisedCode_prX() { runModelTest("inpath advised elements","prX"); }
 
@@ -29,7 +29,7 @@ import org.aspectj.weaver.tools.WeavingAdaptor;
 
 /**
  * @author websterm
- *
+ * 
  */
 public class WeavingURLClassLoaderTest extends TestCase {
 
@@ -43,7 +43,7 @@ public class WeavingURLClassLoaderTest extends TestCase {
 	private final static String AROUNDCLOSURE_ASPECTS = BcweaverTests.TESTDATA_PATH + "/ltw-acaspects.jar";
 	private final static String ITD_ASPECTS = BcweaverTests.TESTDATA_PATH + "/ltw-itdaspects.jar";
 	private final static String PER_ASPECTS = BcweaverTests.TESTDATA_PATH + "/ltw-peraspects.jar";
-    private final static String TEST_BASE = BcweaverTests.TESTDATA_PATH + "/WeavingURLClassLoaderTest/builtLibs";
+	private final static String TEST_BASE = BcweaverTests.TESTDATA_PATH + "/WeavingURLClassLoaderTest/builtLibs";
 
 	private final static String NULL = "null";
 
@@ -53,35 +53,32 @@ public class WeavingURLClassLoaderTest extends TestCase {
 		super(name);
 	}
 
-	public void testLoadClass () {
-		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,"");
-		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,CLASSES_JAR);
+	public void testLoadClass() {
+		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH, "");
+		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH, CLASSES_JAR);
 		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());
 
 		try {
 			Class clazz = loader.loadClass("LTWHelloWorld");
-			invokeMain(clazz,new String[] {}); 
-		}
-		catch (Exception ex) {
+			invokeMain(clazz, new String[] {});
+		} catch (Exception ex) {
 			fail(ex.toString());
 		}
 	}
 
 	/*
-	 * We won't get an exception because the aspect path is empty and there is 
-	 * no aop.xml file so the weaver will be disabled and no reweaving will 
-	 * take place 
+	 * We won't get an exception because the aspect path is empty and there is no aop.xml file so the weaver will be disabled and no
+	 * reweaving will take place
 	 */
-	public void testLoadWovenClass () {
-		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,"");
-		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,WOVEN_JAR);
+	public void testLoadWovenClass() {
+		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH, "");
+		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH, WOVEN_JAR);
 		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());
 
 		try {
 			Class clazz = loader.loadClass("LTWHelloWorld");
-			invokeMain(clazz,new String[] { "LTWAspect" }); 
-		}
-		catch (Exception ex) {
+			invokeMain(clazz, new String[] { "LTWAspect" });
+		} catch (Exception ex) {
 			fail(ex.toString());
 		}
 	}
@@ -89,228 +86,224 @@ public class WeavingURLClassLoaderTest extends TestCase {
 	/*
 	 * We get an exception because the class was not built reweavable
 	 */
-	public void testWeaveWovenClass () {
-		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
-		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,ADVICE_ASPECTS + File.pathSeparator + WOVEN_JAR);
+	public void testWeaveWovenClass() {
+		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH, ADVICE_ASPECTS);
+		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH, ADVICE_ASPECTS + File.pathSeparator + WOVEN_JAR);
 		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());
 
 		try {
 			loader.loadClass("LTWHelloWorld");
 			fail("Expecting org.aspectj.bridge.AbortException");
-		}
-		catch (Exception ex) {
-			assertTrue("Expecting org.aspectj.bridge.AbortException caught " + ex,(ex instanceof AbortException));
+		} catch (Exception ex) {
+			assertTrue("Expecting org.aspectj.bridge.AbortException caught " + ex, (ex instanceof AbortException));
 		}
 	}
 
-	public void testWeavingURLClassLoader () {
+	public void testWeavingURLClassLoader() {
 		URL classes = FileUtil.getFileURL(new File(CLASSES_JAR));
 		URL aspectjrt = FileUtil.getFileURL(new File(ASPECTJRT));
 		URL aspects = FileUtil.getFileURL(new File(ADVICE_ASPECTS));
 		URL[] classURLs = new URL[] { aspects, classes, aspectjrt };
 		URL[] aspectURLs = new URL[] { aspects };
-		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());
+		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs, aspectURLs, getClass().getClassLoader());
 
 		try {
 			Class clazz = loader.loadClass("LTWHelloWorld");
-			invokeMain(clazz,new String[] { "LTWAspect" }); 
-		}
-		catch (Exception ex) {
+			invokeMain(clazz, new String[] { "LTWAspect" });
+		} catch (Exception ex) {
 			fail(ex.toString());
 		}
 	}
 
-	public void testWeaveAdvice () {
-		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
-		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR + File.pathSeparator + ASPECTJRT);
+	public void testWeaveAdvice() {
+		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH, ADVICE_ASPECTS);
+		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH, ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR
+				+ File.pathSeparator + ASPECTJRT);
 		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());
 
 		try {
 			Class clazz = loader.loadClass("LTWHelloWorld");
-			invokeMain(clazz,new String[] { "LTWAspect" }); 
-		}
-		catch (Exception ex) {
+			invokeMain(clazz, new String[] { "LTWAspect" });
+		} catch (Exception ex) {
 			fail(ex.toString());
 		}
 	}
 
-	public void testWeaveAdviceWithVerbose () {
-		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
-		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR + File.pathSeparator + ASPECTJRT);
-		setSystemProperty(WeavingAdaptor.WEAVING_ADAPTOR_VERBOSE,"true");
+	public void testWeaveAdviceWithVerbose() {
+		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH, ADVICE_ASPECTS);
+		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH, ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR
+				+ File.pathSeparator + ASPECTJRT);
+		setSystemProperty(WeavingAdaptor.WEAVING_ADAPTOR_VERBOSE, "true");
 		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());
 
 		try {
 			Class clazz = loader.loadClass("LTWHelloWorld");
-			invokeMain(clazz,new String[] { "LTWAspect" }); 
-		}
-		catch (Exception ex) {
+			invokeMain(clazz, new String[] { "LTWAspect" });
+		} catch (Exception ex) {
 			fail(ex.toString());
 		}
 	}
 
-	public void testWeaveAdviceWithWeaveInfo () {
-		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
-		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR + File.pathSeparator + ASPECTJRT);
-		setSystemProperty(WeavingAdaptor.SHOW_WEAVE_INFO_PROPERTY,"true");
+	public void testWeaveAdviceWithWeaveInfo() {
+		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH, ADVICE_ASPECTS);
+		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH, ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR
+				+ File.pathSeparator + ASPECTJRT);
+		setSystemProperty(WeavingAdaptor.SHOW_WEAVE_INFO_PROPERTY, "true");
 		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());
 
 		try {
 			Class clazz = loader.loadClass("LTWHelloWorld");
-			invokeMain(clazz,new String[] { "LTWAspect" }); 
-		}
-		catch (Exception ex) {
+			invokeMain(clazz, new String[] { "LTWAspect" });
+		} catch (Exception ex) {
 			fail(ex.toString());
 		}
 	}
 
-	public void testWeaveDeclareWarningAdvice () {
-		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,DW_ADVICE_ASPECTS);
-		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,DW_ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
+	public void testWeaveDeclareWarningAdvice() {
+		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH, DW_ADVICE_ASPECTS);
+		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH, DW_ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
 		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());
 
 		try {
 			Class clazz = loader.loadClass("LTWHelloWorld");
-			invokeMain(clazz,new String[] {} ); 
-		}
-		catch (Exception ex) {
+			invokeMain(clazz, new String[] {});
+		} catch (Exception ex) {
 			fail(ex.toString());
 		}
 	}
 
-	public void testWeaveDeclareErrorAdvice () {
-		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,DE_ADVICE_ASPECTS);
-		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,DE_ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
+	public void testWeaveDeclareErrorAdvice() {
+		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH, DE_ADVICE_ASPECTS);
+		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH, DE_ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
 		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());
 
 		try {
 			Class clazz = loader.loadClass("LTWHelloWorld");
-			invokeMain(clazz,new String[] {} ); 
+			invokeMain(clazz, new String[] {});
 			fail("Expecting org.aspectj.bridge.AbortException");
-		}
-		catch (Exception ex) {
-			assertTrue("Expecting org.aspectj.bridge.AbortException caught " + ex,(ex instanceof AbortException));
+		} catch (Exception ex) {
+			assertTrue("Expecting org.aspectj.bridge.AbortException caught " + ex, (ex instanceof AbortException));
 		}
 	}
 
-	public void testWeaveAroundClosure () {
-		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,AROUNDCLOSURE_ASPECTS);
-		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,AROUNDCLOSURE_ASPECTS + File.pathSeparator + CLASSES_JAR + File.pathSeparator + ASPECTJRT);
+	public void testWeaveAroundClosure() {
+		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH, AROUNDCLOSURE_ASPECTS);
+		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH, AROUNDCLOSURE_ASPECTS + File.pathSeparator + CLASSES_JAR
+				+ File.pathSeparator + ASPECTJRT);
 		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());
 
 		try {
 			Class clazz = loader.loadClass("LTWHelloWorld");
-			invokeMain(clazz,new String[] { "LTWAroundClosure" }); 
-		}
-		catch (Exception ex) {
+			invokeMain(clazz, new String[] { "LTWAroundClosure" });
+		} catch (Exception ex) {
 			fail(ex.toString());
 		}
 	}
 
-	public void testWeavingITD () {
+	public void testWeavingITD() {
 		URL classes = FileUtil.getFileURL(new File(CLASSES_JAR));
 		URL aspectjrt = FileUtil.getFileURL(new File(ASPECTJRT));
 		URL aspects = FileUtil.getFileURL(new File(ITD_ASPECTS));
 		URL[] classURLs = new URL[] { aspects, classes, aspectjrt };
 		URL[] aspectURLs = new URL[] { aspects };
-		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());
+		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs, aspectURLs, getClass().getClassLoader());
 
 		try {
 			Class clazz = loader.loadClass("LTWHelloWorld");
-			invokeMain(clazz,new String[] { "LTWInterfaceITD", "LTWFieldITD", "LTWMethodITD" }); 
-		}
-		catch (Exception ex) {
+			invokeMain(clazz, new String[] { "LTWInterfaceITD", "LTWFieldITD", "LTWMethodITD" });
+		} catch (Exception ex) {
+			ex.printStackTrace();
+			// throw new RuntimeException("Failed!", ex);
 			fail(ex.toString());
+			// } finally {
+			// System.exit(0);
 		}
 	}
 
-	public void testWeavingPer () {
+	public void testWeavingPer() {
 		URL classes = FileUtil.getFileURL(new File(CLASSES_JAR));
 		URL aspectjrt = FileUtil.getFileURL(new File(ASPECTJRT));
 		URL aspects = FileUtil.getFileURL(new File(PER_ASPECTS));
 		URL[] classURLs = new URL[] { aspects, classes, aspectjrt };
 		URL[] aspectURLs = new URL[] { aspects };
-		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());
+		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs, aspectURLs, getClass().getClassLoader());
 
 		try {
 			Class clazz = loader.loadClass("LTWHelloWorld");
-			invokeMain(clazz,new String[] { "LTWPerthis" }); 
-		}
-		catch (Exception ex) {
+			invokeMain(clazz, new String[] { "LTWPerthis" });
+		} catch (Exception ex) {
 			fail(ex.toString());
 		}
 	}
 
-	public void testWeavingAspects () {
+	public void testWeavingAspects() {
 		URL classes = FileUtil.getFileURL(new File(CLASSES_JAR));
 		URL aspectjrt = FileUtil.getFileURL(new File(ASPECTJRT));
 		URL aspects1 = FileUtil.getFileURL(new File(ADVICE_ASPECTS));
 		URL aspects2 = FileUtil.getFileURL(new File(AROUNDCLOSURE_ASPECTS));
 		URL aspects3 = FileUtil.getFileURL(new File(ITD_ASPECTS));
 		URL aspects4 = FileUtil.getFileURL(new File(PER_ASPECTS));
-		URL[] classURLs = new URL[] {  aspects1, aspects2, aspects3, aspects4, classes, aspectjrt };
+		URL[] classURLs = new URL[] { aspects1, aspects2, aspects3, aspects4, classes, aspectjrt };
 		URL[] aspectURLs = new URL[] { aspects1, aspects2, aspects3, aspects4 };
-		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());
+		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs, aspectURLs, getClass().getClassLoader());
 
 		try {
 			Class clazz = loader.loadClass("LTWHelloWorld");
-			invokeMain(clazz,new String[] { "LTWAspect", "LTWAroundClosure", "LTWPerthis", "LTWInterfaceITD", "LTWFieldITD", "LTWMethodITD", "LTWPerthis"}); 
-		}
-		catch (Exception ex) {
+			invokeMain(clazz, new String[] { "LTWAspect", "LTWAroundClosure", "LTWPerthis", "LTWInterfaceITD", "LTWFieldITD",
+					"LTWMethodITD", "LTWPerthis" });
+		} catch (Exception ex) {
 			fail(ex.toString());
 		}
 	}
 
-	public void testJunkJar () {		
+	public void testJunkJar() {
 		File junkJar = new File(JUNK_JAR);
-		assertFalse(junkJar + " should not exist",junkJar.exists());
-		
+		assertFalse(junkJar + " should not exist", junkJar.exists());
+
 		URL classes = FileUtil.getFileURL(junkJar);
 		URL[] classURLs = new URL[] { classes };
-		URL[] aspectURLs = new URL[] { };
-		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());
+		URL[] aspectURLs = new URL[] {};
+		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs, aspectURLs, getClass().getClassLoader());
 
 		try {
 			loader.loadClass("LTWHelloWorld");
 			fail("Expecting java.lang.ClassNotFoundException");
-		}
-		catch (Exception ex) {
-			assertTrue("Expecting java.lang.ClassNotFoundException caught " + ex,(ex instanceof ClassNotFoundException));
+		} catch (Exception ex) {
+			assertTrue("Expecting java.lang.ClassNotFoundException caught " + ex, (ex instanceof ClassNotFoundException));
 		}
 	}
 
-	public void testJunkAspectJar () {		
+	public void testJunkAspectJar() {
 		File junkJar = new File(JUNK_JAR);
-		assertFalse(junkJar + " should not exist",junkJar.exists());
-		
+		assertFalse(junkJar + " should not exist", junkJar.exists());
+
 		URL aspects = FileUtil.getFileURL(junkJar);
 		URL[] classURLs = new URL[] { aspects };
 		URL[] aspectURLs = new URL[] { aspects };
-		
+
 		try {
-			new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());
+			new WeavingURLClassLoader(classURLs, aspectURLs, getClass().getClassLoader());
 			fail("Expecting org.aspectj.bridge.AbortException");
-		}
-		catch (Exception ex) {
-			assertTrue("Expecting org.aspectj.bridge.AbortException caught " + ex,(ex instanceof org.aspectj.bridge.AbortException));
+		} catch (Exception ex) {
+			assertTrue("Expecting org.aspectj.bridge.AbortException caught " + ex,
+					(ex instanceof org.aspectj.bridge.AbortException));
 		}
 	}
 
-	public void testAddURL () {
+	public void testAddURL() {
 		URL classes = FileUtil.getFileURL(new File(CLASSES_JAR));
 		URL aspectjrt = FileUtil.getFileURL(new File(ASPECTJRT));
 		URL aspects = FileUtil.getFileURL(new File(ADVICE_ASPECTS));
 		URL[] classURLs = new URL[] { aspects, aspectjrt };
 		URL[] aspectURLs = new URL[] { aspects };
 
-		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());
+		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs, aspectURLs, getClass().getClassLoader());
 		loader.addURL(classes);
 
 		try {
 			Class clazz = loader.loadClass("LTWHelloWorld");
-			invokeMain(clazz,new String[] { "LTWAspect" }); 
-		}
-		catch (Exception ex) {
+			invokeMain(clazz, new String[] { "LTWAspect" });
+		} catch (Exception ex) {
 			fail(ex.toString());
 		}
 	}
@@ -319,20 +312,19 @@ public class WeavingURLClassLoaderTest extends TestCase {
 		URL classes = FileUtil.getFileURL(new File(CLASSES_JAR));
 		URL aspectjrt = FileUtil.getFileURL(new File(ASPECTJRT));
 		URL aspects = FileUtil.getFileURL(new File(ADVICE_ASPECTS));
-		
+
 		URL[] classURLs = new URL[] { aspects, aspectjrt };
 		URL[] aspectURLs = new URL[] { aspects };
-		WeavingURLClassLoader parent = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());
-		
+		WeavingURLClassLoader parent = new WeavingURLClassLoader(classURLs, aspectURLs, getClass().getClassLoader());
+
 		classURLs = new URL[] { classes };
-		aspectURLs = new URL[] { };
-		WeavingURLClassLoader child = new WeavingURLClassLoader(classURLs,aspectURLs,parent);
+		aspectURLs = new URL[] {};
+		WeavingURLClassLoader child = new WeavingURLClassLoader(classURLs, aspectURLs, parent);
 
 		try {
 			Class clazz = child.loadClass("LTWHelloWorld");
-			invokeMain(clazz,new String[] { "LTWAspect" }); 
-		}
-		catch (Exception ex) {
+			invokeMain(clazz, new String[] { "LTWAspect" });
+		} catch (Exception ex) {
 			fail(ex.toString());
 		}
 	}
@@ -340,186 +332,182 @@ public class WeavingURLClassLoaderTest extends TestCase {
 	/*
 	 * Aspects on ASPECTPATH but missing from CLASSPATH
 	 */
-	public void testIncompletePath () {
-		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
-		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,CLASSES_JAR);
+	public void testIncompletePath() {
+		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH, ADVICE_ASPECTS);
+		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH, CLASSES_JAR);
 		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());
 
 		try {
 			Class clazz = loader.loadClass("LTWHelloWorld");
-			invokeMain(clazz,new String[] { "LTWAspect" }); 
+			invokeMain(clazz, new String[] { "LTWAspect" });
 			fail("Expecting java.lang.NoClassDefFoundError");
-		}
-		catch (Exception ex) {
-            String m = ex.getMessage();
-            if (-1 == m.indexOf("java.lang.NoClassDefFoundError")) {
-                fail("Expecting java.lang.NoClassDefFoundError but caught " + ex);
-            }
+		} catch (Exception ex) {
+			String m = ex.getMessage();
+			if (-1 == m.indexOf("java.lang.NoClassDefFoundError")) {
+				fail("Expecting java.lang.NoClassDefFoundError but caught " + ex);
+			}
 		}
 	}
 
 	/*
 	 * Ensure package object is correct
 	 */
-	public void testPackage () {
-		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,"");
-		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,CLASSES_JAR);
+	public void testPackage() {
+		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH, "");
+		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH, CLASSES_JAR);
 		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());
 
 		try {
 			Class clazz = loader.loadClass("ltw.LTWPackageTest");
-			invokeMain(clazz,new String[] { }); 
+			invokeMain(clazz, new String[] {});
 			Package pakkage = clazz.getPackage();
-			assertTrue("Expected 'ltw' got " + pakkage,(pakkage != null));
-		}
-		catch (Exception ex) {
+			assertTrue("Expected 'ltw' got " + pakkage, (pakkage != null));
+		} catch (Exception ex) {
 			fail(ex.toString());
 		}
 	}
-    
-    public void testZipAspects() {
-        try {
-            doTestZipAspects(TEST_BASE + "/aspect.zip");
-        } catch (Error ex) {
-            failWithException(ex);
-        } catch (Exception ex) {
-            failWithException(ex);
-        }
-    }
-    
-    public void testJarAspects() {
-        try {
-            doTestZipAspects(TEST_BASE + "/aspect.jar");
-        } catch (Error ex) {
-            failWithException(ex);
-        } catch (Exception ex) {
-            failWithException(ex);
-        }
-    }
-    
-    /** PR#106736 */
-    public void testClassAspects() {
-        try {
-            doTestZipAspects(TEST_BASE + "/classes");
-        } catch (Error ex) {
-            failWithException(ex);
-        } catch (Exception ex) {
-            failWithException(ex);
-        }
-    }
-    
-    public void testZipJarAspectsTest() {
-        try {
-            doTestZipAspectsTest();            
-            // bug: doTestZipAspects("") attempts to load packag.Aspect?
-            fail("expected error to be thrown");
-        } catch (InvocationTargetException ex) {
-            // expecting error
-            assertTrue(ex.getTargetException() instanceof Error);
-        } catch (RuntimeException ex) {
-            // expecting error
-            String message = ex.getMessage();
-            // expecting error - seems to be wrapped wrong
-            if (-1 == message.indexOf("around advice")) {
-                failWithException(ex);
-            }
-        } catch (Error ex) {
-            failWithException(ex);
-        } catch (Exception ex) {
-            failWithException(ex);
-        }
-    }
-    
+
+	public void testZipAspects() {
+		try {
+			doTestZipAspects(TEST_BASE + "/aspect.zip");
+		} catch (Error ex) {
+			failWithException(ex);
+		} catch (Exception ex) {
+			failWithException(ex);
+		}
+	}
+
+	public void testJarAspects() {
+		try {
+			doTestZipAspects(TEST_BASE + "/aspect.jar");
+		} catch (Error ex) {
+			failWithException(ex);
+		} catch (Exception ex) {
+			failWithException(ex);
+		}
+	}
+
+	/** PR#106736 */
+	public void testClassAspects() {
+		try {
+			doTestZipAspects(TEST_BASE + "/classes");
+		} catch (Error ex) {
+			failWithException(ex);
+		} catch (Exception ex) {
+			failWithException(ex);
+		}
+	}
+
+	public void testZipJarAspectsTest() {
+		try {
+			doTestZipAspectsTest();
+			// bug: doTestZipAspects("") attempts to load packag.Aspect?
+			fail("expected error to be thrown");
+		} catch (InvocationTargetException ex) {
+			// expecting error
+			assertTrue(ex.getTargetException() instanceof Error);
+		} catch (RuntimeException ex) {
+			// expecting error
+			String message = ex.getMessage();
+			// expecting error - seems to be wrapped wrong
+			if (-1 == message.indexOf("around advice")) {
+				failWithException(ex);
+			}
+		} catch (Error ex) {
+			failWithException(ex);
+		} catch (Exception ex) {
+			failWithException(ex);
+		}
+	}
+
 	public void testWeavingURLClassLoaderOddJars() throws Exception {
-		URL classes = FileUtil.getFileURL(new File(TEST_BASE+"/test.jar/main.file"));
+		URL classes = FileUtil.getFileURL(new File(TEST_BASE + "/test.jar/main.file"));
 		URL aspectjrt = FileUtil.getFileURL(new File(ASPECTJRT));
-		URL aspects = FileUtil.getFileURL(new File(TEST_BASE+"/aspectNoExt"));
+		URL aspects = FileUtil.getFileURL(new File(TEST_BASE + "/aspectNoExt"));
 		URL[] classURLs = new URL[] { aspects, classes, aspectjrt };
 		URL[] aspectURLs = new URL[] { aspects };
-		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());
+		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs, aspectURLs, getClass().getClassLoader());
 
-        Class clazz = loader.loadClass("packag.Main");
-        invokeMain(clazz,new String[] { }); 
+		Class clazz = loader.loadClass("packag.Main");
+		invokeMain(clazz, new String[] {});
 	}
-	
+
 	public void testWeavingURLClassLoaderMissingJars() throws Exception {
 		try {
-			URL classes = FileUtil.getFileURL(new File(TEST_BASE+"/test.jar/main.file"));
+			URL classes = FileUtil.getFileURL(new File(TEST_BASE + "/test.jar/main.file"));
 			URL aspectjrt = FileUtil.getFileURL(new File(ASPECTJRT));
-			URL aspects = FileUtil.getFileURL(new File(TEST_BASE+"/MissingFile"));
+			URL aspects = FileUtil.getFileURL(new File(TEST_BASE + "/MissingFile"));
 			URL[] classURLs = new URL[] { aspects, classes, aspectjrt };
 			URL[] aspectURLs = new URL[] { aspects };
-			WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());
-	
-	        Class clazz = loader.loadClass("packag.Main");
-	        invokeMain(clazz,new String[] { }); 
+			WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs, aspectURLs, getClass().getClassLoader());
+
+			Class clazz = loader.loadClass("packag.Main");
+			invokeMain(clazz, new String[] {});
 			fail("Should reject bad aspect MissingFile");
 		} catch (AbortException ae) {
-			assertTrue("Unexpected cause: "+ae.getMessage(), ae.getMessage().indexOf("bad aspect library")!=-1);
+			assertTrue("Unexpected cause: " + ae.getMessage(), ae.getMessage().indexOf("bad aspect library") != -1);
 		}
 	}
-    
-    private void doTestZipAspects(String aspectLib) throws Exception {
-        File classZip = new File(TEST_BASE + "/main.zip");        
-        File zipLib = new File(aspectLib);  
-        URL classes = FileUtil.getFileURL(classZip);
-        URL aspectjrt = FileUtil.getFileURL(new File(ASPECTJRT));
-        URL aspects = FileUtil.getFileURL(zipLib);
-        URL[] classURLs = new URL[] { aspects, classes, aspectjrt };
-        URL[] aspectURLs = new URL[] { aspects };
-        ClassLoader parent = getClass().getClassLoader();
-        WeavingURLClassLoader loader 
-            = new WeavingURLClassLoader(classURLs, aspectURLs, parent);
-        Class clazz = loader.loadClass("packag.Main");
-        invokeMain(clazz,new String[] { }); 
-        // throws Error unless advice applies
-    }
-
-    private void doTestZipAspectsTest() throws Exception {
-        URL classes = FileUtil.getFileURL(new File(TEST_BASE + "/main.zip"));
-        URL aspectjrt = FileUtil.getFileURL(new File(ASPECTJRT));
-        URL[] classURLs = new URL[] { classes, aspectjrt };
-        ClassLoader parent = getClass().getClassLoader();
-        WeavingURLClassLoader loader 
-            = new WeavingURLClassLoader(classURLs, new URL[] { }, parent);
-        Class clazz = loader.loadClass("packag.Main");
-        invokeMain(clazz,new String[] { }); 
-        // throws Error because advice does not apply
-    }
-
-    private void failWithException(Throwable t) {
-        throw new TestError(t.getMessage(), t);      
-    }
-	public static void invokeMain (Class clazz, String[] args)
-	{
+
+	private void doTestZipAspects(String aspectLib) throws Exception {
+		File classZip = new File(TEST_BASE + "/main.zip");
+		File zipLib = new File(aspectLib);
+		URL classes = FileUtil.getFileURL(classZip);
+		URL aspectjrt = FileUtil.getFileURL(new File(ASPECTJRT));
+		URL aspects = FileUtil.getFileURL(zipLib);
+		URL[] classURLs = new URL[] { aspects, classes, aspectjrt };
+		URL[] aspectURLs = new URL[] { aspects };
+		ClassLoader parent = getClass().getClassLoader();
+		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs, aspectURLs, parent);
+		Class clazz = loader.loadClass("packag.Main");
+		invokeMain(clazz, new String[] {});
+		// throws Error unless advice applies
+	}
+
+	private void doTestZipAspectsTest() throws Exception {
+		URL classes = FileUtil.getFileURL(new File(TEST_BASE + "/main.zip"));
+		URL aspectjrt = FileUtil.getFileURL(new File(ASPECTJRT));
+		URL[] classURLs = new URL[] { classes, aspectjrt };
+		ClassLoader parent = getClass().getClassLoader();
+		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs, new URL[] {}, parent);
+		Class clazz = loader.loadClass("packag.Main");
+		invokeMain(clazz, new String[] {});
+		// throws Error because advice does not apply
+	}
+
+	private void failWithException(Throwable t) {
+		throw new TestError(t.getMessage(), t);
+	}
+
+	public static void invokeMain(Class clazz, String[] args) {
 		Class[] paramTypes = new Class[1];
 		paramTypes[0] = args.getClass();
-	
+
 		try {
-			Method method = clazz.getDeclaredMethod("main",paramTypes);
+			Method method = clazz.getDeclaredMethod("main", paramTypes);
 			Object[] params = new Object[1];
 			params[0] = args;
-			method.invoke(null,params);
-		}
-		catch (InvocationTargetException ex) {
+			method.invoke(null, params);
+		} catch (InvocationTargetException ex) {
 			Throwable targetException = ex.getTargetException();
-			if (targetException instanceof RuntimeException) throw (RuntimeException)ex.getTargetException();
-			else throw new RuntimeException(ex.getTargetException().toString());
-		}
-		catch (Exception ex) {
+			if (targetException instanceof RuntimeException)
+				throw (RuntimeException) ex.getTargetException();
+			else
+				throw new RuntimeException(ex.getTargetException().toString());
+		} catch (Exception ex) {
 			throw new RuntimeException(ex.toString());
 		}
 	}
 
-	private void setSystemProperty (String key, String value) {
+	private void setSystemProperty(String key, String value) {
 		Properties systemProperties = System.getProperties();
-		copyProperty(key,systemProperties,savedProperties);
-		systemProperties.setProperty(key,value);
+		copyProperty(key, systemProperties, savedProperties);
+		systemProperties.setProperty(key, value);
 	}
-	
-	private static void copyProperty (String key, Properties from, Properties to) {
-		String value = from.getProperty(key,NULL);
-		to.setProperty(key,value);
+
+	private static void copyProperty(String key, Properties from, Properties to) {
+		String value = from.getProperty(key, NULL);
+		to.setProperty(key, value);
 	}
 
 	protected void setUp() throws Exception {
@@ -529,14 +517,16 @@ public class WeavingURLClassLoaderTest extends TestCase {
 
 	protected void tearDown() throws Exception {
 		super.tearDown();
-		
+
 		/* Restore system properties */
 		Properties systemProperties = System.getProperties();
-		for (Enumeration enu = savedProperties.keys(); enu.hasMoreElements(); ) {
-			String key = (String)enu.nextElement();
+		for (Enumeration enu = savedProperties.keys(); enu.hasMoreElements();) {
+			String key = (String) enu.nextElement();
 			String value = savedProperties.getProperty(key);
-			if (value == NULL) systemProperties.remove(key);
-			else systemProperties.setProperty(key,value);
+			if (value == NULL)
+				systemProperties.remove(key);
+			else
+				systemProperties.setProperty(key, value);
 		}
 	}
 
@@ -83,16 +83,16 @@ public class EclipseFactory {
 	public static boolean DEBUG = false;
 	public static int debug_mungerCount = -1;
 
-	private AjBuildManager buildManager;
-	private LookupEnvironment lookupEnvironment;
-	private boolean xSerializableAspects;
-	private World world;
+	private final AjBuildManager buildManager;
+	private final LookupEnvironment lookupEnvironment;
+	private final boolean xSerializableAspects;
+	private final World world;
 	public Collection finishedTypeMungers = null;
 
 	// We can get clashes if we don't treat raw types differently - we end up looking
 	// up a raw and getting the generic type (pr115788)
-	private Map/* UnresolvedType, TypeBinding */typexToBinding = new HashMap();
-	private Map/* UnresolvedType, TypeBinding */rawTypeXToBinding = new HashMap();
+	private final Map/* UnresolvedType, TypeBinding */typexToBinding = new HashMap();
+	private final Map/* UnresolvedType, TypeBinding */rawTypeXToBinding = new HashMap();
 
 	// XXX currently unused
 	// private Map/*TypeBinding, ResolvedType*/ bindingToResolvedTypeX = new HashMap();
@@ -471,7 +471,7 @@ public class EclipseFactory {
 	 * Before converting the parts of a methodbinding (params, return type) we store the type variables in this structure, then
 	 * should any component of the method binding refer to them, we grab them from the map.
 	 */
-	private Map typeVariablesForThisMember = new HashMap();
+	private final Map typeVariablesForThisMember = new HashMap();
 
 	/**
 	 * This is a map from typevariablebindings (eclipsey things) to the names the user originally specified in their ITD. For
@@ -911,7 +911,7 @@ public class EclipseFactory {
 	// map back to the same type binding - this is important later when Eclipse code is processing
 	// a methodbinding trying to come up with possible bindings for the type variables.
 	// key is currently the name of the type variable...is that ok?
-	private Map typeVariableToTypeBinding = new HashMap();
+	private final Map typeVariableToTypeBinding = new HashMap();
 
 	// /**
 	// * Converts from an TypeVariableReference to a TypeVariableBinding. A TypeVariableReference
@@ -134,7 +134,7 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 	private Map /* String -> List<UCF> */binarySourcesForTheNextCompile = new HashMap();
 
 	// FIXME asc should this really be in here?
-	private IHierarchy structureModel;
+	// private AsmManager structureModel;
 	public AjBuildConfig buildConfig;
 	private boolean ignoreOutxml;
 	private boolean wasFullBuild = true; // true if last build was a full build rather than an incremental build
@@ -257,7 +257,8 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 			if (isFullBuild) {
 				// System.err.println("XXXX batch: " + buildConfig.getFiles());
 				if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {
-					getWorld().setModel(AsmManager.getDefault().getHierarchy());
+					AsmManager.setLastActiveStructureModel(state.getStructureModel());
+					getWorld().setModel(state.getStructureModel());
 					// in incremental build, only get updated model?
 				}
 				binarySourcesForTheNextCompile = state.getBinaryFilesToCompile(true);
@@ -265,13 +266,15 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 				state.clearBinarySourceFiles(); // we don't want these hanging around...
 				if (!proceedOnError() && handler.hasErrors()) {
 					CompilationAndWeavingContext.leavingPhase(ct);
-					if (AsmManager.isReporting())
-						AsmManager.getDefault().reportModelInfo("After a batch build");
+					if (AsmManager.isReporting()) {
+						state.getStructureModel().reportModelInfo("After a batch build");
+					}
 					return false;
 				}
 
-				if (AsmManager.isReporting())
-					AsmManager.getDefault().reportModelInfo("After a batch build");
+				if (AsmManager.isReporting()) {
+					state.getStructureModel().reportModelInfo("After a batch build");
+				}
 
 			} else {
 				// done already?
@@ -279,13 +282,15 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 				// bcelWorld.setModel(StructureModelManager.INSTANCE.getStructureModel());
 				// }
 				// System.err.println("XXXX start inc ");
+				AsmManager.setLastActiveStructureModel(state.getStructureModel());
 				binarySourcesForTheNextCompile = state.getBinaryFilesToCompile(true);
 				Set files = state.getFilesToCompile(true);
-				if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode())
+				if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {
 					if (AsmManager.attemptIncrementalModelRepairs) {
-						AsmManager.getDefault().resetDeltaProcessing();
-						AsmManager.getDefault().processDelta(files, state.getAddedFiles(), state.getDeletedFiles());
+						state.getStructureModel().resetDeltaProcessing();
+						state.getStructureModel().processDelta(files, state.getAddedFiles(), state.getDeletedFiles());
 					}
+				}
 				boolean hereWeGoAgain = !(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
 				for (int i = 0; (i < 5) && hereWeGoAgain; i++) {
 					if (state.listenerDefined())
@@ -317,27 +322,28 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 					if (hereWeGoAgain) {
 						if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode())
 							if (AsmManager.attemptIncrementalModelRepairs)
-								AsmManager.getDefault().processDelta(files, state.getAddedFiles(), state.getDeletedFiles());
+								state.getStructureModel().processDelta(files, state.getAddedFiles(), state.getDeletedFiles());
 					}
 				}
 				if (!files.isEmpty()) {
 					CompilationAndWeavingContext.leavingPhase(ct);
 					return batchBuild(buildConfig, baseHandler);
 				} else {
-					if (AsmManager.isReporting())
-						AsmManager.getDefault().reportModelInfo("After an incremental build");
+					if (AsmManager.isReporting()) {
+						state.getStructureModel().reportModelInfo("After an incremental build");
+					}
 				}
 			}
 
 			// XXX not in Mik's incremental
 			if (buildConfig.isEmacsSymMode()) {
-				new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel();
+				new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel(state.getStructureModel());
 			}
 
 			// for bug 113554: support ajsym file generation for command line builds
 			if (buildConfig.isGenerateCrossRefsMode()) {
 				File configFileProxy = new File(buildConfig.getOutputDir(), CROSSREFS_FILE_NAME);
-				AsmManager.getDefault().writeStructureModel(configFileProxy.getAbsolutePath());
+				state.getStructureModel().writeStructureModel(configFileProxy.getAbsolutePath());
 			}
 
 			// have to tell state we succeeded or next is not incremental
@@ -359,7 +365,7 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 			// but always returns true
 			// XXX weaved not in Mik's incremental
 			if (buildConfig.isGenerateModelMode()) {
-				AsmManager.getDefault().fireModelUpdated();
+				state.getStructureModel().fireModelUpdated();
 			}
 			CompilationAndWeavingContext.leavingPhase(ct);
 
@@ -719,13 +725,16 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 	 * This code is driven before each 'fresh' (batch) build to create a new model.
 	 */
 	private void setupModel(AjBuildConfig config) {
-		AsmManager.setCreatingModel(config.isEmacsSymMode() || config.isGenerateModelMode());
-		if (!AsmManager.isCreatingModel())
+		if (!(config.isEmacsSymMode() || config.isGenerateModelMode())) {
 			return;
+		}
+		// AsmManager.setCreatingModel(config.isEmacsSymMode() || config.isGenerateModelMode());
+		// if (!AsmManager.isCreatingModel())
+		// return;
 
-		AsmManager.getDefault().createNewASM();
+		AsmManager structureModel = AsmManager.createNewStructureModel();
 		// AsmManager.getDefault().getRelationshipMap().clear();
-		IHierarchy model = AsmManager.getDefault().getHierarchy();
+		IHierarchy model = structureModel.getHierarchy();
 		String rootLabel = "<root>";
 
 		IProgramElement.Kind kind = IProgramElement.Kind.FILE_JAVA;
@@ -734,12 +743,12 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 			model.setConfigFile(buildConfig.getConfigFile().getAbsolutePath());
 			kind = IProgramElement.Kind.FILE_LST;
 		}
-		model.setRoot(new ProgramElement(rootLabel, kind, new ArrayList()));
+		model.setRoot(new ProgramElement(structureModel, rootLabel, kind, new ArrayList()));
 
 		model.setFileMap(new HashMap());
-		setStructureModel(model);
-		state.setStructureModel(model);
-		state.setRelationshipMap(AsmManager.getDefault().getRelationshipMap());
+		// setStructureModel(model);
+		state.setStructureModel(structureModel);
+		// state.setRelationshipMap(AsmManager.getDefault().getRelationshipMap());
 	}
 
 	//    
@@ -1230,15 +1239,16 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 		return buf.toString();
 	}
 
-	public void setStructureModel(IHierarchy structureModel) {
-		this.structureModel = structureModel;
-	}
+	//
+	// public void setStructureModel(IHierarchy structureModel) {
+	// this.structureModel = structureModel;
+	// }
 
 	/**
 	 * Returns null if there is no structure model
 	 */
-	public IHierarchy getStructureModel() {
-		return structureModel;
+	public AsmManager getStructureModel() {
+		return (state == null ? null : state.getStructureModel());
 	}
 
 	public IProgressListener getProgressListener() {
@@ -32,8 +32,7 @@ import java.util.Map;
 import java.util.Set;
 
 import org.aspectj.ajdt.internal.compiler.InterimCompilationResult;
-import org.aspectj.asm.IHierarchy;
-import org.aspectj.asm.IRelationshipMap;
+import org.aspectj.asm.AsmManager;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.Message;
 import org.aspectj.bridge.SourceLocation;
@@ -72,9 +71,10 @@ public class AjState implements CompilerConfigurationChangeFlags {
 	private final AjBuildManager buildManager;
 	private boolean couldBeSubsequentIncrementalBuild = false;
 	private INameEnvironment nameEnvironment;
-
-	private IHierarchy structureModel;
-	private IRelationshipMap relmap;
+	//
+	// private IHierarchy structureModel;
+	// private IRelationshipMap relmap;
+	private AsmManager structureModel;
 
 	/**
 	 * When looking at changes on the classpath, this set accumulates files in our state instance that affected by those changes.
@@ -497,7 +497,7 @@ public class AjState implements CompilerConfigurationChangeFlags {
 		return CLASS_FILE_NO_CHANGES;
 	}
 
-	private boolean isAspect(File file) {	
+	private boolean isAspect(File file) {
 		return aspectClassFiles.contains(file.getAbsolutePath());
 	}
 
@@ -1672,11 +1672,11 @@ public class AjState implements CompilerConfigurationChangeFlags {
 
 	}
 
-	public void setStructureModel(IHierarchy model) {
-		structureModel = model;
+	public void setStructureModel(AsmManager structureModel) {
+		this.structureModel = structureModel;
 	}
 
-	public IHierarchy getStructureModel() {
+	public AsmManager getStructureModel() {
 		return structureModel;
 	}
 
@@ -1696,13 +1696,14 @@ public class AjState implements CompilerConfigurationChangeFlags {
 		return world;
 	}
 
-	public void setRelationshipMap(IRelationshipMap irm) {
-		relmap = irm;
-	}
-
-	public IRelationshipMap getRelationshipMap() {
-		return relmap;
-	}
+	//
+	// public void setRelationshipMap(IRelationshipMap irm) {
+	// relmap = irm;
+	// }
+	//
+	// public IRelationshipMap getRelationshipMap() {
+	// return relmap;
+	// }
 
 	public int getNumberOfStructuralChangesSinceLastFullBuild() {
 		return structuralChangesSinceLastFullBuild.size();
@@ -1820,7 +1821,7 @@ public class AjState implements CompilerConfigurationChangeFlags {
 
 	public void wipeAllKnowledge() {
 		buildManager.state = null;
-		buildManager.setStructureModel(null);
+		// buildManager.setStructureModel(null);
 	}
 
 	public Map getAspectNamesToFileNameMap() {
@@ -32,9 +32,7 @@ import org.aspectj.ajdt.internal.compiler.ast.PointcutDeclaration;
 import org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment;
 import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.asm.AsmManager;
-import org.aspectj.asm.IHierarchy;
 import org.aspectj.asm.IProgramElement;
-import org.aspectj.asm.IRelationship;
 import org.aspectj.asm.internal.CharOperation;
 import org.aspectj.asm.internal.ProgramElement;
 import org.aspectj.bridge.ISourceLocation;
@@ -87,7 +85,7 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 	protected AsmElementFormatter formatter = new AsmElementFormatter();
 	// pr148027 - stop generating uses pointcut/pointcut used by relationship
 	// until we do it in the same way as other relationships.
-	public static boolean shouldAddUsesPointcut = false;
+	// public static boolean shouldAddUsesPointcut = false;
 	/**
 	 * Reset for every compilation unit.
 	 */
@@ -111,7 +109,7 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 	 * @param buildConfig
 	 * @param structureModel hiearchy to add this unit's declarations to
 	 */
-	public void buildStructureForCompilationUnit(CompilationUnitDeclaration cuDeclaration, IHierarchy structureModel,
+	public void buildStructureForCompilationUnit(CompilationUnitDeclaration cuDeclaration, AsmManager structureModel,
 			AjBuildConfig buildConfig) {
 		currCompilationResult = cuDeclaration.compilationResult();
 		filename = new String(currCompilationResult.fileName);
@@ -127,64 +125,73 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 		// throw new RuntimeException("not implemented");
 	}
 
-	private void internalBuild(CompilationUnitDeclaration unit, IHierarchy structureModel) {
+	private void internalBuild(CompilationUnitDeclaration unit, AsmManager structureModel) {
 		LangUtil.throwIaxIfNull(structureModel, "structureModel");
-		// if (!currCompilationResult.equals(unit.compilationResult())) {
-		// throw new IllegalArgumentException("invalid unit: " + unit);
-		// }
-		// ---- summary
-		// add unit to package (or root if no package),
-		// first removing any duplicate (XXX? removes children if 3 classes in
-		// same file?)
-		// push the node on the stack
-		// and traverse
-
-		// -- create node to add
-		final File file = new File(new String(unit.getFileName()));
-		final IProgramElement cuNode;
-		{
-			// AMC - use the source start and end from the compilation unit decl
-			int startLine = getStartLine(unit);
-			int endLine = getEndLine(unit);
-			SourceLocation sourceLocation = new SourceLocation(file, startLine, endLine);
-			sourceLocation.setOffset(unit.sourceStart);
-			cuNode = new ProgramElement(new String(file.getName()), IProgramElement.Kind.FILE_JAVA, sourceLocation, 0, null, null);
-		}
-
-		cuNode.addChild(new ProgramElement("import declarations", IProgramElement.Kind.IMPORT_REFERENCE, null, 0, null, null));
-
-		final IProgramElement addToNode = genAddToNode(file, unit, structureModel);
+		try {
+			activeStructureModel = structureModel;
+			// if (!currCompilationResult.equals(unit.compilationResult())) {
+			// throw new IllegalArgumentException("invalid unit: " + unit);
+			// }
+			// ---- summary
+			// add unit to package (or root if no package),
+			// first removing any duplicate (XXX? removes children if 3 classes in
+			// same file?)
+			// push the node on the stack
+			// and traverse
+
+			// -- create node to add
+			final File file = new File(new String(unit.getFileName()));
+			final IProgramElement cuNode;
+			{
+				// AMC - use the source start and end from the compilation unit decl
+				int startLine = getStartLine(unit);
+				int endLine = getEndLine(unit);
+				SourceLocation sourceLocation = new SourceLocation(file, startLine, endLine);
+				sourceLocation.setOffset(unit.sourceStart);
+				cuNode = new ProgramElement(structureModel, new String(file.getName()), IProgramElement.Kind.FILE_JAVA,
+						sourceLocation, 0, null, null);
+			}
 
-		// -- remove duplicates before adding (XXX use them instead?)
-		if (addToNode != null && addToNode.getChildren() != null) {
-			for (ListIterator itt = addToNode.getChildren().listIterator(); itt.hasNext();) {
-				IProgramElement child = (IProgramElement) itt.next();
-				ISourceLocation childLoc = child.getSourceLocation();
-				if (null == childLoc) {
-					// XXX ok, packages have null source locations
-					// signal others?
-				} else if (childLoc.getSourceFile().equals(file)) {
-					itt.remove();
+			cuNode.addChild(new ProgramElement(structureModel, "import declarations", IProgramElement.Kind.IMPORT_REFERENCE, null,
+					0, null, null));
+
+			final IProgramElement addToNode = genAddToNode(file, unit, structureModel);
+
+			// -- remove duplicates before adding (XXX use them instead?)
+			if (addToNode != null && addToNode.getChildren() != null) {
+				for (ListIterator itt = addToNode.getChildren().listIterator(); itt.hasNext();) {
+					IProgramElement child = (IProgramElement) itt.next();
+					ISourceLocation childLoc = child.getSourceLocation();
+					if (null == childLoc) {
+						// XXX ok, packages have null source locations
+						// signal others?
+					} else if (childLoc.getSourceFile().equals(file)) {
+						itt.remove();
+					}
 				}
 			}
-		}
-		// -- add and traverse
-		addToNode.addChild(cuNode);
-		stack.push(cuNode);
-		unit.traverse(this, unit.scope);
+			// -- add and traverse
+			addToNode.addChild(cuNode);
+			stack.push(cuNode);
+			unit.traverse(this, unit.scope);
 
-		// -- update file map (XXX do this before traversal?)
-		try {
-			structureModel.addToFileMap(file.getCanonicalPath(), cuNode);
-		} catch (IOException e) {
-			System.err.println("IOException " + e.getMessage() + " creating path for " + file);
-			// XXX signal IOException when canonicalizing file path
+			// -- update file map (XXX do this before traversal?)
+			try {
+				structureModel.getHierarchy().addToFileMap(file.getCanonicalPath(), cuNode);
+			} catch (IOException e) {
+				System.err.println("IOException " + e.getMessage() + " creating path for " + file);
+				// XXX signal IOException when canonicalizing file path
+			}
+		} finally {
+			activeStructureModel = null;
 		}
 
 	}
 
-	private IProgramElement findOrCreateChildSourceFolder(String sourceFolder, IHierarchy structureModel) {
-		IProgramElement root = structureModel.getRoot();
+	private AsmManager activeStructureModel = null;
+
+	private IProgramElement findOrCreateChildSourceFolder(String sourceFolder, AsmManager structureModel) {
+		IProgramElement root = structureModel.getHierarchy().getRoot();
 		// Check if already there
 		IProgramElement sourceFolderNode = null;
 		List kids = root.getChildren();
@@ -196,7 +203,7 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 			}
 		}
 		if (sourceFolderNode == null) {
-			sourceFolderNode = new ProgramElement(sourceFolder, IProgramElement.Kind.SOURCE_FOLDER, new ArrayList());
+			sourceFolderNode = new ProgramElement(structureModel, sourceFolder, IProgramElement.Kind.SOURCE_FOLDER, new ArrayList());
 			root.addChild(sourceFolderNode);
 		}
 		return sourceFolderNode;
@@ -205,7 +212,7 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 	/**
 	 * Get/create the node (package or root) to add to.
 	 */
-	private IProgramElement genAddToNode(File sourceFile, CompilationUnitDeclaration unit, IHierarchy structureModel) {
+	private IProgramElement genAddToNode(File sourceFile, CompilationUnitDeclaration unit, AsmManager structureModel) {
 		final IProgramElement addToNode;
 		{
 
@@ -223,7 +230,7 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 			// }
 			// } else {
 
-			IProgramElement rootForSource = structureModel.getRoot();
+			IProgramElement rootForSource = structureModel.getHierarchy().getRoot();
 			if (sourceFolder != null) {
 				rootForSource = findOrCreateChildSourceFolder(sourceFolder, structureModel);
 			}
@@ -244,7 +251,7 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 			}
 
 			IProgramElement pkgNode = null;
-			if (structureModel != null && structureModel.getRoot() != null && rootForSource.getChildren() != null) {
+			if (structureModel != null && structureModel.getHierarchy().getRoot() != null && rootForSource.getChildren() != null) {
 				for (Iterator it = rootForSource.getChildren().iterator(); it.hasNext();) {
 					IProgramElement currNode = (IProgramElement) it.next();
 					if (pkgName.equals(currNode.getName())) {
@@ -255,7 +262,7 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 			}
 			if (pkgNode == null) {
 				// note packages themselves have no source location
-				pkgNode = new ProgramElement(pkgName, IProgramElement.Kind.PACKAGE, new ArrayList());
+				pkgNode = new ProgramElement(activeStructureModel, pkgName, IProgramElement.Kind.PACKAGE, new ArrayList());
 				rootForSource.addChild(pkgNode);
 			}
 			addToNode = pkgNode;
@@ -300,11 +307,11 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 						// Create the ImportReference needed to add a
 						// ProgramElement
 						ImportReference importRef = new ImportReference(path, new long[] { 0 }, false, 0);
-						ProgramElement ceNode = new ProgramElement(importRef.toString(), IProgramElement.Kind.IMPORT_REFERENCE,
-								makeLocation(importRef), 0, null, null);
+						IProgramElement ceNode = new ProgramElement(activeStructureModel, importRef.toString(),
+								IProgramElement.Kind.IMPORT_REFERENCE, makeLocation(importRef), 0, null, null);
 						ceNode.setSourceSignature(genSourceSignature(importRef));
 						// Add Element to Imports of Current Class
-						ProgramElement imports = (ProgramElement) ((ProgramElement) stack.peek()).getChildren().get(0);
+						ProgramElement imports = (ProgramElement) ((IProgramElement) stack.peek()).getChildren().get(0);
 						imports.addChild(0, ceNode);
 					}
 				}
@@ -316,7 +323,8 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 			typeModifiers = ((AspectDeclaration) typeDeclaration).getDeclaredModifiers();
 		}
 
-		IProgramElement peNode = new ProgramElement(name, kind, makeLocation(typeDeclaration), typeModifiers, null, null);
+		IProgramElement peNode = new ProgramElement(activeStructureModel, name, kind, makeLocation(typeDeclaration), typeModifiers,
+				null, null);
 		peNode.setSourceSignature(genSourceSignature(typeDeclaration));
 		peNode.setFormalComment(generateJavadocComment(typeDeclaration));
 
@@ -360,7 +368,8 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 			typeModifiers = ((AspectDeclaration) memberTypeDeclaration).getDeclaredModifiers();
 		}
 
-		IProgramElement peNode = new ProgramElement(name, kind, makeLocation(memberTypeDeclaration), typeModifiers, null, null);
+		IProgramElement peNode = new ProgramElement(activeStructureModel, name, kind, makeLocation(memberTypeDeclaration),
+				typeModifiers, null, null);
 		peNode.setSourceSignature(genSourceSignature(memberTypeDeclaration));
 		peNode.setFormalComment(generateJavadocComment(memberTypeDeclaration));
 
@@ -409,7 +418,7 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 			}
 		}
 
-		IProgramElement peNode = new ProgramElement(fullName, kind, makeLocation(memberTypeDeclaration),
+		IProgramElement peNode = new ProgramElement(activeStructureModel, fullName, kind, makeLocation(memberTypeDeclaration),
 				memberTypeDeclaration.modifiers, null, null);
 		peNode.setSourceSignature(genSourceSignature(memberTypeDeclaration));
 		peNode.setFormalComment(generateJavadocComment(memberTypeDeclaration));
@@ -461,19 +470,19 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 		if (methodDeclaration instanceof InterTypeDeclaration) {
 			InterTypeDeclaration itd = (InterTypeDeclaration) methodDeclaration;
 			ResolvedMember sig = itd.getSignature();
-			peNode = new ProgramElement(null, IProgramElement.Kind.ERROR, makeLocation(methodDeclaration), (sig != null ? sig
-					.getModifiers() : 0), null, null);
+			peNode = new ProgramElement(activeStructureModel, null, IProgramElement.Kind.ERROR, makeLocation(methodDeclaration),
+					(sig != null ? sig.getModifiers() : 0), null, null);
 
 		} else {
-			peNode = new ProgramElement(null, IProgramElement.Kind.ERROR, makeLocation(methodDeclaration),
+			peNode = new ProgramElement(activeStructureModel, null, IProgramElement.Kind.ERROR, makeLocation(methodDeclaration),
 					methodDeclaration.modifiers, null, null);
 		}
 		formatter.genLabelAndKind(methodDeclaration, peNode); // will set the
 		// name
 		genBytecodeInfo(methodDeclaration, peNode);
 		List namedPointcuts = genNamedPointcuts(methodDeclaration);
-		if (shouldAddUsesPointcut)
-			addUsesPointcutRelationsForNode(peNode, namedPointcuts, methodDeclaration);
+		// if (shouldAddUsesPointcut)
+		// addUsesPointcutRelationsForNode(peNode, namedPointcuts, methodDeclaration);
 
 		if (methodDeclaration.returnType != null) {
 			// if we don't make the distinction between ITD fields and other
@@ -508,24 +517,24 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 		return true;
 	}
 
-	private void addUsesPointcutRelationsForNode(IProgramElement peNode, List namedPointcuts, MethodDeclaration declaration) {
-		for (Iterator it = namedPointcuts.iterator(); it.hasNext();) {
-			ReferencePointcut rp = (ReferencePointcut) it.next();
-			ResolvedMember member = getPointcutDeclaration(rp, declaration);
-			if (member != null) {
-				IRelationship foreward = AsmManager.getDefault().getRelationshipMap().get(peNode.getHandleIdentifier(),
-						IRelationship.Kind.USES_POINTCUT, "uses pointcut", false, true);
-				IProgramElement forwardIPE = AsmManager.getDefault().getHierarchy().findElementForSourceLine(
-						member.getSourceLocation());
-				foreward.addTarget(AsmManager.getDefault().getHandleProvider().createHandleIdentifier(forwardIPE));
-
-				IRelationship back = AsmManager.getDefault().getRelationshipMap().get(
-						AsmManager.getDefault().getHandleProvider().createHandleIdentifier(forwardIPE),
-						IRelationship.Kind.USES_POINTCUT, "pointcut used by", false, true);
-				back.addTarget(peNode.getHandleIdentifier());
-			}
-		}
-	}
+	// private void addUsesPointcutRelationsForNode(IProgramElement peNode, List namedPointcuts, MethodDeclaration declaration) {
+	// for (Iterator it = namedPointcuts.iterator(); it.hasNext();) {
+	// ReferencePointcut rp = (ReferencePointcut) it.next();
+	// ResolvedMember member = getPointcutDeclaration(rp, declaration);
+	// if (member != null) {
+	// IRelationship foreward = AsmManager.getDefault().getRelationshipMap().get(peNode.getHandleIdentifier(),
+	// IRelationship.Kind.USES_POINTCUT, "uses pointcut", false, true);
+	// IProgramElement forwardIPE = AsmManager.getDefault().getHierarchy().findElementForSourceLine(
+	// member.getSourceLocation());
+	// foreward.addTarget(AsmManager.getDefault().getHandleProvider().createHandleIdentifier(forwardIPE));
+	//
+	// IRelationship back = AsmManager.getDefault().getRelationshipMap().get(
+	// AsmManager.getDefault().getHandleProvider().createHandleIdentifier(forwardIPE),
+	// IRelationship.Kind.USES_POINTCUT, "pointcut used by", false, true);
+	// back.addTarget(peNode.getHandleIdentifier());
+	// }
+	// }
+	// }
 
 	private ResolvedMember getPointcutDeclaration(ReferencePointcut rp, MethodDeclaration declaration) {
 		EclipseFactory factory = ((AjLookupEnvironment) declaration.scope.environment()).factory;
@@ -672,10 +681,10 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 		if (dotIndex != -1) {
 			currPackageImport = importRef.toString().substring(0, dotIndex);
 		}
-		if (!((ProgramElement) stack.peek()).getPackageName().equals(currPackageImport)) {
+		if (!((IProgramElement) stack.peek()).getPackageName().equals(currPackageImport)) {
 
-			ProgramElement peNode = new ProgramElement(new String(importRef.toString()), IProgramElement.Kind.IMPORT_REFERENCE,
-					makeLocation(importRef), 0,// could set static here, but for
+			ProgramElement peNode = new ProgramElement(activeStructureModel, new String(importRef.toString()),
+					IProgramElement.Kind.IMPORT_REFERENCE, makeLocation(importRef), 0,// could set static here, but for
 					// some reason the info is
 					// private
 					null, null);
@@ -686,7 +695,7 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 			// create Source signature for import
 			peNode.setSourceSignature(genSourceSignature(importRef));
 
-			ProgramElement imports = (ProgramElement) ((ProgramElement) stack.peek()).getChildren().get(0);
+			ProgramElement imports = (ProgramElement) ((IProgramElement) stack.peek()).getChildren().get(0);
 			imports.addChild(0, peNode);
 			stack.push(peNode);
 		}
@@ -699,7 +708,7 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 		if (dotIndex != -1) {
 			currPackageImport = importRef.toString().substring(0, dotIndex);
 		}
-		if (!((ProgramElement) stack.peek()).getPackageName().equals(currPackageImport)) {
+		if (!((IProgramElement) stack.peek()).getPackageName().equals(currPackageImport)) {
 			stack.pop();
 		}
 	}
@@ -717,11 +726,11 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 		IProgramElement peNode = null;
 		if (fieldDeclaration.type == null) { // The field represents an enum
 			// value
-			peNode = new ProgramElement(new String(fieldDeclaration.name), IProgramElement.Kind.ENUM_VALUE,
+			peNode = new ProgramElement(activeStructureModel, new String(fieldDeclaration.name), IProgramElement.Kind.ENUM_VALUE,
 					makeLocation(fieldDeclaration), fieldDeclaration.modifiers, null, null);
 			peNode.setCorrespondingType(fieldDeclaration.binding.type.debugName());
 		} else {
-			peNode = new ProgramElement(new String(fieldDeclaration.name), IProgramElement.Kind.FIELD,
+			peNode = new ProgramElement(activeStructureModel, new String(fieldDeclaration.name), IProgramElement.Kind.FIELD,
 					makeLocation(fieldDeclaration), fieldDeclaration.modifiers, null, null);
 			peNode.setCorrespondingType(fieldDeclaration.type.toString());
 		}
@@ -859,8 +868,9 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 			}
 		}
 		argumentsSignature.append(")");
-		IProgramElement peNode = new ProgramElement(new String(constructorDeclaration.selector), IProgramElement.Kind.CONSTRUCTOR,
-				makeLocation(constructorDeclaration), constructorDeclaration.modifiers, null, null);
+		IProgramElement peNode = new ProgramElement(activeStructureModel, new String(constructorDeclaration.selector),
+				IProgramElement.Kind.CONSTRUCTOR, makeLocation(constructorDeclaration), constructorDeclaration.modifiers, null,
+				null);
 		formatter.setParameters(constructorDeclaration, peNode);
 		peNode.setModifiers(constructorDeclaration.modifiers);
 		peNode.setSourceSignature(genSourceSignature(constructorDeclaration));
@@ -956,8 +966,8 @@ public class AsmHierarchyBuilder extends ASTVisitor {
 			return false;
 		inInitializer = initializer;
 
-		IProgramElement peNode = new ProgramElement("...", IProgramElement.Kind.INITIALIZER, makeLocation(initializer),
-				initializer.modifiers, null, null);
+		IProgramElement peNode = new ProgramElement(activeStructureModel, "...", IProgramElement.Kind.INITIALIZER,
+				makeLocation(initializer), initializer.modifiers, null, null);
 		// "",
 		// new ArrayList());
 		((IProgramElement) stack.peek()).addChild(peNode);
@@ -11,217 +11,220 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.ajdt.internal.core.builder;
 
-import java.io.*;
-import java.util.*;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
 
-import org.aspectj.asm.*;
-//import org.aspectj.ajde.compiler.AjdeCompiler;
+import org.aspectj.asm.AsmManager;
+import org.aspectj.asm.IProgramElement;
 
-/** 
+/**
  * @author Mik Kersten
  */
 public class EmacsStructureModelManager {
 
-    private static final String EXTERN_FILE_SUFFIX = ".ajesym";
-
-    public EmacsStructureModelManager() {
-        super();
-    }
-
-    public void externalizeModel() {
-    	if (!AsmManager.getDefault().getHierarchy().isValid()) return;
-        
-        try {
-            //Set fileSet = StructureModelManager.INSTANCE.getStructureModel().getFileMap().entrySet(); 
-			Set fileSet = AsmManager.getDefault().getHierarchy().getFileMapEntrySet(); 
-            for (Iterator it = fileSet.iterator(); it.hasNext(); ) {
-                IProgramElement peNode = (IProgramElement)((Map.Entry)it.next()).getValue();
-                dumpStructureToFile(peNode);
-            }
-        } catch (IOException ioe) {
-            ioe.printStackTrace();
-        }
-    }
-
-//    private void dumpStructureToFile(ProgramElementNode node) throws IOException {
-//        String sourceName = node.getSourceLocation().getSourceFilePath();
-//        String fileName = sourceName.substring(0, sourceName.lastIndexOf(".")) + EXTERN_FILE_SUFFIX;
-//        BufferedWriter writer = new BufferedWriter(new FileWriter(new File(fileName)));
-//        new SExpressionPrinter(writer).printDecls(node);
-//        writer.flush();
-//    }
-
-    private void dumpStructureToFile(IProgramElement node) throws IOException {
-        String s = node.getKind().toString();
-        if (!  (s.equals(IProgramElement.Kind.FILE_ASPECTJ.toString())
-                || s.equals(IProgramElement.Kind.FILE_JAVA.toString()))) {
-            throw new IllegalArgumentException("externalize file, not " + node);
-        }
-        // source files have source locations
-        String sourceName = node.getSourceLocation().getSourceFile().getAbsolutePath();
-        String fileName = sourceName.substring(0, sourceName.lastIndexOf(".")) + EXTERN_FILE_SUFFIX;
-        BufferedWriter writer = null;
-        try {
-            writer = new BufferedWriter(new FileWriter(new File(fileName)));
-            new SExpressionPrinter(writer).printDecls(node);
-            writer.flush();
-        } finally {
-            if (writer != null) {
-                try {  
-                    writer.close();
-                } catch (IOException e) {} // ignore
-            }
-        }
-    }
-
-    /**
-     * This class was not written in an OO style.
-     */
-    private static class SExpressionPrinter {
-
-        private BufferedWriter writer = null;
-
-        public SExpressionPrinter(BufferedWriter writer) {
-            this.writer = writer;
-        }
-
-        private void printDecls(IProgramElement node) {
-            print("(");
-            for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
-                // this ignores relations on the compile unit
-                Object nodeObject = it.next();
-//				throw new RuntimeException("unimplemented");
-//                if (nodeObject instanceof IProgramElement) {
-                    IProgramElement child = (IProgramElement)nodeObject;
-                    printDecl(child, true);
-//                } 
-//                else if (nodeObject instanceof LinkNode) {
-//                    LinkNode child = (LinkNode)nodeObject;
-//                    printDecl(child.getProgramElementNode(), false);
-//                }
-            }
-            print(") ");
-        }
-
-//        private void printDecls(IRelationship node) {
-////            for (Iterator it = node.getTargets().iterator(); it.hasNext(); ) {
-////                // this ignores relations on the compile unit
-////                Object nodeObject = it.next();
-////                throw new RuntimeException("unimplemented");
-//////                if (nodeObject instanceof LinkNode) {
-//////                    LinkNode child = (LinkNode)nodeObject;
-//////                    if (//!child.getProgramElementNode().getKind().equals("stmnt") &&
-//////                        !child.getProgramElementNode().getKind().equals("<undefined>")) {
-//////                        printDecl(child.getProgramElementNode(), false);
-////////                        printDecl(child.getProgramElementNode(), false);
-//////                    }
-//////                }
-////            }
-//        }
-
-        /**
-         * @param   structureNode   can be a ProgramElementNode or a LinkNode
-         */
-        private void printDecl(IProgramElement node, boolean recurse) {
-        	if (node == null || node.getSourceLocation() == null) return;
-            String kind = node.getKind().toString().toLowerCase();
-            print("(");
-            print("(" + node.getSourceLocation().getLine() + " . " + node.getSourceLocation().getColumn() + ") ");
-            print("(" + node.getSourceLocation().getLine() + " . " + node.getSourceLocation().getColumn() + ") ");
-            print(kind + " ");                                     //2
-
-            // HACK:
-            String displayName = node.toString().replace('\"', ' ');
-
-            print("\"" + displayName + "\" ");
-            if (node.getSourceLocation().getSourceFile().getAbsolutePath() != null) {
-                print("\"" + fixFilename(node.getSourceLocation().getSourceFile().getAbsolutePath()) + "\"");  //4
-            } else {
-                print("nil");
-            }
-            if (node.getName() != null) {
-                print("\"" + node.getDeclaringType() + "\" ");         //5
-            } else {
-                print("nil");
-            }
-
-            if (!recurse) {
-                print("nil");
-                print("nil");
-                print("nil");
-            } else {
-                print("(");
-//                if (node instanceof IProgramElement) {
-//                    java.util.List relations = ((IProgramElement)node).getRelations();
-//                    if (relations != null) {
-//                        for (Iterator it = relations.iterator(); it.hasNext(); ) {
-//							IRelationship relNode = (IRelationship)it.next();
-//                            if (relNode.getKind() == IRelationship.Kind.ADVICE ||
-//								relNode.getKind() == IRelationship.Kind.DECLARE) {
-//                                printDecls(relNode);                                   // 6
-//                            }
-//                        }
-//                    }
-//                }
-                print(") ");
-                print("(");
-                print(") ");
-                print("(");
-                Iterator it3 = node.getChildren().iterator();
-                if (it3.hasNext()) {
-                    while (it3.hasNext()) {
-                        // this ignores relations on the compile unit
-                        Object nodeObject = it3.next();
-                        if (nodeObject instanceof IProgramElement) {
-                            IProgramElement currNode = (IProgramElement)nodeObject;
-                            if (//!currNode.isStmntKind() &&
-                                !currNode.getKind().equals("<undefined>")) {
-                                printDecl(currNode, true);
-                            }
-                        }
-                    }
-                }
-                print(") ");
-            }
-
-            print(node.getKind().equals("class") ? "t " : "nil ");        // 9
-//            print(node.getKind().equals("introduction") ? "t " : "nil "); // 10
-            print(node.getKind().equals("introduction") ? "nil " : "nil "); // 10
-            print("nil ");            // 11
-            print("nil ");       // 12
-            print(")");
-        }
-
-        String fixFilename(String filename) {
-            return subst("\\\\", "\\", filename);
-        }
-
-        private void print(String string) {
-            try {
-                writer.write(string + "\n");
-            } catch (IOException ioe) {
-                ioe.printStackTrace();
-            }
-        }
-
-        private String subst(String n, String o, String in) {
-            int pos = in.indexOf(o);
-            if (pos == -1)
-                return in;
-            return in.substring(0, pos) +
-                   n +
-                   subst(n, o, (in.substring(pos + o.length())));
-        }
-
-//        private void lose(Error e) {
-//            try {
-//                print("(ERROR \"" + e.toString() + "\")");
-//            }
-//            catch(Error ex) { }
-//        }
-    }
+	private static final String EXTERN_FILE_SUFFIX = ".ajesym";
+
+	public EmacsStructureModelManager() {
+		super();
+	}
+
+	public void externalizeModel(AsmManager model) {
+		if (!model.getHierarchy().isValid())
+			return;
+
+		try {
+			// Set fileSet = StructureModelManager.INSTANCE.getStructureModel().getFileMap().entrySet();
+			Set fileSet = model.getHierarchy().getFileMapEntrySet();
+			for (Iterator it = fileSet.iterator(); it.hasNext();) {
+				IProgramElement peNode = (IProgramElement) ((Map.Entry) it.next()).getValue();
+				dumpStructureToFile(peNode);
+			}
+		} catch (IOException ioe) {
+			ioe.printStackTrace();
+		}
+	}
+
+	// private void dumpStructureToFile(ProgramElementNode node) throws IOException {
+	// String sourceName = node.getSourceLocation().getSourceFilePath();
+	// String fileName = sourceName.substring(0, sourceName.lastIndexOf(".")) + EXTERN_FILE_SUFFIX;
+	// BufferedWriter writer = new BufferedWriter(new FileWriter(new File(fileName)));
+	// new SExpressionPrinter(writer).printDecls(node);
+	// writer.flush();
+	// }
+
+	private void dumpStructureToFile(IProgramElement node) throws IOException {
+		String s = node.getKind().toString();
+		if (!(s.equals(IProgramElement.Kind.FILE_ASPECTJ.toString()) || s.equals(IProgramElement.Kind.FILE_JAVA.toString()))) {
+			throw new IllegalArgumentException("externalize file, not " + node);
+		}
+		// source files have source locations
+		String sourceName = node.getSourceLocation().getSourceFile().getAbsolutePath();
+		String fileName = sourceName.substring(0, sourceName.lastIndexOf(".")) + EXTERN_FILE_SUFFIX;
+		BufferedWriter writer = null;
+		try {
+			writer = new BufferedWriter(new FileWriter(new File(fileName)));
+			new SExpressionPrinter(writer).printDecls(node);
+			writer.flush();
+		} finally {
+			if (writer != null) {
+				try {
+					writer.close();
+				} catch (IOException e) {
+				} // ignore
+			}
+		}
+	}
+
+	/**
+	 * This class was not written in an OO style.
+	 */
+	private static class SExpressionPrinter {
+
+		private BufferedWriter writer = null;
+
+		public SExpressionPrinter(BufferedWriter writer) {
+			this.writer = writer;
+		}
+
+		private void printDecls(IProgramElement node) {
+			print("(");
+			for (Iterator it = node.getChildren().iterator(); it.hasNext();) {
+				// this ignores relations on the compile unit
+				Object nodeObject = it.next();
+				// throw new RuntimeException("unimplemented");
+				// if (nodeObject instanceof IProgramElement) {
+				IProgramElement child = (IProgramElement) nodeObject;
+				printDecl(child, true);
+				// }
+				// else if (nodeObject instanceof LinkNode) {
+				// LinkNode child = (LinkNode)nodeObject;
+				// printDecl(child.getProgramElementNode(), false);
+				// }
+			}
+			print(") ");
+		}
+
+		// private void printDecls(IRelationship node) {
+		// // for (Iterator it = node.getTargets().iterator(); it.hasNext(); ) {
+		// // // this ignores relations on the compile unit
+		// // Object nodeObject = it.next();
+		// // throw new RuntimeException("unimplemented");
+		// //// if (nodeObject instanceof LinkNode) {
+		// //// LinkNode child = (LinkNode)nodeObject;
+		// //// if (//!child.getProgramElementNode().getKind().equals("stmnt") &&
+		// //// !child.getProgramElementNode().getKind().equals("<undefined>")) {
+		// //// printDecl(child.getProgramElementNode(), false);
+		// ////// printDecl(child.getProgramElementNode(), false);
+		// //// }
+		// //// }
+		// // }
+		// }
+
+		/**
+		 * @param structureNode can be a ProgramElementNode or a LinkNode
+		 */
+		private void printDecl(IProgramElement node, boolean recurse) {
+			if (node == null || node.getSourceLocation() == null)
+				return;
+			String kind = node.getKind().toString().toLowerCase();
+			print("(");
+			print("(" + node.getSourceLocation().getLine() + " . " + node.getSourceLocation().getColumn() + ") ");
+			print("(" + node.getSourceLocation().getLine() + " . " + node.getSourceLocation().getColumn() + ") ");
+			print(kind + " "); // 2
+
+			// HACK:
+			String displayName = node.toString().replace('\"', ' ');
+
+			print("\"" + displayName + "\" ");
+			if (node.getSourceLocation().getSourceFile().getAbsolutePath() != null) {
+				print("\"" + fixFilename(node.getSourceLocation().getSourceFile().getAbsolutePath()) + "\""); // 4
+			} else {
+				print("nil");
+			}
+			if (node.getName() != null) {
+				print("\"" + node.getDeclaringType() + "\" "); // 5
+			} else {
+				print("nil");
+			}
+
+			if (!recurse) {
+				print("nil");
+				print("nil");
+				print("nil");
+			} else {
+				print("(");
+				// if (node instanceof IProgramElement) {
+				// java.util.List relations = ((IProgramElement)node).getRelations();
+				// if (relations != null) {
+				// for (Iterator it = relations.iterator(); it.hasNext(); ) {
+				// IRelationship relNode = (IRelationship)it.next();
+				// if (relNode.getKind() == IRelationship.Kind.ADVICE ||
+				// relNode.getKind() == IRelationship.Kind.DECLARE) {
+				// printDecls(relNode); // 6
+				// }
+				// }
+				// }
+				// }
+				print(") ");
+				print("(");
+				print(") ");
+				print("(");
+				Iterator it3 = node.getChildren().iterator();
+				if (it3.hasNext()) {
+					while (it3.hasNext()) {
+						// this ignores relations on the compile unit
+						Object nodeObject = it3.next();
+						if (nodeObject instanceof IProgramElement) {
+							IProgramElement currNode = (IProgramElement) nodeObject;
+							if (// !currNode.isStmntKind() &&
+							!currNode.getKind().equals("<undefined>")) {
+								printDecl(currNode, true);
+							}
+						}
+					}
+				}
+				print(") ");
+			}
+
+			print(node.getKind().equals("class") ? "t " : "nil "); // 9
+			// print(node.getKind().equals("introduction") ? "t " : "nil "); // 10
+			print(node.getKind().equals("introduction") ? "nil " : "nil "); // 10
+			print("nil "); // 11
+			print("nil "); // 12
+			print(")");
+		}
+
+		String fixFilename(String filename) {
+			return subst("\\\\", "\\", filename);
+		}
+
+		private void print(String string) {
+			try {
+				writer.write(string + "\n");
+			} catch (IOException ioe) {
+				ioe.printStackTrace();
+			}
+		}
+
+		private String subst(String n, String o, String in) {
+			int pos = in.indexOf(o);
+			if (pos == -1)
+				return in;
+			return in.substring(0, pos) + n + subst(n, o, (in.substring(pos + o.length())));
+		}
+
+		// private void lose(Error e) {
+		// try {
+		// print("(ERROR \"" + e.toString() + "\")");
+		// }
+		// catch(Error ex) { }
+		// }
+	}
 }
-
@@ -19,93 +19,97 @@ import java.util.List;
 import java.util.Set;
 
 import org.aspectj.ajdt.internal.compiler.CompilationResultDestinationManager;
-import org.aspectj.asm.AsmManager;
-
 
 /**
- * Central point for all things incremental...
- * - keeps track of the state recorded for each different config file
- * - allows limited interaction with these states
- *
- * - records dependency/change info for particular classpaths
- *   > this will become what JDT keeps in its 'State' object when its finished
+ * Central point for all things incremental... - keeps track of the state recorded for each different config file - allows limited
+ * interaction with these states
+ * 
+ * - records dependency/change info for particular classpaths > this will become what JDT keeps in its 'State' object when its
+ * finished
  */
 public class IncrementalStateManager {
 
 	// FIXME asc needs an API through Ajde for trashing its contents
 	// FIXME asc needs some memory mgmt (softrefs?) to recover memory
-	// SECRETAPI will consume more memory, so turn on at your own risk ;)  Set to 'true' when memory usage is understood
-	public  static boolean recordIncrementalStates = false;
-	public  static boolean debugIncrementalStates = false;
+	// SECRETAPI will consume more memory, so turn on at your own risk ;) Set to 'true' when memory usage is understood
+	public static boolean recordIncrementalStates = false;
+	public static boolean debugIncrementalStates = false;
 	private static Hashtable incrementalStates = new Hashtable();
-	
+
 	public static void recordSuccessfulBuild(String buildConfig, AjState state) {
-		if (!recordIncrementalStates) return;
-		incrementalStates.put(buildConfig,state);
+		if (!recordIncrementalStates)
+			return;
+		incrementalStates.put(buildConfig, state);
 	}
-	
+
 	public static boolean removeIncrementalStateInformationFor(String buildConfig) {
-		return incrementalStates.remove(buildConfig)!=null;
+		return incrementalStates.remove(buildConfig) != null;
 	}
-	
+
 	public static void clearIncrementalStates() {
 		for (Iterator iter = incrementalStates.values().iterator(); iter.hasNext();) {
 			AjState element = (AjState) iter.next();
 			element.wipeAllKnowledge();
 		}
 		incrementalStates.clear();
-		AsmManager.getDefault().createNewASM(); // forget what you know...
+		// AsmManager.getDefault().createNewStructureModel(); // forget what you know...
 	}
-	
+
 	public static Set getConfigFilesKnown() {
 		return incrementalStates.keySet();
 	}
 
 	public static AjState retrieveStateFor(String configFile) {
-		return (AjState)incrementalStates.get(configFile);
+		return (AjState) incrementalStates.get(configFile);
 	}
-	
+
 	// now, managing changes to entries on a classpath
-	
+
 	public static AjState findStateManagingOutputLocation(File location) {
 		Collection allStates = incrementalStates.values();
-		if (debugIncrementalStates) System.err.println("> findStateManagingOutputLocation("+location+") has "+allStates.size()+" states to look through");
+		if (debugIncrementalStates)
+			System.err.println("> findStateManagingOutputLocation(" + location + ") has " + allStates.size()
+					+ " states to look through");
 		for (Iterator iter = allStates.iterator(); iter.hasNext();) {
 			AjState element = (AjState) iter.next();
 			AjBuildConfig ajbc = element.getBuildConfig();
-			if (ajbc==null) {
+			if (ajbc == null) {
 				// FIXME asc why can it ever be null?
-				if (debugIncrementalStates) System.err.println("  No build configuration for state "+element);
+				if (debugIncrementalStates)
+					System.err.println("  No build configuration for state " + element);
 				continue;
 			}
 			File outputDir = ajbc.getOutputDir();
 			if (outputDir != null && outputDir.equals(location)) {
-				if (debugIncrementalStates) System.err.println("< findStateManagingOutputLocation("+location+") returning "+element);
-				return element;				
-			} 
+				if (debugIncrementalStates)
+					System.err.println("< findStateManagingOutputLocation(" + location + ") returning " + element);
+				return element;
+			}
 			CompilationResultDestinationManager outputManager = ajbc.getCompilationResultDestinationManager();
 			if (outputManager != null) {
 				List outputDirs = outputManager.getAllOutputLocations();
-				for (Iterator iterator = outputDirs.iterator(); iterator
-						.hasNext();) {
+				for (Iterator iterator = outputDirs.iterator(); iterator.hasNext();) {
 					File dir = (File) iterator.next();
 					if (dir.equals(location)) {
-						if (debugIncrementalStates) System.err.println("< findStateManagingOutputLocation("+location+") returning "+element);
-						return element;				
+						if (debugIncrementalStates)
+							System.err.println("< findStateManagingOutputLocation(" + location + ") returning " + element);
+						return element;
 					}
 				}
 			}
 			if (outputDir == null && outputManager == null) {
 				// FIXME why can it ever be null? due to using outjar?
-				if (debugIncrementalStates) System.err.println("  output directory and output location manager for "+ajbc+" are null");
+				if (debugIncrementalStates)
+					System.err.println("  output directory and output location manager for " + ajbc + " are null");
 				continue;
 			}
 
 		}
-		if (debugIncrementalStates) System.err.println("< findStateManagingOutputLocation("+location+") returning null");
+		if (debugIncrementalStates)
+			System.err.println("< findStateManagingOutputLocation(" + location + ") returning null");
 		return null;
 	}
-	
+
 	// FIXME asc needs a persistence mechanism for storing/loading all state info
 	// FIXME asc needs to understand two config files might point at the same output dir... what to do about this?
 }
\ No newline at end of file
@@ -20,8 +20,6 @@ import java.util.List;
 import junit.framework.AssertionFailedError;
 import junit.framework.TestCase;
 
-import org.aspectj.ajde.Ajde;
-import org.aspectj.ajde.IconRegistry;
 import org.aspectj.ajde.core.AjCompiler;
 import org.aspectj.ajde.ui.utils.TestBuildProgressMonitor;
 import org.aspectj.ajde.ui.utils.TestCompilerConfiguration;
@@ -29,118 +27,109 @@ import org.aspectj.ajde.ui.utils.TestEditorAdapter;
 import org.aspectj.ajde.ui.utils.TestIdeUIAdapter;
 import org.aspectj.ajde.ui.utils.TestMessageHandler;
 import org.aspectj.ajde.ui.utils.TestRuntimeProperties;
-import org.aspectj.asm.AsmManager;
 import org.aspectj.tools.ajc.Ajc;
 
 public class AjdeTestCase extends TestCase {
 
-    public final static String testdataSrcDir = "../ajde/testdata";
+	public final static String testdataSrcDir = "../ajde/testdata";
 	protected static File sandboxDir;
-	
+
 	private String projectDir;
-    
+
 	protected void setUp() throws Exception {
 		super.setUp();
 		// Create a sandbox in which to work
 		sandboxDir = Ajc.createEmptySandbox();
-		// AMC - added this next line as a temporary workaround for 
+		// AMC - added this next line as a temporary workaround for
 		// listener leakage in AsmManager induced by the Ajde test suite.
-		AsmManager.getDefault().removeAllListeners();
+		// Ajde.getDefault().getModel().removeAllListeners();
 	}
-	
+
 	protected void tearDown() throws Exception {
 		super.tearDown();
 		projectDir = null;
 		sandboxDir = null;
 	}
-	
+
 	/**
-	 * Fill in the working directory with the project files and
-	 * creates a compiler instance for this project
+	 * Fill in the working directory with the project files and creates a compiler instance for this project
 	 */
 	public void initialiseProject(String projectName) {
-		
-		
-		File projectSrc=new File(testdataSrcDir + File.separatorChar + projectName);
-		File destination=new File(getWorkingDir(),projectName);
-		if (!destination.exists()) {destination.mkdir();}
-		copy(projectSrc,destination);
+
+		File projectSrc = new File(testdataSrcDir + File.separatorChar + projectName);
+		File destination = new File(getWorkingDir(), projectName);
+		if (!destination.exists()) {
+			destination.mkdir();
+		}
+		copy(projectSrc, destination);
 		projectDir = destination.getAbsolutePath();
 
 		// need to initialize via AjdeUIManager
-		Ajde.getDefault().init(
-				new TestCompilerConfiguration(projectDir), 
-				new TestMessageHandler(), 
-				new TestBuildProgressMonitor(), 
-				new TestEditorAdapter(), 
-				new TestIdeUIAdapter(), 
-				new IconRegistry(), 
-				null, //new JFrame(), 
-				new TestRuntimeProperties(), 
-				true);
+		Ajde.getDefault().init(new TestCompilerConfiguration(projectDir), new TestMessageHandler(), new TestBuildProgressMonitor(),
+				new TestEditorAdapter(), new TestIdeUIAdapter(), new IconRegistry(), null, // new JFrame(),
+				new TestRuntimeProperties(), true);
 	}
-	
+
 	/**
 	 * @return the working directory
 	 */
-	protected File getWorkingDir() { 
-		return sandboxDir; 
+	protected File getWorkingDir() {
+		return sandboxDir;
 	}
-	
+
 	/**
-	 * @return the absolute path of the project directory
-	 * for example c:\temp\ajcSandbox\ajcTest15200.tmp\myProject
+	 * @return the absolute path of the project directory for example c:\temp\ajcSandbox\ajcTest15200.tmp\myProject
 	 */
 	protected String getAbsoluteProjectDir() {
 		return projectDir;
 	}
-	
+
 	/**
-	 * Copy the contents of some directory to another location - the
-	 * copy is recursive.
+	 * Copy the contents of some directory to another location - the copy is recursive.
 	 */
 	private void copy(File from, File to) {
 		String contents[] = from.list();
-		if (contents==null) return;
+		if (contents == null)
+			return;
 		for (int i = 0; i < contents.length; i++) {
 			String string = contents[i];
-			File f = new File(from,string);
-			File t = new File(to,string);
-			
+			File f = new File(from, string);
+			File t = new File(to, string);
+
 			if (f.isDirectory()) {
 				t.mkdir();
-				copy(f,t);
+				copy(f, t);
 			} else if (f.isFile()) {
 				try {
-					org.aspectj.util.FileUtil.copyFile(f,t);
+					org.aspectj.util.FileUtil.copyFile(f, t);
 				} catch (IOException e) {
 					throw new AssertionFailedError("Unable to copy " + f + " to " + t);
 				}
-			} 
+			}
 		}
 	}
-	
+
 	protected File openFile(String path) {
 		return new File(projectDir + File.separatorChar + path);
 	}
-	
+
 	public void doBuild(String configFile) {
 		getCompilerForConfigFileWithName(configFile).build();
 	}
-	
+
 	public AjCompiler getCompilerForConfigFileWithName(String configFileName) {
 		return Ajde.getDefault().getCompilerForConfigFile(projectDir + File.separator + configFileName);
 	}
 
 	public List getErrorMessages(String configFileName) {
-		return ((TestMessageHandler)getCompilerForConfigFileWithName(configFileName).getMessageHandler()).getErrors();
+		return ((TestMessageHandler) getCompilerForConfigFileWithName(configFileName).getMessageHandler()).getErrors();
 	}
-	
+
 	public List getMessages(String configFileName) {
-		return ((TestMessageHandler)getCompilerForConfigFileWithName(configFileName).getMessageHandler()).getMessages();
+		return ((TestMessageHandler) getCompilerForConfigFileWithName(configFileName).getMessageHandler()).getMessages();
+	}
+
+	protected String genStructureModelExternFilePath(String configFilePath) {
+		return configFilePath.substring(0, configFilePath.lastIndexOf(".lst")) + ".ajsym";
 	}
-	
-    protected String genStructureModelExternFilePath(String configFilePath) {
-        return configFilePath.substring(0, configFilePath.lastIndexOf(".lst")) + ".ajsym";
-    }
 }
@@ -10,141 +10,131 @@
  *******************************************************************************/
 package org.aspectj.ajde;
 
+import java.io.File;
 import java.util.Iterator;
 import java.util.List;
-//import java.util.Properties;
-import java.io.File;
 
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.bridge.IMessage;
+import org.aspectj.org.eclipse.jdt.core.compiler.IProblem;
 import org.aspectj.tools.ajc.AjcTestCase;
 import org.aspectj.tools.ajc.CompilationResult;
-import org.aspectj.org.eclipse.jdt.core.compiler.IProblem;
 
 /**
- * Tests the 'extensions' to AJDE:
- * 1) ID is now available on messages to allow you to see what 'kind' of 
- *    message it is - this activates quick fixes/etc in Eclipse.
+ * Tests the 'extensions' to AJDE: 1) ID is now available on messages to allow you to see what 'kind' of message it is - this
+ * activates quick fixes/etc in Eclipse.
  */
 public class ExtensionTests extends AjcTestCase {
 
 	public static final String PROJECT_DIR = "extensions";
 	private static final boolean debugTests = false;
 	private File baseDir;
-	
+
 	protected void setUp() throws Exception {
 		super.setUp();
-        // TODO-path
-		baseDir = new File("../ajde/testdata",PROJECT_DIR);
+		// TODO-path
+		baseDir = new File("../ajde/testdata", PROJECT_DIR);
 	}
-	
+
 	/**
 	 * Aim: Check that the ID of certain message kinds are correct
 	 * 
-	 *   ajc -warn:unusedImport UnusedImport.java
+	 * ajc -warn:unusedImport UnusedImport.java
 	 * 
 	 * Expected result is that id matches IProblem.UnusedImport
 	 */
-	public void testMessageID () {
-		String[] args = new String[] {"UnusedImport.java","-warn:unusedImport"};
-		CompilationResult result = ajc(baseDir,args);
+	public void testMessageID() {
+		String[] args = new String[] { "UnusedImport.java", "-warn:unusedImport" };
+		CompilationResult result = ajc(baseDir, args);
 		List l = result.getWarningMessages();
-		IMessage m = ((IMessage)l.get(0));
-		assertTrue("Expected ID of message to be "+IProblem.UnusedImport+" (UnusedImport) but found an ID of "+m.getID(),
-			m.getID()==IProblem.UnusedImport);
+		IMessage m = ((IMessage) l.get(0));
+		assertTrue("Expected ID of message to be " + IProblem.UnusedImport + " (UnusedImport) but found an ID of " + m.getID(), m
+				.getID() == IProblem.UnusedImport);
 	}
-	
+
 	public void testInnerClassesInASM() {
-		String[] args = new String[] {"InnerClasses.java","-emacssym"};
-		CompilationResult result = ajc(baseDir,args);
-		/*List l = */result.getWarningMessages();
-		/*Properties p = */AsmManager.ModelInfo.summarizeModel().getProperties();
-		if (debugTests) System.out.println("Structure Model for InnerClasses.java:");
-		walkit(AsmManager.getDefault().getHierarchy().getRoot(),0);
+		String[] args = new String[] { "InnerClasses.java", "-emacssym" };
+		CompilationResult result = ajc(baseDir, args);
+		/* List l = */result.getWarningMessages();
+		/* Properties p = */AsmManager.lastActiveStructureModel.summarizeModel().getProperties();
+		if (debugTests)
+			System.out.println("Structure Model for InnerClasses.java:");
+		walkit(AsmManager.lastActiveStructureModel.getHierarchy().getRoot(), 0);
 		foundNode = null;
-		findChild("main",AsmManager.getDefault().getHierarchy().getRoot());
-		assertTrue("Should have found node 'main' in the model",foundNode!=null);
-		IProgramElement runnableChild = getChild(foundNode,"new Runnable() {..}");
-		assertTrue("'main' should have a child 'new Runnable() {..}'",
-				runnableChild!=null);
-		assertTrue("'new Runnable() {..}' should have a 'run' child",
-				getChild(runnableChild,"run")!=null);
-		
-		/* Left hand side is before the fix, right hand side is after:
-<root>
-  InnerClasses.java
-    import declarations
-    InnerClasses
-      A							A
-        method						method
-        1								new Runnable() {..}
-          run								run
-      main						main
-      2								new Runnable() {..}
-      	  run							run
-      3 							new Object() {..}
-        toString						toString
-      4								new Runnable
-        run								run
+		findChild("main", AsmManager.lastActiveStructureModel.getHierarchy().getRoot());
+		assertTrue("Should have found node 'main' in the model", foundNode != null);
+		IProgramElement runnableChild = getChild(foundNode, "new Runnable() {..}");
+		assertTrue("'main' should have a child 'new Runnable() {..}'", runnableChild != null);
+		assertTrue("'new Runnable() {..}' should have a 'run' child", getChild(runnableChild, "run") != null);
+
+		/*
+		 * Left hand side is before the fix, right hand side is after: <root> InnerClasses.java import declarations InnerClasses A A
+		 * method method 1 new Runnable() {..} run run main main 2 new Runnable() {..} run run 3 new Object() {..} toString toString
+		 * 4 new Runnable run run
 		 */
 
 	}
-	
-	private IProgramElement getChild(IProgramElement parent,String s) {
+
+	private IProgramElement getChild(IProgramElement parent, String s) {
 		List kids = parent.getChildren();
 		for (Iterator iter = kids.iterator(); iter.hasNext();) {
 			IProgramElement element = (IProgramElement) iter.next();
-			if (element.getName().indexOf(s)!=-1) return element;
+			if (element.getName().indexOf(s) != -1)
+				return element;
 		}
 		return null;
 	}
-	
+
 	private IProgramElement foundNode = null;
-	
-	private void findChild(String s,IProgramElement ipe) {
-		if (ipe == null) return;
-		if (ipe.getName().indexOf(s)!=-1) {foundNode = ipe; return;}
-		if (ipe.getChildren()!=null) {
+
+	private void findChild(String s, IProgramElement ipe) {
+		if (ipe == null)
+			return;
+		if (ipe.getName().indexOf(s) != -1) {
+			foundNode = ipe;
+			return;
+		}
+		if (ipe.getChildren() != null) {
 			List kids = ipe.getChildren();
 			for (Iterator iter = kids.iterator(); iter.hasNext();) {
 				IProgramElement element = (IProgramElement) iter.next();
-				findChild(s,element);
+				findChild(s, element);
 			}
 		}
 	}
-	
-	public void walkit(IProgramElement ipe,int indent) {
-	  if (ipe!=null) {
-		  if (debugTests) for (int i = 0 ;i<indent;i++) System.out.print(" ");
-		  if (debugTests) System.out.println(ipe.toLabelString());//getName());
-	    if (ipe.getChildren()!=null) {
-	    	List kids = ipe.getChildren();
-	    	for (Iterator iter = kids.iterator(); iter.hasNext();) {
-				IProgramElement element = (IProgramElement) iter.next();
-				walkit(element,indent+2);
+
+	public void walkit(IProgramElement ipe, int indent) {
+		if (ipe != null) {
+			if (debugTests)
+				for (int i = 0; i < indent; i++)
+					System.out.print(" ");
+			if (debugTests)
+				System.out.println(ipe.toLabelString());// getName());
+			if (ipe.getChildren() != null) {
+				List kids = ipe.getChildren();
+				for (Iterator iter = kids.iterator(); iter.hasNext();) {
+					IProgramElement element = (IProgramElement) iter.next();
+					walkit(element, indent + 2);
+				}
 			}
-	    }
-	  }
+		}
 	}
-	
 
 	/**
 	 * Aim: Check that the start/end of certain warnings are correct
 	 * 
-	 *   ajc -warn:unusedImport UnusedImport.java
+	 * ajc -warn:unusedImport UnusedImport.java
 	 * 
 	 * Expected result is first warning message has start=7 end=20
 	 */
 	public void testMessageSourceStartEnd() {
-		String[] args = new String[] {"UnusedImport.java","-warn:unusedImport"};
-		CompilationResult result = ajc(baseDir,args);
+		String[] args = new String[] { "UnusedImport.java", "-warn:unusedImport" };
+		CompilationResult result = ajc(baseDir, args);
 		List l = result.getWarningMessages();
-		IMessage m = ((IMessage)l.get(0));
-		assertTrue("Expected source start to be 7 but was "+m.getSourceStart(),
-			m.getSourceStart()==7);
-		assertTrue("Expected source end to be 20 but was "+m.getSourceEnd(),
-				m.getSourceEnd()==20);
-	}	
+		IMessage m = ((IMessage) l.get(0));
+		assertTrue("Expected source start to be 7 but was " + m.getSourceStart(), m.getSourceStart() == 7);
+		assertTrue("Expected source end to be 20 but was " + m.getSourceEnd(), m.getSourceEnd() == 20);
+	}
 
 }
@@ -26,61 +26,55 @@ public class SymbolFileGenerationTest extends AjcTestCase {
 	private static final String DIR = "../ajde/testdata/examples/coverage";
 
 	protected File dir = new File(DIR);
-	protected File configFile = new File(DIR + "/coverage.lst");	
+	protected File configFile = new File(DIR + "/coverage.lst");
 	protected File esymFile, outDir, crossRefsFile;
-	
+
 	protected void setUp() throws Exception {
 		super.setUp();
 		esymFile = new File(DIR + "/ModelCoverage.ajesym");
-		outDir = new File(DIR + "/bin");	
+		outDir = new File(DIR + "/bin");
 		crossRefsFile = new File(outDir.getAbsolutePath() + "/build.ajsym");
 	}
-	
+
 	protected void tearDown() throws Exception {
 		super.tearDown();
-				
-		FileUtil.deleteContents(new File(DIR),ajesymResourceFileFilter);
-		FileUtil.deleteContents(new File(DIR + "/pkg"),ajesymResourceFileFilter);
-		
+
+		FileUtil.deleteContents(new File(DIR), ajesymResourceFileFilter);
+		FileUtil.deleteContents(new File(DIR + "/pkg"), ajesymResourceFileFilter);
+
 		FileUtil.deleteContents(new File(DIR + "/bin"));
 		(new File(DIR + "/bin")).delete();
 
 	}
-	
-	public FileFilter ajesymResourceFileFilter =
-		new FileFilter() {
+
+	public FileFilter ajesymResourceFileFilter = new FileFilter() {
 		public boolean accept(File pathname) {
 			String name = pathname.getName().toLowerCase();
 			return name.endsWith(".ajesym");
 		}
 	};
-		
+
 	public void testCrossRefsFileGeneration() {
-		if (crossRefsFile.exists()) assertTrue(crossRefsFile.delete());
-		if (esymFile.exists()) assertTrue(esymFile.delete());
-		String[] args = new String[] {
-				"-d",
-				outDir.getAbsolutePath(),
-				"-crossrefs",
-				"@" + configFile.getAbsolutePath()
-		};
+		if (crossRefsFile.exists())
+			assertTrue(crossRefsFile.delete());
+		if (esymFile.exists())
+			assertTrue(esymFile.delete());
+		String[] args = new String[] { "-d", outDir.getAbsolutePath(), "-crossrefs", "@" + configFile.getAbsolutePath() };
 		ajc(dir, args);
-		
+
 		assertFalse(esymFile.exists());
 		assertTrue(crossRefsFile.exists());
 	}
 
 	public void testEmacssymGeneration() {
-		if (crossRefsFile.exists()) assertTrue(crossRefsFile.delete());
-		if (esymFile.exists()) assertTrue(esymFile.delete());
-		String[] args = new String[] {
-				"-d",
-				outDir.getAbsolutePath(),
-				"-emacssym",
-				"@" + configFile.getAbsolutePath()
-		};
+		if (crossRefsFile.exists()) {
+			assertTrue(crossRefsFile.delete());
+		}
+		if (esymFile.exists())
+			assertTrue(esymFile.delete());
+		String[] args = new String[] { "-d", outDir.getAbsolutePath(), "-emacssym", "@" + configFile.getAbsolutePath() };
 		ajc(dir, args);
-		
+
 		assertTrue(esymFile.exists());
 		assertFalse(crossRefsFile.exists());
 	}
@@ -11,8 +11,7 @@
  *     Helen Hawkins  Converted to new interface (bug 148190) 
  * ******************************************************************/
 
-
-package org.aspectj.ajde.ui; 
+package org.aspectj.ajde.ui;
 
 import java.io.File;
 import java.util.Iterator;
@@ -29,13 +28,13 @@ import org.aspectj.asm.IProgramElement;
  * @author Mik Kersten
  */
 public class StructureViewManagerTest extends AjdeTestCase {
-	
-    // TODO-path
+
+	// TODO-path
 	private final String CONFIG_FILE_PATH = "all.lst";
 	private final String CONFIG_FILE_PATH_2 = "inheritance.lst";
-	
+
 	private FileStructureView currentView;
-	private NullIdeStructureViewRenderer renderer = new NullIdeStructureViewRenderer();
+	private final NullIdeStructureViewRenderer renderer = new NullIdeStructureViewRenderer();
 	private File testFile;
 	private StructureViewProperties properties;
 
@@ -45,12 +44,12 @@ public class StructureViewManagerTest extends AjdeTestCase {
 
 	public static TestSuite suite() {
 		TestSuite result = new TestSuite();
-		result.addTestSuite(StructureViewManagerTest.class);	
+		result.addTestSuite(StructureViewManagerTest.class);
 		return result;
 	}
 
 	public void testModelExists() {
-		assertTrue(AsmManager.getDefault().getHierarchy() != null);
+		assertTrue(Ajde.getDefault().getModel().getHierarchy() != null);
 	}
 
 	public void testNotificationAfterConfigFileChange() {
@@ -58,61 +57,55 @@ public class StructureViewManagerTest extends AjdeTestCase {
 		doBuild(CONFIG_FILE_PATH_2);
 		renderer.setHasBeenNotified(false);
 		assertTrue("not yet notified", !renderer.getHasBeenNotified());
-		Ajde.getDefault().getBuildConfigManager().setActiveConfigFile(CONFIG_FILE_PATH_2);			
+		Ajde.getDefault().getBuildConfigManager().setActiveConfigFile(CONFIG_FILE_PATH_2);
 		assertTrue("notified", renderer.getHasBeenNotified());
 		renderer.setHasBeenNotified(false);
-		Ajde.getDefault().getBuildConfigManager().setActiveConfigFile("MumbleDoesNotExist.lst");			
-		assertTrue("notified", renderer.getHasBeenNotified());		
-		
-		assertTrue(
-			"no structure", 
-			currentView.getRootNode().getStructureNode().getChildren().get(0) 
-			== IHierarchy.NO_STRUCTURE
-		);			
+		Ajde.getDefault().getBuildConfigManager().setActiveConfigFile("MumbleDoesNotExist.lst");
+		assertTrue("notified", renderer.getHasBeenNotified());
+
+		assertTrue("no structure", currentView.getRootNode().getStructureNode().getChildren().get(0) == IHierarchy.NO_STRUCTURE);
 	}
 
 	/**
-	 * @todo	this should be moved to a StructureModelManager test
+	 * @todo this should be moved to a StructureModelManager test
 	 */
 	public void testFreshStructureModelCreation() {
 		renderer.setHasBeenNotified(false);
 		String modelPath = genStructureModelExternFilePath(CONFIG_FILE_PATH);
 		openFile(modelPath).delete();
-		
-		AsmManager.getDefault().readStructureModel(CONFIG_FILE_PATH);
-		
-		assertTrue("notified", renderer.getHasBeenNotified());	
-		// AMC should this be currentView, or should we recreate the root... do the latter	
-		//IProgramElement n = currentView.getRootNode().getIProgramElement();
-		IProgramElement n = AsmManager.getDefault().getHierarchy().getRoot();
-		assertTrue(
-			"no structure", 
-			//currentView.getRootNode().getIProgramElement().getChildren().get(0) 
-			n == IHierarchy.NO_STRUCTURE
-		);	
+
+		Ajde.getDefault().getModel().readStructureModel(CONFIG_FILE_PATH);
+
+		assertTrue("notified", renderer.getHasBeenNotified());
+		// AMC should this be currentView, or should we recreate the root... do the latter
+		// IProgramElement n = currentView.getRootNode().getIProgramElement();
+		IProgramElement n = Ajde.getDefault().getModel().getHierarchy().getRoot();
+		assertTrue("no structure",
+		// currentView.getRootNode().getIProgramElement().getChildren().get(0)
+				n == IHierarchy.NO_STRUCTURE);
 	}
 
 	public void testModelIntegrity() {
 		doBuild(CONFIG_FILE_PATH);
-		IProgramElement modelRoot = AsmManager.getDefault().getHierarchy().getRoot();
-		assertTrue("root exists", modelRoot != null);	
-		
+		IProgramElement modelRoot = Ajde.getDefault().getModel().getHierarchy().getRoot();
+		assertTrue("root exists", modelRoot != null);
+
 		try {
 			testModelIntegrityHelper(modelRoot);
 		} catch (Exception e) {
-			assertTrue(e.toString(), false);	
+			assertTrue(e.toString(), false);
 		}
 	}
 
 	private void testModelIntegrityHelper(IProgramElement node) throws Exception {
-		for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
-			IProgramElement child = (IProgramElement)it.next();
+		for (Iterator it = node.getChildren().iterator(); it.hasNext();) {
+			IProgramElement child = (IProgramElement) it.next();
 			if (node == child.getParent()) {
 				testModelIntegrityHelper(child);
 			} else {
 				throw new Exception("parent-child check failed for child: " + child.toString());
 			}
-		}		
+		}
 	}
 
 	public void testNotificationAfterBuild() {
@@ -122,21 +115,19 @@ public class StructureViewManagerTest extends AjdeTestCase {
 	}
 
 	public void testViewCreationWithNullSourceFileAndProperties() {
-		currentView = Ajde.getDefault().getStructureViewManager().createViewForSourceFile(null, null);	
-		assertTrue(
-			"no structure", 
-			currentView.getRootNode().getStructureNode() 
-			== IHierarchy.NO_STRUCTURE
-		);
+		currentView = Ajde.getDefault().getStructureViewManager().createViewForSourceFile(null, null);
+		assertTrue("no structure", currentView.getRootNode().getStructureNode() == IHierarchy.NO_STRUCTURE);
 	}
-  
+
 	protected void setUp() throws Exception {
 		super.setUp();
+
+		AsmManager.forceSingletonBehaviour = true;
 		initialiseProject("figures-coverage");
-		doBuild(CONFIG_FILE_PATH);		
-		
+		doBuild(CONFIG_FILE_PATH);
+
 		properties = Ajde.getDefault().getStructureViewManager().getDefaultViewProperties();
-        // TODO-path
+		// TODO-path
 		testFile = openFile("../examples/figures-coverage/figures/Figure.java");
 		currentView = Ajde.getDefault().getStructureViewManager().createViewForSourceFile(testFile.getAbsolutePath(), properties);
 		currentView.setRenderer(renderer);
@@ -144,6 +135,6 @@ public class StructureViewManagerTest extends AjdeTestCase {
 
 	protected void tearDown() throws Exception {
 		super.tearDown();
+		AsmManager.forceSingletonBehaviour = false;
 	}
 }
-
@@ -11,7 +11,6 @@
  *     Xerox/PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.testing.util;
 
 import java.util.ArrayList;
@@ -31,9 +30,9 @@ import org.aspectj.asm.IProgramElement;
 
 /**
  * Prototype functionality for package view clients.
- */  
+ */
 public class StructureModelUtil {
-	
+
 	public static class ModelIncorrectException extends Exception {
 
 		private static final long serialVersionUID = 8920868549577870993L;
@@ -42,44 +41,42 @@ public class StructureModelUtil {
 			super(s);
 		}
 	}
-	
+
 	/**
-	 * Check the properties of the current model.  The parameter string lists properties of the model
-	 * that should be correct.  If any of the properties are incorrect, a ModelIncorrectException is
-	 * thrown.
+	 * Check the properties of the current model. The parameter string lists properties of the model that should be correct. If any
+	 * of the properties are incorrect, a ModelIncorrectException is thrown.
 	 * 
 	 * @param toCheck comma separated list of name=value pairs that should be found in the ModelInfo object
 	 * @throws ModelIncorrectException thrown if any of the name=value pairs in toCheck are not found
 	 */
 	public static void checkModel(String toCheck) throws ModelIncorrectException {
-		Properties modelProperties = AsmManager.ModelInfo.summarizeModel().getProperties();
-		
+		Properties modelProperties = AsmManager.lastActiveStructureModel.summarizeModel().getProperties();
+
 		// Break toCheck into pieces and check each exists
-		StringTokenizer st = new StringTokenizer(toCheck,",=");
+		StringTokenizer st = new StringTokenizer(toCheck, ",=");
 		while (st.hasMoreTokens()) {
 			String key = st.nextToken();
 			String expValue = st.nextToken();
 			boolean expectingZero = false;
 			try {
-				expectingZero = (Integer.parseInt(expValue)==0);
+				expectingZero = (Integer.parseInt(expValue) == 0);
 			} catch (NumberFormatException nfe) {
 				// this is ok as expectingZero will be false
 			}
-		    String value = modelProperties.getProperty(key);
-		    if (value == null) {
-		    	if (!expectingZero)
-		    	  throw new ModelIncorrectException("Couldn't find '"+key+"' property for the model");	
-		    } else if (!value.equals(expValue)) {
-		    	throw new ModelIncorrectException("Model property '"+key+"' incorrect:  Expected "+expValue+" but found "+value);
-		    }
-		}	
+			String value = modelProperties.getProperty(key);
+			if (value == null) {
+				if (!expectingZero)
+					throw new ModelIncorrectException("Couldn't find '" + key + "' property for the model");
+			} else if (!value.equals(expValue)) {
+				throw new ModelIncorrectException("Model property '" + key + "' incorrect:  Expected " + expValue + " but found "
+						+ value);
+			}
+		}
 	}
-	
+
 	/**
-	 * This method returns a map from affected source lines in a class to
-	 * a List of aspects affecting that line.
-	 * Based on method of same name by mik kirsten. To be replaced when StructureModelUtil
-	 * corrects its implementation
+	 * This method returns a map from affected source lines in a class to a List of aspects affecting that line. Based on method of
+	 * same name by mik kirsten. To be replaced when StructureModelUtil corrects its implementation
 	 * 
 	 * @param the full path of the source file to get a map for
 	 * 
@@ -87,74 +84,71 @@ public class StructureModelUtil {
 	 */
 	public static Map getLinesToAspectMap(String sourceFilePath) {
 
-//		Map annotationsMap =
-//			AsmManager.getDefault().getInlineAnnotations(
-//				sourceFilePath,
-//				true,
-//				true);
+		// Map annotationsMap =
+		// AsmManager.getDefault().getInlineAnnotations(
+		// sourceFilePath,
+		// true,
+		// true);
 
 		Map aspectMap = new HashMap();
-//		Set keys = annotationsMap.keySet();
-//		for (Iterator it = keys.iterator(); it.hasNext();) {
-//			Object key = it.next();
-//			List annotations = (List) annotationsMap.get(key);
-//			for (Iterator it2 = annotations.iterator(); it2.hasNext();) {
-//				IProgramElement node = (IProgramElement) it2.next();
+		// Set keys = annotationsMap.keySet();
+		// for (Iterator it = keys.iterator(); it.hasNext();) {
+		// Object key = it.next();
+		// List annotations = (List) annotationsMap.get(key);
+		// for (Iterator it2 = annotations.iterator(); it2.hasNext();) {
+		// IProgramElement node = (IProgramElement) it2.next();
 
-//				List relations = node.getRelations();
-//
-//				for (Iterator it3 = relations.iterator(); it3.hasNext();) {
-//					IRelationship relationNode = (IRelationship) it3.next();
+		// List relations = node.getRelations();
+		//
+		// for (Iterator it3 = relations.iterator(); it3.hasNext();) {
+		// IRelationship relationNode = (IRelationship) it3.next();
 
-//					if (relationNode.getKind().equals("Advice")) {
-//						List children = relationNode.getTargets();
-//
-//						List aspects = new Vector();
-//
-//						for (Iterator it4 = children.iterator();
-//							it4.hasNext();
-//							) {
-//							Object object = it4.next();
-//
-////							if (object instanceof LinkNode) {
-////								IProgramElement pNode =
-////									((LinkNode) object).getProgramElementNode();
-////
-////								if (pNode.getProgramElementKind()
-////									== IProgramElement.Kind.ADVICE) {
-////
-////									IProgramElement theAspect = pNode.getParent();
-////
-////									aspects.add(theAspect);
-////
-////								}
-////							}
-//						}
-//						if (!aspects.isEmpty()) {
-//							aspectMap.put(key, aspects);
-//						}
-//					}
-//
-//				}
-//			}
-//		}
+		// if (relationNode.getKind().equals("Advice")) {
+		// List children = relationNode.getTargets();
+		//
+		// List aspects = new Vector();
+		//
+		// for (Iterator it4 = children.iterator();
+		// it4.hasNext();
+		// ) {
+		// Object object = it4.next();
+		//
+		// // if (object instanceof LinkNode) {
+		// // IProgramElement pNode =
+		// // ((LinkNode) object).getProgramElementNode();
+		// //
+		// // if (pNode.getProgramElementKind()
+		// // == IProgramElement.Kind.ADVICE) {
+		// //
+		// // IProgramElement theAspect = pNode.getParent();
+		// //
+		// // aspects.add(theAspect);
+		// //
+		// // }
+		// // }
+		// }
+		// if (!aspects.isEmpty()) {
+		// aspectMap.put(key, aspects);
+		// }
+		// }
+		//
+		// }
+		// }
+		// }
 		return aspectMap;
 	}
 
 	/**
-	 * This method is copied from StructureModelUtil inoder for it to use the working
-	 * version of getLineToAspectMap()
+	 * This method is copied from StructureModelUtil inoder for it to use the working version of getLineToAspectMap()
 	 * 
-	 * @return		the set of aspects with advice that affects the specified package
+	 * @return the set of aspects with advice that affects the specified package
 	 */
 	public static Set getAspectsAffectingPackage(IProgramElement packageNode) {
 		List files = StructureModelUtil.getFilesInPackage(packageNode);
 		Set aspects = new HashSet();
 		for (Iterator it = files.iterator(); it.hasNext();) {
 			IProgramElement fileNode = (IProgramElement) it.next();
-			Map adviceMap =
-				getLinesToAspectMap(
-					fileNode.getSourceLocation().getSourceFile().getAbsolutePath());
+			Map adviceMap = getLinesToAspectMap(fileNode.getSourceLocation().getSourceFile().getAbsolutePath());
 			Collection values = adviceMap.values();
 			for (Iterator it2 = values.iterator(); it2.hasNext();) {
 				aspects.add(it2.next());
@@ -163,25 +157,17 @@ public class StructureModelUtil {
 		return aspects;
 	}
 
-	public static List getPackagesInModel() {
+	public static List getPackagesInModel(AsmManager modl) {
 		List packages = new ArrayList();
-		IHierarchy model = AsmManager.getDefault().getHierarchy();
+		IHierarchy model = modl.getHierarchy();
 		if (model.getRoot().equals(IHierarchy.NO_STRUCTURE)) {
 			return null;
 		} else {
-			return getPackagesHelper(
-				(IProgramElement) model.getRoot(),
-				IProgramElement.Kind.PACKAGE,
-				null,
-				packages);
+			return getPackagesHelper(model.getRoot(), IProgramElement.Kind.PACKAGE, null, packages);
 		}
 	}
 
-	private static List getPackagesHelper(
-		IProgramElement node,
-		IProgramElement.Kind kind,
-		String prename,
-		List matches) {
+	private static List getPackagesHelper(IProgramElement node, IProgramElement.Kind kind, String prename, List matches) {
 
 		if (kind == null || node.getKind().equals(kind)) {
 			if (prename == null) {
@@ -207,75 +193,71 @@ public class StructureModelUtil {
 	/**
 	 * Helper function sorts a list of resources into alphabetical order
 	 */
-//	private List sortElements(List oldElements) {
-//		Object[] temp = oldElements.toArray();
-//		SortingComparator comparator = new SortingComparator();
-//
-//		Arrays.sort(temp, comparator);
-//
-//		List newResources = Arrays.asList(temp);
-//
-//		return newResources;
-//	}
-//
-//	private static List sortArray(List oldElements) {
-//		Object[] temp = oldElements.toArray();
-//		SortArrayComparator comparator = new SortArrayComparator();
-//
-//		Arrays.sort(temp, comparator);
-//		
-//		List newElements = Arrays.asList(temp);
-//
-//		return newElements;
-//	}
-
-//	private class SortingComparator implements Comparator {
-//		public int compare(Object o1, Object o2) {
-//			IProgramElement p1 = (IProgramElement) o1;
-//			IProgramElement p2 = (IProgramElement) o2;
-//
-//			String name1 = p1.getName();
-//			String name2 = p2.getName();
-//
-//			return name1.compareTo(name2);
-//		}
-//	}
-//
-//	private static class SortArrayComparator implements Comparator {
-//		public int compare(Object o1, Object o2) {
-//			Object[] array1 = (Object[]) o1;
-//			Object[] array2 = (Object[]) o2;
-//
-//			IProgramElement p1 = (IProgramElement) array1[1];
-//			IProgramElement p2 = (IProgramElement) array2[1];
-//
-//			String name1 = p1.getName();
-//			String name2 = p2.getName();
-//
-//			return name1.compareTo(name2);
-//		}
-//	}
-
+	// private List sortElements(List oldElements) {
+	// Object[] temp = oldElements.toArray();
+	// SortingComparator comparator = new SortingComparator();
+	//
+	// Arrays.sort(temp, comparator);
+	//
+	// List newResources = Arrays.asList(temp);
+	//
+	// return newResources;
+	// }
+	//
+	// private static List sortArray(List oldElements) {
+	// Object[] temp = oldElements.toArray();
+	// SortArrayComparator comparator = new SortArrayComparator();
+	//
+	// Arrays.sort(temp, comparator);
+	//		
+	// List newElements = Arrays.asList(temp);
+	//
+	// return newElements;
+	// }
+	// private class SortingComparator implements Comparator {
+	// public int compare(Object o1, Object o2) {
+	// IProgramElement p1 = (IProgramElement) o1;
+	// IProgramElement p2 = (IProgramElement) o2;
+	//
+	// String name1 = p1.getName();
+	// String name2 = p2.getName();
+	//
+	// return name1.compareTo(name2);
+	// }
+	// }
+	//
+	// private static class SortArrayComparator implements Comparator {
+	// public int compare(Object o1, Object o2) {
+	// Object[] array1 = (Object[]) o1;
+	// Object[] array2 = (Object[]) o2;
+	//
+	// IProgramElement p1 = (IProgramElement) array1[1];
+	// IProgramElement p2 = (IProgramElement) array2[1];
+	//
+	// String name1 = p1.getName();
+	// String name2 = p2.getName();
+	//
+	// return name1.compareTo(name2);
+	// }
+	// }
 	/**
-	 * @return		all of the AspectJ and Java source files in a package
-	 */ 
+	 * @return all of the AspectJ and Java source files in a package
+	 */
 	public static List getFilesInPackage(IProgramElement packageNode) {
 		List packageContents;
 		if (packageNode == null) {
 			return null;
 		} else {
-			packageContents = packageNode.getChildren();	
+			packageContents = packageNode.getChildren();
 		}
 		List files = new ArrayList();
-		for (Iterator it = packageContents.iterator(); it.hasNext(); ) {
-			IProgramElement packageItem = (IProgramElement)it.next();
-			if (packageItem.getKind() == IProgramElement.Kind.FILE_JAVA 
-				|| packageItem.getKind() == IProgramElement.Kind.FILE_ASPECTJ) {
+		for (Iterator it = packageContents.iterator(); it.hasNext();) {
+			IProgramElement packageItem = (IProgramElement) it.next();
+			if (packageItem.getKind() == IProgramElement.Kind.FILE_JAVA
+					|| packageItem.getKind() == IProgramElement.Kind.FILE_ASPECTJ) {
 				files.add(packageItem);
 			}
-		} 
+		}
 		return files;
-	}	
+	}
 }
-
-
@@ -11,7 +11,6 @@
  *     Helen Hawkins    Converted to new interface (bug 148190) 
  * ******************************************************************/
 
-
 package org.aspectj.testing.util;
 
 import java.io.File;
@@ -26,18 +25,14 @@ import org.aspectj.asm.IProgramElement;
 /**
  * @author Mik Kersten
  */
-public class StructureModelUtilTest extends AjdeCoreTestCase{
-	
-	private String[] files = new String[]{
-			"figures" + File.separator + "Debug.java",
-			"figures" + File.separator + "Figure.java",
-			"figures" + File.separator + "FigureElement.java",
-			"figures" + File.separator + "Main.java",
-			"figures" + File.separator + "composites" + File.separator + "Line.java",
+public class StructureModelUtilTest extends AjdeCoreTestCase {
+
+	private final String[] files = new String[] { "figures" + File.separator + "Debug.java",
+			"figures" + File.separator + "Figure.java", "figures" + File.separator + "FigureElement.java",
+			"figures" + File.separator + "Main.java", "figures" + File.separator + "composites" + File.separator + "Line.java",
 			"figures" + File.separator + "composites" + File.separator + "Square.java",
 			"figures" + File.separator + "primitives" + File.separator + "planar" + File.separator + "Point.java",
-			"figures" + File.separator + "primitives" + File.separator + "solid" + File.separator + "SolidPoint.java"
-	};
+			"figures" + File.separator + "primitives" + File.separator + "solid" + File.separator + "SolidPoint.java" };
 
 	public static void main(String[] args) {
 		junit.swingui.TestRunner.run(StructureModelUtilTest.class);
@@ -45,37 +40,35 @@ public class StructureModelUtilTest extends AjdeCoreTestCase{
 
 	public static TestSuite suite() {
 		TestSuite result = new TestSuite();
-		result.addTestSuite(StructureModelUtilTest.class);	
+		result.addTestSuite(StructureModelUtilTest.class);
 		return result;
 	}
 
 	public void testPackageViewUtil() {
-		List packages = StructureModelUtil.getPackagesInModel(); 
+		List packages = StructureModelUtil.getPackagesInModel(getCompiler().getModel());
 		assertTrue("packages list not null", packages != null);
-        assertTrue("packages list not empty", !packages.isEmpty());
-	
-		IProgramElement packageNode = (IProgramElement)((Object[])packages.get(0))[0];
+		assertTrue("packages list not empty", !packages.isEmpty());
+
+		IProgramElement packageNode = (IProgramElement) ((Object[]) packages.get(0))[0];
 		assertTrue("package node not null", packageNode != null);
-		
+
 		List files = StructureModelUtil.getFilesInPackage(packageNode);
 		assertTrue("fle list not null", files != null);
-		
+
 		// TODO: re-enable
-//		Map lineAdviceMap = StructureModelUtil.getLinesToAspectMap(
-//			((IProgramElement)files.get(0)).getSourceLocation().getSourceFile().getAbsolutePath()
-//		);
-//		
-//		assertTrue("line->advice map not null", lineAdviceMap != null);			
-//		
-//		Set aspects = StructureModelUtil.getAspectsAffectingPackage(packageNode);
-//		assertTrue("aspect list not null", aspects != null);			
+		// Map lineAdviceMap = StructureModelUtil.getLinesToAspectMap(
+		// ((IProgramElement)files.get(0)).getSourceLocation().getSourceFile().getAbsolutePath()
+		// );
+		//		
+		// assertTrue("line->advice map not null", lineAdviceMap != null);
+		//		
+		// Set aspects = StructureModelUtil.getAspectsAffectingPackage(packageNode);
+		// assertTrue("aspect list not null", aspects != null);
 	}
 
-  
 	protected void setUp() throws Exception {
 		initialiseProject("figures-coverage");
-		TestCompilerConfiguration compilerConfig = (TestCompilerConfiguration) getCompiler()
-				.getCompilerConfiguration();
+		TestCompilerConfiguration compilerConfig = (TestCompilerConfiguration) getCompiler().getCompilerConfiguration();
 		compilerConfig.setProjectSourceFiles(getSourceFileList(files));
 		doBuild();
 	}
@@ -84,4 +77,3 @@ public class StructureModelUtilTest extends AjdeCoreTestCase{
 		super.tearDown();
 	}
 }
-
@@ -15,7 +15,6 @@ package org.aspectj.weaver;
 import java.util.Collections;
 import java.util.List;
 
-import org.aspectj.asm.AsmManager;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.weaver.patterns.AndPointcut;
@@ -26,7 +25,7 @@ import org.aspectj.weaver.patterns.TypePattern;
 public abstract class Advice extends ShadowMunger {
 
 	protected AjAttribute.AdviceAttribute attribute; // the pointcut field is
-														// ignored
+	// ignored
 
 	protected AdviceKind kind; // alias of attribute.getKind()
 	protected Member signature;
@@ -36,8 +35,8 @@ public abstract class Advice extends ShadowMunger {
 	protected ResolvedType concreteAspect; // null until after concretize
 
 	protected List innerCflowEntries = Collections.EMPTY_LIST; // just for
-																// cflow*Entry
-																// kinds
+	// cflow*Entry
+	// kinds
 	protected int nFreeVars; // just for cflow*Entry kinds
 
 	protected TypePattern exceptionType; // just for Softener kind
@@ -47,8 +46,8 @@ public abstract class Advice extends ShadowMunger {
 	protected UnresolvedType[] bindingParameterTypes;
 
 	protected List/* Lint.Kind */suppressedLintKinds = null; // based on
-															// annotations on
-															// this advice
+	// annotations on
+	// this advice
 
 	ISourceLocation lastReportedMonitorExitJoinpointLocation = null;
 
@@ -185,11 +184,11 @@ public abstract class Advice extends ShadowMunger {
 						ResolvedType adviceReturnType = getSignature().getGenericReturnType().resolve(world);
 
 						if (shadowReturnType.isParameterizedType() && adviceReturnType.isRawType()) { // Set
-																										// <
-																										// Integer
-																										// >
-																										// and
-																										// Set
+							// <
+							// Integer
+							// >
+							// and
+							// Set
 							ResolvedType shadowReturnGenericType = shadowReturnType.getGenericType(); // Set
 							ResolvedType adviceReturnGenericType = adviceReturnType.getGenericType(); // Set
 							if (shadowReturnGenericType.isAssignableFrom(adviceReturnGenericType)
@@ -216,11 +215,10 @@ public abstract class Advice extends ShadowMunger {
 	}
 
 	/**
-	 * In after returning advice if we are binding the extra parameter to a
-	 * parameterized type we may not be able to do a type-safe conversion.
+	 * In after returning advice if we are binding the extra parameter to a parameterized type we may not be able to do a type-safe
+	 * conversion.
 	 * 
-	 * @param resolvedExtraParameterType the type in the after returning
-	 *            declaration
+	 * @param resolvedExtraParameterType the type in the after returning declaration
 	 * @param shadowReturnType the type at the shadow
 	 * @param world
 	 */
@@ -390,14 +388,14 @@ public abstract class Advice extends ShadowMunger {
 		if (!(other instanceof Advice))
 			return false;
 		Advice o = (Advice) other;
-		return o.kind.equals(kind)
-				&& ((o.pointcut == null) ? (pointcut == null) : o.pointcut.equals(pointcut))
-				&& ((o.signature == null) ? (signature == null) : o.signature.equals(signature))
-				&& (AsmManager.getDefault().getHandleProvider().dependsOnLocation() ? ((o.getSourceLocation() == null) ? (getSourceLocation() == null)
-						: o.getSourceLocation().equals(getSourceLocation()))
-						: true) // pr134471 - remove when handles are improved
-								// to be independent of location
-		;
+		return o.kind.equals(kind) && ((o.pointcut == null) ? (pointcut == null) : o.pointcut.equals(pointcut))
+				&& ((o.signature == null) ? (signature == null) : o.signature.equals(signature));
+		// && (AsmManager.getDefault().getHandleProvider().dependsOnLocation() ? ((o.getSourceLocation() == null) ?
+		// (getSourceLocation() == null)
+		// : o.getSourceLocation().equals(getSourceLocation()))
+		// : true) // pr134471 - remove when handles are improved
+		// // to be independent of location
+		// ;
 
 	}
 
@@ -41,94 +41,74 @@ public class AsmRelationshipProvider {
 	public static final String ANNOTATES = "annotates";
 	public static final String ANNOTATED_BY = "annotated by";
 
-	public void checkerMunger(IHierarchy model, Shadow shadow, Checker checker) {
-		if (!AsmManager.isCreatingModel())
+	public void checkerMunger(AsmManager asm, Shadow shadow, Checker checker) {
+		if (asm == null) // !AsmManager.isCreatingModel())
 			return;
-		if (shadow.getSourceLocation() == null
-				|| checker.getSourceLocation() == null)
+		if (shadow.getSourceLocation() == null || checker.getSourceLocation() == null)
 			return;
 
 		if (World.createInjarHierarchy) {
-			checker.createHierarchy();
+			checker.createHierarchy(asm);
 		}
 
 		// Ensure a node for the target exists
-		IProgramElement targetNode = getNode(AsmManager.getDefault()
-				.getHierarchy(), shadow);
+		IProgramElement targetNode = getNode(asm, shadow);
 		if (targetNode == null)
 			return;
-		String targetHandle = AsmManager.getDefault().getHandleProvider()
-				.createHandleIdentifier(targetNode);
+		String targetHandle = asm.getHandleProvider().createHandleIdentifier(targetNode);
 		if (targetHandle == null)
 			return;
 
-		IProgramElement sourceNode = AsmManager.getDefault().getHierarchy()
-				.findElementForSourceLine(checker.getSourceLocation());
-		String sourceHandle = AsmManager.getDefault().getHandleProvider()
-				.createHandleIdentifier(sourceNode);
+		IProgramElement sourceNode = asm.getHierarchy().findElementForSourceLine(checker.getSourceLocation());
+		String sourceHandle = asm.getHandleProvider().createHandleIdentifier(sourceNode);
 		if (sourceHandle == null)
 			return;
 
-		IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
-		IRelationship foreward = mapper.get(sourceHandle,
-				IRelationship.Kind.DECLARE, MATCHED_BY, false, true);
+		IRelationshipMap mapper = asm.getRelationshipMap();
+		IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE, MATCHED_BY, false, true);
 		foreward.addTarget(targetHandle);
 
-		IRelationship back = mapper.get(targetHandle,
-				IRelationship.Kind.DECLARE, MATCHES_DECLARE, false, true);
+		IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE, MATCHES_DECLARE, false, true);
 		if (back != null && back.getTargets() != null) {
 			back.addTarget(sourceHandle);
 		}
-		if (sourceNode.getSourceLocation()!=null) {
-			AsmManager.getDefault().addAspectInEffectThisBuild(sourceNode.getSourceLocation().getSourceFile());
+		if (sourceNode.getSourceLocation() != null) {
+			asm.addAspectInEffectThisBuild(sourceNode.getSourceLocation().getSourceFile());
 		}
 
 	}
 
 	// For ITDs
-	public void addRelationship(ResolvedType onType, ResolvedTypeMunger munger,
-			ResolvedType originatingAspect) {
+	public void addRelationship(AsmManager asm, ResolvedType onType, ResolvedTypeMunger munger, ResolvedType originatingAspect) {
 
-		if (!AsmManager.isCreatingModel())
+		if (asm == null)// !AsmManager.isCreatingModel())
 			return;
 		if (originatingAspect.getSourceLocation() != null) {
 			String sourceHandle = "";
 			IProgramElement sourceNode = null;
-			if (munger.getSourceLocation() != null
-					&& munger.getSourceLocation().getOffset() != -1) {
-				sourceNode = AsmManager.getDefault()
-						.getHierarchy().findElementForSourceLine(
-								munger.getSourceLocation());
-				sourceHandle = AsmManager.getDefault().getHandleProvider()
-						.createHandleIdentifier(sourceNode);
+			if (munger.getSourceLocation() != null && munger.getSourceLocation().getOffset() != -1) {
+				sourceNode = asm.getHierarchy().findElementForSourceLine(munger.getSourceLocation());
+				sourceHandle = asm.getHandleProvider().createHandleIdentifier(sourceNode);
 			} else {
-				sourceNode = AsmManager.getDefault()
-						.getHierarchy().findElementForSourceLine(
-								originatingAspect.getSourceLocation());
-				sourceHandle = AsmManager.getDefault().getHandleProvider()
-						.createHandleIdentifier(sourceNode);
+				sourceNode = asm.getHierarchy().findElementForSourceLine(originatingAspect.getSourceLocation());
+				sourceHandle = asm.getHandleProvider().createHandleIdentifier(sourceNode);
 			}
 			if (sourceHandle == null)
 				return;
-			IProgramElement targetNode = AsmManager.getDefault().getHierarchy()
-					.findElementForSourceLine(onType.getSourceLocation());
-			String targetHandle = AsmManager.getDefault().getHandleProvider()
-					.createHandleIdentifier(targetNode);
+			IProgramElement targetNode = asm.getHierarchy().findElementForSourceLine(onType.getSourceLocation());
+			String targetHandle = asm.getHandleProvider().createHandleIdentifier(targetNode);
 			if (targetHandle == null)
 				return;
 
-			IRelationshipMap mapper = AsmManager.getDefault()
-					.getRelationshipMap();
-			IRelationship foreward = mapper.get(sourceHandle,
-					IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARES,
-					false, true);
+			IRelationshipMap mapper = asm.getRelationshipMap();
+			IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARES, false,
+					true);
 			foreward.addTarget(targetHandle);
 
-			IRelationship back = mapper.get(targetHandle,
-					IRelationship.Kind.DECLARE_INTER_TYPE,
-					INTER_TYPE_DECLARED_BY, false, true);
+			IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARED_BY, false,
+					true);
 			back.addTarget(sourceHandle);
-			AsmManager.getDefault().addAspectInEffectThisBuild(sourceNode.getSourceLocation().getSourceFile());
+			asm.addAspectInEffectThisBuild(sourceNode.getSourceLocation().getSourceFile());
 		}
 	}
 
@@ -165,47 +145,37 @@ public class AsmRelationshipProvider {
 	// }
 
 	/**
-	 * Adds a declare annotation relationship, sometimes entities don't have
-	 * source locs (methods/fields) so use other variants of this method if that
-	 * is the case as they will look the entities up in the structure model.
+	 * Adds a declare annotation relationship, sometimes entities don't have source locs (methods/fields) so use other variants of
+	 * this method if that is the case as they will look the entities up in the structure model.
 	 */
-	public void addDeclareAnnotationRelationship(
-			ISourceLocation declareAnnotationLocation,
+	public void addDeclareAnnotationRelationship(AsmManager asm, ISourceLocation declareAnnotationLocation,
 			ISourceLocation annotatedLocation) {
-		if (!AsmManager.isCreatingModel())
+		if (asm == null) // !AsmManager.isCreatingModel())
 			return;
 
-		IProgramElement sourceNode = AsmManager.getDefault().getHierarchy()
-				.findElementForSourceLine(declareAnnotationLocation);
-		String sourceHandle = AsmManager.getDefault().getHandleProvider()
-				.createHandleIdentifier(sourceNode);
+		IProgramElement sourceNode = asm.getHierarchy().findElementForSourceLine(declareAnnotationLocation);
+		String sourceHandle = asm.getHandleProvider().createHandleIdentifier(sourceNode);
 		if (sourceHandle == null)
 			return;
 
-		IProgramElement targetNode = AsmManager.getDefault().getHierarchy()
-				.findElementForSourceLine(annotatedLocation);
-		String targetHandle = AsmManager.getDefault().getHandleProvider()
-				.createHandleIdentifier(targetNode);
+		IProgramElement targetNode = asm.getHierarchy().findElementForSourceLine(annotatedLocation);
+		String targetHandle = asm.getHandleProvider().createHandleIdentifier(targetNode);
 		if (targetHandle == null)
 			return;
 
-		IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
-		IRelationship foreward = mapper.get(sourceHandle,
-				IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATES, false, true);
+		IRelationshipMap mapper = asm.getRelationshipMap();
+		IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATES, false, true);
 		foreward.addTarget(targetHandle);
 
-		IRelationship back = mapper.get(targetHandle,
-				IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATED_BY, false,
-				true);
+		IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATED_BY, false, true);
 		back.addTarget(sourceHandle);
-		if (sourceNode.getSourceLocation()!=null) {
-			AsmManager.getDefault().addAspectInEffectThisBuild(sourceNode.getSourceLocation().getSourceFile());
+		if (sourceNode.getSourceLocation() != null) {
+			asm.addAspectInEffectThisBuild(sourceNode.getSourceLocation().getSourceFile());
 		}
 	}
 
-	public void adviceMunger(IHierarchy model, Shadow shadow,
-			ShadowMunger munger) {
-		if (!AsmManager.isCreatingModel())
+	public void adviceMunger(AsmManager asm, Shadow shadow, ShadowMunger munger) {
+		if (asm == null) // !AsmManager.isCreatingModel())
 			return;
 		if (munger instanceof Advice) {
 			Advice advice = (Advice) munger;
@@ -216,13 +186,11 @@ public class AsmRelationshipProvider {
 			}
 
 			if (World.createInjarHierarchy) {
-				munger.createHierarchy();
+				munger.createHierarchy(asm);
 			}
 
-			IRelationshipMap mapper = AsmManager.getDefault()
-					.getRelationshipMap();
-			IProgramElement targetNode = getNode(AsmManager.getDefault()
-					.getHierarchy(), shadow);
+			IRelationshipMap mapper = asm.getRelationshipMap();
+			IProgramElement targetNode = getNode(asm, shadow);
 			if (targetNode == null)
 				return;
 			boolean runtimeTest = advice.hasDynamicTests();
@@ -230,7 +198,7 @@ public class AsmRelationshipProvider {
 			// Work out extra info to inform interested UIs !
 			IProgramElement.ExtraInformation ai = new IProgramElement.ExtraInformation();
 
-			String adviceHandle = advice.getHandle();
+			String adviceHandle = advice.getHandle(asm);
 			if (adviceHandle == null)
 				return;
 
@@ -239,50 +207,42 @@ public class AsmRelationshipProvider {
 			// get it into CVS !!!
 			AdviceKind ak = ((Advice) munger).getKind();
 			ai.setExtraAdviceInformation(ak.getName());
-			IProgramElement adviceElement = AsmManager.getDefault()
-					.getHierarchy().findElementForHandle(adviceHandle);
+			IProgramElement adviceElement = asm.getHierarchy().findElementForHandle(adviceHandle);
 			if (adviceElement != null) {
 				adviceElement.setExtraInfo(ai);
 			}
 			String targetHandle = targetNode.getHandleIdentifier();
 			if (advice.getKind().equals(AdviceKind.Softener)) {
-				IRelationship foreward = mapper.get(adviceHandle,
-						IRelationship.Kind.DECLARE_SOFT, SOFTENS, runtimeTest,
-						true);
+				IRelationship foreward = mapper.get(adviceHandle, IRelationship.Kind.DECLARE_SOFT, SOFTENS, runtimeTest, true);
 				if (foreward != null)
-					foreward.addTarget(targetHandle);//foreward.getTargets().add
-														// (targetHandle);
+					foreward.addTarget(targetHandle);// foreward.getTargets().add
+				// (targetHandle);
 
-				IRelationship back = mapper.get(targetHandle,
-						IRelationship.Kind.DECLARE, SOFTENED_BY, runtimeTest,
-						true);
+				IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE, SOFTENED_BY, runtimeTest, true);
 				if (back != null)
 					back.addTarget(adviceHandle);// back.getTargets().add(
-													// adviceHandle);
+				// adviceHandle);
 			} else {
-				IRelationship foreward = mapper.get(adviceHandle,
-						IRelationship.Kind.ADVICE, ADVISES, runtimeTest, true);
+				IRelationship foreward = mapper.get(adviceHandle, IRelationship.Kind.ADVICE, ADVISES, runtimeTest, true);
 				if (foreward != null)
-					foreward.addTarget(targetHandle);//foreward.getTargets().add
-														// (targetHandle);
+					foreward.addTarget(targetHandle);// foreward.getTargets().add
+				// (targetHandle);
 
-				IRelationship back = mapper.get(targetHandle,
-						IRelationship.Kind.ADVICE, ADVISED_BY, runtimeTest,
-						true);
+				IRelationship back = mapper.get(targetHandle, IRelationship.Kind.ADVICE, ADVISED_BY, runtimeTest, true);
 				if (back != null)
 					back.addTarget(adviceHandle);// back.getTargets().add(
-													// adviceHandle);
+				// adviceHandle);
 			}
-			if (adviceElement.getSourceLocation()!=null) {
-				AsmManager.getDefault().addAspectInEffectThisBuild(adviceElement.getSourceLocation().getSourceFile());
+			if (adviceElement.getSourceLocation() != null) {
+				asm.addAspectInEffectThisBuild(adviceElement.getSourceLocation().getSourceFile());
 			}
 		}
 	}
 
-	protected IProgramElement getNode(IHierarchy model, Shadow shadow) {
+	protected IProgramElement getNode(AsmManager model, Shadow shadow) {
 		Member enclosingMember = shadow.getEnclosingCodeSignature();
 
-		IProgramElement enclosingNode = lookupMember(model, enclosingMember);
+		IProgramElement enclosingNode = lookupMember(model.getHierarchy(), enclosingMember);
 		if (enclosingNode == null) {
 			Lint.Kind err = shadow.getIWorld().getLint().shadowNotInStructure;
 			if (err.isEnabled()) {
@@ -293,10 +253,8 @@ public class AsmRelationshipProvider {
 
 		Member shadowSig = shadow.getSignature();
 		// pr235204
-		if (shadow.getKind() == Shadow.MethodCall
-				|| !shadowSig.equals(enclosingMember)) {
-			IProgramElement bodyNode = findOrCreateCodeNode(enclosingNode,
-					shadowSig, shadow);
+		if (shadow.getKind() == Shadow.MethodCall || !shadowSig.equals(enclosingMember)) {
+			IProgramElement bodyNode = findOrCreateCodeNode(model, enclosingNode, shadowSig, shadow);
 			return bodyNode;
 		} else {
 			return enclosingNode;
@@ -312,32 +270,23 @@ public class AsmRelationshipProvider {
 	/**
 	 * Finds or creates a code IProgramElement for the given shadow.
 	 * 
-	 * The byteCodeName of the created node is set to 'shadowSig.getName() + "!"
-	 * + counter', eg "println!3". The counter is the occurence count of
-	 * children within the enclosingNode which have the same name. So, for
-	 * example, if a method contains two System.out.println statements, the
-	 * first one will have byteCodeName 'println!1' and the second will have
-	 * byteCodeName 'println!2'. This is to ensure the two nodes have unique
-	 * handles when the handles do not depend on sourcelocations.
+	 * The byteCodeName of the created node is set to 'shadowSig.getName() + "!" + counter', eg "println!3". The counter is the
+	 * occurence count of children within the enclosingNode which have the same name. So, for example, if a method contains two
+	 * System.out.println statements, the first one will have byteCodeName 'println!1' and the second will have byteCodeName
+	 * 'println!2'. This is to ensure the two nodes have unique handles when the handles do not depend on sourcelocations.
 	 * 
-	 * Currently the shadows are examined in the sequence they appear in the
-	 * source file. This means that the counters are consistent over incremental
-	 * builds. All aspects are compiled up front and any new aspect created will
-	 * force a full build. Moreover, if the body of the enclosingShadow is
-	 * changed, then the model for this is rebuilt from scratch.
+	 * Currently the shadows are examined in the sequence they appear in the source file. This means that the counters are
+	 * consistent over incremental builds. All aspects are compiled up front and any new aspect created will force a full build.
+	 * Moreover, if the body of the enclosingShadow is changed, then the model for this is rebuilt from scratch.
 	 */
-	private IProgramElement findOrCreateCodeNode(IProgramElement enclosingNode,
-			Member shadowSig, Shadow shadow) {
+	private IProgramElement findOrCreateCodeNode(AsmManager asm, IProgramElement enclosingNode, Member shadowSig, Shadow shadow) {
 		for (Iterator it = enclosingNode.getChildren().iterator(); it.hasNext();) {
 			IProgramElement node = (IProgramElement) it.next();
 			int excl = node.getBytecodeName().lastIndexOf('!');
-			if (((excl != -1 && shadowSig.getName().equals(
-					node.getBytecodeName().substring(0, excl))) || shadowSig
-					.getName().equals(node.getBytecodeName()))
-					&& shadowSig.getSignature().equals(
-							node.getBytecodeSignature())
-					&& sourceLinesMatch(node.getSourceLocation(), shadow
-							.getSourceLocation())) {
+			if (((excl != -1 && shadowSig.getName().equals(node.getBytecodeName().substring(0, excl))) || shadowSig.getName()
+					.equals(node.getBytecodeName()))
+					&& shadowSig.getSignature().equals(node.getBytecodeSignature())
+					&& sourceLinesMatch(node.getSourceLocation(), shadow.getSourceLocation())) {
 				return node;
 			}
 		}
@@ -346,11 +295,9 @@ public class AsmRelationshipProvider {
 
 		// XXX why not use shadow file? new SourceLocation(sl.getSourceFile(),
 		// sl.getLine()),
-		SourceLocation peLoc = new SourceLocation(enclosingNode
-				.getSourceLocation().getSourceFile(), sl.getLine());
+		SourceLocation peLoc = new SourceLocation(enclosingNode.getSourceLocation().getSourceFile(), sl.getLine());
 		peLoc.setOffset(sl.getOffset());
-		IProgramElement peNode = new ProgramElement(shadow.toString(),
-				IProgramElement.Kind.CODE, peLoc, 0, null, null);
+		IProgramElement peNode = new ProgramElement(asm, shadow.toString(), IProgramElement.Kind.CODE, peLoc, 0, null, null);
 
 		// check to see if the enclosing shadow already has children with the
 		// same name. If so we want to add a counter to the byteCodeName
@@ -363,8 +310,7 @@ public class AsmRelationshipProvider {
 				numberOfChildrenWithThisName++;
 			}
 		}
-		peNode.setBytecodeName(shadowSig.getName() + "!"
-				+ String.valueOf(numberOfChildrenWithThisName + 1));
+		peNode.setBytecodeName(shadowSig.getName() + "!" + String.valueOf(numberOfChildrenWithThisName + 1));
 		peNode.setBytecodeSignature(shadowSig.getSignature());
 		enclosingNode.addChild(peNode);
 		return peNode;
@@ -372,20 +318,16 @@ public class AsmRelationshipProvider {
 
 	protected IProgramElement lookupMember(IHierarchy model, Member member) {
 		UnresolvedType declaringType = member.getDeclaringType();
-		IProgramElement classNode = model.findElementForType(declaringType
-				.getPackageName(), declaringType.getClassName());
+		IProgramElement classNode = model.findElementForType(declaringType.getPackageName(), declaringType.getClassName());
 		return findMemberInClass(classNode, member);
 	}
 
-	protected IProgramElement findMemberInClass(IProgramElement classNode,
-			Member member) {
+	protected IProgramElement findMemberInClass(IProgramElement classNode, Member member) {
 		if (classNode == null)
 			return null; // XXX remove this check
 		for (Iterator it = classNode.getChildren().iterator(); it.hasNext();) {
 			IProgramElement node = (IProgramElement) it.next();
-			if (member.getName().equals(node.getBytecodeName())
-					&& member.getSignature()
-							.equals(node.getBytecodeSignature())) {
+			if (member.getName().equals(node.getBytecodeName()) && member.getSignature().equals(node.getBytecodeSignature())) {
 				return node;
 			}
 		}
@@ -425,16 +367,15 @@ public class AsmRelationshipProvider {
 	}
 
 	/**
-	 * Add a relationship to the known set for a declare @method/@constructor
-	 * construct. Locating the method is a messy (for messy read 'fragile') bit
-	 * of code that could break at any moment but it's working for my simple
-	 * testcase. Currently just fails silently if any of the lookup code doesn't
-	 * find anything...
+	 * Add a relationship to the known set for a declare @method/@constructor construct. Locating the method is a messy (for messy
+	 * read 'fragile') bit of code that could break at any moment but it's working for my simple testcase. Currently just fails
+	 * silently if any of the lookup code doesn't find anything...
+	 * 
+	 * @param hierarchy
 	 */
-	public void addDeclareAnnotationMethodRelationship(
-			ISourceLocation sourceLocation, String typename,
-			ResolvedMember method) {
-		if (!AsmManager.isCreatingModel())
+	public void addDeclareAnnotationMethodRelationship(ISourceLocation sourceLocation, String typename, ResolvedMember method,
+			AsmManager structureModel) {
+		if (structureModel == null) // !AsmManager.isCreatingModel())
 			return;
 
 		String pkg = null;
@@ -445,8 +386,9 @@ public class AsmRelationshipProvider {
 			type = typename.substring(packageSeparator + 1);
 		}
 
-		IProgramElement typeElem = AsmManager.getDefault().getHierarchy()
-				.findElementForType(pkg, type);
+		IHierarchy hierarchy = structureModel.getHierarchy();
+
+		IProgramElement typeElem = hierarchy.findElementForType(pkg, type);
 		if (typeElem == null)
 			return;
 
@@ -455,7 +397,7 @@ public class AsmRelationshipProvider {
 		// Type[] args = method.getArgumentTypes();
 		for (int i = 0; i < args.length; i++) {
 			String s = args[i].getName();// Utility.signatureToString(args[i].
-											// getName()getSignature(), false);
+			// getName()getSignature(), false);
 			parmString.append(s);
 			if ((i + 1) < args.length)
 				parmString.append(",");
@@ -465,19 +407,12 @@ public class AsmRelationshipProvider {
 
 		if (method.getName().startsWith("<init>")) {
 			// its a ctor
-			methodElem = AsmManager
-					.getDefault()
-					.getHierarchy()
-					.findElementForSignature(typeElem,
-							IProgramElement.Kind.CONSTRUCTOR, type + parmString);
+			methodElem = hierarchy.findElementForSignature(typeElem, IProgramElement.Kind.CONSTRUCTOR, type + parmString);
 			if (methodElem == null && args.length == 0)
 				methodElem = typeElem; // assume default ctor
 		} else {
 			// its a method
-			methodElem = AsmManager.getDefault().getHierarchy()
-					.findElementForSignature(typeElem,
-							IProgramElement.Kind.METHOD,
-							method.getName() + parmString);
+			methodElem = hierarchy.findElementForSignature(typeElem, IProgramElement.Kind.METHOD, method.getName() + parmString);
 		}
 
 		if (methodElem == null)
@@ -488,42 +423,32 @@ public class AsmRelationshipProvider {
 			if (targetHandle == null)
 				return;
 
-			IProgramElement sourceNode = AsmManager.getDefault().getHierarchy()
-					.findElementForSourceLine(sourceLocation);
-			String sourceHandle = AsmManager.getDefault().getHandleProvider()
-					.createHandleIdentifier(sourceNode);
+			IProgramElement sourceNode = hierarchy.findElementForSourceLine(sourceLocation);
+			String sourceHandle = structureModel.getHandleProvider().createHandleIdentifier(sourceNode);
 			if (sourceHandle == null)
 				return;
 
-			IRelationshipMap mapper = AsmManager.getDefault()
-					.getRelationshipMap();
-			IRelationship foreward = mapper.get(sourceHandle,
-					IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATES, false,
-					true);
+			IRelationshipMap mapper = structureModel.getRelationshipMap();
+			IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATES, false, true);
 			foreward.addTarget(targetHandle);
 
-			IRelationship back = mapper.get(targetHandle,
-					IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATED_BY, false,
-					true);
+			IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATED_BY, false, true);
 			back.addTarget(sourceHandle);
 		} catch (Throwable t) { // I'm worried about that code above, this will
-								// make sure we don't explode if it plays up
+			// make sure we don't explode if it plays up
 			t.printStackTrace(); // I know I know .. but I don't want to lose
-									// it!
+			// it!
 		}
 	}
 
 	/**
-	 * Add a relationship to the known set for a declare @field construct.
-	 * Locating the field is trickier than it might seem since we have no line
-	 * number info for it, we have to dig through the structure model under the
-	 * fields' type in order to locate it. Currently just fails silently if any
-	 * of the lookup code doesn't find anything...
+	 * Add a relationship to the known set for a declare @field construct. Locating the field is trickier than it might seem since
+	 * we have no line number info for it, we have to dig through the structure model under the fields' type in order to locate it.
+	 * Currently just fails silently if any of the lookup code doesn't find anything...
 	 */
-	public void addDeclareAnnotationFieldRelationship(
-			ISourceLocation sourceLocation, String typename,
+	public void addDeclareAnnotationFieldRelationship(AsmManager asm, ISourceLocation sourceLocation, String typename,
 			ResolvedMember field) {
-		if (!AsmManager.isCreatingModel())
+		if (asm == null) // !AsmManager.isCreatingModel())
 			return;
 
 		String pkg = null;
@@ -533,15 +458,12 @@ public class AsmRelationshipProvider {
 			pkg = typename.substring(0, packageSeparator);
 			type = typename.substring(packageSeparator + 1);
 		}
-
-		IProgramElement typeElem = AsmManager.getDefault().getHierarchy()
-				.findElementForType(pkg, type);
+		IHierarchy hierarchy = asm.getHierarchy();
+		IProgramElement typeElem = hierarchy.findElementForType(pkg, type);
 		if (typeElem == null)
 			return;
 
-		IProgramElement fieldElem = AsmManager.getDefault().getHierarchy()
-				.findElementForSignature(typeElem, IProgramElement.Kind.FIELD,
-						field.getName());
+		IProgramElement fieldElem = hierarchy.findElementForSignature(typeElem, IProgramElement.Kind.FIELD, field.getName());
 		if (fieldElem == null)
 			return;
 
@@ -549,21 +471,16 @@ public class AsmRelationshipProvider {
 		if (targetHandle == null)
 			return;
 
-		IProgramElement sourceNode = AsmManager.getDefault().getHierarchy()
-				.findElementForSourceLine(sourceLocation);
-		String sourceHandle = AsmManager.getDefault().getHandleProvider()
-				.createHandleIdentifier(sourceNode);
+		IProgramElement sourceNode = hierarchy.findElementForSourceLine(sourceLocation);
+		String sourceHandle = asm.getHandleProvider().createHandleIdentifier(sourceNode);
 		if (sourceHandle == null)
 			return;
 
-		IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
-		IRelationship foreward = mapper.get(sourceHandle,
-				IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATES, false, true);
+		IRelationshipMap mapper = asm.getRelationshipMap();
+		IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATES, false, true);
 		foreward.addTarget(targetHandle);
 
-		IRelationship back = mapper.get(targetHandle,
-				IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATED_BY, false,
-				true);
+		IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATED_BY, false, true);
 		back.addTarget(sourceHandle);
 	}
 
@@ -10,14 +10,12 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.weaver;
 
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Map;
 
-import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IRelationship;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
@@ -26,7 +24,6 @@ import org.aspectj.weaver.patterns.DeclareErrorOrWarning;
 import org.aspectj.weaver.patterns.PerClause;
 import org.aspectj.weaver.patterns.Pointcut;
 
-
 public class Checker extends ShadowMunger {
 
 	private String msg;
@@ -36,16 +33,16 @@ public class Checker extends ShadowMunger {
 		super(deow.getPointcut(), deow.getStart(), deow.getEnd(), deow.getSourceContext());
 		this.msg = deow.getMessage();
 		this.isError = deow.isError();
-	}		
-	
+	}
+
 	private Checker(Pointcut pc, int start, int end, ISourceContext context) {
-		super(pc,start,end,context);
+		super(pc, start, end, context);
 	}
 
-    public ShadowMunger concretize(ResolvedType fromType, World world, PerClause clause) {
-        pointcut = pointcut.concretize(fromType, getDeclaringType(), 0, this);
-        return this;
-    }
+	public ShadowMunger concretize(ResolvedType fromType, World world, PerClause clause) {
+		pointcut = pointcut.concretize(fromType, getDeclaringType(), 0, this);
+		return this;
+	}
 
 	public void specializeOn(Shadow shadow) {
 		throw new RuntimeException("illegal state");
@@ -54,13 +51,10 @@ public class Checker extends ShadowMunger {
 	public void implementOn(Shadow shadow) {
 		throw new RuntimeException("illegal state");
 	}
-	
-	public ShadowMunger parameterizeWith(ResolvedType declaringType,Map typeVariableMap) {
-		Checker ret = new Checker(
-							getPointcut().parameterizeWith(typeVariableMap,declaringType.getWorld()),
-							getStart(),
-							getEnd(),
-							this.sourceContext);
+
+	public ShadowMunger parameterizeWith(ResolvedType declaringType, Map typeVariableMap) {
+		Checker ret = new Checker(getPointcut().parameterizeWith(typeVariableMap, declaringType.getWorld()), getStart(), getEnd(),
+				this.sourceContext);
 		ret.msg = this.msg;
 		ret.isError = this.isError;
 		return ret;
@@ -68,25 +62,18 @@ public class Checker extends ShadowMunger {
 
 	public boolean match(Shadow shadow, World world) {
 		if (super.match(shadow, world)) {
-			IMessage message = new Message(
-				msg,
-				shadow.toString(),
-				isError ? IMessage.ERROR : IMessage.WARNING,
-				shadow.getSourceLocation(),
-                null,
-                new ISourceLocation[]{this.getSourceLocation()},true,
-				0, // id
-				-1,-1); // source start/end
-            
-            world.getMessageHandler().handleMessage(message);
-			
+			IMessage message = new Message(msg, shadow.toString(), isError ? IMessage.ERROR : IMessage.WARNING, shadow
+					.getSourceLocation(), null, new ISourceLocation[] { this.getSourceLocation() }, true, 0, // id
+					-1, -1); // source start/end
+
+			world.getMessageHandler().handleMessage(message);
+
 			if (world.getCrossReferenceHandler() != null) {
-				world.getCrossReferenceHandler().addCrossReference(this.getSourceLocation(),
-				  shadow.getSourceLocation(),
-				  (this.isError?IRelationship.Kind.DECLARE_ERROR:IRelationship.Kind.DECLARE_WARNING),false);
-			
+				world.getCrossReferenceHandler().addCrossReference(this.getSourceLocation(), shadow.getSourceLocation(),
+						(this.isError ? IRelationship.Kind.DECLARE_ERROR : IRelationship.Kind.DECLARE_WARNING), false);
+
 			}
-			
+
 			if (world.getModel() != null) {
 				AsmRelationshipProvider.getDefault().checkerMunger(world.getModel(), shadow, this);
 			}
@@ -97,39 +84,44 @@ public class Checker extends ShadowMunger {
 	public int compareTo(Object other) {
 		return 0;
 	}
-	
-	public Collection getThrownExceptions() { return Collections.EMPTY_LIST; }
 
-    /**
-     * Default to true
-     * FIXME Alex: ATAJ is that ok in all cases ? 
-     * @return
-     */
-    public boolean mustCheckExceptions() { return true; }
+	public Collection getThrownExceptions() {
+		return Collections.EMPTY_LIST;
+	}
 
+	/**
+	 * Default to true FIXME Alex: ATAJ is that ok in all cases ?
+	 * 
+	 * @return
+	 */
+	public boolean mustCheckExceptions() {
+		return true;
+	}
 
 	// XXX this perhaps ought to take account of the other fields in advice ...
-    public boolean equals(Object other) {
-        if (! (other instanceof Checker)) return false;
-        Checker o = (Checker) other;
-        return  
-          o.isError == isError &&
-        	 ((o.pointcut == null) ? (pointcut == null) : o.pointcut.equals(pointcut)) &&
-          (AsmManager.getDefault().getHandleProvider().dependsOnLocation()
-        		  ?((o.getSourceLocation()==null) ? (getSourceLocation()==null): o.getSourceLocation().equals(getSourceLocation())):true) // pr134471 - remove when handles are improved to be independent of location
-        	;
-    }
+	public boolean equals(Object other) {
+		if (!(other instanceof Checker))
+			return false;
+		Checker o = (Checker) other;
+		return o.isError == isError && ((o.pointcut == null) ? (pointcut == null) : o.pointcut.equals(pointcut))
+		// &&
+		// (AsmManager.getDefault().getHandleProvider().dependsOnLocation()
+		// ?((o.getSourceLocation()==null) ? (getSourceLocation()==null): o.getSourceLocation().equals(getSourceLocation())):true)
+		// // pr134471 - remove when handles are improved to be independent of location
+		;
+	}
 
 	private volatile int hashCode = -1;
-    public int hashCode() {
-    	if (hashCode == -1) {
-            int result = 17;
-            result = 37*result + (isError?1:0);
-            result = 37*result + ((pointcut == null) ? 0 : pointcut.hashCode());
-            hashCode = result;			
+
+	public int hashCode() {
+		if (hashCode == -1) {
+			int result = 17;
+			result = 37 * result + (isError ? 1 : 0);
+			result = 37 * result + ((pointcut == null) ? 0 : pointcut.hashCode());
+			hashCode = result;
 		}
-        return hashCode;
-    }
+		return hashCode;
+	}
 
 	public boolean isError() {
 		return isError;
@@ -10,7 +10,6 @@
  *     PARC     initial implementation 
  * ******************************************************************/
 
-
 package org.aspectj.weaver;
 
 import java.util.ArrayList;
@@ -21,68 +20,66 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
-import org.aspectj.asm.AsmManager;
 import org.aspectj.weaver.patterns.DeclareParents;
 import org.aspectj.weaver.patterns.IVerificationRequired;
 import org.aspectj.weaver.tools.Trace;
 import org.aspectj.weaver.tools.TraceFactory;
 
 /**
- * This holds on to all CrosscuttingMembers for a world.  It handles 
- * management of change.
+ * This holds on to all CrosscuttingMembers for a world. It handles management of change.
  * 
  * @author Jim Hugunin
  */
 public class CrosscuttingMembersSet {
-	//FIXME AV - ? we may need a sequencedHashMap there to ensure source based precedence for @AJ advice
-    private Map /* ResolvedType (the aspect) > CrosscuttingMembers */members = new HashMap();
-	
-	private List shadowMungers             = null;
-	private List typeMungers               = null;
-    private List lateTypeMungers           = null;
-	private List declareSofts              = null;
-	private List declareParents            = null;
-	private List declareAnnotationOnTypes  = null;
-	private List declareAnnotationOnFields = null; 
-	private List declareAnnotationOnMethods= null; // includes ctors
-	private List declareDominates          = null;
+	// FIXME AV - ? we may need a sequencedHashMap there to ensure source based precedence for @AJ advice
+	private final Map /* ResolvedType (the aspect) > CrosscuttingMembers */members = new HashMap();
+
+	private List shadowMungers = null;
+	private List typeMungers = null;
+	private List lateTypeMungers = null;
+	private List declareSofts = null;
+	private List declareParents = null;
+	private List declareAnnotationOnTypes = null;
+	private List declareAnnotationOnFields = null;
+	private List declareAnnotationOnMethods = null; // includes ctors
+	private List declareDominates = null;
 	private boolean changedSinceLastReset = false;
 
-	private List /*IVerificationRequired*/ verificationList = null; // List of things to be verified once the type system is 'complete'
-	
+	private List /* IVerificationRequired */verificationList = null; // List of things to be verified once the type system is
+																	// 'complete'
+
 	private static Trace trace = TraceFactory.getTraceFactory().getTrace(CrosscuttingMembersSet.class);
-	
+
 	public CrosscuttingMembersSet(World world) {
-		trace.enter("<init>",this,world);
+		trace.enter("<init>", this, world);
 
 		trace.exit("<init>");
 	}
 
 	public boolean addOrReplaceAspect(ResolvedType aspectType) {
-		return addOrReplaceAspect(aspectType,true);
+		return addOrReplaceAspect(aspectType, true);
 	}
 
 	/**
-	 * @return whether or not that was a change to the global signature
-	 * 			XXX for efficiency we will need a richer representation than this
+	 * @return whether or not that was a change to the global signature XXX for efficiency we will need a richer representation than
+	 *         this
 	 */
 	public boolean addOrReplaceAspect(ResolvedType aspectType, boolean inWeavingPhase) {
-		trace.enter("addOrReplaceAspect",this,new Object[] {aspectType,new Boolean(inWeavingPhase)});
-		
+		trace.enter("addOrReplaceAspect", this, new Object[] { aspectType, new Boolean(inWeavingPhase) });
+
 		boolean change = false;
-		CrosscuttingMembers xcut = (CrosscuttingMembers)members.get(aspectType);
+		CrosscuttingMembers xcut = (CrosscuttingMembers) members.get(aspectType);
 		if (xcut == null) {
 			members.put(aspectType, aspectType.collectCrosscuttingMembers(inWeavingPhase));
 			clearCaches();
 			change = true;
 		} else {
-			if (xcut.replaceWith(aspectType.collectCrosscuttingMembers(inWeavingPhase),inWeavingPhase)) {
+			if (xcut.replaceWith(aspectType.collectCrosscuttingMembers(inWeavingPhase), inWeavingPhase)) {
 				clearCaches();
 				change = true;
 			} else {
-				if (!AsmManager.getDefault().getHandleProvider().dependsOnLocation()
-						&& inWeavingPhase) {
-					// bug 134541 - even though we haven't changed we may have updated the 
+				if (inWeavingPhase) {
+					// bug 134541 - even though we haven't changed we may have updated the
 					// sourcelocation for the shadowMunger which we need to pick up
 					shadowMungers = null;
 				}
@@ -91,221 +88,218 @@ public class CrosscuttingMembersSet {
 		}
 		if (aspectType.isAbstract()) {
 			// we might have sub-aspects that need to re-collect their crosscutting members from us
-			boolean ancestorChange = addOrReplaceDescendantsOf(aspectType,inWeavingPhase); 
+			boolean ancestorChange = addOrReplaceDescendantsOf(aspectType, inWeavingPhase);
 			change = change || ancestorChange;
 		}
 		changedSinceLastReset = changedSinceLastReset || change;
 
-		trace.exit("addOrReplaceAspect",change);
+		trace.exit("addOrReplaceAspect", change);
 		return change;
 	}
-    
+
 	private boolean addOrReplaceDescendantsOf(ResolvedType aspectType, boolean inWeavePhase) {
-		//System.err.println("Looking at descendants of "+aspectType.getName());
+		// System.err.println("Looking at descendants of "+aspectType.getName());
 		Set knownAspects = members.keySet();
 		Set toBeReplaced = new HashSet();
-		for(Iterator it = knownAspects.iterator(); it.hasNext(); ) {
-			ResolvedType candidateDescendant = (ResolvedType)it.next();
+		for (Iterator it = knownAspects.iterator(); it.hasNext();) {
+			ResolvedType candidateDescendant = (ResolvedType) it.next();
 			if ((candidateDescendant != aspectType) && (aspectType.isAssignableFrom(candidateDescendant))) {
 				toBeReplaced.add(candidateDescendant);
 			}
 		}
 		boolean change = false;
-		for (Iterator it = toBeReplaced.iterator(); it.hasNext(); ) {
-			ResolvedType next = (ResolvedType)it.next();
-			boolean thisChange = addOrReplaceAspect(next,inWeavePhase);
+		for (Iterator it = toBeReplaced.iterator(); it.hasNext();) {
+			ResolvedType next = (ResolvedType) it.next();
+			boolean thisChange = addOrReplaceAspect(next, inWeavePhase);
 			change = change || thisChange;
 		}
 		return change;
 	}
-	
-    public void addAdviceLikeDeclares(ResolvedType aspectType) {
-        CrosscuttingMembers xcut = (CrosscuttingMembers)members.get(aspectType);
-        xcut.addDeclares(aspectType.collectDeclares(true));
-    }
-	
+
+	public void addAdviceLikeDeclares(ResolvedType aspectType) {
+		CrosscuttingMembers xcut = (CrosscuttingMembers) members.get(aspectType);
+		xcut.addDeclares(aspectType.collectDeclares(true));
+	}
+
 	public boolean deleteAspect(UnresolvedType aspectType) {
 		boolean isAspect = members.remove(aspectType) != null;
 		clearCaches();
 		return isAspect;
 	}
-	
+
 	public boolean containsAspect(UnresolvedType aspectType) {
 		return members.containsKey(aspectType);
 	}
-    
-	//XXX only for testing
+
+	// XXX only for testing
 	public void addFixedCrosscuttingMembers(ResolvedType aspectType) {
 		members.put(aspectType, aspectType.crosscuttingMembers);
 		clearCaches();
 	}
-	
-	
+
 	private void clearCaches() {
 		shadowMungers = null;
 		typeMungers = null;
-        lateTypeMungers = null;
+		lateTypeMungers = null;
 		declareSofts = null;
 		declareParents = null;
-		declareAnnotationOnFields=null;
-		declareAnnotationOnMethods=null;
-		declareAnnotationOnTypes=null;
+		declareAnnotationOnFields = null;
+		declareAnnotationOnMethods = null;
+		declareAnnotationOnTypes = null;
 		declareDominates = null;
 	}
-	
-	
+
 	public List getShadowMungers() {
 		if (shadowMungers == null) {
 			ArrayList ret = new ArrayList();
-			for (Iterator i = members.values().iterator(); i.hasNext(); ) {
-				ret.addAll(((CrosscuttingMembers)i.next()).getShadowMungers());
+			for (Iterator i = members.values().iterator(); i.hasNext();) {
+				ret.addAll(((CrosscuttingMembers) i.next()).getShadowMungers());
 			}
 			shadowMungers = ret;
 		}
 		return shadowMungers;
 	}
-	
+
 	public List getTypeMungers() {
 		if (typeMungers == null) {
 			ArrayList ret = new ArrayList();
-			for (Iterator i = members.values().iterator(); i.hasNext(); ) {
-				ret.addAll(((CrosscuttingMembers)i.next()).getTypeMungers());
+			for (Iterator i = members.values().iterator(); i.hasNext();) {
+				ret.addAll(((CrosscuttingMembers) i.next()).getTypeMungers());
 			}
 			typeMungers = ret;
 		}
 		return typeMungers;
 	}
 
-    public List getLateTypeMungers() {
-        if (lateTypeMungers == null) {
-            ArrayList ret = new ArrayList();
-            for (Iterator i = members.values().iterator(); i.hasNext(); ) {
-                ret.addAll(((CrosscuttingMembers)i.next()).getLateTypeMungers());
-            }
-            lateTypeMungers = ret;
-        }
-        return lateTypeMungers;
-    }
+	public List getLateTypeMungers() {
+		if (lateTypeMungers == null) {
+			ArrayList ret = new ArrayList();
+			for (Iterator i = members.values().iterator(); i.hasNext();) {
+				ret.addAll(((CrosscuttingMembers) i.next()).getLateTypeMungers());
+			}
+			lateTypeMungers = ret;
+		}
+		return lateTypeMungers;
+	}
 
 	public List getDeclareSofts() {
 		if (declareSofts == null) {
 			Set ret = new HashSet();
-			for (Iterator i = members.values().iterator(); i.hasNext(); ) {
-				ret.addAll(((CrosscuttingMembers)i.next()).getDeclareSofts());
+			for (Iterator i = members.values().iterator(); i.hasNext();) {
+				ret.addAll(((CrosscuttingMembers) i.next()).getDeclareSofts());
 			}
 			declareSofts = new ArrayList();
 			declareSofts.addAll(ret);
 		}
 		return declareSofts;
 	}
-	
+
 	public List getDeclareParents() {
 		if (declareParents == null) {
 			Set ret = new HashSet();
-			for (Iterator i = members.values().iterator(); i.hasNext(); ) {
-				ret.addAll(((CrosscuttingMembers)i.next()).getDeclareParents());
+			for (Iterator i = members.values().iterator(); i.hasNext();) {
+				ret.addAll(((CrosscuttingMembers) i.next()).getDeclareParents());
 			}
 			declareParents = new ArrayList();
 			declareParents.addAll(ret);
 		}
 		return declareParents;
 	}
-	
+
 	// DECAT Merge multiple together
 	public List getDeclareAnnotationOnTypes() {
 		if (declareAnnotationOnTypes == null) {
 			Set ret = new HashSet();
-			for (Iterator i = members.values().iterator(); i.hasNext(); ) {
-				ret.addAll(((CrosscuttingMembers)i.next()).getDeclareAnnotationOnTypes());
+			for (Iterator i = members.values().iterator(); i.hasNext();) {
+				ret.addAll(((CrosscuttingMembers) i.next()).getDeclareAnnotationOnTypes());
 			}
 			declareAnnotationOnTypes = new ArrayList();
 			declareAnnotationOnTypes.addAll(ret);
 		}
 		return declareAnnotationOnTypes;
 	}
-	
+
 	public List getDeclareAnnotationOnFields() {
 		if (declareAnnotationOnFields == null) {
 			Set ret = new HashSet();
-			for (Iterator i = members.values().iterator(); i.hasNext(); ) {
-				ret.addAll(((CrosscuttingMembers)i.next()).getDeclareAnnotationOnFields());
+			for (Iterator i = members.values().iterator(); i.hasNext();) {
+				ret.addAll(((CrosscuttingMembers) i.next()).getDeclareAnnotationOnFields());
 			}
 			declareAnnotationOnFields = new ArrayList();
 			declareAnnotationOnFields.addAll(ret);
 		}
 		return declareAnnotationOnFields;
 	}
-	
+
 	/**
 	 * Return an amalgamation of the declare @method/@constructor statements.
 	 */
 	public List getDeclareAnnotationOnMethods() {
 		if (declareAnnotationOnMethods == null) {
 			Set ret = new HashSet();
-			for (Iterator i = members.values().iterator(); i.hasNext(); ) {
-				ret.addAll(((CrosscuttingMembers)i.next()).getDeclareAnnotationOnMethods());
+			for (Iterator i = members.values().iterator(); i.hasNext();) {
+				ret.addAll(((CrosscuttingMembers) i.next()).getDeclareAnnotationOnMethods());
 			}
 			declareAnnotationOnMethods = new ArrayList();
 			declareAnnotationOnMethods.addAll(ret);
 		}
 		return declareAnnotationOnMethods;
 	}
-	
+
 	public List getDeclareDominates() {
 		if (declareDominates == null) {
 			ArrayList ret = new ArrayList();
-			for (Iterator i = members.values().iterator(); i.hasNext(); ) {
-				ret.addAll(((CrosscuttingMembers)i.next()).getDeclareDominates());
+			for (Iterator i = members.values().iterator(); i.hasNext();) {
+				ret.addAll(((CrosscuttingMembers) i.next()).getDeclareDominates());
 			}
 			declareDominates = ret;
 		}
 		return declareDominates;
 	}
 
-
 	public ResolvedType findAspectDeclaringParents(DeclareParents p) {
 		Set keys = this.members.keySet();
 		for (Iterator iter = keys.iterator(); iter.hasNext();) {
 			ResolvedType element = (ResolvedType) iter.next();
-			for (Iterator i = ((CrosscuttingMembers)members.get(element)).getDeclareParents().iterator(); i.hasNext(); ) {
-				DeclareParents dp = (DeclareParents)i.next();
-				if (dp.equals(p)) return element;
+			for (Iterator i = ((CrosscuttingMembers) members.get(element)).getDeclareParents().iterator(); i.hasNext();) {
+				DeclareParents dp = (DeclareParents) i.next();
+				if (dp.equals(p))
+					return element;
 			}
 		}
 		return null;
 	}
 
 	public void reset() {
-		verificationList=null;
+		verificationList = null;
 		changedSinceLastReset = false;
 	}
-	
+
 	public boolean hasChangedSinceLastReset() {
 		return changedSinceLastReset;
 	}
 
 	/**
-	 * Record something that needs verifying when we believe the type system is complete.
-	 * Used for things that can't be verified as we go along - for example some
-	 * recursive type variable references (pr133307)
+	 * Record something that needs verifying when we believe the type system is complete. Used for things that can't be verified as
+	 * we go along - for example some recursive type variable references (pr133307)
 	 */
 	public void recordNecessaryCheck(IVerificationRequired verification) {
-		if (verificationList==null) verificationList = new ArrayList();
+		if (verificationList == null)
+			verificationList = new ArrayList();
 		verificationList.add(verification);
 	}
-	
-	
+
 	/**
-	 * Called when type bindings are complete - calls all registered verification
-	 * objects in turn.
+	 * Called when type bindings are complete - calls all registered verification objects in turn.
 	 */
 	public void verify() {
-		if (verificationList==null) return;
+		if (verificationList == null)
+			return;
 		for (Iterator iter = verificationList.iterator(); iter.hasNext();) {
 			IVerificationRequired element = (IVerificationRequired) iter.next();
 			element.verify();
 		}
 		verificationList = null;
 	}
-	
+
 }
@@ -99,12 +99,12 @@ public abstract class ShadowMunger implements PartialOrder.PartialComparable, IH
 		return sourceLocation;
 	}
 
-	public String getHandle() {
+	public String getHandle(AsmManager asm) {
 		if (null == handle) {
 			ISourceLocation sl = getSourceLocation();
 			if (sl != null) {
-				IProgramElement ipe = AsmManager.getDefault().getHierarchy().findElementForSourceLine(sl);
-				handle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(ipe);
+				IProgramElement ipe = asm.getHierarchy().findElementForSourceLine(sl);
+				handle = asm.getHandleProvider().createHandleIdentifier(ipe);
 			}
 		}
 		return handle;
@@ -152,11 +152,11 @@ public abstract class ShadowMunger implements PartialOrder.PartialComparable, IH
 	/**
 	 * Creates the hierarchy for binary aspects
 	 */
-	public void createHierarchy() {
+	public void createHierarchy(AsmManager asm) {
 		if (!isBinary())
 			return;
 
-		IProgramElement sourceFileNode = AsmManager.getDefault().getHierarchy().findElementForSourceLine(getSourceLocation());
+		IProgramElement sourceFileNode = asm.getHierarchy().findElementForSourceLine(getSourceLocation());
 		// the call to findElementForSourceLine(ISourceLocation) returns a file
 		// node
 		// if it can't find a node in the hierarchy for the given
@@ -170,25 +170,23 @@ public abstract class ShadowMunger implements PartialOrder.PartialComparable, IH
 		ResolvedType aspect = getDeclaringType();
 
 		// create the class file node
-		IProgramElement classFileNode = new ProgramElement(sourceFileNode.getName(), IProgramElement.Kind.FILE,
+		IProgramElement classFileNode = new ProgramElement(asm, sourceFileNode.getName(), IProgramElement.Kind.FILE,
 				getBinarySourceLocation(aspect.getSourceLocation()), 0, null, null);
 
 		// create package ipe if one exists....
-		IProgramElement root = AsmManager.getDefault().getHierarchy().getRoot();
-		IProgramElement binaries = AsmManager.getDefault().getHierarchy().findElementForLabel(root,
-				IProgramElement.Kind.SOURCE_FOLDER, "binaries");
+		IProgramElement root = asm.getHierarchy().getRoot();
+		IProgramElement binaries = asm.getHierarchy().findElementForLabel(root, IProgramElement.Kind.SOURCE_FOLDER, "binaries");
 		if (binaries == null) {
-			binaries = new ProgramElement("binaries", IProgramElement.Kind.SOURCE_FOLDER, new ArrayList());
+			binaries = new ProgramElement(asm, "binaries", IProgramElement.Kind.SOURCE_FOLDER, new ArrayList());
 			root.addChild(binaries);
 		}
 		// if (aspect.getPackageName() != null) {
 		String packagename = aspect.getPackageName() == null ? "" : aspect.getPackageName();
 		// check that there doesn't already exist a node with this name
-		IProgramElement pkgNode = AsmManager.getDefault().getHierarchy().findElementForLabel(binaries,
-				IProgramElement.Kind.PACKAGE, packagename);
+		IProgramElement pkgNode = asm.getHierarchy().findElementForLabel(binaries, IProgramElement.Kind.PACKAGE, packagename);
 		// note packages themselves have no source location
 		if (pkgNode == null) {
-			pkgNode = new ProgramElement(packagename, IProgramElement.Kind.PACKAGE, new ArrayList());
+			pkgNode = new ProgramElement(asm, packagename, IProgramElement.Kind.PACKAGE, new ArrayList());
 			binaries.addChild(pkgNode);
 			pkgNode.addChild(classFileNode);
 		} else {
@@ -223,21 +221,21 @@ public abstract class ShadowMunger implements PartialOrder.PartialComparable, IH
 		// }
 
 		// add and create empty import declaration ipe
-		classFileNode
-				.addChild(new ProgramElement("import declarations", IProgramElement.Kind.IMPORT_REFERENCE, null, 0, null, null));
+		classFileNode.addChild(new ProgramElement(asm, "import declarations", IProgramElement.Kind.IMPORT_REFERENCE, null, 0, null,
+				null));
 
 		// add and create aspect ipe
-		IProgramElement aspectNode = new ProgramElement(aspect.getSimpleName(), IProgramElement.Kind.ASPECT,
+		IProgramElement aspectNode = new ProgramElement(asm, aspect.getSimpleName(), IProgramElement.Kind.ASPECT,
 				getBinarySourceLocation(aspect.getSourceLocation()), aspect.getModifiers(), null, null);
 		classFileNode.addChild(aspectNode);
 
-		addChildNodes(aspectNode, aspect.getDeclaredPointcuts());
+		addChildNodes(asm, aspectNode, aspect.getDeclaredPointcuts());
 
-		addChildNodes(aspectNode, aspect.getDeclaredAdvice());
-		addChildNodes(aspectNode, aspect.getDeclares());
+		addChildNodes(asm, aspectNode, aspect.getDeclaredAdvice());
+		addChildNodes(asm, aspectNode, aspect.getDeclares());
 	}
 
-	private void addChildNodes(IProgramElement parent, ResolvedMember[] children) {
+	private void addChildNodes(AsmManager asm, IProgramElement parent, ResolvedMember[] children) {
 		for (int i = 0; i < children.length; i++) {
 			ResolvedMember pcd = children[i];
 			if (pcd instanceof ResolvedPointcutDefinition) {
@@ -246,13 +244,13 @@ public abstract class ShadowMunger implements PartialOrder.PartialComparable, IH
 				if (sLoc == null) {
 					sLoc = rpcd.getSourceLocation();
 				}
-				parent.addChild(new ProgramElement(pcd.getName(), IProgramElement.Kind.POINTCUT, getBinarySourceLocation(sLoc), pcd
-						.getModifiers(), null, Collections.EMPTY_LIST));
+				parent.addChild(new ProgramElement(asm, pcd.getName(), IProgramElement.Kind.POINTCUT,
+						getBinarySourceLocation(sLoc), pcd.getModifiers(), null, Collections.EMPTY_LIST));
 			}
 		}
 	}
 
-	private void addChildNodes(IProgramElement parent, Collection children) {
+	private void addChildNodes(AsmManager asm, IProgramElement parent, Collection children) {
 		int deCtr = 1;
 		int dwCtr = 1;
 		for (Iterator iter = children.iterator(); iter.hasNext();) {
@@ -265,16 +263,16 @@ public abstract class ShadowMunger implements PartialOrder.PartialComparable, IH
 				} else {
 					counter = dwCtr++;
 				}
-				parent.addChild(createDeclareErrorOrWarningChild(decl, counter));
+				parent.addChild(createDeclareErrorOrWarningChild(asm, decl, counter));
 			} else if (element instanceof Advice) {
 				Advice advice = (Advice) element;
-				parent.addChild(createAdviceChild(advice));
+				parent.addChild(createAdviceChild(asm, advice));
 			}
 		}
 	}
 
-	private IProgramElement createDeclareErrorOrWarningChild(DeclareErrorOrWarning decl, int count) {
-		IProgramElement deowNode = new ProgramElement(decl.getName(), decl.isError() ? IProgramElement.Kind.DECLARE_ERROR
+	private IProgramElement createDeclareErrorOrWarningChild(AsmManager asm, DeclareErrorOrWarning decl, int count) {
+		IProgramElement deowNode = new ProgramElement(asm, decl.getName(), decl.isError() ? IProgramElement.Kind.DECLARE_ERROR
 				: IProgramElement.Kind.DECLARE_WARNING, getBinarySourceLocation(decl.getSourceLocation()), decl.getDeclaringType()
 				.getModifiers(), null, null);
 		deowNode.setDetails("\"" + AsmRelationshipUtils.genDeclareMessage(decl.getMessage()) + "\"");
@@ -284,8 +282,8 @@ public abstract class ShadowMunger implements PartialOrder.PartialComparable, IH
 		return deowNode;
 	}
 
-	private IProgramElement createAdviceChild(Advice advice) {
-		IProgramElement adviceNode = new ProgramElement(advice.kind.getName(), IProgramElement.Kind.ADVICE,
+	private IProgramElement createAdviceChild(AsmManager asm, Advice advice) {
+		IProgramElement adviceNode = new ProgramElement(asm, advice.kind.getName(), IProgramElement.Kind.ADVICE,
 				getBinarySourceLocation(advice.getSourceLocation()), advice.signature.getModifiers(), null, Collections.EMPTY_LIST);
 		adviceNode.setDetails(AsmRelationshipUtils.genPointcutDetails(advice.getPointcut()));
 		adviceNode.setBytecodeName(advice.getSignature().getName());
@@ -28,7 +28,7 @@ import java.util.Properties;
 import java.util.Set;
 import java.util.WeakHashMap;
 
-import org.aspectj.asm.IHierarchy;
+import org.aspectj.asm.AsmManager;
 import org.aspectj.bridge.IMessageHandler;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.bridge.Message;
@@ -50,14 +50,12 @@ public abstract class World implements Dump.INode {
 	private IMessageHandler messageHandler = IMessageHandler.SYSTEM_ERR;
 
 	/**
-	 * handler for cross-reference information produced during the weaving
-	 * process
+	 * handler for cross-reference information produced during the weaving process
 	 */
 	private ICrossReferenceHandler xrefHandler = null;
 
 	/**
-	 * Currently 'active' scope in which to lookup (resolve) typevariable
-	 * references
+	 * Currently 'active' scope in which to lookup (resolve) typevariable references
 	 */
 	private TypeVariableDeclaringElement typeVariableLookupScope;
 
@@ -78,7 +76,7 @@ public abstract class World implements Dump.INode {
 	private final CrosscuttingMembersSet crosscuttingMembersSet = new CrosscuttingMembersSet(this);
 
 	/** Model holds ASM relationships */
-	private IHierarchy model = null;
+	private AsmManager model = null;
 
 	/** for processing Xlint messages */
 	private Lint lint = new Lint(this);
@@ -93,8 +91,7 @@ public abstract class World implements Dump.INode {
 	private boolean XhasMember = false;
 
 	/**
-	 * Xpinpoint controls whether we put out developer info showing the source
-	 * of messages
+	 * Xpinpoint controls whether we put out developer info showing the source of messages
 	 */
 	private boolean Xpinpoint = false;
 
@@ -136,14 +133,12 @@ public abstract class World implements Dump.INode {
 	private long warningThreshold;
 
 	/**
-	 * A list of RuntimeExceptions containing full stack information for every
-	 * type we couldn't find.
+	 * A list of RuntimeExceptions containing full stack information for every type we couldn't find.
 	 */
 	private List dumpState_cantFindTypeExceptions = null;
 
 	/**
-	 * Play God. On the first day, God created the primitive types and put them
-	 * in the type map.
+	 * Play God. On the first day, God created the primitive types and put them in the type map.
 	 */
 	protected World() {
 		super();
@@ -183,10 +178,10 @@ public abstract class World implements Dump.INode {
 		}
 	}
 
-	//==========================================================================
+	// ==========================================================================
 	// ===
 	// T Y P E R E S O L U T I O N
-	//==========================================================================
+	// ==========================================================================
 	// ===
 
 	/**
@@ -197,10 +192,8 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * Attempt to resolve a type - the source location gives you some context in
-	 * which resolution is taking place. In the case of an error where we can't
-	 * find the type - we can then at least report why (source location) we were
-	 * trying to resolve it.
+	 * Attempt to resolve a type - the source location gives you some context in which resolution is taking place. In the case of an
+	 * error where we can't find the type - we can then at least report why (source location) we were trying to resolve it.
 	 */
 	public ResolvedType resolve(UnresolvedType ty, ISourceLocation isl) {
 		ResolvedType ret = resolve(ty, true);
@@ -220,8 +213,8 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * Convenience method for resolving an array of unresolved types in one hit.
-	 * Useful for e.g. resolving type parameters in signatures.
+	 * Convenience method for resolving an array of unresolved types in one hit. Useful for e.g. resolving type parameters in
+	 * signatures.
 	 */
 	public ResolvedType[] resolve(UnresolvedType[] types) {
 		if (types == null)
@@ -235,8 +228,7 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * Resolve a type. This the hub of type resolution. The resolved type is
-	 * added to the type map by signature.
+	 * Resolve a type. This the hub of type resolution. The resolved type is added to the type map by signature.
 	 */
 	public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) {
 
@@ -299,16 +291,14 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * Called when a type is resolved - enables its type hierarchy to be
-	 * finished off before we proceed
+	 * Called when a type is resolved - enables its type hierarchy to be finished off before we proceed
 	 */
 	protected void completeBinaryType(ResolvedType ret) {
 	}
 
 	/**
-	 * Return true if the classloader relating to this world is definetly the
-	 * one that will define the specified class. Return false otherwise or we
-	 * don't know for certain.
+	 * Return true if the classloader relating to this world is definetly the one that will define the specified class. Return false
+	 * otherwise or we don't know for certain.
 	 */
 	public boolean isLocallyDefined(String classname) {
 		return false;
@@ -333,10 +323,8 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * Some TypeFactory operations create resolved types directly, but these
-	 * won't be in the typeMap - this resolution process puts them there.
-	 * Resolved types are also told their world which is needed for the special
-	 * autoboxing resolved types.
+	 * Some TypeFactory operations create resolved types directly, but these won't be in the typeMap - this resolution process puts
+	 * them there. Resolved types are also told their world which is needed for the special autoboxing resolved types.
 	 */
 	public ResolvedType resolve(ResolvedType ty) {
 		if (ty.isTypeVariableReference())
@@ -351,8 +339,7 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * Convenience method for finding a type by name and resolving it in one
-	 * step.
+	 * Convenience method for finding a type by name and resolving it in one step.
 	 */
 	public ResolvedType resolve(String name) {
 		// trace.enter("resolve", this, new Object[] {name});
@@ -366,8 +353,8 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * Resolve to a ReferenceType - simple, raw, parameterized, or generic. Raw,
-	 * parameterized, and generic versions of a type share a delegate.
+	 * Resolve to a ReferenceType - simple, raw, parameterized, or generic. Raw, parameterized, and generic versions of a type share
+	 * a delegate.
 	 */
 	private final ResolvedType resolveToReferenceType(UnresolvedType ty, boolean allowMissing) {
 		if (ty.isParameterizedType()) {
@@ -480,8 +467,7 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * Go from an unresolved generic wildcard (represented by UnresolvedType) to
-	 * a resolved version (BoundedReferenceType).
+	 * Go from an unresolved generic wildcard (represented by UnresolvedType) to a resolved version (BoundedReferenceType).
 	 */
 	private ReferenceType resolveGenericWildcardFor(WildcardedUnresolvedType aType) {
 		BoundedReferenceType ret = null;
@@ -501,15 +487,13 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * Find the ReferenceTypeDelegate behind this reference type so that it can
-	 * fulfill its contract.
+	 * Find the ReferenceTypeDelegate behind this reference type so that it can fulfill its contract.
 	 */
 	protected abstract ReferenceTypeDelegate resolveDelegate(ReferenceType ty);
 
 	/**
-	 * Special resolution for "core" types like OBJECT. These are resolved just
-	 * like any other type, but if they are not found it is more serious and we
-	 * issue an error message immediately.
+	 * Special resolution for "core" types like OBJECT. These are resolved just like any other type, but if they are not found it is
+	 * more serious and we issue an error message immediately.
 	 */
 	// OPTIMIZE streamline path for core types? They are just simple types,
 	// could look straight in the typemap?
@@ -522,8 +506,7 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * Lookup a type by signature, if not found then build one and put it in the
-	 * map.
+	 * Lookup a type by signature, if not found then build one and put it in the map.
 	 */
 	public ReferenceType lookupOrCreateName(UnresolvedType ty) {
 		String signature = ty.getSignature();
@@ -536,22 +519,20 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * Lookup a reference type in the world by its signature. Returns null if
-	 * not found.
+	 * Lookup a reference type in the world by its signature. Returns null if not found.
 	 */
 	public ReferenceType lookupBySignature(String signature) {
 		return (ReferenceType) typeMap.get(signature);
 	}
 
-	//==========================================================================
+	// ==========================================================================
 	// ===
 	// T Y P E R E S O L U T I O N -- E N D
-	//==========================================================================
+	// ==========================================================================
 	// ===
 
 	/**
-	 * Member resolution is achieved by resolving the declaring type and then
-	 * looking up the member in the resolved declaring type.
+	 * Member resolution is achieved by resolving the declaring type and then looking up the member in the resolved declaring type.
 	 */
 	public ResolvedMember resolve(Member member) {
 		ResolvedType declaring = member.getDeclaringType().resolve(this);
@@ -588,8 +569,7 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * Same signature as
-	 * org.aspectj.util.PartialOrder.PartialComparable.compareTo
+	 * Same signature as org.aspectj.util.PartialOrder.PartialComparable.compareTo
 	 */
 	public int compareByPrecedence(ResolvedType aspect1, ResolvedType aspect2) {
 		return precedenceCalculator.compareByPrecedence(aspect1, aspect2);
@@ -600,8 +580,7 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * compares by precedence with the additional rule that a super-aspect is
-	 * sorted before its sub-aspects
+	 * compares by precedence with the additional rule that a super-aspect is sorted before its sub-aspects
 	 */
 	public int compareByPrecedenceAndHierarchy(ResolvedType aspect1, ResolvedType aspect2) {
 		return precedenceCalculator.compareByPrecedenceAndHierarchy(aspect1, aspect2);
@@ -611,8 +590,7 @@ public abstract class World implements Dump.INode {
 	// ===========================================================
 
 	/**
-	 * Nobody should hold onto a copy of this message handler, or
-	 * setMessageHandler won't work right.
+	 * Nobody should hold onto a copy of this message handler, or setMessageHandler won't work right.
 	 */
 	public IMessageHandler getMessageHandler() {
 		return messageHandler;
@@ -627,8 +605,8 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * convenenience method for creating and issuing messages via the message
-	 * handler - if you supply two locations you will get two messages.
+	 * convenenience method for creating and issuing messages via the message handler - if you supply two locations you will get two
+	 * messages.
 	 */
 	public void showMessage(Kind kind, String message, ISourceLocation loc1, ISourceLocation loc2) {
 		if (loc1 != null) {
@@ -684,11 +662,11 @@ public abstract class World implements Dump.INode {
 		return crosscuttingMembersSet;
 	}
 
-	public IHierarchy getModel() {
+	public AsmManager getModel() {
 		return model;
 	}
 
-	public void setModel(IHierarchy model) {
+	public void setModel(AsmManager model) {
 		this.model = model;
 	}
 
@@ -737,8 +715,7 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * Set the error and warning threashold which can be taken from
-	 * CompilerOptions (see bug 129282)
+	 * Set the error and warning threashold which can be taken from CompilerOptions (see bug 129282)
 	 * 
 	 * @param errorThreshold
 	 * @param warningThreshold
@@ -749,8 +726,7 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * @return true if ignoring the UnusedDeclaredThrownException and false if
-	 *         this compiler option is set to error or warning
+	 * @return true if ignoring the UnusedDeclaredThrownException and false if this compiler option is set to error or warning
 	 */
 	public boolean isIgnoringUnusedDeclaredThrownException() {
 		// the 0x800000 is CompilerOptions.UnusedDeclaredThrownException
@@ -860,15 +836,13 @@ public abstract class World implements Dump.INode {
 			b = true;
 		else
 			b = getTargetAspectjRuntimeLevel().equals(org.aspectj.weaver.Constants.RUNTIME_LEVEL_12);
-		//System.err.println("Asked if targetting runtime 1.2 , returning: "+b);
+		// System.err.println("Asked if targetting runtime 1.2 , returning: "+b);
 		return b;
 	}
 
 	/*
-	 * Map of types in the world, can have 'references' to expendable ones which
-	 * can be garbage collected to recover memory. An expendable type is a
-	 * reference type that is not exposed to the weaver (ie just pulled in for
-	 * type resolution purposes).
+	 * Map of types in the world, can have 'references' to expendable ones which can be garbage collected to recover memory. An
+	 * expendable type is a reference type that is not exposed to the weaver (ie just pulled in for type resolution purposes).
 	 */
 	protected static class TypeMap {
 
@@ -903,25 +877,21 @@ public abstract class World implements Dump.INode {
 			if (trace.isTraceEnabled())
 				trace.enter("<init>", this, w);
 			this.w = w;
-			memoryProfiling = false;//!w.getMessageHandler().isIgnoring(Message.
+			memoryProfiling = false;// !w.getMessageHandler().isIgnoring(Message.
 			// INFO);
 			if (trace.isTraceEnabled())
 				trace.exit("<init>");
 		}
 
 		/**
-		 * Add a new type into the map, the key is the type signature. Some
-		 * types do *not* go in the map, these are ones involving *member* type
-		 * variables. The reason is that when all you have is the signature
-		 * which gives you a type variable name, you cannot guarantee you are
-		 * using the type variable in the same way as someone previously working
-		 * with a similarly named type variable. So, these do not go into the
-		 * map: - TypeVariableReferenceType. - ParameterizedType where a member
-		 * type variable is involved. - BoundedReferenceType when one of the
-		 * bounds is a type variable.
+		 * Add a new type into the map, the key is the type signature. Some types do *not* go in the map, these are ones involving
+		 * *member* type variables. The reason is that when all you have is the signature which gives you a type variable name, you
+		 * cannot guarantee you are using the type variable in the same way as someone previously working with a similarly named
+		 * type variable. So, these do not go into the map: - TypeVariableReferenceType. - ParameterizedType where a member type
+		 * variable is involved. - BoundedReferenceType when one of the bounds is a type variable.
 		 * 
-		 * definition: "member type variables" - a tvar declared on a generic
-		 * method/ctor as opposed to those you see declared on a generic type.
+		 * definition: "member type variables" - a tvar declared on a generic method/ctor as opposed to those you see declared on a
+		 * generic type.
 		 */
 		public ResolvedType put(String key, ResolvedType type) {
 			if (type.isParameterizedType() && type.isParameterizedWithTypeVariable()) {
@@ -1000,8 +970,7 @@ public abstract class World implements Dump.INode {
 		}
 
 		/**
-		 * Lookup a type by its signature, always look in the real map before
-		 * the expendable map
+		 * Lookup a type by its signature, always look in the real map before the expendable map
 		 */
 		public ResolvedType get(String key) {
 			checkq();
@@ -1067,16 +1036,14 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * Reference types we don't intend to weave may be ejected from the cache if
-	 * we need the space.
+	 * Reference types we don't intend to weave may be ejected from the cache if we need the space.
 	 */
 	protected boolean isExpendable(ResolvedType type) {
 		return (!type.equals(UnresolvedType.OBJECT) && (!type.isExposedToWeaver()) && (!type.isPrimitiveType()));
 	}
 
 	/**
-	 * This class is used to compute and store precedence relationships between
-	 * aspects.
+	 * This class is used to compute and store precedence relationships between aspects.
 	 */
 	private static class AspectPrecedenceCalculator {
 
@@ -1089,9 +1056,8 @@ public abstract class World implements Dump.INode {
 		}
 
 		/**
-		 * Ask every declare precedence in the world to order the two aspects.
-		 * If more than one declare precedence gives an ordering, and the
-		 * orderings conflict, then that's an error.
+		 * Ask every declare precedence in the world to order the two aspects. If more than one declare precedence gives an
+		 * ordering, and the orderings conflict, then that's an error.
 		 */
 		public int compareByPrecedence(ResolvedType firstAspect, ResolvedType secondAspect) {
 			PrecedenceCacheKey key = new PrecedenceCacheKey(firstAspect, secondAspect);
@@ -1294,8 +1260,7 @@ public abstract class World implements Dump.INode {
 	}
 
 	/**
-	 * Register a new pointcut designator handler with the world - this can be
-	 * used by any pointcut parsers attached to the world.
+	 * Register a new pointcut designator handler with the world - this can be used by any pointcut parsers attached to the world.
 	 * 
 	 * @param designatorHandler handler for the new pointcut
 	 */
@@ -76,1770 +76,1639 @@ import org.aspectj.weaver.patterns.TypePattern;
 
 /**
  * Annotation defined aspect reader. Reads the Java 5 annotations and turns them into AjAttributes
- *
+ * 
  * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
  */
 public class AtAjAttributes {
 
-    private final static List EMPTY_LIST = new ArrayList();
-    private final static String[] EMPTY_STRINGS = new String[0];
-    private final static String VALUE = "value";
-    private final static String ARGNAMES = "argNames";
-    private final static String POINTCUT = "pointcut";
-    private final static String THROWING = "throwing";
-    private final static String RETURNING = "returning";
-    private final static String STRING_DESC = "Ljava/lang/String;";
-
-    /**
-     * A struct that allows to add extra arguments without always breaking the API
-     */
-    private static class AjAttributeStruct {
-
-        /**
-         * The list of AjAttribute.XXX that we are populating from the @AJ read
-         */
-        List ajAttributes = new ArrayList();
-
-        /**
-         * The resolved type (class) for which we are reading @AJ for (be it class, method, field annotations)
-         */
-        final ResolvedType enclosingType;
-
-        final ISourceContext context;
-        final IMessageHandler handler;
-
-        public AjAttributeStruct(ResolvedType type, ISourceContext sourceContext, IMessageHandler messageHandler) {
-            enclosingType = type;
-            context = sourceContext;
-            handler = messageHandler;
-        }
-    }
-
-    /**
-     * A struct when we read @AJ on method
-     *
-     * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
-     */
-    private static class AjAttributeMethodStruct extends AjAttributeStruct {
-
-    	// argument names used for formal binding
-        private String[] m_argumentNamesLazy = null;
-        public String unparsedArgumentNames = null; // Set only if discovered as argNames attribute of annotation
-
-        final Method method;
-        final BcelMethod bMethod;
-
-        public AjAttributeMethodStruct(Method method, BcelMethod bMethod, ResolvedType type, ISourceContext sourceContext, IMessageHandler messageHandler) {
-            super(type, sourceContext, messageHandler);
-            this.method = method;
-            this.bMethod = bMethod;
-        }
-
-        public String[] getArgumentNames() {
-            if (m_argumentNamesLazy == null) {
-                m_argumentNamesLazy = getMethodArgumentNames(method,unparsedArgumentNames,this);
-            }
-            return m_argumentNamesLazy;
-        }
-    }
-
-    /**
-     * A struct when we read @AJ on field
-     */
-    private static class AjAttributeFieldStruct extends AjAttributeStruct {
-
-        final Field field;
-        final BcelField bField;
-
-        public AjAttributeFieldStruct(Field field, BcelField bField, ResolvedType type, ISourceContext sourceContext, IMessageHandler messageHandler) {
-            super(type, sourceContext, messageHandler);
-            this.field = field;
-            this.bField = bField;
-        }
-    }
-
-    /**
-     * Annotations are RuntimeVisible only. This allow us to not visit RuntimeInvisible ones.
-     *
-     * @param attribute
-     * @return true if runtime visible annotation
-     */
-    public static boolean acceptAttribute(Attribute attribute) {
-        return (attribute instanceof RuntimeVisibleAnnotations);
-    }
-
-    /**
-     * Extract class level annotations and turn them into AjAttributes.
-     *
-     * @param javaClass
-     * @param type
-     * @param context
-     * @param msgHandler
-     * @return list of AjAttributes
-     */
-    public static List readAj5ClassAttributes(JavaClass javaClass, ReferenceType type, ISourceContext context, IMessageHandler msgHandler, boolean isCodeStyleAspect) {
-    	boolean ignoreThisClass = javaClass.getClassName().charAt(0)=='o' && javaClass.getClassName().startsWith("org.aspectj.lang.annotation");
-    	if (ignoreThisClass) return EMPTY_LIST;
-    	boolean containsPointcut = false;
+	private final static List EMPTY_LIST = new ArrayList();
+	private final static String[] EMPTY_STRINGS = new String[0];
+	private final static String VALUE = "value";
+	private final static String ARGNAMES = "argNames";
+	private final static String POINTCUT = "pointcut";
+	private final static String THROWING = "throwing";
+	private final static String RETURNING = "returning";
+	private final static String STRING_DESC = "Ljava/lang/String;";
+
+	/**
+	 * A struct that allows to add extra arguments without always breaking the API
+	 */
+	private static class AjAttributeStruct {
+
+		/**
+		 * The list of AjAttribute.XXX that we are populating from the @AJ read
+		 */
+		List ajAttributes = new ArrayList();
+
+		/**
+		 * The resolved type (class) for which we are reading @AJ for (be it class, method, field annotations)
+		 */
+		final ResolvedType enclosingType;
+
+		final ISourceContext context;
+		final IMessageHandler handler;
+
+		public AjAttributeStruct(ResolvedType type, ISourceContext sourceContext, IMessageHandler messageHandler) {
+			enclosingType = type;
+			context = sourceContext;
+			handler = messageHandler;
+		}
+	}
+
+	/**
+	 * A struct when we read @AJ on method
+	 * 
+	 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
+	 */
+	private static class AjAttributeMethodStruct extends AjAttributeStruct {
+
+		// argument names used for formal binding
+		private String[] m_argumentNamesLazy = null;
+		public String unparsedArgumentNames = null; // Set only if discovered as argNames attribute of annotation
+
+		final Method method;
+		final BcelMethod bMethod;
+
+		public AjAttributeMethodStruct(Method method, BcelMethod bMethod, ResolvedType type, ISourceContext sourceContext,
+				IMessageHandler messageHandler) {
+			super(type, sourceContext, messageHandler);
+			this.method = method;
+			this.bMethod = bMethod;
+		}
+
+		public String[] getArgumentNames() {
+			if (m_argumentNamesLazy == null) {
+				m_argumentNamesLazy = getMethodArgumentNames(method, unparsedArgumentNames, this);
+			}
+			return m_argumentNamesLazy;
+		}
+	}
+
+	/**
+	 * A struct when we read @AJ on field
+	 */
+	private static class AjAttributeFieldStruct extends AjAttributeStruct {
+
+		final Field field;
+		final BcelField bField;
+
+		public AjAttributeFieldStruct(Field field, BcelField bField, ResolvedType type, ISourceContext sourceContext,
+				IMessageHandler messageHandler) {
+			super(type, sourceContext, messageHandler);
+			this.field = field;
+			this.bField = bField;
+		}
+	}
+
+	/**
+	 * Annotations are RuntimeVisible only. This allow us to not visit RuntimeInvisible ones.
+	 * 
+	 * @param attribute
+	 * @return true if runtime visible annotation
+	 */
+	public static boolean acceptAttribute(Attribute attribute) {
+		return (attribute instanceof RuntimeVisibleAnnotations);
+	}
+
+	/**
+	 * Extract class level annotations and turn them into AjAttributes.
+	 * 
+	 * @param javaClass
+	 * @param type
+	 * @param context
+	 * @param msgHandler
+	 * @return list of AjAttributes
+	 */
+	public static List readAj5ClassAttributes(AsmManager model, JavaClass javaClass, ReferenceType type, ISourceContext context,
+			IMessageHandler msgHandler, boolean isCodeStyleAspect) {
+		boolean ignoreThisClass = javaClass.getClassName().charAt(0) == 'o'
+				&& javaClass.getClassName().startsWith("org.aspectj.lang.annotation");
+		if (ignoreThisClass)
+			return EMPTY_LIST;
+		boolean containsPointcut = false;
 		boolean containsAnnotationClassReference = false;
-        Constant[] cpool = javaClass.getConstantPool().getConstantPool();
-        for (int i = 0; i < cpool.length; i++) {
-            Constant constant = cpool[i];
-            if (constant != null && constant.getTag() == Constants.CONSTANT_Utf8) {
-                String constantValue = ((ConstantUtf8)constant).getBytes();
-                if (constantValue.length()>28 && constantValue.charAt(1)=='o') {
-                	if (constantValue.startsWith("Lorg/aspectj/lang/annotation")) {
-                		containsAnnotationClassReference=true;
-                		if ("Lorg/aspectj/lang/annotation/DeclareAnnotation;".equals(constantValue)) {
-                            msgHandler.handleMessage(
-                                    new Message(
-                                            "Found @DeclareAnnotation while current release does not support it (see '" + type.getName() + "')",
-                                            IMessage.WARNING,
-                                            null,
-                                            type.getSourceLocation()
-                                    )
-                            );
-                        }
-                        if ("Lorg/aspectj/lang/annotation/Pointcut;".equals(constantValue)) {
-                        	containsPointcut=true;
-                        }
-                	}
-
-                }
-            }
-        }
-        if (!containsAnnotationClassReference) return EMPTY_LIST;
-            
-
-        AjAttributeStruct struct = new AjAttributeStruct(type, context, msgHandler);
-        Attribute[] attributes = javaClass.getAttributes();
-        boolean hasAtAspectAnnotation = false;
-        boolean hasAtPrecedenceAnnotation = false;
-
-        for (int i = 0; i < attributes.length; i++) {
-            Attribute attribute = attributes[i];
-            if (acceptAttribute(attribute)) {
-                RuntimeAnnotations rvs = (RuntimeAnnotations) attribute;
-                // we don't need to look for several attribute occurrences since it cannot happen as per JSR175
-                if (!isCodeStyleAspect && !javaClass.isInterface()) {
-                    hasAtAspectAnnotation = handleAspectAnnotation(rvs, struct);
-                    //TODO AV - if put outside the if isCodeStyleAspect then we would enable mix style
-                    hasAtPrecedenceAnnotation = handlePrecedenceAnnotation(rvs, struct);
-                }
-                // there can only be one RuntimeVisible bytecode attribute
-                break;
-            }
-        }
-
-        // basic semantic check
-        if (hasAtPrecedenceAnnotation && !hasAtAspectAnnotation) {
-            msgHandler.handleMessage(
-                    new Message(
-                            "Found @DeclarePrecedence on a non @Aspect type '" + type.getName() + "'",
-                            IMessage.WARNING,
-                            null,
-                            type.getSourceLocation()
-                    )
-            );
-            // bypass what we have read
-            return EMPTY_LIST;
-        }
-
-        // the following block will not detect @Pointcut in non @Aspect types for optimization purpose
-       if (!(hasAtAspectAnnotation || isCodeStyleAspect) && !containsPointcut) {
-           return EMPTY_LIST;
-        }
-
-        //FIXME AV - turn on when ajcMightHaveAspect
-//        if (hasAtAspectAnnotation && type.isInterface()) {
-//            msgHandler.handleMessage(
-//                    new Message(
-//                            "Found @Aspect on an interface type '" + type.getName() + "'",
-//                            IMessage.WARNING,
-//                            null,
-//                            type.getSourceLocation()
-//                    )
-//            );
-//            // bypass what we have read
-//            return EMPTY_LIST;
-//        }
-
-        // semantic check: @Aspect must be public
-        // FIXME AV - do we really want to enforce that?
-//        if (hasAtAspectAnnotation && !javaClass.isPublic()) {
-//            msgHandler.handleMessage(
-//                    new Message(
-//                            "Found @Aspect annotation on a non public class '" + javaClass.getClassName() + "'",
-//                            IMessage.ERROR,
-//                            null,
-//                            type.getSourceLocation()
-//                    )
-//            );
-//            return EMPTY_LIST;
-//        }
-
-        // code style pointcuts are class attributes
-        // we need to gather the @AJ pointcut right now and not at method level annotation extraction time
-        // in order to be able to resolve the pointcut references later on
-        // we don't need to look in super class, the pointcut reference in the grammar will do it
-        
-        for (int i = 0; i < javaClass.getMethods().length; i++) {
-            Method method = javaClass.getMethods()[i];
-            if (method.getName().startsWith(NameMangler.PREFIX)) continue;  // already dealt with by ajc...
-            //FIXME alex optimize, this method struct will gets recreated for advice extraction
-            AjAttributeMethodStruct mstruct = null;
-            boolean processedPointcut = false;
-            Attribute[] mattributes = method.getAttributes();
-            for (int j = 0; j < mattributes.length; j++) {
-                Attribute mattribute = mattributes[j];
-                if (acceptAttribute(mattribute)) {
-                	mstruct = new AjAttributeMethodStruct(method, null, type, context, msgHandler);//FIXME AVASM
-                    processedPointcut = handlePointcutAnnotation((RuntimeAnnotations) mattribute, mstruct);
-                    // there can only be one RuntimeVisible bytecode attribute
-                    break;
-                }
-            }
-            if (processedPointcut) {
-	            // FIXME asc should check we aren't adding multiple versions... will do once I get the tests passing again...
-	            struct.ajAttributes.add(new AjAttribute.WeaverVersionInfo());
-	            struct.ajAttributes.addAll(mstruct.ajAttributes);
-            }
-        }
-
-
-        // code style declare error / warning / implements / parents are field attributes
-        Field[] fs = javaClass.getFields();
-        for (int i = 0; i < fs.length; i++) {
-            Field field = fs[i];
-            if (field.getName().startsWith(NameMangler.PREFIX)) continue;  // already dealt with by ajc...
-            //FIXME alex optimize, this method struct will gets recreated for advice extraction
-            AjAttributeFieldStruct fstruct = new AjAttributeFieldStruct(field, null, type, context, msgHandler);
-            Attribute[] fattributes = field.getAttributes();
-
-            for (int j = 0; j < fattributes.length; j++) {
-                Attribute fattribute = fattributes[j];
-                if (acceptAttribute(fattribute)) {
-                    RuntimeAnnotations frvs = (RuntimeAnnotations) fattribute;
-                    if (handleDeclareErrorOrWarningAnnotation(frvs, fstruct)
-                            || handleDeclareParentsAnnotation(frvs, fstruct)) {
-                        // semantic check - must be in an @Aspect [remove if previous block bypassed in advance]
-                       if (!type.isAnnotationStyleAspect() && !isCodeStyleAspect) {
-                            msgHandler.handleMessage(
-                                    new Message(
-                                            "Found @AspectJ annotations in a non @Aspect type '" + type.getName() + "'",
-                                            IMessage.WARNING,
-                                            null,
-                                            type.getSourceLocation()
-                                    )
-                            );
-                            // go ahead
-                        }
-                    }
-                    // there can only be one RuntimeVisible bytecode attribute
-                    break;
-                }
-            }
-            struct.ajAttributes.addAll(fstruct.ajAttributes);
-        }
-
-        return struct.ajAttributes;
-    }
-
-    /**
-     * Extract method level annotations and turn them into AjAttributes.
-     *
-     * @param method
-     * @param type
-     * @param context
-     * @param msgHandler
-     * @return list of AjAttributes
-     */
-    public static List readAj5MethodAttributes(Method method, BcelMethod bMethod, ResolvedType type, ResolvedPointcutDefinition preResolvedPointcut, ISourceContext context, IMessageHandler msgHandler) {
-        if (method.getName().startsWith(NameMangler.PREFIX)) return Collections.EMPTY_LIST;  // already dealt with by ajc...
-
-        AjAttributeMethodStruct struct = new AjAttributeMethodStruct(method, bMethod, type, context, msgHandler);
-        Attribute[] attributes = method.getAttributes();
-
-        // we remember if we found one @AJ annotation for minimal semantic error reporting
-        // the real reporting beeing done thru AJDT and the compiler mapping @AJ to AjAtttribute
-        // or thru APT
-        //
-        // Note: we could actually skip the whole thing if type is not itself an @Aspect
-        // but then we would not see any warning. We do bypass for pointcut but not for advice since it would
-        // be too silent.
-        boolean hasAtAspectJAnnotation = false;
-        boolean hasAtAspectJAnnotationMustReturnVoid = false;
-        for (int i = 0; i < attributes.length; i++) {
-            Attribute attribute = attributes[i];
-            try {
-                if (acceptAttribute(attribute)) {
-                    RuntimeAnnotations rvs = (RuntimeAnnotations) attribute;
-                    hasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid || handleBeforeAnnotation(
-                            rvs, struct, preResolvedPointcut
-                    );
-                    hasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid || handleAfterAnnotation(
-                            rvs, struct, preResolvedPointcut
-                    );
-                    hasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid || handleAfterReturningAnnotation(
-                            rvs, struct, preResolvedPointcut, bMethod
-                    );
-                    hasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid || handleAfterThrowingAnnotation(
-                            rvs, struct, preResolvedPointcut, bMethod
-                    );
-                    hasAtAspectJAnnotation = hasAtAspectJAnnotation || handleAroundAnnotation(
-                            rvs, struct, preResolvedPointcut
-                    );
-                    // there can only be one RuntimeVisible bytecode attribute
-                    break;
-                }
-            } catch (ReturningFormalNotDeclaredInAdviceSignatureException e) {
-                msgHandler.handleMessage(
-                    new Message(
-                            WeaverMessages.format(WeaverMessages.RETURNING_FORMAL_NOT_DECLARED_IN_ADVICE,e.getFormalName()),
-                            IMessage.ERROR,
-                            null,
-                            bMethod.getSourceLocation())
-                );
-            } catch (ThrownFormalNotDeclaredInAdviceSignatureException e) {
-                msgHandler.handleMessage(
-                        new Message(
-                                WeaverMessages.format(WeaverMessages.THROWN_FORMAL_NOT_DECLARED_IN_ADVICE,e.getFormalName()),
-                                IMessage.ERROR,
-                                null,
-                                bMethod.getSourceLocation())
-                    );			}
-        }
-        hasAtAspectJAnnotation = hasAtAspectJAnnotation || hasAtAspectJAnnotationMustReturnVoid;
-
-        // semantic check - must be in an @Aspect [remove if previous block bypassed in advance]
-        if (hasAtAspectJAnnotation && !type.isAnnotationStyleAspect()) {
-            msgHandler.handleMessage(
-                    new Message(
-                            "Found @AspectJ annotations in a non @Aspect type '" + type.getName() + "'",
-                            IMessage.WARNING,
-                            null,
-                            type.getSourceLocation()
-                    )
-            );
-            // go ahead
-        }
-        // semantic check - advice must be public
-        if (hasAtAspectJAnnotation && !struct.method.isPublic()) {
-            msgHandler.handleMessage(
-                    new Message(
-                            "Found @AspectJ annotation on a non public advice '" + methodToString(struct.method) + "'",
-                            IMessage.ERROR,
-                            null,
-                            type.getSourceLocation()
-                    )
-            );
-            // go ahead
-        }
-        
-        // semantic check - advice must not be static
-        if (hasAtAspectJAnnotation && struct.method.isStatic()) {
-            msgHandler.handleMessage(MessageUtil.error("Advice cannot be declared static '" + methodToString(struct.method) + "'",type.getSourceLocation()));
-//                    new Message(
-//                            "Advice cannot be declared static '" + methodToString(struct.method) + "'",
-//                            IMessage.ERROR,
-//                            null,
-//                            type.getSourceLocation()
-//                    )
-//            );
-            // go ahead
-        }
-        
-        // semantic check for non around advice must return void
-        if (hasAtAspectJAnnotationMustReturnVoid && !Type.VOID.equals(struct.method.getReturnType())) {
-            msgHandler.handleMessage(
-                    new Message(
-                            "Found @AspectJ annotation on a non around advice not returning void '" + methodToString(
-                                    struct.method
-                            ) + "'",
-                            IMessage.ERROR,
-                            null,
-                            type.getSourceLocation()
-                    )
-            );
-            // go ahead
-        }
-
-        return struct.ajAttributes;
-    }
-
-    /**
-     * Extract field level annotations and turn them into AjAttributes.
-     *
-     * @param field
-     * @param type
-     * @param context
-     * @param msgHandler
-     * @return list of AjAttributes, always empty for now
-     */
-    public static List readAj5FieldAttributes(Field field, BcelField bField, ResolvedType type, ISourceContext context, IMessageHandler msgHandler) {
-        // Note: field annotation are for ITD and DEOW - processed at class level directly
-        return Collections.EMPTY_LIST;
-    }
-
-
-    /**
-     * Read @Aspect
-     *
-     * @param runtimeAnnotations
-     * @param struct
-     * @return true if found
-     */
-    private static boolean handleAspectAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeStruct struct) {
-        AnnotationGen aspect = getAnnotation(runtimeAnnotations, AjcMemberMaker.ASPECT_ANNOTATION);
-        if (aspect != null) {
-            // semantic check for inheritance (only one level up)
-            boolean extendsAspect = false;
-            if (!"java.lang.Object".equals(struct.enclosingType.getSuperclass().getName())) {
-                if (!struct.enclosingType.getSuperclass().isAbstract() && struct.enclosingType.getSuperclass().isAspect()) {
-                    reportError("cannot extend a concrete aspect", struct);
-                    return false;
-                }
-                extendsAspect = struct.enclosingType.getSuperclass().isAspect();
-            }
-
-            ElementNameValuePairGen aspectPerClause = getAnnotationElement(aspect, VALUE);
-            final PerClause perClause;
-            if (aspectPerClause == null) {
-                // empty value means singleton unless inherited
-                if (!extendsAspect) {
-                    perClause = new PerSingleton();
-                } else {
-                    perClause = new PerFromSuper(struct.enclosingType.getSuperclass().getPerClause().getKind());
-                }
-            } else {
-                String perX = aspectPerClause.getValue().stringifyValue();
-                if (perX == null || perX.length() <= 0) {
-                    perClause = new PerSingleton();
-                } else {
-                    perClause = parsePerClausePointcut(perX, struct);
-                }
-            }
-            if (perClause == null) {
-                // could not parse it, ignore the aspect
-                return false;
-            } else {
-                perClause.setLocation(struct.context, -1,-1);//struct.context.getOffset(), struct.context.getOffset()+1);//FIXME AVASM
-                // FIXME asc see related comment way about about the version...
-                struct.ajAttributes.add(new AjAttribute.WeaverVersionInfo());
-                AjAttribute.Aspect aspectAttribute = new AjAttribute.Aspect(perClause);
-                struct.ajAttributes.add(aspectAttribute);
-                FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
-                final IScope binding;
-                binding = new BindingScope(
-                            struct.enclosingType,
-                            struct.context,
-                            bindings
-                        );
-
-//                // we can't resolve here since the perclause typically refers to pointcuts
-//                // defined in the aspect that we haven't told the BcelObjectType about yet.
-//
-//                perClause.resolve(binding);
-
-                // so we prepare to do it later...
-                aspectAttribute.setResolutionScope(binding);
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Read a perClause, returns null on failure and issue messages
-     *
-     * @param perClauseString like "pertarget(.....)"
-     * @param struct    for which we are parsing the per clause
-     * @return a PerClause instance
-     */
-    private static PerClause parsePerClausePointcut(String perClauseString, AjAttributeStruct struct) {
-        final String pointcutString;
-        Pointcut pointcut = null;
-        TypePattern typePattern = null;
-        final PerClause perClause;
-        if (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERCFLOW.getName())) {
-            pointcutString = PerClause.KindAnnotationPrefix.PERCFLOW.extractPointcut(perClauseString);
-            pointcut = parsePointcut(pointcutString, struct, false);
-            perClause = new PerCflow(pointcut, false);
-        } else if (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERCFLOWBELOW.getName())) {
-            pointcutString = PerClause.KindAnnotationPrefix.PERCFLOWBELOW.extractPointcut(perClauseString);
-            pointcut = parsePointcut(pointcutString, struct, false);
-            perClause = new PerCflow(pointcut, true);
-        } else if (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERTARGET.getName())) {
-            pointcutString = PerClause.KindAnnotationPrefix.PERTARGET.extractPointcut(perClauseString);
-            pointcut = parsePointcut(pointcutString, struct, false);
-            perClause = new PerObject(pointcut, false);
-        } else if (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERTHIS.getName())) {
-            pointcutString = PerClause.KindAnnotationPrefix.PERTHIS.extractPointcut(perClauseString);
-            pointcut = parsePointcut(pointcutString, struct, false);
-            perClause = new PerObject(pointcut, true);
-        } else if (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERTYPEWITHIN.getName())) {
-            pointcutString = PerClause.KindAnnotationPrefix.PERTYPEWITHIN.extractPointcut(perClauseString);
-            typePattern = parseTypePattern(pointcutString, struct);
-            perClause = new PerTypeWithin(typePattern);
-        } else if (perClauseString.equalsIgnoreCase(PerClause.SINGLETON.getName() + "()")) {
-            perClause = new PerSingleton();
-        } else {
-            // could not parse the @AJ perclause - fallback to singleton and issue an error
-            reportError("@Aspect per clause cannot be read '" + perClauseString + "'", struct);
-            return null;
-        }
-
-        if (!PerClause.SINGLETON.equals(perClause.getKind())
-                && !PerClause.PERTYPEWITHIN.equals(perClause.getKind())
-                && pointcut == null) {
-            // we could not parse the pointcut
-            return null;
-        }
-        if (PerClause.PERTYPEWITHIN.equals(perClause.getKind()) && typePattern == null) {
-            // we could not parse the type pattern
-            return null;
-        }
-        return perClause;
-    }
-
-    /**
-     * Read @DeclarePrecedence
-     *
-     * @param runtimeAnnotations
-     * @param struct
-     * @return true if found
-     */
-    private static boolean handlePrecedenceAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeStruct struct) {
-        AnnotationGen aspect = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREPRECEDENCE_ANNOTATION);
-        if (aspect != null) {
-            ElementNameValuePairGen precedence = getAnnotationElement(aspect, VALUE);
-            if (precedence != null) {
-                String precedencePattern = precedence.getValue().stringifyValue();
-                PatternParser parser = new PatternParser(precedencePattern);
-                DeclarePrecedence ajPrecedence = parser.parseDominates();
-                struct.ajAttributes.add(new AjAttribute.DeclareAttribute(ajPrecedence));
-                return true;
-            }
-        }
-        return false;
-    }
-
-//    /**
-//     * Read @DeclareImplements
-//     *
-//     * @param runtimeAnnotations
-//     * @param struct
-//     * @return true if found
-//     */
-//    private static boolean handleDeclareImplementsAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeFieldStruct struct) {//, ResolvedPointcutDefinition preResolvedPointcut) {
-//        Annotation deci = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREIMPLEMENTS_ANNOTATION);
-//        if (deci != null) {
-//            ElementNameValuePairGen deciPatternNVP = getAnnotationElement(deci, VALUE);
-//            String deciPattern = deciPatternNVP.getValue().stringifyValue();
-//            if (deciPattern != null) {
-//                TypePattern typePattern = parseTypePattern(deciPattern, struct);
-//                ResolvedType fieldType = UnresolvedType.forSignature(struct.field.getSignature()).resolve(struct.enclosingType.getWorld());
-//                if (fieldType.isPrimitiveType()) {
-//                    return false;
-//                } else if (fieldType.isInterface()) {
-//                    TypePattern parent = new ExactTypePattern(UnresolvedType.forSignature(struct.field.getSignature()), false, false);
-//                    parent.resolve(struct.enclosingType.getWorld());
-//                    List parents = new ArrayList(1);
-//                    parents.add(parent);
-//                    //TODO kick ISourceLocation sl = struct.bField.getSourceLocation();    ??
-//                    struct.ajAttributes.add(
-//                            new AjAttribute.DeclareAttribute(
-//                                    new DeclareParents(
-//                                        typePattern,
-//                                        parents,
-//                                        false
-//                                    )
-//                            )
-//                    );
-//                    return true;
-//                } else {
-//                    reportError("@DeclareImplements: can only be used on field whose type is an interface", struct);
-//                    return false;
-//                }
-//            }
-//        }
-//        return false;
-//    }
-
-    /**
-     * Read @DeclareParents
-     *
-     * @param runtimeAnnotations
-     * @param struct
-     * @return true if found
-     */
-    private static boolean handleDeclareParentsAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeFieldStruct struct) {//, ResolvedPointcutDefinition preResolvedPointcut) {
-        AnnotationGen decp = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREPARENTS_ANNOTATION);
-        if (decp != null) {
-            ElementNameValuePairGen decpPatternNVP = getAnnotationElement(decp, VALUE);
-            String decpPattern = decpPatternNVP.getValue().stringifyValue();
-            if (decpPattern != null) {
-                TypePattern typePattern = parseTypePattern(decpPattern, struct);
-                ResolvedType fieldType = UnresolvedType.forSignature(struct.field.getSignature()).resolve(struct.enclosingType.getWorld());
-                if (fieldType.isInterface()) {
-                    TypePattern parent = parseTypePattern(fieldType.getName(),struct);
-                    FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
-	                IScope binding = new BindingScope(struct.enclosingType,struct.context,bindings);
-                    // first add the declare implements like
-                    List parents = new ArrayList(1); parents.add(parent);
-                    DeclareParents dp = new DeclareParents(typePattern,parents,false);
-                    dp.resolve(binding); // resolves the parent and child parts of the decp
-                    
-                    // resolve this so that we can use it for the MethodDelegateMungers below.
-                    // eg. '@Coloured *' will change from a WildTypePattern to an 'AnyWithAnnotationTypePattern' after this resolution
-                    typePattern = typePattern.resolveBindings(binding, Bindings.NONE, false, false);
-                    //TODO kick ISourceLocation sl = struct.bField.getSourceLocation();    ??
-                    // dp.setLocation(dp.getDeclaringType().getSourceContext(), dp.getDeclaringType().getSourceLocation().getOffset(), dp.getDeclaringType().getSourceLocation().getOffset());
-                    dp.setLocation(struct.context,-1,-1); // not ideal...
-                    struct.ajAttributes.add(new AjAttribute.DeclareAttribute(dp));
-
-
-                    // do we have a defaultImpl=xxx.class (ie implementation)
-                    String defaultImplClassName = null;
-                    ElementNameValuePairGen defaultImplNVP = getAnnotationElement(decp, "defaultImpl");
-                    if (defaultImplNVP != null) {
-                        ClassElementValueGen defaultImpl = (ClassElementValueGen) defaultImplNVP.getValue();
-                        defaultImplClassName = UnresolvedType.forSignature(defaultImpl.getClassString()).getName();
-                        if (defaultImplClassName.equals("org.aspectj.lang.annotation.DeclareParents")) {
-                            defaultImplClassName = null;
-                        } else {
-                            // check public no arg ctor
-                            ResolvedType impl = struct.enclosingType.getWorld().resolve(
-                                    defaultImplClassName,
-                                    false
-                            );
-                            ResolvedMember[] mm  = impl.getDeclaredMethods();
-                            boolean hasNoCtorOrANoArgOne = true;
-                            for (int i = 0; i < mm.length; i++) {
-                                ResolvedMember resolvedMember = mm[i];
-                                if (resolvedMember.getName().equals("<init>")) {
-                                    hasNoCtorOrANoArgOne = false;
-                                    if (resolvedMember.getParameterTypes().length == 0
-                                        && resolvedMember.isPublic()) {
-                                        hasNoCtorOrANoArgOne = true;
-                                    }
-                                }
-                                if (hasNoCtorOrANoArgOne) {
-                                    break;
-                                }
-                            }
-                            if (!hasNoCtorOrANoArgOne) {
-                                reportError("@DeclareParents: defaultImpl=\""
-                                            + defaultImplClassName
-                                            + "\" has no public no-arg constructor", struct);
-                            }
-                            if (!fieldType.isAssignableFrom(impl)) {
-                            	reportError("@DeclareParents: defaultImpl=\""+defaultImplClassName+"\" does not implement the interface '"+fieldType.toString()+"'",struct);
-                            }
-                        }
-
-                    }
-
-                    // then iterate on field interface hierarchy (not object)
-                    boolean hasAtLeastOneMethod = false;
-                    ResolvedMember[] methods = (ResolvedMember[])fieldType.getMethodsWithoutIterator(true, false).toArray(new ResolvedMember[0]);
-                    for (int i = 0; i < methods.length; i++) {
-                        ResolvedMember method = methods[i];
-                        if (method.isAbstract()) {
-                        // moved to be detected at weave time if the target doesnt implement the methods
-//                            if (defaultImplClassName == null) {
-//                                // non marker interface with no default impl provided
-//                                reportError("@DeclareParents: used with a non marker interface and no defaultImpl=\"...\" provided", struct);
-//                                return false;
-//                            }
-                            hasAtLeastOneMethod = true;
-                            MethodDelegateTypeMunger mdtm = 
-                                new MethodDelegateTypeMunger(
-                                    method,
-                                    struct.enclosingType,
-                                    defaultImplClassName,
-                                    typePattern
-                                );
-                            mdtm.setSourceLocation(struct.enclosingType.getSourceLocation());
-                            struct.ajAttributes.add(new AjAttribute.TypeMunger(mdtm));
-                        }
-                    }
-                    // successfull so far, we thus need a bcel type munger to have
-                    // a field hosting the mixin in the target type
-                    if (hasAtLeastOneMethod && defaultImplClassName!=null) {
-                        struct.ajAttributes.add(
-                                new AjAttribute.TypeMunger(
-                                        new MethodDelegateTypeMunger.FieldHostTypeMunger(
-                                                AjcMemberMaker.itdAtDeclareParentsField(
-                                                        null,//prototyped
-                                                        fieldType,
-                                                        struct.enclosingType
-                                                ),
-                                                struct.enclosingType,
-                                                typePattern
-                                        )
-                                )
-                        );
-                    }
-
-                    return true;
-                } else {
-                    reportError("@DeclareParents: can only be used on a field whose type is an interface", struct);
-                    return false;
-                }
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Read @Before
-     *
-     * @param runtimeAnnotations
-     * @param struct
-     * @return true if found
-     */
-    private static boolean handleBeforeAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct, ResolvedPointcutDefinition preResolvedPointcut) {
-        AnnotationGen before = getAnnotation(runtimeAnnotations, AjcMemberMaker.BEFORE_ANNOTATION);
-        if (before != null) {
-            ElementNameValuePairGen beforeAdvice = getAnnotationElement(before, VALUE);
-            if (beforeAdvice != null) {
-                // this/target/args binding
-            	String argumentNames = getArgNamesValue(before);
-                if (argumentNames!=null) {
-                	struct.unparsedArgumentNames = argumentNames;
-                }
-                FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
-                try {
-                    bindings = extractBindings(struct);
-                } catch (UnreadableDebugInfoException unreadableDebugInfoException) {
-                    return false;
-                }
-                IScope binding = new BindingScope(
-                        struct.enclosingType,
-                        struct.context,
-                        bindings
-                );
-
-                // joinpoint, staticJoinpoint binding
-                int extraArgument = extractExtraArgument(struct.method);
-
-                Pointcut pc = null;
-                if (preResolvedPointcut != null) {
-                    pc = preResolvedPointcut.getPointcut();
-                    //pc.resolve(binding);
-                } else {
-                    pc = parsePointcut(beforeAdvice.getValue().stringifyValue(), struct, false);
-                    if (pc == null) return false;//parse error
-                    pc = pc.resolve(binding);
-                }
-                setIgnoreUnboundBindingNames(pc, bindings);
-
-                ISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(), struct.bMethod.getDeclarationOffset());
-                struct.ajAttributes.add(
-                        new AjAttribute.AdviceAttribute(
-                                AdviceKind.Before,
-                                pc,
-                                extraArgument,
-                                sl.getOffset(),
-                                sl.getOffset()+1,//FIXME AVASM
-                                struct.context
-                        )
-                );
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Read @After
-     *
-     * @param runtimeAnnotations
-     * @param struct
-     * @return true if found
-     */
-    private static boolean handleAfterAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct, ResolvedPointcutDefinition preResolvedPointcut) {
-        AnnotationGen after = getAnnotation(runtimeAnnotations, AjcMemberMaker.AFTER_ANNOTATION);
-        if (after != null) {
-            ElementNameValuePairGen afterAdvice = getAnnotationElement(after, VALUE);
-            if (afterAdvice != null) {
-                // this/target/args binding
-                FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
-                String argumentNames = getArgNamesValue(after);
-                if (argumentNames!=null) {
-                	struct.unparsedArgumentNames = argumentNames;
-                }
-                try {
-                    bindings = extractBindings(struct);
-                } catch (UnreadableDebugInfoException unreadableDebugInfoException) {
-                    return false;
-                }
-                IScope binding = new BindingScope(
-                        struct.enclosingType,
-                        struct.context,
-                        bindings
-                );
-
-                // joinpoint, staticJoinpoint binding
-                int extraArgument = extractExtraArgument(struct.method);
-
-                Pointcut pc = null;
-                if (preResolvedPointcut != null) {
-                    pc = preResolvedPointcut.getPointcut();
-                } else {
-                    pc = parsePointcut(afterAdvice.getValue().stringifyValue(), struct, false);
-                    if (pc == null) return false;//parse error
-                    pc.resolve(binding);
-                }
-                setIgnoreUnboundBindingNames(pc, bindings);
-
-                ISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(), struct.bMethod.getDeclarationOffset());
-                struct.ajAttributes.add(
-                        new AjAttribute.AdviceAttribute(
-                                AdviceKind.After,
-                                pc,
-                                extraArgument,
-                                sl.getOffset(),
-                                sl.getOffset()+1,//FIXME AVASM
-                                struct.context
-                        )
-                );
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Read @AfterReturning
-     *
-     * @param runtimeAnnotations
-     * @param struct
-     * @return true if found
-     */
-    private static boolean handleAfterReturningAnnotation(
-            RuntimeAnnotations runtimeAnnotations,
-            AjAttributeMethodStruct struct,
-            ResolvedPointcutDefinition preResolvedPointcut,
-            BcelMethod owningMethod)
-    throws ReturningFormalNotDeclaredInAdviceSignatureException
-    {
-        AnnotationGen after = getAnnotation(runtimeAnnotations, AjcMemberMaker.AFTERRETURNING_ANNOTATION);
-        if (after != null) {
-            ElementNameValuePairGen annValue = getAnnotationElement(after, VALUE);
-            ElementNameValuePairGen annPointcut = getAnnotationElement(after, POINTCUT);
-            ElementNameValuePairGen annReturned = getAnnotationElement(after, RETURNING);
-
-            // extract the pointcut and returned type/binding - do some checks
-            String pointcut = null;
-            String returned = null;
-            if ((annValue != null && annPointcut != null) || (annValue == null && annPointcut == null)) {
-                reportError("@AfterReturning: either 'value' or 'poincut' must be provided, not both", struct);
-                return false;
-            }
-            if (annValue != null) {
-                pointcut = annValue.getValue().stringifyValue();
-            } else {
-                pointcut = annPointcut.getValue().stringifyValue();
-            }
-            if (isNullOrEmpty(pointcut)) {
-                reportError("@AfterReturning: either 'value' or 'poincut' must be provided, not both", struct);
-                return false;
-            }
-            if (annReturned != null) {
-                returned = annReturned.getValue().stringifyValue();
-                if (isNullOrEmpty(returned)) {
-                    returned = null;
-                } else {
-                       // check that thrownFormal exists as the last parameter in the advice
-                    String[] pNames = owningMethod.getParameterNames();
-                    if (pNames == null || pNames.length == 0 || !Arrays.asList(pNames).contains(returned)) {
-                        throw new ReturningFormalNotDeclaredInAdviceSignatureException(returned);
-                    }
-                }
-            }
-            String argumentNames = getArgNamesValue(after);
-            if (argumentNames!=null) {
-            	struct.unparsedArgumentNames = argumentNames;
-            }
-            // this/target/args binding
-            // exclude the return binding from the pointcut binding since it is an extraArg binding
-            FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
-            try {
-                bindings = (returned == null ? extractBindings(struct) : extractBindings(struct, returned));
-            } catch (UnreadableDebugInfoException unreadableDebugInfoException) {
-                return false;
-            }
-            IScope binding = new BindingScope(
-                    struct.enclosingType,
-                    struct.context,
-                    bindings
-            );
-
-            // joinpoint, staticJoinpoint binding
-            int extraArgument = extractExtraArgument(struct.method);
-
-            // return binding
-            if (returned != null) {
-                extraArgument |= Advice.ExtraArgument;
-            }
-
-            Pointcut pc = null;
-            if (preResolvedPointcut != null) {
-                pc = preResolvedPointcut.getPointcut();
-            } else {
-                pc = parsePointcut(pointcut, struct, false);
-                if (pc == null) return false;//parse error
-                pc.resolve(binding);
-            }
-            setIgnoreUnboundBindingNames(pc, bindings);
-
-            ISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(), struct.bMethod.getDeclarationOffset());
-            struct.ajAttributes.add(
-                    new AjAttribute.AdviceAttribute(
-                            AdviceKind.AfterReturning,
-                            pc,
-                            extraArgument,
-                            sl.getOffset(),
-                            sl.getOffset()+1,//FIXME AVASM
-                            struct.context
-                    )
-            );
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Read @AfterThrowing
-     *
-     * @param runtimeAnnotations
-     * @param struct
-     * @return true if found
-     */
-    private static boolean handleAfterThrowingAnnotation(
-            RuntimeAnnotations runtimeAnnotations,
-            AjAttributeMethodStruct struct,
-            ResolvedPointcutDefinition preResolvedPointcut,
-            BcelMethod owningMethod)
-    throws ThrownFormalNotDeclaredInAdviceSignatureException
-    {
-        AnnotationGen after = getAnnotation(runtimeAnnotations, AjcMemberMaker.AFTERTHROWING_ANNOTATION);
-        if (after != null) {
-            ElementNameValuePairGen annValue = getAnnotationElement(after, VALUE);
-            ElementNameValuePairGen annPointcut = getAnnotationElement(after, POINTCUT);
-            ElementNameValuePairGen annThrown = getAnnotationElement(after, THROWING);
-
-            // extract the pointcut and throwned type/binding - do some checks
-            String pointcut = null;
-            String thrownFormal = null;
-            if ((annValue != null && annPointcut != null) || (annValue == null && annPointcut == null)) {
-                reportError("@AfterThrowing: either 'value' or 'poincut' must be provided, not both", struct);
-                return false;
-            }
-            if (annValue != null) {
-                pointcut = annValue.getValue().stringifyValue();
-            } else {
-                pointcut = annPointcut.getValue().stringifyValue();
-            }
-            if (isNullOrEmpty(pointcut)) {
-                reportError("@AfterThrowing: either 'value' or 'poincut' must be provided, not both", struct);
-                return false;
-            }
-            if (annThrown != null) {
-                thrownFormal = annThrown.getValue().stringifyValue();
-                if (isNullOrEmpty(thrownFormal)) {
-                    thrownFormal = null;
-                } else {
-                    // check that thrownFormal exists as the last parameter in the advice
-                    String[] pNames = owningMethod.getParameterNames();
-                    if (pNames == null || pNames.length == 0 || !Arrays.asList(pNames).contains(thrownFormal)) {
-                        throw new ThrownFormalNotDeclaredInAdviceSignatureException(thrownFormal);
-                    }
-                }
-            }
-            String argumentNames = getArgNamesValue(after);
-            if (argumentNames!=null) {
-            	struct.unparsedArgumentNames = argumentNames;
-            }
-            // this/target/args binding
-            // exclude the throwned binding from the pointcut binding since it is an extraArg binding
-            FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
-            try {
-                bindings = (thrownFormal == null ? extractBindings(struct) : extractBindings(struct, thrownFormal));
-            } catch (UnreadableDebugInfoException unreadableDebugInfoException) {
-                return false;
-            }
-            IScope binding = new BindingScope(
-                    struct.enclosingType,
-                    struct.context,
-                    bindings
-            );
-
-            // joinpoint, staticJoinpoint binding
-            int extraArgument = extractExtraArgument(struct.method);
-
-            // return binding
-            if (thrownFormal != null) {
-                extraArgument |= Advice.ExtraArgument;
-            }
-
-            Pointcut pc = null;
-            if (preResolvedPointcut != null) {
-                pc = preResolvedPointcut.getPointcut();
-            } else {
-                pc = parsePointcut(pointcut, struct, false);
-                if (pc == null) return false;//parse error
-                pc.resolve(binding);
-            }
-            setIgnoreUnboundBindingNames(pc, bindings);
-
-            ISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(), struct.bMethod.getDeclarationOffset());
-            struct.ajAttributes.add(
-                    new AjAttribute.AdviceAttribute(
-                            AdviceKind.AfterThrowing,
-                            pc,
-                            extraArgument,
-                            sl.getOffset(),
-                            sl.getOffset()+1,//FIXME AVASM
-                            struct.context
-                    )
-            );
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Read @Around
-     *
-     * @param runtimeAnnotations
-     * @param struct
-     * @return true if found
-     */
-    private static boolean handleAroundAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct, ResolvedPointcutDefinition preResolvedPointcut) {
-        AnnotationGen around = getAnnotation(runtimeAnnotations, AjcMemberMaker.AROUND_ANNOTATION);
-        if (around != null) {
-            ElementNameValuePairGen aroundAdvice = getAnnotationElement(around, VALUE);
-            if (aroundAdvice != null) {
-                // this/target/args binding 
-            	String argumentNames = getArgNamesValue(around);
-                if (argumentNames!=null) {
-                	struct.unparsedArgumentNames = argumentNames;
-                }
-                FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
-                try {
-                    bindings = extractBindings(struct);
-                } catch (UnreadableDebugInfoException unreadableDebugInfoException) {
-                    return false;
-                }
-                IScope binding = new BindingScope(
-                        struct.enclosingType,
-                        struct.context,
-                        bindings
-                );
-
-                // joinpoint, staticJoinpoint binding
-                int extraArgument = extractExtraArgument(struct.method);
-
-                Pointcut pc = null;
-                if (preResolvedPointcut != null) {
-                    pc = preResolvedPointcut.getPointcut();
-                } else {
-                    pc = parsePointcut(aroundAdvice.getValue().stringifyValue(), struct, false);
-                    if (pc == null) return false;//parse error
-                    pc.resolve(binding);
-                }
-                setIgnoreUnboundBindingNames(pc, bindings);
-
-                ISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(), struct.bMethod.getDeclarationOffset());
-                struct.ajAttributes.add(
-                        new AjAttribute.AdviceAttribute(
-                                AdviceKind.Around,
-                                pc,
-                                extraArgument,
-                                sl.getOffset(),
-                                sl.getOffset()+1,//FIXME AVASM
-                                struct.context
-                        )
-                );
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Read @Pointcut and handle the resolving in a lazy way to deal with pointcut references
-     *
-     * @param runtimeAnnotations
-     * @param struct
-     * @return true if a pointcut was handled
-     */
-    private static boolean handlePointcutAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct) {
-        AnnotationGen pointcut = getAnnotation(runtimeAnnotations, AjcMemberMaker.POINTCUT_ANNOTATION);
-        if (pointcut==null) return false;
-        ElementNameValuePairGen pointcutExpr = getAnnotationElement(pointcut, VALUE);
-
-        
-        // semantic check: the method must return void, or be "public static boolean" for if() support
-        if (!(Type.VOID.equals(struct.method.getReturnType())
-              || (Type.BOOLEAN.equals(struct.method.getReturnType()) && struct.method.isStatic() && struct.method.isPublic()))) {
-            reportWarning("Found @Pointcut on a method not returning 'void' or not 'public static boolean'", struct);
-            //no need to stop
-        }
-
-        // semantic check: the method must not throw anything
-        if (struct.method.getExceptionTable() != null) {
-            reportWarning("Found @Pointcut on a method throwing exception", struct);
-            // no need to stop
-        }
-
-        String argumentNames = getArgNamesValue(pointcut);
-        if (argumentNames!=null) {
-        	struct.unparsedArgumentNames = argumentNames;
-        }
-        // this/target/args binding
-        final IScope binding;
-        try {
-        	if (struct.method.isAbstract()) {
-        	    binding = null;
-        	} else {
-                binding = new BindingScope(
-                    struct.enclosingType,
-                    struct.context,
-                    extractBindings(struct)
-                );
-        	}
-        } catch (UnreadableDebugInfoException e) {
-            return false;
-        }
-
-        UnresolvedType[] argumentTypes = new UnresolvedType[struct.method.getArgumentTypes().length];
-        for (int i = 0; i < argumentTypes.length; i++) {
-            argumentTypes[i] = UnresolvedType.forSignature(struct.method.getArgumentTypes()[i].getSignature());
-        }
-
-        Pointcut pc = null;
-        if (struct.method.isAbstract()) {
-            if ((pointcutExpr != null && isNullOrEmpty(pointcutExpr.getValue().stringifyValue()))
-                || pointcutExpr == null) {
-                // abstract pointcut
-                // leave pc = null
-            } else {
-                reportError("Found defined @Pointcut on an abstract method", struct);
-                return false;//stop
-            }
-        } else {
-        	if (pointcutExpr==null || isNullOrEmpty(pointcutExpr.getValue().stringifyValue())) {
-        		// the matches nothing pointcut (125475/125480) - perhaps not as cleanly supported as it could be.
-        	} else {
-//              if (pointcutExpr != null) {
-                // use a LazyResolvedPointcutDefinition so that the pointcut is resolved lazily
-                // since for it to be resolved, we will need other pointcuts to be registered as well
-                pc = parsePointcut(pointcutExpr.getValue().stringifyValue(), struct, true);
-                if (pc == null) return false;//parse error
-                pc.setLocation(struct.context, -1, -1);//FIXME AVASM !! bMethod is null here..
-//              } else {
-//                reportError("Found undefined @Pointcut on a non-abstract method", struct);
-//                return false;
-//              }
-        	}
-        }
-        // do not resolve binding now but lazily
-        struct.ajAttributes.add(
-                new AjAttribute.PointcutDeclarationAttribute(
-                        new LazyResolvedPointcutDefinition(
-                                struct.enclosingType,
-                                struct.method.getModifiers(),
-                                struct.method.getName(),
-                                argumentTypes,
-                                UnresolvedType.forSignature(struct.method.getReturnType().getSignature()),
-                                pc,//can be null for abstract pointcut
-                                binding // can be null for abstract pointcut
-                        )
-                )
-        );
-        return true;
-    }
-
-    /**
-     * Read @DeclareError, @DeclareWarning
-     *
-     * @param runtimeAnnotations
-     * @param struct
-     * @return true if found
-     */
-    private static boolean handleDeclareErrorOrWarningAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeFieldStruct struct) {
-        AnnotationGen error = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREERROR_ANNOTATION);
-        boolean hasError = false;
-        if (error != null) {
-            ElementNameValuePairGen declareError = getAnnotationElement(error, VALUE);
-            if (declareError != null) {
-                if (!STRING_DESC.equals(struct.field.getSignature()) || struct.field.getConstantValue() == null) {
-                    reportError("@DeclareError used on a non String constant field", struct);
-                    return false;
-                }
-                Pointcut pc = parsePointcut(declareError.getValue().stringifyValue(), struct, false);
-                if (pc == null) {
-                    hasError = false;//cannot parse pointcut
-                } else {                	 
-                    DeclareErrorOrWarning deow = new DeclareErrorOrWarning(true, pc, struct.field.getConstantValue().toString());
-                    setDeclareErrorOrWarningLocation(deow,struct);
-                    struct.ajAttributes.add(new AjAttribute.DeclareAttribute(deow));
-                    hasError = true;
-                }
-            }
-        }
-        AnnotationGen warning = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREWARNING_ANNOTATION);
-        boolean hasWarning = false;
-        if (warning != null) {
-            ElementNameValuePairGen declareWarning = getAnnotationElement(warning, VALUE);
-            if (declareWarning != null) {
-                if (!STRING_DESC.equals(struct.field.getSignature()) || struct.field.getConstantValue() == null) {
-                    reportError("@DeclareWarning used on a non String constant field", struct);
-                    return false;
-                }
-                Pointcut pc = parsePointcut(declareWarning.getValue().stringifyValue(), struct, false);
-                if (pc == null) {
-                    hasWarning = false;//cannot parse pointcut
-                } else {
-                    DeclareErrorOrWarning deow = new DeclareErrorOrWarning(false, pc, struct.field.getConstantValue().toString());
-                    setDeclareErrorOrWarningLocation(deow,struct);
-                    struct.ajAttributes.add(new AjAttribute.DeclareAttribute(deow));
-                    return hasWarning = true;
-                }
-            }
-        }
-        return hasError || hasWarning;
-    }
-
-    /**
-     * Sets the location for the declare error / warning using the corresponding 
-     * IProgramElement in the structure model. This will only fix bug 120356 if
-     * compiled with -emacssym, however, it does mean that the cross references 
-     * view in AJDT will show the correct information.
-     * 
-     * Other possibilities for fix: 
-     *  1. using the information in ajcDeclareSoft (if this is set correctly) 
-     *     which will fix the problem if compiled with ajc but not if compiled 
-     *     with javac.
-     *  2. creating an AjAttribute called FieldDeclarationLineNumberAttribute 
-     *     (much like MethodDeclarationLineNumberAttribute) which we can ask 
-     *     for the offset. This will again only fix bug 120356 when compiled 
-     *     with ajc.
-     * 
-     * @param deow
-     * @param struct
-     */
-    private static void setDeclareErrorOrWarningLocation(DeclareErrorOrWarning deow, AjAttributeFieldStruct struct) {
-        IHierarchy top = AsmManager.getDefault().getHierarchy();
-        if (top.getRoot() != null) {
-        	IProgramElement ipe = top.findElementForLabel(top.getRoot(),
-      			  IProgramElement.Kind.FIELD,struct.field.getName());
-        	if (ipe != null && ipe.getSourceLocation() != null) {
-    			ISourceLocation sourceLocation = ipe.getSourceLocation();
-    			int start = sourceLocation.getOffset();
-    			int end = start + struct.field.getName().length();
-    			deow.setLocation(struct.context,start,end);
-    			return;
-    		}
+		Constant[] cpool = javaClass.getConstantPool().getConstantPool();
+		for (int i = 0; i < cpool.length; i++) {
+			Constant constant = cpool[i];
+			if (constant != null && constant.getTag() == Constants.CONSTANT_Utf8) {
+				String constantValue = ((ConstantUtf8) constant).getBytes();
+				if (constantValue.length() > 28 && constantValue.charAt(1) == 'o') {
+					if (constantValue.startsWith("Lorg/aspectj/lang/annotation")) {
+						containsAnnotationClassReference = true;
+						if ("Lorg/aspectj/lang/annotation/DeclareAnnotation;".equals(constantValue)) {
+							msgHandler.handleMessage(new Message(
+									"Found @DeclareAnnotation while current release does not support it (see '" + type.getName()
+											+ "')", IMessage.WARNING, null, type.getSourceLocation()));
+						}
+						if ("Lorg/aspectj/lang/annotation/Pointcut;".equals(constantValue)) {
+							containsPointcut = true;
+						}
+					}
+
+				}
+			}
+		}
+		if (!containsAnnotationClassReference)
+			return EMPTY_LIST;
+
+		AjAttributeStruct struct = new AjAttributeStruct(type, context, msgHandler);
+		Attribute[] attributes = javaClass.getAttributes();
+		boolean hasAtAspectAnnotation = false;
+		boolean hasAtPrecedenceAnnotation = false;
+
+		for (int i = 0; i < attributes.length; i++) {
+			Attribute attribute = attributes[i];
+			if (acceptAttribute(attribute)) {
+				RuntimeAnnotations rvs = (RuntimeAnnotations) attribute;
+				// we don't need to look for several attribute occurrences since it cannot happen as per JSR175
+				if (!isCodeStyleAspect && !javaClass.isInterface()) {
+					hasAtAspectAnnotation = handleAspectAnnotation(rvs, struct);
+					// TODO AV - if put outside the if isCodeStyleAspect then we would enable mix style
+					hasAtPrecedenceAnnotation = handlePrecedenceAnnotation(rvs, struct);
+				}
+				// there can only be one RuntimeVisible bytecode attribute
+				break;
+			}
+		}
+
+		// basic semantic check
+		if (hasAtPrecedenceAnnotation && !hasAtAspectAnnotation) {
+			msgHandler.handleMessage(new Message("Found @DeclarePrecedence on a non @Aspect type '" + type.getName() + "'",
+					IMessage.WARNING, null, type.getSourceLocation()));
+			// bypass what we have read
+			return EMPTY_LIST;
+		}
+
+		// the following block will not detect @Pointcut in non @Aspect types for optimization purpose
+		if (!(hasAtAspectAnnotation || isCodeStyleAspect) && !containsPointcut) {
+			return EMPTY_LIST;
+		}
+
+		// FIXME AV - turn on when ajcMightHaveAspect
+		// if (hasAtAspectAnnotation && type.isInterface()) {
+		// msgHandler.handleMessage(
+		// new Message(
+		// "Found @Aspect on an interface type '" + type.getName() + "'",
+		// IMessage.WARNING,
+		// null,
+		// type.getSourceLocation()
+		// )
+		// );
+		// // bypass what we have read
+		// return EMPTY_LIST;
+		// }
+
+		// semantic check: @Aspect must be public
+		// FIXME AV - do we really want to enforce that?
+		// if (hasAtAspectAnnotation && !javaClass.isPublic()) {
+		// msgHandler.handleMessage(
+		// new Message(
+		// "Found @Aspect annotation on a non public class '" + javaClass.getClassName() + "'",
+		// IMessage.ERROR,
+		// null,
+		// type.getSourceLocation()
+		// )
+		// );
+		// return EMPTY_LIST;
+		// }
+
+		// code style pointcuts are class attributes
+		// we need to gather the @AJ pointcut right now and not at method level annotation extraction time
+		// in order to be able to resolve the pointcut references later on
+		// we don't need to look in super class, the pointcut reference in the grammar will do it
+
+		for (int i = 0; i < javaClass.getMethods().length; i++) {
+			Method method = javaClass.getMethods()[i];
+			if (method.getName().startsWith(NameMangler.PREFIX))
+				continue; // already dealt with by ajc...
+			// FIXME alex optimize, this method struct will gets recreated for advice extraction
+			AjAttributeMethodStruct mstruct = null;
+			boolean processedPointcut = false;
+			Attribute[] mattributes = method.getAttributes();
+			for (int j = 0; j < mattributes.length; j++) {
+				Attribute mattribute = mattributes[j];
+				if (acceptAttribute(mattribute)) {
+					mstruct = new AjAttributeMethodStruct(method, null, type, context, msgHandler);// FIXME AVASM
+					processedPointcut = handlePointcutAnnotation((RuntimeAnnotations) mattribute, mstruct);
+					// there can only be one RuntimeVisible bytecode attribute
+					break;
+				}
+			}
+			if (processedPointcut) {
+				// FIXME asc should check we aren't adding multiple versions... will do once I get the tests passing again...
+				struct.ajAttributes.add(new AjAttribute.WeaverVersionInfo());
+				struct.ajAttributes.addAll(mstruct.ajAttributes);
+			}
+		}
+
+		// code style declare error / warning / implements / parents are field attributes
+		Field[] fs = javaClass.getFields();
+		for (int i = 0; i < fs.length; i++) {
+			Field field = fs[i];
+			if (field.getName().startsWith(NameMangler.PREFIX))
+				continue; // already dealt with by ajc...
+			// FIXME alex optimize, this method struct will gets recreated for advice extraction
+			AjAttributeFieldStruct fstruct = new AjAttributeFieldStruct(field, null, type, context, msgHandler);
+			Attribute[] fattributes = field.getAttributes();
+
+			for (int j = 0; j < fattributes.length; j++) {
+				Attribute fattribute = fattributes[j];
+				if (acceptAttribute(fattribute)) {
+					RuntimeAnnotations frvs = (RuntimeAnnotations) fattribute;
+					if (handleDeclareErrorOrWarningAnnotation(model, frvs, fstruct)
+							|| handleDeclareParentsAnnotation(frvs, fstruct)) {
+						// semantic check - must be in an @Aspect [remove if previous block bypassed in advance]
+						if (!type.isAnnotationStyleAspect() && !isCodeStyleAspect) {
+							msgHandler.handleMessage(new Message("Found @AspectJ annotations in a non @Aspect type '"
+									+ type.getName() + "'", IMessage.WARNING, null, type.getSourceLocation()));
+							// go ahead
+						}
+					}
+					// there can only be one RuntimeVisible bytecode attribute
+					break;
+				}
+			}
+			struct.ajAttributes.addAll(fstruct.ajAttributes);
+		}
+
+		return struct.ajAttributes;
+	}
+
+	/**
+	 * Extract method level annotations and turn them into AjAttributes.
+	 * 
+	 * @param method
+	 * @param type
+	 * @param context
+	 * @param msgHandler
+	 * @return list of AjAttributes
+	 */
+	public static List readAj5MethodAttributes(Method method, BcelMethod bMethod, ResolvedType type,
+			ResolvedPointcutDefinition preResolvedPointcut, ISourceContext context, IMessageHandler msgHandler) {
+		if (method.getName().startsWith(NameMangler.PREFIX))
+			return Collections.EMPTY_LIST; // already dealt with by ajc...
+
+		AjAttributeMethodStruct struct = new AjAttributeMethodStruct(method, bMethod, type, context, msgHandler);
+		Attribute[] attributes = method.getAttributes();
+
+		// we remember if we found one @AJ annotation for minimal semantic error reporting
+		// the real reporting beeing done thru AJDT and the compiler mapping @AJ to AjAtttribute
+		// or thru APT
+		//
+		// Note: we could actually skip the whole thing if type is not itself an @Aspect
+		// but then we would not see any warning. We do bypass for pointcut but not for advice since it would
+		// be too silent.
+		boolean hasAtAspectJAnnotation = false;
+		boolean hasAtAspectJAnnotationMustReturnVoid = false;
+		for (int i = 0; i < attributes.length; i++) {
+			Attribute attribute = attributes[i];
+			try {
+				if (acceptAttribute(attribute)) {
+					RuntimeAnnotations rvs = (RuntimeAnnotations) attribute;
+					hasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid
+							|| handleBeforeAnnotation(rvs, struct, preResolvedPointcut);
+					hasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid
+							|| handleAfterAnnotation(rvs, struct, preResolvedPointcut);
+					hasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid
+							|| handleAfterReturningAnnotation(rvs, struct, preResolvedPointcut, bMethod);
+					hasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid
+							|| handleAfterThrowingAnnotation(rvs, struct, preResolvedPointcut, bMethod);
+					hasAtAspectJAnnotation = hasAtAspectJAnnotation || handleAroundAnnotation(rvs, struct, preResolvedPointcut);
+					// there can only be one RuntimeVisible bytecode attribute
+					break;
+				}
+			} catch (ReturningFormalNotDeclaredInAdviceSignatureException e) {
+				msgHandler.handleMessage(new Message(WeaverMessages.format(WeaverMessages.RETURNING_FORMAL_NOT_DECLARED_IN_ADVICE,
+						e.getFormalName()), IMessage.ERROR, null, bMethod.getSourceLocation()));
+			} catch (ThrownFormalNotDeclaredInAdviceSignatureException e) {
+				msgHandler.handleMessage(new Message(WeaverMessages.format(WeaverMessages.THROWN_FORMAL_NOT_DECLARED_IN_ADVICE, e
+						.getFormalName()), IMessage.ERROR, null, bMethod.getSourceLocation()));
+			}
+		}
+		hasAtAspectJAnnotation = hasAtAspectJAnnotation || hasAtAspectJAnnotationMustReturnVoid;
+
+		// semantic check - must be in an @Aspect [remove if previous block bypassed in advance]
+		if (hasAtAspectJAnnotation && !type.isAnnotationStyleAspect()) {
+			msgHandler.handleMessage(new Message("Found @AspectJ annotations in a non @Aspect type '" + type.getName() + "'",
+					IMessage.WARNING, null, type.getSourceLocation()));
+			// go ahead
+		}
+		// semantic check - advice must be public
+		if (hasAtAspectJAnnotation && !struct.method.isPublic()) {
+			msgHandler.handleMessage(new Message("Found @AspectJ annotation on a non public advice '"
+					+ methodToString(struct.method) + "'", IMessage.ERROR, null, type.getSourceLocation()));
+			// go ahead
+		}
+
+		// semantic check - advice must not be static
+		if (hasAtAspectJAnnotation && struct.method.isStatic()) {
+			msgHandler.handleMessage(MessageUtil.error("Advice cannot be declared static '" + methodToString(struct.method) + "'",
+					type.getSourceLocation()));
+			// new Message(
+			// "Advice cannot be declared static '" + methodToString(struct.method) + "'",
+			// IMessage.ERROR,
+			// null,
+			// type.getSourceLocation()
+			// )
+			// );
+			// go ahead
+		}
+
+		// semantic check for non around advice must return void
+		if (hasAtAspectJAnnotationMustReturnVoid && !Type.VOID.equals(struct.method.getReturnType())) {
+			msgHandler.handleMessage(new Message("Found @AspectJ annotation on a non around advice not returning void '"
+					+ methodToString(struct.method) + "'", IMessage.ERROR, null, type.getSourceLocation()));
+			// go ahead
+		}
+
+		return struct.ajAttributes;
+	}
+
+	/**
+	 * Extract field level annotations and turn them into AjAttributes.
+	 * 
+	 * @param field
+	 * @param type
+	 * @param context
+	 * @param msgHandler
+	 * @return list of AjAttributes, always empty for now
+	 */
+	public static List readAj5FieldAttributes(Field field, BcelField bField, ResolvedType type, ISourceContext context,
+			IMessageHandler msgHandler) {
+		// Note: field annotation are for ITD and DEOW - processed at class level directly
+		return Collections.EMPTY_LIST;
+	}
+
+	/**
+	 * Read @Aspect
+	 * 
+	 * @param runtimeAnnotations
+	 * @param struct
+	 * @return true if found
+	 */
+	private static boolean handleAspectAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeStruct struct) {
+		AnnotationGen aspect = getAnnotation(runtimeAnnotations, AjcMemberMaker.ASPECT_ANNOTATION);
+		if (aspect != null) {
+			// semantic check for inheritance (only one level up)
+			boolean extendsAspect = false;
+			if (!"java.lang.Object".equals(struct.enclosingType.getSuperclass().getName())) {
+				if (!struct.enclosingType.getSuperclass().isAbstract() && struct.enclosingType.getSuperclass().isAspect()) {
+					reportError("cannot extend a concrete aspect", struct);
+					return false;
+				}
+				extendsAspect = struct.enclosingType.getSuperclass().isAspect();
+			}
+
+			ElementNameValuePairGen aspectPerClause = getAnnotationElement(aspect, VALUE);
+			final PerClause perClause;
+			if (aspectPerClause == null) {
+				// empty value means singleton unless inherited
+				if (!extendsAspect) {
+					perClause = new PerSingleton();
+				} else {
+					perClause = new PerFromSuper(struct.enclosingType.getSuperclass().getPerClause().getKind());
+				}
+			} else {
+				String perX = aspectPerClause.getValue().stringifyValue();
+				if (perX == null || perX.length() <= 0) {
+					perClause = new PerSingleton();
+				} else {
+					perClause = parsePerClausePointcut(perX, struct);
+				}
+			}
+			if (perClause == null) {
+				// could not parse it, ignore the aspect
+				return false;
+			} else {
+				perClause.setLocation(struct.context, -1, -1);// struct.context.getOffset(), struct.context.getOffset()+1);//FIXME
+				// AVASM
+				// FIXME asc see related comment way about about the version...
+				struct.ajAttributes.add(new AjAttribute.WeaverVersionInfo());
+				AjAttribute.Aspect aspectAttribute = new AjAttribute.Aspect(perClause);
+				struct.ajAttributes.add(aspectAttribute);
+				FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
+				final IScope binding;
+				binding = new BindingScope(struct.enclosingType, struct.context, bindings);
+
+				// // we can't resolve here since the perclause typically refers to pointcuts
+				// // defined in the aspect that we haven't told the BcelObjectType about yet.
+				//
+				// perClause.resolve(binding);
+
+				// so we prepare to do it later...
+				aspectAttribute.setResolutionScope(binding);
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Read a perClause, returns null on failure and issue messages
+	 * 
+	 * @param perClauseString like "pertarget(.....)"
+	 * @param struct for which we are parsing the per clause
+	 * @return a PerClause instance
+	 */
+	private static PerClause parsePerClausePointcut(String perClauseString, AjAttributeStruct struct) {
+		final String pointcutString;
+		Pointcut pointcut = null;
+		TypePattern typePattern = null;
+		final PerClause perClause;
+		if (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERCFLOW.getName())) {
+			pointcutString = PerClause.KindAnnotationPrefix.PERCFLOW.extractPointcut(perClauseString);
+			pointcut = parsePointcut(pointcutString, struct, false);
+			perClause = new PerCflow(pointcut, false);
+		} else if (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERCFLOWBELOW.getName())) {
+			pointcutString = PerClause.KindAnnotationPrefix.PERCFLOWBELOW.extractPointcut(perClauseString);
+			pointcut = parsePointcut(pointcutString, struct, false);
+			perClause = new PerCflow(pointcut, true);
+		} else if (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERTARGET.getName())) {
+			pointcutString = PerClause.KindAnnotationPrefix.PERTARGET.extractPointcut(perClauseString);
+			pointcut = parsePointcut(pointcutString, struct, false);
+			perClause = new PerObject(pointcut, false);
+		} else if (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERTHIS.getName())) {
+			pointcutString = PerClause.KindAnnotationPrefix.PERTHIS.extractPointcut(perClauseString);
+			pointcut = parsePointcut(pointcutString, struct, false);
+			perClause = new PerObject(pointcut, true);
+		} else if (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERTYPEWITHIN.getName())) {
+			pointcutString = PerClause.KindAnnotationPrefix.PERTYPEWITHIN.extractPointcut(perClauseString);
+			typePattern = parseTypePattern(pointcutString, struct);
+			perClause = new PerTypeWithin(typePattern);
+		} else if (perClauseString.equalsIgnoreCase(PerClause.SINGLETON.getName() + "()")) {
+			perClause = new PerSingleton();
+		} else {
+			// could not parse the @AJ perclause - fallback to singleton and issue an error
+			reportError("@Aspect per clause cannot be read '" + perClauseString + "'", struct);
+			return null;
+		}
+
+		if (!PerClause.SINGLETON.equals(perClause.getKind()) && !PerClause.PERTYPEWITHIN.equals(perClause.getKind())
+				&& pointcut == null) {
+			// we could not parse the pointcut
+			return null;
+		}
+		if (PerClause.PERTYPEWITHIN.equals(perClause.getKind()) && typePattern == null) {
+			// we could not parse the type pattern
+			return null;
+		}
+		return perClause;
+	}
+
+	/**
+	 * Read @DeclarePrecedence
+	 * 
+	 * @param runtimeAnnotations
+	 * @param struct
+	 * @return true if found
+	 */
+	private static boolean handlePrecedenceAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeStruct struct) {
+		AnnotationGen aspect = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREPRECEDENCE_ANNOTATION);
+		if (aspect != null) {
+			ElementNameValuePairGen precedence = getAnnotationElement(aspect, VALUE);
+			if (precedence != null) {
+				String precedencePattern = precedence.getValue().stringifyValue();
+				PatternParser parser = new PatternParser(precedencePattern);
+				DeclarePrecedence ajPrecedence = parser.parseDominates();
+				struct.ajAttributes.add(new AjAttribute.DeclareAttribute(ajPrecedence));
+				return true;
+			}
+		}
+		return false;
+	}
+
+	// /**
+	// * Read @DeclareImplements
+	// *
+	// * @param runtimeAnnotations
+	// * @param struct
+	// * @return true if found
+	// */
+	// private static boolean handleDeclareImplementsAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeFieldStruct
+	// struct) {//, ResolvedPointcutDefinition preResolvedPointcut) {
+	// Annotation deci = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREIMPLEMENTS_ANNOTATION);
+	// if (deci != null) {
+	// ElementNameValuePairGen deciPatternNVP = getAnnotationElement(deci, VALUE);
+	// String deciPattern = deciPatternNVP.getValue().stringifyValue();
+	// if (deciPattern != null) {
+	// TypePattern typePattern = parseTypePattern(deciPattern, struct);
+	// ResolvedType fieldType = UnresolvedType.forSignature(struct.field.getSignature()).resolve(struct.enclosingType.getWorld());
+	// if (fieldType.isPrimitiveType()) {
+	// return false;
+	// } else if (fieldType.isInterface()) {
+	// TypePattern parent = new ExactTypePattern(UnresolvedType.forSignature(struct.field.getSignature()), false, false);
+	// parent.resolve(struct.enclosingType.getWorld());
+	// List parents = new ArrayList(1);
+	// parents.add(parent);
+	// //TODO kick ISourceLocation sl = struct.bField.getSourceLocation(); ??
+	// struct.ajAttributes.add(
+	// new AjAttribute.DeclareAttribute(
+	// new DeclareParents(
+	// typePattern,
+	// parents,
+	// false
+	// )
+	// )
+	// );
+	// return true;
+	// } else {
+	// reportError("@DeclareImplements: can only be used on field whose type is an interface", struct);
+	// return false;
+	// }
+	// }
+	// }
+	// return false;
+	// }
+
+	/**
+	 * Read @DeclareParents
+	 * 
+	 * @param runtimeAnnotations
+	 * @param struct
+	 * @return true if found
+	 */
+	private static boolean handleDeclareParentsAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeFieldStruct struct) {// ,
+		// ResolvedPointcutDefinition
+		// preResolvedPointcut)
+		// {
+		AnnotationGen decp = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREPARENTS_ANNOTATION);
+		if (decp != null) {
+			ElementNameValuePairGen decpPatternNVP = getAnnotationElement(decp, VALUE);
+			String decpPattern = decpPatternNVP.getValue().stringifyValue();
+			if (decpPattern != null) {
+				TypePattern typePattern = parseTypePattern(decpPattern, struct);
+				ResolvedType fieldType = UnresolvedType.forSignature(struct.field.getSignature()).resolve(
+						struct.enclosingType.getWorld());
+				if (fieldType.isInterface()) {
+					TypePattern parent = parseTypePattern(fieldType.getName(), struct);
+					FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
+					IScope binding = new BindingScope(struct.enclosingType, struct.context, bindings);
+					// first add the declare implements like
+					List parents = new ArrayList(1);
+					parents.add(parent);
+					DeclareParents dp = new DeclareParents(typePattern, parents, false);
+					dp.resolve(binding); // resolves the parent and child parts of the decp
+
+					// resolve this so that we can use it for the MethodDelegateMungers below.
+					// eg. '@Coloured *' will change from a WildTypePattern to an 'AnyWithAnnotationTypePattern' after this
+					// resolution
+					typePattern = typePattern.resolveBindings(binding, Bindings.NONE, false, false);
+					// TODO kick ISourceLocation sl = struct.bField.getSourceLocation(); ??
+					// dp.setLocation(dp.getDeclaringType().getSourceContext(),
+					// dp.getDeclaringType().getSourceLocation().getOffset(),
+					// dp.getDeclaringType().getSourceLocation().getOffset());
+					dp.setLocation(struct.context, -1, -1); // not ideal...
+					struct.ajAttributes.add(new AjAttribute.DeclareAttribute(dp));
+
+					// do we have a defaultImpl=xxx.class (ie implementation)
+					String defaultImplClassName = null;
+					ElementNameValuePairGen defaultImplNVP = getAnnotationElement(decp, "defaultImpl");
+					if (defaultImplNVP != null) {
+						ClassElementValueGen defaultImpl = (ClassElementValueGen) defaultImplNVP.getValue();
+						defaultImplClassName = UnresolvedType.forSignature(defaultImpl.getClassString()).getName();
+						if (defaultImplClassName.equals("org.aspectj.lang.annotation.DeclareParents")) {
+							defaultImplClassName = null;
+						} else {
+							// check public no arg ctor
+							ResolvedType impl = struct.enclosingType.getWorld().resolve(defaultImplClassName, false);
+							ResolvedMember[] mm = impl.getDeclaredMethods();
+							boolean hasNoCtorOrANoArgOne = true;
+							for (int i = 0; i < mm.length; i++) {
+								ResolvedMember resolvedMember = mm[i];
+								if (resolvedMember.getName().equals("<init>")) {
+									hasNoCtorOrANoArgOne = false;
+									if (resolvedMember.getParameterTypes().length == 0 && resolvedMember.isPublic()) {
+										hasNoCtorOrANoArgOne = true;
+									}
+								}
+								if (hasNoCtorOrANoArgOne) {
+									break;
+								}
+							}
+							if (!hasNoCtorOrANoArgOne) {
+								reportError("@DeclareParents: defaultImpl=\"" + defaultImplClassName
+										+ "\" has no public no-arg constructor", struct);
+							}
+							if (!fieldType.isAssignableFrom(impl)) {
+								reportError("@DeclareParents: defaultImpl=\"" + defaultImplClassName
+										+ "\" does not implement the interface '" + fieldType.toString() + "'", struct);
+							}
+						}
+
+					}
+
+					// then iterate on field interface hierarchy (not object)
+					boolean hasAtLeastOneMethod = false;
+					ResolvedMember[] methods = (ResolvedMember[]) fieldType.getMethodsWithoutIterator(true, false).toArray(
+							new ResolvedMember[0]);
+					for (int i = 0; i < methods.length; i++) {
+						ResolvedMember method = methods[i];
+						if (method.isAbstract()) {
+							// moved to be detected at weave time if the target doesnt implement the methods
+							// if (defaultImplClassName == null) {
+							// // non marker interface with no default impl provided
+							// reportError("@DeclareParents: used with a non marker interface and no defaultImpl=\"...\" provided",
+							// struct);
+							// return false;
+							// }
+							hasAtLeastOneMethod = true;
+							MethodDelegateTypeMunger mdtm = new MethodDelegateTypeMunger(method, struct.enclosingType,
+									defaultImplClassName, typePattern);
+							mdtm.setSourceLocation(struct.enclosingType.getSourceLocation());
+							struct.ajAttributes.add(new AjAttribute.TypeMunger(mdtm));
+						}
+					}
+					// successfull so far, we thus need a bcel type munger to have
+					// a field hosting the mixin in the target type
+					if (hasAtLeastOneMethod && defaultImplClassName != null) {
+						struct.ajAttributes.add(new AjAttribute.TypeMunger(new MethodDelegateTypeMunger.FieldHostTypeMunger(
+								AjcMemberMaker.itdAtDeclareParentsField(null,// prototyped
+										fieldType, struct.enclosingType), struct.enclosingType, typePattern)));
+					}
+
+					return true;
+				} else {
+					reportError("@DeclareParents: can only be used on a field whose type is an interface", struct);
+					return false;
+				}
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Read @Before
+	 * 
+	 * @param runtimeAnnotations
+	 * @param struct
+	 * @return true if found
+	 */
+	private static boolean handleBeforeAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct,
+			ResolvedPointcutDefinition preResolvedPointcut) {
+		AnnotationGen before = getAnnotation(runtimeAnnotations, AjcMemberMaker.BEFORE_ANNOTATION);
+		if (before != null) {
+			ElementNameValuePairGen beforeAdvice = getAnnotationElement(before, VALUE);
+			if (beforeAdvice != null) {
+				// this/target/args binding
+				String argumentNames = getArgNamesValue(before);
+				if (argumentNames != null) {
+					struct.unparsedArgumentNames = argumentNames;
+				}
+				FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
+				try {
+					bindings = extractBindings(struct);
+				} catch (UnreadableDebugInfoException unreadableDebugInfoException) {
+					return false;
+				}
+				IScope binding = new BindingScope(struct.enclosingType, struct.context, bindings);
+
+				// joinpoint, staticJoinpoint binding
+				int extraArgument = extractExtraArgument(struct.method);
+
+				Pointcut pc = null;
+				if (preResolvedPointcut != null) {
+					pc = preResolvedPointcut.getPointcut();
+					// pc.resolve(binding);
+				} else {
+					pc = parsePointcut(beforeAdvice.getValue().stringifyValue(), struct, false);
+					if (pc == null)
+						return false;// parse error
+					pc = pc.resolve(binding);
+				}
+				setIgnoreUnboundBindingNames(pc, bindings);
+
+				ISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(), struct.bMethod
+						.getDeclarationOffset());
+				struct.ajAttributes.add(new AjAttribute.AdviceAttribute(AdviceKind.Before, pc, extraArgument, sl.getOffset(), sl
+						.getOffset() + 1,// FIXME AVASM
+						struct.context));
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Read @After
+	 * 
+	 * @param runtimeAnnotations
+	 * @param struct
+	 * @return true if found
+	 */
+	private static boolean handleAfterAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct,
+			ResolvedPointcutDefinition preResolvedPointcut) {
+		AnnotationGen after = getAnnotation(runtimeAnnotations, AjcMemberMaker.AFTER_ANNOTATION);
+		if (after != null) {
+			ElementNameValuePairGen afterAdvice = getAnnotationElement(after, VALUE);
+			if (afterAdvice != null) {
+				// this/target/args binding
+				FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
+				String argumentNames = getArgNamesValue(after);
+				if (argumentNames != null) {
+					struct.unparsedArgumentNames = argumentNames;
+				}
+				try {
+					bindings = extractBindings(struct);
+				} catch (UnreadableDebugInfoException unreadableDebugInfoException) {
+					return false;
+				}
+				IScope binding = new BindingScope(struct.enclosingType, struct.context, bindings);
+
+				// joinpoint, staticJoinpoint binding
+				int extraArgument = extractExtraArgument(struct.method);
+
+				Pointcut pc = null;
+				if (preResolvedPointcut != null) {
+					pc = preResolvedPointcut.getPointcut();
+				} else {
+					pc = parsePointcut(afterAdvice.getValue().stringifyValue(), struct, false);
+					if (pc == null)
+						return false;// parse error
+					pc.resolve(binding);
+				}
+				setIgnoreUnboundBindingNames(pc, bindings);
+
+				ISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(), struct.bMethod
+						.getDeclarationOffset());
+				struct.ajAttributes.add(new AjAttribute.AdviceAttribute(AdviceKind.After, pc, extraArgument, sl.getOffset(), sl
+						.getOffset() + 1,// FIXME AVASM
+						struct.context));
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Read @AfterReturning
+	 * 
+	 * @param runtimeAnnotations
+	 * @param struct
+	 * @return true if found
+	 */
+	private static boolean handleAfterReturningAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct,
+			ResolvedPointcutDefinition preResolvedPointcut, BcelMethod owningMethod)
+			throws ReturningFormalNotDeclaredInAdviceSignatureException {
+		AnnotationGen after = getAnnotation(runtimeAnnotations, AjcMemberMaker.AFTERRETURNING_ANNOTATION);
+		if (after != null) {
+			ElementNameValuePairGen annValue = getAnnotationElement(after, VALUE);
+			ElementNameValuePairGen annPointcut = getAnnotationElement(after, POINTCUT);
+			ElementNameValuePairGen annReturned = getAnnotationElement(after, RETURNING);
+
+			// extract the pointcut and returned type/binding - do some checks
+			String pointcut = null;
+			String returned = null;
+			if ((annValue != null && annPointcut != null) || (annValue == null && annPointcut == null)) {
+				reportError("@AfterReturning: either 'value' or 'poincut' must be provided, not both", struct);
+				return false;
+			}
+			if (annValue != null) {
+				pointcut = annValue.getValue().stringifyValue();
+			} else {
+				pointcut = annPointcut.getValue().stringifyValue();
+			}
+			if (isNullOrEmpty(pointcut)) {
+				reportError("@AfterReturning: either 'value' or 'poincut' must be provided, not both", struct);
+				return false;
+			}
+			if (annReturned != null) {
+				returned = annReturned.getValue().stringifyValue();
+				if (isNullOrEmpty(returned)) {
+					returned = null;
+				} else {
+					// check that thrownFormal exists as the last parameter in the advice
+					String[] pNames = owningMethod.getParameterNames();
+					if (pNames == null || pNames.length == 0 || !Arrays.asList(pNames).contains(returned)) {
+						throw new ReturningFormalNotDeclaredInAdviceSignatureException(returned);
+					}
+				}
+			}
+			String argumentNames = getArgNamesValue(after);
+			if (argumentNames != null) {
+				struct.unparsedArgumentNames = argumentNames;
+			}
+			// this/target/args binding
+			// exclude the return binding from the pointcut binding since it is an extraArg binding
+			FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
+			try {
+				bindings = (returned == null ? extractBindings(struct) : extractBindings(struct, returned));
+			} catch (UnreadableDebugInfoException unreadableDebugInfoException) {
+				return false;
+			}
+			IScope binding = new BindingScope(struct.enclosingType, struct.context, bindings);
+
+			// joinpoint, staticJoinpoint binding
+			int extraArgument = extractExtraArgument(struct.method);
+
+			// return binding
+			if (returned != null) {
+				extraArgument |= Advice.ExtraArgument;
+			}
+
+			Pointcut pc = null;
+			if (preResolvedPointcut != null) {
+				pc = preResolvedPointcut.getPointcut();
+			} else {
+				pc = parsePointcut(pointcut, struct, false);
+				if (pc == null)
+					return false;// parse error
+				pc.resolve(binding);
+			}
+			setIgnoreUnboundBindingNames(pc, bindings);
+
+			ISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(), struct.bMethod
+					.getDeclarationOffset());
+			struct.ajAttributes.add(new AjAttribute.AdviceAttribute(AdviceKind.AfterReturning, pc, extraArgument, sl.getOffset(),
+					sl.getOffset() + 1,// FIXME AVASM
+					struct.context));
+			return true;
 		}
-        deow.setLocation(struct.context, -1, -1);												
-    }
-    
-    /**
-     * Returns a readable representation of a method.
-     * Method.toString() is not suitable.
-     *
-     * @param method
-     * @return a readable representation of a method
-     */
-    private static String methodToString(Method method) {
-        StringBuffer sb = new StringBuffer();
-        sb.append(method.getName());
-        sb.append(method.getSignature());
-        return sb.toString();
-    }
-
-    /**
-     * Build the bindings for a given method (pointcut / advice)
-     *
-     * @param struct
-     * @return null if no debug info is available
-     */
-    private static FormalBinding[] extractBindings(AjAttributeMethodStruct struct)
-            throws UnreadableDebugInfoException {
-        Method method = struct.method;
-        String[] argumentNames = struct.getArgumentNames();
-
-        // assert debug info was here
-        if (argumentNames.length != method.getArgumentTypes().length) {
-            reportError("Cannot read debug info for @Aspect to handle formal binding in pointcuts (please compile with 'javac -g' or '<javac debug='true'.../>' in Ant)", struct);
-            throw new UnreadableDebugInfoException();
-        }
-
-        List bindings = new ArrayList();
-        for (int i = 0; i < argumentNames.length; i++) {
-            String argumentName = argumentNames[i];
-            UnresolvedType argumentType = UnresolvedType.forSignature(method.getArgumentTypes()[i].getSignature());
-
-            // do not bind JoinPoint / StaticJoinPoint / EnclosingStaticJoinPoint
-            // TODO solve me : this means that the JP/SJP/ESJP cannot appear as binding
-            // f.e. when applying advice on advice etc
-            if ((AjcMemberMaker.TYPEX_JOINPOINT.equals(argumentType)
-                    || AjcMemberMaker.TYPEX_PROCEEDINGJOINPOINT.equals(argumentType)
-                    || AjcMemberMaker.TYPEX_STATICJOINPOINT.equals(argumentType)
-                    || AjcMemberMaker.TYPEX_ENCLOSINGSTATICJOINPOINT.equals(argumentType)
-                    || AjcMemberMaker.AROUND_CLOSURE_TYPE.equals(argumentType))) {
-                //continue;// skip
-                bindings.add(new FormalBinding.ImplicitFormalBinding(argumentType, argumentName, i));
-            } else {
-                bindings.add(new FormalBinding(argumentType, argumentName, i));
-            }
-        }
-
-        return (FormalBinding[]) bindings.toArray(new FormalBinding[]{});
-    }
-
-    //FIXME alex deal with exclude index
-    private static FormalBinding[] extractBindings(AjAttributeMethodStruct struct, String excludeFormal)
-            throws UnreadableDebugInfoException {
-        FormalBinding[] bindings = extractBindings(struct);
-//        int excludeIndex = -1;
-        for (int i = 0; i < bindings.length; i++) {
-            FormalBinding binding = bindings[i];
-            if (binding.getName().equals(excludeFormal)) {
-//                excludeIndex = i;
-                bindings[i] = new FormalBinding.ImplicitFormalBinding(
-                        binding.getType(), binding.getName(), binding.getIndex()
-                );
-                break;
-            }
-        }
-        return bindings;
-//
-//        if (excludeIndex >= 0) {
-//            FormalBinding[] bindingsFiltered = new FormalBinding[bindings.length-1];
-//            int k = 0;
-//            for (int i = 0; i < bindings.length; i++) {
-//                if (i == excludeIndex) {
-//                    ;
-//                } else {
-//                    bindingsFiltered[k] = new FormalBinding(bindings[i].getType(), bindings[i].getName(), k);
-//                    k++;
-//                }
-//            }
-//            return bindingsFiltered;
-//        } else {
-//            return bindings;
-//        }
-    }
-
-    /**
-     * Compute the flag for the xxxJoinPoint extra argument
-     *
-     * @param method
-     * @return extra arg flag
-     */
-    private static int extractExtraArgument(Method method) {
-        Type[] methodArgs = method.getArgumentTypes();
-        String[] sigs = new String[methodArgs.length];
-        for (int i = 0; i < methodArgs.length; i++) {
-            sigs[i] = methodArgs[i].getSignature();
-        }
-        return extractExtraArgument(sigs);
-    }
-
-    /**
-     * Compute the flag for the xxxJoinPoint extra argument
-     *
-     * @param argumentSignatures
-     * @return  extra arg flag
-     */
-    public static int extractExtraArgument(String[] argumentSignatures) {
-        int extraArgument = 0;
-        for (int i = 0; i < argumentSignatures.length; i++) {
-            if (AjcMemberMaker.TYPEX_JOINPOINT.getSignature().equals(argumentSignatures[i])) {
-                extraArgument |= Advice.ThisJoinPoint;
-            } else if (AjcMemberMaker.TYPEX_PROCEEDINGJOINPOINT.getSignature().equals(argumentSignatures[i])) {
-                extraArgument |= Advice.ThisJoinPoint;
-            } else if (AjcMemberMaker.TYPEX_STATICJOINPOINT.getSignature().equals(argumentSignatures[i])) {
-                extraArgument |= Advice.ThisJoinPointStaticPart;
-            } else if (AjcMemberMaker.TYPEX_ENCLOSINGSTATICJOINPOINT.getSignature().equals(argumentSignatures[i])) {
-                extraArgument |= Advice.ThisEnclosingJoinPointStaticPart;
-            }
-        }
-        return extraArgument;
-    }
-
-    /**
-     * Returns the runtime (RV/RIV) annotation of type annotationType or null if no such annotation
-     *
-     * @param rvs
-     * @param annotationType
-     * @return annotation
-     */
-    private static AnnotationGen getAnnotation(RuntimeAnnotations rvs, UnresolvedType annotationType) {
-        final String annotationTypeName = annotationType.getName();
-        for (Iterator iterator = rvs.getAnnotations().iterator(); iterator.hasNext();) {
-            AnnotationGen rv = (AnnotationGen) iterator.next();
-            if (annotationTypeName.equals(rv.getTypeName())) {
-                return rv;
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Returns the value of a given element of an annotation or null if not found
-     * Caution: Does not handles default value.
-     *
-     * @param annotation
-     * @param elementName
-     * @return annotation NVP
-     */
-    private static ElementNameValuePairGen getAnnotationElement(AnnotationGen annotation, String elementName) {
-        for (Iterator iterator1 = annotation.getValues().iterator(); iterator1.hasNext();) {
-            ElementNameValuePairGen element = (ElementNameValuePairGen) iterator1.next();
-            if (elementName.equals(element.getNameString())) {
-                return element;
-            }
-        }
-        return null;
-    }
-    
-    /**
-     * Return the argNames set for an annotation or null if it is not specified.
-     */
-    private static String getArgNamesValue(AnnotationGen anno) {
-    	 for (Iterator iterator1 = anno.getValues().iterator(); iterator1.hasNext();) {
-    		 ElementNameValuePairGen element = (ElementNameValuePairGen) iterator1.next();
-             if (ARGNAMES.equals(element.getNameString())) {
-                 return element.getValue().stringifyValue();
-             }
-         }
-         return null;
-    }
-    
-    private static String lastbit(String fqname) {
-    	int i = fqname.lastIndexOf(".");
-    	if (i==-1) return fqname; else return fqname.substring(i+1);
-    }
-
-    /**
-     * Extract the method argument names.  First we try the debug info attached
-     * to the method (the LocalVariableTable) - if we cannot find that we look
-     * to use the argNames value that may have been supplied on the associated
-     * annotation.  If that fails we just don't know and return an empty string.
-     *
-     * @param method
-     * @param argNamesFromAnnotation 
-     * @param methodStruct 
-     * @return method argument names
-     */
-    private static String[] getMethodArgumentNames(Method method, String argNamesFromAnnotation, AjAttributeMethodStruct methodStruct) {
-        if (method.getArgumentTypes().length == 0) {
-            return EMPTY_STRINGS;
-        }
-
-        final int startAtStackIndex = method.isStatic() ? 0 : 1;
-        final List arguments = new ArrayList();
-        LocalVariableTable lt = method.getLocalVariableTable();
-        if (lt != null) {
-            for (int j = 0; j < lt.getLocalVariableTable().length; j++) {
-                LocalVariable localVariable = lt.getLocalVariableTable()[j];
-                if (localVariable.getStartPC() == 0) {
-                    if (localVariable.getIndex() >= startAtStackIndex) {
-                        arguments.add(new MethodArgument(localVariable.getName(), localVariable.getIndex()));
-                    }
-                }
-            }
-        } else {
-        	// No debug info, do we have an annotation value we can rely on?
-        	if (argNamesFromAnnotation!=null) {
-        		StringTokenizer st = new StringTokenizer(argNamesFromAnnotation," ,");
-        		List args = new ArrayList();
-        		while (st.hasMoreTokens()) { args.add(st.nextToken());}
-        		if (args.size()!=method.getArgumentTypes().length) {
-        			StringBuffer shortString = new StringBuffer().append(lastbit(method.getReturnType().toString())).append(" ").append(method.getName());
-        			if (method.getArgumentTypes().length>0) {
-        				shortString.append("(");
-        				for (int i =0; i<method.getArgumentTypes().length;i++) {
-        					shortString.append(lastbit(method.getArgumentTypes()[i].toString()));
-        					if ((i+1)<method.getArgumentTypes().length) shortString.append(",");
-        					
-        				}
-        				shortString.append(")");
-        		    }
-        			reportError("argNames annotation value does not specify the right number of argument names for the method '"+shortString.toString()+"'",methodStruct);
-                    return EMPTY_STRINGS;
-        		}
-        		return (String[])args.toArray(new String[]{});
-        	}
-        }
-
-        if (arguments.size() != method.getArgumentTypes().length) {
-            return EMPTY_STRINGS;
-        }
-
-        // sort by index
-        Collections.sort(
-                arguments, new Comparator() {
-                    public int compare(Object o, Object o1) {
-                        MethodArgument mo = (MethodArgument) o;
-                        MethodArgument mo1 = (MethodArgument) o1;
-                        if (mo.indexOnStack == mo1.indexOnStack) {
-                            return 0;
-                        } else if (mo.indexOnStack > mo1.indexOnStack) {
-                            return 1;
-                        } else {
-                            return -1;
-                        }
-                    }
-                }
-        );
-        String[] argumentNames = new String[arguments.size()];
-        int i = 0;
-        for (Iterator iterator = arguments.iterator(); iterator.hasNext(); i++) {
-            MethodArgument methodArgument = (MethodArgument) iterator.next();
-            argumentNames[i] = methodArgument.name;
-        }
-        return argumentNames;
-    }
-
-    /**
-     * A method argument, used for sorting by indexOnStack (ie order in signature)
-     *
-     * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
-     */
-    private static class MethodArgument {
-        String name;
-        int indexOnStack;
-
-        public MethodArgument(String name, int indexOnStack) {
-            this.name = name;
-            this.indexOnStack = indexOnStack;
-        }
-    }
-
-    /**
-     * BindingScope that knows the enclosingType, which is needed for pointcut reference resolution
-     *
-     * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
-     */
-    public static class BindingScope extends SimpleScope {
-        private ResolvedType m_enclosingType;
-        private ISourceContext m_sourceContext;
-
-        public BindingScope(ResolvedType type, ISourceContext sourceContext, FormalBinding[] bindings) {
-            super(type.getWorld(), bindings);
-            m_enclosingType = type;
-            m_sourceContext = sourceContext;
-        }
-
-        public ResolvedType getEnclosingType() {
-            return m_enclosingType;
-        }
-
-        public ISourceLocation makeSourceLocation(IHasPosition location) {
-            return m_sourceContext.makeSourceLocation(location);
-        }
-        
-        public UnresolvedType lookupType(String name, IHasPosition location) {
-        	// bug 126560  
-        	if (m_enclosingType != null) {
-        		// add the package we're in to the list of imported
-            	// prefixes so that we can find types in the same package 
-			String pkgName = m_enclosingType.getPackageName();
-			if (pkgName != null && !pkgName.equals("")) {
-				String[] currentImports = getImportedPrefixes();
-				String[] newImports = new String[currentImports.length + 1];
-				for (int i = 0; i < currentImports.length; i++) {
-					newImports[i] = currentImports[i];
+		return false;
+	}
+
+	/**
+	 * Read @AfterThrowing
+	 * 
+	 * @param runtimeAnnotations
+	 * @param struct
+	 * @return true if found
+	 */
+	private static boolean handleAfterThrowingAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct,
+			ResolvedPointcutDefinition preResolvedPointcut, BcelMethod owningMethod)
+			throws ThrownFormalNotDeclaredInAdviceSignatureException {
+		AnnotationGen after = getAnnotation(runtimeAnnotations, AjcMemberMaker.AFTERTHROWING_ANNOTATION);
+		if (after != null) {
+			ElementNameValuePairGen annValue = getAnnotationElement(after, VALUE);
+			ElementNameValuePairGen annPointcut = getAnnotationElement(after, POINTCUT);
+			ElementNameValuePairGen annThrown = getAnnotationElement(after, THROWING);
+
+			// extract the pointcut and throwned type/binding - do some checks
+			String pointcut = null;
+			String thrownFormal = null;
+			if ((annValue != null && annPointcut != null) || (annValue == null && annPointcut == null)) {
+				reportError("@AfterThrowing: either 'value' or 'poincut' must be provided, not both", struct);
+				return false;
+			}
+			if (annValue != null) {
+				pointcut = annValue.getValue().stringifyValue();
+			} else {
+				pointcut = annPointcut.getValue().stringifyValue();
+			}
+			if (isNullOrEmpty(pointcut)) {
+				reportError("@AfterThrowing: either 'value' or 'poincut' must be provided, not both", struct);
+				return false;
+			}
+			if (annThrown != null) {
+				thrownFormal = annThrown.getValue().stringifyValue();
+				if (isNullOrEmpty(thrownFormal)) {
+					thrownFormal = null;
+				} else {
+					// check that thrownFormal exists as the last parameter in the advice
+					String[] pNames = owningMethod.getParameterNames();
+					if (pNames == null || pNames.length == 0 || !Arrays.asList(pNames).contains(thrownFormal)) {
+						throw new ThrownFormalNotDeclaredInAdviceSignatureException(thrownFormal);
+					}
 				}
-				newImports[currentImports.length] = pkgName.concat(".");
-				setImportedPrefixes(newImports);
 			}
+			String argumentNames = getArgNamesValue(after);
+			if (argumentNames != null) {
+				struct.unparsedArgumentNames = argumentNames;
+			}
+			// this/target/args binding
+			// exclude the throwned binding from the pointcut binding since it is an extraArg binding
+			FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
+			try {
+				bindings = (thrownFormal == null ? extractBindings(struct) : extractBindings(struct, thrownFormal));
+			} catch (UnreadableDebugInfoException unreadableDebugInfoException) {
+				return false;
+			}
+			IScope binding = new BindingScope(struct.enclosingType, struct.context, bindings);
+
+			// joinpoint, staticJoinpoint binding
+			int extraArgument = extractExtraArgument(struct.method);
+
+			// return binding
+			if (thrownFormal != null) {
+				extraArgument |= Advice.ExtraArgument;
+			}
+
+			Pointcut pc = null;
+			if (preResolvedPointcut != null) {
+				pc = preResolvedPointcut.getPointcut();
+			} else {
+				pc = parsePointcut(pointcut, struct, false);
+				if (pc == null)
+					return false;// parse error
+				pc.resolve(binding);
+			}
+			setIgnoreUnboundBindingNames(pc, bindings);
+
+			ISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(), struct.bMethod
+					.getDeclarationOffset());
+			struct.ajAttributes.add(new AjAttribute.AdviceAttribute(AdviceKind.AfterThrowing, pc, extraArgument, sl.getOffset(), sl
+					.getOffset() + 1,// FIXME AVASM
+					struct.context));
+			return true;
+		}
+		return false;
+	}
+
+	/**
+	 * Read @Around
+	 * 
+	 * @param runtimeAnnotations
+	 * @param struct
+	 * @return true if found
+	 */
+	private static boolean handleAroundAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct,
+			ResolvedPointcutDefinition preResolvedPointcut) {
+		AnnotationGen around = getAnnotation(runtimeAnnotations, AjcMemberMaker.AROUND_ANNOTATION);
+		if (around != null) {
+			ElementNameValuePairGen aroundAdvice = getAnnotationElement(around, VALUE);
+			if (aroundAdvice != null) {
+				// this/target/args binding
+				String argumentNames = getArgNamesValue(around);
+				if (argumentNames != null) {
+					struct.unparsedArgumentNames = argumentNames;
+				}
+				FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
+				try {
+					bindings = extractBindings(struct);
+				} catch (UnreadableDebugInfoException unreadableDebugInfoException) {
+					return false;
+				}
+				IScope binding = new BindingScope(struct.enclosingType, struct.context, bindings);
+
+				// joinpoint, staticJoinpoint binding
+				int extraArgument = extractExtraArgument(struct.method);
+
+				Pointcut pc = null;
+				if (preResolvedPointcut != null) {
+					pc = preResolvedPointcut.getPointcut();
+				} else {
+					pc = parsePointcut(aroundAdvice.getValue().stringifyValue(), struct, false);
+					if (pc == null)
+						return false;// parse error
+					pc.resolve(binding);
+				}
+				setIgnoreUnboundBindingNames(pc, bindings);
+
+				ISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(), struct.bMethod
+						.getDeclarationOffset());
+				struct.ajAttributes.add(new AjAttribute.AdviceAttribute(AdviceKind.Around, pc, extraArgument, sl.getOffset(), sl
+						.getOffset() + 1,// FIXME AVASM
+						struct.context));
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Read @Pointcut and handle the resolving in a lazy way to deal with pointcut references
+	 * 
+	 * @param runtimeAnnotations
+	 * @param struct
+	 * @return true if a pointcut was handled
+	 */
+	private static boolean handlePointcutAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct struct) {
+		AnnotationGen pointcut = getAnnotation(runtimeAnnotations, AjcMemberMaker.POINTCUT_ANNOTATION);
+		if (pointcut == null)
+			return false;
+		ElementNameValuePairGen pointcutExpr = getAnnotationElement(pointcut, VALUE);
+
+		// semantic check: the method must return void, or be "public static boolean" for if() support
+		if (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())
+				&& struct.method.isStatic() && struct.method.isPublic()))) {
+			reportWarning("Found @Pointcut on a method not returning 'void' or not 'public static boolean'", struct);
+			// no need to stop
+		}
+
+		// semantic check: the method must not throw anything
+		if (struct.method.getExceptionTable() != null) {
+			reportWarning("Found @Pointcut on a method throwing exception", struct);
+			// no need to stop
+		}
+
+		String argumentNames = getArgNamesValue(pointcut);
+		if (argumentNames != null) {
+			struct.unparsedArgumentNames = argumentNames;
+		}
+		// this/target/args binding
+		final IScope binding;
+		try {
+			if (struct.method.isAbstract()) {
+				binding = null;
+			} else {
+				binding = new BindingScope(struct.enclosingType, struct.context, extractBindings(struct));
+			}
+		} catch (UnreadableDebugInfoException e) {
+			return false;
+		}
+
+		UnresolvedType[] argumentTypes = new UnresolvedType[struct.method.getArgumentTypes().length];
+		for (int i = 0; i < argumentTypes.length; i++) {
+			argumentTypes[i] = UnresolvedType.forSignature(struct.method.getArgumentTypes()[i].getSignature());
+		}
+
+		Pointcut pc = null;
+		if (struct.method.isAbstract()) {
+			if ((pointcutExpr != null && isNullOrEmpty(pointcutExpr.getValue().stringifyValue())) || pointcutExpr == null) {
+				// abstract pointcut
+				// leave pc = null
+			} else {
+				reportError("Found defined @Pointcut on an abstract method", struct);
+				return false;// stop
+			}
+		} else {
+			if (pointcutExpr == null || isNullOrEmpty(pointcutExpr.getValue().stringifyValue())) {
+				// the matches nothing pointcut (125475/125480) - perhaps not as cleanly supported as it could be.
+			} else {
+				// if (pointcutExpr != null) {
+				// use a LazyResolvedPointcutDefinition so that the pointcut is resolved lazily
+				// since for it to be resolved, we will need other pointcuts to be registered as well
+				pc = parsePointcut(pointcutExpr.getValue().stringifyValue(), struct, true);
+				if (pc == null)
+					return false;// parse error
+				pc.setLocation(struct.context, -1, -1);// FIXME AVASM !! bMethod is null here..
+				// } else {
+				// reportError("Found undefined @Pointcut on a non-abstract method", struct);
+				// return false;
+				// }
+			}
+		}
+		// do not resolve binding now but lazily
+		struct.ajAttributes.add(new AjAttribute.PointcutDeclarationAttribute(new LazyResolvedPointcutDefinition(
+				struct.enclosingType, struct.method.getModifiers(), struct.method.getName(), argumentTypes, UnresolvedType
+						.forSignature(struct.method.getReturnType().getSignature()), pc,// can be null for abstract pointcut
+				binding // can be null for abstract pointcut
+				)));
+		return true;
+	}
+
+	/**
+	 * Read @DeclareError, @DeclareWarning
+	 * 
+	 * @param runtimeAnnotations
+	 * @param struct
+	 * @return true if found
+	 */
+	private static boolean handleDeclareErrorOrWarningAnnotation(AsmManager model, RuntimeAnnotations runtimeAnnotations,
+			AjAttributeFieldStruct struct) {
+		AnnotationGen error = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREERROR_ANNOTATION);
+		boolean hasError = false;
+		if (error != null) {
+			ElementNameValuePairGen declareError = getAnnotationElement(error, VALUE);
+			if (declareError != null) {
+				if (!STRING_DESC.equals(struct.field.getSignature()) || struct.field.getConstantValue() == null) {
+					reportError("@DeclareError used on a non String constant field", struct);
+					return false;
+				}
+				Pointcut pc = parsePointcut(declareError.getValue().stringifyValue(), struct, false);
+				if (pc == null) {
+					hasError = false;// cannot parse pointcut
+				} else {
+					DeclareErrorOrWarning deow = new DeclareErrorOrWarning(true, pc, struct.field.getConstantValue().toString());
+					setDeclareErrorOrWarningLocation(model, deow, struct);
+					struct.ajAttributes.add(new AjAttribute.DeclareAttribute(deow));
+					hasError = true;
+				}
+			}
+		}
+		AnnotationGen warning = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREWARNING_ANNOTATION);
+		boolean hasWarning = false;
+		if (warning != null) {
+			ElementNameValuePairGen declareWarning = getAnnotationElement(warning, VALUE);
+			if (declareWarning != null) {
+				if (!STRING_DESC.equals(struct.field.getSignature()) || struct.field.getConstantValue() == null) {
+					reportError("@DeclareWarning used on a non String constant field", struct);
+					return false;
+				}
+				Pointcut pc = parsePointcut(declareWarning.getValue().stringifyValue(), struct, false);
+				if (pc == null) {
+					hasWarning = false;// cannot parse pointcut
+				} else {
+					DeclareErrorOrWarning deow = new DeclareErrorOrWarning(false, pc, struct.field.getConstantValue().toString());
+					setDeclareErrorOrWarningLocation(model, deow, struct);
+					struct.ajAttributes.add(new AjAttribute.DeclareAttribute(deow));
+					return hasWarning = true;
+				}
+			}
+		}
+		return hasError || hasWarning;
+	}
+
+	/**
+	 * Sets the location for the declare error / warning using the corresponding IProgramElement in the structure model. This will
+	 * only fix bug 120356 if compiled with -emacssym, however, it does mean that the cross references view in AJDT will show the
+	 * correct information.
+	 * 
+	 * Other possibilities for fix: 1. using the information in ajcDeclareSoft (if this is set correctly) which will fix the problem
+	 * if compiled with ajc but not if compiled with javac. 2. creating an AjAttribute called FieldDeclarationLineNumberAttribute
+	 * (much like MethodDeclarationLineNumberAttribute) which we can ask for the offset. This will again only fix bug 120356 when
+	 * compiled with ajc.
+	 * 
+	 * @param deow
+	 * @param struct
+	 */
+	private static void setDeclareErrorOrWarningLocation(AsmManager model, DeclareErrorOrWarning deow, AjAttributeFieldStruct struct) {
+		IHierarchy top = (model == null ? null : model.getHierarchy());
+		if (top != null && top.getRoot() != null) {
+			IProgramElement ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.FIELD, struct.field.getName());
+			if (ipe != null && ipe.getSourceLocation() != null) {
+				ISourceLocation sourceLocation = ipe.getSourceLocation();
+				int start = sourceLocation.getOffset();
+				int end = start + struct.field.getName().length();
+				deow.setLocation(struct.context, start, end);
+				return;
+			}
+		}
+		deow.setLocation(struct.context, -1, -1);
+	}
+
+	/**
+	 * Returns a readable representation of a method. Method.toString() is not suitable.
+	 * 
+	 * @param method
+	 * @return a readable representation of a method
+	 */
+	private static String methodToString(Method method) {
+		StringBuffer sb = new StringBuffer();
+		sb.append(method.getName());
+		sb.append(method.getSignature());
+		return sb.toString();
+	}
+
+	/**
+	 * Build the bindings for a given method (pointcut / advice)
+	 * 
+	 * @param struct
+	 * @return null if no debug info is available
+	 */
+	private static FormalBinding[] extractBindings(AjAttributeMethodStruct struct) throws UnreadableDebugInfoException {
+		Method method = struct.method;
+		String[] argumentNames = struct.getArgumentNames();
+
+		// assert debug info was here
+		if (argumentNames.length != method.getArgumentTypes().length) {
+			reportError(
+					"Cannot read debug info for @Aspect to handle formal binding in pointcuts (please compile with 'javac -g' or '<javac debug='true'.../>' in Ant)",
+					struct);
+			throw new UnreadableDebugInfoException();
+		}
+
+		List bindings = new ArrayList();
+		for (int i = 0; i < argumentNames.length; i++) {
+			String argumentName = argumentNames[i];
+			UnresolvedType argumentType = UnresolvedType.forSignature(method.getArgumentTypes()[i].getSignature());
+
+			// do not bind JoinPoint / StaticJoinPoint / EnclosingStaticJoinPoint
+			// TODO solve me : this means that the JP/SJP/ESJP cannot appear as binding
+			// f.e. when applying advice on advice etc
+			if ((AjcMemberMaker.TYPEX_JOINPOINT.equals(argumentType)
+					|| AjcMemberMaker.TYPEX_PROCEEDINGJOINPOINT.equals(argumentType)
+					|| AjcMemberMaker.TYPEX_STATICJOINPOINT.equals(argumentType)
+					|| AjcMemberMaker.TYPEX_ENCLOSINGSTATICJOINPOINT.equals(argumentType) || AjcMemberMaker.AROUND_CLOSURE_TYPE
+					.equals(argumentType))) {
+				// continue;// skip
+				bindings.add(new FormalBinding.ImplicitFormalBinding(argumentType, argumentName, i));
+			} else {
+				bindings.add(new FormalBinding(argumentType, argumentName, i));
+			}
+		}
+
+		return (FormalBinding[]) bindings.toArray(new FormalBinding[] {});
+	}
+
+	// FIXME alex deal with exclude index
+	private static FormalBinding[] extractBindings(AjAttributeMethodStruct struct, String excludeFormal)
+			throws UnreadableDebugInfoException {
+		FormalBinding[] bindings = extractBindings(struct);
+		// int excludeIndex = -1;
+		for (int i = 0; i < bindings.length; i++) {
+			FormalBinding binding = bindings[i];
+			if (binding.getName().equals(excludeFormal)) {
+				// excludeIndex = i;
+				bindings[i] = new FormalBinding.ImplicitFormalBinding(binding.getType(), binding.getName(), binding.getIndex());
+				break;
+			}
+		}
+		return bindings;
+		//
+		// if (excludeIndex >= 0) {
+		// FormalBinding[] bindingsFiltered = new FormalBinding[bindings.length-1];
+		// int k = 0;
+		// for (int i = 0; i < bindings.length; i++) {
+		// if (i == excludeIndex) {
+		// ;
+		// } else {
+		// bindingsFiltered[k] = new FormalBinding(bindings[i].getType(), bindings[i].getName(), k);
+		// k++;
+		// }
+		// }
+		// return bindingsFiltered;
+		// } else {
+		// return bindings;
+		// }
+	}
+
+	/**
+	 * Compute the flag for the xxxJoinPoint extra argument
+	 * 
+	 * @param method
+	 * @return extra arg flag
+	 */
+	private static int extractExtraArgument(Method method) {
+		Type[] methodArgs = method.getArgumentTypes();
+		String[] sigs = new String[methodArgs.length];
+		for (int i = 0; i < methodArgs.length; i++) {
+			sigs[i] = methodArgs[i].getSignature();
+		}
+		return extractExtraArgument(sigs);
+	}
+
+	/**
+	 * Compute the flag for the xxxJoinPoint extra argument
+	 * 
+	 * @param argumentSignatures
+	 * @return extra arg flag
+	 */
+	public static int extractExtraArgument(String[] argumentSignatures) {
+		int extraArgument = 0;
+		for (int i = 0; i < argumentSignatures.length; i++) {
+			if (AjcMemberMaker.TYPEX_JOINPOINT.getSignature().equals(argumentSignatures[i])) {
+				extraArgument |= Advice.ThisJoinPoint;
+			} else if (AjcMemberMaker.TYPEX_PROCEEDINGJOINPOINT.getSignature().equals(argumentSignatures[i])) {
+				extraArgument |= Advice.ThisJoinPoint;
+			} else if (AjcMemberMaker.TYPEX_STATICJOINPOINT.getSignature().equals(argumentSignatures[i])) {
+				extraArgument |= Advice.ThisJoinPointStaticPart;
+			} else if (AjcMemberMaker.TYPEX_ENCLOSINGSTATICJOINPOINT.getSignature().equals(argumentSignatures[i])) {
+				extraArgument |= Advice.ThisEnclosingJoinPointStaticPart;
+			}
+		}
+		return extraArgument;
+	}
+
+	/**
+	 * Returns the runtime (RV/RIV) annotation of type annotationType or null if no such annotation
+	 * 
+	 * @param rvs
+	 * @param annotationType
+	 * @return annotation
+	 */
+	private static AnnotationGen getAnnotation(RuntimeAnnotations rvs, UnresolvedType annotationType) {
+		final String annotationTypeName = annotationType.getName();
+		for (Iterator iterator = rvs.getAnnotations().iterator(); iterator.hasNext();) {
+			AnnotationGen rv = (AnnotationGen) iterator.next();
+			if (annotationTypeName.equals(rv.getTypeName())) {
+				return rv;
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Returns the value of a given element of an annotation or null if not found Caution: Does not handles default value.
+	 * 
+	 * @param annotation
+	 * @param elementName
+	 * @return annotation NVP
+	 */
+	private static ElementNameValuePairGen getAnnotationElement(AnnotationGen annotation, String elementName) {
+		for (Iterator iterator1 = annotation.getValues().iterator(); iterator1.hasNext();) {
+			ElementNameValuePairGen element = (ElementNameValuePairGen) iterator1.next();
+			if (elementName.equals(element.getNameString())) {
+				return element;
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Return the argNames set for an annotation or null if it is not specified.
+	 */
+	private static String getArgNamesValue(AnnotationGen anno) {
+		for (Iterator iterator1 = anno.getValues().iterator(); iterator1.hasNext();) {
+			ElementNameValuePairGen element = (ElementNameValuePairGen) iterator1.next();
+			if (ARGNAMES.equals(element.getNameString())) {
+				return element.getValue().stringifyValue();
+			}
+		}
+		return null;
+	}
+
+	private static String lastbit(String fqname) {
+		int i = fqname.lastIndexOf(".");
+		if (i == -1)
+			return fqname;
+		else
+			return fqname.substring(i + 1);
+	}
+
+	/**
+	 * Extract the method argument names. First we try the debug info attached to the method (the LocalVariableTable) - if we cannot
+	 * find that we look to use the argNames value that may have been supplied on the associated annotation. If that fails we just
+	 * don't know and return an empty string.
+	 * 
+	 * @param method
+	 * @param argNamesFromAnnotation
+	 * @param methodStruct
+	 * @return method argument names
+	 */
+	private static String[] getMethodArgumentNames(Method method, String argNamesFromAnnotation,
+			AjAttributeMethodStruct methodStruct) {
+		if (method.getArgumentTypes().length == 0) {
+			return EMPTY_STRINGS;
+		}
+
+		final int startAtStackIndex = method.isStatic() ? 0 : 1;
+		final List arguments = new ArrayList();
+		LocalVariableTable lt = method.getLocalVariableTable();
+		if (lt != null) {
+			for (int j = 0; j < lt.getLocalVariableTable().length; j++) {
+				LocalVariable localVariable = lt.getLocalVariableTable()[j];
+				if (localVariable.getStartPC() == 0) {
+					if (localVariable.getIndex() >= startAtStackIndex) {
+						arguments.add(new MethodArgument(localVariable.getName(), localVariable.getIndex()));
+					}
+				}
+			}
+		} else {
+			// No debug info, do we have an annotation value we can rely on?
+			if (argNamesFromAnnotation != null) {
+				StringTokenizer st = new StringTokenizer(argNamesFromAnnotation, " ,");
+				List args = new ArrayList();
+				while (st.hasMoreTokens()) {
+					args.add(st.nextToken());
+				}
+				if (args.size() != method.getArgumentTypes().length) {
+					StringBuffer shortString = new StringBuffer().append(lastbit(method.getReturnType().toString())).append(" ")
+							.append(method.getName());
+					if (method.getArgumentTypes().length > 0) {
+						shortString.append("(");
+						for (int i = 0; i < method.getArgumentTypes().length; i++) {
+							shortString.append(lastbit(method.getArgumentTypes()[i].toString()));
+							if ((i + 1) < method.getArgumentTypes().length)
+								shortString.append(",");
+
+						}
+						shortString.append(")");
+					}
+					reportError("argNames annotation value does not specify the right number of argument names for the method '"
+							+ shortString.toString() + "'", methodStruct);
+					return EMPTY_STRINGS;
+				}
+				return (String[]) args.toArray(new String[] {});
+			}
+		}
+
+		if (arguments.size() != method.getArgumentTypes().length) {
+			return EMPTY_STRINGS;
+		}
+
+		// sort by index
+		Collections.sort(arguments, new Comparator() {
+			public int compare(Object o, Object o1) {
+				MethodArgument mo = (MethodArgument) o;
+				MethodArgument mo1 = (MethodArgument) o1;
+				if (mo.indexOnStack == mo1.indexOnStack) {
+					return 0;
+				} else if (mo.indexOnStack > mo1.indexOnStack) {
+					return 1;
+				} else {
+					return -1;
+				}
+			}
+		});
+		String[] argumentNames = new String[arguments.size()];
+		int i = 0;
+		for (Iterator iterator = arguments.iterator(); iterator.hasNext(); i++) {
+			MethodArgument methodArgument = (MethodArgument) iterator.next();
+			argumentNames[i] = methodArgument.name;
+		}
+		return argumentNames;
+	}
+
+	/**
+	 * A method argument, used for sorting by indexOnStack (ie order in signature)
+	 * 
+	 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
+	 */
+	private static class MethodArgument {
+		String name;
+		int indexOnStack;
+
+		public MethodArgument(String name, int indexOnStack) {
+			this.name = name;
+			this.indexOnStack = indexOnStack;
+		}
+	}
+
+	/**
+	 * BindingScope that knows the enclosingType, which is needed for pointcut reference resolution
+	 * 
+	 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
+	 */
+	public static class BindingScope extends SimpleScope {
+		private final ResolvedType m_enclosingType;
+		private final ISourceContext m_sourceContext;
+
+		public BindingScope(ResolvedType type, ISourceContext sourceContext, FormalBinding[] bindings) {
+			super(type.getWorld(), bindings);
+			m_enclosingType = type;
+			m_sourceContext = sourceContext;
+		}
+
+		public ResolvedType getEnclosingType() {
+			return m_enclosingType;
+		}
+
+		public ISourceLocation makeSourceLocation(IHasPosition location) {
+			return m_sourceContext.makeSourceLocation(location);
+		}
+
+		public UnresolvedType lookupType(String name, IHasPosition location) {
+			// bug 126560
+			if (m_enclosingType != null) {
+				// add the package we're in to the list of imported
+				// prefixes so that we can find types in the same package
+				String pkgName = m_enclosingType.getPackageName();
+				if (pkgName != null && !pkgName.equals("")) {
+					String[] currentImports = getImportedPrefixes();
+					String[] newImports = new String[currentImports.length + 1];
+					for (int i = 0; i < currentImports.length; i++) {
+						newImports[i] = currentImports[i];
+					}
+					newImports[currentImports.length] = pkgName.concat(".");
+					setImportedPrefixes(newImports);
+				}
+			}
+			return super.lookupType(name, location);
+		}
+
+	}
+
+	/**
+	 * LazyResolvedPointcutDefinition lazyly resolve the pointcut so that we have time to register all pointcut referenced before
+	 * pointcut resolution happens
+	 * 
+	 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
+	 */
+	public static class LazyResolvedPointcutDefinition extends ResolvedPointcutDefinition {
+		private final Pointcut m_pointcutUnresolved;
+		private final IScope m_binding;
+
+		private Pointcut m_lazyPointcut = null;
+
+		public LazyResolvedPointcutDefinition(UnresolvedType declaringType, int modifiers, String name,
+				UnresolvedType[] parameterTypes, UnresolvedType returnType, Pointcut pointcut, IScope binding) {
+			super(declaringType, modifiers, name, parameterTypes, returnType, null);
+			m_pointcutUnresolved = pointcut;
+			m_binding = binding;
+		}
+
+		public Pointcut getPointcut() {
+			if (m_lazyPointcut == null) {
+				m_lazyPointcut = m_pointcutUnresolved.resolve(m_binding);
+				m_lazyPointcut.copyLocationFrom(m_pointcutUnresolved);
+			}
+			return m_lazyPointcut;
+		}
+	}
+
+	/**
+	 * Helper to test empty strings
+	 * 
+	 * @param s
+	 * @return true if empty or null
+	 */
+	private static boolean isNullOrEmpty(String s) {
+		return (s == null || s.length() <= 0);
+	}
+
+	/**
+	 * Set the pointcut bindings for which to ignore unbound issues, so that we can implicitly bind xxxJoinPoint for @AJ advices
+	 * 
+	 * @param pointcut
+	 * @param bindings
+	 */
+	private static void setIgnoreUnboundBindingNames(Pointcut pointcut, FormalBinding[] bindings) {
+		// register ImplicitBindings as to be ignored since unbound
+		// TODO is it likely to fail in a bad way if f.e. this(jp) etc ?
+		List ignores = new ArrayList();
+		for (int i = 0; i < bindings.length; i++) {
+			FormalBinding formalBinding = bindings[i];
+			if (formalBinding instanceof FormalBinding.ImplicitFormalBinding) {
+				ignores.add(formalBinding.getName());
+			}
+		}
+		pointcut.m_ignoreUnboundBindingForNames = (String[]) ignores.toArray(new String[ignores.size()]);
+	}
+
+	/**
+	 * A check exception when we cannot read debug info (needed for formal binding)
+	 */
+	private static class UnreadableDebugInfoException extends Exception {
+	}
+
+	/**
+	 * Report an error
+	 * 
+	 * @param message
+	 * @param location
+	 */
+	private static void reportError(String message, AjAttributeStruct location) {
+		if (!location.handler.isIgnoring(IMessage.ERROR)) {
+			location.handler.handleMessage(new Message(message, location.enclosingType.getSourceLocation(), true));
+		}
+	}
+
+	/**
+	 * Report a warning
+	 * 
+	 * @param message
+	 * @param location
+	 */
+	private static void reportWarning(String message, AjAttributeStruct location) {
+		if (!location.handler.isIgnoring(IMessage.WARNING)) {
+			location.handler.handleMessage(new Message(message, location.enclosingType.getSourceLocation(), false));
+		}
+	}
+
+	/**
+	 * Parse the given pointcut, return null on failure and issue an error
+	 * 
+	 * @param pointcutString
+	 * @param struct
+	 * @param allowIf
+	 * @return pointcut, unresolved
+	 */
+	private static Pointcut parsePointcut(String pointcutString, AjAttributeStruct struct, boolean allowIf) {
+		try {
+			PatternParser parser = new PatternParser(pointcutString, struct.context);
+			Pointcut pointcut = parser.parsePointcut();
+			parser.checkEof();
+			pointcut.check(null, struct.enclosingType.getWorld());
+			if (!allowIf && pointcutString.indexOf("if()") >= 0 && hasIf(pointcut)) {
+				reportError("if() pointcut is not allowed at this pointcut location '" + pointcutString + "'", struct);
+				return null;
+			}
+			pointcut.setLocation(struct.context, -1, -1);// FIXME -1,-1 is not good enough
+			return pointcut;
+		} catch (ParserException e) {
+			reportError("Invalid pointcut '" + pointcutString + "': " + e.toString()
+					+ (e.getLocation() == null ? "" : " at position " + e.getLocation().getStart()), struct);
+			return null;
+		}
+	}
+
+	private static boolean hasIf(Pointcut pointcut) {
+		IfFinder visitor = new IfFinder();
+		pointcut.accept(visitor, null);
+		return visitor.hasIf;
+	}
+
+	/**
+	 * Parse the given type pattern, return null on failure and issue an error
+	 * 
+	 * @param patternString
+	 * @param location
+	 * @return type pattern
+	 */
+	private static TypePattern parseTypePattern(String patternString, AjAttributeStruct location) {
+		try {
+			TypePattern typePattern = new PatternParser(patternString).parseTypePattern();
+			typePattern.setLocation(location.context, -1, -1);// FIXME -1,-1 is not good enough
+			return typePattern;
+		} catch (ParserException e) {
+			reportError("Invalid type pattern'" + patternString + "' : " + e.getLocation(), location);
+			return null;
+		}
+	}
+
+	static class ThrownFormalNotDeclaredInAdviceSignatureException extends Exception {
+
+		private final String formalName;
+
+		public ThrownFormalNotDeclaredInAdviceSignatureException(String formalName) {
+			this.formalName = formalName;
+		}
+
+		public String getFormalName() {
+			return formalName;
+		}
+	}
+
+	static class ReturningFormalNotDeclaredInAdviceSignatureException extends Exception {
+
+		private final String formalName;
+
+		public ReturningFormalNotDeclaredInAdviceSignatureException(String formalName) {
+			this.formalName = formalName;
+		}
+
+		public String getFormalName() {
+			return formalName;
 		}
-        	return super.lookupType(name,location);
-        }
-        
-    }
-
-    /**
-     * LazyResolvedPointcutDefinition lazyly resolve the pointcut so that we have time to register all
-     * pointcut referenced before pointcut resolution happens
-     *
-     * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
-     */
-    public static class LazyResolvedPointcutDefinition extends ResolvedPointcutDefinition {
-        private Pointcut m_pointcutUnresolved;
-        private IScope m_binding;
-
-        private Pointcut m_lazyPointcut = null;
-
-        public LazyResolvedPointcutDefinition(UnresolvedType declaringType, int modifiers, String name,
-                                              UnresolvedType[] parameterTypes, UnresolvedType returnType,
-                                              Pointcut pointcut, IScope binding) {
-            super(declaringType, modifiers, name, parameterTypes, returnType, null);
-            m_pointcutUnresolved = pointcut;
-            m_binding = binding;
-        }
-
-        public Pointcut getPointcut() {
-            if (m_lazyPointcut == null) {
-                m_lazyPointcut = m_pointcutUnresolved.resolve(m_binding);
-                m_lazyPointcut.copyLocationFrom(m_pointcutUnresolved);
-            }
-            return m_lazyPointcut;
-        }
-    }
-
-    /**
-     * Helper to test empty strings
-     *
-     * @param s
-     * @return true if empty or null
-     */
-    private static boolean isNullOrEmpty(String s) {
-        return (s == null || s.length() <= 0);
-    }
-
-    /**
-     * Set the pointcut bindings for which to ignore unbound issues, so that we can implicitly bind
-     * xxxJoinPoint for @AJ advices
-     *
-     * @param pointcut
-     * @param bindings
-     */
-    private static void setIgnoreUnboundBindingNames(Pointcut pointcut, FormalBinding[] bindings) {
-        // register ImplicitBindings as to be ignored since unbound
-        // TODO is it likely to fail in a bad way if f.e. this(jp) etc ?
-        List ignores = new ArrayList();
-        for (int i = 0; i < bindings.length; i++) {
-            FormalBinding formalBinding = bindings[i];
-            if (formalBinding instanceof FormalBinding.ImplicitFormalBinding) {
-                ignores.add(formalBinding.getName());
-            }
-        }
-        pointcut.m_ignoreUnboundBindingForNames = (String[]) ignores.toArray(new String[ignores.size()]);
-    }
-
-    /**
-     * A check exception when we cannot read debug info (needed for formal binding)
-     */
-    private static class UnreadableDebugInfoException extends Exception {
-    }
-
-    /**
-     * Report an error
-     *
-     * @param message
-     * @param location
-     */
-    private static void reportError(String message, AjAttributeStruct location) {
-        if (!location.handler.isIgnoring(IMessage.ERROR)) {
-            location.handler.handleMessage(
-                    new Message(
-                            message,
-                            location.enclosingType.getSourceLocation(),
-                            true
-                    )
-            );
-        }
-    }
-
-    /**
-     * Report a warning
-     *
-     * @param message
-     * @param location
-     */
-    private static void reportWarning(String message, AjAttributeStruct location) {
-        if (!location.handler.isIgnoring(IMessage.WARNING)) {
-            location.handler.handleMessage(
-                    new Message(
-                            message,
-                            location.enclosingType.getSourceLocation(),
-                            false
-                    )
-            );
-        }
-    }
-
-    /**
-     * Parse the given pointcut, return null on failure and issue an error
-     *
-     * @param pointcutString
-     * @param struct
-     * @param allowIf
-     * @return pointcut, unresolved
-     */
-    private static Pointcut parsePointcut(String pointcutString, AjAttributeStruct struct, boolean allowIf) {
-        try {
-        	PatternParser parser = new PatternParser(pointcutString, struct.context);
-            Pointcut pointcut = parser.parsePointcut();
-            parser.checkEof();
-            pointcut.check(null,struct.enclosingType.getWorld());
-            if (!allowIf && pointcutString.indexOf("if()") >= 0 && hasIf(pointcut)) {
-                reportError("if() pointcut is not allowed at this pointcut location '" + pointcutString +"'", struct);
-                return null;
-            }
-            pointcut.setLocation(struct.context, -1, -1);//FIXME -1,-1 is not good enough
-            return pointcut;
-        } catch (ParserException e) {
-            reportError("Invalid pointcut '" + pointcutString + "': " + e.toString() +
-            		(e.getLocation()==null?"":" at position "+e.getLocation().getStart()), struct);
-            return null;
-        }
-    }
-    
-
-    private static boolean hasIf(Pointcut pointcut) {
-        IfFinder visitor = new IfFinder();
-        pointcut.accept(visitor, null);
-        return visitor.hasIf;
-    }
-
-    /**
-     * Parse the given type pattern, return null on failure and issue an error
-     *
-     * @param patternString
-     * @param location
-     * @return type pattern
-     */
-    private static TypePattern parseTypePattern(String patternString, AjAttributeStruct location) {
-        try {
-            TypePattern typePattern = new PatternParser(patternString).parseTypePattern();
-            typePattern.setLocation(location.context, -1, -1);//FIXME -1,-1 is not good enough
-            return typePattern;
-        } catch (ParserException e) {
-            reportError("Invalid type pattern'" + patternString + "' : " + e.getLocation(), location);
-            return null;
-        }
-    }
-
-    static class ThrownFormalNotDeclaredInAdviceSignatureException extends Exception {
-
-        private String formalName;
-
-        public ThrownFormalNotDeclaredInAdviceSignatureException(String formalName) {
-            this.formalName = formalName;
-        }
-
-        public String getFormalName() { return formalName; }
-    }
-
-    static class ReturningFormalNotDeclaredInAdviceSignatureException extends Exception {
-
-        private String formalName;
-
-        public ReturningFormalNotDeclaredInAdviceSignatureException(String formalName) {
-            this.formalName = formalName;
-        }
-
-        public String getFormalName() { return formalName; }
-    }
+	}
 }
@@ -123,11 +123,11 @@ class BcelClassWeaver implements IClassWeaver {
 	private List addedSuperInitializersAsList = null; // List<IfaceInitList>
 	private final Map addedSuperInitializers = new HashMap(); // Interface ->
 	// IfaceInitList
-	private List addedThisInitializers = new ArrayList(); // List<NewFieldMunger>
-	private List addedClassInitializers = new ArrayList(); // List<NewFieldMunger
+	private final List addedThisInitializers = new ArrayList(); // List<NewFieldMunger>
+	private final List addedClassInitializers = new ArrayList(); // List<NewFieldMunger
 	// >
 
-	private Map mapToAnnotations = new HashMap();
+	private final Map mapToAnnotations = new HashMap();
 
 	// private BcelShadow clinitShadow = null;
 
@@ -880,7 +880,7 @@ class BcelClassWeaver implements IClassWeaver {
 							mg.addAnnotation(decaM.getAnnotationX());
 
 							AsmRelationshipProvider.getDefault().addDeclareAnnotationMethodRelationship(decaM.getSourceLocation(),
-									clazz.getName(), mg.getMemberView());//getMethod());
+									clazz.getName(), mg.getMemberView(), world.getModel());// getMethod());
 							reportMethodCtorWeavingMessage(clazz, mg.getMemberView(), decaM, mg.getDeclarationLineNumber());
 							isChanged = true;
 							modificationOccured = true;
@@ -923,8 +923,8 @@ class BcelClassWeaver implements IClassWeaver {
 								annotationsToAdd.add(a);
 
 								mg.addAnnotation(decaM.getAnnotationX());
-								AsmRelationshipProvider.getDefault().addDeclareAnnotationMethodRelationship(decaM.getSourceLocation(),
-										clazz.getName(), mg.getMemberView());//getMethod());
+								AsmRelationshipProvider.getDefault().addDeclareAnnotationMethodRelationship(
+										decaM.getSourceLocation(), clazz.getName(), mg.getMemberView(), world.getModel());// getMethod());
 								isChanged = true;
 								modificationOccured = true;
 								forRemoval.add(decaM);
@@ -1102,8 +1102,8 @@ class BcelClassWeaver implements IClassWeaver {
 					if (doesAlreadyHaveAnnotation(annotationHolder, itdIsActually, decaF, reportedErrors))
 						continue; // skip this one...
 					annotationHolder.addAnnotation(decaF.getAnnotationX());
-					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaF.getSourceLocation(),
-							itdIsActually.getSourceLocation());
+					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(world.getModel(),
+							decaF.getSourceLocation(), itdIsActually.getSourceLocation());
 					isChanged = true;
 					modificationOccured = true;
 
@@ -1125,8 +1125,8 @@ class BcelClassWeaver implements IClassWeaver {
 						if (doesAlreadyHaveAnnotation(annotationHolder, itdIsActually, decaF, reportedErrors))
 							continue; // skip this one...
 						annotationHolder.addAnnotation(decaF.getAnnotationX());
-						AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaF.getSourceLocation(),
-								itdIsActually.getSourceLocation());
+						AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(world.getModel(),
+								decaF.getSourceLocation(), itdIsActually.getSourceLocation());
 						isChanged = true;
 						modificationOccured = true;
 						forRemoval.add(decaF);
@@ -1160,8 +1160,8 @@ class BcelClassWeaver implements IClassWeaver {
 					}
 					annotationHolder.addAnnotation(decaMC.getAnnotationX());
 					isChanged = true;
-					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaMC.getSourceLocation(),
-							unMangledInterMethod.getSourceLocation());
+					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(world.getModel(),
+							decaMC.getSourceLocation(), unMangledInterMethod.getSourceLocation());
 					reportMethodCtorWeavingMessage(clazz, unMangledInterMethod, decaMC, -1);
 					modificationOccured = true;
 				} else {
@@ -1183,8 +1183,8 @@ class BcelClassWeaver implements IClassWeaver {
 							continue; // skip this one...
 						annotationHolder.addAnnotation(decaMC.getAnnotationX());
 						unMangledInterMethod.addAnnotation(decaMC.getAnnotationX());
-						AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaMC.getSourceLocation(),
-								unMangledInterMethod.getSourceLocation());
+						AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(world.getModel(),
+								decaMC.getSourceLocation(), unMangledInterMethod.getSourceLocation());
 						isChanged = true;
 						modificationOccured = true;
 						forRemoval.add(decaMC);
@@ -1302,8 +1302,8 @@ class BcelClassWeaver implements IClassWeaver {
 								}
 							}
 
-							AsmRelationshipProvider.getDefault().addDeclareAnnotationFieldRelationship(decaF.getSourceLocation(),
-									clazz.getName(), aBcelField);//.getFieldAsIs());
+							AsmRelationshipProvider.getDefault().addDeclareAnnotationFieldRelationship(world.getModel(),
+									decaF.getSourceLocation(), clazz.getName(), aBcelField);// .getFieldAsIs());
 							reportFieldAnnotationWeavingMessage(clazz, fields, fieldCounter, decaF);
 							isChanged = true;
 							modificationOccured = true;
@@ -1337,8 +1337,8 @@ class BcelClassWeaver implements IClassWeaver {
 									continue; // skip this one...
 								}
 								aBcelField.addAnnotation(decaF.getAnnotationX());
-								AsmRelationshipProvider.getDefault().addDeclareAnnotationFieldRelationship(decaF.getSourceLocation(),
-										clazz.getName(), aBcelField);//.getFieldAsIs());
+								AsmRelationshipProvider.getDefault().addDeclareAnnotationFieldRelationship(world.getModel(),
+										decaF.getSourceLocation(), clazz.getName(), aBcelField);// .getFieldAsIs());
 								isChanged = true;
 								modificationOccured = true;
 								forRemoval.add(decaF);
@@ -353,8 +353,8 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 		typeMungers = new ArrayList();
 		declares = new ArrayList();
 		processAttributes(l, pointcuts, false);
-		l = AtAjAttributes.readAj5ClassAttributes(javaClass, getResolvedTypeX(), getResolvedTypeX().getSourceContext(), msgHandler,
-				isCodeStyleAspect);
+		l = AtAjAttributes.readAj5ClassAttributes(getResolvedTypeX().getWorld().getModel(), javaClass, getResolvedTypeX(),
+				getResolvedTypeX().getSourceContext(), msgHandler, isCodeStyleAspect);
 		AjAttribute.Aspect deferredAspectAttribute = processAttributes(l, pointcuts, true);
 
 		if (pointcuts.size() == 0) {
@@ -31,7 +31,6 @@ import org.aspectj.apache.bcel.generic.InstructionHandle;
 import org.aspectj.apache.bcel.generic.InstructionList;
 import org.aspectj.apache.bcel.generic.InvokeInstruction;
 import org.aspectj.apache.bcel.generic.Type;
-import org.aspectj.asm.AsmManager;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.bridge.Message;
@@ -118,7 +117,8 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 		}
 
 		if (changed && worthReporting) {
-			AsmRelationshipProvider.getDefault().addRelationship(weaver.getLazyClassGen().getType(), munger, getAspectType());
+			AsmRelationshipProvider.getDefault().addRelationship(getWorld().getModel(), weaver.getLazyClassGen().getType(), munger,
+					getAspectType());
 		}
 
 		// TAG: WeavingMessage
@@ -1792,10 +1792,11 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 			return false;
 		BcelTypeMunger o = (BcelTypeMunger) other;
 		return ((o.getMunger() == null) ? (getMunger() == null) : o.getMunger().equals(getMunger()))
-				&& ((o.getAspectType() == null) ? (getAspectType() == null) : o.getAspectType().equals(getAspectType()))
-				&& (AsmManager.getDefault().getHandleProvider().dependsOnLocation() ? ((o.getSourceLocation() == null) ? (getSourceLocation() == null)
-						: o.getSourceLocation().equals(getSourceLocation()))
-						: true); // pr134471 - remove when handles are improved
+				&& ((o.getAspectType() == null) ? (getAspectType() == null) : o.getAspectType().equals(getAspectType()));
+		// && (AsmManager.getDefault().getHandleProvider().dependsOnLocation() ? ((o.getSourceLocation() == null) ?
+		// (getSourceLocation() == null)
+		// : o.getSourceLocation().equals(getSourceLocation()))
+		// : true); // pr134471 - remove when handles are improved
 		// to be independent of location
 
 	}
@@ -43,7 +43,6 @@ import java.util.zip.ZipOutputStream;
 
 import org.aspectj.apache.bcel.classfile.ClassParser;
 import org.aspectj.apache.bcel.classfile.JavaClass;
-import org.aspectj.asm.AsmManager;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.bridge.Message;
@@ -1114,10 +1113,10 @@ public class BcelWeaver {
 
 		for (Iterator i = input.getClassFileIterator(); i.hasNext();) {
 			UnwovenClassFile classFile = (UnwovenClassFile) i.next();
-			if (AsmManager.isCreatingModel() && !isBatchWeave) {
+			if (world.getModel() != null /* AsmManager.isCreatingModel() */&& !isBatchWeave) {
 				// remove all relationships where this file being woven is the
 				// target of the relationship
-				AsmManager.getDefault().removeRelationshipsTargettingThisType(classFile.getClassName());
+				world.getModel().removeRelationshipsTargettingThisType(classFile.getClassName());
 			}
 		}
 
@@ -1602,7 +1601,7 @@ public class BcelWeaver {
 			boolean problemReported = verifyTargetIsOK(decA, onType, annoX, reportProblems);
 
 			if (!problemReported) {
-				AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decA.getSourceLocation(),
+				AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(world.getModel(), decA.getSourceLocation(),
 						onType.getSourceLocation());
 				// TAG: WeavingMessage
 				if (!getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {
@@ -42,17 +42,35 @@ import org.aspectj.asm.internal.RelationshipMap;
 import org.aspectj.bridge.ISourceLocation;
 
 /**
- * The Abstract Structure Model (ASM) represents the containment hierarchy and crossccutting structure map for AspectJ programs. It
+ * The Abstract Structure Model (ASM) represents the containment hierarchy and crosscutting structure map for AspectJ programs. It
  * is used by IDE views such as the document outline, and by other tools such as ajdoc to show both AspectJ declarations and
  * crosscutting links, such as which advice affects which join point shadows.
  * 
  * @author Mik Kersten
+ * @author Andy Clement
  */
 public class AsmManager {
 
-	private static AsmManager instance = new AsmManager();
+	// For testing ONLY
+	public static boolean recordingLastActiveStructureModel = true;
+	public static AsmManager lastActiveStructureModel;
+	public static boolean forceSingletonBehaviour = false;
+
+	// SECRETAPI asc pull the secret options together into a system API you lazy fool
+	public static boolean attemptIncrementalModelRepairs = false;
+	// Dumping the model is expensive
+	public static boolean dumpModelPostBuild = false;
+	// For offline debugging, you can now ask for the AsmManager to
+	// dump the model - see the method setReporting()
+	private static boolean dumpModel = false;
+	private static boolean dumpRelationships = false;
+	private static boolean dumpDeltaProcessing = false;
+	private static IModelFilter modelFilter = null;
+	private static String dumpFilename = "";
+	private static boolean reporting = false;
+
+	private static boolean completingTypeBindings = false;
 
-	private IElementHandleProvider handleProvider;
 	private final List structureListeners = new ArrayList();
 
 	// The model is 'manipulated' by the AjBuildManager.setupModel() code which
@@ -64,24 +82,8 @@ public class AsmManager {
 	// between projects.
 	protected IHierarchy hierarchy;
 	private IRelationshipMap mapper;
+	private IElementHandleProvider handleProvider;
 
-	private static boolean creatingModel = false;
-	public static boolean dumpModelPostBuild = false; // Dumping the model is
-	// expensive
-	// SECRETAPI asc pull the secret options together into a system API you lazy
-	// fool
-	public static boolean attemptIncrementalModelRepairs = false;
-
-	// For offline debugging, you can now ask for the AsmManager to
-	// dump the model - see the method setReporting()
-	private static boolean dumpModel = false;
-	private static boolean dumpRelationships = false;
-	private static boolean dumpDeltaProcessing = false;
-	private static IModelFilter modelFilter = null;
-	private static String dumpFilename = "";
-	private static boolean reporting = false;
-
-	private static boolean completingTypeBindings = false;
 	private final CanonicalFilePathMap canonicalFilePathMap = new CanonicalFilePathMap();
 	// Record the Set<File> for which the model has been modified during the
 	// last incremental build
@@ -94,27 +96,29 @@ public class AsmManager {
 	// setReporting("c:/model.nfo",true,true,true,true);
 	// }
 
-	protected AsmManager() {
-		handleProvider = new JDTLikeHandleProvider();
-		createNewASM();
+	private AsmManager() {
 	}
 
-	public void createNewASM() {
-		hierarchy = new AspectJElementHierarchy();
-		mapper = new RelationshipMap(hierarchy);
+	public static AsmManager createNewStructureModel() {
+		if (forceSingletonBehaviour && lastActiveStructureModel != null) {
+			return lastActiveStructureModel;
+		}
+		AsmManager asm = new AsmManager();
+		asm.hierarchy = new AspectJElementHierarchy(asm);
+		asm.mapper = new RelationshipMap(asm.hierarchy);
+		asm.handleProvider = new JDTLikeHandleProvider(asm);
 		// call initialize on the handleProvider when we create a new ASM
 		// to give handleProviders the chance to reset any state
-		handleProvider.initialize();
-		resetDeltaProcessing();
+		asm.handleProvider.initialize();
+		asm.resetDeltaProcessing();
+		setLastActiveStructureModel(asm);
+		return asm;
 	}
 
 	public IHierarchy getHierarchy() {
 		return hierarchy;
 	}
 
-	public static AsmManager getDefault() {
-		return instance;
-	}
 
 	public IRelationshipMap getRelationshipMap() {
 		return mapper;
@@ -167,7 +171,7 @@ public class AsmManager {
 			return;
 		for (Iterator it = children.iterator(); it.hasNext();) {
 			IProgramElement next = (IProgramElement) it.next();
-			List rels = AsmManager.getDefault().getRelationshipMap().get(next);
+			List rels = mapper.get(next);
 			if (next != null
 					&& ((next.getKind() == IProgramElement.Kind.CODE && showSubMember) || (next.getKind() != IProgramElement.Kind.CODE && showMemberAndType))
 					&& rels != null && rels.size() > 0) {
@@ -238,6 +242,7 @@ public class AsmManager {
 				FileInputStream in = new FileInputStream(filePath);
 				ObjectInputStream s = new ObjectInputStream(in);
 				hierarchy = (AspectJElementHierarchy) s.readObject();
+				((AspectJElementHierarchy) hierarchy).setAsmManager(this);
 				hierarchyReadOK = true;
 				mapper = (RelationshipMap) s.readObject();
 				((RelationshipMap) mapper).setHierarchy(hierarchy);
@@ -419,7 +424,7 @@ public class AsmManager {
 			BufferedWriter bw = new BufferedWriter(fw);
 			if (dumpModel) {
 				bw.write("=== MODEL STATUS REPORT ========= " + reasonForReport + "\n");
-				dumptree(bw, AsmManager.getDefault().getHierarchy().getRoot(), 0);
+				dumptree(bw, hierarchy.getRoot(), 0);
 
 				bw.write("=== END OF MODEL REPORT =========\n");
 			}
@@ -428,7 +433,7 @@ public class AsmManager {
 				dumprels(bw);
 				bw.write("=== END OF RELATIONSHIPS REPORT ==\n");
 			}
-			Properties p = ModelInfo.summarizeModel().getProperties();
+			Properties p = summarizeModel().getProperties();
 			Enumeration pkeyenum = p.keys();
 			bw.write("=== Properties of the model and relationships map =====\n");
 			while (pkeyenum.hasMoreElements()) {
@@ -477,12 +482,11 @@ public class AsmManager {
 	}
 
 	public void dumprels(Writer w) throws IOException {
-		IRelationshipMap irm = AsmManager.getDefault().getRelationshipMap();
 		int ctr = 1;
-		Set entries = irm.getEntries();
+		Set entries = mapper.getEntries();
 		for (Iterator iter = entries.iterator(); iter.hasNext();) {
 			String hid = (String) iter.next();
-			List rels = irm.get(hid);
+			List rels = mapper.get(hid);
 			for (Iterator iterator = rels.iterator(); iterator.hasNext();) {
 				IRelationship ir = (IRelationship) iterator.next();
 				List targets = ir.getTargets();
@@ -500,12 +504,11 @@ public class AsmManager {
 
 	private void dumprelsStderr(String key) {
 		System.err.println("Relationships dump follows: " + key);
-		IRelationshipMap irm = AsmManager.getDefault().getRelationshipMap();
 		int ctr = 1;
-		Set entries = irm.getEntries();
+		Set entries = mapper.getEntries();
 		for (Iterator iter = entries.iterator(); iter.hasNext();) {
 			String hid = (String) iter.next();
-			List rels = irm.get(hid);
+			List rels = mapper.get(hid);
 			for (Iterator iterator = rels.iterator(); iterator.hasNext();) {
 				IRelationship ir = (IRelationship) iterator.next();
 				List targets = ir.getTargets();
@@ -527,15 +530,13 @@ public class AsmManager {
 	 */
 	public boolean removeStructureModelForFiles(Writer fw, Collection files) throws IOException {
 
-		IHierarchy model = AsmManager.getDefault().getHierarchy();
-
 		boolean modelModified = false;
 
 		Set deletedNodes = new HashSet();
 		for (Iterator iter = files.iterator(); iter.hasNext();) {
 			File fileForCompilation = (File) iter.next();
-			String correctedPath = AsmManager.getDefault().getCanonicalFilePath(fileForCompilation);
-			IProgramElement progElem = (IProgramElement) model.findInFileMap(correctedPath);
+			String correctedPath = getCanonicalFilePath(fileForCompilation);
+			IProgramElement progElem = (IProgramElement) hierarchy.findInFileMap(correctedPath);
 			if (progElem != null) {
 				// Found it, let's remove it
 				if (dumpDeltaProcessing) {
@@ -544,14 +545,15 @@ public class AsmManager {
 				removeNode(progElem);
 				lastBuildChanges.add(fileForCompilation);
 				deletedNodes.add(getCanonicalFilePath(progElem.getSourceLocation().getSourceFile()));
-				if (!model.removeFromFileMap(correctedPath))
+				if (!hierarchy.removeFromFileMap(correctedPath))
 					throw new RuntimeException("Whilst repairing model, couldn't remove entry for file: " + correctedPath
 							+ " from the filemap");
 				modelModified = true;
 			}
 		}
-		if (modelModified)
-			model.updateHandleMap(deletedNodes);
+		if (modelModified) {
+			hierarchy.updateHandleMap(deletedNodes);
+		}
 		return modelModified;
 	}
 
@@ -565,7 +567,6 @@ public class AsmManager {
 		// config.getFiles())
 
 		// List files = config.getFiles();
-		IHierarchy model = AsmManager.getDefault().getHierarchy();
 
 		boolean modelModified = false;
 		// Files to delete are: those to be compiled + those that have been
@@ -576,8 +577,8 @@ public class AsmManager {
 		Set deletedNodes = new HashSet();
 		for (Iterator iter = filesToRemoveFromStructureModel.iterator(); iter.hasNext();) {
 			File fileForCompilation = (File) iter.next();
-			String correctedPath = AsmManager.getDefault().getCanonicalFilePath(fileForCompilation);
-			IProgramElement progElem = (IProgramElement) model.findInFileMap(correctedPath);
+			String correctedPath = getCanonicalFilePath(fileForCompilation);
+			IProgramElement progElem = (IProgramElement) hierarchy.findInFileMap(correctedPath);
 			if (progElem != null) {
 				// Found it, let's remove it
 				if (dumpDeltaProcessing) {
@@ -585,15 +586,15 @@ public class AsmManager {
 				}
 				removeNode(progElem);
 				deletedNodes.add(getCanonicalFilePath(progElem.getSourceLocation().getSourceFile()));
-				if (!model.removeFromFileMap(correctedPath))
+				if (!hierarchy.removeFromFileMap(correctedPath))
 					throw new RuntimeException("Whilst repairing model, couldn't remove entry for file: " + correctedPath
 							+ " from the filemap");
 				modelModified = true;
 			}
 		}
 		if (modelModified) {
-			model.flushTypeMap();
-			model.updateHandleMap(deletedNodes);
+			hierarchy.flushTypeMap();
+			hierarchy.updateHandleMap(deletedNodes);
 		}
 	}
 
@@ -867,7 +868,7 @@ public class AsmManager {
 	 */
 	private void repairRelationships(Writer fw) {
 		try {
-			IHierarchy model = AsmManager.getDefault().getHierarchy();
+			// IHierarchy model = AsmManager.getDefault().getHierarchy();
 			// TODO Speed this code up by making this assumption:
 			// the only piece of the handle that is interesting is the file
 			// name. We are working at file granularity, if the
@@ -877,7 +878,7 @@ public class AsmManager {
 				fw.write("Repairing relationships map:\n");
 
 			// Now sort out the relationships map
-			IRelationshipMap irm = AsmManager.getDefault().getRelationshipMap();
+			// IRelationshipMap irm = AsmManager.getDefault().getRelationshipMap();
 			Set sourcesToRemove = new HashSet();
 			Set nonExistingHandles = new HashSet(); // Cache of handles that we
 			// *know* are invalid
@@ -885,7 +886,7 @@ public class AsmManager {
 			int tgthandlecounter = 0;
 
 			// Iterate over the source handles in the relationships map
-			Set keyset = irm.getEntries(); // These are source handles
+			Set keyset = mapper.getEntries(); // These are source handles
 			for (Iterator keyiter = keyset.iterator(); keyiter.hasNext();) {
 				String hid = (String) keyiter.next();
 				srchandlecounter++;
@@ -895,7 +896,7 @@ public class AsmManager {
 					sourcesToRemove.add(hid);
 				} else {
 					// We better check if it actually exists
-					IProgramElement existingElement = model.getElement(hid);
+					IProgramElement existingElement = hierarchy.getElement(hid);
 					if (dumpDeltaProcessing)
 						fw.write("Looking for handle [" + hid + "] in model, found: " + existingElement + "\n");
 
@@ -906,7 +907,7 @@ public class AsmManager {
 						nonExistingHandles.add(hid); // Speed up a bit you swine
 					} else {
 						// Ok, so the source is valid, what about the targets?
-						List relationships = irm.get(hid);
+						List relationships = mapper.get(hid);
 						List relationshipsToRemove = new ArrayList();
 						// Iterate through the relationships against this source
 						// handle
@@ -927,7 +928,7 @@ public class AsmManager {
 									targetsToRemove.add(targethid);
 								} else {
 									// We better check
-									IProgramElement existingTarget = model.getElement(targethid);
+									IProgramElement existingTarget = hierarchy.getElement(targethid);
 									if (existingTarget == null) {
 										if (dumpDeltaProcessing)
 											fw.write("Target handle [" + targethid + "] for srchid[" + hid + "]rel["
@@ -989,10 +990,10 @@ public class AsmManager {
 								// relationships !!
 								for (int i = 0; i < relationshipsToRemove.size(); i++) {
 									IRelationship irel = (IRelationship) relationshipsToRemove.get(i);
-									verifyAssumption(irm.remove(hid, irel), "Failed to remove relationship " + irel.getName()
+									verifyAssumption(mapper.remove(hid, irel), "Failed to remove relationship " + irel.getName()
 											+ " for shid " + hid);
 								}
-								List rels = irm.get(hid);
+								List rels = mapper.get(hid);
 								if (rels == null || rels.size() == 0)
 									sourcesToRemove.add(hid);
 							}
@@ -1003,8 +1004,8 @@ public class AsmManager {
 			// Remove sources that have no valid relationships any more
 			for (Iterator srciter = sourcesToRemove.iterator(); srciter.hasNext();) {
 				String hid = (String) srciter.next();
-				irm.removeAll(hid);
-				IProgramElement ipe = model.getElement(hid);
+				mapper.removeAll(hid);
+				IProgramElement ipe = hierarchy.getElement(hid);
 				if (ipe != null) {
 					// If the relationship was hanging off a 'code' node, delete
 					// it.
@@ -1113,7 +1114,7 @@ public class AsmManager {
 	/**
 	 * A ModelInfo object captures basic information about the structure model. It is used for testing and producing debug info.
 	 */
-	public static class ModelInfo {
+	public class ModelInfo {
 		private final Hashtable nodeTypeCount = new Hashtable();
 		private final Properties extraProperties = new Properties();
 
@@ -1179,26 +1180,26 @@ public class AsmManager {
 			extraProperties.setProperty(string, string2);
 		}
 
-		public static ModelInfo summarizeModel() {
-			return new ModelInfo(AsmManager.getDefault().getHierarchy(), AsmManager.getDefault().getRelationshipMap());
-		}
 	}
 
-	/**
-	 * Set to indicate whether we are currently building a structure model, should be set up front.
-	 */
-	public static void setCreatingModel(boolean b) {
-		creatingModel = b;
+	public ModelInfo summarizeModel() {
+		return new ModelInfo(getHierarchy(), getRelationshipMap());
 	}
 
 	/**
-	 * returns true if we are currently generating a structure model, enables guarding of expensive operations on an empty/null
-	 * model.
+	 * Set to indicate whether we are currently building a structure model, should be set up front.
 	 */
-	public static boolean isCreatingModel() {
-		return creatingModel;
-	}
-
+	// public static void setCreatingModel(boolean b) {
+	// creatingModel = b;
+	// }
+	//
+	// /**
+	// * returns true if we are currently generating a structure model, enables guarding of expensive operations on an empty/null
+	// * model.
+	// */
+	// public static boolean isCreatingModel() {
+	// return creatingModel;
+	// }
 	public static void setCompletingTypeBindings(boolean b) {
 		completingTypeBindings = b;
 	}
@@ -1207,13 +1208,13 @@ public class AsmManager {
 		return completingTypeBindings;
 	}
 
-	public void setRelationshipMap(IRelationshipMap irm) {
-		mapper = irm;
-	}
-
-	public void setHierarchy(IHierarchy ih) {
-		hierarchy = ih;
-	}
+	// public void setRelationshipMap(IRelationshipMap irm) {
+	// mapper = irm;
+	// }
+	//
+	// public void setHierarchy(IHierarchy ih) {
+	// hierarchy = ih;
+	// }
 
 	public void resetDeltaProcessing() {
 		lastBuildChanges.clear();
@@ -1239,4 +1240,10 @@ public class AsmManager {
 		aspectsWeavingInLastBuild.add(f);
 	}
 
+	public static void setLastActiveStructureModel(AsmManager structureModel) {
+		if (recordingLastActiveStructureModel) {
+			lastActiveStructureModel = structureModel;
+		}
+	}
+
 }
@@ -17,61 +17,49 @@ import java.io.File;
 import org.aspectj.bridge.ISourceLocation;
 
 /**
- * Adapter used to uniquely identify program element handles.  Can be
- * implemented and overridden in @see{AsmManager} in order to provide
- * IDE-specific mechanisms of identifying elements.  For example, AJDT
- * uses workspace-relative paths that are understood by its JavaCore 
- * class.  
+ * Adapter used to uniquely identify program element handles. Can be implemented and overridden in @see{AsmManager} in order to
+ * provide IDE-specific mechanisms of identifying elements. For example, AJDT uses workspace-relative paths that are understood by
+ * its JavaCore class.
  * 
  * @author Mik Kersten
  */
 public interface IElementHandleProvider {
 
-    /**
-     * @return  a String uniquely identifying this element
-     */
-    public String createHandleIdentifier(ISourceLocation location);
+	/**
+	 * @return a String uniquely identifying this element
+	 */
+	public String createHandleIdentifier(ISourceLocation location);
 
-    /**
-     * @return  a String uniquely identifying this element
-     */
-    public String createHandleIdentifier(File sourceFile, int line,int column,int offset);
+	/**
+	 * @return a String uniquely identifying this element
+	 */
+	public String createHandleIdentifier(File sourceFile, int line, int column, int offset);
 
-    /**
-     * @return  a String uniquely identifying this element
-     */
+	/**
+	 * @return a String uniquely identifying this element
+	 */
 	public String createHandleIdentifier(IProgramElement ipe);
-    
-    /**
-     * NOTE: this is necessary for the current implementation to look up nodes, 
-     * but we may want to consider removing it.
-     * 
-     * @return a String corresponding to the  
-     */
-    public String getFileForHandle(String handle);
-    
-    /**
-     * NOTE: this is necessary for the current implementation to look up nodes, 
-     * but we may want to consider removing it.
-     * 
-     * @return the line number corresponding to this handel
-     */
-    public int getLineNumberForHandle(String handle);
-    
-    public int getOffSetForHandle(String handle);
-    
-    // See pr134471 
-    /**
-     * @return true if the handles produced by the provider 
-     * depend on ISourceLocations and false otherwise
-     */
-    public boolean dependsOnLocation();
-    
-    /**
-     * Initializes handle provider state.
-     * 
-     * The initializer is invoked when a new ASM is
-     * created on a full build.
-     */
-    public void initialize();
+
+	/**
+	 * NOTE: this is necessary for the current implementation to look up nodes, but we may want to consider removing it.
+	 * 
+	 * @return a String corresponding to the
+	 */
+	public String getFileForHandle(String handle);
+
+	/**
+	 * NOTE: this is necessary for the current implementation to look up nodes, but we may want to consider removing it.
+	 * 
+	 * @return the line number corresponding to this handel
+	 */
+	public int getLineNumberForHandle(String handle);
+
+	public int getOffSetForHandle(String handle);
+
+	/**
+	 * Initializes handle provider state.
+	 * 
+	 * The initializer is invoked when a new ASM is created on a full build.
+	 */
+	public void initialize();
 }
@@ -12,7 +12,8 @@
 package org.aspectj.asm;
 
 import java.io.Serializable;
-import java.util.*;
+import java.util.HashMap;
+import java.util.Set;
 
 import org.aspectj.asm.internal.ProgramElement;
 import org.aspectj.bridge.ISourceLocation;
@@ -21,80 +22,80 @@ import org.aspectj.bridge.ISourceLocation;
  * @author Mik Kersten
  */
 public interface IHierarchy extends Serializable {
-	public static final IProgramElement NO_STRUCTURE =
-		new ProgramElement(
-			"<build to view structure>",
-			IProgramElement.Kind.ERROR,
-			null);
+	public static final IProgramElement NO_STRUCTURE = new ProgramElement(null, "<build to view structure>",
+			IProgramElement.Kind.ERROR, null);
 
 	public IProgramElement getElement(String handle);
+
 	public IProgramElement getRoot();
+
 	public void setRoot(IProgramElement root);
+
 	public void addToFileMap(Object key, Object value);
+
 	public boolean removeFromFileMap(Object key);
+
 	public void setFileMap(HashMap fileMap);
+
 	public Object findInFileMap(Object key);
+
 	public Set getFileMapEntrySet();
+
 	public boolean isValid();
 
 	/**
-	 * @return	null if not found
+	 * @return null if not found
 	 */
 	public IProgramElement findElementForHandle(String handle);
 
-	/** 
+	/**
 	 * Returns the first match
 	 * 
 	 * @param parent
-	 * @param kind		not null
+	 * @param kind not null
 	 * @return null if not found
 	 */
-	public IProgramElement findElementForSignature(
-		IProgramElement parent,
-		IProgramElement.Kind kind,
-		String signature);
+	public IProgramElement findElementForSignature(IProgramElement parent, IProgramElement.Kind kind, String signature);
 
-	/** 
+	/**
 	 * Returns the first match
 	 * 
 	 * @param parent
-	 * @param kind		not null
+	 * @param kind not null
 	 * @return null if not found
 	 */
-	public IProgramElement findElementForLabel(
-		IProgramElement parent,
-		IProgramElement.Kind kind,
-		String label);
+	public IProgramElement findElementForLabel(IProgramElement parent, IProgramElement.Kind kind, String label);
 
 	/**
-	 * @param packageName	if null default package is searched
-	 * @param className 	can't be null
+	 * @param packageName if null default package is searched
+	 * @param className can't be null
 	 */
 	public IProgramElement findElementForType(String packageName, String typeName);
-		
+
 	/**
-	 * @param		sourceFilePath	modified to '/' delimited path for consistency
-	 * @return		a new structure node for the file if it was not found in the model
+	 * @param sourceFilePath modified to '/' delimited path for consistency
+	 * @return a new structure node for the file if it was not found in the model
 	 */
 	public IProgramElement findElementForSourceFile(String sourceFile);
-	
+
 	/**
 	 * TODO: discriminate columns
 	 */
 	public IProgramElement findElementForSourceLine(ISourceLocation location);
-	
+
 	/**
-	 * Never returns null 
+	 * Never returns null
 	 * 
-	 * @param		sourceFilePath	canonicalized path for consistency
-	 * @param 		lineNumber		if 0 or 1 the corresponding file node will be returned
-	 * @return		a new structure node for the file if it was not found in the model
+	 * @param sourceFilePath canonicalized path for consistency
+	 * @param lineNumber if 0 or 1 the corresponding file node will be returned
+	 * @return a new structure node for the file if it was not found in the model
 	 */
 	public IProgramElement findElementForSourceLine(String sourceFilePath, int lineNumber);
+
 	public IProgramElement findElementForOffSet(String sourceFilePath, int lineNumber, int offSet);
-	
+
 	public String getConfigFile();
-	
+
 	public void setConfigFile(String configFile);
 
 	public void flushTypeMap();
@@ -195,6 +195,8 @@ public interface IProgramElement extends Serializable {
 
 	public IProgramElement walk(HierarchyWalker walker);
 
+	public AsmManager getModel();
+
 	/**
 	 * Uses "typesafe enum" pattern.
 	 */
@@ -36,17 +36,26 @@ public class AspectJElementHierarchy implements IHierarchy {
 
 	private static final long serialVersionUID = 6462734311117048620L;
 
+	private transient AsmManager asm;
 	protected IProgramElement root = null;
 	protected String configFile = null;
 
 	private Map fileMap = null;
-	private Map handleMap = null;
+	private Map handleMap = new HashMap();
 	private Map typeMap = null;
 
+	public AspectJElementHierarchy(AsmManager asm) {
+		this.asm = asm;
+	}
+
 	public IProgramElement getElement(String handle) {
 		return findElementForHandleOrCreate(handle, false);
 	}
 
+	public void setAsmManager(AsmManager asm) { // used when deserializing
+		this.asm = asm;
+	}
+
 	public IProgramElement getRoot() {
 		return root;
 	}
@@ -281,7 +290,7 @@ public class AspectJElementHierarchy implements IHierarchy {
 			if (!isValid() || sourceFile == null) {
 				return IHierarchy.NO_STRUCTURE;
 			} else {
-				String correctedPath = AsmManager.getDefault().getCanonicalFilePath(new File(sourceFile));
+				String correctedPath = asm.getCanonicalFilePath(new File(sourceFile));
 				// StructureNode node = (StructureNode)getFileMap().get(correctedPath);//findFileNode(filePath, model);
 				IProgramElement node = (IProgramElement) findInFileMap(correctedPath);// findFileNode(filePath, model);
 				if (node != null) {
@@ -300,8 +309,7 @@ public class AspectJElementHierarchy implements IHierarchy {
 	 */
 	public IProgramElement findElementForSourceLine(ISourceLocation location) {
 		try {
-			return findElementForSourceLine(AsmManager.getDefault().getCanonicalFilePath(location.getSourceFile()), location
-					.getLine());
+			return findElementForSourceLine(asm.getCanonicalFilePath(location.getSourceFile()), location.getLine());
 		} catch (Exception e) {
 			return null;
 		}
@@ -315,7 +323,7 @@ public class AspectJElementHierarchy implements IHierarchy {
 	 * @return a new structure node for the file if it was not found in the model
 	 */
 	public IProgramElement findElementForSourceLine(String sourceFilePath, int lineNumber) {
-		String canonicalSFP = AsmManager.getDefault().getCanonicalFilePath(new File(sourceFilePath));
+		String canonicalSFP = asm.getCanonicalFilePath(new File(sourceFilePath));
 		IProgramElement node = findNodeForSourceLineHelper(root, canonicalSFP, lineNumber, -1);
 		if (node != null) {
 			return node;
@@ -325,7 +333,7 @@ public class AspectJElementHierarchy implements IHierarchy {
 	}
 
 	public IProgramElement findElementForOffSet(String sourceFilePath, int lineNumber, int offSet) {
-		String canonicalSFP = AsmManager.getDefault().getCanonicalFilePath(new File(sourceFilePath));
+		String canonicalSFP = asm.getCanonicalFilePath(new File(sourceFilePath));
 		IProgramElement node = findNodeForSourceLineHelper(root, canonicalSFP, lineNumber, offSet);
 		if (node != null) {
 			return node;
@@ -348,7 +356,7 @@ public class AspectJElementHierarchy implements IHierarchy {
 			lastSlash = i;
 		}
 		String fileName = sourceFilePath.substring(lastSlash + 1);
-		IProgramElement fileNode = new ProgramElement(fileName, IProgramElement.Kind.FILE_JAVA, new SourceLocation(new File(
+		IProgramElement fileNode = new ProgramElement(asm, fileName, IProgramElement.Kind.FILE_JAVA, new SourceLocation(new File(
 				sourceFilePath), 1, 1), 0, null, null);
 		// fileNode.setSourceLocation();
 		fileNode.addChild(NO_STRUCTURE);
@@ -530,12 +538,12 @@ public class AspectJElementHierarchy implements IHierarchy {
 	}
 
 	private String getFilename(String hid) {
-		return AsmManager.getDefault().getHandleProvider().getFileForHandle(hid);
+		return asm.getHandleProvider().getFileForHandle(hid);
 	}
 
 	private String getCanonicalFilePath(IProgramElement ipe) {
 		if (ipe.getSourceLocation() != null) {
-			return AsmManager.getDefault().getCanonicalFilePath(ipe.getSourceLocation().getSourceFile());
+			return asm.getCanonicalFilePath(ipe.getSourceLocation().getSourceFile());
 		}
 		return "";
 	}
@@ -1,101 +0,0 @@
-/* *******************************************************************
- * Copyright (c) 2003 Contributors.
- * All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://www.eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: 
- *     Mik Kersten     initial implementation 
- * ******************************************************************/
-
-package org.aspectj.asm.internal;
-
-import java.io.File;
-import java.util.StringTokenizer;
-
-import org.aspectj.asm.AsmManager;
-import org.aspectj.asm.IElementHandleProvider;
-import org.aspectj.asm.IProgramElement;
-import org.aspectj.bridge.ISourceLocation;
-
-/**
- * HandleProvider of the form '<full path to src file>|line|column|offset'
- * 
- * @author Mik Kersten
- */
-public class FullPathHandleProvider implements IElementHandleProvider {
-
-    static final String ID_DELIM = "|";
-    
-    public String createHandleIdentifier(ISourceLocation location) {
-        StringBuffer sb = new StringBuffer();
-        sb.append(AsmManager.getDefault()
-                            .getCanonicalFilePath(location.getSourceFile()));
-        sb.append(ID_DELIM);
-        sb.append(location.getLine());
-        sb.append(ID_DELIM);
-        sb.append(location.getColumn());
-        sb.append(ID_DELIM);
-        sb.append(location.getOffset());
-        return sb.toString();
-    }
-    
-    public String createHandleIdentifier(File sourceFile, int line,int column,int offset) {
-        StringBuffer sb = new StringBuffer();
-        sb.append(AsmManager.getDefault().getCanonicalFilePath(sourceFile));
-        sb.append(ID_DELIM);
-        sb.append(line);
-        sb.append(ID_DELIM);
-        sb.append(column);
-        sb.append(ID_DELIM);
-        sb.append(offset);
-        return sb.toString();       
-    }
-
-    public String getFileForHandle(String handle) {
-        StringTokenizer st = new StringTokenizer(handle, ID_DELIM);
-        String file = st.nextToken();
-        return file;
-    }
-
-    public int getLineNumberForHandle(String handle) {
-        StringTokenizer st = new StringTokenizer(handle, ID_DELIM);
-        st.nextToken(); // skip over the file
-        return new Integer(st.nextToken()).intValue();
-    }
-
-	public int getOffSetForHandle(String handle) {
-		StringTokenizer st = new StringTokenizer(handle, ID_DELIM);
-        st.nextToken(); // skip over the file
-        st.nextToken(); // skip over the line number
-        st.nextToken(); // skip over the column
-        return new Integer(st.nextToken()).intValue();
-	}
-
-	public String createHandleIdentifier(IProgramElement ipe) {
-		if (ipe == null) return null;
-		if (ipe.getHandleIdentifier(false) != null) {
-			return ipe.getHandleIdentifier(false);
-		}
-		String handle = null;  
-		if (ipe.getSourceLocation() != null) {
-			handle = createHandleIdentifier(ipe.getSourceLocation());
-		} else {
-			handle = createHandleIdentifier(ISourceLocation.NO_FILE,-1,-1,-1);
-		}
-		ipe.setHandleIdentifier(handle);
-		return handle;
-	}
-
-	public boolean dependsOnLocation() {
-		// handles contain information from the source location therefore 
-		// return true;
-		return true;
-	}
-
-	public void initialize() {
-		// nothing to initialize...
-	}
-}
@@ -29,6 +29,8 @@ import org.aspectj.bridge.ISourceLocation;
  */
 public class JDTLikeHandleProvider implements IElementHandleProvider {
 
+	private final AsmManager asm;
+
 	// Need to keep our own count of the number of initializers
 	// because this information cannot be gained from the ipe.
 	private int initializerCounter = 0;
@@ -39,6 +41,10 @@ public class JDTLikeHandleProvider implements IElementHandleProvider {
 	private final String backslash = "\\";
 	private final String emptyString = "";
 
+	public JDTLikeHandleProvider(AsmManager asm) {
+		this.asm = asm;
+	}
+
 	public String createHandleIdentifier(IProgramElement ipe) {
 
 		// AjBuildManager.setupModel --> top of the tree is either
@@ -50,7 +56,7 @@ public class JDTLikeHandleProvider implements IElementHandleProvider {
 			// therefore just return it
 			return ipe.getHandleIdentifier();
 		} else if (ipe.getKind().equals(IProgramElement.Kind.FILE_LST)) {
-			String configFile = AsmManager.getDefault().getHierarchy().getConfigFile();
+			String configFile = asm.getHierarchy().getConfigFile();
 			int start = configFile.lastIndexOf(File.separator);
 			int end = configFile.lastIndexOf(".lst");
 			if (end != -1) {
@@ -242,9 +248,9 @@ public class JDTLikeHandleProvider implements IElementHandleProvider {
 	}
 
 	public String getFileForHandle(String handle) {
-		IProgramElement node = AsmManager.getDefault().getHierarchy().getElement(handle);
+		IProgramElement node = asm.getHierarchy().getElement(handle);
 		if (node != null) {
-			return AsmManager.getDefault().getCanonicalFilePath(node.getSourceLocation().getSourceFile());
+			return asm.getCanonicalFilePath(node.getSourceLocation().getSourceFile());
 		} else if (handle.charAt(0) == HandleProviderDelimiter.ASPECT_CU.getDelimiter()
 				|| handle.charAt(0) == HandleProviderDelimiter.COMPILATIONUNIT.getDelimiter()) {
 			// it's something like *MyAspect.aj or {MyClass.java. In other words
@@ -256,7 +262,7 @@ public class JDTLikeHandleProvider implements IElementHandleProvider {
 	}
 
 	public int getLineNumberForHandle(String handle) {
-		IProgramElement node = AsmManager.getDefault().getHierarchy().getElement(handle);
+		IProgramElement node = asm.getHierarchy().getElement(handle);
 		if (node != null) {
 			return node.getSourceLocation().getLine();
 		} else if (handle.charAt(0) == HandleProviderDelimiter.ASPECT_CU.getDelimiter()
@@ -270,7 +276,7 @@ public class JDTLikeHandleProvider implements IElementHandleProvider {
 	}
 
 	public int getOffSetForHandle(String handle) {
-		IProgramElement node = AsmManager.getDefault().getHierarchy().getElement(handle);
+		IProgramElement node = asm.getHierarchy().getElement(handle);
 		if (node != null) {
 			return node.getSourceLocation().getOffset();
 		} else if (handle.charAt(0) == HandleProviderDelimiter.ASPECT_CU.getDelimiter()
@@ -284,7 +290,7 @@ public class JDTLikeHandleProvider implements IElementHandleProvider {
 	}
 
 	public String createHandleIdentifier(ISourceLocation location) {
-		IProgramElement node = AsmManager.getDefault().getHierarchy().findElementForSourceLine(location);
+		IProgramElement node = asm.getHierarchy().findElementForSourceLine(location);
 		if (node != null) {
 			return createHandleIdentifier(node);
 		}
@@ -292,8 +298,7 @@ public class JDTLikeHandleProvider implements IElementHandleProvider {
 	}
 
 	public String createHandleIdentifier(File sourceFile, int line, int column, int offset) {
-		IProgramElement node = AsmManager.getDefault().getHierarchy().findElementForOffSet(sourceFile.getAbsolutePath(), line,
-				offset);
+		IProgramElement node = asm.getHierarchy().findElementForOffSet(sourceFile.getAbsolutePath(), line, offset);
 		if (node != null) {
 			return createHandleIdentifier(node);
 		}
@@ -31,6 +31,7 @@ import org.aspectj.bridge.ISourceLocation;
  */
 public class ProgramElement implements IProgramElement {
 
+	public transient AsmManager asm; // which structure model is this node part of
 	private static final long serialVersionUID = 171673495267384449L;
 	public static boolean shortITDNames = true;
 
@@ -60,21 +61,30 @@ public class ProgramElement implements IProgramElement {
 
 	// --- ctors
 
+	public AsmManager getModel() {
+		return asm;
+	}
+
 	/** Used during de-externalization */
 	public ProgramElement() {
+		int stop = 1;
 	}
 
 	/** Use to create program element nodes that do not correspond to source locations */
-	public ProgramElement(String name, Kind kind, List children) {
+	public ProgramElement(AsmManager asm, String name, Kind kind, List children) {
+		this.asm = asm;
+		if (asm == null && !name.equals("<build to view structure>")) {
+			throw new RuntimeException();
+		}
 		this.name = name;
 		this.kind = kind;
 		if (children != null)
 			setChildren(children);
 	}
 
-	public ProgramElement(String name, IProgramElement.Kind kind, ISourceLocation sourceLocation, int modifiers, String comment,
-			List children) {
-		this(name, kind, children);
+	public ProgramElement(AsmManager asm, String name, IProgramElement.Kind kind, ISourceLocation sourceLocation, int modifiers,
+			String comment, List children) {
+		this(asm, name, kind, children);
 		this.sourceLocation = sourceLocation;
 		setFormalComment(comment);
 		// if (comment!=null && comment.length()>0) formalComment = comment;
@@ -525,7 +535,11 @@ public class ProgramElement implements IProgramElement {
 
 	public String getHandleIdentifier(boolean create) {
 		if (null == handle && create) {
-			handle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(this);
+			if (asm == null && name.equals("<build to view structure>")) {
+				handle = "<build to view structure>";
+			} else {
+				handle = asm.getHandleProvider().createHandleIdentifier(this);
+			}
 		}
 		return handle;
 	}
@@ -12,6 +12,7 @@ package org.aspectj.ajde.core;
 
 import org.aspectj.ajde.core.internal.AjdeCoreBuildManager;
 import org.aspectj.ajdt.internal.core.builder.IncrementalStateManager;
+import org.aspectj.asm.AsmManager;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.Message;
 import org.aspectj.org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
@@ -148,4 +149,12 @@ public class AjCompiler {
 	public Object getCustomMungerFactory() {
 		return buildManager.getCustomMungerFactory();
 	}
+
+	public AsmManager getModel() {
+		return buildManager.getStructureModel();
+	}
+
+	// public AsmManager getStructureModel() {
+	// return buildManager.getStructureModel();
+	// }
 }
@@ -63,6 +63,10 @@ public class AjdeCoreBuildManager {
 		AsmManager.attemptIncrementalModelRepairs = true;
 	}
 
+	// public AsmManager getStructureModel() {
+	// return ajBuildManager.
+	// }
+
 	/**
 	 * Execute a full or incremental build
 	 * 
@@ -77,8 +81,9 @@ public class AjdeCoreBuildManager {
 				// No existing state so we must do a full build
 				fullBuild = true;
 			} else {
-				AsmManager.getDefault().setRelationshipMap(existingState.getRelationshipMap());
-				AsmManager.getDefault().setHierarchy(existingState.getStructureModel());
+				AsmManager.setLastActiveStructureModel(existingState.getStructureModel());
+				// AsmManager.getDefault().setRelationshipMap(existingState.getRelationshipMap());
+				// AsmManager.getDefault().setHierarchy(existingState.getStructureModel());
 			}
 		}
 		try {
@@ -394,4 +399,8 @@ public class AjdeCoreBuildManager {
 	public void cleanupEnvironment() {
 		ajBuildManager.cleanupEnvironment();
 	}
+
+	public AsmManager getStructureModel() {
+		return ajBuildManager.getStructureModel();
+	}
 }
@@ -19,104 +19,98 @@ import java.util.List;
 import junit.framework.AssertionFailedError;
 import junit.framework.TestCase;
 
-import org.aspectj.asm.AsmManager;
 import org.aspectj.tools.ajc.Ajc;
 
 /**
- * Testcase class to be used by all ajde.core tests. Provides
- * helper methods to set up the environment in a sandbox
- * as well as to drive a build.
+ * Testcase class to be used by all ajde.core tests. Provides helper methods to set up the environment in a sandbox as well as to
+ * drive a build.
  */
 public class AjdeCoreTestCase extends TestCase {
 
-    public final static String testdataSrcDir = "../ajde.core/testdata";
+	public final static String testdataSrcDir = "../ajde.core/testdata";
 	protected static File sandboxDir;
-	
+
 	private String projectDir;
-    private AjCompiler compiler;
+	private AjCompiler compiler;
 
-    
 	protected void setUp() throws Exception {
 		super.setUp();
 		// Create a sandbox in which to work
 		sandboxDir = Ajc.createEmptySandbox();
-		// AMC - added this next line as a temporary workaround for 
+		// AMC - added this next line as a temporary workaround for
 		// listener leakage in AsmManager induced by the Ajde test suite.
-		AsmManager.getDefault().removeAllListeners();
+		// AsmManager.getDefault().removeAllListeners();
 	}
-	
+
 	protected void tearDown() throws Exception {
 		super.tearDown();
 		compiler.clearLastState();
 		compiler = null;
 	}
-	
+
 	/**
-	 * Fill in the working directory with the project files and
-	 * creates a compiler instance for this project
+	 * Fill in the working directory with the project files and creates a compiler instance for this project
 	 */
 	public void initialiseProject(String projectName) throws IOException {
-		File projectSrc=new File(testdataSrcDir + File.separatorChar + projectName);
-		File destination=new File(getWorkingDir(),projectName);
-		if (!destination.exists()) {destination.mkdir();}
-		copy(projectSrc,destination);
-		projectDir = destination.getCanonicalPath();//getAbsolutePath();
-		
-		compiler = new AjCompiler(
-				projectDir,
-				new TestCompilerConfiguration(projectDir),
-				new TestBuildProgressMonitor(),
-				new TestMessageHandler()); 
+		File projectSrc = new File(testdataSrcDir + File.separatorChar + projectName);
+		File destination = new File(getWorkingDir(), projectName);
+		if (!destination.exists()) {
+			destination.mkdir();
+		}
+		copy(projectSrc, destination);
+		projectDir = destination.getCanonicalPath();// getAbsolutePath();
+
+		compiler = new AjCompiler(projectDir, new TestCompilerConfiguration(projectDir), new TestBuildProgressMonitor(),
+				new TestMessageHandler());
 	}
-	
+
 	/**
 	 * @return the working directory
 	 */
-	protected File getWorkingDir() { 
-		return sandboxDir; 
+	protected File getWorkingDir() {
+		return sandboxDir;
 	}
-	
+
 	/**
-	 * @return the absolute path of the project directory
-	 * for example c:\temp\ajcSandbox\ajcTest15200.tmp\myProject
+	 * @return the absolute path of the project directory for example c:\temp\ajcSandbox\ajcTest15200.tmp\myProject
 	 */
 	protected String getAbsoluteProjectDir() {
 		return projectDir;
 	}
-	
+
 	/**
-	 * Copy the contents of some directory to another location - the
-	 * copy is recursive.
+	 * Copy the contents of some directory to another location - the copy is recursive.
 	 */
 	private void copy(File from, File to) {
 		String contents[] = from.list();
-		if (contents==null) return;
+		if (contents == null)
+			return;
 		for (int i = 0; i < contents.length; i++) {
 			String string = contents[i];
-			File f = new File(from,string);
-			File t = new File(to,string);
-			
+			File f = new File(from, string);
+			File t = new File(to, string);
+
 			if (f.isDirectory()) {
 				t.mkdir();
-				copy(f,t);
+				copy(f, t);
 			} else if (f.isFile()) {
 				try {
-					org.aspectj.util.FileUtil.copyFile(f,t);
+					org.aspectj.util.FileUtil.copyFile(f, t);
 				} catch (IOException e) {
 					throw new AssertionFailedError("Unable to copy " + f + " to " + t);
 				}
-			} 
+			}
 		}
 	}
-	
+
 	protected File openFile(String path) {
 		return new File(projectDir + File.separatorChar + path);
 	}
-	
+
 	public void doBuild() {
 		doBuild(true);
 	}
-	
+
 	public void doBuild(boolean buildFresh) {
 		if (buildFresh) {
 			compiler.buildFresh();
@@ -124,29 +118,29 @@ public class AjdeCoreTestCase extends TestCase {
 			compiler.build();
 		}
 	}
-	
+
 	public AjCompiler getCompiler() {
 		return compiler;
 	}
-	
+
 	public boolean checkFor(String what) {
-		List ll = ((TestMessageHandler)compiler.getMessageHandler()).getMessages();
+		List ll = ((TestMessageHandler) compiler.getMessageHandler()).getMessages();
 		for (Iterator iter = ll.iterator(); iter.hasNext();) {
-			Object element =  iter.next();
+			Object element = iter.next();
 			if (element.toString().indexOf(what) != -1)
 				return true;
 		}
 		return false;
 	}
-	
+
 	public void dumpTaskData() {
-		List ll = ((TestMessageHandler)compiler.getMessageHandler()).getMessages();
+		List ll = ((TestMessageHandler) compiler.getMessageHandler()).getMessages();
 		for (Iterator iter = ll.iterator(); iter.hasNext();) {
-			Object element =  iter.next();
-			System.out.println("RecordedMessage>"+element);
+			Object element = iter.next();
+			System.out.println("RecordedMessage>" + element);
 		}
 	}
-	
+
 	public List getSourceFileList(String[] files) {
 		List sourceFiles = new ArrayList();
 		for (int i = 0; i < files.length; i++) {
@@ -154,5 +148,5 @@ public class AjdeCoreTestCase extends TestCase {
 		}
 		return sourceFiles;
 	}
-	
+
 }
@@ -19,6 +19,7 @@ import org.aspectj.asm.IProgramElement;
 
 public class AsmDeclarationsTests extends AjdeCoreTestCase {
 
+	private AsmManager manager = null;
 	private IHierarchy model = null;
 
 	private final String[] files = new String[] { "ModelCoverage.java", "pkg" + File.separator + "InPackage.java" };
@@ -31,7 +32,8 @@ public class AsmDeclarationsTests extends AjdeCoreTestCase {
 		compilerConfig = (TestCompilerConfiguration) getCompiler().getCompilerConfiguration();
 		compilerConfig.setProjectSourceFiles(getSourceFileList(files));
 		doBuild();
-		model = AsmManager.getDefault().getHierarchy();
+		manager = AsmManager.lastActiveStructureModel;
+		model = AsmManager.lastActiveStructureModel.getHierarchy();
 	}
 
 	protected void tearDown() throws Exception {
@@ -47,7 +49,7 @@ public class AsmDeclarationsTests extends AjdeCoreTestCase {
 	}
 
 	public void testAspectAccessibility() {
-		IProgramElement packageAspect = AsmManager.getDefault().getHierarchy().findElementForType(null, "AdviceNamingCoverage");
+		IProgramElement packageAspect = model.findElementForType(null, "AdviceNamingCoverage");
 		assertNotNull(packageAspect);
 		assertEquals(IProgramElement.Accessibility.PACKAGE, packageAspect.getAccessibility());
 		assertEquals("aspect should not have public in it's signature", "aspect AdviceNamingCoverage", packageAspect
@@ -55,7 +57,7 @@ public class AsmDeclarationsTests extends AjdeCoreTestCase {
 	}
 
 	public void testStaticModifiers() {
-		IProgramElement aspect = AsmManager.getDefault().getHierarchy().findElementForType(null, "ModifiersCoverage");
+		IProgramElement aspect = model.findElementForType(null, "ModifiersCoverage");
 		assertNotNull(aspect);
 
 		IProgramElement staticA = model.findElementForSignature(aspect, IProgramElement.Kind.FIELD, "staticA");
@@ -64,7 +66,6 @@ public class AsmDeclarationsTests extends AjdeCoreTestCase {
 		IProgramElement finalA = model.findElementForSignature(aspect, IProgramElement.Kind.FIELD, "finalA");
 		assertTrue(!finalA.getModifiers().contains(IProgramElement.Modifiers.STATIC));
 		assertTrue(finalA.getModifiers().contains(IProgramElement.Modifiers.FINAL));
-
 	}
 
 	public void testFileInPackageAndDefaultPackage() {
@@ -81,7 +82,7 @@ public class AsmDeclarationsTests extends AjdeCoreTestCase {
 		IProgramElement node = model.getRoot();
 		assertNotNull(node);
 
-		IProgramElement aspect = AsmManager.getDefault().getHierarchy().findElementForType(null, "DeclareCoverage");
+		IProgramElement aspect = model.findElementForType(null, "DeclareCoverage");
 		assertNotNull(aspect);
 
 		String label = "declare error: \"Illegal construct..\"";
@@ -123,7 +124,7 @@ public class AsmDeclarationsTests extends AjdeCoreTestCase {
 		IProgramElement node = model.getRoot();
 		assertNotNull(node);
 
-		IProgramElement aspect = AsmManager.getDefault().getHierarchy().findElementForType(null, "InterTypeDecCoverage");
+		IProgramElement aspect = model.findElementForType(null, "InterTypeDecCoverage");
 		assertNotNull(aspect);
 
 		String fieldMsg = "Point.xxx";
@@ -148,7 +149,7 @@ public class AsmDeclarationsTests extends AjdeCoreTestCase {
 		IProgramElement node = model.getRoot();
 		assertNotNull(node);
 
-		IProgramElement aspect = AsmManager.getDefault().getHierarchy().findElementForType(null, "AdviceNamingCoverage");
+		IProgramElement aspect = model.findElementForType(null, "AdviceNamingCoverage");
 		assertNotNull(aspect);
 
 		String ptct = "named()";
@@ -166,7 +167,7 @@ public class AsmDeclarationsTests extends AjdeCoreTestCase {
 		IProgramElement node = model.getRoot();
 		assertNotNull(node);
 
-		IProgramElement aspect = AsmManager.getDefault().getHierarchy().findElementForType(null, "AbstractAspect");
+		IProgramElement aspect = model.findElementForType(null, "AbstractAspect");
 		assertNotNull(aspect);
 
 		String abst = "abPtct()";
@@ -179,7 +180,7 @@ public class AsmDeclarationsTests extends AjdeCoreTestCase {
 		IProgramElement node = model.getRoot();
 		assertNotNull(node);
 
-		IProgramElement aspect = AsmManager.getDefault().getHierarchy().findElementForType(null, "AdviceNamingCoverage");
+		IProgramElement aspect = model.findElementForType(null, "AdviceNamingCoverage");
 		assertNotNull(aspect);
 
 		String anon = "before(): <anonymous pointcut>";
@@ -16,7 +16,6 @@ import java.util.List;
 
 import org.aspectj.ajde.core.AjdeCoreTestCase;
 import org.aspectj.ajde.core.TestCompilerConfiguration;
-import org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder;
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.asm.IRelationship;
@@ -25,21 +24,17 @@ public class AsmRelationshipsTests extends AjdeCoreTestCase {
 
 	private AsmManager manager = null;
 
-	private String[] files = new String[]{
-			"ModelCoverage.java",
-			"pkg" + File.separator + "InPackage.java"
-	};
-	
+	private final String[] files = new String[] { "ModelCoverage.java", "pkg" + File.separator + "InPackage.java" };
+
 	private TestCompilerConfiguration compilerConfig;
 
 	protected void setUp() throws Exception {
 		super.setUp();
 		initialiseProject("coverage");
-		compilerConfig = (TestCompilerConfiguration) getCompiler()
-				.getCompilerConfiguration();
+		compilerConfig = (TestCompilerConfiguration) getCompiler().getCompilerConfiguration();
 		compilerConfig.setProjectSourceFiles(getSourceFileList(files));
 		doBuild();
-		manager = AsmManager.getDefault();
+		manager = AsmManager.lastActiveStructureModel;
 	}
 
 	protected void tearDown() throws Exception {
@@ -47,155 +42,152 @@ public class AsmRelationshipsTests extends AjdeCoreTestCase {
 		compilerConfig = null;
 		manager = null;
 	}
-	
-	// see pr148027
-	public void testUsesPointcut() {
-		if (!AsmHierarchyBuilder.shouldAddUsesPointcut) return;
-		
-	    IProgramElement ptUsage = AsmManager.getDefault().getHierarchy().findElementForType(null, "PointcutUsage");
-	    assertNotNull(ptUsage);
-	    IProgramElement pts = AsmManager.getDefault().getHierarchy().findElementForType(null, "Pointcuts");
-	    assertNotNull(pts);
-	    
-		IProgramElement pUsesA = manager.getHierarchy().findElementForLabel(
-		        ptUsage, 
-				IProgramElement.Kind.POINTCUT, 
-				"usesA()"/*Point"*/);
-		assertNotNull(pUsesA);
-
-		IProgramElement ptsA = manager.getHierarchy().findElementForLabel(
-		        pts, 
-				IProgramElement.Kind.POINTCUT, 
-				"a()"/*Point"*/);
-		assertNotNull(ptsA);
-		
-		assertTrue(AsmManager.getDefault().getRelationshipMap().get(pUsesA).size()>0);
-		assertTrue(AsmManager.getDefault().getRelationshipMap().get(ptsA).size()>0);
-	}
-	
-	public void testDeclareParents() {		
-		IProgramElement aspect = AsmManager.getDefault().getHierarchy().findElementForType(null, "DeclareCoverage");
-
-		IProgramElement dp = manager.getHierarchy().findElementForLabel(
-				aspect, 
-				IProgramElement.Kind.DECLARE_PARENTS, 
-				"declare parents: implements Serializable"/*Point"*/);
-		
+
+	// // see pr148027
+	// public void testUsesPointcut() {
+	// if (!AsmHierarchyBuilder.shouldAddUsesPointcut) return;
+	//		
+	// IProgramElement ptUsage = AsmManager.getDefault().getHierarchy().findElementForType(null, "PointcutUsage");
+	// assertNotNull(ptUsage);
+	// IProgramElement pts = AsmManager.getDefault().getHierarchy().findElementForType(null, "Pointcuts");
+	// assertNotNull(pts);
+	//	    
+	// IProgramElement pUsesA = manager.getHierarchy().findElementForLabel(
+	// ptUsage,
+	// IProgramElement.Kind.POINTCUT,
+	// "usesA()"/*Point"*/);
+	// assertNotNull(pUsesA);
+	//
+	// IProgramElement ptsA = manager.getHierarchy().findElementForLabel(
+	// pts,
+	// IProgramElement.Kind.POINTCUT,
+	// "a()"/*Point"*/);
+	// assertNotNull(ptsA);
+	//		
+	// assertTrue(AsmManager.getDefault().getRelationshipMap().get(pUsesA).size()>0);
+	// assertTrue(AsmManager.getDefault().getRelationshipMap().get(ptsA).size()>0);
+	// }
+
+	public void testDeclareParents() {
+		IProgramElement aspect = manager.getHierarchy().findElementForType(null, "DeclareCoverage");
+
+		IProgramElement dp = manager.getHierarchy().findElementForLabel(aspect, IProgramElement.Kind.DECLARE_PARENTS,
+				"declare parents: implements Serializable"/* Point" */);
+
 		assertNotNull(dp);
-		/*List relations = */manager.getRelationshipMap().get(dp);
-				
-		List rels = AsmManager.getDefault().getRelationshipMap().get(dp);
-		assertTrue(rels.size()>0);
-		
-//		assertTrue(rel.getTargets().size() > 0);
-//		
-//		checkDeclareMapping("DeclareCoverage", "Point", , 
-//			"Point", "matched by", "matches declare", 
-//			IProgramElement.Kind.DECLARE_PARENTS);		
+		/* List relations = */manager.getRelationshipMap().get(dp);
+
+		List rels = manager.getRelationshipMap().get(dp);
+		assertTrue(rels.size() > 0);
+
+		// assertTrue(rel.getTargets().size() > 0);
+		//		
+		// checkDeclareMapping("DeclareCoverage", "Point", ,
+		// "Point", "matched by", "matches declare",
+		// IProgramElement.Kind.DECLARE_PARENTS);
 	}
-	
-	public void testDeclareWarningAndError() {		
-		checkDeclareMapping("DeclareCoverage", "Point", "declare warning: \"Illegal call.\"", 
-			"method-call(void Point.setX(int))", "matched by", "matches declare", IProgramElement.Kind.DECLARE_WARNING);		
+
+	public void testDeclareWarningAndError() {
+		checkDeclareMapping("DeclareCoverage", "Point", "declare warning: \"Illegal call.\"", "method-call(void Point.setX(int))",
+				"matched by", "matches declare", IProgramElement.Kind.DECLARE_WARNING);
 	}
-	
-	public void testInterTypeDeclarations() {		
-		checkInterTypeMapping("InterTypeDecCoverage", "Point", "Point.xxx", "Point", 
-			"declared on", "aspect declarations", IProgramElement.Kind.INTER_TYPE_FIELD);	
-		checkInterTypeMapping("InterTypeDecCoverage", "Point", "Point.check(int,Line)", 
-			"Point", "declared on", "aspect declarations", IProgramElement.Kind.INTER_TYPE_METHOD);	
+
+	public void testInterTypeDeclarations() {
+		checkInterTypeMapping("InterTypeDecCoverage", "Point", "Point.xxx", "Point", "declared on", "aspect declarations",
+				IProgramElement.Kind.INTER_TYPE_FIELD);
+		checkInterTypeMapping("InterTypeDecCoverage", "Point", "Point.check(int,Line)", "Point", "declared on",
+				"aspect declarations", IProgramElement.Kind.INTER_TYPE_METHOD);
 	}
 
-	public void testAdvice() {	
-		checkMapping("AdvisesRelationshipCoverage", "Point", "before(): methodExecutionP..", 
-			"setX(int)", "advises", "advised by");
-		checkUniDirectionalMapping("AdvisesRelationshipCoverage", "Point", "before(): getP..", 
-			"field-get(int Point.x)", "advises");
-		checkUniDirectionalMapping("AdvisesRelationshipCoverage", "Point", "before(): setP..", 
-			"field-set(int Point.x)", "advises");	
+	public void testAdvice() {
+		checkMapping("AdvisesRelationshipCoverage", "Point", "before(): methodExecutionP..", "setX(int)", "advises", "advised by");
+		checkUniDirectionalMapping("AdvisesRelationshipCoverage", "Point", "before(): getP..", "field-get(int Point.x)", "advises");
+		checkUniDirectionalMapping("AdvisesRelationshipCoverage", "Point", "before(): setP..", "field-set(int Point.x)", "advises");
 	}
 
-	private void checkDeclareMapping(String fromType, String toType, String from, String to, 
-		String forwardRelName, String backRelName, IProgramElement.Kind kind) {
-		
-		IProgramElement aspect = AsmManager.getDefault().getHierarchy().findElementForType(null, fromType);
-		assertNotNull(aspect);		
+	private void checkDeclareMapping(String fromType, String toType, String from, String to, String forwardRelName,
+			String backRelName, IProgramElement.Kind kind) {
+
+		IProgramElement aspect = manager.getHierarchy().findElementForType(null, fromType);
+		assertNotNull(aspect);
 		String beforeExec = from;
 		IProgramElement beforeExecNode = manager.getHierarchy().findElementForLabel(aspect, kind, beforeExec);
 		assertNotNull(beforeExecNode);
 		IRelationship rel = manager.getRelationshipMap().get(beforeExecNode, IRelationship.Kind.DECLARE, forwardRelName);
 		assertTrue(rel.getTargets().size() > 0);
-		String handle = (String)rel.getTargets().get(0);
-		assertEquals(manager.getHierarchy().findElementForHandle(handle).toString(), to);  
+		String handle = (String) rel.getTargets().get(0);
+		assertEquals(manager.getHierarchy().findElementForHandle(handle).toString(), to);
 
-		IProgramElement clazz = AsmManager.getDefault().getHierarchy().findElementForType(null, toType);
+		IProgramElement clazz = manager.getHierarchy().findElementForType(null, toType);
 		assertNotNull(clazz);
 		String set = to;
 		IProgramElement setNode = manager.getHierarchy().findElementForLabel(clazz, IProgramElement.Kind.CODE, set);
 		assertNotNull(setNode);
 		IRelationship rel2 = manager.getRelationshipMap().get(setNode, IRelationship.Kind.DECLARE, backRelName);
-		String handle2 = (String)rel2.getTargets().get(0);
+		String handle2 = (String) rel2.getTargets().get(0);
 		assertEquals(manager.getHierarchy().findElementForHandle(handle2).toString(), from);
 	}
-	
-	private void checkUniDirectionalMapping(String fromType, String toType, String from, 
-		String to, String relName) {
-		
-		IProgramElement aspect = AsmManager.getDefault().getHierarchy().findElementForType(null, fromType);
-		assertNotNull(aspect);		
+
+	private void checkUniDirectionalMapping(String fromType, String toType, String from, String to, String relName) {
+
+		IProgramElement aspect = manager.getHierarchy().findElementForType(null, fromType);
+		assertNotNull(aspect);
 		String beforeExec = from;
-		IProgramElement beforeExecNode = manager.getHierarchy().findElementForLabel(aspect, IProgramElement.Kind.ADVICE, beforeExec);
+		IProgramElement beforeExecNode = manager.getHierarchy()
+				.findElementForLabel(aspect, IProgramElement.Kind.ADVICE, beforeExec);
 		assertNotNull(beforeExecNode);
 		IRelationship rel = manager.getRelationshipMap().get(beforeExecNode, IRelationship.Kind.ADVICE, relName);
-		for (Iterator it = rel.getTargets().iterator(); it.hasNext(); ) {
-			String currHandle = (String)it.next();
-			if (manager.getHierarchy().findElementForHandle(currHandle).toLabelString().equals(to)) return;
+		for (Iterator it = rel.getTargets().iterator(); it.hasNext();) {
+			String currHandle = (String) it.next();
+			if (manager.getHierarchy().findElementForHandle(currHandle).toLabelString().equals(to))
+				return;
 		}
 		fail(); // didn't find it
 	}
 
-	private void checkMapping(String fromType, String toType, String from, String to, 
-		String forwardRelName, String backRelName) {
-		
-		IProgramElement aspect = AsmManager.getDefault().getHierarchy().findElementForType(null, fromType);
-		assertNotNull(aspect);		
+	private void checkMapping(String fromType, String toType, String from, String to, String forwardRelName, String backRelName) {
+
+		IProgramElement aspect = manager.getHierarchy().findElementForType(null, fromType);
+		assertNotNull(aspect);
 		String beforeExec = from;
-		IProgramElement beforeExecNode = manager.getHierarchy().findElementForLabel(aspect, IProgramElement.Kind.ADVICE, beforeExec);
+		IProgramElement beforeExecNode = manager.getHierarchy()
+				.findElementForLabel(aspect, IProgramElement.Kind.ADVICE, beforeExec);
 		assertNotNull(beforeExecNode);
 		IRelationship rel = manager.getRelationshipMap().get(beforeExecNode, IRelationship.Kind.ADVICE, forwardRelName);
-		String handle = (String)rel.getTargets().get(0);
-		assertEquals(manager.getHierarchy().findElementForHandle(handle).toString(), to);  
+		String handle = (String) rel.getTargets().get(0);
+		assertEquals(manager.getHierarchy().findElementForHandle(handle).toString(), to);
 
-		IProgramElement clazz = AsmManager.getDefault().getHierarchy().findElementForType(null, toType);
+		IProgramElement clazz = manager.getHierarchy().findElementForType(null, toType);
 		assertNotNull(clazz);
 		String set = to;
 		IProgramElement setNode = manager.getHierarchy().findElementForLabel(clazz, IProgramElement.Kind.METHOD, set);
 		assertNotNull(setNode);
 		IRelationship rel2 = manager.getRelationshipMap().get(setNode, IRelationship.Kind.ADVICE, backRelName);
-		String handle2 = (String)rel2.getTargets().get(0);
+		String handle2 = (String) rel2.getTargets().get(0);
 		assertEquals(manager.getHierarchy().findElementForHandle(handle2).toString(), from);
 	}
 
-	private void checkInterTypeMapping(String fromType, String toType, String from, 
-		String to, String forwardRelName, String backRelName, IProgramElement.Kind declareKind) {
-		
-		IProgramElement aspect = AsmManager.getDefault().getHierarchy().findElementForType(null, fromType);
-		assertNotNull(aspect);		
+	private void checkInterTypeMapping(String fromType, String toType, String from, String to, String forwardRelName,
+			String backRelName, IProgramElement.Kind declareKind) {
+
+		IProgramElement aspect = manager.getHierarchy().findElementForType(null, fromType);
+		assertNotNull(aspect);
 		String beforeExec = from;
 		IProgramElement fromNode = manager.getHierarchy().findElementForLabel(aspect, declareKind, beforeExec);
 		assertNotNull(fromNode);
 		IRelationship rel = manager.getRelationshipMap().get(fromNode, IRelationship.Kind.DECLARE_INTER_TYPE, forwardRelName);
-		String handle = (String)rel.getTargets().get(0);
-		assertEquals(manager.getHierarchy().findElementForHandle(handle).toString(), to);  
+		String handle = (String) rel.getTargets().get(0);
+		assertEquals(manager.getHierarchy().findElementForHandle(handle).toString(), to);
 
-		IProgramElement clazz = AsmManager.getDefault().getHierarchy().findElementForType(null, toType);
+		IProgramElement clazz = manager.getHierarchy().findElementForType(null, toType);
 		assertNotNull(clazz);
-//		String set = to;
+		// String set = to;
 		IRelationship rel2 = manager.getRelationshipMap().get(clazz, IRelationship.Kind.DECLARE_INTER_TYPE, backRelName);
-//		String handle2 = (String)rel2.getTargets().get(0);
-		for (Iterator it = rel2.getTargets().iterator(); it.hasNext(); ) {
-			String currHandle = (String)it.next();
-			if (manager.getHierarchy().findElementForHandle(currHandle).toLabelString().equals(from)) return;
+		// String handle2 = (String)rel2.getTargets().get(0);
+		for (Iterator it = rel2.getTargets().iterator(); it.hasNext();) {
+			String currHandle = (String) it.next();
+			if (manager.getHierarchy().findElementForHandle(currHandle).toLabelString().equals(from))
+				return;
 		}
 		fail(); // didn't find it
 	}
@@ -26,11 +26,8 @@ import org.aspectj.asm.IProgramElement;
 
 public class SavedModelConsistencyTests extends AjdeCoreTestCase {
 
-	private String[] files = new String[]{
-			"ModelCoverage.java",
-			"pkg" + File.separator + "InPackage.java"
-	};
-	
+	private final String[] files = new String[] { "ModelCoverage.java", "pkg" + File.separator + "InPackage.java" };
+
 	private TestMessageHandler handler;
 	private TestCompilerConfiguration compilerConfig;
 
@@ -38,18 +35,16 @@ public class SavedModelConsistencyTests extends AjdeCoreTestCase {
 		super.setUp();
 		initialiseProject("coverage");
 		handler = (TestMessageHandler) getCompiler().getMessageHandler();
-		compilerConfig = (TestCompilerConfiguration) getCompiler()
-				.getCompilerConfiguration();
+		compilerConfig = (TestCompilerConfiguration) getCompiler().getCompilerConfiguration();
 		compilerConfig.setProjectSourceFiles(getSourceFileList(files));
 		// In order to get a model on the disk to read in, do a build with the right flag set !
 		try {
-			AsmManager.dumpModelPostBuild=true;
+			AsmManager.dumpModelPostBuild = true;
 			doBuild();
 		} finally {
-			AsmManager.dumpModelPostBuild=false;
+			AsmManager.dumpModelPostBuild = false;
 		}
-		assertTrue("Expected no compiler errors but found "
-				+ handler.getErrors(), handler.getErrors().isEmpty());
+		assertTrue("Expected no compiler errors but found " + handler.getErrors(), handler.getErrors().isEmpty());
 	}
 
 	protected void tearDown() throws Exception {
@@ -57,63 +52,61 @@ public class SavedModelConsistencyTests extends AjdeCoreTestCase {
 		handler = null;
 		compilerConfig = null;
 	}
-	
+
 	public void testInterfaceIsSameInBoth() {
-		AsmManager.getDefault().readStructureModel(getAbsoluteProjectDir());
-		
-        IHierarchy model = AsmManager.getDefault().getHierarchy();
-        assertTrue("model exists", model != null);
-        
-		assertTrue("root exists", model.getRoot() != null);        // TODO-path
+		AsmManager asm = AsmManager.createNewStructureModel();
+		asm.readStructureModel(getAbsoluteProjectDir());
+
+		IHierarchy model = asm.getHierarchy();
+		assertTrue("model exists", model != null);
+
+		assertTrue("root exists", model.getRoot() != null); // TODO-path
 		File testFile = openFile("ModelCoverage.java");
 		assertTrue("Expected " + testFile.getAbsolutePath() + " to exist, but it did not", testFile.exists());
-		
-		IProgramElement nodePreBuild = model.findElementForSourceLine(testFile.getAbsolutePath(), 5);	
-		
+
+		IProgramElement nodePreBuild = model.findElementForSourceLine(testFile.getAbsolutePath(), 5);
+
 		doBuild();
-		assertTrue("Expected no compiler errors but found "
-				+ handler.getErrors(), handler.getErrors().isEmpty());
-		
-		IProgramElement nodePostBuild = model.findElementForSourceLine(testFile.getAbsolutePath(), 5);	
-		
-		assertTrue("Nodes should be identical: Prebuild kind = "+nodePreBuild.getKind()+
-				   "   Postbuild kind = "+nodePostBuild.getKind(),
-				   nodePreBuild.getKind().equals(nodePostBuild.getKind()));
-		
+		assertTrue("Expected no compiler errors but found " + handler.getErrors(), handler.getErrors().isEmpty());
+
+		IProgramElement nodePostBuild = model.findElementForSourceLine(testFile.getAbsolutePath(), 5);
+
+		assertTrue("Nodes should be identical: Prebuild kind = " + nodePreBuild.getKind() + "   Postbuild kind = "
+				+ nodePostBuild.getKind(), nodePreBuild.getKind().equals(nodePostBuild.getKind()));
+
 	}
-	
+
 	public void testModelIsSamePreAndPostBuild() {
-		AsmManager.getDefault().readStructureModel(getAbsoluteProjectDir());
-        IHierarchy model = AsmManager.getDefault().getHierarchy();
-        assertTrue("model exists", model != null);
-	
-        final List preBuildKinds = new ArrayList();
+		AsmManager asm = AsmManager.createNewStructureModel();
+		asm.readStructureModel(getAbsoluteProjectDir());
+		// AsmManager.getDefault().readStructureModel(getAbsoluteProjectDir());
+		IHierarchy model = asm.getHierarchy();
+		assertTrue("model exists", model != null);
+
+		final List preBuildKinds = new ArrayList();
 		HierarchyWalker walker = new HierarchyWalker() {
-  		    public void preProcess(IProgramElement node) {
-  		    	preBuildKinds.add(node.getKind());
-  		    }
-  		};
-  		AsmManager.getDefault().getHierarchy().getRoot().walk(walker);
-		assertFalse("Expected there to be build kinds but didn't "
-				+ "find any", preBuildKinds.isEmpty());
-  		
+			public void preProcess(IProgramElement node) {
+				preBuildKinds.add(node.getKind());
+			}
+		};
+		asm.getHierarchy().getRoot().walk(walker);
+		assertFalse("Expected there to be build kinds but didn't " + "find any", preBuildKinds.isEmpty());
+
 		doBuild();
-		assertTrue("Expected no compiler errors but found "
-				+ handler.getErrors(), handler.getErrors().isEmpty());
-		
-        final List postBuildKinds = new ArrayList();
+		assertTrue("Expected no compiler errors but found " + handler.getErrors(), handler.getErrors().isEmpty());
+
+		final List postBuildKinds = new ArrayList();
 		HierarchyWalker walker2 = new HierarchyWalker() {
-  		    public void preProcess(IProgramElement node) {
-  		    	postBuildKinds.add(node.getKind());
-  		    }
-  		};
-  		AsmManager.getDefault().getHierarchy().getRoot().walk(walker2);	
-		assertFalse("Expected there to be build kinds but didn't "
-				+ "find any", preBuildKinds.isEmpty());
-
-		assertTrue("Lists should be the same: PRE"+preBuildKinds.toString()
-				+"  POST"+postBuildKinds.toString(),preBuildKinds.equals(postBuildKinds));
-		
+			public void preProcess(IProgramElement node) {
+				postBuildKinds.add(node.getKind());
+			}
+		};
+		asm.getHierarchy().getRoot().walk(walker2);
+		assertFalse("Expected there to be build kinds but didn't " + "find any", preBuildKinds.isEmpty());
+
+		assertTrue("Lists should be the same: PRE" + preBuildKinds.toString() + "  POST" + postBuildKinds.toString(), preBuildKinds
+				.equals(postBuildKinds));
+
 	}
-	
+
 }
@@ -28,27 +28,22 @@ public class StructureModelTests extends AjdeCoreTestCase {
 
 	private AsmManager manager = null;
 
-	private String[] files = new String[]{
-			"figures" + File.separator + "Debug.java",
-			"figures" + File.separator + "Figure.java",
-			"figures" + File.separator + "FigureElement.java",
-			"figures" + File.separator + "Main.java",
-			"figures" + File.separator + "composites" + File.separator + "Line.java",
+	private final String[] files = new String[] { "figures" + File.separator + "Debug.java",
+			"figures" + File.separator + "Figure.java", "figures" + File.separator + "FigureElement.java",
+			"figures" + File.separator + "Main.java", "figures" + File.separator + "composites" + File.separator + "Line.java",
 			"figures" + File.separator + "composites" + File.separator + "Square.java",
 			"figures" + File.separator + "primitives" + File.separator + "planar" + File.separator + "Point.java",
-			"figures" + File.separator + "primitives" + File.separator + "solid" + File.separator + "SolidPoint.java"
-	};
-	
+			"figures" + File.separator + "primitives" + File.separator + "solid" + File.separator + "SolidPoint.java" };
+
 	private TestCompilerConfiguration compilerConfig;
 
 	protected void setUp() throws Exception {
 		super.setUp();
 		initialiseProject("figures-coverage");
-		compilerConfig = (TestCompilerConfiguration) getCompiler()
-				.getCompilerConfiguration();
+		compilerConfig = (TestCompilerConfiguration) getCompiler().getCompilerConfiguration();
 		compilerConfig.setProjectSourceFiles(getSourceFileList(files));
 		doBuild();
-		manager = AsmManager.getDefault();
+		manager = AsmManager.lastActiveStructureModel;
 	}
 
 	protected void tearDown() throws Exception {
@@ -56,91 +51,90 @@ public class StructureModelTests extends AjdeCoreTestCase {
 		compilerConfig = null;
 		manager = null;
 	}
-	
+
 	public void testRootForSourceFile() throws IOException {
-		File testFile = openFile("figures" + File.separator + "Figure.java");	
-		IProgramElement node = manager.getHierarchy().findElementForSourceFile(
-			testFile.getAbsolutePath());
-		assertTrue("find result", node != null) ;	
-		String child = ((IProgramElement)node.getChildren().get(1)).getName();
-        assertTrue("expected Figure got child " + child, child.equals("Figure"));
+		File testFile = openFile("figures" + File.separator + "Figure.java");
+		IProgramElement node = manager.getHierarchy().findElementForSourceFile(testFile.getAbsolutePath());
+		assertTrue("find result", node != null);
+		String child = ((IProgramElement) node.getChildren().get(1)).getName();
+		assertTrue("expected Figure got child " + child, child.equals("Figure"));
 	}
 
 	public void testPointcutName() throws IOException {
-		File testFile = openFile("figures" + File.separator + "Main.java");	
-		IProgramElement node = manager.getHierarchy().findElementForSourceFile(
-			testFile.getAbsolutePath());
-		assertTrue("find result", node != null) ;	
-		IProgramElement pNode = (IProgramElement)(node).getChildren().get(2);
-		IProgramElement pointcut = (IProgramElement)pNode.getChildren().get(0);
+		File testFile = openFile("figures" + File.separator + "Main.java");
+		IProgramElement node = manager.getHierarchy().findElementForSourceFile(testFile.getAbsolutePath());
+		assertTrue("find result", node != null);
+		IProgramElement pNode = (IProgramElement) (node).getChildren().get(2);
+		IProgramElement pointcut = (IProgramElement) pNode.getChildren().get(0);
 		assertTrue("kind", pointcut.getKind().equals(IProgramElement.Kind.POINTCUT));
 		assertTrue("found node: " + pointcut.getName(), pointcut.toLabelString().equals("testptct()"));
 	}
 
 	public void testFileNodeFind() throws IOException {
 		File testFile = openFile("figures" + File.separator + "Main.java");
-		
-//		System.err.println(((IProgramElement)((IProgramElement)Ajde.getDefault().getStructureModelManager().getHierarchy().getRoot().getChildren().get(0)).getChildren().get(3)).getSourceLocation().getSourceFile().getAbsolutePath());
-//		System.err.println(testFile.getAbsolutePath());
-		
-		IProgramElement node = manager.getHierarchy().findElementForSourceLine(
-			testFile.getAbsolutePath(), 1);
-		assertTrue("find result", node != null) ;	
-		assertEquals("find result has children", 3, node.getChildren().size()) ;	
+
+		// System.err.println(((IProgramElement)((IProgramElement)Ajde.getDefault().getStructureModelManager().getHierarchy().getRoot().getChildren().get(0)).getChildren().get(3)).getSourceLocation().getSourceFile().getAbsolutePath());
+		// System.err.println(testFile.getAbsolutePath());
+
+		IProgramElement node = manager.getHierarchy().findElementForSourceLine(testFile.getAbsolutePath(), 1);
+		assertTrue("find result", node != null);
+		assertEquals("find result has children", 3, node.getChildren().size());
 		assertTrue("found node: " + node.getName(), node.getKind().equals(IProgramElement.Kind.FILE_JAVA));
 	}
-  
-  	/**
-  	 * @todo	add negative test to make sure things that aren't runnable aren't annotated
-  	 */ 
+
+	/**
+	 * @todo add negative test to make sure things that aren't runnable aren't annotated
+	 */
 	public void testMainClassNodeInfo() throws IOException {
-        IHierarchy model = manager.getHierarchy();
-        assertTrue("model exists", model != null);
+		IHierarchy model = manager.getHierarchy();
+		assertTrue("model exists", model != null);
 		assertTrue("root exists", model.getRoot() != null);
 		File testFile = openFile("figures" + File.separator + "Main.java");
-		IProgramElement node = model.findElementForSourceLine(testFile.getAbsolutePath(), 11);	
-		assertTrue("find result", node != null);	
+		IProgramElement node = model.findElementForSourceLine(testFile.getAbsolutePath(), 11);
+		assertTrue("find result", node != null);
 		IProgramElement pNode = node.getParent();
-        if (null == pNode) {
-            assertTrue("null parent of " + node, false);
-        }
+		if (null == pNode) {
+			assertTrue("null parent of " + node, false);
+		}
 		assertTrue("found node: " + pNode.getName(), pNode.isRunnable());
-	}  
-	
+	}
+
 	/**
 	 * Integrity could be checked somewhere in the API.
-	 */ 
+	 */
 	public void testModelIntegrity() {
 		IProgramElement modelRoot = manager.getHierarchy().getRoot();
-		assertTrue("root exists", modelRoot != null);	
-		
+		assertTrue("root exists", modelRoot != null);
+
 		try {
 			testModelIntegrityHelper(modelRoot);
 		} catch (Exception e) {
-			assertTrue(e.toString(), false);	
+			assertTrue(e.toString(), false);
 		}
 	}
 
 	private void testModelIntegrityHelper(IProgramElement node) throws Exception {
-		for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
-			IProgramElement child = (IProgramElement)it.next();
+		for (Iterator it = node.getChildren().iterator(); it.hasNext();) {
+			IProgramElement child = (IProgramElement) it.next();
 			if (node == child.getParent()) {
 				testModelIntegrityHelper(child);
 			} else {
 				throw new Exception("parent-child check failed for child: " + child.toString());
 			}
-		}		
+		}
+	}
+
+	public void testNoChildIsNull() {
+		HierarchyWalker walker = new HierarchyWalker() {
+			public void preProcess(IProgramElement node) {
+				if (node.getChildren() == null)
+					return;
+				for (Iterator it = node.getChildren().iterator(); it.hasNext();) {
+					if (it.next() == null)
+						throw new NullPointerException("null child on node: " + node.getName());
+				}
+			}
+		};
+		manager.getHierarchy().getRoot().walk(walker);
 	}
-  
-  	public void testNoChildIsNull() {
-  		HierarchyWalker walker = new HierarchyWalker() {
-  		    public void preProcess(IProgramElement node) {
-  		    	if (node.getChildren() == null) return;
-  		    	for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
-  		    		if (it.next() == null) throw new NullPointerException("null child on node: " + node.getName());	
-  		    	}
-  		    }
-  		};
-  		manager.getHierarchy().getRoot().walk(walker);
-  	}  
 }
@@ -9,8 +9,9 @@
  * Contributors: 
  *     Mik Kersten     initial implementation 
  * ******************************************************************/
- package org.aspectj.tools.ajdoc;
+package org.aspectj.tools.ajdoc;
 
+import org.aspectj.asm.AsmManager;
 import org.aspectj.bridge.IMessage;
 
 /**
@@ -21,17 +22,17 @@ import org.aspectj.bridge.IMessage;
 public class CompilerWrapper extends org.aspectj.tools.ajc.Main {
 
 	private static CompilerWrapper INSTANCE = null;
-	
-    public static void main(String[] args) {
-    	INSTANCE = new CompilerWrapper();
+
+	public static AsmManager executeMain(String[] args) {
+		INSTANCE = new CompilerWrapper();
 		INSTANCE.runMain(args, true);
+		return AsmManager.lastActiveStructureModel;
+	}
 
-    }
-    
 	public static boolean hasErrors() {
 		return INSTANCE.ourHandler.getErrors().length > 0;
 	}
-	
+
 	public static IMessage[] getErrors() {
 		return INSTANCE.ourHandler.getErrors();
 	}
@@ -53,13 +53,13 @@ class HtmlDecorator {
 	static File rootDir = null;
 	static String docVisibilityModifier;
 
-	static void decorateHTMLFromInputFiles(Hashtable table, File newRootDir, File[] inputFiles, String docModifier)
+	static void decorateHTMLFromInputFiles(AsmManager model, Hashtable table, File newRootDir, File[] inputFiles, String docModifier)
 			throws IOException {
 		rootDir = newRootDir;
 		declIDTable = table;
 		docVisibilityModifier = docModifier;
 		for (int i = 0; i < inputFiles.length; i++) {
-			decorateHTMLFromIPEs(getProgramElements(inputFiles[i].getCanonicalPath()), rootDir.getCanonicalPath()
+			decorateHTMLFromIPEs(getProgramElements(model, inputFiles[i].getCanonicalPath()), rootDir.getCanonicalPath()
 					+ Config.DIR_SEP_CHAR, docModifier, false);
 		}
 	}
@@ -516,7 +516,7 @@ class HtmlDecorator {
 				IProgramElement currDecl = null;
 				if (o instanceof String) {
 					String currHandle = (String) o;
-					currDecl = AsmManager.getDefault().getHierarchy().findElementForHandle(currHandle);
+					currDecl = node.getModel().getHierarchy().findElementForHandle(currHandle);
 				} else if (o instanceof IProgramElement) {
 					currDecl = (IProgramElement) o;
 				} else {
@@ -668,7 +668,7 @@ class HtmlDecorator {
 		List addedNames = new ArrayList(); // for ensuring that we don't add duplciates
 		for (Iterator it = targets.iterator(); it.hasNext();) {
 			String currHandle = (String) it.next();
-			IProgramElement currDecl = AsmManager.getDefault().getHierarchy().findElementForHandle(currHandle);
+			IProgramElement currDecl = decl.getModel().getHierarchy().findElementForHandle(currHandle);
 			if (currDecl.getKind().equals(IProgramElement.Kind.CODE)) {
 				currDecl = currDecl.getParent(); // promote to enclosing
 			}
@@ -850,9 +850,9 @@ class HtmlDecorator {
 		return formattedComment;
 	}
 
-	static public IProgramElement[] getProgramElements(String filename) {
+	static public IProgramElement[] getProgramElements(AsmManager model, String filename) {
 
-		IProgramElement file = (IProgramElement) AsmManager.getDefault().getHierarchy().findElementForSourceFile(filename);
+		IProgramElement file = (IProgramElement) model.getHierarchy().findElementForSourceFile(filename);
 		final List nodes = new ArrayList();
 		HierarchyWalker walker = new HierarchyWalker() {
 			public void preProcess(IProgramElement node) {
@@ -14,400 +14,405 @@
 
 package org.aspectj.tools.ajdoc;
 
-import java.io.*;
-import java.util.*;
-
+import java.io.BufferedReader;
+import java.io.File;
 import java.io.FileFilter;
-
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.FileReader;
+import java.io.FilenameFilter;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Hashtable;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.StringTokenizer;
+import java.util.Vector;
+
+import org.aspectj.asm.AsmManager;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.Version;
 import org.aspectj.util.FileUtil;
 
 /**
- * This is an old implementation of ajdoc that does not use an OO style.  However, it 
- * does the job, and should serve to evolve a lightweight ajdoc implementation until
- * we can make a properly extended javadoc implementation.
+ * This is an old implementation of ajdoc that does not use an OO style. However, it does the job, and should serve to evolve a
+ * lightweight ajdoc implementation until we can make a properly extended javadoc implementation.
  * 
  * @author Mik Kersten
  */
 public class Main implements Config {
 
-	private static final String FAIL_MESSAGE =  "> compile failed, exiting ajdoc";
+	private static final String FAIL_MESSAGE = "> compile failed, exiting ajdoc";
+
+	/** Command line options. */
+	static Vector options;
 
-    /** Command line options. */
-    static Vector options;
+	/** Options to pass to ajc. */
+	static Vector ajcOptions;
 
-    /** Options to pass to ajc. */
-    static Vector ajcOptions;
+	/** All of the files to be processed by ajdoc. */
+	static Vector filenames;
 
-    /** All of the files to be processed by ajdoc. */
-    static Vector filenames;
+	/** List of files to pass to javadoc. */
+	static Vector fileList;
 
-    /** List of files to pass to javadoc. */
-    static Vector fileList;
+	/** List of packages to pass to javadoc. */
+	static Vector packageList;
 
-    /** List of packages to pass to javadoc. */
-    static Vector packageList;
+	/** Default to package visiblity. */
+	static String docModifier = "package";
 
-    /** Default to package visiblity. */
-    static String docModifier = "package";
+	static Vector sourcepath;
 
-    static Vector sourcepath;
+	static boolean verboseMode = false;
+	static boolean packageMode = false;
+	static boolean authorStandardDocletSwitch = false;
+	static boolean versionStandardDocletSwitch = false;
+	static File rootDir = null;
+	static Hashtable declIDTable = new Hashtable();
+	static String docDir = ".";
+
+	private static boolean deleteTempFilesOnExit = true;
 
-    static boolean verboseMode = false;
-    static boolean packageMode = false;
-    static boolean authorStandardDocletSwitch = false;
-    static boolean versionStandardDocletSwitch = false;
-    static File    rootDir       = null;
-    static Hashtable declIDTable   = new Hashtable();
-    static String  docDir          = ".";
-    
-    private static boolean deleteTempFilesOnExit = true;
-    
 	private static boolean aborted = false;
 	private static IMessage[] errors;
 	private static boolean shownAjdocUsageMessage = false;
-	
+
 	// creating a local variable to enable us to create the ajdocworkingdir
 	// in a local sandbox during testing
 	private static String outputWorkingDir = Config.WORKING_DIR;
 
-    public static void clearState() {
-        options = new Vector();
-        ajcOptions = new Vector();
-        filenames = new Vector();
-        fileList= new Vector();
-        packageList = new Vector();
-        docModifier = "package";
-        sourcepath = new Vector();
-        verboseMode = false;
-        packageMode = false;
-        rootDir       = null;
-        declIDTable   = new Hashtable();
-        docDir          = ".";
-    	aborted = false;
-    	deleteTempFilesOnExit = true;
-    }
-
-    public static void main(String[] args) {
-    	clearState();
-    	if (!JavadocRunner.has14ToolsAvailable()) {
-    		System.err.println("ajdoc requires a JDK 1.4 or later tools jar - exiting");
-    		aborted = true;
-    		return;
-    	}
-    	  
-        // STEP 1: parse the command line and do other global setup
-        sourcepath.addElement("."); // add the current directory to the classapth
-        parseCommandLine(args);  
-        rootDir = getRootDir();
-        File[] inputFiles      = new File[filenames.size()];
-        File[] signatureFiles  = new File[filenames.size()];
-        try {
-            // create the workingdir if it doesn't exist
-            if ( !(new File( outputWorkingDir ).isDirectory()) ) {
-                File dir = new File( outputWorkingDir );
-                dir.mkdir();
-                if (deleteTempFilesOnExit) dir.deleteOnExit();
-            }
-
-            for (int i = 0; i < filenames.size(); i++) {
-                inputFiles[i]     = new File((String)filenames.elementAt(i));
-            }
-
-            // PHASE 0: call ajc
-            callAjc(inputFiles);
-            if (CompilerWrapper.hasErrors()) {
-            	System.out.println(FAIL_MESSAGE);
-            	aborted = true;
-            	errors = CompilerWrapper.getErrors();
-            	return;
-            }    
-
-            for (int ii = 0; ii < filenames.size(); ii++) {
-                signatureFiles[ii] = createSignatureFile(inputFiles[ii]);
-            }
-
-            // PHASE 1: generate Signature files (Java with DeclIDs and no bodies).
-            System.out.println( "> Building signature files..." );
-			try{
-				StubFileGenerator.doFiles(declIDTable, inputFiles, signatureFiles);
-			} catch (DocException d){
+	public static void clearState() {
+		options = new Vector();
+		ajcOptions = new Vector();
+		filenames = new Vector();
+		fileList = new Vector();
+		packageList = new Vector();
+		docModifier = "package";
+		sourcepath = new Vector();
+		verboseMode = false;
+		packageMode = false;
+		rootDir = null;
+		declIDTable = new Hashtable();
+		docDir = ".";
+		aborted = false;
+		deleteTempFilesOnExit = true;
+	}
+
+	public static void main(String[] args) {
+		clearState();
+		if (!JavadocRunner.has14ToolsAvailable()) {
+			System.err.println("ajdoc requires a JDK 1.4 or later tools jar - exiting");
+			aborted = true;
+			return;
+		}
+
+		// STEP 1: parse the command line and do other global setup
+		sourcepath.addElement("."); // add the current directory to the classapth
+		parseCommandLine(args);
+		rootDir = getRootDir();
+		File[] inputFiles = new File[filenames.size()];
+		File[] signatureFiles = new File[filenames.size()];
+		try {
+			// create the workingdir if it doesn't exist
+			if (!(new File(outputWorkingDir).isDirectory())) {
+				File dir = new File(outputWorkingDir);
+				dir.mkdir();
+				if (deleteTempFilesOnExit)
+					dir.deleteOnExit();
+			}
+
+			for (int i = 0; i < filenames.size(); i++) {
+				inputFiles[i] = new File((String) filenames.elementAt(i));
+			}
+
+			// PHASE 0: call ajc
+			AsmManager model = callAjc(inputFiles);
+			if (CompilerWrapper.hasErrors()) {
+				System.out.println(FAIL_MESSAGE);
+				aborted = true;
+				errors = CompilerWrapper.getErrors();
+				return;
+			}
+
+			for (int ii = 0; ii < filenames.size(); ii++) {
+				signatureFiles[ii] = createSignatureFile(model, inputFiles[ii]);
+			}
+
+			// PHASE 1: generate Signature files (Java with DeclIDs and no bodies).
+			System.out.println("> Building signature files...");
+			try {
+				StubFileGenerator.doFiles(model, declIDTable, inputFiles, signatureFiles);
+			} catch (DocException d) {
 				System.err.println(d.getMessage());
 				return;
 			}
 
-            // PHASE 2: let Javadoc generate HTML (with DeclIDs)
+			// PHASE 2: let Javadoc generate HTML (with DeclIDs)
 			callJavadoc(signatureFiles);
 
-            // PHASE 3: add AspectDoc specific stuff to the HTML (and remove the DeclIDS).
-			decorateHtmlFiles(inputFiles);
-            System.out.println( "> Finished." );
-        } catch (Throwable e) {
-            handleInternalError(e);
-            exit(-2);
-        }
-    }
-    
-    private static void callAjc(File[] inputFiles) {
-        ajcOptions.addElement("-noExit");
-		ajcOptions.addElement("-XjavadocsInModel");  	// TODO: wrong option to force model gen
-        ajcOptions.addElement("-d"); 
-        ajcOptions.addElement(rootDir.getAbsolutePath());
+			// PHASE 3: add AspectDoc specific stuff to the HTML (and remove the DeclIDS).
+			decorateHtmlFiles(model, inputFiles);
+			System.out.println("> Finished.");
+		} catch (Throwable e) {
+			handleInternalError(e);
+			exit(-2);
+		}
+	}
+
+	private static AsmManager callAjc(File[] inputFiles) {
+		ajcOptions.addElement("-noExit");
+		ajcOptions.addElement("-XjavadocsInModel"); // TODO: wrong option to force model gen
+		ajcOptions.addElement("-d");
+		ajcOptions.addElement(rootDir.getAbsolutePath());
 		String[] argsToCompiler = new String[ajcOptions.size() + inputFiles.length];
-        int i = 0;
-        for ( ; i < ajcOptions.size(); i++ ) {
-            argsToCompiler[i] = (String)ajcOptions.elementAt(i);
-        }
-        for ( int j = 0; j < inputFiles.length; j++) {
-            argsToCompiler[i] = inputFiles[j].getAbsolutePath();
-            //System.out.println(">> file to ajc: " + inputFiles[j].getAbsolutePath());
-            i++;
-        }
-        System.out.println( "> Calling ajc..." );
-        CompilerWrapper.main(argsToCompiler);
-    }
-    
-    private static void callJavadoc(File[] signatureFiles) throws IOException {
-        System.out.println( "> Calling javadoc..." );
-        String[] javadocargs = null;
-        if ( packageMode ) {
-            int numExtraArgs = 2;
-            if (authorStandardDocletSwitch) numExtraArgs++;
-            if (versionStandardDocletSwitch) numExtraArgs++;
-            javadocargs = new String[numExtraArgs + options.size() + packageList.size() +
-                                     fileList.size() ];
-            javadocargs[0] = "-sourcepath";
-            javadocargs[1] = outputWorkingDir;
-            int argIndex = 2;
-            if (authorStandardDocletSwitch) {
-                javadocargs[argIndex] = "-author";
-                argIndex++;
-            }
-            if (versionStandardDocletSwitch) {
-                javadocargs[argIndex] = "-version";
-            }
-            //javadocargs[1] = getSourcepathAsString();
-            for (int k = 0; k < options.size(); k++) {
-                javadocargs[numExtraArgs+k] = (String)options.elementAt(k);
-            }
-            for (int k = 0; k < packageList.size(); k++) {
-                javadocargs[numExtraArgs+options.size() + k] = (String)packageList.elementAt(k);
-            }
-            for (int k = 0; k < fileList.size(); k++) {
-                javadocargs[numExtraArgs+options.size() + packageList.size() + k] = (String)fileList.elementAt(k);
-            }
-        }
-        else {
-            javadocargs = new String[options.size() + signatureFiles.length];
-            for (int k = 0; k < options.size(); k++) {
-                javadocargs[k] = (String)options.elementAt(k);
-            }
-            for (int k = 0; k < signatureFiles.length; k++) {
-                javadocargs[options.size() + k] = StructureUtil.translateAjPathName(signatureFiles[k].getCanonicalPath());
-            }
-        }
-     
-        JavadocRunner.callJavadoc(javadocargs);    	
-    }
-    
-    /** 
-     * We start with the known HTML files (the ones that correspond directly to the
-     * input files.)  As we go along, we may learn that Javadoc split one .java file
-     * into multiple .html files to handle inner classes or local classes.  The html
-     * file decorator picks that up.
-     */
-    private static void decorateHtmlFiles(File[] inputFiles) throws IOException {
-        System.out.println( "> Decorating html files..." );
-        HtmlDecorator.decorateHTMLFromInputFiles(declIDTable,
-                                          rootDir,
-                                          inputFiles,
-                                          docModifier); 
-        
-        System.out.println( "> Removing generated tags..." );
-        removeDeclIDsFromFile("index-all.html", true);
-        removeDeclIDsFromFile("serialized-form.html", true);
-        if (packageList.size() > 0) {
-            for (int p = 0; p < packageList.size(); p++) {
-                removeDeclIDsFromFile(((String)packageList.elementAt(p)).replace('.','/') +
-                                       Config.DIR_SEP_CHAR +
-                                       "package-summary.html", true);
-            }
-        } else {
+		int i = 0;
+		for (; i < ajcOptions.size(); i++) {
+			argsToCompiler[i] = (String) ajcOptions.elementAt(i);
+		}
+		for (int j = 0; j < inputFiles.length; j++) {
+			argsToCompiler[i] = inputFiles[j].getAbsolutePath();
+			// System.out.println(">> file to ajc: " + inputFiles[j].getAbsolutePath());
+			i++;
+		}
+		System.out.println("> Calling ajc...");
+		return CompilerWrapper.executeMain(argsToCompiler);
+	}
+
+	private static void callJavadoc(File[] signatureFiles) throws IOException {
+		System.out.println("> Calling javadoc...");
+		String[] javadocargs = null;
+		if (packageMode) {
+			int numExtraArgs = 2;
+			if (authorStandardDocletSwitch)
+				numExtraArgs++;
+			if (versionStandardDocletSwitch)
+				numExtraArgs++;
+			javadocargs = new String[numExtraArgs + options.size() + packageList.size() + fileList.size()];
+			javadocargs[0] = "-sourcepath";
+			javadocargs[1] = outputWorkingDir;
+			int argIndex = 2;
+			if (authorStandardDocletSwitch) {
+				javadocargs[argIndex] = "-author";
+				argIndex++;
+			}
+			if (versionStandardDocletSwitch) {
+				javadocargs[argIndex] = "-version";
+			}
+			// javadocargs[1] = getSourcepathAsString();
+			for (int k = 0; k < options.size(); k++) {
+				javadocargs[numExtraArgs + k] = (String) options.elementAt(k);
+			}
+			for (int k = 0; k < packageList.size(); k++) {
+				javadocargs[numExtraArgs + options.size() + k] = (String) packageList.elementAt(k);
+			}
+			for (int k = 0; k < fileList.size(); k++) {
+				javadocargs[numExtraArgs + options.size() + packageList.size() + k] = (String) fileList.elementAt(k);
+			}
+		} else {
+			javadocargs = new String[options.size() + signatureFiles.length];
+			for (int k = 0; k < options.size(); k++) {
+				javadocargs[k] = (String) options.elementAt(k);
+			}
+			for (int k = 0; k < signatureFiles.length; k++) {
+				javadocargs[options.size() + k] = StructureUtil.translateAjPathName(signatureFiles[k].getCanonicalPath());
+			}
+		}
+
+		JavadocRunner.callJavadoc(javadocargs);
+	}
+
+	/**
+	 * We start with the known HTML files (the ones that correspond directly to the input files.) As we go along, we may learn that
+	 * Javadoc split one .java file into multiple .html files to handle inner classes or local classes. The html file decorator
+	 * picks that up.
+	 */
+	private static void decorateHtmlFiles(AsmManager model, File[] inputFiles) throws IOException {
+		System.out.println("> Decorating html files...");
+		HtmlDecorator.decorateHTMLFromInputFiles(model, declIDTable, rootDir, inputFiles, docModifier);
+
+		System.out.println("> Removing generated tags...");
+		removeDeclIDsFromFile("index-all.html", true);
+		removeDeclIDsFromFile("serialized-form.html", true);
+		if (packageList.size() > 0) {
+			for (int p = 0; p < packageList.size(); p++) {
+				removeDeclIDsFromFile(((String) packageList.elementAt(p)).replace('.', '/') + Config.DIR_SEP_CHAR
+						+ "package-summary.html", true);
+			}
+		} else {
 			File[] files = rootDir.listFiles();
-			if (files == null){
+			if (files == null) {
 				System.err.println("Destination directory is not a directory: " + rootDir.toString());
 				return;
 			}
-        	files = FileUtil.listFiles(rootDir, new FileFilter() {
-        		public boolean accept(File f) {
+			files = FileUtil.listFiles(rootDir, new FileFilter() {
+				public boolean accept(File f) {
 					return f.getName().equals("package-summary.html");
 				}
-        	});
-        	for (int j = 0; j < files.length; j++) {
-        		removeDeclIDsFromFile(files[j].getAbsolutePath(), false);
-        	}
-        }    	
-    }
-    
-    private static void removeDeclIDsFromFile(String filename, boolean relativePath) {
-        // Remove the decl ids from "index-all.html"
-        File indexFile;
-        if (relativePath) {
-        	indexFile = new File(docDir + Config.DIR_SEP_CHAR + filename);
-        } else {
-        	indexFile = new File(filename);
-        }
-        try {
-        if ( indexFile.exists() ) {
-            BufferedReader indexFileReader = new BufferedReader( new FileReader( indexFile ) );
-            // StringBuffer greatly reduces the time it takes to remove generated tags
-            StringBuffer indexFileBuffer = new StringBuffer((int)indexFile.length());
-            String line = indexFileReader.readLine();
-            while ( line != null ) {
-              int indexStart = line.indexOf( Config.DECL_ID_STRING );
-              int indexEnd   = line.indexOf( Config.DECL_ID_TERMINATOR );
-              if ( indexStart != -1 && indexEnd != -1 ) {
-                line = line.substring( 0, indexStart ) +
-                       line.substring( indexEnd+Config.DECL_ID_TERMINATOR.length() );
-              }
-              indexFileBuffer.append(line);
-              line = indexFileReader.readLine();
-            }
-            FileOutputStream fos = new FileOutputStream( indexFile );
-            fos.write( indexFileBuffer.toString().getBytes() );
-            
-            indexFileReader.close();
-            fos.close();
-        }
-        }
-        catch (IOException ioe) {
-              // be siltent
-        }
-    }
-
-    static Vector getSourcePath() {
-        Vector  sourcePath = new Vector();
-        boolean found      = false;
-        for ( int i = 0; i < options.size(); i++ ) {
-            String currOption = (String)options.elementAt(i);
-            if (found && !currOption.startsWith("-")) {
-                sourcePath.add(currOption);
-            }
-            if (currOption.equals("-sourcepath")) {
-                found = true;
-            }
-        }
-        return sourcePath;
-    }
-
-    static File getRootDir() {
-        File rootDir = new File( "." );
-        for ( int i = 0; i < options.size(); i++ ) {
-            if ( ((String)options.elementAt(i)).equals( "-d" ) ) {
-                rootDir = new File((String)options.elementAt(i+1));
-                if ( !rootDir.exists() ) {
-                	rootDir.mkdir();
-//                    System.out.println( "Destination directory not found: " +
-//                                        (String)options.elementAt(i+1) );
-//                    System.exit( -1 );
-                }
-            }
-        }
-        return rootDir;
-    }
-
-    static File createSignatureFile(File inputFile) throws IOException {
-    	String packageName = StructureUtil.getPackageDeclarationFromFile(inputFile);
-    	
-        String filename    = "";
-        if ( packageName != null ) {
-            String pathName =  outputWorkingDir + '/' + packageName.replace('.', '/');
-            File packageDir = new File(pathName);
-            if ( !packageDir.exists() ) {
-                packageDir.mkdirs();
-                if (deleteTempFilesOnExit) packageDir.deleteOnExit();
-            }
-            //verifyPackageDirExists(packageName, null);
-            packageName = packageName.replace( '.','/' ); // !!!
-            filename = outputWorkingDir + Config.DIR_SEP_CHAR + packageName +
-                       Config.DIR_SEP_CHAR + inputFile.getName();
-        }
-        else {
-            filename = outputWorkingDir + Config.DIR_SEP_CHAR + inputFile.getName();
-        }
-        File signatureFile = new File( filename );
-        if (deleteTempFilesOnExit) signatureFile.deleteOnExit();
-        return signatureFile;
-    }
-
-
-//    static void verifyPackageDirExists( String packageName, String offset ) {
-//        System.err.println(">>> name: " + packageName + ", offset: " + offset);
-//        if ( packageName.indexOf( "." ) != -1 ) {
-//            File tempFile = new File("c:/aspectj-test/d1/d2/d3");
-//            tempFile.mkdirs();
-//            String currPkgDir = packageName.substring( 0, packageName.indexOf( "." ) );
-//            String remainingPkg = packageName.substring( packageName.indexOf( "." )+1 );
-//            String filePath = null;
-//            if ( offset != null ) {
-//                filePath = Config.WORKING_DIR + Config.DIR_SEP_CHAR +
-//                           offset + Config.DIR_SEP_CHAR + currPkgDir ;
-//            }
-//            else {
-//                filePath = Config.WORKING_DIR + Config.DIR_SEP_CHAR + currPkgDir;
-//            }
-//            File packageDir = new File( filePath );
-//            if ( !packageDir.exists() ) {
-//                packageDir.mkdir();
-//                if (deleteTempFilesOnExit) packageDir.deleteOnExit();
-//            }
-//            if ( remainingPkg != "" ) {
-//                verifyPackageDirExists( remainingPkg, currPkgDir );
-//            }
-//        }
-//        else {
-//            String filePath = null;
-//            if ( offset != null ) {
-//                filePath = Config.WORKING_DIR + Config.DIR_SEP_CHAR + offset + Config.DIR_SEP_CHAR + packageName;
-//            }
-//            else {
-//                filePath = Config.WORKING_DIR + Config.DIR_SEP_CHAR + packageName;
-//            }
-//            File packageDir = new File( filePath );
-//            if ( !packageDir.exists() ) {
-//                packageDir.mkdir();
-//                if (deleteTempFilesOnExit) packageDir.deleteOnExit();
-//            }
-//        }
-//    }
-
-    /**
-     * Can read Eclipse-generated single-line arg
-     */
-    static void parseCommandLine(String[] args) {
-        if (args.length == 0) {
-            displayHelpAndExit( null );
-        } else if (args.length == 1 && args[0].startsWith("@")) {
-        	String argFile = args[0].substring(1);
-        	System.out.println("> Using arg file: " + argFile);  
-        	BufferedReader br;
+			});
+			for (int j = 0; j < files.length; j++) {
+				removeDeclIDsFromFile(files[j].getAbsolutePath(), false);
+			}
+		}
+	}
+
+	private static void removeDeclIDsFromFile(String filename, boolean relativePath) {
+		// Remove the decl ids from "index-all.html"
+		File indexFile;
+		if (relativePath) {
+			indexFile = new File(docDir + Config.DIR_SEP_CHAR + filename);
+		} else {
+			indexFile = new File(filename);
+		}
+		try {
+			if (indexFile.exists()) {
+				BufferedReader indexFileReader = new BufferedReader(new FileReader(indexFile));
+				// StringBuffer greatly reduces the time it takes to remove generated tags
+				StringBuffer indexFileBuffer = new StringBuffer((int) indexFile.length());
+				String line = indexFileReader.readLine();
+				while (line != null) {
+					int indexStart = line.indexOf(Config.DECL_ID_STRING);
+					int indexEnd = line.indexOf(Config.DECL_ID_TERMINATOR);
+					if (indexStart != -1 && indexEnd != -1) {
+						line = line.substring(0, indexStart) + line.substring(indexEnd + Config.DECL_ID_TERMINATOR.length());
+					}
+					indexFileBuffer.append(line);
+					line = indexFileReader.readLine();
+				}
+				FileOutputStream fos = new FileOutputStream(indexFile);
+				fos.write(indexFileBuffer.toString().getBytes());
+
+				indexFileReader.close();
+				fos.close();
+			}
+		} catch (IOException ioe) {
+			// be siltent
+		}
+	}
+
+	static Vector getSourcePath() {
+		Vector sourcePath = new Vector();
+		boolean found = false;
+		for (int i = 0; i < options.size(); i++) {
+			String currOption = (String) options.elementAt(i);
+			if (found && !currOption.startsWith("-")) {
+				sourcePath.add(currOption);
+			}
+			if (currOption.equals("-sourcepath")) {
+				found = true;
+			}
+		}
+		return sourcePath;
+	}
+
+	static File getRootDir() {
+		File rootDir = new File(".");
+		for (int i = 0; i < options.size(); i++) {
+			if (((String) options.elementAt(i)).equals("-d")) {
+				rootDir = new File((String) options.elementAt(i + 1));
+				if (!rootDir.exists()) {
+					rootDir.mkdir();
+					// System.out.println( "Destination directory not found: " +
+					// (String)options.elementAt(i+1) );
+					// System.exit( -1 );
+				}
+			}
+		}
+		return rootDir;
+	}
+
+	static File createSignatureFile(AsmManager model, File inputFile) throws IOException {
+		String packageName = StructureUtil.getPackageDeclarationFromFile(model, inputFile);
+
+		String filename = "";
+		if (packageName != null) {
+			String pathName = outputWorkingDir + '/' + packageName.replace('.', '/');
+			File packageDir = new File(pathName);
+			if (!packageDir.exists()) {
+				packageDir.mkdirs();
+				if (deleteTempFilesOnExit)
+					packageDir.deleteOnExit();
+			}
+			// verifyPackageDirExists(packageName, null);
+			packageName = packageName.replace('.', '/'); // !!!
+			filename = outputWorkingDir + Config.DIR_SEP_CHAR + packageName + Config.DIR_SEP_CHAR + inputFile.getName();
+		} else {
+			filename = outputWorkingDir + Config.DIR_SEP_CHAR + inputFile.getName();
+		}
+		File signatureFile = new File(filename);
+		if (deleteTempFilesOnExit)
+			signatureFile.deleteOnExit();
+		return signatureFile;
+	}
+
+	// static void verifyPackageDirExists( String packageName, String offset ) {
+	// System.err.println(">>> name: " + packageName + ", offset: " + offset);
+	// if ( packageName.indexOf( "." ) != -1 ) {
+	// File tempFile = new File("c:/aspectj-test/d1/d2/d3");
+	// tempFile.mkdirs();
+	// String currPkgDir = packageName.substring( 0, packageName.indexOf( "." ) );
+	// String remainingPkg = packageName.substring( packageName.indexOf( "." )+1 );
+	// String filePath = null;
+	// if ( offset != null ) {
+	// filePath = Config.WORKING_DIR + Config.DIR_SEP_CHAR +
+	// offset + Config.DIR_SEP_CHAR + currPkgDir ;
+	// }
+	// else {
+	// filePath = Config.WORKING_DIR + Config.DIR_SEP_CHAR + currPkgDir;
+	// }
+	// File packageDir = new File( filePath );
+	// if ( !packageDir.exists() ) {
+	// packageDir.mkdir();
+	// if (deleteTempFilesOnExit) packageDir.deleteOnExit();
+	// }
+	// if ( remainingPkg != "" ) {
+	// verifyPackageDirExists( remainingPkg, currPkgDir );
+	// }
+	// }
+	// else {
+	// String filePath = null;
+	// if ( offset != null ) {
+	// filePath = Config.WORKING_DIR + Config.DIR_SEP_CHAR + offset + Config.DIR_SEP_CHAR + packageName;
+	// }
+	// else {
+	// filePath = Config.WORKING_DIR + Config.DIR_SEP_CHAR + packageName;
+	// }
+	// File packageDir = new File( filePath );
+	// if ( !packageDir.exists() ) {
+	// packageDir.mkdir();
+	// if (deleteTempFilesOnExit) packageDir.deleteOnExit();
+	// }
+	// }
+	// }
+
+	/**
+	 * Can read Eclipse-generated single-line arg
+	 */
+	static void parseCommandLine(String[] args) {
+		if (args.length == 0) {
+			displayHelpAndExit(null);
+		} else if (args.length == 1 && args[0].startsWith("@")) {
+			String argFile = args[0].substring(1);
+			System.out.println("> Using arg file: " + argFile);
+			BufferedReader br;
 			try {
 				br = new BufferedReader(new FileReader(argFile));
 				String line = "";
-	        	line = br.readLine();
-	        	StringTokenizer st = new StringTokenizer(line, " ");
-	        	List argList = new ArrayList();
-	        	while(st.hasMoreElements()) {
-	        		argList.add(st.nextElement());
-	        	}
-	        	//System.err.println(argList);
-	        	args = new String[argList.size()];
-	        	int counter = 0;
-	        	for (Iterator it = argList.iterator(); it.hasNext(); ) {
-	        		args[counter] = (String)it.next();
-	        		counter++;
-	        	}
+				line = br.readLine();
+				StringTokenizer st = new StringTokenizer(line, " ");
+				List argList = new ArrayList();
+				while (st.hasMoreElements()) {
+					argList.add(st.nextElement());
+				}
+				// System.err.println(argList);
+				args = new String[argList.size()];
+				int counter = 0;
+				for (Iterator it = argList.iterator(); it.hasNext();) {
+					args[counter] = (String) it.next();
+					counter++;
+				}
 			} catch (FileNotFoundException e) {
 				System.err.println("> could not read arg file: " + argFile);
 				e.printStackTrace();
@@ -415,359 +420,345 @@ public class Main implements Config {
 				System.err.println("> could not read arg file: " + argFile);
 				ioe.printStackTrace();
 			}
-        }
-        List vargs = new LinkedList(Arrays.asList(args));
-
-        parseArgs(vargs, new File( "." ));  // !!!
-
-        if (filenames.size() == 0) {
-            displayHelpAndExit( "ajdoc: No packages or classes specified" );
-        }
-    }
-
-    static void setSourcepath(String arg) {
-           sourcepath.clear();
-           arg = arg + File.pathSeparator; // makes things easier for ourselves
-           StringTokenizer tokenizer = new StringTokenizer(arg, File.pathSeparator);
-           while (tokenizer.hasMoreElements()) {
-                 sourcepath.addElement(tokenizer.nextElement());
-           }
-    }
-
-    static String getSourcepathAsString() {
-       String cPath = "";
-       for (int i = 0; i < sourcepath.size(); i++) {
-           cPath += (String)sourcepath.elementAt(i) + Config.DIR_SEP_CHAR + outputWorkingDir;
-           if (i != sourcepath.size()-1) {
-              cPath += File.pathSeparator;
-           }
-       }
-       return cPath;
-    }
-
-    static void parseArgs(List vargs, File currentWorkingDir) {
-        boolean addNextAsOption     = false;
-        boolean addNextAsArgFile    = false;
-        boolean addNextToAJCOptions = false;
-        boolean addNextAsDocDir     = false;
-        boolean addNextAsClasspath  = false;
-        boolean ignoreArg           = false;  // used for discrepancy betwen class/sourcepath in ajc/javadoc
-        boolean addNextAsSourcePath = false;
-        if ( vargs.size() == 0 ) {
-            displayHelpAndExit( null );
-        }
-        for (int i = 0; i < vargs.size() ; i++) {
-            String arg = (String)vargs.get(i);  
-            ignoreArg = false;
-            if (addNextAsDocDir) {
-                docDir = arg;
-                addNextAsDocDir = false;
-            }
-            if (addNextAsClasspath) {
-                addNextAsClasspath = false;
-            }
-            if (addNextAsSourcePath) {
-                setSourcepath( arg );
-                addNextAsSourcePath = false;
-                ignoreArg = true;
-            }
-            
-            if ( arg.startsWith("@") ) {
-                expandAtSignFile(arg.substring(1), currentWorkingDir);
-            } else if ( arg.equals( "-argfile" ) ) {
-                addNextAsArgFile = true;
-            } else if ( addNextAsArgFile ) {
-                expandAtSignFile(arg, currentWorkingDir);
-                addNextAsArgFile = false;
-            } else if (arg.equals("-d") ) {
-                addNextAsOption = true;
-                options.addElement(arg);
-                addNextAsDocDir = true;
-            } else if ( arg.equals( "-bootclasspath" ) ) {
-                addNextAsOption = true;
-                addNextToAJCOptions = true;
-                options.addElement( arg );
-                ajcOptions.addElement( arg );
-            } else if ( arg.equals( "-source" ) ) {
-                addNextAsOption = true;
-                addNextToAJCOptions = true; 
-                addNextAsClasspath = true;  
-                options.addElement(arg); 
-                ajcOptions.addElement(arg);  
-            } else if ( arg.equals( "-classpath" ) ) {
-                addNextAsOption = true;
-                addNextToAJCOptions = true;
-                addNextAsClasspath = true;
-                options.addElement( arg );
-                ajcOptions.addElement( arg );
-            } else if ( arg.equals( "-encoding" ) ) {
-                addNextAsOption = true;
-                addNextToAJCOptions = false;
-                options.addElement( arg );
-            } else if ( arg.equals( "-docencoding" ) ) {
-                addNextAsOption = true;
-                addNextToAJCOptions = false;
-                options.addElement( arg );
-            } else if ( arg.equals( "-charset" ) ) {
-                addNextAsOption = true;
-                addNextToAJCOptions = false;
-                options.addElement( arg );
-            } else if ( arg.equals( "-sourcepath" ) ) {
-                addNextAsSourcePath = true;
-                //options.addElement( arg );
-                //ajcOptions.addElement( arg );
-            } else if ( arg.equals( "-link" ) ) {
-                addNextAsOption = true;
-            	options.addElement(arg);
-            } else if ( arg.equals( "-bottom" ) ) {
-                addNextAsOption = true;
-            	options.addElement(arg);
-            } else if ( arg.equals( "-windowtitle" ) ) {
-                addNextAsOption = true;
-            	options.addElement(arg);
-            } else if (arg.equals("-XajdocDebug")) {
-            	deleteTempFilesOnExit = false;
-            } else if (arg.equals("-use")) {
-            	System.out.println("> Ignoring unsupported option: -use");
-            } else if (arg.equals("-splitindex")) {
-            	// passed to javadoc
-            } else if (arg.startsWith("-") || addNextAsOption || addNextToAJCOptions) {
-                if ( arg.equals( "-private" ) ) {
-                    docModifier = "private";
-                } else if ( arg.equals( "-package" ) ) {
-                    docModifier = "package";
-                } else if ( arg.equals( "-protected" ) ) {
-                    docModifier = "protected";
-                } else if ( arg.equals( "-public" ) ) {
-                    docModifier = "public";
-                } else if ( arg.equals( "-verbose" ) ) {
-                    verboseMode = true;
-                } else if ( arg.equals( "-author" ) ) {
-                    authorStandardDocletSwitch = true;
-                } else if ( arg.equals( "-version" ) ) {
-                    versionStandardDocletSwitch = true;
-                } else if ( arg.equals( "-v" ) ) {
-                    System.out.println(getVersion());
-                    exit(0);
-                } else if ( arg.equals( "-help" ) ) {
-                    displayHelpAndExit( null );
-                } else if ( arg.equals( "-doclet" ) || arg.equals( "-docletpath" ) ) {
-                    System.out.println( "The doclet and docletpath options are not currently supported    \n" +
-                                        "since ajdoc makes assumptions about the behavior of the standard \n" +
-                                        "doclet. If you would find this option useful please email us at: \n" +
-                                        "                                                                 \n" +
-                                        "       aspectj-dev@eclipse.org                            \n" +
-                                        "                                                                 \n" );
-                    exit(0);
-                } else if (arg.equals("-nonavbar")
-                	|| arg.equals("-noindex")) {
-                	// pass through 
-                	//System.err.println("> ignoring unsupported option: " + arg);
-                } else if (addNextToAJCOptions || addNextAsOption) {
-                	// deal with these two options together even though effectively
-                	// just falling through if addNextAsOption is true. Otherwise
-                	// will have to ensure check "addNextToAJCOptions" before
-                	// "addNextAsOption" so as the options are added to the 
-                	// correct lists.
-                	if (addNextToAJCOptions) {
-                    	ajcOptions.addElement(arg);
-                    	if (!arg.startsWith("-")) {
-                    		addNextToAJCOptions = false;
-    					}
-                    	if (!addNextAsOption) {
-    						continue;
-    					}						
+		}
+		List vargs = new LinkedList(Arrays.asList(args));
+
+		parseArgs(vargs, new File(".")); // !!!
+
+		if (filenames.size() == 0) {
+			displayHelpAndExit("ajdoc: No packages or classes specified");
+		}
+	}
+
+	static void setSourcepath(String arg) {
+		sourcepath.clear();
+		arg = arg + File.pathSeparator; // makes things easier for ourselves
+		StringTokenizer tokenizer = new StringTokenizer(arg, File.pathSeparator);
+		while (tokenizer.hasMoreElements()) {
+			sourcepath.addElement(tokenizer.nextElement());
+		}
+	}
+
+	static String getSourcepathAsString() {
+		String cPath = "";
+		for (int i = 0; i < sourcepath.size(); i++) {
+			cPath += (String) sourcepath.elementAt(i) + Config.DIR_SEP_CHAR + outputWorkingDir;
+			if (i != sourcepath.size() - 1) {
+				cPath += File.pathSeparator;
+			}
+		}
+		return cPath;
+	}
+
+	static void parseArgs(List vargs, File currentWorkingDir) {
+		boolean addNextAsOption = false;
+		boolean addNextAsArgFile = false;
+		boolean addNextToAJCOptions = false;
+		boolean addNextAsDocDir = false;
+		boolean addNextAsClasspath = false;
+		boolean ignoreArg = false; // used for discrepancy betwen class/sourcepath in ajc/javadoc
+		boolean addNextAsSourcePath = false;
+		if (vargs.size() == 0) {
+			displayHelpAndExit(null);
+		}
+		for (int i = 0; i < vargs.size(); i++) {
+			String arg = (String) vargs.get(i);
+			ignoreArg = false;
+			if (addNextAsDocDir) {
+				docDir = arg;
+				addNextAsDocDir = false;
+			}
+			if (addNextAsClasspath) {
+				addNextAsClasspath = false;
+			}
+			if (addNextAsSourcePath) {
+				setSourcepath(arg);
+				addNextAsSourcePath = false;
+				ignoreArg = true;
+			}
+
+			if (arg.startsWith("@")) {
+				expandAtSignFile(arg.substring(1), currentWorkingDir);
+			} else if (arg.equals("-argfile")) {
+				addNextAsArgFile = true;
+			} else if (addNextAsArgFile) {
+				expandAtSignFile(arg, currentWorkingDir);
+				addNextAsArgFile = false;
+			} else if (arg.equals("-d")) {
+				addNextAsOption = true;
+				options.addElement(arg);
+				addNextAsDocDir = true;
+			} else if (arg.equals("-bootclasspath")) {
+				addNextAsOption = true;
+				addNextToAJCOptions = true;
+				options.addElement(arg);
+				ajcOptions.addElement(arg);
+			} else if (arg.equals("-source")) {
+				addNextAsOption = true;
+				addNextToAJCOptions = true;
+				addNextAsClasspath = true;
+				options.addElement(arg);
+				ajcOptions.addElement(arg);
+			} else if (arg.equals("-classpath")) {
+				addNextAsOption = true;
+				addNextToAJCOptions = true;
+				addNextAsClasspath = true;
+				options.addElement(arg);
+				ajcOptions.addElement(arg);
+			} else if (arg.equals("-encoding")) {
+				addNextAsOption = true;
+				addNextToAJCOptions = false;
+				options.addElement(arg);
+			} else if (arg.equals("-docencoding")) {
+				addNextAsOption = true;
+				addNextToAJCOptions = false;
+				options.addElement(arg);
+			} else if (arg.equals("-charset")) {
+				addNextAsOption = true;
+				addNextToAJCOptions = false;
+				options.addElement(arg);
+			} else if (arg.equals("-sourcepath")) {
+				addNextAsSourcePath = true;
+				// options.addElement( arg );
+				// ajcOptions.addElement( arg );
+			} else if (arg.equals("-link")) {
+				addNextAsOption = true;
+				options.addElement(arg);
+			} else if (arg.equals("-bottom")) {
+				addNextAsOption = true;
+				options.addElement(arg);
+			} else if (arg.equals("-windowtitle")) {
+				addNextAsOption = true;
+				options.addElement(arg);
+			} else if (arg.equals("-XajdocDebug")) {
+				deleteTempFilesOnExit = false;
+			} else if (arg.equals("-use")) {
+				System.out.println("> Ignoring unsupported option: -use");
+			} else if (arg.equals("-splitindex")) {
+				// passed to javadoc
+			} else if (arg.startsWith("-") || addNextAsOption || addNextToAJCOptions) {
+				if (arg.equals("-private")) {
+					docModifier = "private";
+				} else if (arg.equals("-package")) {
+					docModifier = "package";
+				} else if (arg.equals("-protected")) {
+					docModifier = "protected";
+				} else if (arg.equals("-public")) {
+					docModifier = "public";
+				} else if (arg.equals("-verbose")) {
+					verboseMode = true;
+				} else if (arg.equals("-author")) {
+					authorStandardDocletSwitch = true;
+				} else if (arg.equals("-version")) {
+					versionStandardDocletSwitch = true;
+				} else if (arg.equals("-v")) {
+					System.out.println(getVersion());
+					exit(0);
+				} else if (arg.equals("-help")) {
+					displayHelpAndExit(null);
+				} else if (arg.equals("-doclet") || arg.equals("-docletpath")) {
+					System.out.println("The doclet and docletpath options are not currently supported    \n"
+							+ "since ajdoc makes assumptions about the behavior of the standard \n"
+							+ "doclet. If you would find this option useful please email us at: \n"
+							+ "                                                                 \n"
+							+ "       aspectj-dev@eclipse.org                            \n"
+							+ "                                                                 \n");
+					exit(0);
+				} else if (arg.equals("-nonavbar") || arg.equals("-noindex")) {
+					// pass through
+					// System.err.println("> ignoring unsupported option: " + arg);
+				} else if (addNextToAJCOptions || addNextAsOption) {
+					// deal with these two options together even though effectively
+					// just falling through if addNextAsOption is true. Otherwise
+					// will have to ensure check "addNextToAJCOptions" before
+					// "addNextAsOption" so as the options are added to the
+					// correct lists.
+					if (addNextToAJCOptions) {
+						ajcOptions.addElement(arg);
+						if (!arg.startsWith("-")) {
+							addNextToAJCOptions = false;
+						}
+						if (!addNextAsOption) {
+							continue;
+						}
 					}
-                } else if (arg.startsWith("-")) {
-                	ajcOptions.addElement(arg);
+				} else if (arg.startsWith("-")) {
+					ajcOptions.addElement(arg);
 					addNextToAJCOptions = true;
 					continue;
-                } else {
-                	System.err.println("> unrecognized argument: " + arg);
-                    displayHelpAndExit( null );
-                }  
-                options.addElement(arg);
-                addNextAsOption = false;
-            } else { 
-                // check if this is a file or a package
-//            	System.err.println(">>>>>>>> " + );
-//            	String entryName = arg.substring(arg.lastIndexOf(File.separator)+1);
-                if (FileUtil.hasSourceSuffix(arg) || arg.endsWith(".lst") && arg != null ) {
-                    File f = new File(arg);
-                    if (f.isAbsolute()) {
-                    	filenames.addElement(arg);
-                    }
-                    else {
-                        filenames.addElement( currentWorkingDir + Config.DIR_SEP_CHAR + arg );
-                    }
-                    fileList.addElement( arg );
-                }
-
-                // PACKAGE MODE STUFF
-                else if (!ignoreArg) {
-                	
-                    packageMode = true;
-                    packageList.addElement( arg );
-                    arg = arg.replace( '.', '/' );  // !!!
-
-                    // do this for every item in the classpath
-                    for ( int c = 0; c < sourcepath.size(); c++ ) {
-                      String path = (String)sourcepath.elementAt(c) + Config.DIR_SEP_CHAR + arg;
-                      File pkg = new File(path);
-                      if ( pkg.isDirectory() ) {
-                          String[] files = pkg.list( new FilenameFilter() {
-                              public boolean accept( File dir, String name )  {
-                                  int index1 = name.lastIndexOf( "." );
-                                  int index2 = name.length();
-                                  if ( (index1 >= 0 && index2 >= 0 ) &&
-                                        (name.substring(index1, index2).equals( ".java" )
-										 || name.substring(index1, index2).equals( ".aj" ))) {
-                                      return true;
-                                  }
-                                  else  {
-                                      return false;
-                                  }
-                              }
-                             } );
-                          for ( int j = 0; j < files.length; j++ ) {
-                              filenames.addElement( (String)sourcepath.elementAt(c) +
-                                                    Config.DIR_SEP_CHAR +
-                                                    arg + Config.DIR_SEP_CHAR + files[j] );
-                          }
-                      }
-                      else if (c == sourcepath.size() ) { // last element on classpath
-                          System.out.println( "ajdoc: No package, class, or source file " +
-                                              "found named " + arg + "." );
-                      }
-                      else {
-                           // didn't find it on that element of the classpath but that's ok
-                      }
-                    }  
-                }
-            }
-        }
-        // set the default visibility as an option to javadoc option
-        if ( !options.contains( "-private" ) &&
-             !options.contains( "-package" ) &&
-             !options.contains( "-protected" ) &&
-             !options.contains( "-public" ) ) {
-            options.addElement( "-package" );
-        }        
-    }
-
-    static void expandAtSignFile(String filename, File currentWorkingDir) {
-        List result = new LinkedList();
-
-        File atFile = qualifiedFile(filename, currentWorkingDir);
-        String atFileParent = atFile.getParent();
-        File myWorkingDir = null;
-        if (atFileParent != null) myWorkingDir = new File(atFileParent);
-
-        try {
-            BufferedReader stream = new BufferedReader(new FileReader(atFile));
-            String line = null;
-            while ( (line = stream.readLine()) != null) {
-                // strip out any comments of the form # to end of line
-                int commentStart = line.indexOf("//");
-                if (commentStart != -1) {
-                    line = line.substring(0, commentStart);
-                }
-
-                // remove extra whitespace that might have crept in
-                line = line.trim();
-                // ignore blank lines
-                if (line.length() == 0) continue;
-                result.add(line);
-            }
-        } catch (IOException e) {
-            System.err.println("Error while reading the @ file " + atFile.getPath() + ".\n"
-                               + e);
-            System.exit( -1 );
-        }
-
-        parseArgs(result, myWorkingDir);
-    }
-
-    static File qualifiedFile(String name, File currentWorkingDir) {
-        name = name.replace('/', File.separatorChar);
-        File file = new File(name);
-        if (!file.isAbsolute() && currentWorkingDir != null) {
-            file = new File(currentWorkingDir, name);
-        }
-        return file;
-    }
-
-
-    static void displayHelpAndExit(String message) {
-    	shownAjdocUsageMessage = true;
-        if (message != null) {
+				} else {
+					System.err.println("> unrecognized argument: " + arg);
+					displayHelpAndExit(null);
+				}
+				options.addElement(arg);
+				addNextAsOption = false;
+			} else {
+				// check if this is a file or a package
+				// System.err.println(">>>>>>>> " + );
+				// String entryName = arg.substring(arg.lastIndexOf(File.separator)+1);
+				if (FileUtil.hasSourceSuffix(arg) || arg.endsWith(".lst") && arg != null) {
+					File f = new File(arg);
+					if (f.isAbsolute()) {
+						filenames.addElement(arg);
+					} else {
+						filenames.addElement(currentWorkingDir + Config.DIR_SEP_CHAR + arg);
+					}
+					fileList.addElement(arg);
+				}
+
+				// PACKAGE MODE STUFF
+				else if (!ignoreArg) {
+
+					packageMode = true;
+					packageList.addElement(arg);
+					arg = arg.replace('.', '/'); // !!!
+
+					// do this for every item in the classpath
+					for (int c = 0; c < sourcepath.size(); c++) {
+						String path = (String) sourcepath.elementAt(c) + Config.DIR_SEP_CHAR + arg;
+						File pkg = new File(path);
+						if (pkg.isDirectory()) {
+							String[] files = pkg.list(new FilenameFilter() {
+								public boolean accept(File dir, String name) {
+									int index1 = name.lastIndexOf(".");
+									int index2 = name.length();
+									if ((index1 >= 0 && index2 >= 0)
+											&& (name.substring(index1, index2).equals(".java") || name.substring(index1, index2)
+													.equals(".aj"))) {
+										return true;
+									} else {
+										return false;
+									}
+								}
+							});
+							for (int j = 0; j < files.length; j++) {
+								filenames.addElement((String) sourcepath.elementAt(c) + Config.DIR_SEP_CHAR + arg
+										+ Config.DIR_SEP_CHAR + files[j]);
+							}
+						} else if (c == sourcepath.size()) { // last element on classpath
+							System.out.println("ajdoc: No package, class, or source file " + "found named " + arg + ".");
+						} else {
+							// didn't find it on that element of the classpath but that's ok
+						}
+					}
+				}
+			}
+		}
+		// set the default visibility as an option to javadoc option
+		if (!options.contains("-private") && !options.contains("-package") && !options.contains("-protected")
+				&& !options.contains("-public")) {
+			options.addElement("-package");
+		}
+	}
+
+	static void expandAtSignFile(String filename, File currentWorkingDir) {
+		List result = new LinkedList();
+
+		File atFile = qualifiedFile(filename, currentWorkingDir);
+		String atFileParent = atFile.getParent();
+		File myWorkingDir = null;
+		if (atFileParent != null)
+			myWorkingDir = new File(atFileParent);
+
+		try {
+			BufferedReader stream = new BufferedReader(new FileReader(atFile));
+			String line = null;
+			while ((line = stream.readLine()) != null) {
+				// strip out any comments of the form # to end of line
+				int commentStart = line.indexOf("//");
+				if (commentStart != -1) {
+					line = line.substring(0, commentStart);
+				}
+
+				// remove extra whitespace that might have crept in
+				line = line.trim();
+				// ignore blank lines
+				if (line.length() == 0)
+					continue;
+				result.add(line);
+			}
+		} catch (IOException e) {
+			System.err.println("Error while reading the @ file " + atFile.getPath() + ".\n" + e);
+			System.exit(-1);
+		}
+
+		parseArgs(result, myWorkingDir);
+	}
+
+	static File qualifiedFile(String name, File currentWorkingDir) {
+		name = name.replace('/', File.separatorChar);
+		File file = new File(name);
+		if (!file.isAbsolute() && currentWorkingDir != null) {
+			file = new File(currentWorkingDir, name);
+		}
+		return file;
+	}
+
+	static void displayHelpAndExit(String message) {
+		shownAjdocUsageMessage = true;
+		if (message != null) {
 			System.err.println(message);
 			System.err.println();
-	        System.err.println(Config.USAGE);
-        } else {
+			System.err.println(Config.USAGE);
+		} else {
 			System.out.println(Config.USAGE);
 			exit(0);
-        }
-    }
-
-    static protected void exit(int value) {
-        System.out.flush();
-        System.err.flush();
-        System.exit(value);
-    }
-
-    /* This section of code handles errors that occur during compilation */
-    static final String internalErrorMessage =
-        "                                                                  \n"+
-        "If this has not already been logged as a bug raised please raise  \n"+
-        "a new AspectJ bug at https://bugs.eclipse.org/bugs including the  \n"+
-        "text below. To make the bug a priority, please also include a test\n"+
-        "program that can reproduce this problem.\n ";
-
-    static public void handleInternalError(Throwable uncaughtThrowable) {
-        System.err.println("An internal error occured in ajdoc");
-        System.err.println(internalErrorMessage);
-        System.err.println(uncaughtThrowable.toString());
-        uncaughtThrowable.printStackTrace();
-        System.err.println();
-    }
-
-    static String getVersion() {
-        return "ajdoc version " + Version.text;
-    }
-    
+		}
+	}
+
+	static protected void exit(int value) {
+		System.out.flush();
+		System.err.flush();
+		System.exit(value);
+	}
+
+	/* This section of code handles errors that occur during compilation */
+	static final String internalErrorMessage = "                                                                  \n"
+			+ "If this has not already been logged as a bug raised please raise  \n"
+			+ "a new AspectJ bug at https://bugs.eclipse.org/bugs including the  \n"
+			+ "text below. To make the bug a priority, please also include a test\n"
+			+ "program that can reproduce this problem.\n ";
+
+	static public void handleInternalError(Throwable uncaughtThrowable) {
+		System.err.println("An internal error occured in ajdoc");
+		System.err.println(internalErrorMessage);
+		System.err.println(uncaughtThrowable.toString());
+		uncaughtThrowable.printStackTrace();
+		System.err.println();
+	}
+
+	static String getVersion() {
+		return "ajdoc version " + Version.text;
+	}
+
 	public static boolean hasAborted() {
 		return aborted;
 	}
-	
+
 	public static IMessage[] getErrors() {
 		return errors;
 	}
-	
+
 	public static boolean hasShownAjdocUsageMessage() {
 		return shownAjdocUsageMessage;
 	}
-	
+
 	/**
-	 * Sets the output working dir to be <fullyQualifiedOutputDir>\ajdocworkingdir
-	 * Useful in testing to redirect the ajdocworkingdir to the sandbox
+	 * Sets the output working dir to be <fullyQualifiedOutputDir>\ajdocworkingdir Useful in testing to redirect the ajdocworkingdir
+	 * to the sandbox
 	 */
 	public static void setOutputWorkingDir(String fullyQulifiedOutputDir) {
 		if (fullyQulifiedOutputDir == null) {
 			resetOutputWorkingDir();
 		} else {
-			outputWorkingDir = fullyQulifiedOutputDir + File.separatorChar + 
-									Config.WORKING_DIR;			
+			outputWorkingDir = fullyQulifiedOutputDir + File.separatorChar + Config.WORKING_DIR;
 		}
 	}
-	
+
 	/**
-	 * Resets the output working dir to be the default which is
-	 * <the current directory>\ajdocworkingdir
+	 * Resets the output working dir to be the default which is <the current directory>\ajdocworkingdir
 	 */
 	public static void resetOutputWorkingDir() {
 		outputWorkingDir = Config.WORKING_DIR;
 	}
 }
-
-
@@ -9,7 +9,7 @@
  * Contributors: 
  *     Mik Kersten     initial implementation 
  * ******************************************************************/
- package org.aspectj.tools.ajdoc;
+package org.aspectj.tools.ajdoc;
 
 import java.io.File;
 import java.util.ArrayList;
@@ -26,76 +26,71 @@ import org.aspectj.asm.IRelationship;
 public class StructureUtil {
 
 	/**
-	 * Calculate the targets for a given IProgramElement (and it's 
-	 * immediate children if its not a type or if the child is
-	 * CODE) and relationship kind
+	 * Calculate the targets for a given IProgramElement (and it's immediate children if its not a type or if the child is CODE) and
+	 * relationship kind
 	 * 
-	 * @return	null if a relationship of that kind is not found
+	 * @return null if a relationship of that kind is not found
 	 */
-	public static List /*String*/ getTargets(IProgramElement node, IRelationship.Kind kind) {
-		return getTargets(node,kind,null);
+	public static List /* String */getTargets(IProgramElement node, IRelationship.Kind kind) {
+		return getTargets(node, kind, null);
 	}
-	
+
 	/**
-	 * Calculate the targets for a given IProgramElement (and it's immediate
-	 * children if its not a type or if the child is CODE) and relationship 
-	 * kind with the specified relationship name.
+	 * Calculate the targets for a given IProgramElement (and it's immediate children if its not a type or if the child is CODE) and
+	 * relationship kind with the specified relationship name.
 	 * 
 	 * @return null if a relationship of that kind is not found
 	 */
-	public static List /*String*/ getTargets(IProgramElement node, IRelationship.Kind kind, String relName) {
+	public static List /* String */getTargets(IProgramElement node, IRelationship.Kind kind, String relName) {
 		List relations = new ArrayList();
-		List rels = AsmManager.getDefault().getRelationshipMap().get(node);
+		List rels = node.getModel().getRelationshipMap().get(node);
 		if (rels != null) {
 			relations.addAll(rels);
 		}
-	    for (Iterator iter = node.getChildren().iterator(); iter.hasNext();) {
+		for (Iterator iter = node.getChildren().iterator(); iter.hasNext();) {
 			IProgramElement child = (IProgramElement) iter.next();
 			// if we're not a type, or if we are and the child is code, then
 			// we want to get the relationships for this child - this means that the
 			// correct relationships appear against the type in the ajdoc
-			if (!node.getKind().isType() 
-					|| child.getKind().equals(IProgramElement.Kind.CODE) ) {
-				List childRelations = AsmManager.getDefault().getRelationshipMap().get(child);
+			if (!node.getKind().isType() || child.getKind().equals(IProgramElement.Kind.CODE)) {
+				List childRelations = node.getModel().getRelationshipMap().get(child);
 				if (childRelations != null) {
-					for (Iterator iterator = childRelations.iterator(); iterator
-							.hasNext();) {
+					for (Iterator iterator = childRelations.iterator(); iterator.hasNext();) {
 						IRelationship rel = (IRelationship) iterator.next();
 						if (!relations.contains(rel)) {
 							relations.add(rel);
 						}
 					}
-				}					
+				}
 			}
-		}			
-	    if (relations == null || relations.isEmpty()) return null;
-		List targets = new ArrayList(); 
-		for (Iterator it = relations.iterator(); it.hasNext(); ) {
-	      	IRelationship rtn = (IRelationship)it.next();
-	      	if (rtn.getKind().equals(kind)
-	      			&& ((relName != null  && relName.equals(rtn.getName()))
-	      					|| relName == null)){
-	      		List targs = rtn.getTargets();
-	      		for (Iterator iter = targs.iterator(); iter.hasNext();) {
+		}
+		if (relations == null || relations.isEmpty())
+			return null;
+		List targets = new ArrayList();
+		for (Iterator it = relations.iterator(); it.hasNext();) {
+			IRelationship rtn = (IRelationship) it.next();
+			if (rtn.getKind().equals(kind) && ((relName != null && relName.equals(rtn.getName())) || relName == null)) {
+				List targs = rtn.getTargets();
+				for (Iterator iter = targs.iterator(); iter.hasNext();) {
 					String element = (String) iter.next();
 					if (!targets.contains(element)) {
 						targets.add(element);
 					}
 				}
-	      	}
-	     }
-		return targets;		
+			}
+		}
+		return targets;
 	}
-	
-	static List /*IProgramElement */ getDeclareInterTypeTargets(IProgramElement node, IProgramElement.Kind kind) {
+
+	static List /* IProgramElement */getDeclareInterTypeTargets(IProgramElement node, IProgramElement.Kind kind) {
 		List targets = new ArrayList();
-		List stringTargets = StructureUtil.getTargets(node,IRelationship.Kind.DECLARE_INTER_TYPE);
+		List stringTargets = StructureUtil.getTargets(node, IRelationship.Kind.DECLARE_INTER_TYPE);
 		if (stringTargets == null) {
 			return null;
 		}
 		for (Iterator iter = stringTargets.iterator(); iter.hasNext();) {
 			String element = (String) iter.next();
-			IProgramElement ipe = AsmManager.getDefault().getHierarchy().findElementForHandle(element);
+			IProgramElement ipe = node.getModel().getHierarchy().findElementForHandle(element);
 			if (ipe != null && ipe.getKind().equals(kind)) {
 				targets.add(ipe);
 			}
@@ -103,41 +98,41 @@ public class StructureUtil {
 		return targets;
 	}
 
-	public static List/*String*/ getDeclareTargets(IProgramElement node) {
-	    List relations = AsmManager.getDefault().getRelationshipMap().get(node);
-		List targets = null; 
-	    if (relations == null) return null;
-		for (Iterator it = relations.iterator(); it.hasNext(); ) {
-	      	IRelationship rtn = (IRelationship)it.next();
-	      	if (rtn.getKind().isDeclareKind()) {
-	      		targets = rtn.getTargets();
-	      	}
-	     }
+	public static List/* String */getDeclareTargets(IProgramElement node) {
+		List relations = node.getModel().getRelationshipMap().get(node);
+		List targets = null;
+		if (relations == null)
+			return null;
+		for (Iterator it = relations.iterator(); it.hasNext();) {
+			IRelationship rtn = (IRelationship) it.next();
+			if (rtn.getKind().isDeclareKind()) {
+				targets = rtn.getTargets();
+			}
+		}
 		return targets;
 	}
-	
-	public static String getPackageDeclarationFromFile(File file) {
-    	IProgramElement fileNode = (IProgramElement)AsmManager.getDefault().getHierarchy().findElementForSourceFile(file.getAbsolutePath());
-    	String packageName = ((IProgramElement)fileNode.getChildren().get(0)).getPackageName();
-    	return packageName;
+
+	public static String getPackageDeclarationFromFile(AsmManager model, File file) {
+		IProgramElement fileNode = model.getHierarchy().findElementForSourceFile(file.getAbsolutePath());
+		String packageName = ((IProgramElement) fileNode.getChildren().get(0)).getPackageName();
+		return packageName;
 	}
-	
+
 	public static String genSignature(IProgramElement node) {
 		StringBuffer sb = new StringBuffer();
-		
+
 		String accessibility = node.getAccessibility().toString();
 		if (!accessibility.equals("package")) {
 			sb.append(accessibility);
 			sb.append(' ');
 		}
-		
+
 		String modifiers = "";
-		for (Iterator modIt = node.getModifiers().iterator(); modIt.hasNext(); ) {
+		for (Iterator modIt = node.getModifiers().iterator(); modIt.hasNext();) {
 			modifiers += modIt.next() + " ";
 		}
-	
-		if (node.getKind().equals(IProgramElement.Kind.METHOD) || 
-			node.getKind().equals(IProgramElement.Kind.FIELD)) {
+
+		if (node.getKind().equals(IProgramElement.Kind.METHOD) || node.getKind().equals(IProgramElement.Kind.FIELD)) {
 			sb.append(node.getCorrespondingType());
 			sb.append(' ');
 		}
@@ -146,23 +141,23 @@ public class StructureUtil {
 			sb.append("class ");
 		} else if (node.getKind().equals(IProgramElement.Kind.INTERFACE)) {
 			sb.append("interface ");
-		} 
+		}
 
 		sb.append(node.getName());
-		
-		if (node.getParameterTypes() != null ) {
-			sb.append('('); 
+
+		if (node.getParameterTypes() != null) {
+			sb.append('(');
 			for (int i = 0; i < node.getParameterTypes().size(); i++) {
-				sb.append((String)node.getParameterTypes().get(i));
+				sb.append((String) node.getParameterTypes().get(i));
 				sb.append(' ');
-				sb.append((String)node.getParameterNames().get(i));
-				if (i < node.getParameterTypes().size()-1) {
+				sb.append((String) node.getParameterNames().get(i));
+				if (i < node.getParameterTypes().size() - 1) {
 					sb.append(", ");
 				}
 			}
 			sb.append(')');
 		}
-		
+
 		return sb.toString();
 	}
 
@@ -174,24 +169,24 @@ public class StructureUtil {
 			// !!! using exceptions for logic, fix
 			isIntName = false;
 		}
-//		System.err.println(">>>>>>>> " + node.getName());
+		// System.err.println(">>>>>>>> " + node.getName());
 		return isIntName || node.getName().startsWith("new ");
-//		return isIntName;
-//		if (!isIntName) {
-//			 
-//			return node.getName().startsWith("new ");
-//		} else {
-//			return false; 
-//		}
+		// return isIntName;
+		// if (!isIntName) {
+		//			 
+		// return node.getName().startsWith("new ");
+		// } else {
+		// return false;
+		// }
 	}
 
 	/**
-	 * @return	same path, but ending in ".java" instead of ".aj"
+	 * @return same path, but ending in ".java" instead of ".aj"
 	 */
 	public static String translateAjPathName(String path) {
-    	if (path.endsWith(".aj")) {
-    		path = path.substring(0, path.lastIndexOf(".aj")) + ".java";
-    	} 
-    	return path;
+		if (path.endsWith(".aj")) {
+			path = path.substring(0, path.lastIndexOf(".aj")) + ".java";
+		}
+		return path;
 	}
 }
@@ -14,7 +14,11 @@
 
 package org.aspectj.tools.ajdoc;
 
-import java.io.*;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.List;
@@ -25,208 +29,193 @@ import org.aspectj.asm.IProgramElement;
 /**
  * @author Mik Kersten
  */
-class StubFileGenerator{
-
-    static Hashtable declIDTable = null;
-
-    static void doFiles (Hashtable table,
-                        File[] inputFiles,
-                        File[] signatureFiles) throws DocException {
-        declIDTable = table;
-        for (int i = 0; i < inputFiles.length; i++) {
-            processFile(inputFiles[i], signatureFiles[i]);
-        }
-    }
-    
-
-    static void processFile(File inputFile, File signatureFile) throws DocException {
-        try {
-        	String path = StructureUtil.translateAjPathName(signatureFile.getCanonicalPath());
-            PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(path)));
-             
-            String packageName = StructureUtil.getPackageDeclarationFromFile(inputFile);
-            
-            if (packageName != null && packageName != "") {
-                writer.println( "package " + packageName + ";" );
-            }
-
-           	IProgramElement fileNode = (IProgramElement)AsmManager.getDefault().getHierarchy().findElementForSourceFile(inputFile.getAbsolutePath());
-        	for (Iterator it = fileNode.getChildren().iterator(); it.hasNext(); ) {
-        		IProgramElement node = (IProgramElement)it.next();
-        		if (node.getKind().equals(IProgramElement.Kind.IMPORT_REFERENCE)) {
-        			processImportDeclaration(node, writer);
-        		} else {
+class StubFileGenerator {
+
+	static Hashtable declIDTable = null;
+
+	static void doFiles(AsmManager model, Hashtable table, File[] inputFiles, File[] signatureFiles) throws DocException {
+		declIDTable = table;
+		for (int i = 0; i < inputFiles.length; i++) {
+			processFile(model, inputFiles[i], signatureFiles[i]);
+		}
+	}
+
+	static void processFile(AsmManager model, File inputFile, File signatureFile) throws DocException {
+		try {
+			String path = StructureUtil.translateAjPathName(signatureFile.getCanonicalPath());
+			PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(path)));
+
+			String packageName = StructureUtil.getPackageDeclarationFromFile(model, inputFile);
+
+			if (packageName != null && packageName != "") {
+				writer.println("package " + packageName + ";");
+			}
+
+			IProgramElement fileNode = model.getHierarchy().findElementForSourceFile(inputFile.getAbsolutePath());
+			for (Iterator it = fileNode.getChildren().iterator(); it.hasNext();) {
+				IProgramElement node = (IProgramElement) it.next();
+				if (node.getKind().equals(IProgramElement.Kind.IMPORT_REFERENCE)) {
+					processImportDeclaration(node, writer);
+				} else {
 					try {
-        			  processTypeDeclaration(node, writer);
-					} catch (DocException d){
+						processTypeDeclaration(node, writer);
+					} catch (DocException d) {
 						throw new DocException("File name invalid: " + inputFile.toString());
 					}
-        		}
-        	}
-           	
-            // if we got an error we don't want the contents of the file
-            writer.close(); 
-        } catch (IOException e) {
-            System.err.println(e.getMessage());
-            e.printStackTrace();
-        } 
-    }
-
-    private static void processImportDeclaration(IProgramElement node, PrintWriter writer) throws IOException {
-    	List imports = node.getChildren();
-    	for (Iterator i = imports.iterator(); i.hasNext();) {
+				}
+			}
+
+			// if we got an error we don't want the contents of the file
+			writer.close();
+		} catch (IOException e) {
+			System.err.println(e.getMessage());
+			e.printStackTrace();
+		}
+	}
+
+	private static void processImportDeclaration(IProgramElement node, PrintWriter writer) throws IOException {
+		List imports = node.getChildren();
+		for (Iterator i = imports.iterator(); i.hasNext();) {
 			IProgramElement importNode = (IProgramElement) i.next();
 			writer.println(importNode.getSourceSignature());
-		}  	 
-    }
-    
-    private static void processTypeDeclaration(IProgramElement classNode, PrintWriter writer) throws DocException {
-    	
-    	String formalComment = addDeclID(classNode, classNode.getFormalComment());
-    	writer.println(formalComment);
-    	
-    	String signature = genSourceSignature(classNode);// StructureUtil.genSignature(classNode);
-		if (signature == null){
+		}
+	}
+
+	private static void processTypeDeclaration(IProgramElement classNode, PrintWriter writer) throws DocException {
+
+		String formalComment = addDeclID(classNode, classNode.getFormalComment());
+		writer.println(formalComment);
+
+		String signature = genSourceSignature(classNode);// StructureUtil.genSignature(classNode);
+		if (signature == null) {
 			throw new DocException("The java file is invalid");
 		}
-    	
-//    	System.err.println("######" + signature + ", " + classNode.getName());
-    	if (!StructureUtil.isAnonymous(classNode) && !classNode.getName().equals("<undefined>")) {
-	    	writer.println(signature + " { " );
-	    	processMembers(classNode.getChildren(), writer, classNode.getKind().equals(IProgramElement.Kind.INTERFACE));
-	    	writer.println();
+
+		// System.err.println("######" + signature + ", " + classNode.getName());
+		if (!StructureUtil.isAnonymous(classNode) && !classNode.getName().equals("<undefined>")) {
+			writer.println(signature + " { ");
+			processMembers(classNode.getChildren(), writer, classNode.getKind().equals(IProgramElement.Kind.INTERFACE));
+			writer.println();
 			writer.println("}");
-    	}
-    }
+		}
+	}
 
-	private static void processMembers(List/*IProgramElement*/ members, PrintWriter writer, boolean declaringTypeIsInterface) throws DocException {
-    	for (Iterator it = members.iterator(); it.hasNext();) {
+	private static void processMembers(List/* IProgramElement */members, PrintWriter writer, boolean declaringTypeIsInterface)
+			throws DocException {
+		for (Iterator it = members.iterator(); it.hasNext();) {
 			IProgramElement member = (IProgramElement) it.next();
-		
-	    	if (member.getKind().isType()) { 
-	    		if (!member.getParent().getKind().equals(IProgramElement.Kind.METHOD)
-	    			 && !StructureUtil.isAnonymous(member)) {// don't print anonymous types
-//	    			System.err.println(">>>>>>>>>>>>>" + member.getName() + "<<<<" + member.getParent());
-	    			processTypeDeclaration(member, writer);
-	    		}
+
+			if (member.getKind().isType()) {
+				if (!member.getParent().getKind().equals(IProgramElement.Kind.METHOD) && !StructureUtil.isAnonymous(member)) {// don't
+					// print
+					// anonymous
+					// types
+					// System.err.println(">>>>>>>>>>>>>" + member.getName() + "<<<<" + member.getParent());
+					processTypeDeclaration(member, writer);
+				}
 			} else {
-		    	String formalComment = addDeclID(member, member.getFormalComment());;
-		    	writer.println(formalComment);
-		    	
-		    	String signature = ""; 
-		    	if (!member.getKind().equals(IProgramElement.Kind.POINTCUT)
-		    	    && !member.getKind().equals(IProgramElement.Kind.ADVICE)) {
-					signature = member.getSourceSignature();//StructureUtil.genSignature(member);
-					if (member.getKind().equals(IProgramElement.Kind.ENUM_VALUE)){
+				String formalComment = addDeclID(member, member.getFormalComment());
+				;
+				writer.println(formalComment);
+
+				String signature = "";
+				if (!member.getKind().equals(IProgramElement.Kind.POINTCUT)
+						&& !member.getKind().equals(IProgramElement.Kind.ADVICE)) {
+					signature = member.getSourceSignature();// StructureUtil.genSignature(member);
+					if (member.getKind().equals(IProgramElement.Kind.ENUM_VALUE)) {
 						int index = members.indexOf(member);
-						if ((index + 1 < members.size()) &&
-								((IProgramElement)members.get(index+1)).getKind().equals(IProgramElement.Kind.ENUM_VALUE)){
+						if ((index + 1 < members.size())
+								&& ((IProgramElement) members.get(index + 1)).getKind().equals(IProgramElement.Kind.ENUM_VALUE)) {
 							// if the next member is also an ENUM_VALUE:
 							signature = signature + ",";
 						} else {
 							signature = signature + ";";
 						}
 					}
-                } 
-		    	
-		    	if (member.getKind().isDeclare()) {
-//		    		System.err.println("> Skipping declare (ajdoc limitation): " + member.toLabelString());
-		    	} else if (signature != null &&
-		    		signature != "" && 
-		    		!member.getKind().isInterTypeMember() &&
-					!member.getKind().equals(IProgramElement.Kind.INITIALIZER) &&
-					!StructureUtil.isAnonymous(member)) {   
-		    		writer.print(signature);
-		    	} else {
-//		    		System.err.println(">> skipping: " + member.getKind());
-		    	}  
-		      
-		    	if (member.getKind().equals(IProgramElement.Kind.METHOD) ||
-		    		member.getKind().equals(IProgramElement.Kind.CONSTRUCTOR)) {
-		    		if (member.getParent().getKind().equals(IProgramElement.Kind.INTERFACE) ||
-		    			signature.indexOf("abstract ") != -1) {
-		    			writer.println(";");
-		    		} else {
-		    			writer.println(" { }");
-		    		}
-		    		
-		    	} else if (member.getKind().equals(IProgramElement.Kind.FIELD)) {
-//		    		writer.println(";");
-		    	}
+				}
+
+				if (member.getKind().isDeclare()) {
+					// System.err.println("> Skipping declare (ajdoc limitation): " + member.toLabelString());
+				} else if (signature != null && signature != "" && !member.getKind().isInterTypeMember()
+						&& !member.getKind().equals(IProgramElement.Kind.INITIALIZER) && !StructureUtil.isAnonymous(member)) {
+					writer.print(signature);
+				} else {
+					// System.err.println(">> skipping: " + member.getKind());
+				}
+
+				if (member.getKind().equals(IProgramElement.Kind.METHOD)
+						|| member.getKind().equals(IProgramElement.Kind.CONSTRUCTOR)) {
+					if (member.getParent().getKind().equals(IProgramElement.Kind.INTERFACE) || signature.indexOf("abstract ") != -1) {
+						writer.println(";");
+					} else {
+						writer.println(" { }");
+					}
+
+				} else if (member.getKind().equals(IProgramElement.Kind.FIELD)) {
+					// writer.println(";");
+				}
 			}
 		}
-    }
-
-    /**
-     * Translates "aspect" to "class", as long as its not ".aspect"
-     */
-    private static String genSourceSignature(IProgramElement classNode) {
-    	String signature = classNode.getSourceSignature();
-		if (signature != null){
+	}
+
+	/**
+	 * Translates "aspect" to "class", as long as its not ".aspect"
+	 */
+	private static String genSourceSignature(IProgramElement classNode) {
+		String signature = classNode.getSourceSignature();
+		if (signature != null) {
 			int index = signature.indexOf("aspect");
-			if (index == 0 || (index != -1 && signature.charAt(index-1) != '.') ) {
-				signature = signature.substring(0, index) +
-				"class " +
-				signature.substring(index + 6, signature.length());
+			if (index == 0 || (index != -1 && signature.charAt(index - 1) != '.')) {
+				signature = signature.substring(0, index) + "class " + signature.substring(index + 6, signature.length());
 			}
 		}
-    	return signature;
+		return signature;
+	}
+
+	static int nextDeclID = 0;
+
+	static String addDeclID(IProgramElement decl, String formalComment) {
+		String declID = "" + ++nextDeclID;
+		declIDTable.put(declID, decl);
+		return addToFormal(formalComment, Config.DECL_ID_STRING + declID + Config.DECL_ID_TERMINATOR);
+	}
+
+	/**
+	 * We want to go: just before the first period just before the first @ just before the end of the comment
+	 * 
+	 * Adds a place holder for the period ('#') if one will need to be replaced.
+	 */
+	static String addToFormal(String formalComment, String string) {
+		if (string == null || string.equals("")) {
+			return formalComment;
+		}
+		// boolean appendPeriod = true;
+		if ((formalComment == null) || formalComment.equals("")) {
+			// formalComment = "/**\n * . \n */\n";
+			formalComment = "/**\n * \n */\n";
+			// appendPeriod = false;
+		}
+		formalComment = formalComment.trim();
+
+		int atsignPos = formalComment.indexOf('@');
+		int endPos = formalComment.indexOf("*/");
+		int periodPos = formalComment.indexOf("/**");
+		int position = 0;
+		String periodPlaceHolder = "";
+		if (periodPos != -1) {
+			position = periodPos + 3;// length of "/**"
+		} else if (atsignPos != -1) {
+			string = string + "\n * ";
+			position = atsignPos;
+		} else if (endPos != -1) {
+			string = "* " + string + "\n";
+			position = endPos;
+		} else {
+			// !!! perhaps this error should not be silent
+			throw new Error("Failed to append to formal comment for comment: " + formalComment);
+		}
+
+		return formalComment.substring(0, position) + periodPlaceHolder + string + formalComment.substring(position);
 	}
-	
-    static int nextDeclID = 0;
-    static String addDeclID(IProgramElement decl, String formalComment) {
-        String declID = "" + ++nextDeclID;
-        declIDTable.put(declID, decl);
-        return addToFormal(formalComment, Config.DECL_ID_STRING + declID + Config.DECL_ID_TERMINATOR);
-    }
-
-    /**
-     * We want to go:
-     *   just before the first period
-     *   just before the first @
-     *   just before the end of the comment
-     *
-     * Adds a place holder for the period ('#') if one will need to be
-     * replaced.
-     */
-    static String addToFormal(String formalComment, String string) {
-       if(string == null || string.equals("")) {
-          return formalComment;
-       }
-        //boolean appendPeriod = true;
-        if ( (formalComment == null) || formalComment.equals("")) {
-            //formalComment = "/**\n * . \n */\n";
-            formalComment = "/**\n * \n */\n";
-            //appendPeriod = false;
-        }
-        formalComment = formalComment.trim();
-
-        int atsignPos = formalComment.indexOf('@');
-        int    endPos = formalComment.indexOf("*/");
-        int periodPos = formalComment.indexOf("/**");
-        int position  = 0;
-        String periodPlaceHolder = "";
-        if ( periodPos != -1 ) {
-            position = periodPos + 3;// length of "/**"
-        }
-        else if ( atsignPos != -1 ) {
-            string = string + "\n * ";
-            position = atsignPos;
-        }
-        else if ( endPos != -1 ) {
-            string = "* " + string + "\n";
-            position = endPos;
-        }
-        else {
-            // !!! perhaps this error should not be silent
-            throw new Error("Failed to append to formal comment for comment: " +
-                formalComment );
-        }
-
-        return
-            formalComment.substring(0, position) + periodPlaceHolder +
-            string +
-            formalComment.substring(position);
-    }
 
 }
@@ -62,7 +62,7 @@ public class Ajde {
 	private IconRegistry iconRegistry;
 	private IRuntimeProperties runtimeProperties;
 	private boolean initialized = false;
-
+	private AsmManager asm;
 	private OptionsFrame optionsFrame = null;
 	private Frame rootFrame = null;
 	private StructureViewPanel fileStructurePanel = null;
@@ -70,7 +70,7 @@ public class Ajde {
 	private EditorAdapter editorAdapter;
 	private StructureViewManager structureViewManager;
 	private StructureSearchManager structureSearchManager;
-	private BuildConfigManager configurationManager;
+	private final BuildConfigManager configurationManager;
 
 	// all to do with building....
 	private ICompilerConfiguration compilerConfig;
@@ -78,6 +78,10 @@ public class Ajde {
 	private IBuildProgressMonitor buildProgressMonitor;
 	private AjCompiler compiler;
 
+	public AsmManager getModel() {
+		return asm;
+	}
+
 	/**
 	 * This class can only be constructured by itself (as a singleton) or by sub-classes.
 	 */
@@ -96,6 +100,7 @@ public class Ajde {
 			INSTANCE.compilerConfig = compilerConfig;
 			INSTANCE.uiBuildMsgHandler = uiBuildMessageHandler;
 			INSTANCE.buildProgressMonitor = monitor;
+			INSTANCE.asm = AsmManager.createNewStructureModel();
 
 			INSTANCE.iconRegistry = iconRegistry;
 			INSTANCE.ideUIAdapter = ideUIAdapter;
@@ -142,8 +147,9 @@ public class Ajde {
 
 	private final BuildConfigListener STRUCTURE_UPDATE_CONFIG_LISTENER = new BuildConfigListener() {
 		public void currConfigChanged(String configFilePath) {
-			if (configFilePath != null)
-				AsmManager.getDefault().readStructureModel(configFilePath);
+			if (configFilePath != null) {
+				Ajde.getDefault().asm.readStructureModel(configFilePath);
+			}
 		}
 
 		public void configsListUpdated(List configsList) {
@@ -234,7 +240,7 @@ public class Ajde {
 		final String classpath;
 		final String[] args;
 		final boolean valid;
-		private Frame rootFrame;
+		private final Frame rootFrame;
 
 		RunProperties(ICompilerConfiguration compilerConfig, IRuntimeProperties runtimeProperties, IUIBuildMessageHandler handler,
 				Frame rootFrame) {
@@ -313,8 +319,8 @@ public class Ajde {
 
 	static class CompilerThread extends Thread {
 
-		private AjCompiler compiler;
-		private boolean buildFresh;
+		private final AjCompiler compiler;
+		private final boolean buildFresh;
 
 		public CompilerThread(AjCompiler compiler, boolean buildFresh) {
 			this.compiler = compiler;
@@ -463,4 +469,20 @@ public class Ajde {
 		}
 		return compiler;
 	}
+
+	public AsmManager getModelForConfigFile(String configFile) {
+		return compiler.getModel();
+		// if ((compiler == null || !compiler.getId().equals(configFile))) {
+		// if (compiler != null) {
+		// // have to remove the incremental state of the previous
+		// // compiler - this will remove it from the
+		// // IncrementalStateManager's
+		// // list
+		// compiler.clearLastState();
+		// }
+		// getMessageHandler().reset();
+		// compiler = new AjCompiler(configFile, getCompilerConfig(), getBuildProgressMonitor(), getMessageHandler());
+		// }
+
+	}
 }
@@ -12,7 +12,6 @@
  *     Helen Hawkins  Converted to new interface (bug 148190) 
  * ******************************************************************/
 
- 
 package org.aspectj.ajde.ui;
 
 import java.util.ArrayList;
@@ -24,53 +23,42 @@ import org.aspectj.asm.IHierarchy;
 import org.aspectj.asm.IProgramElement;
 
 /**
- * @author	Mik Kersten
+ * @author Mik Kersten
  */
 public class StructureSearchManager {
 
 	/**
-	 * @param		pattern		case-sensitive substring of node name
+	 * @param pattern case-sensitive substring of node name
 	 * 
-	 * @return 	null if a corresponding node was not found
+	 * @return null if a corresponding node was not found
 	 */
-	public List findMatches(
-		String pattern, 
-		IProgramElement.Kind kind) {
-		
+	public List findMatches(String pattern, IProgramElement.Kind kind) {
+
 		List matches = new ArrayList();
-		IHierarchy model = AsmManager.getDefault().getHierarchy();
+		IHierarchy model = AsmManager.lastActiveStructureModel.getHierarchy();
 		if (model.getRoot().equals(IHierarchy.NO_STRUCTURE)) {
 			return null;
 		} else {
 			return findMatchesHelper(model.getRoot(), pattern, kind, matches);
 		}
-	}					
-	
-	
-	private List findMatchesHelper(
-		IProgramElement node, 
-		String pattern, 
-		IProgramElement.Kind kind,
-		List matches) {
-			
+	}
+
+	private List findMatchesHelper(IProgramElement node, String pattern, IProgramElement.Kind kind, List matches) {
+
 		if (node != null && node.getName().indexOf(pattern) != -1) {
 			if (kind == null || node.getKind().equals(kind)) {
-				matches.add(node);	
-			} 
+				matches.add(node);
+			}
 		}
 		if (node != null && node.getChildren() != null) {
-			for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
-				IProgramElement nextNode = (IProgramElement)it.next();
-				if (nextNode!=null) {
-					findMatchesHelper(
-							nextNode, 
-							pattern, 
-							kind,
-							matches);
+			for (Iterator it = node.getChildren().iterator(); it.hasNext();) {
+				IProgramElement nextNode = (IProgramElement) it.next();
+				if (nextNode != null) {
+					findMatchesHelper(nextNode, pattern, kind, matches);
 				}
 			}
 		}
-		 
-		return matches;		
+
+		return matches;
 	}
 }
@@ -21,7 +21,6 @@ import java.util.List;
 import org.aspectj.ajde.Ajde;
 import org.aspectj.ajde.ui.internal.NavigationHistoryModel;
 import org.aspectj.ajde.ui.internal.TreeStructureViewBuilder;
-import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IHierarchy;
 import org.aspectj.asm.IHierarchyListener;
 import org.aspectj.asm.IProgramElement;
@@ -33,11 +32,11 @@ import org.aspectj.asm.internal.AspectJElementHierarchy;
  */
 public class StructureViewManager {
 
-	private TreeStructureViewBuilder treeViewBuilder;
+	private final TreeStructureViewBuilder treeViewBuilder;
 	// private String buildConfigFilePath = null;
 
-	private NavigationHistoryModel historyModel = new NavigationHistoryModel();
-	private ArrayList structureViews = new ArrayList();
+	private final NavigationHistoryModel historyModel = new NavigationHistoryModel();
+	private final ArrayList structureViews = new ArrayList();
 	private FileStructureView defaultFileView = null;
 
 	private static final StructureViewProperties DEFAULT_VIEW_PROPERTIES;
@@ -59,7 +58,7 @@ public class StructureViewManager {
 	public StructureViewManager(StructureViewNodeFactory nodeFactory) {
 		treeViewBuilder = new TreeStructureViewBuilder(nodeFactory);
 
-		AsmManager.getDefault().addListener(VIEW_LISTENER);
+		Ajde.getDefault().getModel().addListener(VIEW_LISTENER);
 	}
 
 	public void fireNavigateBackAction(StructureView view) {
@@ -88,7 +87,7 @@ public class StructureViewManager {
 	 * @param newFilePath the canonicalized path to the new file
 	 */
 	public void fireNavigationAction(String newFilePath, int lineNumber) {
-		IProgramElement currNode = AsmManager.getDefault().getHierarchy().findElementForSourceLine(newFilePath, lineNumber);
+		IProgramElement currNode = Ajde.getDefault().getModel().getHierarchy().findElementForSourceLine(newFilePath, lineNumber);
 
 		if (currNode != null) {
 			navigationAction(currNode, true);
@@ -116,7 +115,7 @@ public class StructureViewManager {
 			String newFilePath = node.getSourceLocation().getSourceFile().getAbsolutePath();
 			if (defaultFileView.getSourceFile() != null && !defaultFileView.getSourceFile().equals(newFilePath)) {
 				defaultFileView.setSourceFile(newFilePath);
-				treeViewBuilder.buildView(defaultFileView, AsmManager.getDefault().getHierarchy());
+				treeViewBuilder.buildView(defaultFileView, Ajde.getDefault().getModel().getHierarchy());
 			}
 		}
 
@@ -142,7 +141,7 @@ public class StructureViewManager {
 
 	public void refreshView(StructureView view) {
 		IStructureViewNode activeNode = view.getActiveNode();
-		treeViewBuilder.buildView(view, AsmManager.getDefault().getHierarchy());
+		treeViewBuilder.buildView(view, Ajde.getDefault().getModel().getHierarchy());
 		view.setActiveNode(activeNode);
 	}
 
@@ -177,7 +176,7 @@ public class StructureViewManager {
 			properties = DEFAULT_VIEW_PROPERTIES;
 		FileStructureView view = new FileStructureView(properties);
 		view.setSourceFile(sourceFilePath);
-		treeViewBuilder.buildView(view, AsmManager.getDefault().getHierarchy());
+		treeViewBuilder.buildView(view, Ajde.getDefault().getModel().getHierarchy());
 		structureViews.add(view);
 		return view;
 	}
@@ -11,26 +11,30 @@
  *     Xerox/PARC     initial implementation 
  * ******************************************************************/
 
- 
 package org.aspectj.ajde.ui;
 
-import java.util.*;
+import java.util.Iterator;
+import java.util.List;
 
-import org.aspectj.asm.*;
+import org.aspectj.ajde.Ajde;
+import org.aspectj.asm.AsmManager;
+import org.aspectj.asm.IProgramElement;
+import org.aspectj.asm.IRelationship;
+import org.aspectj.asm.IRelationshipMap;
 
 /**
  * @author Mik Kersten
- */ 
+ */
 public abstract class StructureViewNodeFactory {
 
-	private AbstractIconRegistry iconRegistry;	
+	private final AbstractIconRegistry iconRegistry;
 
 	public StructureViewNodeFactory(AbstractIconRegistry iconRegistry) {
-		this.iconRegistry = iconRegistry;			
+		this.iconRegistry = iconRegistry;
 	}
 
 	public IStructureViewNode createNode(IProgramElement node) {
-		return createNode(node, null);		
+		return createNode(node, null);
 	}
 
 	public IStructureViewNode createNode(IProgramElement node, List children) {
@@ -38,30 +42,25 @@ public abstract class StructureViewNodeFactory {
 
 		IStructureViewNode svNode = createDeclaration(node, icon, children);
 		String nodeHandle = node.getHandleIdentifier();
-		// Don't put relationships on fields as they can then appear twice when building the outline - 
+		// Don't put relationships on fields as they can then appear twice when building the outline -
 		// once under clinit field-set nodes and once under the field declaration.
-		if (nodeHandle != null && !node.getKind().equals(IProgramElement.Kind.FIELD)) {	
-			AsmManager manager = AsmManager.getDefault();
-			IRelationshipMap relMap = (manager==null?null:manager.getRelationshipMap());
-			List relationships = (relMap==null?null:relMap.get(nodeHandle));
+		if (nodeHandle != null && !node.getKind().equals(IProgramElement.Kind.FIELD)) {
+			AsmManager manager = Ajde.getDefault().getModel();
+			IRelationshipMap relMap = (manager == null ? null : manager.getRelationshipMap());
+			List relationships = (relMap == null ? null : relMap.get(nodeHandle));
 			if (relationships != null) {
-				for (Iterator it = relationships.iterator(); it.hasNext(); ) {
-					IRelationship rel = (IRelationship)it.next();
+				for (Iterator it = relationships.iterator(); it.hasNext();) {
+					IRelationship rel = (IRelationship) it.next();
 					if (rel != null && rel.getTargets().size() > 0) {
-						IStructureViewNode relNode = createRelationship(
-							rel, 
-							iconRegistry.getIcon(rel.getKind())
-						);
+						IStructureViewNode relNode = createRelationship(rel, iconRegistry.getIcon(rel.getKind()));
 						if (relNode != null) {
-						svNode.add(relNode, 0);					
-							for (Iterator it2 = rel.getTargets().iterator(); it2.hasNext(); ) {
-								String handle = (String)it2.next();
-								IProgramElement link = AsmManager.getDefault().getHierarchy().findElementForHandle(handle);
+							svNode.add(relNode, 0);
+							for (Iterator it2 = rel.getTargets().iterator(); it2.hasNext();) {
+								String handle = (String) it2.next();
+								IProgramElement link = Ajde.getDefault().getModel().getHierarchy().findElementForHandle(handle);
 								if (link != null) {
-									IStructureViewNode linkNode = createLink(
-										link,   
-										iconRegistry.getStructureIcon(link.getKind(), link.getAccessibility())  
-									);	
+									IStructureViewNode linkNode = createLink(link, iconRegistry.getStructureIcon(link.getKind(),
+											link.getAccessibility()));
 									relNode.add(linkNode);
 								}
 							}
@@ -75,27 +74,26 @@ public abstract class StructureViewNodeFactory {
 
 	/**
 	 * Implementors must override this method in order to create link new nodes.
-	 */ 
+	 */
 	protected abstract IStructureViewNode createLink(IProgramElement node, AbstractIcon icon);
-	
+
 	/**
 	 * Implementors must override this method in order to create new relationship nodes.
 	 * 
 	 * If returned node is null it will not be added to the tree.
-	 */ 	
+	 */
 	protected abstract IStructureViewNode createRelationship(IRelationship relationship, AbstractIcon icon);
 
 	/**
 	 * Implementors must override this method in order to create new nodes.
-	 */ 
+	 */
 	protected abstract IStructureViewNode createDeclaration(IProgramElement node, AbstractIcon icon, List children);
 
 	/**
 	 * Don't show code elements under types since they show under the corresponding initializers.
 	 */
 	public static boolean acceptNode(IProgramElement parent, IProgramElement child) {
-		if (parent.getKind() == IProgramElement.Kind.CLASS 
-			&& child.getKind() == IProgramElement.Kind.CODE) {
+		if (parent.getKind() == IProgramElement.Kind.CLASS && child.getKind() == IProgramElement.Kind.CODE) {
 			return false;
 		} else {
 			return true;
@@ -12,7 +12,6 @@
  *     Helen Hawkins  Converted to new interface (bug 148190)  
  * ******************************************************************/
 
-
 package org.aspectj.ajde.ui.swing;
 
 import java.awt.BorderLayout;
@@ -33,7 +32,6 @@ import javax.swing.border.Border;
 import org.aspectj.ajde.Ajde;
 import org.aspectj.ajde.ui.StructureView;
 import org.aspectj.ajde.ui.StructureViewProperties;
-import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IHierarchy;
 import org.aspectj.asm.IHierarchyListener;
 import org.aspectj.asm.IProgramElement;
@@ -43,179 +41,177 @@ import org.aspectj.bridge.Message;
 public class SimpleStructureViewToolPanel extends JPanel {
 
 	private static final long serialVersionUID = -7573973278642540506L;
-	private StructureView currentView;
-	private JButton separator_button = new JButton();
+	private final StructureView currentView;
+	private final JButton separator_button = new JButton();
 	private boolean hideNonAJEnabled = false;
 	private boolean hideAssociationsEnabled = false;
 	private boolean sortEnabled = false;
 
-    Border border1;
-    Border border2;
-    JButton structureView_button = new JButton();
-    JPanel label_panel = new JPanel();
-    JLabel currConfig_field = new JLabel();
-    JPanel spacer_panel = new JPanel();
-    JPanel jPanel2 = new JPanel();
-    JButton forward_button = new JButton();
-    JPanel navigation_panel = new JPanel();
-    JButton back_button = new JButton();
-    BorderLayout borderLayout1 = new BorderLayout();
-    JPanel buttons_panel = new JPanel();
-    BorderLayout borderLayout2 = new BorderLayout();
-    BorderLayout borderLayout3 = new BorderLayout();
-    BorderLayout borderLayout4 = new BorderLayout();
-
-    public final IHierarchyListener MODEL_LISTENER = new IHierarchyListener() {
-        public void elementsUpdated(IHierarchy model) {
+	Border border1;
+	Border border2;
+	JButton structureView_button = new JButton();
+	JPanel label_panel = new JPanel();
+	JLabel currConfig_field = new JLabel();
+	JPanel spacer_panel = new JPanel();
+	JPanel jPanel2 = new JPanel();
+	JButton forward_button = new JButton();
+	JPanel navigation_panel = new JPanel();
+	JButton back_button = new JButton();
+	BorderLayout borderLayout1 = new BorderLayout();
+	JPanel buttons_panel = new JPanel();
+	BorderLayout borderLayout2 = new BorderLayout();
+	BorderLayout borderLayout3 = new BorderLayout();
+	BorderLayout borderLayout4 = new BorderLayout();
+
+	public final IHierarchyListener MODEL_LISTENER = new IHierarchyListener() {
+		public void elementsUpdated(IHierarchy model) {
 			String path = Ajde.getDefault().getBuildConfigManager().getActiveConfigFile();
-			String fileName = "<no active config>"; 
-			if (path != null) fileName = new File(path).getName();
+			String fileName = "<no active config>";
+			if (path != null)
+				fileName = new File(path).getName();
 			updateCurrConfigLabel(fileName);
-        }
-    };
-    
-    JButton hideNonAJ_button = new JButton();
-    JPanel navigation_panel1 = new JPanel();
-    JButton hideAssociations_button = new JButton();
-    BorderLayout borderLayout5 = new BorderLayout();
-    JButton sort_button = new JButton();
+		}
+	};
+
+	JButton hideNonAJ_button = new JButton();
+	JPanel navigation_panel1 = new JPanel();
+	JButton hideAssociations_button = new JButton();
+	BorderLayout borderLayout5 = new BorderLayout();
+	JButton sort_button = new JButton();
 
 	public SimpleStructureViewToolPanel(StructureView currentView) {
 		this.currentView = currentView;
-		AsmManager.getDefault().addListener(MODEL_LISTENER);
+		Ajde.getDefault().getModel().addListener(MODEL_LISTENER);
 		try {
 			jbInit();
 		} catch (Exception e) {
-        	Message msg = new Message("Could not initialize GUI.",IMessage.ERROR,e,null);
-        	Ajde.getDefault().getMessageHandler().handleMessage(msg);
+			Message msg = new Message("Could not initialize GUI.", IMessage.ERROR, e, null);
+			Ajde.getDefault().getMessageHandler().handleMessage(msg);
 		}
 		updateCurrConfigLabel("<no active config>");
 	}
-  
-    private void updateCurrConfigLabel(String text) {
-    	currConfig_field.setText("  File View (" + text + ")");
-    }
-
-	private void jbInit() throws Exception {
-        border1 = BorderFactory.createBevelBorder(BevelBorder.LOWERED,Color.white,Color.white,new Color(156, 156, 158),new Color(109, 109, 110));
-        border2 = BorderFactory.createEmptyBorder(0,1,0,0);
-
-
-
-        separator_button.setPreferredSize(new Dimension(2, 16));
-        separator_button.setMinimumSize(new Dimension(2, 16));
-        separator_button.setEnabled(false);
-        separator_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
-        separator_button.setMaximumSize(new Dimension(2, 16));
-
 
-        structureView_button.addActionListener(new java.awt.event.ActionListener() {
-            public void actionPerformed(ActionEvent e) {
-                structureView_button_actionPerformed(e);
-            }
-        });
-        structureView_button.setIcon(Ajde.getDefault().getIconRegistry().getStructureViewIcon());
-        structureView_button.setBorder(border2);
-        structureView_button.setToolTipText("Navigate back");
-        structureView_button.setPreferredSize(new Dimension(20, 20));
-        structureView_button.setMinimumSize(new Dimension(20, 20));
-        structureView_button.setMaximumSize(new Dimension(24, 20));
-        currConfig_field.setBackground(SystemColor.control);
-        currConfig_field.setFont(new java.awt.Font("SansSerif", 0, 11));
-        currConfig_field.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
-        //currConfig_field.setEditable(false);
-        currConfig_field.setText("     ");
-
-        forward_button.addActionListener(new java.awt.event.ActionListener() {
-            public void actionPerformed(ActionEvent e) {
-                forward_button_actionPerformed(e);
-            }
-        });
-        forward_button.setIcon(Ajde.getDefault().getIconRegistry().getForwardIcon());
-        forward_button.setToolTipText("Navigate forward");
-        forward_button.setPreferredSize(new Dimension(20, 20));
-        forward_button.setMinimumSize(new Dimension(20, 20));
-        forward_button.setMaximumSize(new Dimension(24, 20));
-        forward_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
-        navigation_panel.setLayout(borderLayout1);
-        back_button.setMaximumSize(new Dimension(24, 20));
-        back_button.setMinimumSize(new Dimension(20, 20));
-        back_button.setPreferredSize(new Dimension(20, 20));
-        back_button.setToolTipText("Navigate back");
-        back_button.setIcon(Ajde.getDefault().getIconRegistry().getBackIcon());
-        back_button.addActionListener(new java.awt.event.ActionListener() {
-            public void actionPerformed(ActionEvent e) {
-                back_button_actionPerformed(e);
-            }
-        });
-        back_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
-        this.setLayout(borderLayout2);
-        buttons_panel.setLayout(borderLayout3);
-        label_panel.setLayout(borderLayout4);
-        hideNonAJ_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
-        hideNonAJ_button.setMaximumSize(new Dimension(24, 20));
-        hideNonAJ_button.setMinimumSize(new Dimension(20, 20));
-        hideNonAJ_button.setPreferredSize(new Dimension(20, 20));
-        hideNonAJ_button.setToolTipText("Hide non-AspectJ members");
-        hideNonAJ_button.setIcon(Ajde.getDefault().getIconRegistry().getHideNonAJIcon());
-        hideNonAJ_button.addActionListener(new java.awt.event.ActionListener() {
-            public void actionPerformed(ActionEvent e) {
-                hideNonAJ_button_actionPerformed(e);
-            }
-        });
-        navigation_panel1.setLayout(borderLayout5);
-        hideAssociations_button.setMaximumSize(new Dimension(24, 20));
-        hideAssociations_button.setMinimumSize(new Dimension(20, 20));
-        hideAssociations_button.setPreferredSize(new Dimension(20, 20));
-        hideAssociations_button.setToolTipText("Hide associations");
-        hideAssociations_button.setIcon(Ajde.getDefault().getIconRegistry().getHideAssociationsIcon());
-        hideAssociations_button.addActionListener(new java.awt.event.ActionListener() {
-            public void actionPerformed(ActionEvent e) {
-                hideAssociations_button_actionPerformed(e);
-            }
-        });
-        hideAssociations_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
-        sort_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
-        sort_button.addActionListener(new java.awt.event.ActionListener() {
-            public void actionPerformed(ActionEvent e) {
-                sort_button_actionPerformed(e);
-            }
-        });
-        sort_button.setIcon(Ajde.getDefault().getIconRegistry().getOrderIcon());
-        sort_button.setToolTipText("Sort member");
-        sort_button.setPreferredSize(new Dimension(20, 20));
-        sort_button.setMinimumSize(new Dimension(20, 20));
-        sort_button.setMaximumSize(new Dimension(24, 20));
-        label_panel.add(currConfig_field,  BorderLayout.CENTER);
-        //label_panel.add(structureView_button,  BorderLayout.WEST);
-        this.add(spacer_panel,  BorderLayout.CENTER);
-        this.add(buttons_panel,  BorderLayout.EAST);
-        buttons_panel.add(navigation_panel, BorderLayout.CENTER);
-        navigation_panel.add(back_button, BorderLayout.CENTER);
-        navigation_panel.add(forward_button, BorderLayout.EAST);
-        navigation_panel.add(jPanel2, BorderLayout.WEST);
-        buttons_panel.add(navigation_panel1,  BorderLayout.WEST);
-        navigation_panel1.add(hideAssociations_button,  BorderLayout.EAST);
-        navigation_panel1.add(hideNonAJ_button,  BorderLayout.CENTER);
-        navigation_panel1.add(sort_button,  BorderLayout.WEST);
-        this.add(label_panel,  BorderLayout.WEST);
+	private void updateCurrConfigLabel(String text) {
+		currConfig_field.setText("  File View (" + text + ")");
+	}
 
+	private void jbInit() throws Exception {
+		border1 = BorderFactory.createBevelBorder(BevelBorder.LOWERED, Color.white, Color.white, new Color(156, 156, 158),
+				new Color(109, 109, 110));
+		border2 = BorderFactory.createEmptyBorder(0, 1, 0, 0);
+
+		separator_button.setPreferredSize(new Dimension(2, 16));
+		separator_button.setMinimumSize(new Dimension(2, 16));
+		separator_button.setEnabled(false);
+		separator_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
+		separator_button.setMaximumSize(new Dimension(2, 16));
+
+		structureView_button.addActionListener(new java.awt.event.ActionListener() {
+			public void actionPerformed(ActionEvent e) {
+				structureView_button_actionPerformed(e);
+			}
+		});
+		structureView_button.setIcon(Ajde.getDefault().getIconRegistry().getStructureViewIcon());
+		structureView_button.setBorder(border2);
+		structureView_button.setToolTipText("Navigate back");
+		structureView_button.setPreferredSize(new Dimension(20, 20));
+		structureView_button.setMinimumSize(new Dimension(20, 20));
+		structureView_button.setMaximumSize(new Dimension(24, 20));
+		currConfig_field.setBackground(SystemColor.control);
+		currConfig_field.setFont(new java.awt.Font("SansSerif", 0, 11));
+		currConfig_field.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
+		// currConfig_field.setEditable(false);
+		currConfig_field.setText("     ");
+
+		forward_button.addActionListener(new java.awt.event.ActionListener() {
+			public void actionPerformed(ActionEvent e) {
+				forward_button_actionPerformed(e);
+			}
+		});
+		forward_button.setIcon(Ajde.getDefault().getIconRegistry().getForwardIcon());
+		forward_button.setToolTipText("Navigate forward");
+		forward_button.setPreferredSize(new Dimension(20, 20));
+		forward_button.setMinimumSize(new Dimension(20, 20));
+		forward_button.setMaximumSize(new Dimension(24, 20));
+		forward_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
+		navigation_panel.setLayout(borderLayout1);
+		back_button.setMaximumSize(new Dimension(24, 20));
+		back_button.setMinimumSize(new Dimension(20, 20));
+		back_button.setPreferredSize(new Dimension(20, 20));
+		back_button.setToolTipText("Navigate back");
+		back_button.setIcon(Ajde.getDefault().getIconRegistry().getBackIcon());
+		back_button.addActionListener(new java.awt.event.ActionListener() {
+			public void actionPerformed(ActionEvent e) {
+				back_button_actionPerformed(e);
+			}
+		});
+		back_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
+		this.setLayout(borderLayout2);
+		buttons_panel.setLayout(borderLayout3);
+		label_panel.setLayout(borderLayout4);
+		hideNonAJ_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
+		hideNonAJ_button.setMaximumSize(new Dimension(24, 20));
+		hideNonAJ_button.setMinimumSize(new Dimension(20, 20));
+		hideNonAJ_button.setPreferredSize(new Dimension(20, 20));
+		hideNonAJ_button.setToolTipText("Hide non-AspectJ members");
+		hideNonAJ_button.setIcon(Ajde.getDefault().getIconRegistry().getHideNonAJIcon());
+		hideNonAJ_button.addActionListener(new java.awt.event.ActionListener() {
+			public void actionPerformed(ActionEvent e) {
+				hideNonAJ_button_actionPerformed(e);
+			}
+		});
+		navigation_panel1.setLayout(borderLayout5);
+		hideAssociations_button.setMaximumSize(new Dimension(24, 20));
+		hideAssociations_button.setMinimumSize(new Dimension(20, 20));
+		hideAssociations_button.setPreferredSize(new Dimension(20, 20));
+		hideAssociations_button.setToolTipText("Hide associations");
+		hideAssociations_button.setIcon(Ajde.getDefault().getIconRegistry().getHideAssociationsIcon());
+		hideAssociations_button.addActionListener(new java.awt.event.ActionListener() {
+			public void actionPerformed(ActionEvent e) {
+				hideAssociations_button_actionPerformed(e);
+			}
+		});
+		hideAssociations_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
+		sort_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
+		sort_button.addActionListener(new java.awt.event.ActionListener() {
+			public void actionPerformed(ActionEvent e) {
+				sort_button_actionPerformed(e);
+			}
+		});
+		sort_button.setIcon(Ajde.getDefault().getIconRegistry().getOrderIcon());
+		sort_button.setToolTipText("Sort member");
+		sort_button.setPreferredSize(new Dimension(20, 20));
+		sort_button.setMinimumSize(new Dimension(20, 20));
+		sort_button.setMaximumSize(new Dimension(24, 20));
+		label_panel.add(currConfig_field, BorderLayout.CENTER);
+		// label_panel.add(structureView_button, BorderLayout.WEST);
+		this.add(spacer_panel, BorderLayout.CENTER);
+		this.add(buttons_panel, BorderLayout.EAST);
+		buttons_panel.add(navigation_panel, BorderLayout.CENTER);
+		navigation_panel.add(back_button, BorderLayout.CENTER);
+		navigation_panel.add(forward_button, BorderLayout.EAST);
+		navigation_panel.add(jPanel2, BorderLayout.WEST);
+		buttons_panel.add(navigation_panel1, BorderLayout.WEST);
+		navigation_panel1.add(hideAssociations_button, BorderLayout.EAST);
+		navigation_panel1.add(hideNonAJ_button, BorderLayout.CENTER);
+		navigation_panel1.add(sort_button, BorderLayout.WEST);
+		this.add(label_panel, BorderLayout.WEST);
 
 	}
 
-    private void forward_button_actionPerformed(ActionEvent e) {
-    	Ajde.getDefault().getStructureViewManager().fireNavigateForwardAction(currentView);
-    }
+	private void forward_button_actionPerformed(ActionEvent e) {
+		Ajde.getDefault().getStructureViewManager().fireNavigateForwardAction(currentView);
+	}
 
-    private void back_button_actionPerformed(ActionEvent e) {
-    	Ajde.getDefault().getStructureViewManager().fireNavigateBackAction(currentView);
-    }
+	private void back_button_actionPerformed(ActionEvent e) {
+		Ajde.getDefault().getStructureViewManager().fireNavigateBackAction(currentView);
+	}
 
-    void structureView_button_actionPerformed(ActionEvent e) {
+	void structureView_button_actionPerformed(ActionEvent e) {
 
-    }
+	}
 
-    private void hideNonAJ_button_actionPerformed(ActionEvent e) {
+	private void hideNonAJ_button_actionPerformed(ActionEvent e) {
 		if (hideNonAJEnabled) {
 			hideNonAJ_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
 			hideNonAJEnabled = false;
@@ -223,42 +219,34 @@ public class SimpleStructureViewToolPanel extends JPanel {
 		} else {
 			hideNonAJ_button.setBorder(AjdeWidgetStyles.LOWERED_BEVEL_BORDER);
 			hideNonAJEnabled = true;
-			currentView.getViewProperties().setFilteredMemberKinds(
-				IProgramElement.Kind.getNonAJMemberKinds()
-			);
+			currentView.getViewProperties().setFilteredMemberKinds(IProgramElement.Kind.getNonAJMemberKinds());
 		}
 		Ajde.getDefault().getStructureViewManager().refreshView(currentView);
-    }
+	}
 
-    private void hideAssociations_button_actionPerformed(ActionEvent e) {
+	private void hideAssociations_button_actionPerformed(ActionEvent e) {
 		if (hideAssociationsEnabled) {
 			hideAssociations_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
 			hideAssociationsEnabled = false;
-			currentView.getViewProperties().setRelations(
-				Ajde.getDefault().getStructureViewManager().getAvailableRelations()
-			);
+			currentView.getViewProperties().setRelations(Ajde.getDefault().getStructureViewManager().getAvailableRelations());
 		} else {
 			hideAssociations_button.setBorder(AjdeWidgetStyles.LOWERED_BEVEL_BORDER);
 			hideAssociationsEnabled = true;
 			currentView.getViewProperties().setRelations(new ArrayList());
 		}
 		Ajde.getDefault().getStructureViewManager().refreshView(currentView);
-    }
+	}
 
-    private void sort_button_actionPerformed(ActionEvent e) {
+	private void sort_button_actionPerformed(ActionEvent e) {
 		if (sortEnabled) {
 			sort_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
 			sortEnabled = false;
-			currentView.getViewProperties().setSorting(
-				StructureViewProperties.Sorting.DECLARATIONAL
-			);
+			currentView.getViewProperties().setSorting(StructureViewProperties.Sorting.DECLARATIONAL);
 		} else {
 			sort_button.setBorder(AjdeWidgetStyles.LOWERED_BEVEL_BORDER);
 			sortEnabled = true;
-			currentView.getViewProperties().setSorting(
-				StructureViewProperties.Sorting.ALPHABETICAL
-			);
+			currentView.getViewProperties().setSorting(StructureViewProperties.Sorting.ALPHABETICAL);
 		}
 		Ajde.getDefault().getStructureViewManager().refreshView(currentView);
-    }
+	}
 }
@@ -32,7 +32,6 @@ import org.aspectj.ajde.ui.javaoptions.JavaComplianceOptionsPanel;
 import org.aspectj.ajde.ui.javaoptions.JavaDebugOptionsPanel;
 import org.aspectj.ajde.ui.javaoptions.JavaOtherOptionsPanel;
 import org.aspectj.ajde.ui.swing.MultiStructureViewPanel;
-import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IHierarchy;
 import org.aspectj.asm.IHierarchyListener;
 import org.aspectj.tools.ajbrowser.core.BrowserBuildProgressMonitor;
@@ -98,7 +97,7 @@ public class BrowserManager {
 
 			setUpConfigFiles(configFilesArgs);
 
-			AsmManager.getDefault().addListener(VIEW_LISTENER);
+			Ajde.getDefault().getModel().addListener(VIEW_LISTENER);
 
 		} catch (Throwable t) {
 			t.printStackTrace();
