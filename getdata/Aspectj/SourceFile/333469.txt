@@ -0,0 +1,10 @@
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+
+public class MyList extends ArrayList<Integer> {
+	public static void main(String []argv) throws Exception {
+		Field f = MyList.class.getDeclaredField("serialVersionUID");
+		f.setAccessible(true);
+		System.out.println("ser="+f.getLong(new MyList()));
+	}
+}
\ No newline at end of file
@@ -0,0 +1,7 @@
+import java.io.Serializable;
+
+aspect MyList_Serializable {
+  declare parents : MyList implements Serializable;
+
+  private static final long MyList.serialVersionUID = 1L; // causes compiler failure
+}
\ No newline at end of file
@@ -21,6 +21,10 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
  */
 public class Ajc1611Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	public void testGenericsAndItds_333469() {
+		runTest("pr333469");
+	}
+
 	public void testMissingType_332388() {
 		runTest("pr332388");
 	}
@@ -22,6 +22,13 @@
      </compile>
   </ajc-test>
 
+  <ajc-test dir="bugs1611/pr333469" title="pr333469">
+     <compile files="MyList.java MyList_Serializable.java" options="-1.5"/>
+     <run class="MyList">
+     <stdout><line text="ser=1"/></stdout>
+     </run>
+  </ajc-test>
+  
   <ajc-test dir="bugs1611/pr332388_2" title="pr332388 - 2">
      <compile files="M.java" outjar="M.jar" options="-1.5"/>
      <compile files="A.java" classpath="M.jar" outjar="A.jar" options="-1.5"/>
@@ -209,9 +209,25 @@ public class CrosscuttingMembers {
 			// Looking it up ensures we get the annotations - the accessedMembers are just retrieved from the attribute and
 			// don't have that information
 			ResolvedMember resolvedMember = world.resolve(member);
+
+			// pr333469
+			// If the member is for an ITD (e.g. serialVersionUID) then during resolution we may resolve it on
+			// a supertype because it doesn't yet exist on the target.
+			// For example: MyList extends ArrayList<String> and the ITD is on MyList - after resolution it may be:
+			// ArrayList<String>.serialVersionUID, we need to avoid that happening
+
 			if (resolvedMember == null) {
 				// can happen for ITDs - are there many privileged access ITDs??
 				resolvedMember = member;
+				if (resolvedMember.hasBackingGenericMember()) {
+					resolvedMember = resolvedMember.getBackingGenericMember();
+				}
+			} else {
+				UnresolvedType unresolvedDeclaringType = member.getDeclaringType().getRawType();
+				UnresolvedType resolvedDeclaringType = resolvedMember.getDeclaringType().getRawType();
+				if (!unresolvedDeclaringType.equals(resolvedDeclaringType)) {
+					resolvedMember = member;
+				}
 			}
 			PrivilegedAccessMunger privilegedAccessMunger = new PrivilegedAccessMunger(resolvedMember,
 					version >= WeaverVersionInfo.WEAVER_VERSION_AJ169);
