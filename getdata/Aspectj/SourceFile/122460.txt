@@ -0,0 +1,6 @@
+package a;
+aspect A {
+  before():staticinitialization(!A) {
+    System.out.println("intercepted "+thisJoinPoint.getSignature().getDeclaringType());
+  }
+}
@@ -0,0 +1,6 @@
+package code;
+public class Code {
+  public static void main(String[] argv) {
+    new runner.Runner().run();
+  }
+}
@@ -0,0 +1,6 @@
+package runner;
+public class Runner {
+  public void run() {
+    System.out.println("running");
+  }
+}
@@ -0,0 +1,7 @@
+<aspectj>
+<aspects>
+ <aspect name="a.A"/>
+</aspects>
+<weaver>
+</weaver>
+</aspectj>
@@ -0,0 +1,7 @@
+<aspectj>
+<aspects>
+ <aspect name="a.A" scope="!runner.Runner AND code.Code"/>
+</aspects>
+<weaver>
+</weaver>
+</aspectj>
@@ -0,0 +1,7 @@
+<aspectj>
+<aspects>
+ <aspect name="a.A" scope="!*"/>
+</aspects>
+<weaver>
+</weaver>
+</aspectj>
@@ -18,6 +18,21 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc169Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	// control test - weaves everything
+	public void testScopingLTW_122460_1() {
+		runTest("scoping ltw - 1");
+	}
+
+	// scoped to one type
+	public void testScopingLTW_122460_2() {
+		runTest("scoping ltw - 2");
+	}
+
+	// scope is '!*' - nothing woven
+	public void testScopingLTW_122460_3() {
+		runTest("scoping ltw - 3");
+	}
+
 	public void testDeclareSoftCall_307009_1() {
 		runTest("declare soft and call - 1");
 	}
@@ -2,6 +2,39 @@
 
 <suite>
 
+  <ajc-test dir="bugs169/pr122460/one" title="scoping ltw - 3">
+     <compile files="A.java" options="-1.5 -Xlint:ignore" outjar="aspects.jar"/>
+     <compile files="Code.java Runner.java"/>
+     <run class="code.Code" ltw="aop_none.xml" classpath="aspects.jar">
+     <stdout>
+     <line text="running"/>
+     </stdout>
+     </run>
+  </ajc-test>
+  
+  <ajc-test dir="bugs169/pr122460/one" title="scoping ltw - 1">
+     <compile files="A.java" options="-1.5 -Xlint:ignore" outjar="aspects.jar"/>
+     <compile files="Code.java Runner.java"/>
+     <run class="code.Code" ltw="aop.xml" classpath="aspects.jar">
+     <stdout>
+     <line text="intercepted class code.Code"/>
+     <line text="intercepted class runner.Runner"/>
+     <line text="running"/>
+     </stdout>
+     </run>
+  </ajc-test>
+  
+  <ajc-test dir="bugs169/pr122460/one" title="scoping ltw - 2">
+     <compile files="A.java" options="-1.5 -Xlint:ignore" outjar="aspects.jar"/>
+     <compile files="Code.java Runner.java"/>
+     <run class="code.Code" ltw="aop_codeonly.xml" classpath="aspects.jar">
+     <stdout>
+     <line text="intercepted class code.Code"/>
+     <line text="running"/>
+     </stdout>
+     </run>
+  </ajc-test>
+  
    <ajc-test dir="bugs169/pr307009" title="declare soft and call - 1">
    	<compile files="Test.java Test2.java Ann.java Bug.aj" options="-1.5 -showWeaveInfo">
    		<message kind="weave" text="Softening exceptions in type 'Test' (Test.java:4) as defined by aspect 'Bug' (Bug.aj:3)"/>
@@ -907,7 +907,7 @@ public class BcelWorld extends World implements Repository {
 			return;
 		}
 		if (!xmlFiles.isEmpty()) {
-			xmlConfiguration = new WeavingXmlConfig(this);
+			xmlConfiguration = new WeavingXmlConfig(this, WeavingXmlConfig.MODE_COMPILE);
 		}
 		for (File xmlfile : xmlFiles) {
 			try {
@@ -921,6 +921,17 @@ public class BcelWorld extends World implements Repository {
 		}
 	}
 
+	/**
+	 * Add a scoped aspects where the scoping was defined in an aop.xml file and this world is being used in a LTW configuration
+	 */
+	public void addScopedAspect(String name, String scope) {
+		this.isXmlConfiguredWorld = true;
+		if (xmlConfiguration == null) {
+			xmlConfiguration = new WeavingXmlConfig(this, WeavingXmlConfig.MODE_LTW);
+		}
+		xmlConfiguration.addScopedAspect(name, scope);
+	}
+
 	public void setXmlConfigured(boolean b) {
 		this.isXmlConfiguredWorld = b;
 	}
@@ -956,11 +967,18 @@ public class BcelWorld extends World implements Repository {
 	 */
 	static class WeavingXmlConfig {
 
+		final static int MODE_COMPILE = 1;
+		final static int MODE_LTW = 2;
+
+		private int mode;
+
 		private boolean initialized = false; // Lazily done
 		private List<Definition> definitions = new ArrayList<Definition>();
 
 		private List<String> resolvedIncludedAspects = new ArrayList<String>();
 		private Map<String, TypePattern> scopes = new HashMap<String, TypePattern>();
+
+		// these are not set for LTW mode (exclusion of these fast match patterns is handled before the weaver/world are used)
 		private List<String> includedFastMatchPatterns = Collections.emptyList();
 		private List<TypePattern> includedPatterns = Collections.emptyList();
 		private List<String> excludedFastMatchPatterns = Collections.emptyList();
@@ -968,14 +986,33 @@ public class BcelWorld extends World implements Repository {
 
 		private BcelWorld world;
 
-		public WeavingXmlConfig(BcelWorld bcelWorld) {
+		public WeavingXmlConfig(BcelWorld bcelWorld, int mode) {
 			this.world = bcelWorld;
+			this.mode = mode;
 		}
 
 		public void add(Definition d) {
 			definitions.add(d);
 		}
 
+		public void addScopedAspect(String aspectName, String scope) {
+			ensureInitialized();
+			resolvedIncludedAspects.add(aspectName);
+			try {
+				TypePattern scopePattern = new PatternParser(scope).parseTypePattern();
+				scopePattern.resolve(world);
+				scopes.put(aspectName, scopePattern);
+				if (!world.getMessageHandler().isIgnoring(IMessage.INFO)) {
+					world.getMessageHandler().handleMessage(
+							MessageUtil.info("Aspect '" + aspectName + "' is scoped to apply against types matching pattern '"
+									+ scopePattern.toString() + "'"));
+				}
+			} catch (Exception e) {
+				world.getMessageHandler().handleMessage(
+						MessageUtil.error("Unable to parse scope as type pattern.  Scope was '" + scope + "': " + e.getMessage()));
+			}
+		}
+
 		public void ensureInitialized() {
 			if (!initialized) {
 				try {
@@ -1071,6 +1108,9 @@ public class BcelWorld extends World implements Repository {
 		// Since if the weaver is seeing it during this kind of build, the type is implicitly included. So all we should check
 		// for is exclusion
 		public boolean excludesType(ResolvedType type) {
+			if (mode == MODE_LTW) {
+				return false;
+			}
 			String typename = type.getName();
 			boolean excluded = false;
 			for (String excludedPattern : excludedFastMatchPatterns) {
@@ -1089,6 +1129,7 @@ public class BcelWorld extends World implements Repository {
 			}
 			return excluded;
 		}
+
 	}
 
 	public TypeMap getTypeMap() {
@@ -78,10 +78,10 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 	private List<String> includeExactName = new ArrayList<String>();
 	private boolean includeStar = false;
 
-	private List m_aspectExcludeTypePattern = new ArrayList();
-	private List m_aspectExcludeStartsWith = new ArrayList();
-	private List m_aspectIncludeTypePattern = new ArrayList();
-	private List m_aspectIncludeStartsWith = new ArrayList();
+	private List<TypePattern> m_aspectExcludeTypePattern = new ArrayList<TypePattern>();
+	private List<String> m_aspectExcludeStartsWith = new ArrayList<String>();
+	private List<TypePattern> m_aspectIncludeTypePattern = new ArrayList<TypePattern>();
+	private List<String> m_aspectIncludeStartsWith = new ArrayList<String>();
 
 	private StringBuffer namespace;
 	private IWeavingContext weavingContext;
@@ -201,12 +201,12 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 	 * @param weaver
 	 * @param loader
 	 */
-	List parseDefinitions(final ClassLoader loader) {
+	List<Definition> parseDefinitions(final ClassLoader loader) {
 		if (trace.isTraceEnabled()) {
 			trace.enter("parseDefinitions", this);
 		}
 
-		List definitions = new ArrayList();
+		List<Definition> definitions = new ArrayList<Definition>();
 		try {
 			info("register classloader " + getClassLoaderName(loader));
 			// TODO av underoptimized: we will parse each XML once per CL that see it
@@ -242,12 +242,12 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 						error("malformed definition url: " + nextDefinition);
 					}
 				} else {
-					Enumeration xmls = weavingContext.getResources(nextDefinition);
+					Enumeration<URL> xmls = weavingContext.getResources(nextDefinition);
 					// System.out.println("? registerDefinitions: found-aop.xml=" + xmls.hasMoreElements() + ", loader=" + loader);
 
-					Set seenBefore = new HashSet();
+					Set<URL> seenBefore = new HashSet<URL>();
 					while (xmls.hasMoreElements()) {
-						URL xml = (URL) xmls.nextElement();
+						URL xml = xmls.nextElement();
 						if (trace.isTraceEnabled()) {
 							trace.event("parseDefinitions", this, xml);
 						}
@@ -275,7 +275,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 		return definitions;
 	}
 
-	private boolean registerDefinitions(final BcelWeaver weaver, final ClassLoader loader, List definitions) {
+	private boolean registerDefinitions(final BcelWeaver weaver, final ClassLoader loader, List<Definition> definitions) {
 		if (trace.isTraceEnabled()) {
 			trace.enter("registerDefinitions", this, definitions);
 		}
@@ -388,12 +388,10 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 		// TODO proceedOnError option
 	}
 
-	private void registerAspectExclude(final BcelWeaver weaver, final ClassLoader loader, final List definitions) {
+	private void registerAspectExclude(final BcelWeaver weaver, final ClassLoader loader, final List<Definition> definitions) {
 		String fastMatchInfo = null;
-		for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
-			Definition definition = (Definition) iterator.next();
-			for (Iterator iterator1 = definition.getAspectExcludePatterns().iterator(); iterator1.hasNext();) {
-				String exclude = (String) iterator1.next();
+		for (Definition definition : definitions) {
+			for (String exclude : definition.getAspectExcludePatterns()) {
 				TypePattern excludePattern = new PatternParser(exclude).parseTypePattern();
 				m_aspectExcludeTypePattern.add(excludePattern);
 				fastMatchInfo = looksLikeStartsWith(exclude);
@@ -404,12 +402,10 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 		}
 	}
 
-	private void registerAspectInclude(final BcelWeaver weaver, final ClassLoader loader, final List definitions) {
+	private void registerAspectInclude(final BcelWeaver weaver, final ClassLoader loader, final List<Definition> definitions) {
 		String fastMatchInfo = null;
-		for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
-			Definition definition = (Definition) iterator.next();
-			for (Iterator iterator1 = definition.getAspectIncludePatterns().iterator(); iterator1.hasNext();) {
-				String include = (String) iterator1.next();
+		for (Definition definition : definitions) {
+			for (String include : definition.getAspectIncludePatterns()) {
 				TypePattern includePattern = new PatternParser(include).parseTypePattern();
 				m_aspectIncludeTypePattern.add(includePattern);
 				fastMatchInfo = looksLikeStartsWith(include);
@@ -438,7 +434,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 	 * @param loader
 	 * @param definitions
 	 */
-	private boolean registerAspects(final BcelWeaver weaver, final ClassLoader loader, final List definitions) {
+	private boolean registerAspects(final BcelWeaver weaver, final ClassLoader loader, final List<Definition> definitions) {
 		if (trace.isTraceEnabled()) {
 			trace.enter("registerAspects", this, new Object[] { weaver, loader, definitions });
 		}
@@ -449,21 +445,25 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 
 		// iterate aspectClassNames
 		// exclude if in any of the exclude list
-		for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
-			Definition definition = (Definition) iterator.next();
-			for (Iterator aspects = definition.getAspectClassNames().iterator(); aspects.hasNext();) {
-				String aspectClassName = (String) aspects.next();
+		for (Definition definition : definitions) {
+			for (String aspectClassName : definition.getAspectClassNames()) {
 				if (acceptAspect(aspectClassName)) {
 					info("register aspect " + aspectClassName);
 					// System.err.println("? ClassLoaderWeavingAdaptor.registerAspects() aspectName=" + aspectClassName +
 					// ", loader=" + loader + ", bundle=" + weavingContext.getClassLoaderName());
-					/* ResolvedType aspect = */weaver.addLibraryAspect(aspectClassName);
+					// ResolvedType aspect =
+					weaver.addLibraryAspect(aspectClassName);
 
 					// generate key for SC
 					if (namespace == null) {
 						namespace = new StringBuffer(aspectClassName);
 					} else {
-						namespace = namespace.append(";" + aspectClassName);
+						namespace = namespace.append(";").append(aspectClassName);
+					}
+
+					String definedScope = definition.getScopeForAspect(aspectClassName);
+					if (definedScope != null) {
+						((BcelWorld) weaver.getWorld()).addScopedAspect(aspectClassName, definedScope);
 					}
 				} else {
 					// warn("aspect excluded: " + aspectClassName);
@@ -474,8 +474,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 
 		// iterate concreteAspects
 		// exclude if in any of the exclude list - note that the user defined name matters for that to happen
-		for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
-			Definition definition = (Definition) iterator.next();
+		for (Definition definition : definitions) {
 			for (Definition.ConcreteAspect concreteAspect : definition.getConcreteAspects()) {
 				if (acceptAspect(concreteAspect.name)) {
 					info("define aspect " + concreteAspect.name);
@@ -859,13 +858,13 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 		// EXCLUDE: if one match then reject
 		String fastClassName = aspectClassName.replace('/', '.').replace('.', '$');
 		for (int i = 0; i < m_aspectExcludeStartsWith.size(); i++) {
-			if (fastClassName.startsWith((String) m_aspectExcludeStartsWith.get(i))) {
+			if (fastClassName.startsWith(m_aspectExcludeStartsWith.get(i))) {
 				return false;
 			}
 		}
 		// INCLUDE: if one match then accept
 		for (int i = 0; i < m_aspectIncludeStartsWith.size(); i++) {
-			if (fastClassName.startsWith((String) m_aspectIncludeStartsWith.get(i))) {
+			if (fastClassName.startsWith(m_aspectIncludeStartsWith.get(i))) {
 				return true;
 			}
 		}
@@ -17,6 +17,7 @@ import java.util.Enumeration;
 import java.util.List;
 
 import org.aspectj.weaver.bcel.BcelWeakClassLoaderReference;
+import org.aspectj.weaver.loadtime.definition.Definition;
 import org.aspectj.weaver.tools.Trace;
 import org.aspectj.weaver.tools.TraceFactory;
 import org.aspectj.weaver.tools.WeavingAdaptor;
@@ -34,8 +35,8 @@ public class DefaultWeavingContext implements IWeavingContext {
 	private static Trace trace = TraceFactory.getTraceFactory().getTrace(DefaultWeavingContext.class);
 
 	/**
-	 * Construct a new WeavingContext to use the specified ClassLoader
-	 * This is the constructor which should be used.
+	 * Construct a new WeavingContext to use the specified ClassLoader This is the constructor which should be used.
+	 * 
 	 * @param loader
 	 */
 	public DefaultWeavingContext(ClassLoader loader) {
@@ -62,11 +63,11 @@ public class DefaultWeavingContext implements IWeavingContext {
 	 */
 	public String getClassLoaderName() {
 		ClassLoader loader = getClassLoader();
-    	return ((loader!=null)?loader.getClass().getName()+"@"+Integer.toHexString(System.identityHashCode(loader)):"null");
+		return ((loader != null) ? loader.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(loader))
+				: "null");
 	}
-	
 
-	public ClassLoader getClassLoader() { 
+	public ClassLoader getClassLoader() {
 		return loaderRef.getClassLoader();
 	}
 
@@ -74,55 +75,63 @@ public class DefaultWeavingContext implements IWeavingContext {
 	 * @return filename
 	 */
 	public String getFile(URL url) {
-    	return url.getFile();
+		return url.getFile();
 	}
 
 	/**
-	 * @return unqualifiedclassname@hashcode 
+	 * @return unqualifiedclassname@hashcode
 	 */
-	public String getId () {
+	public String getId() {
 		if (shortName == null) {
-			shortName = getClassLoaderName().replace('$','.');
+			shortName = getClassLoaderName().replace('$', '.');
 			int index = shortName.lastIndexOf(".");
-			if (index!=-1) {
+			if (index != -1) {
 				shortName = shortName.substring(index + 1);
 			}
 		}
 		return shortName;
 	}
-	
-	public String getSuffix () {
+
+	public String getSuffix() {
 		return getClassLoaderName();
 	}
 
 	public boolean isLocallyDefined(String classname) {
-        String asResource = classname.replace('.', '/').concat(".class");
-        ClassLoader loader = getClassLoader();
-        URL localURL = loader.getResource(asResource);
-        if (localURL == null) return false;
+		String asResource = classname.replace('.', '/').concat(".class");
+		ClassLoader loader = getClassLoader();
+		URL localURL = loader.getResource(asResource);
+		if (localURL == null) {
+			return false;
+		}
 
 		boolean isLocallyDefined = true;
-		
-        ClassLoader parent = loader.getParent();
-        if (parent != null) {
-            URL parentURL = parent.getResource(asResource);
-            if (localURL.equals(parentURL)) isLocallyDefined =  false;
-        } 
-        return isLocallyDefined;
+
+		ClassLoader parent = loader.getParent();
+		if (parent != null) {
+			URL parentURL = parent.getResource(asResource);
+			if (localURL.equals(parentURL)) {
+				isLocallyDefined = false;
+			}
+		}
+		return isLocallyDefined;
 	}
 
 	/**
 	 * Simply call weaving adaptor back to parse aop.xml
-	 *
+	 * 
 	 * @param weaver
 	 * @param loader
 	 */
-	public List getDefinitions(final ClassLoader loader, final WeavingAdaptor adaptor) {
-	        if (trace.isTraceEnabled()) trace.enter("getDefinitions", this, new Object[] { "goo", adaptor });
-	
-	        List definitions = ((ClassLoaderWeavingAdaptor)adaptor).parseDefinitions(loader);
-	        
-	        if (trace.isTraceEnabled()) trace.exit("getDefinitions",definitions);
-			return definitions;
-	    }
+	public List<Definition> getDefinitions(final ClassLoader loader, final WeavingAdaptor adaptor) {
+		if (trace.isTraceEnabled()) {
+			trace.enter("getDefinitions", this, new Object[] { "goo", adaptor });
+		}
+
+		List<Definition> definitions = ((ClassLoaderWeavingAdaptor) adaptor).parseDefinitions(loader);
+
+		if (trace.isTraceEnabled()) {
+			trace.exit("getDefinitions", definitions);
+		}
+		return definitions;
+	}
 }
