@@ -274,10 +274,19 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 					List newParentTargetMethods = newParentTarget.getType().getMethodsWithoutIterator(false, true);
 					for (Iterator ii = newParentTargetMethods.iterator(); ii.hasNext() && discoveredImpl == null;) {
 						ResolvedMember gen2 = (ResolvedMember) ii.next();
-						if (gen2.getName().equals(o.getName()) && gen2.getParameterSignature().equals(o.getParameterSignature())
-								&& !gen2.isAbstract()) {
-							discoveredImpl = gen2; // Found a valid
-							// implementation !
+						if (gen2.getName().equals(o.getName()) && !gen2.isAbstract()) {
+							String oSig = o.getParameterSignature();
+							// could be a match
+							if (gen2.getParameterSignature().equals(oSig)) {
+								discoveredImpl = gen2;
+							} else {
+								// Does the erasure match? In which case a bridge method will be created later to
+								// satisfy the abstract method
+								if (gen2.hasBackingGenericMember()
+										&& gen2.getBackingGenericMember().getParameterSignature().equals(oSig)) {
+									discoveredImpl = gen2;
+								}
+							}
 						}
 					}
 					if (discoveredImpl == null) {
@@ -1146,7 +1155,7 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 	 * @param unMangledInterMethod the method to bridge 'to' that we have already created in the 'subtype'
 	 * @param clazz the class in which to put the bridge method
 	 * @param paramTypes Parameter types for the bridge method, passed in as an optimization since the caller is likely to have
-	 *            already created them.
+	 *        already created them.
 	 * @param theBridgeMethod
 	 */
 	private void createBridgeMethod(BcelWorld world, NewMethodTypeMunger munger, ResolvedMember unMangledInterMethod,
@@ -0,0 +1,28 @@
+public class Code {
+}
+
+interface Accessor<V>
+{
+    V get(String key);
+
+    void set(String key, V value);
+}
+
+class AccessorImpl<V> implements Accessor<V> {
+
+    public V get(String key) {
+        System.out.println("Calling get(..)");
+        return null;
+    }
+
+    public void set(String key, V value) {
+        System.out.println("Calling set(..)");
+    }
+
+}
+
+class Target {}
+
+aspect TargetEnhancer {
+    declare parents: Target extends AccessorImpl<String>;
+}
@@ -23,6 +23,10 @@ public class Ajc166Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	// runTest("generics bridge");
 	// }
 
+	public void testGenericsDecp_pr282299() {
+		runTest("generics and decp");
+	}
+
 	public void testGenericSigProblem_pr284297() {
 		runTest("generic signature problem");
 	}
@@ -2,10 +2,14 @@
 
 <suite>
 
+  <ajc-test dir="bugs166/pr282299" title="generics and decp">
+     <compile files="Code.java" options="-1.5"/>
+  </ajc-test>
+   
   <ajc-test dir="bugs166/pr284297" title="generic signature problem">
      <compile files="DomainLogic.java DomainObject.java FancyDomainLogic.java" options="-1.5" outjar="code.jar"/>
      <compile files="FancyDomainLogicImpl.java" options="-1.5" classpath="code.jar"/>
-   </ajc-test>
+  </ajc-test>
 
    <ajc-test dir="bugs166/pr283229" title="interfaces and serializable">
      <compile files="Foo.java" options="-1.5 -XaddSerialVersionUID"/>
