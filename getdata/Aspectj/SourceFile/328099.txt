@@ -19,6 +19,7 @@ import java.io.IOException;
 import java.io.PrintWriter;
 import java.net.URL;
 import java.net.URLClassLoader;
+import java.security.ProtectionDomain;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -82,9 +83,10 @@ public class WeavingAdaptor implements IMessageContext {
 	private WeavingAdaptorMessageHolder messageHolder;
 	private boolean abortOnError = false;
 	protected GeneratedClassHandler generatedClassHandler;
-	protected Map generatedClasses = new HashMap(); /* String -> UnwovenClassFile */
+	protected Map<String, IUnwovenClassFile> generatedClasses = new HashMap<String, IUnwovenClassFile>();
 	public BcelObjectType delegateForCurrentClass; // lazily initialized, should be used to prevent parsing bytecode multiple
 	// times
+	protected ProtectionDomain activeProtectionDomain;
 
 	private boolean haveWarnedOnJavax = false;
 
@@ -127,7 +129,7 @@ public class WeavingAdaptor implements IMessageContext {
 	}
 
 	private List getFullClassPath(ClassLoader loader) {
-		List list = new LinkedList();
+		List<String> list = new LinkedList<String>();
 		for (; loader != null; loader = loader.getParent()) {
 			if (loader instanceof URLClassLoader) {
 				URL[] urls = ((URLClassLoader) loader).getURLs();
@@ -143,7 +145,7 @@ public class WeavingAdaptor implements IMessageContext {
 	}
 
 	private List getFullAspectPath(ClassLoader loader) {
-		List list = new LinkedList();
+		List<String> list = new LinkedList<String>();
 		for (; loader != null; loader = loader.getParent()) {
 			if (loader instanceof WeavingClassLoader) {
 				URL[] urls = ((WeavingClassLoader) loader).getAspectURLs();
@@ -517,8 +519,8 @@ public class WeavingAdaptor implements IMessageContext {
 		}
 	}
 
-	private static List makeClasspath(String cp) {
-		List ret = new ArrayList();
+	private static List<String> makeClasspath(String cp) {
+		List<String> ret = new ArrayList<String>();
 		if (cp != null) {
 			StringTokenizer tok = new StringTokenizer(cp, File.pathSeparator);
 			while (tok.hasMoreTokens()) {
@@ -816,15 +818,12 @@ public class WeavingAdaptor implements IMessageContext {
 				public void acceptResult(IUnwovenClassFile result) {
 					if (wovenClass == null) {
 						wovenClass = result;
-
 						String name = result.getClassName();
 						if (shouldDump(name.replace('/', '.'), false)) {
 							dump(name, result.getBytes(), false);
 						}
-					}
-
-					/* Classes generated by weaver e.g. around closure advice */
-					else {
+					} else {
+						// Classes generated by weaver e.g. around closure advice
 						String className = result.getClassName();
 						generatedClasses.put(className, result);
 						generatedClasses.put(wovenClass.getClassName(), result);
@@ -855,4 +854,8 @@ public class WeavingAdaptor implements IMessageContext {
 			};
 		}
 	}
+
+	public void setActiveProtectionDomain(ProtectionDomain protectionDomain) {
+		activeProtectionDomain = protectionDomain;
+	}
 }
\ No newline at end of file
@@ -0,0 +1 @@
+public class X{}
@@ -0,0 +1,10 @@
+<!DOCTYPE aspectj PUBLIC
+        "-//AspectJ//DTD//EN" "http://www.eclipse.org/aspectj/dtd/aspectj.dtd">
+<aspectj>
+  <weaver options="-debug">
+    <include within="foo.bar..*" />
+  </weaver>
+  <aspects>
+    <aspect name="foo.bar.BarAspect"/>
+  </aspects>
+</aspectj>
Binary files differ
Binary files differ
@@ -0,0 +1,95 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>foo.bar</groupId>
+  <artifactId>aspectj-certificate-problem</artifactId>
+  <version>1.0-SNAPSHOT</version>
+  <packaging>jar</packaging>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+  </properties>
+
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration>
+          <compilerVersion>1.6</compilerVersion>
+          <fork>true</fork>
+          <source>1.6</source>
+          <target>1.6</target>
+          <showWarnings>true</showWarnings>
+          <showDeprecation>true</showDeprecation>
+        </configuration>
+      </plugin>
+      <plugin>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <version>2.2</version>
+        <configuration>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+          <archive>
+            <manifest>
+              <mainClass>foo.bar.Foo</mainClass>
+            </manifest>
+          </archive>
+        </configuration>
+        <executions>
+          <execution>
+            <id>make-assembly</id>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jarsigner-plugin</artifactId>
+        <configuration>
+          <keystore>cert/key.store</keystore>
+          <alias>foo</alias>
+          <storepass>foobar</storepass>
+          <archiveDirectory>target</archiveDirectory>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>exec-maven-plugin</artifactId>
+        <version>1.1</version>
+        <executions>
+          <execution>
+            <goals>
+              <goal>exec</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <executable>java</executable>
+          <!-- optional -->
+          <arguments>
+            <argument>-javaagent:/Users/aclement/installs/aspectj1611/lib/aspectjweaver.jar</argument>
+            <argument>-jar</argument>
+            <argument>target/aspectj-certificate-problem-1.0-SNAPSHOT-jar-with-dependencies.jar</argument>
+          </arguments>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+  <dependencies>
+    <dependency>
+      <groupId>org.aspectj</groupId>
+      <artifactId>aspectjrt</artifactId>
+      <version>1.6.10</version>
+    </dependency>
+    <dependency>
+      <groupId>org.aspectj</groupId>
+      <artifactId>aspectjweaver</artifactId>
+      <version>1.6.10</version>
+    </dependency>
+  </dependencies>
+</project>
@@ -0,0 +1,9 @@
+Build the src contents into a jar which will then contain class files and our manifest.  Jar typically code.jar
+
+Then sign the jar with
+ jarsigner -keystore ../cert/key.store -storepass foobar code.jar foo
+
+as per: http://introcs.cs.princeton.edu/85application/jar/sign.html
+
+then you can run it:
+java -javaagent:XXX -classpath code.jar foo.bar.Foo
@@ -0,0 +1,10 @@
+<!DOCTYPE aspectj PUBLIC
+        "-//AspectJ//DTD//EN" "http://www.eclipse.org/aspectj/dtd/aspectj.dtd">
+<aspectj>
+  <weaver>
+    <include within="foo.bar..*" />
+  </weaver>
+  <aspects>
+    <aspect name="foo.bar.BarAspect"/>
+  </aspects>
+</aspectj>
\ No newline at end of file
@@ -0,0 +1,23 @@
+package foo.bar;
+
+import org.aspectj.lang.ProceedingJoinPoint;
+import org.aspectj.lang.annotation.Around;
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.annotation.Pointcut;
+
+@Aspect
+public class BarAspect {
+    @SuppressWarnings("unused")
+    @Pointcut("execution(* foo.bar.Foo.bar())")
+    private void pointcut() {
+    }
+
+    @Around("pointcut()")
+    public Object applyAdvice(ProceedingJoinPoint pjp) throws Throwable {
+        System.out.print("pre...");
+        Object retVal = pjp.proceed();
+        System.out.println("...post");
+        return retVal;
+    }
+
+}
@@ -0,0 +1,18 @@
+package foo.bar;
+
+/**
+ * Hello world!
+ *
+ */
+public class Foo
+{
+    public void bar() {
+        System.out.print(this.getClass().getSimpleName() + ".bar()");
+    }
+
+    public static void main( String[] args )
+    {
+        Foo foo = new Foo();
+        foo.bar();
+    }
+}
@@ -0,0 +1,7 @@
+package foo.bar;
+
+public class FooLaunch {
+  public static void main(String[]argv) {
+    Foo.main(argv);
+  }
+}
@@ -21,38 +21,42 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
  */
 public class Ajc1612Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+	// public void testSignedJarLtw_328099() {
+	// runTest("signed jar ltw");
+	// }
+
 	public void testVerifyError_315398() {
 		runTest("verifyerror");
 	}
-	
+
 	public void testVerifyError_315398_2() {
 		runTest("verifyerror - 2");
 	}
-	
+
 	public void testRawTypePointcut_327134() {
 		runTest("rawtype pointcut");
 	}
-	
+
 	public void testRawTypeWarning_335810() {
 		runTest("rawtype warning");
 	}
-	
-//	public void testDecpGenerics_344005() {
-//		runTest("decp generics");
-//	}
-	
+
+	// public void testDecpGenerics_344005() {
+	// runTest("decp generics");
+	// }
+
 	public void testIllegalAccessError_343051() {
 		runTest("illegalaccesserror");
 	}
-	
+
 	public void testItitNpe_339974() {
 		runTest("itit npe");
 	}
-	
-//	public void testNoImportError_342605() {
-//		runTest("noimporterror");
-//	}
-	
+
+	// public void testNoImportError_342605() {
+	// runTest("noimporterror");
+	// }
+
 	public void testClashingLocalTypes_342323() {
 		runTest("clashing local types");
 	}
@@ -2,6 +2,15 @@
 
 <suite>
 
+<ajc-test dir="bugs1612/pr328099" title="signed jar ltw">
+<compile files="X.java" classpath="code.jar"/>
+<run class="foo.bar.FooLaunch" ltw="aop.xml" classpath="$sandbox/code.jar">
+<stdout>
+<line text="pre...Foo.bar()...post"/>
+</stdout>
+</run>
+</ajc-test>
+
 <ajc-test dir="bugs1612/pr315398" title="verifyerror">
 <compile files="Code.java" options="-1.5">
 </compile>
@@ -37,21 +37,20 @@ public class ClassPreProcessorAgentAdapter implements ClassFileTransformer {
 	}
 
 	/**
-	 * Weaving delegation
+	 * Invokes the weaver to modify some set of input bytes.
 	 * 
 	 * @param loader the defining class loader
-	 * @param className the name of class beeing loaded
-	 * @param classBeingRedefined when hotswap is called
-	 * @param protectionDomain
-	 * @param bytes the bytecode before weaving
-	 * @return the weaved bytecode
+	 * @param className the name of class being loaded
+	 * @param classBeingRedefined is set when hotswap is being attempted
+	 * @param protectionDomain the protection domain for the class being loaded
+	 * @param bytes the incoming bytes (before weaving)
+	 * @return the woven bytes
 	 */
 	public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain,
 			byte[] bytes) throws IllegalClassFormatException {
 		if (classBeingRedefined != null) {
-			System.err.println("INFO: (Enh120375):  AspectJ attempting reweave of '"+className+"'");
+			System.err.println("INFO: (Enh120375):  AspectJ attempting reweave of '" + className + "'");
 		}
-		return s_preProcessor.preProcess(className, bytes, loader);
+		return s_preProcessor.preProcess(className, bytes, loader, protectionDomain);
 	}
-
 }
@@ -13,18 +13,24 @@ package org.aspectj.tools.ajc;
 
 import java.io.ByteArrayOutputStream;
 import java.io.File;
+import java.io.FilePermission;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.PrintStream;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.lang.reflect.ReflectPermission;
 import java.net.URL;
 import java.net.URLClassLoader;
+import java.security.Permission;
+import java.security.Policy;
+import java.security.ProtectionDomain;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.PropertyPermission;
 import java.util.StringTokenizer;
 
 import junit.framework.TestCase;
@@ -622,7 +628,14 @@ public class AjcTestCase extends TestCase {
 			command.append(" ");
 			command.append(args[i]);
 		}
-
+//		try {
+//			// Enable the security manager
+//			Policy.setPolicy(new MyPolicy());
+//			SecurityManager sm = new SecurityManager();
+//			System.setSecurityManager(sm);
+//		} catch (SecurityException se) {
+//			// SecurityManager already set
+//		}
 		ByteArrayOutputStream baosOut = new ByteArrayOutputStream();
 		ByteArrayOutputStream baosErr = new ByteArrayOutputStream();
 		ClassLoader contexClassLoader = Thread.currentThread().getContextClassLoader();
@@ -654,6 +667,15 @@ public class AjcTestCase extends TestCase {
 			// the main method threw an exception...
 			fail("Exception thrown by " + className + ".main(String[]) :" + invTgt.getTargetException());
 		} finally {
+
+//			try {
+//				// Enable the security manager
+//				SecurityManager sm = new SecurityManager();
+//				System.setSecurityManager(null);
+//			} catch (SecurityException se) {
+//				se.printStackTrace();
+//				// SecurityManager already set
+//			}
 			Thread.currentThread().setContextClassLoader(contexClassLoader);
 			stopCapture(baosErr, baosOut);
 			lastRunResult = new RunResult(command.toString(), new String(baosOut.toByteArray()), new String(baosErr.toByteArray()));
@@ -661,6 +683,36 @@ public class AjcTestCase extends TestCase {
 		return lastRunResult;
 	}
 
+//	static class MyPolicy extends Policy {
+//
+//		@Override
+//		public boolean implies(ProtectionDomain domain, Permission permission) {
+//			// if (permission != SecurityConstants.GET_POLICY_PERMISSION) {
+//			// // System.out.println(domain + " " + permission.getName());
+//			// System.out.println(permission.getName());
+//			// }
+//			// if (true) {
+//			// return true;
+//			// }
+//			if (permission instanceof PropertyPermission) {
+//				return true;
+//			}
+//			if (permission instanceof RuntimePermission) {
+//				return true;
+//			}
+//			if (permission instanceof FilePermission) {
+//				// System.out.println(permission);
+//				return true;
+//			}
+//			if (permission instanceof ReflectPermission) {
+//				return true;
+//			}
+//			// System.out.println(permission);
+//			return super.implies(domain, permission);
+//			// return true;
+//		}
+//	}
+
 	/*
 	 * Must create weaving class loader reflectively using new parent so we don't have a reference to a World loaded from CLASSPATH
 	 * which won't be able to resolve Java 5 specific extensions and may cause ClassCastExceptions
@@ -37,7 +37,7 @@ public class AjTest extends TestCase {
 	public void testPreProcess() {
 		ClassLoader loader = new URLClassLoader(new URL[] {}, null);
 		Aj aj = new Aj();
-		aj.preProcess("Junk", new byte[] {}, loader);
+		aj.preProcess("Junk", new byte[] {}, loader, null);
 	}
 
 	public void testGetNamespace() {
@@ -13,6 +13,7 @@ package org.aspectj.weaver.loadtime;
 
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
+import java.security.ProtectionDomain;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -73,7 +74,7 @@ public class Aj implements ClassPreProcessor {
 	 * @param loader
 	 * @return weaved bytes
 	 */
-	public byte[] preProcess(String className, byte[] bytes, ClassLoader loader) {
+	public byte[] preProcess(String className, byte[] bytes, ClassLoader loader, ProtectionDomain protectionDomain) {
 		// TODO AV needs to doc that
 		if (loader == null || className == null || loader.getClass().getName().equals(deleLoader)) {
 			// skip boot loader, null classes (hibernate), or those from a reflection loader
@@ -93,11 +94,16 @@ public class Aj implements ClassPreProcessor {
 						trace.exit("preProcess");
 					return bytes;
 				}
-				byte[] newBytes = weavingAdaptor.weaveClass(className, bytes, false);
-				Dump.dumpOnExit(weavingAdaptor.getMessageHolder(), true);
-				if (trace.isTraceEnabled())
-					trace.exit("preProcess", newBytes);
-				return newBytes;
+				try {
+					weavingAdaptor.setActiveProtectionDomain(protectionDomain);
+					byte[] newBytes = weavingAdaptor.weaveClass(className, bytes, false);
+					Dump.dumpOnExit(weavingAdaptor.getMessageHolder(), true);
+					if (trace.isTraceEnabled())
+						trace.exit("preProcess", newBytes);
+					return newBytes;
+				} finally {
+					weavingAdaptor.setActiveProtectionDomain(null);
+				}
 			}
 
 			/* Don't like to do this but JVMTI swallows all exceptions */
@@ -19,6 +19,7 @@ import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.net.MalformedURLException;
 import java.net.URL;
+import java.security.ProtectionDomain;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.HashMap;
@@ -137,8 +138,12 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 			} catch (Throwable throwable) {
 				throwable.printStackTrace();
 			}
+			if (activeProtectionDomain != null) {
+				defineClass(loaderRef.getClassLoader(), name, bytes, activeProtectionDomain);
+			} else {
+				defineClass(loaderRef.getClassLoader(), name, bytes); // could be done lazily using the hook
 
-			defineClass(loaderRef.getClassLoader(), name, bytes); // could be done lazily using the hook
+			}
 		}
 	}
 
@@ -977,6 +982,9 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 		generatedClasses = new HashMap();
 	}
 
+	private Method defineClassMethod;
+	private Method defineClassWithProtectionDomainMethod;
+
 	private void defineClass(ClassLoader loader, String name, byte[] bytes) {
 		if (trace.isTraceEnabled()) {
 			trace.enter("defineClass", this, new Object[] { loader, name, bytes });
@@ -985,11 +993,45 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 		debug("generating class '" + name + "'");
 
 		try {
-			// TODO av protection domain, and optimize
-			Method defineClass = ClassLoader.class.getDeclaredMethod("defineClass", new Class[] { String.class, bytes.getClass(),
-					int.class, int.class });
-			defineClass.setAccessible(true);
-			clazz = defineClass.invoke(loader, new Object[] { name, bytes, new Integer(0), new Integer(bytes.length) });
+			if (defineClassMethod == null) {
+				defineClassMethod = ClassLoader.class.getDeclaredMethod("defineClass", new Class[] { String.class,
+						bytes.getClass(), int.class, int.class });
+			}
+			defineClassMethod.setAccessible(true);
+			clazz = defineClassMethod.invoke(loader, new Object[] { name, bytes, new Integer(0), new Integer(bytes.length) });
+		} catch (InvocationTargetException e) {
+			if (e.getTargetException() instanceof LinkageError) {
+				warn("define generated class failed", e.getTargetException());
+				// is already defined (happens for X$ajcMightHaveAspect interfaces since aspects are reweaved)
+				// TODO maw I don't think this is OK and
+			} else {
+				warn("define generated class failed", e.getTargetException());
+			}
+		} catch (Exception e) {
+			warn("define generated class failed", e);
+		}
+
+		if (trace.isTraceEnabled()) {
+			trace.exit("defineClass", clazz);
+		}
+	}
+
+	private void defineClass(ClassLoader loader, String name, byte[] bytes, ProtectionDomain protectionDomain) {
+		if (trace.isTraceEnabled()) {
+			trace.enter("defineClass", this, new Object[] { loader, name, bytes, protectionDomain });
+		}
+		Object clazz = null;
+		debug("generating class '" + name + "'");
+
+		try {
+			// System.out.println(">> Defining with protection domain " + name + " pd=" + protectionDomain);
+			if (defineClassWithProtectionDomainMethod == null) {
+				defineClassWithProtectionDomainMethod = ClassLoader.class.getDeclaredMethod("defineClass", new Class[] {
+						String.class, bytes.getClass(), int.class, int.class, ProtectionDomain.class });
+			}
+			defineClassWithProtectionDomainMethod.setAccessible(true);
+			clazz = defineClassWithProtectionDomainMethod.invoke(loader, new Object[] { name, bytes, new Integer(0),
+					new Integer(bytes.length), protectionDomain });
 		} catch (InvocationTargetException e) {
 			if (e.getTargetException() instanceof LinkageError) {
 				warn("define generated class failed", e.getTargetException());
@@ -11,26 +11,29 @@
  *******************************************************************************/
 package org.aspectj.weaver.loadtime;
 
+import java.security.ProtectionDomain;
+
 /**
- * Generic class pre processor interface that allows to separate the AspectJ 5 load time weaving
- * from Java 5 JVMTI interfaces for further use on Java 1.3 / 1.4
- *
+ * Generic class pre processor interface that allows to separate the AspectJ 5 load time weaving from Java 5 JVMTI interfaces for
+ * further use on Java 1.3 / 1.4
+ * 
  * @author Alexandre Vasseur
  */
 public interface ClassPreProcessor {
 
-    /**
-     * Post constructor initialization, usually empty
-     */
-    void initialize();
+	/**
+	 * Post constructor initialization, usually empty
+	 */
+	void initialize();
 
-    /**
-     * Weave
-     *
-     * @param className
-     * @param bytes
-     * @param classLoader
-     * @return
-     */
-    byte[] preProcess(String className, byte[] bytes, ClassLoader classLoader);
+	/**
+	 * Weave
+	 * 
+	 * @param className
+	 * @param bytes
+	 * @param classLoader
+	 * @param a protection domain that may be used for defining extraneous classes generated as part of modifying the one passed in
+	 * @return
+	 */
+	byte[] preProcess(String className, byte[] bytes, ClassLoader classLoader, ProtectionDomain protectionDomain);
 }
\ No newline at end of file
@@ -16,66 +16,66 @@ import com.bea.jvm.ClassLibrary;
 import com.bea.jvm.JVMFactory;
 
 /**
- * BEA JRocket JMAPI agent. 
+ * BEA JRocket JMAPI agent.
  * 
  * Use "-Xmanagement:class=org.aspectj.weaver.loadtime.JRockitAgent"
  */
 public class JRockitAgent implements com.bea.jvm.ClassPreProcessor {
 
 	private ClassPreProcessor preProcessor;
-	
+
 	/*
-	 * This is used to implement the recursion protection offered by JVMTI
-	 * but not by JRockit JMAPI. I we are called to preProcess a class while
-	 * already preProcessing another we will return immediately
+	 * This is used to implement the recursion protection offered by JVMTI but not by JRockit JMAPI. I we are called to preProcess a
+	 * class while already preProcessing another we will return immediately
 	 */
 	private static ThreadLocalStack stack = new ThreadLocalStack();
-	
-	
-	public JRockitAgent () {
+
+	public JRockitAgent() {
 		this.preProcessor = new Aj();
-		
-	    ClassLibrary cl = JVMFactory.getJVM().getClassLibrary();
-        cl.setClassPreProcessor(this);
+
+		ClassLibrary cl = JVMFactory.getJVM().getClassLibrary();
+		cl.setClassPreProcessor(this);
 	}
-	
+
 	public byte[] preProcess(ClassLoader loader, String className, byte[] bytes) {
 		byte[] newBytes = bytes;
 
 		if (stack.empty()) {
 			stack.push(className);
-			newBytes =  preProcessor.preProcess(className, bytes, loader);
+			newBytes = preProcessor.preProcess(className, bytes, loader, null);
 			stack.pop();
 		}
-		
+
 		return newBytes;
 	}
 
 	private static class ThreadLocalStack extends ThreadLocal {
 
-		public boolean empty () {
-			Stack stack = (Stack)get();
+		public boolean empty() {
+			Stack stack = (Stack) get();
 			return stack.empty();
 		}
 
-		public Object peek () {
+		public Object peek() {
 			Object obj = null;
-			Stack stack = (Stack)get();
-			if (!stack.empty()) obj = stack.peek();
+			Stack stack = (Stack) get();
+			if (!stack.empty())
+				obj = stack.peek();
 			return obj;
 		}
-		
-		public void push (Object obj) {
-			Stack stack = (Stack)get();
-			if (!stack.empty() && obj == stack.peek()) throw new RuntimeException(obj.toString());
+
+		public void push(Object obj) {
+			Stack stack = (Stack) get();
+			if (!stack.empty() && obj == stack.peek())
+				throw new RuntimeException(obj.toString());
 			stack.push(obj);
 		}
-		
-		public Object pop () {
-			Stack stack = (Stack)get();
+
+		public Object pop() {
+			Stack stack = (Stack) get();
 			return stack.pop();
 		}
-		
+
 		protected Object initialValue() {
 			return new Stack();
 		}
