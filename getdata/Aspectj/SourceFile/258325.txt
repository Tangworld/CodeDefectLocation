@@ -1077,12 +1077,12 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 				} else {
 					outFile = new File(destinationPath, filename).getPath();
 				}
-				if (buildConfig.getCompilationResultDestinationManager() != null) {
-					buildConfig.getCompilationResultDestinationManager().reportClassFileWrite(outFile);
-				}
 				BufferedOutputStream os = FileUtil.makeOutputStream(new File(outFile));
 				os.write(classFile.getBytes());
 				os.close();
+				if (buildConfig.getCompilationResultDestinationManager() != null) {
+					buildConfig.getCompilationResultDestinationManager().reportClassFileWrite(outFile);
+				}
 				return outFile;
 			}
 
@@ -388,4 +388,8 @@ class MyOutputLocationManager implements IOutputLocationManager {
 	public String getSourceFolderForFile(File sourceFile) {
 		return null;
 	}
+
+	public void reportClassFileWrite(String outputfile) {
+	}
+
 }
@@ -16,7 +16,6 @@ import java.util.List;
 
 import org.aspectj.ajde.core.IOutputLocationManager;
 
-
 /**
  * OutputLocationManger tests which check whether the correct type of build has happened.
  */
@@ -24,15 +23,14 @@ public class IncrementalOutputLocationManagerTests extends AbstractMultiProjectI
 
 	public void testPr166580() {
 		initialiseProject("PR166580");
-		configureOutputLocationManager("PR166580",new MyOutputLocationManager("PR166580",2));
+		configureOutputLocationManager("PR166580", new MyOutputLocationManager("PR166580", 2));
 		build("PR166580");
 		checkWasFullBuild();
-		alter("PR166580","inc1");
+		alter("PR166580", "inc1");
 		build("PR166580");
 		checkWasntFullBuild();
 	}
-	
-	
+
 	/**
 	 * Will send output from src dir 'srcX' to directory 'binX'
 	 */
@@ -41,17 +39,20 @@ public class IncrementalOutputLocationManagerTests extends AbstractMultiProjectI
 		private String projectDir;
 		private int numberOfSrcDirs;
 		private List allOutputDirs;
-		
+
 		public MyOutputLocationManager(String projectName, int numberOfSrcDirs) {
 			projectDir = getWorkingDir() + File.separator + projectName;
 			this.numberOfSrcDirs = numberOfSrcDirs;
 		}
-		
+
+		public void reportClassFileWrite(String outputfile) {
+		}
+
 		public File getOutputLocationForClass(File compilationUnit) {
 			String path = compilationUnit.getAbsolutePath();
 			int index = path.indexOf("src");
-			String number = path.substring(index +3,index + 4);
-			File ret =  new File(projectDir + File.separator + "bin" + number);
+			String number = path.substring(index + 3, index + 4);
+			File ret = new File(projectDir + File.separator + "bin" + number);
 			if (!ret.exists()) {
 				ret.mkdirs();
 			}
@@ -85,7 +86,7 @@ public class IncrementalOutputLocationManagerTests extends AbstractMultiProjectI
 		public String getSourceFolderForFile(File sourceFile) {
 			return null;
 		}
-		
+
 	}
-	
+
 }
@@ -20,107 +20,92 @@ import java.util.Set;
 
 import org.aspectj.ajde.core.IOutputLocationManager;
 import org.aspectj.ajdt.internal.core.builder.AjBuildConfig;
-import org.aspectj.ajdt.internal.core.builder.AjBuildManager;
 import org.aspectj.ajdt.internal.core.builder.AjState;
 import org.aspectj.ajdt.internal.core.builder.IncrementalStateManager;
 import org.aspectj.util.FileUtil;
 import org.aspectj.weaver.bcel.UnwovenClassFile;
 
 /**
- * Similar to OutputLocationManagerTests, however, tests the different
- * scenarios when no outputDir is set but instead there is an 
- * OutputLocationManager which returns the same output location for all 
- * files and resources.
+ * Similar to OutputLocationManagerTests, however, tests the different scenarios when no outputDir is set but instead there is an
+ * OutputLocationManager which returns the same output location for all files and resources.
  * 
- * There are eight places where AjBuildConfig.getOutputDir() is called
- * that are tested here:
+ * There are eight places where AjBuildConfig.getOutputDir() is called that are tested here:
  * 
- * AjBuildManager.getOutputClassFileName(..) - testCorrectInfoWhenNoOutputPath
- * AjBuildManager.initBcelWorld(..) - testPathResolutionWithInpathDirAndNoOutputPath
- *                                    testPathResolutionWithInpathJarAndNoOutputPath
- * AjBuildManager.writeManifest(..) - testCopyManifest
- * AjBuildManager.writeOutxml(..) - testOutxml
- *                                - testOutXmlForAspectsWithDifferentOutputDirs
- * AjState.createUnwovenClassFile(..) - testPathResolutionAfterChangeInClassOnInpath
- * AjState.deleteResources(..) - testAjStateDeleteResources
- * AjState.maybeDeleteResources(..) - testAjStateDeleteResourcesInInputDir
+ * AjBuildManager.getOutputClassFileName(..) - testCorrectInfoWhenNoOutputPath AjBuildManager.initBcelWorld(..) -
+ * testPathResolutionWithInpathDirAndNoOutputPath testPathResolutionWithInpathJarAndNoOutputPath AjBuildManager.writeManifest(..) -
+ * testCopyManifest AjBuildManager.writeOutxml(..) - testOutxml - testOutXmlForAspectsWithDifferentOutputDirs
+ * AjState.createUnwovenClassFile(..) - testPathResolutionAfterChangeInClassOnInpath AjState.deleteResources(..) -
+ * testAjStateDeleteResources AjState.maybeDeleteResources(..) - testAjStateDeleteResourcesInInputDir
  * AjState.removeAllResultsOfLastBuild(..) - testAllResourcesAreDeletedCorrectlyOnPathChange
  * IncrementalStateManager.findStateManagingOutputLocation(..) - testFindStateManagingOutputLocation
  * 
- * The other three places are not tested here because they were implemented
- * when OutputLocationManager was introduced.
+ * The other three places are not tested here because they were implemented when OutputLocationManager was introduced.
  * 
  */
 public class MoreOutputLocationManagerTests extends AbstractMultiProjectIncrementalAjdeInteractionTestbed {
-	
+
 	private String inpathTestingDir;
 	private String expectedOutputDir;
-	
+
 	protected void setUp() throws Exception {
 		super.setUp();
 		initialiseProject("inpathTesting");
 		inpathTestingDir = getWorkingDir() + File.separator + "inpathTesting";
 		expectedOutputDir = inpathTestingDir + File.separator + "bin";
-		configureOutputLocationManager("inpathTesting",new SingleDirOutputLocMgr(inpathTestingDir));
+		configureOutputLocationManager("inpathTesting", new SingleDirOutputLocMgr(inpathTestingDir));
 	}
-	
+
 	/**
-	 * Tests that the UnwovenClassFiles have the correct path when there
-	 * is no outputDir but there is an OutputLocationManager. Is a simple
-	 * project that has no inpath setting
+	 * Tests that the UnwovenClassFiles have the correct path when there is no outputDir but there is an OutputLocationManager. Is a
+	 * simple project that has no inpath setting
 	 */
 	public void testCorrectInfoWhenNoOutputPath() {
 		build("inpathTesting");
 		AjState state = getState();
-		
+
 		Map classNameToFileMap = state.getClassNameToFileMap();
-		assertFalse("expected there to be classes ",classNameToFileMap.isEmpty());
+		assertFalse("expected there to be classes ", classNameToFileMap.isEmpty());
 		Set entrySet = classNameToFileMap.entrySet();
 		for (Iterator iterator = entrySet.iterator(); iterator.hasNext();) {
 			Map.Entry entry = (Map.Entry) iterator.next();
 			String className = (String) entry.getKey();
-			String fullClassName = expectedOutputDir + File.separator + className.replace('.',File.separatorChar) + ".class";
+			String fullClassName = expectedOutputDir + File.separator + className.replace('.', File.separatorChar) + ".class";
 			File file = (File) entry.getValue();
-			assertEquals("expected file to have path \n" + fullClassName + ", but" +
-					" found path \n" + file.getAbsolutePath(),fullClassName,
-					file.getAbsolutePath());
+			assertEquals("expected file to have path \n" + fullClassName + ", but" + " found path \n" + file.getAbsolutePath(),
+					fullClassName, file.getAbsolutePath());
 		}
 	}
-	
+
 	/**
-	 * Tests that can retieve the state that manages a given output location
-	 * when there is no outputDir set
+	 * Tests that can retieve the state that manages a given output location when there is no outputDir set
 	 */
 	public void testFindStateManagingOutputLocation() {
 		build("inpathTesting");
 		AjState state = IncrementalStateManager.findStateManagingOutputLocation(new File(expectedOutputDir));
-		assertNotNull("Expected to find a state that managed output location " +
-				expectedOutputDir + ", but did not", state);
-		
+		assertNotNull("Expected to find a state that managed output location " + expectedOutputDir + ", but did not", state);
+
 	}
-	
+
 	/**
-	 * Tests that the UnwovenClassFiles corresponding to classes on the
-	 * inpath have the correct class name when there is no output directory 
-	 * (ultimately tests AjBuildManager.initBcelWorld() when there is a
-	 * jar on the inpath). Only does one build.
+	 * Tests that the UnwovenClassFiles corresponding to classes on the inpath have the correct class name when there is no output
+	 * directory (ultimately tests AjBuildManager.initBcelWorld() when there is a jar on the inpath). Only does one build.
 	 */
 	public void testPathResolutionWithInpathDirAndNoOutputPath() {
-		String inpathDir  = inpathTestingDir + File.separator + "injarBin" + File.separator + "pkg";
+		String inpathDir = inpathTestingDir + File.separator + "injarBin" + File.separator + "pkg";
 		addInpathEntry(inpathDir);
 		build("inpathTesting");
 
 		// expect to compile the aspect in 'inpathTesting' project and weave
 		// both the aspect and the class on the inpath.
-		checkCompileWeaveCount("inpathTesting",1,2);
-		
+		checkCompileWeaveCount("inpathTesting", 1, 2);
+
 		// get hold of the state for this project - expect to find one
 		AjState state = getState();
 
 		// the classes onthe inpath are recorded against the AjBuildManager
 		// (they are deleted from the ajstate whilst cleaning up after a build)
 		Map binarySources = state.getAjBuildManager().getBinarySourcesForThisWeave();
-		assertFalse("expected there to be binary sources from the inpath setting but didn't find any",binarySources.isEmpty());
+		assertFalse("expected there to be binary sources from the inpath setting but didn't find any", binarySources.isEmpty());
 
 		List unwovenClassFiles = (List) binarySources.get(inpathDir + File.separator + "InpathClass.class");
 		List fileNames = new ArrayList();
@@ -132,37 +117,35 @@ public class MoreOutputLocationManagerTests extends AbstractMultiProjectIncremen
 				fileNames.add(ucf.getFilename());
 			}
 		}
-		assertTrue("expected to find UnwovenClassFile from directory\n" + expectedOutputDir +
-				", \n but found files " + fileNames, fileNames.isEmpty());		
+		assertTrue("expected to find UnwovenClassFile from directory\n" + expectedOutputDir + ", \n but found files " + fileNames,
+				fileNames.isEmpty());
 	}
 
 	/**
-	 * Tests that the UnwovenClassFiles corresponding to classes on the
-	 * inpath have the correct class name when there is no output directory 
-	 * (ultimately tests AjState.createUnwovenClassFile(BinarySourceFile)
-	 * and ensures the unwovenClassFile has the correct name. Makes a change to
-	 * a class file on the inpath to ensure we enter this method (there is a 
-	 * check that says are we the first build))
+	 * Tests that the UnwovenClassFiles corresponding to classes on the inpath have the correct class name when there is no output
+	 * directory (ultimately tests AjState.createUnwovenClassFile(BinarySourceFile) and ensures the unwovenClassFile has the correct
+	 * name. Makes a change to a class file on the inpath to ensure we enter this method (there is a check that says are we the
+	 * first build))
 	 */
 	public void testPathResolutionAfterChangeInClassOnInpath() throws Exception {
-		String inpathDir  = inpathTestingDir + File.separator + "injarBin" + File.separator + "pkg";
+		String inpathDir = inpathTestingDir + File.separator + "injarBin" + File.separator + "pkg";
 		addInpathEntry(inpathDir);
 		build("inpathTesting");
 
-		// build again so that we enter 
+		// build again so that we enter
 		// AjState.createUnwovenClassFile(BinarySourceFile)
-		File from = new File(testdataSrcDir+File.separatorChar+"inpathTesting"
-				+File.separatorChar+"newInpathClass" + File.separatorChar + "InpathClass.class");
+		File from = new File(testdataSrcDir + File.separatorChar + "inpathTesting" + File.separatorChar + "newInpathClass"
+				+ File.separatorChar + "InpathClass.class");
 		File destination = new File(inpathDir + File.separatorChar + "InpathClass.class");
-		FileUtil.copyFile(from,destination);
-		
+		FileUtil.copyFile(from, destination);
+
 		// get hold of the state for this project - expect to find one
 		AjState state = getState();
 		AjBuildConfig buildConfig = state.getBuildConfig();
 		state.prepareForNextBuild(buildConfig);
 
 		Map binarySources = state.getBinaryFilesToCompile(true);
-		assertFalse("expected there to be binary sources from the inpath setting but didn't find any",binarySources.isEmpty());
+		assertFalse("expected there to be binary sources from the inpath setting but didn't find any", binarySources.isEmpty());
 
 		List unwovenClassFiles = (List) binarySources.get(inpathDir + File.separator + "InpathClass.class");
 		List fileNames = new ArrayList();
@@ -174,174 +157,165 @@ public class MoreOutputLocationManagerTests extends AbstractMultiProjectIncremen
 				fileNames.add(ucf.getFilename());
 			}
 		}
-		assertTrue("expected to find UnwovenClassFile from directory\n" + expectedOutputDir +
-				", \n but found files " + fileNames, fileNames.isEmpty());		
+		assertTrue("expected to find UnwovenClassFile from directory\n" + expectedOutputDir + ", \n but found files " + fileNames,
+				fileNames.isEmpty());
 	}
-	
+
 	/**
-	 * Tests that the UnwovenClassFiles corresponding to jars on the
-	 * inpath have the correct class name when there is no output path 
-	 * (ultimately tests AjBuildManager.initBcelWorld() when there is a
-	 * jar on the inpath). Only does one build.
+	 * Tests that the UnwovenClassFiles corresponding to jars on the inpath have the correct class name when there is no output path
+	 * (ultimately tests AjBuildManager.initBcelWorld() when there is a jar on the inpath). Only does one build.
 	 */
 	public void testPathResolutionWithInpathJarAndNoOutputPath() {
-		String inpathDir  = inpathTestingDir + File.separator + "inpathJar.jar";
+		String inpathDir = inpathTestingDir + File.separator + "inpathJar.jar";
 		addInpathEntry(inpathDir);
 		build("inpathTesting");
 		// expect to compile the aspect in 'inpathTesting' project and weave
 		// both the aspect and the class in the jar on the inpath.
-		checkCompileWeaveCount("inpathTesting",1,2);
-		
+		checkCompileWeaveCount("inpathTesting", 1, 2);
+
 		AjState state = getState();
 
 		// tests AjState.createUnwovenClassFile(BinarySourceFile)
 		Map binarySources = state.getAjBuildManager().getBinarySourcesForThisWeave();
-		assertFalse("expected there to be binary sources from the inpath setting but didn't find any",binarySources.isEmpty());
+		assertFalse("expected there to be binary sources from the inpath setting but didn't find any", binarySources.isEmpty());
 
 		List unwovenClassFiles = (List) binarySources.get(inpathDir);
 		List fileNames = new ArrayList();
-		
+
 		for (Iterator iterator = unwovenClassFiles.iterator(); iterator.hasNext();) {
 			UnwovenClassFile ucf = (UnwovenClassFile) iterator.next();
 			if (ucf.getFilename().indexOf(expectedOutputDir) == -1) {
 				fileNames.add(ucf.getFilename());
 			}
 		}
-		assertTrue("expected to find UnwovenClassFile from directory\n" + expectedOutputDir +
-				", \n but found files " + fileNames, fileNames.isEmpty());		
+		assertTrue("expected to find UnwovenClassFile from directory\n" + expectedOutputDir + ", \n but found files " + fileNames,
+				fileNames.isEmpty());
+
+	}
 
-	}	
-	
 	/**
-	 * A manifest file is in the jar on the inpath - check that it's 
-	 * copied to the correct place
+	 * A manifest file is in the jar on the inpath - check that it's copied to the correct place
 	 */
 	public void testCopyManifest() {
-		String inpathDir  = inpathTestingDir + File.separator + "inpathJar.jar";
+		String inpathDir = inpathTestingDir + File.separator + "inpathJar.jar";
 		addInpathEntry(inpathDir);
-		
+
 		build("inpathTesting");
 		String resource = expectedOutputDir + File.separator + "META-INF" + File.separator + "MANIFEST.MF";
 		File f = new File(resource);
-		assertTrue("expected file " + resource + " to exist but it did not",f.exists());
+		assertTrue("expected file " + resource + " to exist but it did not", f.exists());
 	}
-	
+
 	/**
-	 * "resources" are contained within inpath jars - check that
-	 * a text file contained within a jar is copied and then 
-	 * deleted correctly. Essentially tests AjState.deleteResources().
+	 * "resources" are contained within inpath jars - check that a text file contained within a jar is copied and then deleted
+	 * correctly. Essentially tests AjState.deleteResources().
 	 */
 	// see 243376: for now don't do this, waste of cpu - ajdt better for handling resources - but is that true for inpath resources?
-//	public void testAjStateDeleteResources() {
-//		String inpathDir  = inpathTestingDir + File.separator + "inpathJar.jar";
-//		addInpathEntry(inpathDir);
-//		
-//		build("inpathTesting");
-//		
-//		AjState state = getState();
-//		
-//		String resource = expectedOutputDir + File.separator + "inpathResource.txt";
-//		File f = new File(resource);
-//		assertTrue("expected file " + resource + " to exist but it did not",f.exists());
-//		// this call should delete the resources
-//		state.getFilesToCompile(true);
-//		assertFalse("did not expect the file " + resource + " to exist but it does",f.exists());
-//	}
-	
+	// public void testAjStateDeleteResources() {
+	// String inpathDir = inpathTestingDir + File.separator + "inpathJar.jar";
+	// addInpathEntry(inpathDir);
+	//		
+	// build("inpathTesting");
+	//		
+	// AjState state = getState();
+	//		
+	// String resource = expectedOutputDir + File.separator + "inpathResource.txt";
+	// File f = new File(resource);
+	// assertTrue("expected file " + resource + " to exist but it did not",f.exists());
+	// // this call should delete the resources
+	// state.getFilesToCompile(true);
+	// assertFalse("did not expect the file " + resource + " to exist but it does",f.exists());
+	// }
 	/**
-	 * Can set to copy resources that are in inpath dirs - check that
-	 * a text file contained within such a dir is copied and then 
+	 * Can set to copy resources that are in inpath dirs - check that a text file contained within such a dir is copied and then
 	 * deleted correctly. Essentially tests AjState.maybeDeleteResources().
 	 */
 	// see 243376: for now don't do this, waste of cpu - ajdt better for handling resources - but is that true for inpath resources?
-//	public void testAjStateDeleteResourcesInInputDir() {
-//		// temporary problem with this on linux, think it is a filesystem lastmodtime issue
-//		if (System.getProperty("os.name","").toLowerCase().equals("linux")) return;
-//		if (System.getProperty("os.name","").toLowerCase().indexOf("mac")!=-1) return;
-//
-//		AjBuildManager.COPY_INPATH_DIR_RESOURCES = true;
-//		try {
-//			String inpathDir = inpathTestingDir + File.separator + "injarBin"
-//					+ File.separator + "pkg";
-//			addInpathEntry(inpathDir);
-//			build("inpathTesting");
-//			AjState state = getState();
-//			String resource = "inDirResource.txt";
-//			assertTrue("expected state to have resource " + resource + "but it did not", 
-//					state.hasResource(resource));
-//			// this call should delete the resources - tests AjState.deleteResources()
-//			state.getFilesToCompile(true);
-//			assertFalse("did not expect state to have resource " + resource +
-//					" but found that it did", state.hasResource(resource));
-//		} finally {
-//			AjBuildManager.COPY_INPATH_DIR_RESOURCES = false;
-//		}
-//		
-//	}
-	
+	// public void testAjStateDeleteResourcesInInputDir() {
+	// // temporary problem with this on linux, think it is a filesystem lastmodtime issue
+	// if (System.getProperty("os.name","").toLowerCase().equals("linux")) return;
+	// if (System.getProperty("os.name","").toLowerCase().indexOf("mac")!=-1) return;
+	//
+	// AjBuildManager.COPY_INPATH_DIR_RESOURCES = true;
+	// try {
+	// String inpathDir = inpathTestingDir + File.separator + "injarBin"
+	// + File.separator + "pkg";
+	// addInpathEntry(inpathDir);
+	// build("inpathTesting");
+	// AjState state = getState();
+	// String resource = "inDirResource.txt";
+	// assertTrue("expected state to have resource " + resource + "but it did not",
+	// state.hasResource(resource));
+	// // this call should delete the resources - tests AjState.deleteResources()
+	// state.getFilesToCompile(true);
+	// assertFalse("did not expect state to have resource " + resource +
+	// " but found that it did", state.hasResource(resource));
+	// } finally {
+	// AjBuildManager.COPY_INPATH_DIR_RESOURCES = false;
+	// }
+	//		
+	// }
 	/**
-	 * Changing inpath entry from a jar to a directory between builds means
-	 * that AjState should realise somethings changed. This causes all resources
-	 * (Manifest and txt files) to be deleted. Also should be a full build.
-	 * Essentially tests AjState.removeAllResultsFromLastBuild().
+	 * Changing inpath entry from a jar to a directory between builds means that AjState should realise somethings changed. This
+	 * causes all resources (Manifest and txt files) to be deleted. Also should be a full build. Essentially tests
+	 * AjState.removeAllResultsFromLastBuild().
 	 */
 	public void testAllResourcesAreDeletedCorrectlyOnPathChange() {
-		String inpathJar  = inpathTestingDir + File.separator + "inpathJar.jar";
+		String inpathJar = inpathTestingDir + File.separator + "inpathJar.jar";
 
 		addInpathEntry(inpathJar);
 		build("inpathTesting");
-		
+
 		String resource = expectedOutputDir + File.separator + "inpathResource.txt";
 		File f = new File(resource);
-		assertTrue("expected file " + resource + " to exist but it did not",f.exists());
+		assertTrue("expected file " + resource + " to exist but it did not", f.exists());
 
 		// this should force a change and the file is deleted
 		// tests AjState.removeAllResultsFromLastBuild()
 		addInpathEntry(null);
 		build("inpathTesting");
-		assertFalse("did not expect the file " + resource + " to exist but it does",f.exists());
+		assertFalse("did not expect the file " + resource + " to exist but it does", f.exists());
 
 		checkWasFullBuild();
-	}	
-	
+	}
+
 	public void testOutxml() {
-		configureNonStandardCompileOptions("inpathTesting","-outxml");
+		configureNonStandardCompileOptions("inpathTesting", "-outxml");
 		build("inpathTesting");
 		String resource = expectedOutputDir + File.separator + "META-INF" + File.separator + "aop-ajc.xml";
 		File f = new File(resource);
-		assertTrue("expected file " + resource + " to exist but it did not",f.exists());
+		assertTrue("expected file " + resource + " to exist but it did not", f.exists());
 	}
-	
+
 	public void testAspectsRecordedOnlyOnceInState() {
-		configureNonStandardCompileOptions("inpathTesting","-outxml");
+		configureNonStandardCompileOptions("inpathTesting", "-outxml");
 		build("inpathTesting");
 		AjState state = getState();
 		Map m = state.getAspectNamesToFileNameMap();
-		assertEquals("Expected only one aspect recored in the state but found " + m.size(),1,m.size());
+		assertEquals("Expected only one aspect recored in the state but found " + m.size(), 1, m.size());
 		build("inpathTesting");
 		m = state.getAspectNamesToFileNameMap();
-		assertEquals("Expected only one aspect recored in the state but found " + m.size(),1,m.size());
+		assertEquals("Expected only one aspect recored in the state but found " + m.size(), 1, m.size());
 	}
-	
+
 	private AjState getState() {
 		// get hold of the state for this project - expect to find one
 		AjState state = IncrementalStateManager.retrieveStateFor(inpathTestingDir);
-		assertNotNull("expected to find AjState for build config " + inpathTestingDir 
-				+ " but didn't", state);
+		assertNotNull("expected to find AjState for build config " + inpathTestingDir + " but didn't", state);
 		return state;
 	}
-	
+
 	private void addInpathEntry(String entry) {
 		if (entry == null) {
-			configureInPath("inpathTesting",null);
+			configureInPath("inpathTesting", null);
 			return;
 		}
 		File f = new File(entry);
 		Set s = new HashSet();
 		s.add(f);
-		configureInPath("inpathTesting",s);
+		configureInPath("inpathTesting", s);
 	}
-	
+
 	/**
 	 * Sends all output to the same directory
 	 */
@@ -352,15 +326,15 @@ public class MoreOutputLocationManagerTests extends AbstractMultiProjectIncremen
 		private String testProjectOutputPath;
 		private List allOutputLocations;
 		private File outputLoc;
-		
+
 		public SingleDirOutputLocMgr(String testProjectPath) {
 			this.testProjectOutputPath = testProjectPath + File.separator + "bin";
 			outputLoc = new File(testProjectOutputPath);
-			
+
 			allOutputLocations = new ArrayList();
 			allOutputLocations.add(outputLoc);
 		}
-		
+
 		public File getOutputLocationForClass(File compilationUnit) {
 			return outputLoc;
 		}
@@ -369,7 +343,7 @@ public class MoreOutputLocationManagerTests extends AbstractMultiProjectIncremen
 			return outputLoc;
 		}
 
-		public List /*File*/ getAllOutputLocations() {
+		public List /* File */getAllOutputLocations() {
 			return allOutputLocations;
 		}
 
@@ -377,10 +351,13 @@ public class MoreOutputLocationManagerTests extends AbstractMultiProjectIncremen
 			return outputLoc;
 		}
 
+		public void reportClassFileWrite(String outputfile) {
+		}
+
 		public String getSourceFolderForFile(File sourceFile) {
 			// TODO Auto-generated method stub
 			return null;
 		}
 	}
-	
+
 }
@@ -99,4 +99,8 @@ public class MultiProjTestOutputLocationManager implements IOutputLocationManage
 		}
 	}
 
+	public void reportClassFileWrite(String outputfile) {
+		// System.err.println(">>>" + outputfile);
+	}
+
 }
@@ -20,85 +20,86 @@ import java.util.Map;
 import org.aspectj.ajde.core.IOutputLocationManager;
 
 /**
- * Test the OutputLocationManager support used to enable multiple output folders.
- * These aren't true "multi-project incremental" tests, but that superclass has some
- * handy methods over and above AjdeInteractionTestCase that I want to use.
+ * Test the OutputLocationManager support used to enable multiple output folders. These aren't true "multi-project incremental"
+ * tests, but that superclass has some handy methods over and above AjdeInteractionTestCase that I want to use.
  */
 public class OutputLocationManagerTests extends AbstractMultiProjectIncrementalAjdeInteractionTestbed {
 
 	private static final String PROJECT_NAME = "MultipleOutputFolders";
 	private MyOutputLocationManager outputLocationManager;
-	
+
 	protected void setUp() throws Exception {
 		super.setUp();
 		initialiseProject(PROJECT_NAME);
 		this.outputLocationManager = new MyOutputLocationManager(new File(getFile(PROJECT_NAME, "")));
-		configureOutputLocationManager(PROJECT_NAME,this.outputLocationManager);
+		configureOutputLocationManager(PROJECT_NAME, this.outputLocationManager);
 	}
-	
+
 	public void testDefaultOutputLocationUsedWhenNoOutputLocationManager() {
-		configureOutputLocationManager(PROJECT_NAME,null);
+		configureOutputLocationManager(PROJECT_NAME, null);
 		build(PROJECT_NAME);
-		assertFileExists(PROJECT_NAME,"bin/a/A.class");
-		assertFileExists(PROJECT_NAME,"bin/b/B.class");
+		assertFileExists(PROJECT_NAME, "bin/a/A.class");
+		assertFileExists(PROJECT_NAME, "bin/b/B.class");
 	}
-	
+
 	public void testTwoSourceRootsWithSeparateOutputLocations() {
 		build(PROJECT_NAME);
-		assertFileExists(PROJECT_NAME,"target/main/classes/a/A.class");
-		assertFileExists(PROJECT_NAME,"target/test/classes/b/B.class");
+		assertFileExists(PROJECT_NAME, "target/main/classes/a/A.class");
+		assertFileExists(PROJECT_NAME, "target/test/classes/b/B.class");
 	}
-	
+
 	public void testResourceCopying() {
 		Map resourceMap = new HashMap();
-		resourceMap.put("resourceOne.txt", new File(getFile(PROJECT_NAME,"srcRootOne/resourceOne.txt")));
-		resourceMap.put("resourceTwo.txt", new File(getFile(PROJECT_NAME,"srcRootTwo/resourceTwo.txt")));
-		configureResourceMap(PROJECT_NAME,resourceMap);
+		resourceMap.put("resourceOne.txt", new File(getFile(PROJECT_NAME, "srcRootOne/resourceOne.txt")));
+		resourceMap.put("resourceTwo.txt", new File(getFile(PROJECT_NAME, "srcRootTwo/resourceTwo.txt")));
+		configureResourceMap(PROJECT_NAME, resourceMap);
 		build(PROJECT_NAME);
-		assertFileExists(PROJECT_NAME,"target/main/classes/resourceOne.txt");
-		assertFileExists(PROJECT_NAME,"target/test/classes/resourceTwo.txt");		
+		assertFileExists(PROJECT_NAME, "target/main/classes/resourceOne.txt");
+		assertFileExists(PROJECT_NAME, "target/test/classes/resourceTwo.txt");
 	}
-	
+
 	public void testGeneratedClassesPlacedInAppropriateOutputFolder() {
-		configureNonStandardCompileOptions(PROJECT_NAME,"-XnoInline");
+		configureNonStandardCompileOptions(PROJECT_NAME, "-XnoInline");
 		build(PROJECT_NAME);
-		assertFileExists(PROJECT_NAME,"target/main/classes/a/A.class");
-		assertFileExists(PROJECT_NAME,"target/main/classes/a/A$AjcClosure1.class");		
+		assertFileExists(PROJECT_NAME, "target/main/classes/a/A.class");
+		assertFileExists(PROJECT_NAME, "target/main/classes/a/A$AjcClosure1.class");
 	}
 
 	/**
-	 * Tests the case when we have two aspects, each of which are
-	 * sent to a different output location. There should be an 
-	 * aop.xml file in each of the two output directories.
+	 * Tests the case when we have two aspects, each of which are sent to a different output location. There should be an aop.xml
+	 * file in each of the two output directories.
 	 */
 	public void testOutXmlForAspectsWithDifferentOutputDirs() {
-		configureNonStandardCompileOptions(PROJECT_NAME,"-outxml");
+		configureNonStandardCompileOptions(PROJECT_NAME, "-outxml");
 		build(PROJECT_NAME);
-		assertFileExists(PROJECT_NAME,"target/main/classes/META-INF/aop-ajc.xml");
-		assertFileExists(PROJECT_NAME,"target/test/classes/META-INF/aop-ajc.xml");
+		assertFileExists(PROJECT_NAME, "target/main/classes/META-INF/aop-ajc.xml");
+		assertFileExists(PROJECT_NAME, "target/test/classes/META-INF/aop-ajc.xml");
 		// aop.xml file should exist even if there aren't any aspects (mirrors
 		// what happens when there's one output dir)
-		checkXMLAspectCount(PROJECT_NAME,"",0,getFile(PROJECT_NAME,"target/anotherTest/classes"));
-		// add aspects to the srcRootThree src dir and they should appear in the 
+		checkXMLAspectCount(PROJECT_NAME, "", 0, getFile(PROJECT_NAME, "target/anotherTest/classes"));
+		// add aspects to the srcRootThree src dir and they should appear in the
 		// corresponding aop.xml file
-		alter(PROJECT_NAME,"inc1");
+		alter(PROJECT_NAME, "inc1");
 		build(PROJECT_NAME);
-		checkXMLAspectCount(PROJECT_NAME,"c.C$AnAspect",1,getFile(PROJECT_NAME,"target/anotherTest/classes"));
+		checkXMLAspectCount(PROJECT_NAME, "c.C$AnAspect", 1, getFile(PROJECT_NAME, "target/anotherTest/classes"));
 	}
-	
+
 	protected void assertFileExists(String project, String relativePath) {
-		assertTrue("file " + relativePath + " should have been created as a result of building " + project,
-				    new File(getFile(project, relativePath)).exists());
+		assertTrue("file " + relativePath + " should have been created as a result of building " + project, new File(getFile(
+				project, relativePath)).exists());
 	}
-	
+
 	private static class MyOutputLocationManager implements IOutputLocationManager {
-		
+
 		private File projectHome;
 		private List allOutputDirs;
-		
+
 		public MyOutputLocationManager(File projectHome) {
 			this.projectHome = projectHome;
-			
+
+		}
+
+		public void reportClassFileWrite(String outputfile) {
 		}
 
 		public File getOutputLocationForClass(File compilationUnit) {
@@ -111,7 +112,7 @@ public class OutputLocationManagerTests extends AbstractMultiProjectIncrementalA
 			} else if (compilationUnitName.indexOf("srcRootThree") != -1) {
 				relativePath = "target/anotherTest/classes";
 			}
-			File ret =  new File(projectHome,relativePath);
+			File ret = new File(projectHome, relativePath);
 			if (!ret.exists()) {
 				ret.mkdirs();
 			}
@@ -125,19 +126,23 @@ public class OutputLocationManagerTests extends AbstractMultiProjectIncrementalA
 		public List getAllOutputLocations() {
 			if (allOutputDirs == null) {
 				allOutputDirs = new ArrayList();
-				allOutputDirs.add(new File(projectHome,"target/main/classes"));
-				allOutputDirs.add(new File(projectHome,"target/test/classes"));
-				allOutputDirs.add(new File(projectHome,"target/anotherTest/classes"));
+				allOutputDirs.add(new File(projectHome, "target/main/classes"));
+				allOutputDirs.add(new File(projectHome, "target/test/classes"));
+				allOutputDirs.add(new File(projectHome, "target/anotherTest/classes"));
 			}
 			return allOutputDirs;
 		}
 
 		public File getDefaultOutputLocation() {
-			return new File(projectHome,"target/main/classes");
+			return new File(projectHome, "target/main/classes");
 		}
 
 		public String getSourceFolderForFile(File sourceFile) {
 			return null;
 		}
 	}
+
+	public void reportClassFileWrite(String outputfile) {
+	}
+
 }
@@ -15,11 +15,9 @@ import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Test implementation of IOutputLocationManager. By default returns the
- * same location for both resources and classes, however, setter methods
- * enable the user to specify different location for these. Note that the
- * user is unable to specify different output location for different class
- * files.
+ * Test implementation of IOutputLocationManager. By default returns the same location for both resources and classes, however,
+ * setter methods enable the user to specify different location for these. Note that the user is unable to specify different output
+ * location for different class files.
  */
 public class TestOutputLocationManager implements IOutputLocationManager {
 
@@ -27,7 +25,7 @@ public class TestOutputLocationManager implements IOutputLocationManager {
 	private File classOutputLoc;
 	private File resourceOutputLoc;
 	private List allOutputLocations;
-	
+
 	public TestOutputLocationManager(String testProjectPath) {
 		this.testProjectOutputPath = testProjectPath + File.separator + "bin";
 	}
@@ -41,18 +39,18 @@ public class TestOutputLocationManager implements IOutputLocationManager {
 		initLocations();
 		return resourceOutputLoc;
 	}
-	
+
 	// -------------- setter methods useful for testing -------------
 	public void setOutputLocForClass(File f) {
 		classOutputLoc = f;
 	}
-	
+
 	public void setOutputLocForResource(File f) {
 		resourceOutputLoc = f;
 	}
 
 	public List getAllOutputLocations() {
-		if(allOutputLocations == null) {
+		if (allOutputLocations == null) {
 			allOutputLocations = new ArrayList();
 			initLocations();
 			allOutputLocations.add(classOutputLoc);
@@ -67,7 +65,7 @@ public class TestOutputLocationManager implements IOutputLocationManager {
 		initLocations();
 		return classOutputLoc;
 	}
-	
+
 	private void initLocations() {
 		if (classOutputLoc == null) {
 			classOutputLoc = new File(testProjectOutputPath);
@@ -80,6 +78,8 @@ public class TestOutputLocationManager implements IOutputLocationManager {
 	public String getSourceFolderForFile(File sourceFile) {
 		return null;
 	}
-	
+
+	public void reportClassFileWrite(String outputfile) {
+	}
 
 }
@@ -15,53 +15,50 @@ import java.io.File;
 import java.util.List;
 
 /**
- * Interface that handles where the compilation output is sent. Allows
- * for the output folder to be different for different source files.
+ * Interface that handles where the compilation output is sent. Allows for the output folder to be different for different source
+ * files.
  */
 public interface IOutputLocationManager {
 
 	/**
-	 * Return the directory root under which the results of compiling the given
-	 * source file. For example, if the source file contains the type a.b.C, and
-	 * this method returns "target/classes" the resulting class file will be written
-	 * to "target/classes/a/b/C.class"
+	 * Return the directory root under which the results of compiling the given source file. For example, if the source file
+	 * contains the type a.b.C, and this method returns "target/classes" the resulting class file will be written to
+	 * "target/classes/a/b/C.class"
 	 * 
-	 * @param compilationUnit  the compilation unit that has been compiled
-	 * @return a File object representing the root directory under which compilation results for this
-	 *  unit should be written
+	 * @param compilationUnit the compilation unit that has been compiled
+	 * @return a File object representing the root directory under which compilation results for this unit should be written
 	 */
 	File getOutputLocationForClass(File compilationUnit);
 
 	/**
-     * For environments where multiple source folders are supported, they need to be included
-     * in the model.  This method allows AspectJ to determine which source folder a source file
-     * came from.  Example return values would be "src" or "main/java"
-     *
+	 * For environments where multiple source folders are supported, they need to be included in the model. This method allows
+	 * AspectJ to determine which source folder a source file came from. Example return values would be "src" or "main/java"
+	 * 
 	 * @param sourceFile the File object for the source file
 	 * @return the source folder where this file came from, or null if in project root or source folders not supported.
 	 */
 	String getSourceFolderForFile(File sourceFile);
-	
+
 	/**
-	 * When copying resources from source folders to output location, return the
-	 * root directory under which the resource should be copied.
+	 * When copying resources from source folders to output location, return the root directory under which the resource should be
+	 * copied.
 	 * 
 	 * @param resource the resource to be copied
-	 * @return a File object representing the root directory under which this resource
-	 * should be copied
+	 * @return a File object representing the root directory under which this resource should be copied
 	 */
 	File getOutputLocationForResource(File resource);
 
 	/**
 	 * Return a list of all output locations handled by this OutputLocationManager
 	 */
-	List /*File*/ getAllOutputLocations();
-	
+	List /* File */getAllOutputLocations();
+
 	/**
-	 * Return the default output location (for example, <my_project>/bin). This is
-	 * where classes which are on the inpath will be placed.
+	 * Return the default output location (for example, <my_project>/bin). This is where classes which are on the inpath will be
+	 * placed.
 	 */
 	File getDefaultOutputLocation();
 
-		
+	void reportClassFileWrite(String outputfile);
+
 }
@@ -19,21 +19,20 @@ import org.aspectj.ajde.core.IOutputLocationManager;
 import org.aspectj.ajdt.internal.compiler.CompilationResultDestinationManager;
 
 /**
- * Enables the output locations detailed by the IOutputLocationManager 
- * implementation to be related to the comipler/weaver.
+ * Enables the output locations detailed by the IOutputLocationManager implementation to be related to the comipler/weaver.
  */
 public class OutputLocationAdapter implements CompilationResultDestinationManager {
 
 	private IOutputLocationManager locationManager;
-	
+
 	public OutputLocationAdapter(IOutputLocationManager mgr) {
 		this.locationManager = mgr;
 	}
-	
+
 	public File getOutputLocationForClass(File compilationUnit) {
 		return this.locationManager.getOutputLocationForClass(compilationUnit);
 	}
-	
+
 	public String getSourceFolderForFile(File sourceFile) {
 		return this.locationManager.getSourceFolderForFile(sourceFile);
 	}
@@ -49,4 +48,8 @@ public class OutputLocationAdapter implements CompilationResultDestinationManage
 	public File getDefaultOutputLocation() {
 		return this.locationManager.getDefaultOutputLocation();
 	}
+
+	public void reportClassFileWrite(String outputfile) {
+		this.locationManager.reportClassFileWrite(outputfile);
+	}
 }
@@ -17,11 +17,9 @@ import java.util.List;
 import org.aspectj.ajde.core.IOutputLocationManager;
 
 /**
- * Test implementation of IOutputLocationManager. By default returns the
- * same location for both resources and classes, however, setter methods
- * enable the user to specify different location for these. Note that the
- * user is unable to specify different output location for different class
- * files.
+ * Test implementation of IOutputLocationManager. By default returns the same location for both resources and classes, however,
+ * setter methods enable the user to specify different location for these. Note that the user is unable to specify different output
+ * location for different class files.
  */
 public class TestOutputLocationManager implements IOutputLocationManager {
 
@@ -29,11 +27,14 @@ public class TestOutputLocationManager implements IOutputLocationManager {
 	private File classOutputLoc;
 	private File resourceOutputLoc;
 	private List allOutputLocations;
-	
+
 	public TestOutputLocationManager(String testProjectPath) {
 		this.testProjectOutputPath = testProjectPath + File.separator + "bin";
 	}
-	
+
+	public void reportClassFileWrite(String outputfile) {
+	}
+
 	public String getUniqueIdentifier() {
 		return testProjectOutputPath;
 	}
@@ -47,18 +48,18 @@ public class TestOutputLocationManager implements IOutputLocationManager {
 		initLocations();
 		return resourceOutputLoc;
 	}
-	
+
 	// -------------- setter methods useful for testing -------------
 	public void setOutputLocForClass(File f) {
 		classOutputLoc = f;
 	}
-	
+
 	public void setOutputLocForResource(File f) {
 		resourceOutputLoc = f;
 	}
 
 	public List getAllOutputLocations() {
-		if(allOutputLocations == null) {
+		if (allOutputLocations == null) {
 			allOutputLocations = new ArrayList();
 			initLocations();
 			allOutputLocations.add(classOutputLoc);
@@ -72,7 +73,7 @@ public class TestOutputLocationManager implements IOutputLocationManager {
 	public File getDefaultOutputLocation() {
 		return classOutputLoc;
 	}
-	
+
 	private void initLocations() {
 		if (classOutputLoc == null) {
 			classOutputLoc = new File(testProjectOutputPath);
@@ -85,6 +86,5 @@ public class TestOutputLocationManager implements IOutputLocationManager {
 	public String getSourceFolderForFile(File sourceFile) {
 		return null;
 	}
-	
 
 }
@@ -18,15 +18,13 @@ import org.aspectj.ajde.core.IOutputLocationManager;
 import org.aspectj.ajde.ui.UserPreferencesAdapter;
 
 /**
- * IOutputLocationManager which returns the same output location for
- * all files and resources.
+ * IOutputLocationManager which returns the same output location for all files and resources.
  */
 public class BrowserOutputLocationManager implements IOutputLocationManager {
 
 	private UserPreferencesAdapter preferencesAdapter;
 
-	public BrowserOutputLocationManager(
-			UserPreferencesAdapter preferencesAdapter) {
+	public BrowserOutputLocationManager(UserPreferencesAdapter preferencesAdapter) {
 		this.preferencesAdapter = preferencesAdapter;
 	}
 
@@ -39,8 +37,7 @@ public class BrowserOutputLocationManager implements IOutputLocationManager {
 	}
 
 	private String getCommonOutputDir() {
-		String outputPath = preferencesAdapter.getProjectPreference(
-				PreferenceStoreConstants.BUILD_OUTPUTPATH);
+		String outputPath = preferencesAdapter.getProjectPreference(PreferenceStoreConstants.BUILD_OUTPUTPATH);
 		if (outputPath == null) {
 			return ".";
 		}
@@ -61,4 +58,7 @@ public class BrowserOutputLocationManager implements IOutputLocationManager {
 		return null;
 	}
 
+	public void reportClassFileWrite(String outputfile) {
+	}
+
 }
@@ -16,51 +16,56 @@ import java.util.List;
 
 /**
  * acts as a bridge from ajde's OutputLocationManager interface to the compiler internals
+ * 
  * @author adrian
- *
+ * 
  */
 public interface CompilationResultDestinationManager {
 
 	/**
-	 * Return the directory root under which the results of compiling the given
-	 * source file. For example, if the source file contains the type a.b.C, and
-	 * this method returns "target/classes" the resulting class file will be written
-	 * to "target/classes/a/b/C.class"
+	 * Return the directory root under which the results of compiling the given source file. For example, if the source file
+	 * contains the type a.b.C, and this method returns "target/classes" the resulting class file will be written to
+	 * "target/classes/a/b/C.class"
 	 * 
-	 * @param compilationUnit  the compilation unit that has been
-	 *  compiled
-	 * @return a File object representing the root directory under which compilation results for this
-	 *  unit should be written
+	 * @param compilationUnit the compilation unit that has been compiled
+	 * @return a File object representing the root directory under which compilation results for this unit should be written
 	 */
 	File getOutputLocationForClass(File compilationUnit);
-	
+
 	/**
-     * Return the source folder where this source file came from, relative to the project root.
-     * For example 'src' or 'src/main/java' or 'src/test/java'
-     * @param sourceFile the file for which the source folder should be determined
-     * @return the source folder
-     */
- 	String getSourceFolderForFile(File sourceFile);
-	
+	 * Return the source folder where this source file came from, relative to the project root. For example 'src' or 'src/main/java'
+	 * or 'src/test/java'
+	 * 
+	 * @param sourceFile the file for which the source folder should be determined
+	 * @return the source folder
+	 */
+	String getSourceFolderForFile(File sourceFile);
+
 	/**
-	 * When copying resources from source folders to output location, return the
-	 * root directory under which the resource should be copied.
+	 * When copying resources from source folders to output location, return the root directory under which the resource should be
+	 * copied.
 	 * 
 	 * @param resource the resource to be copied
-	 * @return a File object representing the root directory under which this resource
-	 * should be copied
+	 * @return a File object representing the root directory under which this resource should be copied
 	 */
 	File getOutputLocationForResource(File resource);
-	
+
 	/**
 	 * Return a list of all output locations handled by this OutputLocationManager
 	 */
-	List /*File*/ getAllOutputLocations();
-	
+	List /* File */getAllOutputLocations();
+
 	/**
-	 * Return the default output location (for example, <my_project>/bin). This is
-	 * where classes which are on the inpath will be placed.
+	 * Return the default output location (for example, <my_project>/bin). This is where classes which are on the inpath will be
+	 * placed.
 	 */
 	File getDefaultOutputLocation();
-	
+
+	/**
+	 * Report that a class file is being written to the specified location.
+	 * 
+	 * @param outputfile the output file (including .class suffix)
+	 */
+	void reportClassFileWrite(String outputfile);
+
 }
@@ -1077,6 +1077,9 @@ public class AjBuildManager implements IOutputClassFileNameProvider, IBinarySour
 				} else {
 					outFile = new File(destinationPath, filename).getPath();
 				}
+				if (buildConfig.getCompilationResultDestinationManager() != null) {
+					buildConfig.getCompilationResultDestinationManager().reportClassFileWrite(outFile);
+				}
 				BufferedOutputStream os = FileUtil.makeOutputStream(new File(outFile));
 				os.write(classFile.getBytes());
 				os.close();
