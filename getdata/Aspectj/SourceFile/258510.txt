@@ -126,17 +126,14 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 	// ??? duplicates some of super's code
 	public void completeTypeBindings() {
 		AsmManager.setCompletingTypeBindings(true);
-		ContextToken completeTypeBindingsToken = CompilationAndWeavingContext
-				.enteringPhase(
-						CompilationAndWeavingContext.COMPLETING_TYPE_BINDINGS,
-						"");
+		ContextToken completeTypeBindingsToken = CompilationAndWeavingContext.enteringPhase(
+				CompilationAndWeavingContext.COMPLETING_TYPE_BINDINGS, "");
 		// builtInterTypesAndPerClauses = false;
 		// pendingTypesToWeave = new ArrayList();
 		stepCompleted = BUILD_TYPE_HIERARCHY;
 
 		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
-			ContextToken tok = CompilationAndWeavingContext.enteringPhase(
-					CompilationAndWeavingContext.CHECK_AND_SET_IMPORTS,
+			ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.CHECK_AND_SET_IMPORTS,
 					units[i].compilationResult.fileName);
 			units[i].scope.checkAndSetImports();
 			CompilationAndWeavingContext.leavingPhase(tok);
@@ -144,8 +141,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		stepCompleted = CHECK_AND_SET_IMPORTS;
 
 		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
-			ContextToken tok = CompilationAndWeavingContext.enteringPhase(
-					CompilationAndWeavingContext.CONNECTING_TYPE_HIERARCHY,
+			ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.CONNECTING_TYPE_HIERARCHY,
 					units[i].compilationResult.fileName);
 			units[i].scope.connectTypeHierarchy();
 			CompilationAndWeavingContext.leavingPhase(tok);
@@ -153,8 +149,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		stepCompleted = CONNECT_TYPE_HIERARCHY;
 
 		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
-			ContextToken tok = CompilationAndWeavingContext.enteringPhase(
-					CompilationAndWeavingContext.BUILDING_FIELDS_AND_METHODS,
+			ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.BUILDING_FIELDS_AND_METHODS,
 					units[i].compilationResult.fileName);
 			// units[i].scope.checkParameterizedTypes(); do this check a little
 			// later, after ITDs applied to stbs
@@ -242,9 +237,8 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 			while (typesToProcess.size() > 0) {
 				// A side effect of weaveIntertypes() is that the processed type
 				// is removed from the collection
-				weaveIntertypes(typesToProcess,
-						(SourceTypeBinding) typesToProcess.get(0), typeMungers,
-						declareParents, declareAnnotationOnTypes);
+				weaveIntertypes(typesToProcess, (SourceTypeBinding) typesToProcess.get(0), typeMungers, declareParents,
+						declareAnnotationOnTypes);
 			}
 
 		} else {
@@ -252,8 +246,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 			for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
 				// System.err.println("Working on "+new
 				// String(units[i].getFileName()));
-				weaveInterTypeDeclarations(units[i].scope, typeMungers,
-						declareParents, declareAnnotationOnTypes);
+				weaveInterTypeDeclarations(units[i].scope, typeMungers, declareParents, declareAnnotationOnTypes);
 			}
 		}
 
@@ -264,10 +257,8 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
 			SourceTypeBinding[] b = units[i].scope.topLevelTypes;
 			for (int j = 0; j < b.length; j++) {
-				ContextToken tok = CompilationAndWeavingContext
-						.enteringPhase(
-								CompilationAndWeavingContext.RESOLVING_POINTCUT_DECLARATIONS,
-								b[j].sourceName);
+				ContextToken tok = CompilationAndWeavingContext.enteringPhase(
+						CompilationAndWeavingContext.RESOLVING_POINTCUT_DECLARATIONS, b[j].sourceName);
 				resolvePointcutDeclarations(b[j].scope);
 				CompilationAndWeavingContext.leavingPhase(tok);
 			}
@@ -276,10 +267,8 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
 			SourceTypeBinding[] b = units[i].scope.topLevelTypes;
 			for (int j = 0; j < b.length; j++) {
-				ContextToken tok = CompilationAndWeavingContext
-						.enteringPhase(
-								CompilationAndWeavingContext.ADDING_DECLARE_WARNINGS_AND_ERRORS,
-								b[j].sourceName);
+				ContextToken tok = CompilationAndWeavingContext.enteringPhase(
+						CompilationAndWeavingContext.ADDING_DECLARE_WARNINGS_AND_ERRORS, b[j].sourceName);
 				addAdviceLikeDeclares(b[j].scope);
 				CompilationAndWeavingContext.leavingPhase(tok);
 			}
@@ -326,7 +315,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 	// new Integer(i+1),
 	// typeVariables[i].getDisplayName(),
 	// superType.getGenericType().getName());
-	//factory.getWorld().getMessageHandler().handleMessage(MessageUtil.error(msg
+	// factory.getWorld().getMessageHandler().handleMessage(MessageUtil.error(msg
 	// ,onType.getSourceLocation()));
 	// }
 	// }
@@ -343,25 +332,21 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		} else if (rb instanceof ParameterizedTypeBinding) {
 			// If its a PTB we need to pull the SourceTypeBinding out of it.
 			ParameterizedTypeBinding ptb = (ParameterizedTypeBinding) rb;
-			if (ptb.type instanceof SourceTypeBinding
-					&& yetToProcess.contains(ptb.type)) {
-				collectAllITDsAndDeclares((SourceTypeBinding) ptb.type,
-						yetToProcess);
+			if (ptb.type instanceof SourceTypeBinding && yetToProcess.contains(ptb.type)) {
+				collectAllITDsAndDeclares((SourceTypeBinding) ptb.type, yetToProcess);
 			}
 		}
 	}
 
 	/**
-	 * Find all the ITDs and Declares, but it is important we do this from the
-	 * supertypes down to the subtypes.
+	 * Find all the ITDs and Declares, but it is important we do this from the supertypes down to the subtypes.
 	 * 
 	 * @param sourceType
 	 * @param yetToProcess
 	 */
 	private void collectAllITDsAndDeclares(SourceTypeBinding sourceType, Collection yetToProcess) {
 		// Look at the supertype first
-		ContextToken tok = CompilationAndWeavingContext.enteringPhase(
-				CompilationAndWeavingContext.COLLECTING_ITDS_AND_DECLARES,
+		ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.COLLECTING_ITDS_AND_DECLARES,
 				sourceType.sourceName);
 
 		yetToProcess.remove(sourceType);
@@ -382,41 +367,32 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 	}
 
 	/**
-	 * Weave the parents and intertype decls into a given type. This method
-	 * looks at the supertype and superinterfaces for the specified type and
-	 * recurses to weave those first if they are in the full list of types we
-	 * are going to process during this compile... it stops recursing the first
-	 * time it hits a type we aren't going to process during this compile. This
-	 * could cause problems if you supply 'pieces' of a hierarchy, i.e. the
-	 * bottom and the top, but not the middle - but what the hell are you doing
-	 * if you do that?
+	 * Weave the parents and intertype decls into a given type. This method looks at the supertype and superinterfaces for the
+	 * specified type and recurses to weave those first if they are in the full list of types we are going to process during this
+	 * compile... it stops recursing the first time it hits a type we aren't going to process during this compile. This could cause
+	 * problems if you supply 'pieces' of a hierarchy, i.e. the bottom and the top, but not the middle - but what the hell are you
+	 * doing if you do that?
 	 */
-	private void weaveIntertypes(List typesToProcess,
-			SourceTypeBinding typeToWeave, Collection typeMungers,
+	private void weaveIntertypes(List typesToProcess, SourceTypeBinding typeToWeave, Collection typeMungers,
 			Collection declareParents, Collection declareAnnotationOnTypes) {
 		// Look at the supertype first
 		ReferenceBinding superType = typeToWeave.superclass();
-		if (typesToProcess.contains(superType)
-				&& superType instanceof SourceTypeBinding) {
+		if (typesToProcess.contains(superType) && superType instanceof SourceTypeBinding) {
 			// System.err.println("Recursing to supertype "+new
 			// String(superType.getFileName()));
-			weaveIntertypes(typesToProcess, (SourceTypeBinding) superType,
-					typeMungers, declareParents, declareAnnotationOnTypes);
+			weaveIntertypes(typesToProcess, (SourceTypeBinding) superType, typeMungers, declareParents, declareAnnotationOnTypes);
 		}
 		// Then look at the superinterface list
 		ReferenceBinding[] interfaceTypes = typeToWeave.superInterfaces();
 		for (int i = 0; i < interfaceTypes.length; i++) {
 			ReferenceBinding binding = interfaceTypes[i];
-			if (typesToProcess.contains(binding)
-					&& binding instanceof SourceTypeBinding) {
+			if (typesToProcess.contains(binding) && binding instanceof SourceTypeBinding) {
 				// System.err.println("Recursing to superinterface "+new
 				// String(binding.getFileName()));
-				weaveIntertypes(typesToProcess, (SourceTypeBinding) binding,
-						typeMungers, declareParents, declareAnnotationOnTypes);
+				weaveIntertypes(typesToProcess, (SourceTypeBinding) binding, typeMungers, declareParents, declareAnnotationOnTypes);
 			}
 		}
-		weaveInterTypeDeclarations(typeToWeave, typeMungers, declareParents,
-				declareAnnotationOnTypes, false);
+		weaveInterTypeDeclarations(typeToWeave, typeMungers, declareParents, declareAnnotationOnTypes, false);
 		typesToProcess.remove(typeToWeave);
 	}
 
@@ -497,12 +473,10 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 	}
 
 	/**
-	 * Return true if the declaration has @Aspect annotation. Called 'couldBe'
-	 * rather than 'is' because someone else may have defined an annotation
-	 * called Aspect - we can't verify the full name (including package name)
-	 * because it may not have been resolved just yet and rather going through
-	 * expensive resolution when we dont have to, this gives us a cheap check
-	 * that tells us whether to bother.
+	 * Return true if the declaration has @Aspect annotation. Called 'couldBe' rather than 'is' because someone else may have
+	 * defined an annotation called Aspect - we can't verify the full name (including package name) because it may not have been
+	 * resolved just yet and rather going through expensive resolution when we dont have to, this gives us a cheap check that tells
+	 * us whether to bother.
 	 */
 	private boolean couldBeAnnotationStyleAspectDeclaration(TypeDeclaration dec) {
 		Annotation[] annotations = dec.annotations;
@@ -590,8 +564,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 	private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, Collection typeMungers, Collection declareParents,
 			Collection declareAnnotationOnTypes, boolean skipInners) {
 
-		ContextToken tok = CompilationAndWeavingContext.enteringPhase(
-				CompilationAndWeavingContext.WEAVING_INTERTYPE_DECLARATIONS,
+		ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.WEAVING_INTERTYPE_DECLARATIONS,
 				sourceType.sourceName);
 
 		ResolvedType onType = factory.fromEclipse(sourceType);
@@ -622,13 +595,11 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		// Check if the type we are looking at is the topMostImplementor of a
 		// dangerous interface -
 		// report a problem if it is.
-		for (Iterator i = dangerousInterfaces.entrySet().iterator(); i
-				.hasNext();) {
+		for (Iterator i = dangerousInterfaces.entrySet().iterator(); i.hasNext();) {
 			Map.Entry entry = (Map.Entry) i.next();
 			ResolvedType interfaceType = (ResolvedType) entry.getKey();
 			if (onType.isTopmostImplementor(interfaceType)) {
-				factory.showMessage(IMessage.ERROR, onType + ": "
-						+ entry.getValue(), onType.getSourceLocation(), null);
+				factory.showMessage(IMessage.ERROR, onType + ": " + entry.getValue(), onType.getSourceLocation(), null);
 			}
 		}
 
@@ -754,16 +725,13 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 	}
 
 	/**
-	 * Called when we discover we are weaving intertype declarations on some
-	 * type that has an existing 'WeaverStateInfo' object - this is typically
-	 * some previously woven type that has been passed on the inpath.
+	 * Called when we discover we are weaving intertype declarations on some type that has an existing 'WeaverStateInfo' object -
+	 * this is typically some previously woven type that has been passed on the inpath.
 	 * 
 	 * sourceType and onType are the 'same type' - the former is the 'Eclipse' version and the latter is the 'Weaver' version.
 	 */
-	private void processTypeMungersFromExistingWeaverState(
-			SourceTypeBinding sourceType, ResolvedType onType) {
-		Collection previouslyAppliedMungers = onType.getWeaverState()
-				.getTypeMungers(onType);
+	private void processTypeMungersFromExistingWeaverState(SourceTypeBinding sourceType, ResolvedType onType) {
+		Collection previouslyAppliedMungers = onType.getWeaverState().getTypeMungers(onType);
 
 		for (Iterator i = previouslyAppliedMungers.iterator(); i.hasNext();) {
 			ConcreteTypeMunger m = (ConcreteTypeMunger) i.next();
@@ -784,16 +752,14 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.PROCESSING_DECLARE_PARENTS,
 				sourceType.sourceName);
 		ResolvedType resolvedSourceType = factory.fromEclipse(sourceType);
-		List newParents = declareParents.findMatchingNewParents(
-				resolvedSourceType, false);
+		List newParents = declareParents.findMatchingNewParents(resolvedSourceType, false);
 		if (!newParents.isEmpty()) {
 			for (Iterator i = newParents.iterator(); i.hasNext();) {
 				ResolvedType parent = (ResolvedType) i.next();
 				if (dangerousInterfaces.containsKey(parent)) {
 					ResolvedType onType = factory.fromEclipse(sourceType);
-					factory.showMessage(IMessage.ERROR, onType + ": "
-							+ dangerousInterfaces.get(parent), onType
-							.getSourceLocation(), null);
+					factory.showMessage(IMessage.ERROR, onType + ": " + dangerousInterfaces.get(parent),
+							onType.getSourceLocation(), null);
 				}
 				if (Modifier.isFinal(parent.getModifiers())) {
 					factory.showMessage(IMessage.ERROR, "cannot extend final class " + parent.getClassName(), declareParents
@@ -849,16 +815,14 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		return sb.toString();
 	}
 
-	private boolean doDeclareAnnotations(DeclareAnnotation decA,
-			SourceTypeBinding sourceType, boolean reportProblems) {
+	private boolean doDeclareAnnotations(DeclareAnnotation decA, SourceTypeBinding sourceType, boolean reportProblems) {
 		ResolvedType rtx = factory.fromEclipse(sourceType);
 		if (!decA.matches(rtx))
 			return false;
 		if (!rtx.isExposedToWeaver())
 			return false;
 
-		ContextToken tok = CompilationAndWeavingContext.enteringPhase(
-				CompilationAndWeavingContext.PROCESSING_DECLARE_ANNOTATIONS,
+		ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.PROCESSING_DECLARE_ANNOTATIONS,
 				sourceType.sourceName);
 
 		// Get the annotation specified in the declare
@@ -966,23 +930,16 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 
 					if (reportProblems) {
 						if (decA.isExactPattern()) {
-							factory
-									.showMessage(
-											IMessage.ERROR,
-											WeaverMessages
-													.format(
-															WeaverMessages.INCORRECT_TARGET_FOR_DECLARE_ANNOTATION,
-															rtx.getName(),
-															toAdd[0].type,
-															stringifyTargets(abits)),
-											decA.getSourceLocation(), null);
+							factory.showMessage(IMessage.ERROR, WeaverMessages.format(
+									WeaverMessages.INCORRECT_TARGET_FOR_DECLARE_ANNOTATION, rtx.getName(), toAdd[0].type,
+									stringifyTargets(abits)), decA.getSourceLocation(), null);
 						}
 						// dont put out the lint - the weaving process will do
 						// that
 						// else {
 						// if (factory.getWorld().getLint().
 						// invalidTargetForAnnotation.isEnabled()) {
-						//factory.getWorld().getLint().invalidTargetForAnnotation
+						// factory.getWorld().getLint().invalidTargetForAnnotation
 						// .signal(new
 						// String[]{rtx.getName(),toAdd[0].type.toString(),
 						// stringifyTargets
@@ -1008,8 +965,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		if (currentAnnotations != null)
 			for (int i = 0; i < currentAnnotations.length; i++) {
 				Annotation annotation = currentAnnotations[i];
-				String a = CharOperation
-						.toString(annotation.type.getTypeName());
+				String a = CharOperation.toString(annotation.type.getTypeName());
 				String b = CharOperation.toString(toAdd[0].type.getTypeName());
 				// FIXME asc we have a lint for attempting to add an annotation
 				// twice to a method,
@@ -1076,20 +1032,16 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 	}
 
 	/**
-	 * Transform an annotation from its AJ form to an eclipse form. We *DONT*
-	 * care about the values of the annotation. that is because it is only being
-	 * stuck on a type during type completion to allow for other constructs
-	 * (decps, decas) that might be looking for it - when the class actually
-	 * gets to disk it wont have this new annotation on it and during weave time
-	 * we will do the right thing copying across values too.
+	 * Transform an annotation from its AJ form to an eclipse form. We *DONT* care about the values of the annotation. that is
+	 * because it is only being stuck on a type during type completion to allow for other constructs (decps, decas) that might be
+	 * looking for it - when the class actually gets to disk it wont have this new annotation on it and during weave time we will do
+	 * the right thing copying across values too.
 	 */
-	private static Annotation createAnnotationFromBcelAnnotation(
-			AnnotationAJ annX, int pos, EclipseFactory factory) {
+	private static Annotation createAnnotationFromBcelAnnotation(AnnotationAJ annX, int pos, EclipseFactory factory) {
 		String name = annX.getTypeName();
 		TypeBinding tb = factory.makeTypeBinding(annX.getType());
 		// String theName = annX.getSignature().getBaseName();
-		char[][] typeName = CharOperation.splitOn('.', name.replace('$', '.')
-				.toCharArray()); // pr149293 - not bulletproof...
+		char[][] typeName = CharOperation.splitOn('.', name.replace('$', '.').toCharArray()); // pr149293 - not bulletproof...
 		long[] positions = new long[typeName.length];
 		for (int i = 0; i < positions.length; i++)
 			positions[i] = pos;
@@ -1220,7 +1172,8 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 			ReferenceType rt = (ReferenceType) onType;
 			ReferenceTypeDelegate rtd = rt.getDelegate();
 			if (rtd instanceof BcelObjectType) {
-				((BcelObjectType) rtd).addParent(parent);
+				rt.addParent(parent);
+				// ((BcelObjectType) rtd).addParent(parent);
 			}
 		}
 
@@ -1275,9 +1228,8 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 	}
 
 	/**
-	 * Callback driven when the compiler detects an anonymous type during block
-	 * resolution. We need to add it to the weaver so that we don't trip up
-	 * later.
+	 * Callback driven when the compiler detects an anonymous type during block resolution. We need to add it to the weaver so that
+	 * we don't trip up later.
 	 * 
 	 * @param aBinding
 	 */
@@ -1361,7 +1313,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 // System.arraycopy(currentlyHas,0,newset,1,currentlyHas.length);
 // }
 // methodDecl.annotations = newset;
-//System.err.println("New set on "+CharOperation.charToString(sourceMb.selector)
+// System.err.println("New set on "+CharOperation.charToString(sourceMb.selector)
 // +" is "+newset);
 // } else
 // System.err.println("NO MATCH");
@@ -81,8 +81,7 @@ import org.aspectj.weaver.patterns.PerSingleton;
 import org.aspectj.weaver.patterns.Pointcut;
 
 /**
- * Supports viewing eclipse TypeDeclarations/SourceTypeBindings as a
- * ResolvedType
+ * Supports viewing eclipse TypeDeclarations/SourceTypeBindings as a ResolvedType
  * 
  * @author Jim Hugunin
  */
@@ -358,8 +357,8 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 	}
 
 	/**
-	 * This method may not return all fields, for example it may not include the
-	 * ajc$initFailureCause or ajc$perSingletonInstance fields - see bug 129613
+	 * This method may not return all fields, for example it may not include the ajc$initFailureCause or ajc$perSingletonInstance
+	 * fields - see bug 129613
 	 */
 	public ResolvedMember[] getDeclaredFields() {
 		if (declaredFields == null)
@@ -368,8 +367,8 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 	}
 
 	/**
-	 * This method may not return all methods, for example it may not include
-	 * clinit, aspectOf, hasAspect or ajc$postClinit methods - see bug 129613
+	 * This method may not return all methods, for example it may not include clinit, aspectOf, hasAspect or ajc$postClinit methods
+	 * - see bug 129613
 	 */
 	public ResolvedMember[] getDeclaredMethods() {
 		if (declaredMethods == null)
@@ -464,18 +463,12 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 
 	public boolean isEnum() {
 		return (binding.getAccessFlags() & ACC_ENUM) != 0;
-	}
+		}
 
 	public boolean isAnnotation() {
 		return (binding.getAccessFlags() & ACC_ANNOTATION) != 0;
 	}
 
-	public void addAnnotation(AnnotationAJ annotationX) {
-		// XXX Big hole here - annotationX holds a BCEL annotation but
-		// we need an Eclipse one here, we haven't written the conversion utils
-		// yet. Not sure if this method will be called in practice...
-		throw new RuntimeException("EclipseSourceType.addAnnotation() not implemented");
-	}
 
 	public boolean isAnnotationWithRuntimeRetention() {
 		if (!isAnnotation()) {
@@ -590,23 +583,17 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 	/**
 	 * WARNING: This method does not have a complete implementation.
 	 * 
-	 * The aim is that it converts Eclipse annotation objects to the AspectJ
-	 * form of annotations (the type AnnotationAJ). The AnnotationX objects
-	 * returned are wrappers over either a Bcel annotation type or the AspectJ
-	 * AnnotationAJ type. The minimal implementation provided here is for
-	 * processing the RetentionPolicy and Target annotation types - these are
-	 * the only ones which the weaver will attempt to process from an
-	 * EclipseSourceType.
+	 * The aim is that it converts Eclipse annotation objects to the AspectJ form of annotations (the type AnnotationAJ). The
+	 * AnnotationX objects returned are wrappers over either a Bcel annotation type or the AspectJ AnnotationAJ type. The minimal
+	 * implementation provided here is for processing the RetentionPolicy and Target annotation types - these are the only ones
+	 * which the weaver will attempt to process from an EclipseSourceType.
 	 * 
-	 * More notes: The pipeline has required us to implement this. With the
-	 * pipeline we can be weaving a type and asking questions of annotations
-	 * before they have been turned into Bcel objects - ie. when they are still
-	 * in EclipseSourceType form. Without the pipeline we would have converted
-	 * everything to Bcel objects before proceeding with weaving. Because the
-	 * pipeline won't start weaving until all aspects have been compiled and the
-	 * fact that no AspectJ constructs match on the values within annotations,
-	 * this code only needs to deal with converting system annotations that the
-	 * weaver needs to process (RetentionPolicy, Target).
+	 * More notes: The pipeline has required us to implement this. With the pipeline we can be weaving a type and asking questions
+	 * of annotations before they have been turned into Bcel objects - ie. when they are still in EclipseSourceType form. Without
+	 * the pipeline we would have converted everything to Bcel objects before proceeding with weaving. Because the pipeline won't
+	 * start weaving until all aspects have been compiled and the fact that no AspectJ constructs match on the values within
+	 * annotations, this code only needs to deal with converting system annotations that the weaver needs to process
+	 * (RetentionPolicy, Target).
 	 */
 	public AnnotationAJ[] getAnnotations() {
 		if (annotations != null)
@@ -625,14 +612,11 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 	}
 
 	/**
-	 * Convert one eclipse annotation into an AnnotationX object containing an
-	 * AnnotationAJ object.
+	 * Convert one eclipse annotation into an AnnotationX object containing an AnnotationAJ object.
 	 * 
-	 * This code and the helper methods used by it will go *BANG* if they
-	 * encounter anything not currently supported - this is safer than limping
-	 * along with a malformed annotation. When the *BANG* is encountered the bug
-	 * reporter should indicate the kind of annotation they were working with
-	 * and this code can be enhanced to support it.
+	 * This code and the helper methods used by it will go *BANG* if they encounter anything not currently supported - this is safer
+	 * than limping along with a malformed annotation. When the *BANG* is encountered the bug reporter should indicate the kind of
+	 * annotation they were working with and this code can be enhanced to support it.
 	 */
 	public AnnotationAJ convertEclipseAnnotation(Annotation eclipseAnnotation, World w) {
 		// TODO if it is sourcevisible, we shouldn't let it through!!!!!!!!!
@@ -652,8 +636,7 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 	}
 
 	/**
-	 * Use the information in the supplied eclipse based annotation to fill in
-	 * the standard annotation.
+	 * Use the information in the supplied eclipse based annotation to fill in the standard annotation.
 	 * 
 	 * @param annotation eclipse based annotation representation
 	 * @param annotationAJ AspectJ based annotation representation
@@ -1044,8 +1027,4 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 		return tv;
 	}
 
-	public void ensureDelegateConsistent() {
-		// do nothing, currently these can't become inconsistent (phew)
-	}
-
 }
@@ -37,11 +37,10 @@ import org.aspectj.weaver.tools.PointcutDesignatorHandler;
 import org.aspectj.weaver.tools.PointcutParameter;
 
 /**
- * @author colyer Provides Java 5 behaviour in reflection based delegates
- *         (overriding 1.4 behaviour from superclass where appropriate)
+ * @author colyer Provides Java 5 behaviour in reflection based delegates (overriding 1.4 behaviour from superclass where
+ *         appropriate)
  */
-public class Java15ReflectionBasedReferenceTypeDelegate extends
-		ReflectionBasedReferenceTypeDelegate {
+public class Java15ReflectionBasedReferenceTypeDelegate extends ReflectionBasedReferenceTypeDelegate {
 
 	private AjType<?> myType;
 	private ResolvedType[] annotations;
@@ -60,22 +59,19 @@ public class Java15ReflectionBasedReferenceTypeDelegate extends
 	}
 
 	@Override
-	public void initialize(ReferenceType aType, Class aClass,
-			ClassLoader classLoader, World aWorld) {
+	public void initialize(ReferenceType aType, Class aClass, ClassLoader classLoader, World aWorld) {
 		super.initialize(aType, aClass, classLoader, aWorld);
 		myType = AjTypeSystem.getAjType(aClass);
 		annotationFinder = new Java15AnnotationFinder();
 		argNameFinder = annotationFinder;
-		annotationFinder.setClassLoader(this.classLoaderReference
-				.getClassLoader());
+		annotationFinder.setClassLoader(this.classLoaderReference.getClassLoader());
 		annotationFinder.setWorld(aWorld);
 		this.typeConverter = new JavaLangTypeToResolvedTypeConverter(aWorld);
 	}
 
 	public ReferenceType buildGenericType() {
-		return (ReferenceType) UnresolvedType.forGenericTypeVariables(
-				getResolvedTypeX().getSignature(), getTypeVariables()).resolve(
-				getWorld());
+		return (ReferenceType) UnresolvedType.forGenericTypeVariables(getResolvedTypeX().getSignature(), getTypeVariables())
+				.resolve(getWorld());
 	}
 
 	public AnnotationAJ[] getAnnotations() {
@@ -89,8 +85,7 @@ public class Java15ReflectionBasedReferenceTypeDelegate extends
 
 	public ResolvedType[] getAnnotationTypes() {
 		if (annotations == null) {
-			annotations = annotationFinder.getAnnotations(getBaseClass(),
-					getWorld());
+			annotations = annotationFinder.getAnnotations(getBaseClass(), getWorld());
 		}
 		return annotations;
 	}
@@ -136,8 +131,8 @@ public class Java15ReflectionBasedReferenceTypeDelegate extends
 	// If the superclass is null, return Object - same as bcel does
 	public ResolvedType getSuperclass() {
 		if (superclass == null && getBaseClass() != Object.class) {// superclass
-																	// of Object
-																	// is null
+			// of Object
+			// is null
 			Type t = this.getBaseClass().getGenericSuperclass();
 			if (t != null)
 				superclass = typeConverter.fromType(t);
@@ -148,41 +143,33 @@ public class Java15ReflectionBasedReferenceTypeDelegate extends
 	}
 
 	public TypeVariable[] getTypeVariables() {
-		TypeVariable[] workInProgressSetOfVariables = (TypeVariable[]) getResolvedTypeX()
-				.getWorld().getTypeVariablesCurrentlyBeingProcessed(
-						getBaseClass());
+		TypeVariable[] workInProgressSetOfVariables = (TypeVariable[]) getResolvedTypeX().getWorld()
+				.getTypeVariablesCurrentlyBeingProcessed(getBaseClass());
 		if (workInProgressSetOfVariables != null) {
 			return workInProgressSetOfVariables;
 		}
 		if (this.typeVariables == null) {
-			java.lang.reflect.TypeVariable[] tVars = this.getBaseClass()
-					.getTypeParameters();
+			java.lang.reflect.TypeVariable[] tVars = this.getBaseClass().getTypeParameters();
 			TypeVariable[] rTypeVariables = new TypeVariable[tVars.length];
 			// basic initialization
 			for (int i = 0; i < tVars.length; i++) {
 				rTypeVariables[i] = new TypeVariable(tVars[i].getName());
 			}
 			// stash it
-			this.getResolvedTypeX().getWorld()
-					.recordTypeVariablesCurrentlyBeingProcessed(getBaseClass(),
-							rTypeVariables);
+			this.getResolvedTypeX().getWorld().recordTypeVariablesCurrentlyBeingProcessed(getBaseClass(), rTypeVariables);
 			// now fill in the details...
 			for (int i = 0; i < tVars.length; i++) {
-				TypeVariableReferenceType tvrt = ((TypeVariableReferenceType) typeConverter
-						.fromType(tVars[i]));
+				TypeVariableReferenceType tvrt = ((TypeVariableReferenceType) typeConverter.fromType(tVars[i]));
 				TypeVariable tv = tvrt.getTypeVariable();
 				rTypeVariables[i].setUpperBound(tv.getUpperBound());
-				rTypeVariables[i].setAdditionalInterfaceBounds(tv
-						.getAdditionalInterfaceBounds());
+				rTypeVariables[i].setAdditionalInterfaceBounds(tv.getAdditionalInterfaceBounds());
 				rTypeVariables[i].setDeclaringElement(tv.getDeclaringElement());
-				rTypeVariables[i].setDeclaringElementKind(tv
-						.getDeclaringElementKind());
+				rTypeVariables[i].setDeclaringElementKind(tv.getDeclaringElementKind());
 				rTypeVariables[i].setRank(tv.getRank());
 				rTypeVariables[i].setLowerBound(tv.getLowerBound());
 			}
 			this.typeVariables = rTypeVariables;
-			this.getResolvedTypeX().getWorld()
-					.forgetTypeVariablesCurrentlyBeingProcessed(getBaseClass());
+			this.getResolvedTypeX().getWorld().forgetTypeVariablesCurrentlyBeingProcessed(getBaseClass());
 		}
 		return this.typeVariables;
 	}
@@ -193,8 +180,7 @@ public class Java15ReflectionBasedReferenceTypeDelegate extends
 		if (methods == null) {
 			Method[] reflectMethods = this.myType.getDeclaredMethods();
 			Constructor[] reflectCons = this.myType.getDeclaredConstructors();
-			ResolvedMember[] rMethods = new ResolvedMember[reflectMethods.length
-					+ reflectCons.length];
+			ResolvedMember[] rMethods = new ResolvedMember[reflectMethods.length + reflectCons.length];
 			for (int i = 0; i < reflectMethods.length; i++) {
 				rMethods[i] = createGenericMethodMember(reflectMethods[i]);
 			}
@@ -217,49 +203,33 @@ public class Java15ReflectionBasedReferenceTypeDelegate extends
 	}
 
 	private ResolvedMember createGenericMethodMember(Method forMethod) {
-		ReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(
-				org.aspectj.weaver.Member.METHOD, getGenericResolvedType(),
-				forMethod.getModifiers(), typeConverter.fromType(forMethod
-						.getReturnType()), forMethod.getName(), typeConverter
-						.fromTypes(forMethod.getParameterTypes()),
-				typeConverter.fromTypes(forMethod.getExceptionTypes()),
-				forMethod);
+		ReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.METHOD,
+				getGenericResolvedType(), forMethod.getModifiers(), typeConverter.fromType(forMethod.getReturnType()), forMethod
+						.getName(), typeConverter.fromTypes(forMethod.getParameterTypes()), typeConverter.fromTypes(forMethod
+						.getExceptionTypes()), forMethod);
 		ret.setAnnotationFinder(this.annotationFinder);
-		ret
-				.setGenericSignatureInformationProvider(new Java15GenericSignatureInformationProvider(
-						this.getWorld()));
+		ret.setGenericSignatureInformationProvider(new Java15GenericSignatureInformationProvider(this.getWorld()));
 		return ret;
 	}
 
-	private ResolvedMember createGenericConstructorMember(
-			Constructor forConstructor) {
-		ReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(
-				org.aspectj.weaver.Member.METHOD,
-				getGenericResolvedType(),
-				forConstructor.getModifiers(),
+	private ResolvedMember createGenericConstructorMember(Constructor forConstructor) {
+		ReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.METHOD,
+				getGenericResolvedType(), forConstructor.getModifiers(),
 				// to return what BCEL returns the return type is void
 				ResolvedType.VOID,// getGenericResolvedType(),
-				"<init>", typeConverter.fromTypes(forConstructor
-						.getParameterTypes()), typeConverter
-						.fromTypes(forConstructor.getExceptionTypes()),
-				forConstructor);
+				"<init>", typeConverter.fromTypes(forConstructor.getParameterTypes()), typeConverter.fromTypes(forConstructor
+						.getExceptionTypes()), forConstructor);
 		ret.setAnnotationFinder(this.annotationFinder);
-		ret
-				.setGenericSignatureInformationProvider(new Java15GenericSignatureInformationProvider(
-						this.getWorld()));
+		ret.setGenericSignatureInformationProvider(new Java15GenericSignatureInformationProvider(this.getWorld()));
 		return ret;
 	}
 
 	private ResolvedMember createGenericFieldMember(Field forField) {
-		ReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(
-				org.aspectj.weaver.Member.FIELD, getGenericResolvedType(),
-				forField.getModifiers(), typeConverter.fromType(forField
-						.getType()), forField.getName(), new UnresolvedType[0],
-				forField);
+		ReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.FIELD,
+				getGenericResolvedType(), forField.getModifiers(), typeConverter.fromType(forField.getType()), forField.getName(),
+				new UnresolvedType[0], forField);
 		ret.setAnnotationFinder(this.annotationFinder);
-		ret
-				.setGenericSignatureInformationProvider(new Java15GenericSignatureInformationProvider(
-						this.getWorld()));
+		ret.setGenericSignatureInformationProvider(new Java15GenericSignatureInformationProvider(this.getWorld()));
 		return ret;
 	}
 
@@ -270,18 +240,13 @@ public class Java15ReflectionBasedReferenceTypeDelegate extends
 			InternalUseOnlyPointcutParser parser = null;
 			World world = getWorld();
 			if (world instanceof ReflectionWorld) {
-				parser = new InternalUseOnlyPointcutParser(classLoaderReference
-						.getClassLoader(), (ReflectionWorld) getWorld());
+				parser = new InternalUseOnlyPointcutParser(classLoaderReference.getClassLoader(), (ReflectionWorld) getWorld());
 			} else {
-				parser = new InternalUseOnlyPointcutParser(classLoaderReference
-						.getClassLoader());
+				parser = new InternalUseOnlyPointcutParser(classLoaderReference.getClassLoader());
 			}
-			Set additionalPointcutHandlers = world
-					.getRegisteredPointcutHandlers();
-			for (Iterator handlerIterator = additionalPointcutHandlers
-					.iterator(); handlerIterator.hasNext();) {
-				PointcutDesignatorHandler handler = (PointcutDesignatorHandler) handlerIterator
-						.next();
+			Set additionalPointcutHandlers = world.getRegisteredPointcutHandlers();
+			for (Iterator handlerIterator = additionalPointcutHandlers.iterator(); handlerIterator.hasNext();) {
+				PointcutDesignatorHandler handler = (PointcutDesignatorHandler) handlerIterator.next();
 				parser.registerPointcutDesignatorHandler(handler);
 			}
 
@@ -293,12 +258,10 @@ public class Java15ReflectionBasedReferenceTypeDelegate extends
 				AjType<?>[] ptypes = pcs[i].getParameterTypes();
 				UnresolvedType[] weaverPTypes = new UnresolvedType[ptypes.length];
 				for (int j = 0; j < weaverPTypes.length; j++) {
-					weaverPTypes[j] = this.typeConverter.fromType(ptypes[j]
-							.getJavaClass());
+					weaverPTypes[j] = this.typeConverter.fromType(ptypes[j].getJavaClass());
 				}
-				pointcuts[i] = new DeferredResolvedPointcutDefinition(
-						getResolvedTypeX(), pcs[i].getModifiers(), pcs[i]
-								.getName(), weaverPTypes);
+				pointcuts[i] = new DeferredResolvedPointcutDefinition(getResolvedTypeX(), pcs[i].getModifiers(), pcs[i].getName(),
+						weaverPTypes);
 			}
 			// phase 2, now go back round and resolve in-place all of the
 			// pointcuts
@@ -309,30 +272,23 @@ public class Java15ReflectionBasedReferenceTypeDelegate extends
 				if (pnames.length != ptypes.length) {
 					pnames = tryToDiscoverParameterNames(pcs[i]);
 					if (pnames == null || (pnames.length != ptypes.length)) {
-						throw new IllegalStateException(
-								"Required parameter names not available when parsing pointcut "
-										+ pcs[i].getName() + " in type "
-										+ getResolvedTypeX().getName());
+						throw new IllegalStateException("Required parameter names not available when parsing pointcut "
+								+ pcs[i].getName() + " in type " + getResolvedTypeX().getName());
 					}
 				}
 				parameters[i] = new PointcutParameter[ptypes.length];
 				for (int j = 0; j < parameters[i].length; j++) {
-					parameters[i][j] = parser.createPointcutParameter(
-							pnames[j], ptypes[j].getJavaClass());
+					parameters[i][j] = parser.createPointcutParameter(pnames[j], ptypes[j].getJavaClass());
 				}
 				String pcExpr = pcs[i].getPointcutExpression().toString();
-				org.aspectj.weaver.patterns.Pointcut pc = parser
-						.resolvePointcutExpression(pcExpr, getBaseClass(),
-								parameters[i]);
-				((ResolvedPointcutDefinition) pointcuts[i])
-						.setParameterNames(pnames);
+				org.aspectj.weaver.patterns.Pointcut pc = parser.resolvePointcutExpression(pcExpr, getBaseClass(), parameters[i]);
+				((ResolvedPointcutDefinition) pointcuts[i]).setParameterNames(pnames);
 				((ResolvedPointcutDefinition) pointcuts[i]).setPointcut(pc);
 			}
 			// phase 3, now concretize them all
 			for (int i = 0; i < pointcuts.length; i++) {
 				ResolvedPointcutDefinition rpd = (ResolvedPointcutDefinition) pointcuts[i];
-				rpd.setPointcut(parser.concretizePointcutExpression(rpd
-						.getPointcut(), getBaseClass(), parameters[i]));
+				rpd.setPointcut(parser.concretizePointcutExpression(rpd.getPointcut(), getBaseClass(), parameters[i]));
 			}
 		}
 		return pointcuts;
@@ -340,8 +296,7 @@ public class Java15ReflectionBasedReferenceTypeDelegate extends
 
 	// for @AspectJ pointcuts compiled by javac only...
 	private String[] tryToDiscoverParameterNames(Pointcut pcut) {
-		Method[] ms = pcut.getDeclaringType().getJavaClass()
-				.getDeclaredMethods();
+		Method[] ms = pcut.getDeclaringType().getJavaClass().getDeclaredMethods();
 		for (Method m : ms) {
 			if (m.getName().equals(pcut.getName())) {
 				return argNameFinder.getParameterNames(m);
@@ -18,11 +18,10 @@ import java.util.Map;
 import org.aspectj.weaver.patterns.PerClause;
 
 /**
- * A BoundedReferenceType is the result of a generics wildcard expression ?
- * extends String, ? super Foo etc..
+ * A BoundedReferenceType is the result of a generics wildcard expression ? extends String, ? super Foo etc..
  * 
- * The "signature" for a bounded reference type follows the generic signature
- * specification in section 4.4 of JVM spec: *,+,- plus signature strings.
+ * The "signature" for a bounded reference type follows the generic signature specification in section 4.4 of JVM spec: *,+,- plus
+ * signature strings.
  * 
  * The bound may be a type variable (e.g. ? super T)
  */
@@ -46,10 +45,8 @@ public class BoundedReferenceType extends ReferenceType {
 		return lowerBound;
 	}
 
-	public BoundedReferenceType(ReferenceType aBound, boolean isExtends,
-			World world) {
-		super((isExtends ? "+" : "-") + aBound.signature,
-				aBound.signatureErasure, world);
+	public BoundedReferenceType(ReferenceType aBound, boolean isExtends, World world) {
+		super((isExtends ? "+" : "-") + aBound.signature, aBound.signatureErasure, world);
 		this.isExtends = isExtends;
 		this.isSuper = !isExtends;
 		if (isExtends) {
@@ -58,12 +55,10 @@ public class BoundedReferenceType extends ReferenceType {
 			lowerBound = aBound;
 			upperBound = world.resolve(UnresolvedType.OBJECT);
 		}
-		setDelegate(new ReferenceTypeReferenceTypeDelegate(
-				(ReferenceType) getUpperBound()));
+		setDelegate(new ReferenceTypeReferenceTypeDelegate((ReferenceType) getUpperBound()));
 	}
 
-	public BoundedReferenceType(ReferenceType aBound, boolean isExtends,
-			World world, ReferenceType[] additionalInterfaces) {
+	public BoundedReferenceType(ReferenceType aBound, boolean isExtends, World world, ReferenceType[] additionalInterfaces) {
 		this(aBound, isExtends, world);
 		this.additionalInterfaceBounds = additionalInterfaces;
 	}
@@ -76,29 +71,24 @@ public class BoundedReferenceType extends ReferenceType {
 		ReferenceType[] parameterizedAdditionalInterfaces = new ReferenceType[additionalInterfaceBounds == null ? 0
 				: additionalInterfaceBounds.length];
 		for (int i = 0; i < parameterizedAdditionalInterfaces.length; i++) {
-			parameterizedAdditionalInterfaces[i] = (ReferenceType) additionalInterfaceBounds[i]
-					.parameterize(typeBindings);
+			parameterizedAdditionalInterfaces[i] = (ReferenceType) additionalInterfaceBounds[i].parameterize(typeBindings);
 		}
 		if (isExtends) {
-			return new BoundedReferenceType((ReferenceType) getUpperBound()
-					.parameterize(typeBindings), isExtends, world,
+			return new BoundedReferenceType((ReferenceType) getUpperBound().parameterize(typeBindings), isExtends, world,
 					parameterizedAdditionalInterfaces);
 		} else {
-			return new BoundedReferenceType((ReferenceType) getLowerBound()
-					.parameterize(typeBindings), isExtends, world,
+			return new BoundedReferenceType((ReferenceType) getLowerBound().parameterize(typeBindings), isExtends, world,
 					parameterizedAdditionalInterfaces);
 		}
 	}
 
 	/**
-	 * only for use when resolving GenericsWildcardTypeX or a
-	 * TypeVariableReferenceType
+	 * only for use when resolving GenericsWildcardTypeX or a TypeVariableReferenceType
 	 */
 	protected BoundedReferenceType(String sig, String sigErasure, World world) {
 		super(sig, sigErasure, world);
 		upperBound = world.resolve(UnresolvedType.OBJECT);
-		setDelegate(new ReferenceTypeReferenceTypeDelegate(
-				(ReferenceType) getUpperBound()));
+		setDelegate(new ReferenceTypeReferenceTypeDelegate((ReferenceType) getUpperBound()));
 	}
 
 	public ReferenceType[] getInterfaceBounds() {
@@ -110,8 +100,7 @@ public class BoundedReferenceType extends ReferenceType {
 	}
 
 	public boolean isExtends() {
-		return (isExtends && !getUpperBound().getSignature().equals(
-				"Ljava/lang/Object;"));
+		return (isExtends && !getUpperBound().getSignature().equals("Ljava/lang/Object;"));
 	}
 
 	public boolean isSuper() {
@@ -121,12 +110,10 @@ public class BoundedReferenceType extends ReferenceType {
 	public boolean alwaysMatches(ResolvedType aCandidateType) {
 		if (isExtends()) {
 			// aCandidateType must be a subtype of upperBound
-			return ((ReferenceType) getUpperBound())
-					.isAssignableFrom(aCandidateType);
+			return ((ReferenceType) getUpperBound()).isAssignableFrom(aCandidateType);
 		} else if (isSuper()) {
 			// aCandidateType must be a supertype of lowerBound
-			return aCandidateType
-					.isAssignableFrom((ReferenceType) getLowerBound());
+			return aCandidateType.isAssignableFrom((ReferenceType) getLowerBound());
 		} else {
 			return true; // straight '?'
 		}
@@ -142,9 +129,7 @@ public class BoundedReferenceType extends ReferenceType {
 			ResolvedType myLowerBound = (ResolvedType) getLowerBound();
 			if (isExtends()) {
 				if (boundedRT.isExtends()) {
-					return myUpperBound
-							.isAssignableFrom((ResolvedType) boundedRT
-									.getUpperBound());
+					return myUpperBound.isAssignableFrom((ResolvedType) boundedRT.getUpperBound());
 				} else if (boundedRT.isSuper()) {
 					return myUpperBound == boundedRT.getLowerBound();
 				} else {
@@ -152,8 +137,7 @@ public class BoundedReferenceType extends ReferenceType {
 				}
 			} else if (isSuper()) {
 				if (boundedRT.isSuper()) {
-					return ((ResolvedType) boundedRT.getLowerBound())
-							.isAssignableFrom(myLowerBound);
+					return ((ResolvedType) boundedRT.getLowerBound()).isAssignableFrom(myLowerBound);
 				} else if (boundedRT.isExtends()) {
 					return myLowerBound == boundedRT.getUpperBound();
 				} else {
@@ -181,13 +165,9 @@ public class BoundedReferenceType extends ReferenceType {
 	public ResolvedType[] getDeclaredInterfaces() {
 		ResolvedType[] interfaces = super.getDeclaredInterfaces();
 		if (additionalInterfaceBounds.length > 0) {
-			ResolvedType[] allInterfaces = new ResolvedType[interfaces.length
-					+ additionalInterfaceBounds.length];
-			System
-					.arraycopy(interfaces, 0, allInterfaces, 0,
-							interfaces.length);
-			System.arraycopy(additionalInterfaceBounds, 0, allInterfaces,
-					interfaces.length, additionalInterfaceBounds.length);
+			ResolvedType[] allInterfaces = new ResolvedType[interfaces.length + additionalInterfaceBounds.length];
+			System.arraycopy(interfaces, 0, allInterfaces, 0, interfaces.length);
+			System.arraycopy(additionalInterfaceBounds, 0, allInterfaces, interfaces.length, additionalInterfaceBounds.length);
 			return allInterfaces;
 		} else {
 			return interfaces;
@@ -198,18 +178,12 @@ public class BoundedReferenceType extends ReferenceType {
 		return true;
 	}
 
-	protected static class ReferenceTypeReferenceTypeDelegate extends
-			AbstractReferenceTypeDelegate {
+	protected static class ReferenceTypeReferenceTypeDelegate extends AbstractReferenceTypeDelegate {
 
 		public ReferenceTypeReferenceTypeDelegate(ReferenceType backing) {
 			super(backing, false);
 		}
 
-		public void addAnnotation(AnnotationAJ annotationX) {
-			throw new UnsupportedOperationException(
-					"What on earth do you think you are doing???");
-		}
-
 		public boolean isAspect() {
 			return resolvedTypeX.isAspect();
 		}
@@ -326,9 +300,5 @@ public class BoundedReferenceType extends ReferenceType {
 			return resolvedTypeX.getTypeVariables();
 		}
 
-		public void ensureDelegateConsistent() {
-			resolvedTypeX.getDelegate().ensureDelegateConsistent();
-		}
-
 	}
 }
@@ -26,11 +26,6 @@ public class GeneratedReferenceTypeDelegate extends AbstractReferenceTypeDelegat
 	public GeneratedReferenceTypeDelegate(ReferenceType backing) {
 		super(backing, false);
 	}
-
-	public void addAnnotation(AnnotationAJ annotationX) {
-		throw new UnsupportedOperationException("Not supported for GeneratedReferenceTypeDelegate");
-	}
-
 	public boolean isAspect() {
 		throw new UnsupportedOperationException("Not supported for GeneratedReferenceTypeDelegate");
 	}
@@ -151,8 +146,4 @@ public class GeneratedReferenceTypeDelegate extends AbstractReferenceTypeDelegat
 		throw new UnsupportedOperationException("Not supported for GeneratedReferenceTypeDelegate");
 	}
 
-	public void ensureDelegateConsistent() {
-		throw new UnsupportedOperationException("Not supported for GeneratedReferenceTypeDelegate");
-	}
-
 }
\ No newline at end of file
@@ -53,6 +53,18 @@ public class ReferenceType extends ResolvedType {
 	Collection parameterizedDeclares = null;
 	Collection parameterizedTypeMungers = null;
 
+	// During matching it can be necessary to temporary mark types as annotated. For example
+	// a declare @type may trigger a separate declare parents to match, and so the annotation
+	// is temporarily held against the referencetype, the annotation will be properly
+	// added to the class during weaving.
+	private ResolvedType[] annotationTypes = null;
+	private AnnotationAJ[] annotations = null;
+	
+	// Similarly these are temporary replacements and additions for the superclass and
+	// superinterfaces
+	private ResolvedType newSuperclass;
+	private ResolvedType[] newInterfaces;
+
 	// ??? should set delegate before any use
 	public ReferenceType(String signature, World world) {
 		super(signature, world);
@@ -133,23 +145,72 @@ public class ReferenceType extends ResolvedType {
 	}
 
 	public void addAnnotation(AnnotationAJ annotationX) {
-		delegate.addAnnotation(annotationX);
+		if (annotations == null) {
+			annotations = new AnnotationAJ[1];
+			annotations[0] = annotationX;
+		} else {
+			AnnotationAJ[] newAnnotations = new AnnotationAJ[annotations.length + 1];
+			System.arraycopy(annotations, 0, newAnnotations, 1, annotations.length);
+			newAnnotations[0] = annotationX;
+			annotations = newAnnotations;
+		}
+		addAnnotationType(annotationX.getType());
 	}
 
 	public boolean hasAnnotation(UnresolvedType ofType) {
-		return delegate.hasAnnotation(ofType);
+		boolean onDelegate = delegate.hasAnnotation(ofType);
+		if (onDelegate) {
+			return true;
+		}
+		if (annotationTypes != null) {
+			for (int i = 0; i < annotationTypes.length; i++) {
+				if (annotationTypes[i].equals(ofType)) {
+					return true;
+				}
+			}
+		}
+		return false;
+	}
+
+	private void addAnnotationType(ResolvedType ofType) {
+		if (annotationTypes == null) {
+			annotationTypes = new ResolvedType[1];
+			annotationTypes[0] = ofType;
+		} else {
+			ResolvedType[] newAnnotationTypes = new ResolvedType[annotationTypes.length + 1];
+			System.arraycopy(annotationTypes, 0, newAnnotationTypes, 1, annotationTypes.length);
+			newAnnotationTypes[0] = ofType;
+			annotationTypes = newAnnotationTypes;
+		}
 	}
 
 	public ResolvedType[] getAnnotationTypes() {
 		if (delegate == null) {
 			throw new BCException("Unexpected null delegate for type " + this.getName());
 		}
-		return delegate.getAnnotationTypes();
+		if (annotationTypes == null) {
+			// there are no extras:
+			return delegate.getAnnotationTypes();
+		} else {
+			ResolvedType[] delegateAnnotationTypes = delegate.getAnnotationTypes();
+			ResolvedType[] result = new ResolvedType[annotationTypes.length + delegateAnnotationTypes.length];
+			System.arraycopy(delegateAnnotationTypes, 0, result, 0, delegateAnnotationTypes.length);
+			System.arraycopy(annotationTypes, 0, result, delegateAnnotationTypes.length, annotationTypes.length);
+			return result;
+		}
 	}
 
 	public AnnotationAJ getAnnotationOfType(UnresolvedType ofType) {
 		AnnotationAJ[] axs = delegate.getAnnotations();
 		if (axs == null) {
+			if (annotations != null) {
+				String searchSig = ofType.getSignature();
+				for (int i = 0; i < annotations.length; i++) {
+					if (annotations[i].getTypeSignature().equals(searchSig)) {
+						return annotations[i];
+					}
+				}
+			}
 			return null;
 		}
 		for (int i = 0; i < axs.length; i++) {
@@ -477,8 +538,14 @@ public class ReferenceType extends ResolvedType {
 	public ResolvedType[] getDeclaredInterfaces() {
 		if (parameterizedInterfaces != null)
 			return parameterizedInterfaces;
+		ResolvedType[] delegateInterfaces = delegate.getDeclaredInterfaces();
+		if (newInterfaces != null) {
+			ResolvedType[] extraInterfaces = new ResolvedType[delegateInterfaces.length + newInterfaces.length];
+			System.arraycopy(delegateInterfaces, 0, extraInterfaces, 0, delegateInterfaces.length);
+			System.arraycopy(newInterfaces, 0, extraInterfaces, delegateInterfaces.length, newInterfaces.length);
+			delegateInterfaces = extraInterfaces;
+		}
 		if (isParameterizedType()) {
-			ResolvedType[] delegateInterfaces = delegate.getDeclaredInterfaces();
 			// UnresolvedType[] paramTypes =
 			// getTypesForMemberParameterization();
 			parameterizedInterfaces = new ResolvedType[delegateInterfaces.length];
@@ -495,7 +562,6 @@ public class ReferenceType extends ResolvedType {
 			}
 			return parameterizedInterfaces;
 		} else if (isRawType()) {
-			ResolvedType[] delegateInterfaces = delegate.getDeclaredInterfaces();
 			UnresolvedType[] paramTypes = getTypesForMemberParameterization();
 			parameterizedInterfaces = new ResolvedType[delegateInterfaces.length];
 			for (int i = 0; i < parameterizedInterfaces.length; i++) {
@@ -513,7 +579,7 @@ public class ReferenceType extends ResolvedType {
 			}
 			return parameterizedInterfaces;
 		}
-		return delegate.getDeclaredInterfaces();
+		return delegateInterfaces;
 	}
 
 	/**
@@ -715,6 +781,12 @@ public class ReferenceType extends ResolvedType {
 	}
 
 	public ResolvedType getSuperclass() {
+		if (newSuperclass != null) {
+			if (this.isParameterizedType() && newSuperclass.isParameterizedType()) {
+				return newSuperclass.parameterize(getMemberParameterizationMap()).resolve(getWorld());
+			}
+			return newSuperclass;
+		}
 		ResolvedType ret = null;
 		try {
 			world.setTypeVariableLookupScope(this);
@@ -840,4 +912,36 @@ public class ReferenceType extends ResolvedType {
 		return ret.toString();
 	}
 
+	public void ensureConsistent() {
+		annotations = null;
+		annotationTypes = null;
+		newSuperclass = null;
+		newInterfaces = null;
+	}
+
+
+	public void addParent(ResolvedType newParent) {
+		if (newParent.isClass()) {
+			newSuperclass = newParent;
+		} else {
+			if (newInterfaces == null) {
+				newInterfaces = new ResolvedType[1];
+				newInterfaces[0] = newParent;
+			} else {
+				ResolvedType[] existing = delegate.getDeclaredInterfaces();
+				if (existing != null) {
+					for (int i = 0; i < existing.length; i++) {
+						if (existing[i].equals(newParent)) {
+							return; // already has this interface
+						}
+					}
+				}
+				ResolvedType[] newNewInterfaces = new ResolvedType[newInterfaces.length + 1];
+				System.arraycopy(newInterfaces, 0, newNewInterfaces, 1, newInterfaces.length);
+				newNewInterfaces[0] = newParent;
+				newInterfaces = newNewInterfaces;
+				parameterizedInterfaces = null;// invalidate cached info
+			}
+		}
+	}
 }
\ No newline at end of file
@@ -17,21 +17,17 @@ import java.util.Collection;
 import org.aspectj.weaver.patterns.PerClause;
 
 /**
- * Abstraction over a type - a reference type is Object and a descendant of Object, other types (int/etc) are considered primitive
+ * Abstraction over a type - a reference type is Object or a descendant of Object, other types (int/etc) are considered primitive
  * types. Abstract implementation provided by AbstractReferenceTypeDelegate.
  */
-public interface ReferenceTypeDelegate {
-
-	// TODO asc move to proxy
-	public void addAnnotation(AnnotationAJ annotationX);
-
-	public void ensureDelegateConsistent(); // Required evil because of mutator
 
-	// methods in delegates :( (see
-	// pr85132)
+public interface ReferenceTypeDelegate {
 
 	public boolean isAspect();
-
+	
+	/**
+	 * @return true if the type is an annotation style aspect (a type marked @Aspect)
+	 */
 	public boolean isAnnotationStyleAspect();
 
 	public boolean isInterface();
@@ -42,10 +38,19 @@ public interface ReferenceTypeDelegate {
 
 	public String getRetentionPolicy();
 
+	/**
+	 * @return true if this annotation type can be on a regular type (ie. it doesn't specify anything or it specifies TYPE)
+	 */
 	public boolean canAnnotationTargetType();
 
+	/**
+	 * @return all the possible targets that this annotation can be placed upon
+	 */
 	public AnnotationTargetKind[] getAnnotationTargetKinds();
 
+	/**
+	 * @return true if this annotation type has a retention policy of RUNTIME
+	 */
 	public boolean isAnnotationWithRuntimeRetention();
 
 	public boolean isClass();
@@ -56,8 +61,6 @@ public interface ReferenceTypeDelegate {
 
 	public boolean isNested();
 
-	public boolean isExposedToWeaver();
-
 	public boolean hasAnnotation(UnresolvedType ofType);
 
 	public AnnotationAJ[] getAnnotations();
@@ -74,6 +77,12 @@ public interface ReferenceTypeDelegate {
 
 	public TypeVariable[] getTypeVariables();
 
+	public int getModifiers();
+
+	// aspect declaration related members
+	/**
+	 * @return for an aspect declaration, return the
+	 */
 	public PerClause getPerClause();
 
 	public Collection getDeclares();
@@ -82,7 +91,7 @@ public interface ReferenceTypeDelegate {
 
 	public Collection getPrivilegedAccesses();
 
-	public int getModifiers();
+	// end of aspect declaration related members
 
 	public ResolvedType getSuperclass();
 
@@ -90,6 +99,9 @@ public interface ReferenceTypeDelegate {
 
 	public ReferenceType getResolvedTypeX();
 
+	// needs renaming isWeavable or removing from here
+	public boolean isExposedToWeaver();
+
 	public boolean doesNotExposeShadowMungers();
 
 	public ISourceContext getSourceContext();
@@ -335,39 +335,39 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 	 * described in JVM spec 2ed 5.4.3.3. Doesnt check ITDs.
 	 * 
 	 * <p>
-	 * Check the current type for the method.  If it is not found, check the super class and any super interfaces.  Taking
-	 * care not to process interfaces multiple times.
+	 * Check the current type for the method. If it is not found, check the super class and any super interfaces. Taking care not to
+	 * process interfaces multiple times.
 	 */
 	public ResolvedMember lookupMethod(Member m) {
 		List typesTolookat = new ArrayList();
 		typesTolookat.add(this);
 		int pos = 0;
-		while (pos<typesTolookat.size()) {
-			ResolvedType type = (ResolvedType)typesTolookat.get(pos++);
+		while (pos < typesTolookat.size()) {
+			ResolvedType type = (ResolvedType) typesTolookat.get(pos++);
 			if (!type.isMissing()) {
 				ResolvedMember[] methods = type.getDeclaredMethods();
-				if (methods!=null) {
-					for (int i=0;i<methods.length;i++) {
+				if (methods != null) {
+					for (int i = 0; i < methods.length; i++) {
 						ResolvedMember method = methods[i];
 						if (matches(method, m)) {
 							return method;
 						}
 						// might be worth checking the method behind the parameterized method (137496)
-						if (method.hasBackingGenericMember() && m.getName().equals(method.getName())) { 
+						if (method.hasBackingGenericMember() && m.getName().equals(method.getName())) {
 							if (matches(method.getBackingGenericMember(), m))
 								return method;
-						}					
+						}
 					}
 				}
 			}
 			// Queue the superclass:
 			ResolvedType superclass = type.getSuperclass();
-			if (superclass!=null) {
+			if (superclass != null) {
 				typesTolookat.add(superclass);
 			}
 			// Queue any interfaces not already checked:
 			ResolvedType[] superinterfaces = type.getDeclaredInterfaces();
-			if (superinterfaces!=null) {
+			if (superinterfaces != null) {
 				for (int i = 0; i < superinterfaces.length; i++) {
 					ResolvedType interf = superinterfaces[i];
 					if (!typesTolookat.contains(interf)) {
@@ -391,7 +391,6 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 		return null;
 	}
 
-	
 	/**
 	 * return null if not found
 	 */
@@ -550,7 +549,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 			ResolvedPointcutDefinition f = (ResolvedPointcutDefinition) i.next();
 			// the resolvedpointcutdefinition can be null if there are other problems that
 			// prevented its resolution
-			if (f!=null && name.equals(f.getName())) {
+			if (f != null && name.equals(f.getName())) {
 				return f;
 			}
 		}
@@ -650,6 +649,10 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 		return acc;
 	}
 
+	public void addParent(ResolvedType newParent) {
+		// Nothing to do for anything except a ReferenceType
+	}
+
 	protected boolean doesNotExposeShadowMungers() {
 		return false;
 	}
@@ -1875,7 +1878,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 			// System.err.println("looking at: " + inherited + " in " + this);
 			// System.err.println("            " + inherited.isAbstract() +
 			// " in " + this.isAbstract());
-			if (inherited!=null && inherited.isAbstract()) {
+			if (inherited != null && inherited.isAbstract()) {
 				if (!this.isAbstract()) {
 					getWorld().showMessage(IMessage.ERROR,
 							WeaverMessages.format(WeaverMessages.POINCUT_NOT_CONCRETE, inherited, this.getName()),
@@ -2243,4 +2246,13 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 		return binaryPath;
 	}
 
+	/**
+	 * Undo any temporary modifications to the type (for example it may be holding annotations temporarily whilst some matching is
+	 * occurring - These annotations will be added properly during weaving but sometimes for type completion they need to be held
+	 * here for a while).
+	 */
+	public void ensureConsistent() {
+		// Nothing to do for anything except a ReferenceType
+	}
+
 }
@@ -18,108 +18,105 @@ import java.io.IOException;
  * Represents a type variable with bounds
  */
 public class TypeVariable {
-	
+
 	public static final TypeVariable[] NONE = new TypeVariable[0];
 	/**
-	 * whether or not the bounds of this type variable have been 
-	 * resolved
+	 * whether or not the bounds of this type variable have been resolved
 	 */
 	private boolean isResolved = false;
-	
-	
+
 	private boolean beingResolved = false;
-	
+
 	/**
 	 * the name of the type variable as recorded in the generic signature
 	 */
 	private String name;
-	
+
 	private int rank;
 
-    // It would be nice to push this field onto the TypeVariableDeclaringElement
-    // interface (a getKind()) but at the moment we don't always guarantee
-    // to set the declaring element (eclipse seems to utilise the knowledge of
-    // what declared the type variable, but we dont yet...)
+	// It would be nice to push this field onto the TypeVariableDeclaringElement
+	// interface (a getKind()) but at the moment we don't always guarantee
+	// to set the declaring element (eclipse seems to utilise the knowledge of
+	// what declared the type variable, but we dont yet...)
 	/**
 	 * What kind of element declared this type variable?
 	 */
 	private int declaringElementKind = UNKNOWN;
 	public static final int UNKNOWN = -1;
-	public static final int METHOD  = 1;
-	public static final int TYPE    = 2;
+	public static final int METHOD = 1;
+	public static final int TYPE = 2;
 	private TypeVariableDeclaringElement declaringElement;
-	
+
 	/**
-	 * the upper bound of the type variable (default to Object).
-	 * From the extends clause, eg. T extends Number.
+	 * the upper bound of the type variable (default to Object). From the extends clause, eg. T extends Number.
 	 */
 	private UnresolvedType upperBound = UnresolvedType.OBJECT;
-	
+
 	/**
-	 * any additional upper (interface) bounds.
-	 * from the extends clause, e.g. T extends Number & Comparable
+	 * any additional upper (interface) bounds. from the extends clause, e.g. T extends Number & Comparable
 	 */
 	private UnresolvedType[] additionalInterfaceBounds = new UnresolvedType[0];
-	
+
 	/**
-	 * any lower bound.
-	 * from the super clause, eg T super Foo
+	 * any lower bound. from the super clause, eg T super Foo
 	 */
 	private UnresolvedType lowerBound = null;
-	
+
 	public TypeVariable(String aName) {
 		this.name = aName;
 	}
-	
+
 	public TypeVariable(String aName, UnresolvedType anUpperBound) {
 		this(aName);
 		this.upperBound = anUpperBound;
 	}
-	
-	public TypeVariable(String aName, UnresolvedType anUpperBound, 
-			                        UnresolvedType[] someAdditionalInterfaceBounds) {
-		this(aName,anUpperBound);
+
+	public TypeVariable(String aName, UnresolvedType anUpperBound, UnresolvedType[] someAdditionalInterfaceBounds) {
+		this(aName, anUpperBound);
 		this.additionalInterfaceBounds = someAdditionalInterfaceBounds;
 	}
-	
-	public TypeVariable(String aName, UnresolvedType anUpperBound, 
-            UnresolvedType[] someAdditionalInterfaceBounds, UnresolvedType aLowerBound) {
-		this(aName,anUpperBound,someAdditionalInterfaceBounds);
+
+	public TypeVariable(String aName, UnresolvedType anUpperBound, UnresolvedType[] someAdditionalInterfaceBounds,
+			UnresolvedType aLowerBound) {
+		this(aName, anUpperBound, someAdditionalInterfaceBounds);
 		this.lowerBound = aLowerBound;
 	}
-	
-	// First bound is the first 'real' bound, this can be an interface if 
+
+	// First bound is the first 'real' bound, this can be an interface if
 	// no class bound was specified (it will default to object)
 	public UnresolvedType getFirstBound() {
-		if (upperBound.equals(UnresolvedType.OBJECT) && additionalInterfaceBounds!=null && additionalInterfaceBounds.length!=0) {
+		if (upperBound.equals(UnresolvedType.OBJECT) && additionalInterfaceBounds != null && additionalInterfaceBounds.length != 0) {
 			return additionalInterfaceBounds[0];
 		}
 		return upperBound;
 	}
-	
+
 	public UnresolvedType getUpperBound() {
 		return upperBound;
 	}
-	
+
 	public UnresolvedType[] getAdditionalInterfaceBounds() {
 		return additionalInterfaceBounds;
 	}
-	
+
 	public UnresolvedType getLowerBound() {
 		return lowerBound;
 	}
-	
+
 	public String getName() {
 		return name;
 	}
-	
+
 	/**
 	 * resolve all the bounds of this type variable
 	 */
 	public TypeVariable resolve(World inSomeWorld) {
-		if (beingResolved) { return this; } // avoid spiral of death
+		if (beingResolved) {
+			return this;
+		} // avoid spiral of death
 		beingResolved = true;
-		if (isResolved) return this;
+		if (isResolved)
+			return this;
 
 		TypeVariable resolvedTVar = null;
 
@@ -140,33 +137,35 @@ public class TypeVariable {
 				ResolvedMember declaring = (ResolvedMember) declaringElement;
 				TypeVariable[] tvrts = declaring.getTypeVariables();
 				for (int i = 0; i < tvrts.length; i++) {
-					if (tvrts[i].getName().equals(getName())) resolvedTVar = tvrts[i];
-//					if (tvrts[i].isTypeVariableReference()) {
-//						TypeVariableReferenceType tvrt = (TypeVariableReferenceType) tvrts[i].resolve(inSomeWorld);
-//						TypeVariable tv = tvrt.getTypeVariable();
-//						if (tv.getName().equals(getName())) resolvedTVar = tv;
-//					}
-				}			
+					if (tvrts[i].getName().equals(getName()))
+						resolvedTVar = tvrts[i];
+					// if (tvrts[i].isTypeVariableReference()) {
+					// TypeVariableReferenceType tvrt = (TypeVariableReferenceType) tvrts[i].resolve(inSomeWorld);
+					// TypeVariable tv = tvrt.getTypeVariable();
+					// if (tv.getName().equals(getName())) resolvedTVar = tv;
+					// }
+				}
 			}
-			
+
 			if (resolvedTVar == null) {
 				// well, this is bad... we didn't find the type variable on the member
 				// could be a separate compilation issue...
 				// should issue message, this is a workaround to get us going...
-				resolvedTVar = this;				
+				resolvedTVar = this;
 			}
 		} else {
 			resolvedTVar = this;
 		}
-				
+
 		upperBound = resolvedTVar.upperBound;
 		lowerBound = resolvedTVar.lowerBound;
 		additionalInterfaceBounds = resolvedTVar.additionalInterfaceBounds;
-		
+
 		upperBound = upperBound.resolve(inSomeWorld);
-		if (lowerBound != null) lowerBound = lowerBound.resolve(inSomeWorld);
-		
-		if (additionalInterfaceBounds!=null) {
+		if (lowerBound != null)
+			lowerBound = lowerBound.resolve(inSomeWorld);
+
+		if (additionalInterfaceBounds != null) {
 			for (int i = 0; i < additionalInterfaceBounds.length; i++) {
 				additionalInterfaceBounds[i] = additionalInterfaceBounds[i].resolve(inSomeWorld);
 			}
@@ -175,63 +174,63 @@ public class TypeVariable {
 		beingResolved = false;
 		return this;
 	}
-	
+
 	/**
-	 * answer true if the given type satisfies all of the bound constraints of this
-	 * type variable.
-	 * If type variable has not been resolved then throws IllegalStateException
+	 * answer true if the given type satisfies all of the bound constraints of this type variable. If type variable has not been
+	 * resolved then throws IllegalStateException
 	 */
 	public boolean canBeBoundTo(ResolvedType aCandidateType) {
-		if (!isResolved) throw new IllegalStateException("Can't answer binding questions prior to resolving");
-		
+		if (!isResolved)
+			throw new IllegalStateException("Can't answer binding questions prior to resolving");
+
 		// wildcard can accept any binding
-		if (aCandidateType.isGenericWildcard()) {  // AMC - need a more robust test!
+		if (aCandidateType.isGenericWildcard()) { // AMC - need a more robust test!
 			return true;
 		}
-		
+
 		// otherwise can be bound iff...
-		//  aCandidateType is a subtype of upperBound
-		if (!isASubtypeOf(upperBound,aCandidateType)) {
+		// aCandidateType is a subtype of upperBound
+		if (!isASubtypeOf(upperBound, aCandidateType)) {
 			return false;
 		}
-		//  aCandidateType is a subtype of all additionalInterfaceBounds
+		// aCandidateType is a subtype of all additionalInterfaceBounds
 		for (int i = 0; i < additionalInterfaceBounds.length; i++) {
 			if (!isASubtypeOf(additionalInterfaceBounds[i], aCandidateType)) {
 				return false;
 			}
 		}
-		//  lowerBound is a subtype of aCandidateType
-		if ((lowerBound != null) && (!isASubtypeOf(aCandidateType,lowerBound))) {
+		// lowerBound is a subtype of aCandidateType
+		if ((lowerBound != null) && (!isASubtypeOf(aCandidateType, lowerBound))) {
 			return false;
 		}
 		return true;
 	}
-	
+
 	private boolean isASubtypeOf(UnresolvedType candidateSuperType, UnresolvedType candidateSubType) {
 		ResolvedType superType = (ResolvedType) candidateSuperType;
 		ResolvedType subType = (ResolvedType) candidateSubType;
 		return superType.isAssignableFrom(subType);
 	}
 
-	// only used when resolving 
+	// only used when resolving
 	public void setUpperBound(UnresolvedType aTypeX) {
 		this.upperBound = aTypeX;
 	}
-	
+
 	// only used when resolving
 	public void setLowerBound(UnresolvedType aTypeX) {
 		this.lowerBound = aTypeX;
 	}
-	
+
 	// only used when resolving
 	public void setAdditionalInterfaceBounds(UnresolvedType[] someTypeXs) {
 		this.additionalInterfaceBounds = someTypeXs;
 	}
-	
+
 	public String toDebugString() {
 		return getDisplayName();
 	}
-	
+
 	public String getDisplayName() {
 		StringBuffer ret = new StringBuffer();
 		ret.append(name);
@@ -253,54 +252,53 @@ public class TypeVariable {
 		}
 		return ret.toString();
 	}
-	
+
 	// good enough approximation
 	public String toString() {
 		return "TypeVar " + getDisplayName();
 	}
-	
+
 	/**
-	 * Return complete signature, e.g. "T extends Number" would return "T:Ljava/lang/Number;"
-	 * note: MAY INCLUDE P types if bounds are parameterized types
+	 * Return complete signature, e.g. "T extends Number" would return "T:Ljava/lang/Number;" note: MAY INCLUDE P types if bounds
+	 * are parameterized types
 	 */
 	public String getSignature() {
-	  	StringBuffer sb = new StringBuffer();
-	  	sb.append(name);
+		StringBuffer sb = new StringBuffer();
+		sb.append(name);
 		sb.append(":");
-  		sb.append(upperBound.getSignature());
-	  	if (additionalInterfaceBounds!=null && additionalInterfaceBounds.length!=0) {
-		  	sb.append(":");
-		  	for (int i = 0; i < additionalInterfaceBounds.length; i++) {
+		sb.append(upperBound.getSignature());
+		if (additionalInterfaceBounds != null && additionalInterfaceBounds.length != 0) {
+			sb.append(":");
+			for (int i = 0; i < additionalInterfaceBounds.length; i++) {
 				UnresolvedType iBound = additionalInterfaceBounds[i];
 				sb.append(iBound.getSignature());
 			}
-	  	}
+		}
 		return sb.toString();
 	}
-	
+
 	/**
 	 * @return signature for inclusion in an attribute, there must be no 'P' in it signatures
 	 */
 	public String getSignatureForAttribute() {
-	  	StringBuffer sb = new StringBuffer();
-	  	sb.append(name);
+		StringBuffer sb = new StringBuffer();
+		sb.append(name);
 		sb.append(":");
-  		sb.append(((ResolvedType)upperBound).getSignatureForAttribute());
-	  	if (additionalInterfaceBounds!=null && additionalInterfaceBounds.length!=0) {
-		  	sb.append(":");
-		  	for (int i = 0; i < additionalInterfaceBounds.length; i++) {
-				ResolvedType iBound = (ResolvedType)additionalInterfaceBounds[i];
+		sb.append(((ResolvedType) upperBound).getSignatureForAttribute());
+		if (additionalInterfaceBounds != null && additionalInterfaceBounds.length != 0) {
+			sb.append(":");
+			for (int i = 0; i < additionalInterfaceBounds.length; i++) {
+				ResolvedType iBound = (ResolvedType) additionalInterfaceBounds[i];
 				sb.append(iBound.getSignatureForAttribute());
 			}
-	  	}
+		}
 		return sb.toString();
 	}
 
-	
 	public void setRank(int rank) {
-		this.rank=rank;
+		this.rank = rank;
 	}
-	
+
 	public int getRank() {
 		return rank;
 	}
@@ -313,25 +311,25 @@ public class TypeVariable {
 			this.declaringElementKind = METHOD;
 		}
 	}
-	
+
 	public TypeVariableDeclaringElement getDeclaringElement() {
 		return declaringElement;
 	}
-	
+
 	public void setDeclaringElementKind(int kind) {
 		this.declaringElementKind = kind;
 	}
-	
+
 	public int getDeclaringElementKind() {
-//		if (declaringElementKind==UNKNOWN) throw new RuntimeException("Dont know declarer of this tvar : "+this);
+		// if (declaringElementKind==UNKNOWN) throw new RuntimeException("Dont know declarer of this tvar : "+this);
 		return declaringElementKind;
 	}
-	
+
 	public void write(DataOutputStream s) throws IOException {
-	// name, upperbound, additionalInterfaceBounds, lowerbound
+		// name, upperbound, additionalInterfaceBounds, lowerbound
 		s.writeUTF(name);
 		upperBound.write(s);
-		if (additionalInterfaceBounds==null || additionalInterfaceBounds.length==0) {
+		if (additionalInterfaceBounds == null || additionalInterfaceBounds.length == 0) {
 			s.writeInt(0);
 		} else {
 			s.writeInt(additionalInterfaceBounds.length);
@@ -341,30 +339,31 @@ public class TypeVariable {
 			}
 		}
 	}
-	
+
 	public static TypeVariable read(VersionedDataInputStream s) throws IOException {
-    	
-		//if (s.getMajorVersion()>=AjAttribute.WeaverVersionInfo.WEAVER_VERSION_MAJOR_AJ150) {
-			
+
+		// if (s.getMajorVersion()>=AjAttribute.WeaverVersionInfo.WEAVER_VERSION_MAJOR_AJ150) {
+
 		String name = s.readUTF();
 		UnresolvedType ubound = UnresolvedType.read(s);
 		int iboundcount = s.readInt();
 		UnresolvedType[] ibounds = UnresolvedType.NONE;
-		if (iboundcount>0) {
+		if (iboundcount > 0) {
 			ibounds = new UnresolvedType[iboundcount];
-			for (int i=0; i<iboundcount; i++) {
+			for (int i = 0; i < iboundcount; i++) {
 				ibounds[i] = UnresolvedType.read(s);
 			}
 		}
-		
-		TypeVariable newVariable = new TypeVariable(name,ubound,ibounds);
-		return newVariable;		
-    }
+
+		TypeVariable newVariable = new TypeVariable(name, ubound, ibounds);
+		return newVariable;
+	}
 
 	public String getGenericSignature() {
-		return "T"+name+";";
-//		return "T"+getSignature();
+		return "T" + name + ";";
+		// return "T"+getSignature();
 	}
+
 	public String getErasureSignature() {
 		return getFirstBound().getErasureSignature();
 	}
@@ -79,27 +79,11 @@ public class ReflectionBasedReferenceTypeDelegate implements ReferenceTypeDelega
 	public ReferenceType buildGenericType() {
 		throw new UnsupportedOperationException("Shouldn't be asking for generic type at 1.4 source level or lower");
 	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.aspectj.weaver.ReferenceTypeDelegate#addAnnotation(org.aspectj.weaver .AnnotationX)
-	 */
-	public void addAnnotation(AnnotationAJ annotationX) {
-		throw new UnsupportedOperationException("Cannot add an annotation to a reflection based delegate");
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.aspectj.weaver.ReferenceTypeDelegate#isAspect()
-	 */
 	public boolean isAspect() {
 		// we could do better than this in Java 5 by looking at the annotations
 		// on the type...
 		return false;
 	}
-
 	/*
 	 * (non-Javadoc)
 	 * 
@@ -110,46 +94,27 @@ public class ReflectionBasedReferenceTypeDelegate implements ReferenceTypeDelega
 		// on the type...
 		return false;
 	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.aspectj.weaver.ReferenceTypeDelegate#isInterface()
-	 */
+	
 	public boolean isInterface() {
 		return this.myClass.isInterface();
 	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.aspectj.weaver.ReferenceTypeDelegate#isEnum()
-	 */
 	public boolean isEnum() {
 		// cant be an enum in Java 1.4 or prior
 		return false;
 	}
-
 	/*
 	 * (non-Javadoc)
 	 * 
-	 * @see org.aspectj.weaver.ReferenceTypeDelegate#isAnnotation()
+	 * @see org.aspectj.weaver.ReferenceTypeDelegate#isAnnotationWithRuntimeRetention ()
 	 */
-	public boolean isAnnotation() {
+	public boolean isAnnotationWithRuntimeRetention() {
 		// cant be an annotation in Java 1.4 or prior
 		return false;
 	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.aspectj.weaver.ReferenceTypeDelegate#isAnnotationWithRuntimeRetention ()
-	 */
-	public boolean isAnnotationWithRuntimeRetention() {
+public boolean isAnnotation() {
 		// cant be an annotation in Java 1.4 or prior
 		return false;
 	}
-
 	public String getRetentionPolicy() {
 		// cant be an annotation in Java 1.4 or prior
 		return null;
@@ -162,12 +127,6 @@ public class ReflectionBasedReferenceTypeDelegate implements ReferenceTypeDelega
 	public AnnotationTargetKind[] getAnnotationTargetKinds() {
 		return null;
 	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.aspectj.weaver.ReferenceTypeDelegate#isClass()
-	 */
 	public boolean isClass() {
 		return !this.myClass.isInterface() && !this.myClass.isPrimitive() && !this.myClass.isArray();
 	}
@@ -418,11 +377,6 @@ public class ReflectionBasedReferenceTypeDelegate implements ReferenceTypeDelega
 		return null;
 	}
 
-	public void ensureDelegateConsistent() {
-		// Nothing to do - a reflection based delegate can't become
-		// inconsistent...
-	}
-
 	public ReflectionBasedResolvedMemberImpl createResolvedMemberFor(Member aMember) {
 		return null;
 	}
@@ -113,7 +113,6 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 	private static final int DISCOVERED_ANNOTATION_TARGET_KINDS = 0x0008;
 	private static final int DISCOVERED_DECLARED_SIGNATURE = 0x0010;
 	private static final int DISCOVERED_WHETHER_ANNOTATION_STYLE = 0x0020;
-	private static final int DAMAGED = 0x0040; // see note(2) below
 
 	private static final String[] NO_INTERFACE_SIGS = new String[] {};
 
@@ -453,12 +452,6 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 		return javaClass;
 	}
 
-	public void ensureDelegateConsistent() {
-		if ((bitflag & DAMAGED) != 0) {
-			resetState();
-		}
-	}
-
 	public void resetState() {
 		if (javaClass == null) {
 			// we might store the classname and allow reloading?
@@ -545,36 +538,6 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 		return wvInfo;
 	}
 
-	public void addParent(ResolvedType newParent) {
-		bitflag |= DAMAGED;
-		if (newParent.isClass()) {
-			superclassSignature = newParent.getSignature();
-			superclassName = newParent.getName();
-			// superClass = newParent;
-		} else {
-			ResolvedType[] oldInterfaceNames = getDeclaredInterfaces();
-			int exists = -1;
-			for (int i = 0; i < oldInterfaceNames.length; i++) {
-				ResolvedType type = oldInterfaceNames[i];
-				if (type.equals(newParent)) {
-					exists = i;
-					break;
-				}
-			}
-			if (exists == -1) {
-
-				int len = interfaceSignatures.length;
-				String[] newInterfaceSignatures = new String[len + 1];
-				System.arraycopy(interfaceSignatures, 0, newInterfaceSignatures, 0, len);
-				newInterfaceSignatures[len] = newParent.getSignature();
-				interfaceSignatures = newInterfaceSignatures;
-			}
-		}
-		// System.err.println("javaClass: " +
-		// Arrays.asList(javaClass.getInterfaceNames()) + " super " +
-		// superclassName);
-		// if (lazyClassGen != null) lazyClassGen.print();
-	}
 
 	// -- annotation related
 
@@ -598,21 +561,6 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 		return false;
 	}
 
-	// evil mutator - adding state not stored in the java class
-	public void addAnnotation(AnnotationAJ annotation) {
-		bitflag |= DAMAGED;
-		int len = annotations.length;
-		AnnotationAJ[] ret = new AnnotationAJ[len + 1];
-		System.arraycopy(annotations, 0, ret, 0, len);
-		ret[len] = annotation;
-		annotations = ret;
-
-		len = annotationTypes.length;
-		ResolvedType[] ret2 = new ResolvedType[len + 1];
-		System.arraycopy(annotationTypes, 0, ret2, 0, len);
-		ret2[len] = getResolvedTypeX().getWorld().resolve(UnresolvedType.forName(annotation.getTypeName()));
-		annotationTypes = ret2;
-	}
 
 	public boolean isAnnotationWithRuntimeRetention() {
 		return (getRetentionPolicy() == null ? false : getRetentionPolicy().equals("RUNTIME"));
@@ -895,48 +843,6 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 			getSourceContext().tidy();
 	}
 
-	// --- methods for testing
-
-	// for testing - if we have this attribute, return it - will return null if
-	// it doesnt know anything
-	// public AjAttribute[] getAttributes(String name) {
-	// List results = new ArrayList();
-	// List l =
-	// BcelAttributes.readAjAttributes(javaClass.getClassName(),javaClass
-	// .getAttributes(),
-	// getResolvedTypeX().getSourceContext(),getResolvedTypeX().getWorld(),
-	// AjAttribute.WeaverVersionInfo.UNKNOWN);
-	// for (Iterator iter = l.iterator(); iter.hasNext();) {
-	// AjAttribute element = (AjAttribute) iter.next();
-	// if (element.getNameString().equals(name)) results.add(element);
-	// }
-	// if (results.size()>0) {
-	// return (AjAttribute[])results.toArray(new AjAttribute[]{});
-	// }
-	// return null;
-	// }
-	//	
-	// // for testing - use with the method above - this returns *all* including
-	// those that are not Aj attributes
-	// public String[] getAttributeNames() {
-	// Attribute[] as = javaClass.getAttributes();
-	// String[] strs = new String[as.length];
-	// for (int j = 0; j < as.length; j++) {
-	// strs[j] = as[j].getName();
-	// }
-	// return strs;
-	// }
-
-	// for testing
-	public void addPointcutDefinition(ResolvedPointcutDefinition d) {
-		bitflag |= DAMAGED;
-		int len = pointcuts.length;
-		ResolvedPointcutDefinition[] ret = new ResolvedPointcutDefinition[len + 1];
-		System.arraycopy(pointcuts, 0, ret, 0, len);
-		ret[len] = d;
-		pointcuts = ret;
-	}
-
 	public boolean hasBeenWoven() {
 		return hasBeenWoven;
 	}
@@ -441,7 +441,7 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 	 * The main part of implementing declare parents extends. Modify super ctor calls to target the new type.
 	 */
 	public boolean attemptToModifySuperCalls(BcelClassWeaver weaver, LazyClassGen newParentTarget, ResolvedType newParent) {
-		String currentParent = newParentTarget.getSuperClassname();
+		String currentParent = newParentTarget.getSuperClass().getName();// getName();
 		if (newParent.getGenericType() != null)
 			newParent = newParent.getGenericType(); // target new super calls at
 		// the generic type if its
@@ -692,7 +692,7 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 
 			gen.addMethodGen(mg1);
 
-			gen.addInterface(munger.getInterfaceType(), getSourceLocation());
+			gen.addInterface(munger.getInterfaceType().resolve(weaver.getWorld()), getSourceLocation());
 
 			return true;
 		} else {
@@ -1128,9 +1128,7 @@ public class BcelWeaver {
 			String className = classFile.getClassName();
 			ResolvedType theType = world.resolve(className);
 			if (theType != null) {
-				BcelObjectType classType = BcelWorld.getBcelObjectType(theType);
-				if (classType != null)
-					classType.ensureDelegateConsistent();
+				theType.ensureConsistent();
 			}
 		}
 
@@ -1672,7 +1670,8 @@ public class BcelWeaver {
 				// itself
 				// (like transform super calls) - that is done in
 				// BcelTypeMunger.mungeNewParent()
-				classType.addParent(newParent);
+				// classType.addParent(newParent);
+				onType.addParent(newParent);
 				ResolvedTypeMunger newParentMunger = new NewParentTypeMunger(newParent);
 				newParentMunger.setSourceLocation(p.getSourceLocation());
 				onType.addInterTypeMunger(new BcelTypeMunger(newParentMunger, xcutSet.findAspectDeclaringParents(p)));
@@ -613,7 +613,8 @@ public class BcelWorld extends World implements Repository {
 		if (!result.isExposedToWeaver())
 			return; // cant need resetting
 		ReferenceType rt = (ReferenceType) result;
-		rt.getDelegate().ensureDelegateConsistent();
+		rt.ensureConsistent();
+		// rt.getDelegate().ensureDelegateConsistent();
 		// If we want to rebuild it 'from scratch' then:
 		// ClassParser cp = new ClassParser(new
 		// ByteArrayInputStream(newbytes),new String(cs));
@@ -645,7 +646,8 @@ public class BcelWorld extends World implements Repository {
 				// itself
 				// (like transform super calls) - that is done in
 				// BcelTypeMunger.mungeNewParent()
-				classType.addParent(newParent);
+				// classType.addParent(newParent);
+				onType.addParent(newParent);
 				ResolvedTypeMunger newParentMunger = new NewParentTypeMunger(newParent);
 				newParentMunger.setSourceLocation(p.getSourceLocation());
 				onType.addInterTypeMunger(new BcelTypeMunger(newParentMunger, getCrosscuttingMembersSet()
@@ -105,6 +105,9 @@ public final class LazyClassGen {
 	private long calculatedSerialVersionUID;
 	private boolean hasClinit = false;
 
+	private ResolvedType[] extraSuperInterfaces = null;
+	private ResolvedType superclass = null;
+
 	// ---
 
 	static class InlinedSourceFileInfo {
@@ -504,25 +507,35 @@ public final class LazyClassGen {
 	}
 
 	/**
-	 * When working with 1.5 generics, a signature attribute is attached to the type which indicates how it was declared. This
-	 * routine ensures the signature attribute for what we are about to write out is correct. Basically its responsibilities are: 1.
-	 * Checking whether the attribute needs changing (i.e. did weaving change the type hierarchy) 2. If it did, removing the old
-	 * attribute 3. Check if we need an attribute at all, are we generic? are our supertypes parameterized/generic? 4. Build the new
-	 * attribute which includes all typevariable, supertype and superinterface information
+	 * When working with Java generics, a signature attribute is attached to the type which indicates how it was declared. This
+	 * routine ensures the signature attribute for the class we are about to write out is correct. Basically its responsibilities
+	 * are:
+	 * <ol>
+	 * <li>
+	 * Checking whether the attribute needs changing (ie. did weaving change the type hierarchy) - if it did, remove the old
+	 * attribute
+	 * <li>
+	 * Check if we need an attribute at all, are we generic? are our supertypes parameterized/generic?
+	 * <li>
+	 * Build the new attribute which includes all typevariable, supertype and superinterface information
+	 * </ol>
 	 */
 	private void fixupGenericSignatureAttribute() {
 
-		if (getWorld() != null && !getWorld().isInJava5Mode())
+		if (getWorld() != null && !getWorld().isInJava5Mode()) {
 			return;
+		}
 
 		// TODO asc generics Temporarily assume that types we generate dont need a signature attribute (closure/etc).. will need
 		// revisiting no doubt...
-		if (myType == null)
+		if (myType == null) {
 			return;
+		}
 
 		// 1. Has anything changed that would require us to modify this attribute?
-		if (!regenerateGenericSignatureAttribute)
+		if (!regenerateGenericSignatureAttribute) {
 			return;
+		}
 
 		// 2. Find the old attribute
 		Signature sigAttr = null;
@@ -544,9 +557,16 @@ public final class LazyClassGen {
 				if (typeX.isGenericType() || typeX.isParameterizedType())
 					needAttribute = true;
 			}
+			if (extraSuperInterfaces != null) {
+				for (int i = 0; i < extraSuperInterfaces.length; i++) {
+					ResolvedType interfaceType = extraSuperInterfaces[i];
+					if (interfaceType.isGenericType() || interfaceType.isParameterizedType())
+						needAttribute = true;
+				}
+			}
 
 			// check the supertype
-			ResolvedType superclassRTX = myType.getSuperclass();
+			ResolvedType superclassRTX = getSuperClass();
 			if (superclassRTX.isGenericType() || superclassRTX.isParameterizedType())
 				needAttribute = true;
 		}
@@ -564,15 +584,22 @@ public final class LazyClassGen {
 				signature.append(">");
 			}
 			// now the supertype
-			String supersig = myType.getSuperclass().getSignatureForAttribute();
+			String supersig = getSuperClass().getSignatureForAttribute();
 			signature.append(supersig);
 			ResolvedType[] interfaceRTXs = myType.getDeclaredInterfaces();
 			for (int i = 0; i < interfaceRTXs.length; i++) {
 				String s = interfaceRTXs[i].getSignatureForAttribute();
 				signature.append(s);
 			}
-			if (sigAttr != null)
+			if (extraSuperInterfaces != null) {
+				for (int i = 0; i < extraSuperInterfaces.length; i++) {
+					String s = extraSuperInterfaces[i].getSignatureForAttribute();
+					signature.append(s);
+				}
+			}
+			if (sigAttr != null) {
 				myGen.removeAttribute(sigAttr);
+			}
 			myGen.addAttribute(createSignatureAttribute(signature.toString()));
 		}
 	}
@@ -632,27 +659,41 @@ public final class LazyClassGen {
 		classGens.add(newClass);
 	}
 
-	public void addInterface(UnresolvedType typeX, ISourceLocation sourceLocation) {
+	public void addInterface(ResolvedType newInterface, ISourceLocation sourceLocation) {
 		regenerateGenericSignatureAttribute = true;
-		myGen.addInterface(typeX.getRawName());
-		if (!typeX.equals(UnresolvedType.SERIALIZABLE))
-			warnOnAddedInterface(typeX.getName(), sourceLocation);
+
+		if (extraSuperInterfaces == null) {
+			extraSuperInterfaces = new ResolvedType[1];
+			extraSuperInterfaces[0] = newInterface;
+		} else {
+			ResolvedType[] x = new ResolvedType[extraSuperInterfaces.length + 1];
+			System.arraycopy(extraSuperInterfaces, 0, x, 1, extraSuperInterfaces.length);
+			x[0] = newInterface;
+			extraSuperInterfaces = x;
+		}
+		myGen.addInterface(newInterface.getRawName());
+		if (!newInterface.equals(UnresolvedType.SERIALIZABLE))
+			warnOnAddedInterface(newInterface.getName(), sourceLocation);
 	}
 
-	public void setSuperClass(ResolvedType typeX) {
+	public void setSuperClass(ResolvedType newSuperclass) {
 		regenerateGenericSignatureAttribute = true;
-		myType.addParent(typeX); // used for the attribute
-		if (typeX.getGenericType() != null)
-			typeX = typeX.getGenericType();
-		myGen.setSuperclassName(typeX.getName()); // used in the real class data
+		superclass = newSuperclass;
+		// myType.addParent(typeX); // used for the attribute
+		if (newSuperclass.getGenericType() != null) {
+			newSuperclass = newSuperclass.getGenericType();
+		}
+		myGen.setSuperclassName(newSuperclass.getName()); // used in the real class data
 	}
 
-	public String getSuperClassname() {
-		return myGen.getSuperclassName();
-	}
+	// public String getSuperClassname() {
+	// return myGen.getSuperclassName();
+	// }
 
-	// FIXME asc not great that some of these ask the gen and some ask the type ! (see the related setters too)
 	public ResolvedType getSuperClass() {
+		if (superclass != null) {
+			return superclass;
+		}
 		return myType.getSuperclass();
 	}
 
@@ -665,7 +706,6 @@ public final class LazyClassGen {
 		List ret = new ArrayList();
 		ret.add(this);
 		ret.addAll(classGens);
-
 		return ret;
 	}
 
