@@ -555,7 +555,7 @@ public class AspectDeclaration extends TypeDeclaration {
 				BranchLabel instanceFound = new BranchLabel(codeStream);
 
 				ExceptionLabel anythingGoesWrong = new ExceptionLabel(codeStream, world
-						.makeTypeBinding(UnresolvedType.JAVA_LANG_EXCEPTION));
+						.makeTypeBinding(UnresolvedType.JL_EXCEPTION));
 				anythingGoesWrong.placeStart();
 				codeStream.aload_0();
 				codeStream.invokestatic(world.makeMethodBindingForCall(AjcMemberMaker.perTypeWithinGetInstance(typeX)));
@@ -650,7 +650,7 @@ public class AspectDeclaration extends TypeDeclaration {
 		final EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(this.scope);
 		generateMethod(classFile, hasAspectMethod, new BodyGenerator() {
 			public void generate(CodeStream codeStream) {
-				ExceptionLabel goneBang = new ExceptionLabel(codeStream, world.makeTypeBinding(UnresolvedType.JAVA_LANG_EXCEPTION));
+				ExceptionLabel goneBang = new ExceptionLabel(codeStream, world.makeTypeBinding(UnresolvedType.JL_EXCEPTION));
 				BranchLabel noInstanceExists = new BranchLabel(codeStream);
 				BranchLabel leave = new BranchLabel(codeStream);
 				goneBang.placeStart();
@@ -713,7 +713,7 @@ public class AspectDeclaration extends TypeDeclaration {
 				new BodyGenerator() {
 					public void generate(CodeStream codeStream) {
 						ExceptionLabel exc = new ExceptionLabel(codeStream, world
-								.makeTypeBinding(UnresolvedType.JAVA_LANG_EXCEPTION));
+								.makeTypeBinding(UnresolvedType.JL_EXCEPTION));
 						exc.placeStart();
 						codeStream.aload_0();
 						codeStream.getfield(world.makeFieldBinding(AjcMemberMaker.perTypeWithinWithinTypeField(typeX, typeX)));
@@ -727,7 +727,7 @@ public class AspectDeclaration extends TypeDeclaration {
 		final EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(this.scope);
 		generateMethod(classFile, AjcMemberMaker.perTypeWithinGetInstance(world.fromBinding(binding)), new BodyGenerator() {
 			public void generate(CodeStream codeStream) {
-				ExceptionLabel exc = new ExceptionLabel(codeStream, world.makeTypeBinding(UnresolvedType.JAVA_LANG_EXCEPTION));
+				ExceptionLabel exc = new ExceptionLabel(codeStream, world.makeTypeBinding(UnresolvedType.JL_EXCEPTION));
 				exc.placeStart();
 				codeStream.aload_0();
 				codeStream.ldc(NameMangler.perTypeWithinLocalAspectOf(typeX));
@@ -736,7 +736,7 @@ public class AspectDeclaration extends TypeDeclaration {
 						world.makeTypeBinding(UnresolvedType.forSignature("Ljava/lang/reflect/Method;")), // return type
 						new TypeBinding[] { world.makeTypeBinding(UnresolvedType.forSignature("Ljava/lang/String;")),
 								world.makeTypeBinding(UnresolvedType.forSignature("[Ljava/lang/Class;")) },
-						new ReferenceBinding[0], (ReferenceBinding) world.makeTypeBinding(UnresolvedType.JAVA_LANG_CLASS)));
+						new ReferenceBinding[0], (ReferenceBinding) world.makeTypeBinding(UnresolvedType.JL_CLASS)));
 				codeStream.astore_1();
 				codeStream.aload_1();
 				codeStream.aconst_null();
@@ -92,8 +92,8 @@ public class AnnotationAccessVar extends BcelVar {
 
 		InstructionList il = new InstructionList();
 
-		Type jlClass = BcelWorld.makeBcelType(UnresolvedType.JAVA_LANG_CLASS);
-		Type jlString = BcelWorld.makeBcelType(UnresolvedType.JAVA_LANG_STRING);
+		Type jlClass = BcelWorld.makeBcelType(UnresolvedType.JL_CLASS);
+		Type jlString = BcelWorld.makeBcelType(UnresolvedType.JL_STRING);
 		Type jlClassArray = BcelWorld.makeBcelType(UnresolvedType.JAVA_LANG_CLASS_ARRAY);
 		Type jlaAnnotation = BcelWorld.makeBcelType(UnresolvedType.JAVA_LANG_ANNOTATION);
 
@@ -155,15 +155,15 @@ public final class BcelRenderer implements ITestVisitor, IExprVisitor {
 		// Load up the var again
 		il.append(((BcelVar) hasAnnotation.getVar()).createLoad(fact));
 
-		Member getClass = MemberImpl.method(UnresolvedType.OBJECT, 0, UnresolvedType.JAVA_LANG_CLASS, "getClass",
+		Member getClass = MemberImpl.method(UnresolvedType.OBJECT, 0, UnresolvedType.JL_CLASS, "getClass",
 				UnresolvedType.NONE);
 		il.append(Utility.createInvoke(fact, world, getClass));
 		// aload annotationClass
 		il.append(fact.createConstant(new ObjectType(hasAnnotation.getAnnotationType().getName())));
 		// int annClassIndex = fact.getConstantPool().addClass(hasAnnotation.getAnnotationType().getSignature());
 		// il.append(new LDC_W(annClassIndex));
-		Member isAnnotationPresent = MemberImpl.method(UnresolvedType.JAVA_LANG_CLASS, 0, ResolvedType.BOOLEAN,
-				"isAnnotationPresent", new UnresolvedType[] { UnresolvedType.JAVA_LANG_CLASS });
+		Member isAnnotationPresent = MemberImpl.method(UnresolvedType.JL_CLASS, 0, ResolvedType.BOOLEAN,
+				"isAnnotationPresent", new UnresolvedType[] { UnresolvedType.JL_CLASS });
 		il.append(Utility.createInvoke(fact, world, isAnnotationPresent));
 		il.append(createJumpBasedOnBooleanOnStack());
 		instructions.insert(il);
@@ -45,6 +45,7 @@ import org.aspectj.weaver.AnnotationOnTypeMunger;
 import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.ConcreteTypeMunger;
 import org.aspectj.weaver.Member;
+import org.aspectj.weaver.MemberUtils;
 import org.aspectj.weaver.MethodDelegateTypeMunger;
 import org.aspectj.weaver.NameMangler;
 import org.aspectj.weaver.NewConstructorTypeMunger;
@@ -151,28 +152,23 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 				// if doing parents munging at compile time only...
 				NewParentTypeMunger parentTM = (NewParentTypeMunger) munger;
 				if (parentTM.isMixin()) {
-					weaver.getWorld()
-							.getMessageHandler()
-							.handleMessage(
-									WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_MIXIN, new String[] {
-											parentTM.getNewParent().getName(), fName, weaver.getLazyClassGen().getType().getName(),
-											tName }, weaver.getLazyClassGen().getClassName(), getAspectType().getName()));
+					weaver.getWorld().getMessageHandler().handleMessage(
+							WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_MIXIN,
+									new String[] { parentTM.getNewParent().getName(), fName,
+											weaver.getLazyClassGen().getType().getName(), tName }, weaver.getLazyClassGen()
+											.getClassName(), getAspectType().getName()));
 				} else {
 					if (parentTM.getNewParent().isInterface()) {
-						weaver.getWorld()
-								.getMessageHandler()
-								.handleMessage(
-										WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSIMPLEMENTS,
-												new String[] { weaver.getLazyClassGen().getType().getName(), tName,
-														parentTM.getNewParent().getName(), fName }, weaver.getLazyClassGen()
-														.getClassName(), getAspectType().getName()));
+						weaver.getWorld().getMessageHandler().handleMessage(
+								WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSIMPLEMENTS,
+										new String[] { weaver.getLazyClassGen().getType().getName(), tName,
+												parentTM.getNewParent().getName(), fName },
+										weaver.getLazyClassGen().getClassName(), getAspectType().getName()));
 					} else {
-						weaver.getWorld()
-								.getMessageHandler()
-								.handleMessage(
-										WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSEXTENDS,
-												new String[] { weaver.getLazyClassGen().getType().getName(), tName,
-														parentTM.getNewParent().getName(), fName }));
+						weaver.getWorld().getMessageHandler().handleMessage(
+								WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSEXTENDS, new String[] {
+										weaver.getLazyClassGen().getType().getName(), tName, parentTM.getNewParent().getName(),
+										fName }));
 						// TAG: WeavingMessage DECLARE PARENTS: EXTENDS
 						// reportDeclareParentsMessage(WeaveMessage.
 						// WEAVEMESSAGE_DECLAREPARENTSEXTENDS,sourceType,parent);
@@ -190,12 +186,10 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 					kindString = "member class";
 					fromString = fName;
 				}
-				weaver.getWorld()
-						.getMessageHandler()
-						.handleMessage(
-								WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_ITD, new String[] {
-										weaver.getLazyClassGen().getType().getName(), tName, kindString, getAspectType().getName(),
-										fromString }, weaver.getLazyClassGen().getClassName(), getAspectType().getName()));
+				weaver.getWorld().getMessageHandler().handleMessage(
+						WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_ITD, new String[] {
+								weaver.getLazyClassGen().getType().getName(), tName, kindString, getAspectType().getName(),
+								fromString }, weaver.getLazyClassGen().getClassName(), getAspectType().getName()));
 			}
 		}
 
@@ -222,45 +216,50 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 	 * For a long time, AspectJ did not allow binary weaving of declare parents. This restriction is now lifted but could do with
 	 * more testing!
 	 */
-	private boolean mungeNewParent(BcelClassWeaver weaver, NewParentTypeMunger munger) {
+	private boolean mungeNewParent(BcelClassWeaver weaver, NewParentTypeMunger typeTransformer) {
 		LazyClassGen newParentTarget = weaver.getLazyClassGen();
-		ResolvedType newParent = munger.getNewParent();
+		ResolvedType newParent = typeTransformer.getNewParent();
 
-		boolean cont = true; // Set to false when we error, so we don't actually
-		// *do* the munge
-		cont = enforceDecpRule1_abstractMethodsImplemented(weaver, munger.getSourceLocation(), newParentTarget, newParent);
-		cont = enforceDecpRule2_cantExtendFinalClass(weaver, munger.getSourceLocation(), newParentTarget, newParent) && cont;
+		boolean performChange = true;
+		performChange = enforceDecpRule1_abstractMethodsImplemented(weaver, typeTransformer.getSourceLocation(), newParentTarget,
+				newParent);
+		performChange = enforceDecpRule2_cantExtendFinalClass(weaver, typeTransformer.getSourceLocation(), newParentTarget,
+				newParent)
+				&& performChange;
 
 		List<ResolvedMember> methods = newParent.getMethodsWithoutIterator(false, true, false);
-		for (Iterator<ResolvedMember> iter = methods.iterator(); iter.hasNext();) {
-			ResolvedMember superMethod = iter.next();
-			if (!superMethod.getName().equals("<init>")) {
-				LazyMethodGen subMethod = findMatchingMethod(newParentTarget, superMethod);
+		for (ResolvedMember method : methods) {
+			if (!method.getName().equals("<init>")) {
+				LazyMethodGen subMethod = findMatchingMethod(newParentTarget, method);
 				// FIXME asc is this safe for all bridge methods?
 				if (subMethod != null && !subMethod.isBridgeMethod()) {
-					if (!(subMethod.isSynthetic() && superMethod.isSynthetic())) {
-						if (!(subMethod.isStatic() && subMethod.getName().startsWith("access$"))) { // ignore generated
-							// accessors
-							cont = enforceDecpRule3_visibilityChanges(weaver, newParent, superMethod, subMethod) && cont;
-							cont = enforceDecpRule4_compatibleReturnTypes(weaver, superMethod, subMethod) && cont;
-							cont = enforceDecpRule5_cantChangeFromStaticToNonstatic(weaver, munger.getSourceLocation(),
-									superMethod, subMethod) && cont;
+					if (!(subMethod.isSynthetic() && method.isSynthetic())) {
+						if (!(subMethod.isStatic() && subMethod.getName().startsWith("access$"))) {
+							// ignore generated accessors
+							performChange = enforceDecpRule3_visibilityChanges(weaver, newParent, method, subMethod)
+									&& performChange;
+							performChange = enforceDecpRule4_compatibleReturnTypes(weaver, method, subMethod) && performChange;
+							performChange = enforceDecpRule5_cantChangeFromStaticToNonstatic(weaver, typeTransformer
+									.getSourceLocation(), method, subMethod)
+									&& performChange;
 						}
 					}
 				}
 			}
 		}
-		if (!cont) {
-			return false; // A rule was violated and an error message already
-			// reported
+		if (!performChange) {
+			// A rule was violated and an error message already reported
+			return false;
 		}
 
-		if (newParent.isClass()) { // Changing the supertype
+		if (newParent.isClass()) {
+			// Changing the supertype
 			if (!attemptToModifySuperCalls(weaver, newParentTarget, newParent)) {
 				return false;
 			}
 			newParentTarget.setSuperClass(newParent);
-		} else { // Adding a new interface
+		} else {
+			// Add a new interface
 			newParentTarget.addInterface(newParent, getSourceLocation());
 		}
 		return true;
@@ -272,85 +271,74 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 	 */
 	private boolean enforceDecpRule1_abstractMethodsImplemented(BcelClassWeaver weaver, ISourceLocation mungerLoc,
 			LazyClassGen newParentTarget, ResolvedType newParent) {
+		// Ignore abstract classes or interfaces
+		if (newParentTarget.isAbstract() || newParentTarget.isInterface()) {
+			return true;
+		}
 		boolean ruleCheckingSucceeded = true;
-		if (!(newParentTarget.isAbstract() || newParentTarget.isInterface())) { // Ignore
-			// abstract
-			// classes
-			// or
-			// interfaces
-			List<ResolvedMember> methods = newParent.getMethodsWithoutIterator(false, true, false);
-			for (Iterator<ResolvedMember> i = methods.iterator(); i.hasNext();) {
-				ResolvedMember o = i.next();
-				if (o.isAbstract() && !o.getName().startsWith("ajc$interField")) { // Ignore
-					// abstract
-					// methods
-					// of
-					// ajc$interField
-					// prefixed
-					// methods
-					ResolvedMember discoveredImpl = null;
-					List<ResolvedMember> newParentTargetMethods = newParentTarget.getType().getMethodsWithoutIterator(false, true,
-							false);
-					for (Iterator<ResolvedMember> ii = newParentTargetMethods.iterator(); ii.hasNext() && discoveredImpl == null;) {
-						ResolvedMember gen2 = ii.next();
-						if (gen2.getName().equals(o.getName()) && !gen2.isAbstract()) {
-							String oSig = o.getParameterSignature();
-							// could be a match
-							if (gen2.getParameterSignature().equals(oSig)) {
-								discoveredImpl = gen2;
-							} else {
-								// Does the erasure match? In which case a bridge method will be created later to
-								// satisfy the abstract method
-								if (gen2.hasBackingGenericMember()
-										&& gen2.getBackingGenericMember().getParameterSignature().equals(oSig)) {
-									discoveredImpl = gen2;
+		List<ResolvedMember> newParentMethods = newParent.getMethodsWithoutIterator(false, true, false);
+		for (ResolvedMember newParentMethod : newParentMethods) {
+			String newParentMethodName = newParentMethod.getName();
+			// Ignore abstract  ajc$interField prefixed methods
+			if (newParentMethod.isAbstract() && !newParentMethodName.startsWith("ajc$interField")) {
+				ResolvedMember discoveredImpl = null;
+				List<ResolvedMember> targetMethods = newParentTarget.getType().getMethodsWithoutIterator(false, true, false);
+				for (ResolvedMember targetMethod : targetMethods) {
+					if (!targetMethod.isAbstract() && targetMethod.getName().equals(newParentMethodName)) {
+						String newParentMethodSig = newParentMethod.getParameterSignature(); // ([TT;)
+						String targetMethodSignature = targetMethod.getParameterSignature(); // ([Ljava/lang/Object;)
+						// could be a match
+						if (targetMethodSignature.equals(newParentMethodSig)) {
+							discoveredImpl = targetMethod;
+						} else {
+							// Does the erasure match? In which case a bridge method will be created later to
+							// satisfy the abstract method
+							if (targetMethod.hasBackingGenericMember()
+									&& targetMethod.getBackingGenericMember().getParameterSignature().equals(newParentMethodSig)) {
+								discoveredImpl = targetMethod;
+							} else if (newParentMethod.hasBackingGenericMember()) {
+								if (newParentMethod.getBackingGenericMember().getParameterSignature().equals(targetMethodSignature)) {
+									discoveredImpl = targetMethod;
 								}
 							}
 						}
+						if (discoveredImpl != null) {
+							break;
+						}
 					}
-					if (discoveredImpl == null) {
-						// didnt find a valid implementation, lets check the
-						// ITDs on this type to see if they satisfy it
-						boolean satisfiedByITD = false;
-						for (Iterator<ConcreteTypeMunger> ii = newParentTarget.getType().getInterTypeMungersIncludingSupers()
-								.iterator(); ii.hasNext();) {
-							ConcreteTypeMunger m = ii.next();
-							if (m.getMunger() != null && m.getMunger().getKind() == ResolvedTypeMunger.Method) {
-								ResolvedMember sig = m.getSignature();
-								if (!Modifier.isAbstract(sig.getModifiers())) {
-
-									// If the ITD shares a type variable with
-									// some target type, we need to tailor it
-									// for that
-									// type
-									if (m.isTargetTypeParameterized()) {
-										ResolvedType genericOnType = getWorld().resolve(sig.getDeclaringType()).getGenericType();
-										m = m.parameterizedFor(newParent.discoverActualOccurrenceOfTypeInHierarchy(genericOnType));
-										sig = m.getSignature(); // possible sig
-										// change when
-										// type
-										// parameters
-										// filled in
-									}
-									if (ResolvedType.matches(
-											AjcMemberMaker.interMethod(sig, m.getAspectType(),
-													sig.getDeclaringType().resolve(weaver.getWorld()).isInterface()), o)) {
-										satisfiedByITD = true;
-									}
+				}
+				if (discoveredImpl == null) {
+					// didnt find a valid implementation, lets check the
+					// ITDs on this type to see if they satisfy it
+					boolean satisfiedByITD = false;
+					for (ConcreteTypeMunger m : newParentTarget.getType().getInterTypeMungersIncludingSupers()) {
+						if (m.getMunger() != null && m.getMunger().getKind() == ResolvedTypeMunger.Method) {
+							ResolvedMember sig = m.getSignature();
+							if (!Modifier.isAbstract(sig.getModifiers())) {
+								// If the ITD shares a type variable with some target type, we need to tailor it
+								// for that type
+								if (m.isTargetTypeParameterized()) {
+									ResolvedType genericOnType = getWorld().resolve(sig.getDeclaringType()).getGenericType();
+									m = m.parameterizedFor(newParent.discoverActualOccurrenceOfTypeInHierarchy(genericOnType));
+									// possible sig change when type parameters filled in
+									sig = m.getSignature();
+								}
+								if (ResolvedType.matches(AjcMemberMaker.interMethod(sig, m.getAspectType(), sig.getDeclaringType()
+										.resolve(weaver.getWorld()).isInterface()), newParentMethod)) {
+									satisfiedByITD = true;
 								}
-							} else if (m.getMunger() != null && m.getMunger().getKind() == ResolvedTypeMunger.MethodDelegate2) {
-								satisfiedByITD = true;// AV - that should be
-								// enough, no need to
-								// check more
 							}
+						} else if (m.getMunger() != null && m.getMunger().getKind() == ResolvedTypeMunger.MethodDelegate2) {
+							// AV - that should be enough, no need to check more
+							satisfiedByITD = true;
 						}
-						if (!satisfiedByITD) {
-							error(weaver, "The type " + newParentTarget.getName()
-									+ " must implement the inherited abstract method " + o.getDeclaringType() + "." + o.getName()
-									+ o.getParameterSignature(), newParentTarget.getType().getSourceLocation(),
-									new ISourceLocation[] { o.getSourceLocation(), mungerLoc });
-							ruleCheckingSucceeded = false;
-						}
+					}
+					if (!satisfiedByITD) {
+						error(weaver, "The type " + newParentTarget.getName() + " must implement the inherited abstract method "
+								+ newParentMethod.getDeclaringType() + "." + newParentMethodName
+								+ newParentMethod.getParameterSignature(), newParentTarget.getType().getSourceLocation(),
+								new ISourceLocation[] { newParentMethod.getSourceLocation(), mungerLoc });
+						ruleCheckingSucceeded = false;
 					}
 				}
 			}
@@ -361,11 +349,11 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 	/**
 	 * Rule 2. Can't extend final types
 	 */
-	private boolean enforceDecpRule2_cantExtendFinalClass(BcelClassWeaver weaver, ISourceLocation mungerLoc,
-			LazyClassGen newParentTarget, ResolvedType newParent) {
+	private boolean enforceDecpRule2_cantExtendFinalClass(BcelClassWeaver weaver, ISourceLocation transformerLoc,
+			LazyClassGen targetType, ResolvedType newParent) {
 		if (newParent.isFinal()) {
-			error(weaver, "Cannot make type " + newParentTarget.getName() + " extend final class " + newParent.getName(),
-					newParentTarget.getType().getSourceLocation(), new ISourceLocation[] { mungerLoc });
+			error(weaver, "Cannot make type " + targetType.getName() + " extend final class " + newParent.getName(), targetType
+					.getType().getSourceLocation(), new ISourceLocation[] { transformerLoc });
 			return false;
 		}
 		return true;
@@ -379,29 +367,23 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 		boolean cont = true;
 		if (Modifier.isPublic(superMethod.getModifiers())) {
 			if (subMethod.isProtected() || subMethod.isDefault() || subMethod.isPrivate()) {
-				weaver.getWorld()
-						.getMessageHandler()
-						.handleMessage(
-								MessageUtil.error("Cannot reduce the visibility of the inherited method '" + superMethod
-										+ "' from " + newParent.getName(), superMethod.getSourceLocation()));
+				weaver.getWorld().getMessageHandler().handleMessage(
+						MessageUtil.error("Cannot reduce the visibility of the inherited method '" + superMethod + "' from "
+								+ newParent.getName(), superMethod.getSourceLocation()));
 				cont = false;
 			}
 		} else if (Modifier.isProtected(superMethod.getModifiers())) {
 			if (subMethod.isDefault() || subMethod.isPrivate()) {
-				weaver.getWorld()
-						.getMessageHandler()
-						.handleMessage(
-								MessageUtil.error("Cannot reduce the visibility of the inherited method '" + superMethod
-										+ "' from " + newParent.getName(), superMethod.getSourceLocation()));
+				weaver.getWorld().getMessageHandler().handleMessage(
+						MessageUtil.error("Cannot reduce the visibility of the inherited method '" + superMethod + "' from "
+								+ newParent.getName(), superMethod.getSourceLocation()));
 				cont = false;
 			}
 		} else if (superMethod.isDefault()) {
 			if (subMethod.isPrivate()) {
-				weaver.getWorld()
-						.getMessageHandler()
-						.handleMessage(
-								MessageUtil.error("Cannot reduce the visibility of the inherited method '" + superMethod
-										+ "' from " + newParent.getName(), superMethod.getSourceLocation()));
+				weaver.getWorld().getMessageHandler().handleMessage(
+						MessageUtil.error("Cannot reduce the visibility of the inherited method '" + superMethod + "' from "
+								+ newParent.getName(), superMethod.getSourceLocation()));
 				cont = false;
 			}
 		}
@@ -423,12 +405,9 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 			ResolvedType subType = weaver.getWorld().resolve(subMethod.getReturnType());
 			ResolvedType superType = weaver.getWorld().resolve(superMethod.getReturnType());
 			if (!superType.isAssignableFrom(subType)) {
-				weaver.getWorld()
-						.getMessageHandler()
-						.handleMessage(
-								MessageUtil.error("The return type is incompatible with " + superMethod.getDeclaringType() + "."
-										+ superMethod.getName() + superMethod.getParameterSignature(),
-										subMethod.getSourceLocation()));
+				weaver.getWorld().getMessageHandler().handleMessage(
+						MessageUtil.error("The return type is incompatible with " + superMethod.getDeclaringType() + "."
+								+ superMethod.getName() + superMethod.getParameterSignature(), subMethod.getSourceLocation()));
 				// this just might be a better error message...
 				// "The return type '"+subReturnTypeSig+
 				// "' is incompatible with the overridden method "
@@ -450,13 +429,13 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 		boolean superMethodStatic = Modifier.isStatic(superMethod.getModifiers());
 		if (superMethodStatic && !subMethod.isStatic()) {
 			error(weaver, "This instance method " + subMethod.getName() + subMethod.getParameterSignature()
-					+ " cannot override the static method from " + superMethod.getDeclaringType().getName(),
-					subMethod.getSourceLocation(), new ISourceLocation[] { mungerLoc });
+					+ " cannot override the static method from " + superMethod.getDeclaringType().getName(), subMethod
+					.getSourceLocation(), new ISourceLocation[] { mungerLoc });
 			return false;
 		} else if (!superMethodStatic && subMethod.isStatic()) {
 			error(weaver, "The static method " + subMethod.getName() + subMethod.getParameterSignature()
-					+ " cannot hide the instance method from " + superMethod.getDeclaringType().getName(),
-					subMethod.getSourceLocation(), new ISourceLocation[] { mungerLoc });
+					+ " cannot hide the instance method from " + superMethod.getDeclaringType().getName(), subMethod
+					.getSourceLocation(), new ISourceLocation[] { mungerLoc });
 			return false;
 		}
 		return true;
@@ -471,10 +450,12 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 	 * Search the specified type for a particular method - do not use the return value in the comparison as it is not considered for
 	 * overriding.
 	 */
-	private LazyMethodGen findMatchingMethod(LazyClassGen newParentTarget, ResolvedMember m) {
-		for (LazyMethodGen gen : newParentTarget.getMethodGens()) {
-			if (gen.getName().equals(m.getName()) && gen.getParameterSignature().equals(m.getParameterSignature())) {
-				return gen;
+	private LazyMethodGen findMatchingMethod(LazyClassGen type, ResolvedMember searchMethod) {
+		String searchName = searchMethod.getName();
+		String searchSig = searchMethod.getParameterSignature();
+		for (LazyMethodGen method : type.getMethodGens()) {
+			if (method.getName().equals(searchName) && method.getParameterSignature().equals(searchSig)) {
+				return method;
 			}
 		}
 		return null;
@@ -497,7 +478,7 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 
 		// Look for ctors to modify
 		for (LazyMethodGen aMethod : mgs) {
-			if (aMethod.getName().equals("<init>")) {
+			if (LazyMethodGen.isConstructor(aMethod)) {
 				InstructionList insList = aMethod.getBody();
 				InstructionHandle handle = insList.getStart();
 				while (handle != null) {
@@ -528,19 +509,15 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 
 								if (!satisfiedByITDC) {
 									String csig = createReadableCtorSig(newParent, cpg, invokeSpecial);
-									weaver.getWorld()
-											.getMessageHandler()
-											.handleMessage(
-													MessageUtil.error(
-															"Unable to modify hierarchy for " + newParentTarget.getClassName()
-																	+ " - the constructor " + csig + " is missing",
-															this.getSourceLocation()));
+									weaver.getWorld().getMessageHandler().handleMessage(
+											MessageUtil.error("Unable to modify hierarchy for " + newParentTarget.getClassName()
+													+ " - the constructor " + csig + " is missing", this.getSourceLocation()));
 									return false;
 								}
 							}
 
-							int idx = cpg.addMethodref(newParent.getName(), invokeSpecial.getMethodName(cpg),
-									invokeSpecial.getSignature(cpg));
+							int idx = cpg.addMethodref(newParent.getName(), invokeSpecial.getMethodName(cpg), invokeSpecial
+									.getSignature(cpg));
 							invokeSpecial.setIndex(idx);
 						}
 					}
@@ -574,13 +551,11 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 		return sb.toString();
 	}
 
-	private ResolvedMember getConstructorWithSignature(ResolvedType tx, String signature) {
-		ResolvedMember[] mems = tx.getDeclaredJavaMethods();
-		for (int i = 0; i < mems.length; i++) {
-			ResolvedMember rm = mems[i];
-			if (rm.getName().equals("<init>")) {
-				if (rm.getSignature().equals(signature)) {
-					return rm;
+	private ResolvedMember getConstructorWithSignature(ResolvedType type, String searchSig) {
+		for (ResolvedMember method : type.getDeclaredJavaMethods()) {
+			if (MemberUtils.isConstructor(method)) {
+				if (method.getSignature().equals(searchSig)) {
+					return method;
 				}
 			}
 		}
@@ -600,10 +575,10 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 		if (onType.equals(gen.getType())) {
 			if (member.getKind() == Member.FIELD) {
 				// System.out.println("matched: " + gen);
-				addFieldGetter(gen, member,
-						AjcMemberMaker.privilegedAccessMethodForFieldGet(aspectType, member, munger.shortSyntax));
-				addFieldSetter(gen, member,
-						AjcMemberMaker.privilegedAccessMethodForFieldSet(aspectType, member, munger.shortSyntax));
+				addFieldGetter(gen, member, AjcMemberMaker
+						.privilegedAccessMethodForFieldGet(aspectType, member, munger.shortSyntax));
+				addFieldSetter(gen, member, AjcMemberMaker
+						.privilegedAccessMethodForFieldSet(aspectType, member, munger.shortSyntax));
 				return true;
 			} else if (member.getKind() == Member.METHOD) {
 				addMethodDispatch(gen, member, AjcMemberMaker.privilegedAccessMethodForMethod(aspectType, member));
@@ -695,9 +670,9 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 	}
 
 	protected LazyMethodGen makeMethodGen(LazyClassGen gen, ResolvedMember member) {
-		LazyMethodGen ret = new LazyMethodGen(member.getModifiers(), BcelWorld.makeBcelType(member.getReturnType()),
-				member.getName(), BcelWorld.makeBcelTypes(member.getParameterTypes()), UnresolvedType.getNames(member
-						.getExceptions()), gen);
+		LazyMethodGen ret = new LazyMethodGen(member.getModifiers(), BcelWorld.makeBcelType(member.getReturnType()), member
+				.getName(), BcelWorld.makeBcelTypes(member.getParameterTypes()), UnresolvedType.getNames(member.getExceptions()),
+				gen);
 
 		// 43972 : Static crosscutting makes interfaces unusable for javac
 		// ret.makeSynthetic();
@@ -705,8 +680,8 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 	}
 
 	protected FieldGen makeFieldGen(LazyClassGen gen, ResolvedMember member) {
-		return new FieldGen(member.getModifiers(), BcelWorld.makeBcelType(member.getReturnType()), member.getName(),
-				gen.getConstantPool());
+		return new FieldGen(member.getModifiers(), BcelWorld.makeBcelType(member.getReturnType()), member.getName(), gen
+				.getConstantPool());
 	}
 
 	private boolean mungePerObjectInterface(BcelClassWeaver weaver, PerObjectInterfaceTypeMunger munger) {
@@ -767,8 +742,8 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 		// e.g.
 		// "public com_blah_SecurityAspect ajc$com_blah_SecurityAspect$localAspectOf()"
 		Type fieldType = BcelWorld.makeBcelType(aspectType);
-		LazyMethodGen mg = new LazyMethodGen(Modifier.PUBLIC | Modifier.STATIC, fieldType,
-				NameMangler.perTypeWithinLocalAspectOf(aspectType), new Type[0], new String[0], gen);
+		LazyMethodGen mg = new LazyMethodGen(Modifier.PUBLIC | Modifier.STATIC, fieldType, NameMangler
+				.perTypeWithinLocalAspectOf(aspectType), new Type[0], new String[0], gen);
 		InstructionList il = new InstructionList();
 		// PTWIMPL ?? Should check if it is null and throw
 		// NoAspectBoundException
@@ -956,35 +931,22 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 					ResolvedType rt = classGen.getType();
 					if (rt.isInterface()) {
 						ISourceLocation sloc = munger.getSourceLocation();
-						classWeaver
-								.getWorld()
-								.getMessageHandler()
-								.handleMessage(
-										MessageUtil.error(
-												"ITD target "
-														+ rt.getName()
-														+ " is an interface but has been incorrectly determined to be the topmost implementor of "
-														+ onType.getName() + ". ITD is " + this.getSignature(), sloc));
+						classWeaver.getWorld().getMessageHandler().handleMessage(
+								MessageUtil.error("ITD target " + rt.getName()
+										+ " is an interface but has been incorrectly determined to be the topmost implementor of "
+										+ onType.getName() + ". ITD is " + this.getSignature(), sloc));
 					}
 					if (!onType.isAssignableFrom(rt)) {
 						ISourceLocation sloc = munger.getSourceLocation();
-						classWeaver
-								.getWorld()
-								.getMessageHandler()
-								.handleMessage(
-										MessageUtil.error(
-												"ITD target " + rt.getName() + " doesn't appear to implement " + onType.getName()
-														+ " why did we consider it the top most implementor? ITD is "
-														+ this.getSignature(), sloc));
+						classWeaver.getWorld().getMessageHandler().handleMessage(
+								MessageUtil.error("ITD target " + rt.getName() + " doesn't appear to implement " + onType.getName()
+										+ " why did we consider it the top most implementor? ITD is " + this.getSignature(), sloc));
 					}
 				} else if (!rtx.isExposedToWeaver()) {
 					ISourceLocation sLoc = munger.getSourceLocation();
-					classWeaver
-							.getWorld()
-							.getMessageHandler()
-							.handleMessage(
-									MessageUtil.error(WeaverMessages.format(WeaverMessages.ITD_NON_EXPOSED_IMPLEMENTOR, rtx,
-											getAspectType().getName()), (sLoc == null ? getAspectType().getSourceLocation() : sLoc)));
+					classWeaver.getWorld().getMessageHandler().handleMessage(
+							MessageUtil.error(WeaverMessages.format(WeaverMessages.ITD_NON_EXPOSED_IMPLEMENTOR, rtx,
+									getAspectType().getName()), (sLoc == null ? getAspectType().getSourceLocation() : sLoc)));
 				} else {
 					// XXX what does this state mean?
 					// We have incorrectly identified what is the top most
@@ -1360,9 +1322,9 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 				return true;
 			}
 
-			LazyMethodGen mg = new LazyMethodGen(introduced.getModifiers() - Modifier.ABSTRACT, bcelReturnType,
-					introduced.getName(), BcelWorld.makeBcelTypes(introduced.getParameterTypes()),
-					BcelWorld.makeBcelTypesAsClassNames(introduced.getExceptions()), gen);
+			LazyMethodGen mg = new LazyMethodGen(introduced.getModifiers() - Modifier.ABSTRACT, bcelReturnType, introduced
+					.getName(), BcelWorld.makeBcelTypes(introduced.getParameterTypes()), BcelWorld
+					.makeBcelTypesAsClassNames(introduced.getExceptions()), gen);
 
 			// annotation copy from annotation on ITD interface
 			if (weaver.getWorld().isInJava5Mode()) {
@@ -1438,7 +1400,8 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 			} else {
 				body.append(fact.createNew(munger.getImplClassName()));
 				body.append(InstructionConstants.DUP);
-				body.append(fact.createInvoke(munger.getImplClassName(), "<init>", Type.VOID, Type.NO_ARGS, Constants.INVOKESPECIAL));
+				body.append(fact
+						.createInvoke(munger.getImplClassName(), "<init>", Type.VOID, Type.NO_ARGS, Constants.INVOKESPECIAL));
 				body.append(Utility.createSet(fact, munger.getDelegate(weaver.getLazyClassGen().getType())));
 			}
 
@@ -1913,8 +1876,8 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 				ResolvedMember toBridgeTo = munger.getDeclaredSignature().parameterizedWith(null,
 						munger.getSignature().getDeclaringType().resolve(getWorld()), false, munger.getTypeVariableAliases());
 				boolean needsbridging = false;
-				if (!toBridgeTo.getReturnType().getErasureSignature()
-						.equals(munger.getSignature().getReturnType().getErasureSignature())) {
+				if (!toBridgeTo.getReturnType().getErasureSignature().equals(
+						munger.getSignature().getReturnType().getErasureSignature())) {
 					needsbridging = true;
 				}
 				if (needsbridging) {
@@ -1943,8 +1906,8 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 				ResolvedMember toBridgeTo = munger.getDeclaredSignature().parameterizedWith(null,
 						munger.getSignature().getDeclaringType().resolve(getWorld()), false, munger.getTypeVariableAliases());
 				boolean needsbridging = false;
-				if (!toBridgeTo.getReturnType().getErasureSignature()
-						.equals(munger.getSignature().getReturnType().getErasureSignature())) {
+				if (!toBridgeTo.getReturnType().getErasureSignature().equals(
+						munger.getSignature().getReturnType().getErasureSignature())) {
 					needsbridging = true;
 				}
 				if (needsbridging) {
@@ -1998,7 +1961,7 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 	}
 
 	@Override
-	public ConcreteTypeMunger parameterizeWith(Map m, World w) {
+	public ConcreteTypeMunger parameterizeWith(Map<String, UnresolvedType> m, World w) {
 		return new BcelTypeMunger(munger.parameterizeWith(m, w), aspectType);
 	}
 
@@ -51,7 +51,6 @@ import org.aspectj.apache.bcel.generic.Type;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.weaver.AjAttribute;
-import org.aspectj.weaver.AjAttribute.WeaverVersionInfo;
 import org.aspectj.weaver.AnnotationAJ;
 import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.ISourceContext;
@@ -62,6 +61,7 @@ import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.Shadow;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.WeaverMessages;
+import org.aspectj.weaver.AjAttribute.WeaverVersionInfo;
 import org.aspectj.weaver.tools.Traceable;
 
 /**
@@ -442,15 +442,10 @@ public final class LazyMethodGen implements Traceable {
 			savedMethod = gen.getMethod();
 			return savedMethod;
 		} catch (ClassGenException e) {
-			enclosingClass
-					.getBcelObjectType()
-					.getResolvedTypeX()
-					.getWorld()
-					.showMessage(
-							IMessage.ERROR,
-							WeaverMessages.format(WeaverMessages.PROBLEM_GENERATING_METHOD, this.getClassName(), this.getName(),
-									e.getMessage()),
-							this.getMemberView() == null ? null : this.getMemberView().getSourceLocation(), null);
+			enclosingClass.getBcelObjectType().getResolvedTypeX().getWorld().showMessage(
+					IMessage.ERROR,
+					WeaverMessages.format(WeaverMessages.PROBLEM_GENERATING_METHOD, this.getClassName(), this.getName(), e
+							.getMessage()), this.getMemberView() == null ? null : this.getMemberView().getSourceLocation(), null);
 			// throw e; PR 70201.... let the normal problem reporting
 			// infrastructure deal with this rather than crashing.
 			body = null;
@@ -911,8 +906,8 @@ public final class LazyMethodGen implements Traceable {
 			for (int i = 0; i < newParameterAnnotations.length; i++) {
 				AnnotationAJ[] annos = newParameterAnnotations[i];
 				for (int j = 0; j < annos.length; j++) {
-					gen.addParameterAnnotation(i,
-							new AnnotationGen(((BcelAnnotation) annos[j]).getBcelAnnotation(), gen.getConstantPool(), true));
+					gen.addParameterAnnotation(i, new AnnotationGen(((BcelAnnotation) annos[j]).getBcelAnnotation(), gen
+							.getConstantPool(), true));
 				}
 			}
 		}
@@ -1169,8 +1164,8 @@ public final class LazyMethodGen implements Traceable {
 				continue;
 			}
 			gen.addExceptionHandler(jumpForward(r.getRealStart(), forDeletion), jumpForward(r.getRealEnd(), forDeletion),
-					jumpForward(r.getHandler(), forDeletion),
-					(r.getCatchType() == null) ? null : (ObjectType) BcelWorld.makeBcelType(r.getCatchType()));
+					jumpForward(r.getHandler(), forDeletion), (r.getCatchType() == null) ? null : (ObjectType) BcelWorld
+							.makeBcelType(r.getCatchType()));
 		}
 
 		for (InstructionHandle handle : forDeletion) {
@@ -1741,4 +1736,8 @@ public final class LazyMethodGen implements Traceable {
 		return enclosingClass.getConstantPool();
 	}
 
+	public static boolean isConstructor(LazyMethodGen aMethod) {
+		return aMethod.getName().equals("<init>");
+	}
+
 }
@@ -56,7 +56,7 @@ public class TypeAnnotationAccessVar extends BcelVar {
 
 	public InstructionList createLoadInstructions(ResolvedType toType, InstructionFactory fact) {
 		InstructionList il = new InstructionList();
-		Type jlClass = BcelWorld.makeBcelType(UnresolvedType.JAVA_LANG_CLASS);
+		Type jlClass = BcelWorld.makeBcelType(UnresolvedType.JL_CLASS);
 		Type jlaAnnotation = BcelWorld.makeBcelType(UnresolvedType.ANNOTATION);
 		il.append(target.createLoad(fact));
 		il.append(fact.createInvoke("java/lang/Object", "getClass", jlClass, new Type[] {}, Constants.INVOKEVIRTUAL));
@@ -109,7 +109,7 @@ public class AjcMemberMaker {
 		if (!isSerializableAspect(aspectType)) {
 			modifiers |= Modifier.TRANSIENT;
 		}
-		return new ResolvedMemberImpl(Member.FIELD, declaringType, modifiers, UnresolvedType.JAVA_LANG_STRING,
+		return new ResolvedMemberImpl(Member.FIELD, declaringType, modifiers, UnresolvedType.JL_STRING,
 				NameMangler.PERTYPEWITHIN_WITHINTYPEFIELD, UnresolvedType.NONE);
 	}
 
@@ -126,7 +126,7 @@ public class AjcMemberMaker {
 	public static ResolvedMember perTypeWithinGetInstance(UnresolvedType declaringType) {
 		// private static a.X ajc$getInstance(java.lang.Class)
 		ResolvedMemberImpl rm = new ResolvedMemberImpl(Member.METHOD, declaringType, PRIVATE_STATIC, declaringType, // return value
-				NameMangler.PERTYPEWITHIN_GETINSTANCE_METHOD, new UnresolvedType[] { UnresolvedType.JAVA_LANG_CLASS });
+				NameMangler.PERTYPEWITHIN_GETINSTANCE_METHOD, new UnresolvedType[] { UnresolvedType.JL_CLASS });
 		return rm;
 	}
 
@@ -134,7 +134,7 @@ public class AjcMemberMaker {
 	public static ResolvedMember perTypeWithinGetWithinTypeNameMethod(UnresolvedType declaringType, boolean inJava5Mode) {
 		// public String getWithinTypeName()
 		ResolvedMemberImpl rm = new ResolvedMemberImpl(Member.METHOD, declaringType, Modifier.PUBLIC,
-				UnresolvedType.JAVA_LANG_STRING, // return value
+				UnresolvedType.JL_STRING, // return value
 				NameMangler.PERTYPEWITHIN_GETWITHINTYPENAME_METHOD, UnresolvedType.NONE);
 		return rm;
 	}
@@ -69,14 +69,16 @@ public abstract class ConcreteTypeMunger implements PartialOrder.PartialComparab
 	}
 
 	public ISourceLocation getSourceLocation() {
-		if (munger == null)
+		if (munger == null) {
 			return null;
+		}
 		return munger.getSourceLocation(); // XXX
 	}
 
 	public boolean matches(ResolvedType onType) {
-		if (munger == null)
+		if (munger == null) {
 			throw new RuntimeException("huh: " + this);
+		}
 		return munger.matches(onType, aspectType);
 	}
 
@@ -119,8 +121,9 @@ public abstract class ConcreteTypeMunger implements PartialOrder.PartialComparab
 	 * </code>
 	 */
 	public boolean isTargetTypeParameterized() {
-		if (munger == null)
+		if (munger == null) {
 			return false;
+		}
 		return munger.sharesTypeVariablesWithGenericType();
 	}
 
@@ -131,12 +134,13 @@ public abstract class ConcreteTypeMunger implements PartialOrder.PartialComparab
 	public abstract ConcreteTypeMunger parameterizedFor(ResolvedType targetType);
 
 	public boolean isLateMunger() {
-		if (munger == null)
+		if (munger == null) {
 			return false;
+		}
 		return munger.isLateMunger();
 	}
 
-	public abstract ConcreteTypeMunger parameterizeWith(Map parameterizationMap, World world);
+	public abstract ConcreteTypeMunger parameterizeWith(Map<String, UnresolvedType> parameterizationMap, World world);
 
 	/**
 	 * Some type mungers are created purely to help with the implementation of shadow mungers. For example to support the cflow()
@@ -381,17 +381,13 @@ public class MemberImpl implements Member {
 	}
 
 	public String getParameterSignature() {
-		if (paramSignature != null) {
-			return paramSignature;
-		}
-		StringBuffer sb = new StringBuffer();
-		sb.append("(");
-		for (int i = 0; i < parameterTypes.length; i++) {
-			UnresolvedType tx = parameterTypes[i];
-			sb.append(tx.getSignature());
+		if (paramSignature == null) {
+			StringBuilder sb = new StringBuilder("(");
+			for (UnresolvedType parameterType : parameterTypes) {
+				sb.append(parameterType.getSignature());
+			}
+			paramSignature = sb.append(")").toString();
 		}
-		sb.append(")");
-		paramSignature = sb.toString();
 		return paramSignature;
 	}
 
@@ -0,0 +1,25 @@
+/* *******************************************************************
+ * Copyright (c) 2010 Contributors
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ * Andy Clement, SpringSource
+ * ******************************************************************/
+package org.aspectj.weaver;
+
+/**
+ * Common utility methods for members.
+ * 
+ * @author Andy Clement
+ */
+public class MemberUtils {
+
+	public static boolean isConstructor(ResolvedMember member) {
+		return member.getName().equals("<init>");
+	}
+
+}
@@ -128,7 +128,7 @@ public class NewFieldTypeMunger extends ResolvedTypeMunger {
 		return nftm;
 	}
 
-	public ResolvedTypeMunger parameterizeWith(Map m, World w) {
+	public ResolvedTypeMunger parameterizeWith(Map<String, UnresolvedType> m, World w) {
 		ResolvedMember parameterizedSignature = getSignature().parameterizedWith(m, w);
 		NewFieldTypeMunger nftm = new NewFieldTypeMunger(parameterizedSignature, getSuperMethodsCalled(), typeVariableAliases);
 		nftm.setDeclaredSignature(getSignature());
@@ -69,9 +69,9 @@ public class NewMethodTypeMunger extends ResolvedTypeMunger {
 	public static ResolvedTypeMunger readMethod(VersionedDataInputStream s, ISourceContext context) throws IOException {
 		ISourceLocation sloc = null;
 		ResolvedMemberImpl rmImpl = ResolvedMemberImpl.readResolvedMember(s, context);
-		Set superMethodsCalled = readSuperMethodsCalled(s);
+		Set<ResolvedMember> superMethodsCalled = readSuperMethodsCalled(s);
 		sloc = readSourceLocation(s);
-		List typeVarAliases = readInTypeAliases(s);
+		List<String> typeVarAliases = readInTypeAliases(s);
 
 		ResolvedTypeMunger munger = new NewMethodTypeMunger(rmImpl, superMethodsCalled, typeVarAliases);
 		if (sloc != null) {
@@ -138,7 +138,7 @@ public class NewMethodTypeMunger extends ResolvedTypeMunger {
 		return result;
 	}
 
-	public ResolvedTypeMunger parameterizeWith(Map m, World w) {
+	public ResolvedTypeMunger parameterizeWith(Map<String, UnresolvedType> m, World w) {
 		ResolvedMember parameterizedSignature = getSignature().parameterizedWith(m, w);
 		NewMethodTypeMunger nmtm = new NewMethodTypeMunger(parameterizedSignature, getSuperMethodsCalled(), typeVariableAliases);
 		nmtm.setDeclaredSignature(getSignature());
@@ -1039,17 +1039,13 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 	 * getParam
 	 */
 	public String getParameterSignatureErased() {
-		if (myParameterSignatureErasure != null) {
-			return myParameterSignatureErasure;
-		}
-		StringBuffer sig = new StringBuffer();
-		UnresolvedType[] myParameterTypes = getParameterTypes();
-		for (int i = 0; i < myParameterTypes.length; i++) {
-			UnresolvedType thisParameter = myParameterTypes[i];
-			// type vars will be erased to first bound
-			sig.append(thisParameter.getErasureSignature());
+		if (myParameterSignatureErasure == null) {
+			StringBuilder sig = new StringBuilder();
+			for (UnresolvedType parameter : getParameterTypes()) {
+				sig.append(parameter.getErasureSignature());
+			}
+			myParameterSignatureErasure = sig.toString();
 		}
-		myParameterSignatureErasure = sig.toString();
 		return myParameterSignatureErasure;
 	}
 
@@ -2499,7 +2499,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 	 * @return true if assignable to java.lang.Exception
 	 */
 	public boolean isException() {
-		return (world.getCoreType(UnresolvedType.JAVA_LANG_EXCEPTION).isAssignableFrom(this));
+		return (world.getCoreType(UnresolvedType.JL_EXCEPTION).isAssignableFrom(this));
 	}
 
 	/**
@@ -488,7 +488,7 @@ public abstract class ResolvedTypeMunger {
 		return false;
 	}
 
-	public ResolvedTypeMunger parameterizeWith(Map m, World w) {
+	public ResolvedTypeMunger parameterizeWith(Map<String, UnresolvedType> m, World w) {
 		throw new BCException("Dont call parameterizeWith() on a type munger of this kind: " + this.getClass());
 	}
 
@@ -69,7 +69,7 @@ public class TypeFactory {
 	 * Creates a sensible unresolvedtype from some signature, for example: signature = LIGuard<TT;>; bound = toString=IGuard<T>
 	 * sig=PIGuard<TT;>; sigErasure=LIGuard; kind=parameterized
 	 */
-	private static UnresolvedType convertSigToType(String aSignature) {
+	static UnresolvedType convertSigToType(String aSignature) {
 		UnresolvedType bound = null;
 		int startOfParams = aSignature.indexOf('<');
 		if (startOfParams == -1) {
@@ -132,6 +132,15 @@ public class TypeFactory {
 					endOfParams = locateMatchingEndAngleBracket(lastType, startOfParams);
 					typeParams = createTypeParams(lastType.substring(startOfParams + 1, endOfParams));
 				}
+				StringBuilder s = new StringBuilder();
+				int firstAngleBracket = signature.indexOf('<');
+				s.append("P").append(signature.substring(1, firstAngleBracket));
+				s.append('<');
+				for (UnresolvedType typeParameter : typeParams) {
+					s.append(typeParameter.getSignature());
+				}
+				s.append(">;");
+				signature = s.toString();//'P' + signature.substring(1);
 				return new UnresolvedType(signature, signatureErasure, typeParams);
 			}
 			// can't replace above with convertSigToType - leads to stackoverflow
@@ -185,6 +194,54 @@ public class TypeFactory {
 		} else if (firstChar == '@') {
 			// missing type
 			return ResolvedType.MISSING;
+		} else if (firstChar == 'L') {
+			// only an issue if there is also an angle bracket
+			int leftAngleBracket = signature.indexOf('<');
+
+			if (leftAngleBracket == -1) {
+				return new UnresolvedType(signature);
+			} else {
+				int endOfParams = locateMatchingEndAngleBracket(signature, leftAngleBracket);
+				StringBuffer erasureSig = new StringBuffer(signature);
+				erasureSig.setCharAt(0, 'L');
+				while (leftAngleBracket != -1) {
+					erasureSig.delete(leftAngleBracket, endOfParams + 1);
+					leftAngleBracket = locateFirstBracket(erasureSig);
+					if (leftAngleBracket != -1) {
+						endOfParams = locateMatchingEndAngleBracket(erasureSig, leftAngleBracket);
+					}
+				}
+
+				String signatureErasure = erasureSig.toString();
+
+				// TODO should consider all the intermediate parameterizations as well!
+				// the type parameters of interest are only those that apply to the 'last type' in the signature
+				// if the signature is 'PMyInterface<String>$MyOtherType;' then there are none...
+				String lastType = null;
+				int nestedTypePosition = signature.indexOf("$", endOfParams); // don't look for $ INSIDE the parameters
+				if (nestedTypePosition != -1) {
+					lastType = signature.substring(nestedTypePosition + 1);
+				} else {
+					lastType = new String(signature);
+				}
+				leftAngleBracket = lastType.indexOf("<");
+				UnresolvedType[] typeParams = UnresolvedType.NONE;
+				if (leftAngleBracket != -1) {
+					endOfParams = locateMatchingEndAngleBracket(lastType, leftAngleBracket);
+					typeParams = createTypeParams(lastType.substring(leftAngleBracket + 1, endOfParams));
+				}
+				StringBuilder s = new StringBuilder();
+				int firstAngleBracket = signature.indexOf('<');
+				s.append("P").append(signature.substring(1, firstAngleBracket));
+				s.append('<');
+				for (UnresolvedType typeParameter : typeParams) {
+					s.append(typeParameter.getSignature());
+				}
+				s.append(">;");
+				signature = s.toString();//'P' + signature.substring(1);
+				return new UnresolvedType(signature, signatureErasure, typeParams);
+			}
+
 		}
 		return new UnresolvedType(signature);
 	}
@@ -224,16 +281,18 @@ public class TypeFactory {
 
 	private static UnresolvedType[] createTypeParams(String typeParameterSpecification) {
 		String remainingToProcess = typeParameterSpecification;
-		List types = new ArrayList();
+		List<UnresolvedType> types = new ArrayList<UnresolvedType>();
 		while (remainingToProcess.length() != 0) {
 			int endOfSig = 0;
 			int anglies = 0;
+			boolean hadAnglies = false;
 			boolean sigFound = false; // OPTIMIZE can this be done better?
 			for (endOfSig = 0; (endOfSig < remainingToProcess.length()) && !sigFound; endOfSig++) {
 				char thisChar = remainingToProcess.charAt(endOfSig);
 				switch (thisChar) {
 				case '<':
 					anglies++;
+					hadAnglies = true;
 					break;
 				case '>':
 					anglies--;
@@ -260,7 +319,11 @@ public class TypeFactory {
 					}
 				}
 			}
-			types.add(createTypeFromSignature(remainingToProcess.substring(0, endOfSig)));
+			String forProcessing = remainingToProcess.substring(0, endOfSig);
+			if (hadAnglies && forProcessing.charAt(0) == 'L') {
+				forProcessing = "P" + forProcessing.substring(1);
+			}
+			types.add(createTypeFromSignature(forProcessing));
 			remainingToProcess = remainingToProcess.substring(endOfSig);
 		}
 		UnresolvedType[] typeParams = new UnresolvedType[types.size()];
@@ -19,66 +19,22 @@ import java.io.IOException;
 import java.util.Map;
 
 import org.aspectj.util.GenericSignature;
-import org.aspectj.util.GenericSignature.ClassSignature;
 import org.aspectj.util.GenericSignatureParser;
+import org.aspectj.util.GenericSignature.ClassSignature;
 import org.aspectj.weaver.tools.Traceable;
 
 /**
- * A UnresolvedType represents a type to the weaver. It has a basic signature that knows nothing about type variables, type
- * parameters, etc.. UnresolvedTypes are resolved in some World (a repository of types). When a UnresolvedType is resolved it turns
- * into a ResolvedType which may be a primitive type, or a ReferenceType. ReferenceTypes may refer to simple, generic, parameterized
- * or type-variable based reference types. A ReferenceType is backed by a delegate that provides information about the type based on
- * some repository (currently either BCEL or an EclipseSourceType, but in the future we probably need to support java.lang.reflect
- * based delegates too).
- * 
+ * A UnresolvedType represents a type to the weaver. UnresolvedTypes are resolved in some World (a type repository). When a
+ * UnresolvedType is resolved it turns into a ResolvedType which may be a primitive type, or a ReferenceType. ReferenceTypes may
+ * refer to simple, generic, parameterized or type-variable based reference types. A ReferenceType is backed by a delegate that
+ * provides information about the type based on some repository (for example an Eclipse based delegate, a bytecode based delegate or
+ * a reflection based delegate).
+ * <p>
  * Every UnresolvedType has a signature, the unique key for the type in the world.
- * 
- * 
- * TypeXs are fully aware of their complete type information (there is no erasure in the UnresolvedType world). To achieve this, the
- * signature of TypeXs combines the basic Java signature and the generic signature information into one complete signature.
- * 
- * The format of a UnresolvedType signature is as follows:
- * 
- * a simple (non-generic, non-parameterized) type has the as its signature the Java signature. e.g. Ljava/lang/String;
- * 
- * a generic type has signature: TypeParamsOpt ClassSig SuperClassSig SuperIntfListOpt
- * 
- * following the Generic signature grammar in the JVM spec., but with the addition of the ClassSignature (which is not in the
- * generic signature). In addition type variable names are replaced by a simple number which represents their declaration order in
- * the type declaration.
- * 
- * e.g. public class Foo<T extends Number> would have signature: <1:Ljava/lang/Number>Lorg.xyz.Foo;Ljava/lang/Object;
- * 
- * A parameterized type is a distinct type in the world with its own signature following the grammar:
- * 
- * TypeParamsOpt ClassSig<ParamSigList>;
- * 
- * but with the L for the class sig replaced by "P". For example List<String> has signature
- * 
- * Pjava/util/List<Ljava/lang/String>;
- * 
- * and List<T> in the following class : class Foo<T> { List<T> lt; }
- * 
- * has signature: <1:>Pjava/util/List<T1;>;
- * 
- * A typex that represents a type variable has its own unique signature, following the grammar for a FormalTypeParameter in the JVM
- * spec.
- * 
- * A generic typex has its true signature and also an erasure signature. Both of these are keys pointing to the same UnresolvedType
- * in the world. For example List has signature:
- * 
- * <1:>Ljava/util/List;Ljava/lang/Object;
- * 
- * and the erasure signature
- * 
- * Ljava/util/List;
- * 
- * Generics wildcards introduce their own special signatures for type parameters. The wildcard ? has signature * The wildcard ?
- * extends Foo has signature +LFoo; The wildcard ? super Foo has signature -LFoo;
  */
 public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 
-	// common types referred to by the weaver
+	// common type structures
 	public static final UnresolvedType[] NONE = new UnresolvedType[0];
 	public static final UnresolvedType OBJECT = forSignature("Ljava/lang/Object;");
 	public static final UnresolvedType OBJECTARRAY = forSignature("[Ljava/lang/Object;");
@@ -91,10 +47,10 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 	public static final UnresolvedType AT_RETENTION = forSignature("Ljava/lang/annotation/Retention;");
 	public static final UnresolvedType ENUM = forSignature("Ljava/lang/Enum;");
 	public static final UnresolvedType ANNOTATION = forSignature("Ljava/lang/annotation/Annotation;");
-	public static final UnresolvedType JAVA_LANG_CLASS = forSignature("Ljava/lang/Class;");
+	public static final UnresolvedType JL_CLASS = forSignature("Ljava/lang/Class;");
 	public static final UnresolvedType JAVA_LANG_CLASS_ARRAY = forSignature("[Ljava/lang/Class;");
-	public static final UnresolvedType JAVA_LANG_STRING = forSignature("Ljava/lang/String;");
-	public static final UnresolvedType JAVA_LANG_EXCEPTION = forSignature("Ljava/lang/Exception;");
+	public static final UnresolvedType JL_STRING = forSignature("Ljava/lang/String;");
+	public static final UnresolvedType JL_EXCEPTION = forSignature("Ljava/lang/Exception;");
 	public static final UnresolvedType JAVA_LANG_REFLECT_METHOD = forSignature("Ljava/lang/reflect/Method;");
 	public static final UnresolvedType JAVA_LANG_REFLECT_FIELD = forSignature("Ljava/lang/reflect/Field;");
 	public static final UnresolvedType JAVA_LANG_REFLECT_CONSTRUCTOR = forSignature("Ljava/lang/reflect/Constructor;");
@@ -106,18 +62,20 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 	public static final UnresolvedType JOINPOINT_STATICPART = forSignature("Lorg/aspectj/lang/JoinPoint$StaticPart;");
 	public static final UnresolvedType JOINPOINT_ENCLOSINGSTATICPART = forSignature("Lorg/aspectj/lang/JoinPoint$EnclosingStaticPart;");
 
-	// this doesn't belong here and will get moved to ResolvedType later in the refactoring
+	// A type is considered missing if we have a signature for it but cannot find the delegate
 	public static final String MISSING_NAME = "@missing@";
 
 	// OPTIMIZE I dont think you can ask something unresolved what kind of type it is, how can it always know? Push down into
-	// resolvedtype
-	// that will force references to resolvedtypes to be correct rather than relying on unresolvedtypes to answer questions
+	// resolvedtype that will force references to resolvedtypes to be correct rather than relying on unresolvedtypes to answer questions
 	protected TypeKind typeKind = TypeKind.SIMPLE; // what kind of type am I?
 
+	protected String signature;
+
 	/**
-	 * THE SIGNATURE - see the comments above for how this is defined
+	 * The erasure of the signature. Contains only the Java signature of the type with all supertype, superinterface, type variable,
+	 * and parameter information removed.
 	 */
-	protected String signature;
+	protected String signatureErasure;
 
 	/**
 	 * Calculated on first request - the package name (java.lang for type java.lang.String)
@@ -130,12 +88,6 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 	private String className;
 
 	/**
-	 * The erasure of the signature. Contains only the Java signature of the type with all supertype, superinterface, type variable,
-	 * and parameter information removed.
-	 */
-	protected String signatureErasure;
-
-	/**
 	 * Iff isParameterized(), then these are the type parameters
 	 */
 	protected UnresolvedType[] typeParameters;
@@ -198,7 +150,7 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 	}
 
 	/**
-	 * Equality is checked based on the underlying signature. {@link ResolvedType} objects' equals is by reference.
+	 * Equality is checked based on the underlying signature.
 	 */
 	@Override
 	public boolean equals(Object other) {
@@ -237,7 +189,7 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 		}
 	}
 
-	// ---- Things we can do without a world
+	// The operations supported by an UnresolvedType are those that do not require a world
 
 	/**
 	 * This is the size of this type as used in JVM.
@@ -246,15 +198,6 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 		return 1;
 	}
 
-	public static UnresolvedType makeArray(UnresolvedType base, int dims) {
-		StringBuffer sig = new StringBuffer();
-		for (int i = 0; i < dims; i++) {
-			sig.append("[");
-		}
-		sig.append(base.getSignature());
-		return UnresolvedType.forSignature(sig.toString());
-	}
-
 	/**
 	 * NOTE: Use forSignature() if you can, it'll be cheaper ! Constructs a UnresolvedType for a java language type name. For
 	 * example:
@@ -398,7 +341,7 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 	 * 
 	 * </blockquote>
 	 * 
-	 * Types may equivalently be produced by this or by {@link #forName(String)}.
+	 * Types may equivalently be produced by this or by {@link #forName(String)}. This method should not be passed P signatures.
 	 * 
 	 * <blockquote>
 	 * 
@@ -413,6 +356,7 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 	 * @return a type object represnting that JVM bytecode signature.
 	 */
 	public static UnresolvedType forSignature(String signature) {
+		assert !(signature.startsWith("L") && signature.indexOf("<") != -1);
 		switch (signature.charAt(0)) {
 		case 'B':
 			return ResolvedType.BYTE;
@@ -740,51 +684,49 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 	}
 
 	private static String nameToSignature(String name) {
-		if (name.equals("byte")) {
-			return "B";
-		}
-		if (name.equals("char")) {
-			return "C";
-		}
-		if (name.equals("double")) {
-			return "D";
-		}
-		if (name.equals("float")) {
-			return "F";
-		}
-		if (name.equals("int")) {
-			return "I";
-		}
-		if (name.equals("long")) {
-			return "J";
-		}
-		if (name.equals("short")) {
-			return "S";
-		}
-		if (name.equals("boolean")) {
-			return "Z";
-		}
-		if (name.equals("void")) {
-			return "V";
-		}
-		if (name.equals("?")) {
-			return name;
+		int len = name.length();
+		if (len < 8) {
+			if (name.equals("byte")) {
+				return "B";
+			}
+			if (name.equals("char")) {
+				return "C";
+			}
+			if (name.equals("double")) {
+				return "D";
+			}
+			if (name.equals("float")) {
+				return "F";
+			}
+			if (name.equals("int")) {
+				return "I";
+			}
+			if (name.equals("long")) {
+				return "J";
+			}
+			if (name.equals("short")) {
+				return "S";
+			}
+			if (name.equals("boolean")) {
+				return "Z";
+			}
+			if (name.equals("void")) {
+				return "V";
+			}
+			if (name.equals("?")) {
+				return name;
+			}
 		}
 		if (name.endsWith("[]")) {
 			return "[" + nameToSignature(name.substring(0, name.length() - 2));
 		}
-		if (name.length() != 0) {
-			// lots more tests could be made here...
-
+		if (len != 0) {
 			// check if someone is calling us with something that is a signature already
-			if (name.charAt(0) == '[') {
-				throw new BCException("Do not call nameToSignature with something that looks like a signature (descriptor): '"
-						+ name + "'");
-			}
+			assert name.charAt(0) != '[';
 
 			if (name.indexOf("<") == -1) {
-				// not parameterised
-				return "L" + name.replace('.', '/') + ";";
+				// not parameterized
+				return new StringBuilder("L").append(name.replace('.', '/')).append(';').toString();
 			} else {
 				StringBuffer nameBuff = new StringBuffer();
 				int nestLevel = 0;
@@ -835,40 +777,27 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 		}
 	}
 
+	/**
+	 * Write out an UnresolvedType - the signature should be enough.
+	 */
 	public final void write(CompressingDataOutputStream s) throws IOException {
 		s.writeUTF(getSignature());
 	}
 
+	/**
+	 * Read in an UnresolvedType - just read the signature and rebuild the UnresolvedType.
+	 */
 	public static UnresolvedType read(DataInputStream s) throws IOException {
 		String sig = s.readUTF();
 		if (sig.equals(MISSING_NAME)) {
 			return ResolvedType.MISSING;
 		} else {
-			UnresolvedType ret = UnresolvedType.forSignature(sig);
-			return ret;
+			// TODO isn't it a shame to build these (this method is expensive) and then chuck them away on resolution?
+			// TODO review callers and see if they are immediately resolving it, maybe we can do something more optimal if they are
+			return UnresolvedType.forSignature(sig);
 		}
 	}
 
-	public static void writeArray(UnresolvedType[] types, CompressingDataOutputStream s) throws IOException {
-		int len = types.length;
-		s.writeShort(len);
-		for (int i = 0; i < len; i++) {
-			types[i].write(s);
-		}
-	}
-
-	public static UnresolvedType[] readArray(DataInputStream s) throws IOException {
-		int len = s.readShort();
-		if (len == 0) {
-			return UnresolvedType.NONE;
-		}
-		UnresolvedType[] types = new UnresolvedType[len];
-		for (int i = 0; i < len; i++) {
-			types[i] = UnresolvedType.read(s);
-		}
-		return types;
-	}
-
 	public String getNameAsIdentifier() {
 		return getName().replace('.', '_');
 	}
@@ -883,42 +812,10 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 		}
 	}
 
-	public String getPackageName() {
-		if (packageName == null) {
-			String name = getName();
-			if (name.indexOf("<") != -1) {
-				name = name.substring(0, name.indexOf("<"));
-			}
-			int index = name.lastIndexOf('.');
-			if (index == -1) {
-				packageName = "";
-			} else {
-				packageName = name.substring(0, index);
-			}
-		}
-		return packageName;
-	}
-
 	public UnresolvedType[] getTypeParameters() {
 		return typeParameters == null ? UnresolvedType.NONE : typeParameters;
 	}
 
-	/**
-	 * Doesn't include the package
-	 */
-	public String getClassName() {
-		if (className == null) {
-			String name = getName();
-			int index = name.lastIndexOf('.');
-			if (index == -1) {
-				className = name;
-			} else {
-				className = name.substring(index + 1);
-			}
-		}
-		return className;
-	}
-
 	public TypeVariable[] getTypeVariables() {
 		return typeVariables;
 	}
@@ -973,4 +870,70 @@ public class UnresolvedType implements Traceable, TypeVariableDeclaringElement {
 	public UnresolvedType parameterize(Map<String, UnresolvedType> typeBindings) {
 		throw new UnsupportedOperationException("unable to parameterize unresolved type: " + signature);
 	}
+
+	/**
+	 * @return the class name (does not include the package name)
+	 */
+	public String getClassName() {
+		if (className == null) {
+			String name = getName();
+			int index = name.lastIndexOf('.');
+			if (index == -1) {
+				className = name;
+			} else {
+				className = name.substring(index + 1);
+			}
+		}
+		return className;
+	}
+
+	/**
+	 * @return the package name (no class name included)
+	 */
+	public String getPackageName() {
+		if (packageName == null) {
+			String name = getName();
+			if (name.indexOf("<") != -1) {
+				name = name.substring(0, name.indexOf("<"));
+			}
+			int index = name.lastIndexOf('.');
+			if (index == -1) {
+				packageName = "";
+			} else {
+				packageName = name.substring(0, index);
+			}
+		}
+		return packageName;
+	}
+
+	// TODO these move to a TypeUtils class
+
+	public static void writeArray(UnresolvedType[] types, CompressingDataOutputStream stream) throws IOException {
+		int len = types.length;
+		stream.writeShort(len);
+		for (UnresolvedType type : types) {
+			type.write(stream);
+		}
+	}
+
+	public static UnresolvedType[] readArray(DataInputStream s) throws IOException {
+		int len = s.readShort();
+		if (len == 0) {
+			return UnresolvedType.NONE;
+		}
+		UnresolvedType[] types = new UnresolvedType[len];
+		for (int i = 0; i < len; i++) {
+			types[i] = UnresolvedType.read(s);
+		}
+		return types;
+	}
+
+	public static UnresolvedType makeArray(UnresolvedType base, int dims) {
+		StringBuffer sig = new StringBuffer();
+		for (int i = 0; i < dims; i++) {
+			sig.append("[");
+		}
+		sig.append(base.getSignature());
+		return UnresolvedType.forSignature(sig.toString());
+	}
 }
@@ -8,7 +8,6 @@
  * ******************************************************************/
 package org.aspectj.weaver;
 
-
 /**
  * @author Adrian Colyer
  * @author Andy Clement
@@ -23,13 +22,14 @@ public class UnresolvedTypeVariableReferenceType extends UnresolvedType implemen
 	}
 
 	public UnresolvedTypeVariableReferenceType(TypeVariable aTypeVariable) {
-		super(aTypeVariable.getFirstBound().getSignature());
+		super("T" + aTypeVariable.getName() + ";", aTypeVariable.getFirstBound().getErasureSignature());//aTypeVariable.getFirstBound().getSignature());
 		this.typeVariable = aTypeVariable;
 	}
 
 	// only used when resolving circular refs...
 	public void setTypeVariable(TypeVariable aTypeVariable) {
 		this.signature = "T" + aTypeVariable.getName() + ";"; // aTypeVariable.getUpperBound().getSignature();
+		this.signatureErasure = aTypeVariable.getFirstBound().getErasureSignature();
 		this.typeVariable = aTypeVariable;
 		this.typeKind = TypeKind.TYPE_VARIABLE;
 	}
@@ -181,7 +181,7 @@ public class WildAnnotationTypePattern extends AnnotationTypePattern {
 						} else {
 							throw new RuntimeException("Not implemented for " + t);
 						}
-					} else if (t.equals(ResolvedType.JAVA_LANG_STRING)) {
+					} else if (t.equals(ResolvedType.JL_STRING)) {
 						// nothing to do, it will be OK
 					} else {
 						throw new RuntimeException("Compiler limitation: annotation value support not implemented for type " + t);
@@ -33,6 +33,7 @@ public class MatcherModuleTests extends TestCase {
 		suite.addTestSuite(ReflectionWorldSpecificTest.class);
 		suite.addTestSuite(ReflectionWorldBasicTest.class);
 		suite.addTestSuite(ReflectionWorldPointcutExpressionTests.class);
+		suite.addTestSuite(TypeFactoryTests.class);
 		suite.addTest(PatternsTests.suite());
 		return suite;
 	}
@@ -0,0 +1,76 @@
+/* *******************************************************************
+ * Copyright (c) 2010 Contributors.
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ * ******************************************************************/
+package org.aspectj.weaver;
+
+import junit.framework.TestCase;
+
+/**
+ * Check signature to type mapping.
+ * 
+ * @author Andy Clement
+ */
+public class TypeFactoryTests extends TestCase {
+
+	public void testParameterizedSig() {
+		UnresolvedType t = null;
+		t = UnresolvedType.forSignature("Pjava/util/List<Ljava/lang/String;>;");
+		assertEquals("Ljava/util/List;", t.getErasureSignature());
+		assertEquals("Ljava/lang/String;", t.getTypeParameters()[0].signature);
+		assertEquals("Ljava/lang/String;", t.getTypeParameters()[0].signatureErasure);
+		assertEquals("Pjava/util/List<Ljava/lang/String;>;", t.getSignature());
+
+		t = TypeFactory.createTypeFromSignature("Ljava/util/List<Ljava/lang/String;>;");
+		assertEquals("Ljava/util/List;", t.getErasureSignature());
+		assertEquals("Ljava/lang/String;", t.getTypeParameters()[0].signature);
+		assertEquals("Ljava/lang/String;", t.getTypeParameters()[0].signatureErasure);
+		assertEquals("Pjava/util/List<Ljava/lang/String;>;", t.getSignature());
+
+		t = UnresolvedType.forName("java.util.List<java.lang.String>");
+		assertEquals("Ljava/util/List;", t.getErasureSignature());
+		assertEquals("Ljava/lang/String;", t.getTypeParameters()[0].signature);
+		assertEquals("Ljava/lang/String;", t.getTypeParameters()[0].signatureErasure);
+		assertEquals("Pjava/util/List<Ljava/lang/String;>;", t.getSignature());
+
+		t = UnresolvedType.forSignature("Pjava/util/Map<TS;Pjava/util/List<Ljava/lang/String;>;>;");
+		assertEquals("Ljava/util/Map;", t.getErasureSignature());
+		assertEquals("TS;", t.getTypeParameters()[0].signature);
+		assertEquals("Ljava/lang/Object;", t.getTypeParameters()[0].signatureErasure);
+		assertEquals("S", ((UnresolvedTypeVariableReferenceType) t.getTypeParameters()[0]).getTypeVariable().getName());
+		assertEquals("Pjava/util/Map<TS;Pjava/util/List<Ljava/lang/String;>;>;", t.getSignature());
+		assertEquals("Pjava/util/List<Ljava/lang/String;>;", t.getTypeParameters()[1].signature);
+		assertEquals("Ljava/util/List;", t.getTypeParameters()[1].signatureErasure);
+
+		t = UnresolvedType.forSignature("Pjava/util/List<+Pnl/ZoekFoo<TS;Pnl/ZoekCopy<TS;>;>;>;");
+		assertEquals("Ljava/util/List;", t.getErasureSignature());
+		WildcardedUnresolvedType wut = (WildcardedUnresolvedType) t.getTypeParameters()[0];
+		assertEquals("+Pnl/ZoekFoo<TS;Pnl/ZoekCopy<TS;>;>;", wut.signature);
+		assertEquals("Lnl/ZoekFoo;", wut.signatureErasure);
+		assertTrue(wut.isExtends());
+		assertEquals("Pnl/ZoekFoo<TS;Pnl/ZoekCopy<TS;>;>;", wut.getUpperBound().signature);
+		assertEquals("Lnl/ZoekFoo;", wut.getUpperBound().signatureErasure);
+		UnresolvedTypeVariableReferenceType tvar = (UnresolvedTypeVariableReferenceType) wut.getUpperBound().getTypeParameters()[0];
+		assertEquals("Pnl/ZoekFoo<TS;Pnl/ZoekCopy<TS;>;>;", wut.getUpperBound().signature);
+		assertEquals("Lnl/ZoekFoo;", wut.getUpperBound().signatureErasure);
+		assertEquals("S", tvar.getTypeVariable().getName());
+		UnresolvedType t2 = wut.getUpperBound().getTypeParameters()[1];
+		assertEquals("Pnl/ZoekCopy<TS;>;", t2.getSignature());
+		assertEquals("Lnl/ZoekCopy;", t2.getErasureSignature());
+
+		//		//		t = UnresolvedType.forSignature("Ljava/util/List<+Lnl/ZoekFoo<TS;Lnl/ZoekCopy<TS;>;>;>;");
+		//		t = TypeFactory.createTypeFromSignature("Ljava/util/List<+Lnl/ZoekFoo<TS;Lnl/ZoekCopy<TS;>;>;>;");
+		//		System.out.println(t.getSignature());
+		//
+		//		t = TypeFactory.createTypeFromSignature("Ljava/util/List<Lnl/ZoekFoo<Ljava/lang/String;>;>;");
+		//		System.out.println(t.getSignature()); // Pjava/util/List<Lnl/ZoekFoo<Ljava/lang/String;>;>;
+
+		// TODO should be able to cope with nested parameterizations
+		// Foo<String>.Bar<List<Map<String,Integer>>>
+		// both components Foo and Bar of that are parameterized
+	}
+}
@@ -4582,7 +4582,7 @@
 		<message kind="weave" text="Type 'ParentChildRelationship$ParentHasChildren' (GenericAspectY.aj) has intertyped method from 'ParentChildRelationship' (GenericAspectY.aj:'java.util.List&lt;C&gt; ParentChildRelationship$ParentHasChildren.getChildren()')"/>
 		<message kind="weave" text="Type 'ParentChildRelationship$ParentHasChildren' (GenericAspectY.aj) has intertyped method from 'ParentChildRelationship' (GenericAspectY.aj:'void ParentChildRelationship$ParentHasChildren.addChild(C)')"/>
 		<message kind="weave" text="Type 'ParentChildRelationship$ParentHasChildren' (GenericAspectY.aj) has intertyped method from 'ParentChildRelationship' (GenericAspectY.aj:'void ParentChildRelationship$ParentHasChildren.removeChild(C)')"/>
-		<message kind="weave" text="Type 'ParentChildRelationship$ChildHasParent' (GenericAspectY.aj) has intertyped field from 'ParentChildRelationship' (GenericAspectY.aj:'ParentChildRelationship$ParentHasChildren ParentChildRelationship$ChildHasParent.parent')"/>
+		<message kind="weave" text="Type 'ParentChildRelationship$ChildHasParent' (GenericAspectY.aj) has intertyped field from 'ParentChildRelationship' (GenericAspectY.aj:'P ParentChildRelationship$ChildHasParent.parent')"/>
 		<message kind="weave" text="Type 'ParentChildRelationship$ChildHasParent' (GenericAspectY.aj) has intertyped method from 'ParentChildRelationship' (GenericAspectY.aj:'P ParentChildRelationship$ChildHasParent.getParent()')"/>
 		<message kind="weave" text="Type 'ParentChildRelationship$ChildHasParent' (GenericAspectY.aj) has intertyped method from 'ParentChildRelationship' (GenericAspectY.aj:'void ParentChildRelationship$ChildHasParent.setParent(P)')"/>
 		<message kind="weave" text="Extending interface set for type 'Bottom' (GenericAspectY.aj) to include 'ParentChildRelationship$ChildHasParent&lt;Top&gt;' (GenericAspectY.aj)"/>
@@ -4606,7 +4606,7 @@
 		<message kind="weave" text="Type 'ParentChildRelationship$ParentHasChildren' (GenericAspectZ.aj) has intertyped method from 'ParentChildRelationship' (GenericAspectZ.aj:'java.util.List&lt;C&gt; ParentChildRelationship$ParentHasChildren.getChildren()')"/>
 		<message kind="weave" text="Type 'ParentChildRelationship$ParentHasChildren' (GenericAspectZ.aj) has intertyped method from 'ParentChildRelationship' (GenericAspectZ.aj:'void ParentChildRelationship$ParentHasChildren.addChild(C)')"/>
 		<message kind="weave" text="Type 'ParentChildRelationship$ParentHasChildren' (GenericAspectZ.aj) has intertyped method from 'ParentChildRelationship' (GenericAspectZ.aj:'void ParentChildRelationship$ParentHasChildren.removeChild(C)')"/>
-		<message kind="weave" text="Type 'ParentChildRelationship$ChildHasParent' (GenericAspectZ.aj) has intertyped field from 'ParentChildRelationship' (GenericAspectZ.aj:'ParentChildRelationship$ParentHasChildren ParentChildRelationship$ChildHasParent.parent')"/>
+		<message kind="weave" text="Type 'ParentChildRelationship$ChildHasParent' (GenericAspectZ.aj) has intertyped field from 'ParentChildRelationship' (GenericAspectZ.aj:'P ParentChildRelationship$ChildHasParent.parent')"/>
 		<message kind="weave" text="Type 'ParentChildRelationship$ChildHasParent' (GenericAspectZ.aj) has intertyped method from 'ParentChildRelationship' (GenericAspectZ.aj:'P ParentChildRelationship$ChildHasParent.getParent()')"/>
 		<message kind="weave" text="Type 'ParentChildRelationship$ChildHasParent' (GenericAspectZ.aj) has intertyped method from 'ParentChildRelationship' (GenericAspectZ.aj:'void ParentChildRelationship$ChildHasParent.setParent(P)')"/>
 		<message kind="weave" text="Extending interface set for type 'Bottom' (GenericAspectZ.aj) to include 'ParentChildRelationship$ChildHasParent&lt;Top&gt;' (GenericAspectZ.aj)"/>
