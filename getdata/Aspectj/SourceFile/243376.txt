@@ -49,6 +49,16 @@ public interface ICompilerConfiguration {
     public List /*String*/ getProjectSourceFiles();
 
     /**
+     * Return a subset of those files we'd get on getProjectSourceFiles() - the subset that have changed since
+     * the last build.  If someone else has already worked out what needs rebuilding, we don't need to do it again
+     * by checking all of the projectSourceFiles(). Returning an empty list means nothing has changed, returning null
+     * means you have no idea what changed and the compiler should work it out.
+     * 
+     * @return a subset of those files that would be returned on getProjectSourceFiles() that have actually *changed*
+     */
+    public List /*String*/ getProjectSourceFilesChanged();
+    
+    /**
      * @return the classpath to use
      */
     public String getClasspath();
@@ -342,27 +342,33 @@ public class AspectJElementHierarchy implements IHierarchy {
 	// findElementForHandle() to mirror behaviour before pr141730
 	private IProgramElement findElementForHandleOrCreate(String handle, boolean create) {
 		// try the cache first...
-		IProgramElement ret = (IProgramElement) handleMap.get(handle);
-		if (ret != null) return ret;
+		IProgramElement ipe = (IProgramElement) handleMap.get(handle);
+		if (ipe != null) {
+			return ipe;
+		}
 
-		ret = findElementForHandle(root,handle);
-		if (ret == null && create) {
-			ret = createFileStructureNode(getFilename(handle));
+		ipe = findElementForHandle(root,handle);
+		if (ipe == null && create) {
+			ipe = createFileStructureNode(getFilename(handle));
 		}
-		if (ret != null) {
-			cache(handle,(ProgramElement)ret);
+		if (ipe != null) {
+			cache(handle,ipe);
 		}
-		return ret;
+		return ipe;
 	}
 
 	private IProgramElement findElementForHandle(IProgramElement parent, String handle) {
 		for (Iterator it = parent.getChildren().iterator(); it.hasNext(); ) {
 			IProgramElement node = (IProgramElement)it.next();
-			if (handle.equals(node.getHandleIdentifier())) {
+			String nodeHid = node.getHandleIdentifier();
+			if (handle.equals(nodeHid)) {
 				return node;
 			} else {
-				IProgramElement childSearch = findElementForHandle(node,handle);
-				if (childSearch != null) return childSearch;
+				if (handle.startsWith(nodeHid)) {
+					// it must be down here if it is anywhere
+					IProgramElement childSearch = findElementForHandle(node,handle);
+					if (childSearch != null) return childSearch;
+				}
 			}
 		}
 		return null;
@@ -9,12 +9,11 @@
  * Contributors: 
  *     Mik Kersten     initial implementation 
  * ******************************************************************/
-
-
 package org.aspectj.asm;
 
 import java.io.*;
 import java.util.List;
+import java.util.Set;
 
 /**
  * @author Mik Kersten
@@ -27,16 +26,13 @@ public interface IRelationship extends Serializable {
 
 	public String getSourceHandle();
 
-	public boolean addTarget(String handle);
+	public void addTarget(String handle);
 
 	public Kind getKind();
 
 	public boolean hasRuntimeTest();
 
-	/**
-	 * Uses "typesafe enum" pattern.
-	 */
-	public static class Kind implements Serializable {
+	public static class Kind implements Serializable { // typesafe enum
 
 		private static final long serialVersionUID = -2691351740214705220L;
 
@@ -10,15 +10,13 @@
  *     Mik Kersten     initial implementation 
  *     Andy Clement    Extensions for better IDE representation
  * ******************************************************************/
-
-
 package org.aspectj.asm.internal;
 
+import java.util.Collection;
 import java.util.List;
+import java.util.Set;
 
 import org.aspectj.asm.IRelationship;
-//import org.aspectj.asm.IRelationship.Kind;
-
 
 /**
  * @author Mik Kersten
@@ -29,6 +27,7 @@ public class Relationship implements IRelationship {
 
 	private String name;
 	private Kind kind;
+	private boolean isAffects;
 	private String sourceHandle;
 	private List targets;
 	private boolean hasRuntimeTest;
@@ -41,6 +40,13 @@ public class Relationship implements IRelationship {
 		boolean runtimeTest) {
 
 		this.name = name;
+		this.isAffects = 
+			name.equals("advises") || 
+	        name.equals("declares on") || 
+	        name.equals("softens") ||
+	        name.equals("matched by") || 
+	        name.equals("declared on") || 
+	        name.equals("annotates");
 		this.kind = kind;
 		this.sourceHandle = sourceHandle;
 		this.targets = targets;
@@ -63,33 +69,28 @@ public class Relationship implements IRelationship {
 		return sourceHandle;
 	}
 
+	// TODO should be a Set and not a list
 	public List getTargets() {
 		return targets;
 	}
 
-	public boolean addTarget(String handle) {
-		if (targets.contains(handle)) return false;
+	public void addTarget(String handle) {
+		if (targets.contains(handle)) return;
 		targets.add(handle);
-		return true;
 	}
 
 	public boolean hasRuntimeTest() {
 		return hasRuntimeTest;
 	}
 
-	// For repairing the relationship map on incremental builds, we need
-	// to know the direction of the relationship: either 'affects' or 'affected by'
-	// this set are considered the 'affects' relationship.  If we know which direction
-	// it is in, we know which ones should be removed when a particular resource
-	// is modified because the subsequent reweave will re-add it.
+	/**
+	 * Return the direction of the relationship.  It might be affects or affected-by.
+	 * The direction enables the incremental model repair code to do the right thing.
+	 * 
+	 * @return true if is an affects relationship: advises/declareson/softens/matchedby/declaredon/annotates
+	 */
 	public boolean isAffects() {
-	    // TODO should be a well defined set (enum type) with a flag for this...
-		return name.equals("advises") || 
-		        name.equals("declares on") || 
-		        name.equals("softens") ||
-		        name.equals("matched by") || 
-		        name.equals("declared on") || 
-		        name.equals("annotates");
+		return isAffects;
 	}
 
 }
@@ -341,7 +341,12 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
             // have to tell state we succeeded or next is not incremental
             state.successfulCompile(buildConfig,batch);
 
-            copyResourcesToDestination();
+			// For a full compile, copy resources to the destination
+			// - they should not get deleted on incremental and AJDT
+			// will handle changes to them that require a recopying
+            if (batch) {
+            	copyResourcesToDestination();
+            }
 
             if (buildConfig.getOutxmlName() != null) {
             	writeOutxmlFile();
@@ -761,7 +761,11 @@ public class AjState {
             }
 
 			deleteClassFiles();
-			deleteResources();
+			// Do not delete resources on incremental build, AJDT will handle
+			// copying updates to the output folder.  AspectJ only does a copy
+			// of them on full build (see copyResourcesToDestination() call
+			// in AjBuildManager)
+//			deleteResources();
 
 			addAffectedSourceFiles(thisTime,thisTime);
 		} else {
@@ -231,51 +231,53 @@ public class MoreOutputLocationManagerTests extends AbstractMultiProjectIncremen
 	 * a text file contained within a jar is copied and then 
 	 * deleted correctly. Essentially tests AjState.deleteResources().
 	 */
-	public void testAjStateDeleteResources() {
-		String inpathDir  = inpathTestingDir + File.separator + "inpathJar.jar";
-		addInpathEntry(inpathDir);
-		
-		build("inpathTesting");
-		
-		AjState state = getState();
-		
-		String resource = expectedOutputDir + File.separator + "inpathResource.txt";
-		File f = new File(resource);
-		assertTrue("expected file " + resource + " to exist but it did not",f.exists());
-		// this call should delete the resources
-		state.getFilesToCompile(true);
-		assertFalse("did not expect the file " + resource + " to exist but it does",f.exists());
-	}
+	// see 243376: for now don't do this, waste of cpu - ajdt better for handling resources - but is that true for inpath resources?
+//	public void testAjStateDeleteResources() {
+//		String inpathDir  = inpathTestingDir + File.separator + "inpathJar.jar";
+//		addInpathEntry(inpathDir);
+//		
+//		build("inpathTesting");
+//		
+//		AjState state = getState();
+//		
+//		String resource = expectedOutputDir + File.separator + "inpathResource.txt";
+//		File f = new File(resource);
+//		assertTrue("expected file " + resource + " to exist but it did not",f.exists());
+//		// this call should delete the resources
+//		state.getFilesToCompile(true);
+//		assertFalse("did not expect the file " + resource + " to exist but it does",f.exists());
+//	}
 
 	/**
 	 * Can set to copy resources that are in inpath dirs - check that
 	 * a text file contained within such a dir is copied and then 
 	 * deleted correctly. Essentially tests AjState.maybeDeleteResources().
 	 */
-	public void testAjStateDeleteResourcesInInputDir() {
-		// temporary problem with this on linux, think it is a filesystem lastmodtime issue
-		if (System.getProperty("os.name","").toLowerCase().equals("linux")) return;
-		if (System.getProperty("os.name","").toLowerCase().indexOf("mac")!=-1) return;
-
-		AjBuildManager.COPY_INPATH_DIR_RESOURCES = true;
-		try {
-			String inpathDir = inpathTestingDir + File.separator + "injarBin"
-					+ File.separator + "pkg";
-			addInpathEntry(inpathDir);
-			build("inpathTesting");
-			AjState state = getState();
-			String resource = "inDirResource.txt";
-			assertTrue("expected state to have resource " + resource + "but it did not", 
-					state.hasResource(resource));
-			// this call should delete the resources - tests AjState.deleteResources()
-			state.getFilesToCompile(true);
-			assertFalse("did not expect state to have resource " + resource +
-					" but found that it did", state.hasResource(resource));
-		} finally {
-			AjBuildManager.COPY_INPATH_DIR_RESOURCES = false;
-		}
-		
-	}
+	// see 243376: for now don't do this, waste of cpu - ajdt better for handling resources - but is that true for inpath resources?
+//	public void testAjStateDeleteResourcesInInputDir() {
+//		// temporary problem with this on linux, think it is a filesystem lastmodtime issue
+//		if (System.getProperty("os.name","").toLowerCase().equals("linux")) return;
+//		if (System.getProperty("os.name","").toLowerCase().indexOf("mac")!=-1) return;
+//
+//		AjBuildManager.COPY_INPATH_DIR_RESOURCES = true;
+//		try {
+//			String inpathDir = inpathTestingDir + File.separator + "injarBin"
+//					+ File.separator + "pkg";
+//			addInpathEntry(inpathDir);
+//			build("inpathTesting");
+//			AjState state = getState();
+//			String resource = "inDirResource.txt";
+//			assertTrue("expected state to have resource " + resource + "but it did not", 
+//					state.hasResource(resource));
+//			// this call should delete the resources - tests AjState.deleteResources()
+//			state.getFilesToCompile(true);
+//			assertFalse("did not expect state to have resource " + resource +
+//					" but found that it did", state.hasResource(resource));
+//		} finally {
+//			AjBuildManager.COPY_INPATH_DIR_RESOURCES = false;
+//		}
+//		
+//	}
 
 	/**
 	 * Changing inpath entry from a jar to a directory between builds means
