@@ -0,0 +1,64 @@
+/*******************************************************************************
+ * Copyright (c) 2005 Contributors.
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ * 
+ * Contributors:
+ *   Alexandre Vasseur         initial implementation
+ *******************************************************************************/
+package ataspectj;
+
+import junit.framework.TestCase;
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.annotation.Before;
+import org.aspectj.lang.JoinPoint;
+import org.aspectj.lang.reflect.MethodSignature;
+
+/**
+ * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
+ */
+public class Bug104212 extends TestCase {
+
+    static int s_i = 0;
+
+    public static void main(String[] args) {
+        TestHelper.runAndThrowOnFailure(suite());
+    }
+
+    public static junit.framework.Test suite() {
+        return new junit.framework.TestSuite(Bug104212.class);
+    }
+
+    public void testStaticMethodFromSuperClass() {
+        Child.doSome();
+        assertEquals(1, s_i);
+    }
+
+    static class Parent {
+        static void foo() {}
+    }
+
+    static class Child extends Parent {
+        static void doSome() {
+            foo();// this is the bug
+        }
+    }
+
+    @Aspect
+    public static class TestAspect {
+
+        @Before("call(* ataspectj.Bug104212.Parent.foo()) && within(ataspectj.Bug104212.Child)")
+        public void before(JoinPoint jp) {
+            // AJ bug was here since Java 1.4...
+            // was: call(Bug104212.Child.foo())
+            assertEquals("call(Bug104212.Parent.foo())", jp.toShortString());
+            assertEquals(Parent.class, jp.getSignature().getDeclaringType());
+            assertNotNull(((MethodSignature)jp.getSignature()).getMethod());
+            s_i++;
+        }
+    }
+
+}
@@ -116,4 +116,8 @@ public class AtAjSyntaxTests extends XMLBasedAjcTestCase {
     public void testMultipleBinding() {
         runTest("MultipleBinding");
     }
+
+    public void testBug104212() {
+        runTest("Bug104212");
+    }
 }
\ No newline at end of file
@@ -144,4 +144,10 @@
         <run class="ataspectj.MultipleBindingTest"/>
     </ajc-test>
 
+    <ajc-test dir="java5/ataspectj" title="Bug104212">
+        <compile files="ataspectj/Bug104212.java,ataspectj/TestHelper.java" options="-1.5"/>
+        <run class="ataspectj.Bug104212"/>
+    </ajc-test>
+
+
 </suite>
\ No newline at end of file
@@ -1626,7 +1626,7 @@ class BcelClassWeaver implements IClassWeaver {
 		String methodName = invoke.getName(cpg);
 		if (methodName.startsWith(NameMangler.PREFIX)) {
 			Member method =
-				BcelWorld.makeMethodSignature(clazz, invoke);
+				world.makeMethodSignature(clazz, invoke);
 			ResolvedMember declaredSig = method.resolve(world);
 			//System.err.println(method + ", declaredSig: "  +declaredSig);
 			if (declaredSig == null) return;
@@ -705,7 +705,7 @@ public class BcelShadow extends Shadow {
     {
         final InstructionList body = enclosingMethod.getBody();
 
-        Member sig = BcelWorld.makeMethodSignature(
+        Member sig = world.makeMethodSignature(
                     	enclosingMethod.getEnclosingClass(),
                     	(InvokeInstruction) callHandle.getInstruction());
 
@@ -736,7 +736,7 @@ public class BcelShadow extends Shadow {
             new BcelShadow(
                 world,
                 MethodCall,
-                BcelWorld.makeMethodSignature(
+                world.makeMethodSignature(
                     enclosingMethod.getEnclosingClass(),
                     (InvokeInstruction) callHandle.getInstruction()),
                 enclosingMethod,
@@ -20,6 +20,7 @@ import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.StringTokenizer;
+import java.util.Iterator;
 
 import org.aspectj.apache.bcel.classfile.ClassParser;
 import org.aspectj.apache.bcel.classfile.JavaClass;
@@ -355,7 +356,7 @@ public class BcelWorld extends World implements Repository {
 
     }
 
-    public static Member makeMethodSignature(LazyClassGen cg, InvokeInstruction ii) {
+    public Member makeMethodSignature(LazyClassGen cg, InvokeInstruction ii) {
     	ConstantPoolGen cpg = cg.getConstantPoolGen();
         String declaring = ii.getClassName(cpg);
         String name = ii.getName(cpg);
@@ -369,6 +370,27 @@ public class BcelWorld extends World implements Repository {
               : (ii instanceof INVOKESPECIAL && ! name.equals("<init>"))
                 ? Modifier.PRIVATE
                 : 0;
+
+        // in Java 1.4 and after, static method call of super class within subclass method appears
+        // as declared by the subclass in the bytecode - but they are not
+        // see #104212
+        if (ii instanceof INVOKESTATIC) {
+            ResolvedType appearsDeclaredBy = resolve(declaring);
+            // look for the method there
+            for (Iterator iterator = appearsDeclaredBy.getMethods(); iterator.hasNext();) {
+                ResolvedMember method = (ResolvedMember) iterator.next();
+                if (method.isStatic()) {
+                    if (name.equals(method.getName()) && signature.equals(method.getSignature())) {
+                        // we found it
+                        declaring = method.getDeclaringType().getName();
+                        break;
+                    }
+                }
+
+            }
+        }
+        //FIXME if not found we ll end up again with the bug.. can this happen?
+
         return Member.method(UnresolvedType.forName(declaring), modifier, name, signature);
     }  
 
