@@ -1015,8 +1015,8 @@ public class AspectDeclaration extends TypeDeclaration {
 				hasAspectMethod = AjcMemberMaker.perObjectHasAspectMethod(typeX);
 			} else if (perClause.getKind() == PerClause.PERTYPEWITHIN) {
 			    // PTWIMPL Use these variants of aspectOf()/hasAspect()
-				aspectOfMethod  = AjcMemberMaker.perTypeWithinAspectOfMethod(typeX);
-				hasAspectMethod = AjcMemberMaker.perTypeWithinHasAspectMethod(typeX);
+				aspectOfMethod  = AjcMemberMaker.perTypeWithinAspectOfMethod(typeX,world.getWorld().isInJava5Mode());
+				hasAspectMethod = AjcMemberMaker.perTypeWithinHasAspectMethod(typeX,world.getWorld().isInJava5Mode());
 			} else {
 				throw new RuntimeException("bad per clause: " + perClause);	
 			}
@@ -570,12 +570,6 @@ public class EclipseFactory {
 	private ReferenceBinding lookupBinding(String sname) {
 		char[][] name = CharOperation.splitOn('.', sname.toCharArray());
 		ReferenceBinding rb = lookupEnvironment.getType(name);
-		// XXX We do this because the pertypewithin aspectOf(Class) generated method needs it.  Without this
-		// we don't get a 'rawtype' as the argument type for a messagesend to aspectOf() and this leads to 
-		// a compile error if some client class calls aspectOf(A.class) or similar as it says Class<A> isn't
-		// compatible with Class<T>
-		if (sname.equals("java.lang.Class")) 
-			rb = lookupEnvironment.createRawType(rb,rb.enclosingType());
 		return rb;		
 	}
 
Binary files differ
Binary files differ
@@ -0,0 +1,27 @@
+import java.util.*;
+
+public class Pr109283 {
+	
+	enum Foo { Wibble, Wobble, Woo }
+	
+	public static void main(String[] args) throws Exception {
+		EnumSet<Foo> set = EnumSet.noneOf(Foo.class);
+		C c2 = Recipient.instanceOf(C.class);
+	}
+	
+	
+}
+
+class C {}
+
+class Recipient {}
+
+aspect Donor {
+	
+	static <E> E Recipient.first(List<E> elements) { return elements.get(0); }
+	
+	public static <T> T Recipient.instanceOf(Class<T> aT) throws Exception { 
+		return aT.newInstance(); 
+	}
+	
+}
@@ -450,6 +450,10 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	  runTest("declare parents on a missing type");
   }
 
+  public void testParameterizedGenericMethods() {
+	  runTest("parameterized generic methods");
+  }
+  
   // helper methods.....
 
   public SyntheticRepository createRepos(File cpentry) {
@@ -602,6 +602,11 @@
         </compile>
     </ajc-test>
 
+    <ajc-test dir="bugs150" title="parameterized generic methods">
+        <compile files="Pr109283.aj" options="-1.5 -warn:indirectStatic">
+        </compile>
+    </ajc-test> 
+    
     <!-- ============================================================================ -->
     <!-- ============================================================================ -->
 
@@ -3287,7 +3292,7 @@
 
    <ajc-test dir="java5/generics/itds/sharing" title="method itd using type variable from target type - I2">
      <compile files="MethodI2.aj" options="-1.5">
-       <message kind="error" line="7" text="The method m(List&lt;Integer&gt;) in the type Base&lt;N&gt; is not applicable for the arguments (List&lt;String&gt;)"/>
+       <message kind="error" line="7" text="The method m(List&lt;Integer&gt;) in the type Base&lt;Integer&gt; is not applicable for the arguments (List&lt;String&gt;)"/>
      </compile>
    </ajc-test>
 
@@ -3445,8 +3450,8 @@
    </ajc-test>
    <ajc-test dir="java5/generics/genericaspects/" title="uberaspects - M">
      <compile files="GenericAspectM.aj" options="-1.5">
-       <message kind="error" line="23" text="The method m0(Integer) in the type GenericAspect&lt;A,B&gt;.SimpleI&lt;L&gt; is not applicable for the arguments (String)"/>
-       <message kind="error" line="24" text="The method m1(List&lt;Integer&gt;) in the type GenericAspect&lt;A,B&gt;.SimpleI&lt;L&gt; is not applicable for the arguments (List&lt;String&gt;)"/>
+       <message kind="error" line="23" text="The method m0(Integer) in the type GenericAspect&lt;A,B&gt;.SimpleI&lt;Integer&gt; is not applicable for the arguments (String)"/>
+       <message kind="error" line="24" text="The method m1(List&lt;Integer&gt;) in the type GenericAspect&lt;A,B&gt;.SimpleI&lt;Integer&gt; is not applicable for the arguments (List&lt;String&gt;)"/>
        <message kind="error" line="25" text="Type mismatch: cannot convert from String to Integer"/>
        <message kind="error" line="26" text="Type mismatch: cannot convert from List&lt;String&gt; to List&lt;Integer&gt;"/>
      </compile>
@@ -3458,7 +3463,7 @@
    <ajc-test dir="java5/generics/genericaspects/" title="uberaspects - O">
      <compile files="GenericAspectO.aj" options="-1.5">
        <message kind="error" line="24" text="Cannot make a static reference to the non-static field Bottom.parent"/>
-       <message kind="error" line="26" text="The method add(Bottom) in the type List&lt;E&gt; is not applicable for the arguments (Top)"/>
+       <message kind="error" line="26" text="The method add(Bottom) in the type List&lt;Bottom&gt; is not applicable for the arguments (Top)"/>
        <message kind="error" line="27" text="Cannot make a static reference to the non-static field Top.children"/>
      </compile>
    </ajc-test>
@@ -270,17 +270,45 @@ public class AjcMemberMaker {
 	};
 
 	// PTWIMPL ResolvedMember for aspectOf(), declared in aspect
-	public static ResolvedMember perTypeWithinAspectOfMethod(UnresolvedType declaringType) {
-		return new ResolvedMemberImpl(Member.METHOD,
-				declaringType, PUBLIC_STATIC, "aspectOf", 
-				"(Ljava/lang/Class;)" + declaringType.getSignature());		
+	public static ResolvedMember perTypeWithinAspectOfMethod(UnresolvedType declaringType,boolean inJava5Mode) {
+		UnresolvedType parameterType = null;
+		if (inJava5Mode) {
+			parameterType = UnresolvedType.forRawTypeName("java.lang.Class");
+		} else {
+			parameterType = UnresolvedType.forSignature("Ljava/lang/Class;");
+		}
+		return new ResolvedMemberImpl(
+				Member.METHOD,
+				declaringType,
+				PUBLIC_STATIC,
+				declaringType,
+				"aspectOf",
+				new UnresolvedType[] {parameterType}
+				);
+//		return new ResolvedMemberImpl(Member.METHOD,
+//				declaringType, PUBLIC_STATIC, "aspectOf", 
+//				"(Ljava/lang/Class;)" + declaringType.getSignature());		
 	}
 
 	// PTWIMPL ResolvedMember for hasAspect(), declared in aspect
-	public static ResolvedMember perTypeWithinHasAspectMethod(UnresolvedType declaringType) {
-		return new ResolvedMemberImpl(Member.METHOD,
-			declaringType, PUBLIC_STATIC, "hasAspect", 
-			"(Ljava/lang/Class;)Z");		
+	public static ResolvedMember perTypeWithinHasAspectMethod(UnresolvedType declaringType, boolean inJava5Mode) {
+		UnresolvedType parameterType = null;
+		if (inJava5Mode) {
+			parameterType = UnresolvedType.forRawTypeName("java.lang.Class");
+		} else {
+			parameterType = UnresolvedType.forSignature("Ljava/lang/Class;");
+		}
+		return new ResolvedMemberImpl(
+				Member.METHOD,
+				declaringType,
+				PUBLIC_STATIC,
+				ResolvedType.BOOLEAN,
+				"hasAspect",
+				new UnresolvedType[] {parameterType}
+				);
+//		return new ResolvedMemberImpl(Member.METHOD,
+//			declaringType, PUBLIC_STATIC, "hasAspect", 
+//			"(Ljava/lang/Class;)Z");		
 	};
 
 	// -- privileged accessors
@@ -398,7 +398,7 @@ public class BcelPerClauseAspectAdder extends BcelTypeMunger {
 
     private void generatePerTWAspectOfMethod(LazyClassGen classGen) {
         InstructionFactory factory = classGen.getFactory();
-        LazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinAspectOfMethod(aspectType));
+        LazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinAspectOfMethod(aspectType,classGen.getWorld().isInJava5Mode()));
         flagAsSynthetic(method, false);
         classGen.addMethodGen(method);
 
@@ -437,7 +437,7 @@ public class BcelPerClauseAspectAdder extends BcelTypeMunger {
 
     private void generatePerTWHasAspectMethod(LazyClassGen classGen) {
         InstructionFactory factory = classGen.getFactory();
-        LazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinHasAspectMethod(aspectType));
+        LazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinHasAspectMethod(aspectType,classGen.getWorld().isInJava5Mode()));
         flagAsSynthetic(method, false);
         classGen.addMethodGen(method);
 
