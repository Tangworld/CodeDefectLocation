@@ -226,7 +226,8 @@ public class InterTypeConstructorDeclaration extends InterTypeDeclaration {
 		ResolvedType declaringTypeX = world.fromEclipse(onTypeBinding);
 		ResolvedType aspectType = world.fromEclipse(classScope.referenceContext.binding);
 
-		
+		if (interTypeScope==null) return null; // We encountered a problem building the scope, don't continue - error already reported
+
 
 		// This signature represents what we want consumers of the targetted type to 'see'
 		ResolvedMember signature = world.makeResolvedMemberForITD(binding,onTypeBinding,interTypeScope.getRecoveryAliases());
@@ -35,6 +35,7 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 import org.aspectj.weaver.AjAttribute;
 import org.aspectj.weaver.ResolvedMember;
 import org.aspectj.weaver.ResolvedTypeMunger;
@@ -338,7 +339,7 @@ public abstract class InterTypeDeclaration extends AjMethodDeclaration {
 	 * they have to be resolved against the ontype, not the aspect containing the ITD.
 	 */
 	public void ensureScopeSetup() {
-		if (scopeSetup) return; // don't do it agai
+		if (scopeSetup) return; // don't do it again
 		MethodScope scope = this.scope;
 
 		TypeReference ot = onType;
@@ -353,6 +354,15 @@ public abstract class InterTypeDeclaration extends AjMethodDeclaration {
 		// resolve it
 		ReferenceBinding rb = (ReferenceBinding)ot.getTypeBindingPublic(scope.parent);
 
+		if (rb instanceof TypeVariableBinding) {
+			scope.problemReporter().signalError(sourceStart,sourceEnd,
+					  "Cannot make inter-type declarations on type variables, use an interface and declare parents");
+			this.ignoreFurtherInvestigation=true;
+			rb = new ProblemReferenceBinding(rb.compoundName,((TypeVariableBinding)rb).firstBound.enclosingType(),0);
+			return;
+		}
+
+		
 		// if resolution failed, give up - someone else is going to report an error
 		if (rb instanceof ProblemReferenceBinding) return;
 
@@ -199,6 +199,9 @@ public class InterTypeFieldDeclaration extends InterTypeDeclaration {
 			declaringType = declaringType.getGenericType();
 		}
 
+		if (interTypeScope==null) return null; // We encountered a problem building the scope, don't continue - error already reported
+
+		
 		// Build a half correct resolvedmember (makeResolvedMember understands tvars) then build a fully correct sig from it
 		ResolvedMember sigtemp = world.makeResolvedMemberForITD(binding,onTypeBinding,interTypeScope.getRecoveryAliases());
 		ResolvedMember sig = new ResolvedMemberImpl(Member.FIELD,declaringType,declaredModifiers,
@@ -180,9 +180,12 @@ public class InterTypeMethodDeclaration extends InterTypeDeclaration {
 			//return null;
 			throw new AbortCompilationUnit(compilationResult,null);
 		}
+
 		if (isTargetAnnotation(classScope,"method")) return null; // Error message output in isTargetAnnotation
 		if (isTargetEnum(classScope,"method")) return null; // Error message output in isTargetEnum
 
+		if (interTypeScope==null) return null; // We encountered a problem building the scope, don't continue - error already reported
+		
 		// This signature represents what we want consumers of the targetted type to 'see'
 		// must use the factory method to build it since there may be typevariables from the binding
 		// referred to in the parameters/returntype
@@ -19,6 +19,7 @@ import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.InvocationSite;
+import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Scope;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
@@ -57,8 +58,15 @@ public class InterTypeFieldBinding extends FieldBinding {
 
 		SourceTypeBinding invocationType = scope.invocationType();
 		//System.out.println("receiver: " + receiverType + ", " + invocationType);
+		ReferenceBinding declaringType = declaringClass;
 
-		if (invocationType == declaringClass) return true;
+		// FIXME asc what about parameterized types and private ITD generic fields on interfaces?
+		
+		// Don't work with a raw type, work with the generic type
+		if (declaringClass.isRawType()) 
+			 declaringType = ((RawTypeBinding)declaringClass).type;
+		
+		if (invocationType == declaringType) return true;
 
 
 	//	if (invocationType.isPrivileged) {
@@ -74,9 +82,9 @@ public class InterTypeFieldBinding extends FieldBinding {
 		if (isPrivate()) {
 			// answer true if the receiverType is the declaringClass
 			// AND the invocationType and the declaringClass have a common enclosingType
-			if (receiverType != declaringClass) return false;
+			if (receiverType != declaringType) return false;
 
-			if (invocationType != declaringClass) {
+			if (invocationType != declaringType) {
 				ReferenceBinding outerInvocationType = invocationType;
 				ReferenceBinding temp = outerInvocationType.enclosingType();
 				while (temp != null) {
@@ -84,7 +92,7 @@ public class InterTypeFieldBinding extends FieldBinding {
 					temp = temp.enclosingType();
 				}
 
-				ReferenceBinding outerDeclaringClass = declaringClass;
+				ReferenceBinding outerDeclaringClass = declaringType;
 				temp = outerDeclaringClass.enclosingType();
 				while (temp != null) {
 					outerDeclaringClass = temp;
@@ -58,6 +58,9 @@ public class InterTypeScope extends ClassScope {
 			else throw new BCException("In parameterized type "+onType+", can't handle reference binding "+rb);
 		} else if (onType instanceof ProblemReferenceBinding) { 
 			return null;
+		} else if (onType instanceof TypeVariableBinding) {
+			// Problem will have already been reported, cant ITD on a type variable.
+			return null;
 		}
 
 		throw new BCException("can't handle: " + onType);
@@ -51,8 +51,10 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testITDCtor_pr112783()       { runTest("Problem with constructor ITDs");}
   */
 
-  public void testUnboundFormal_pr112027() { runTest("unexpected error unboundFormalInPC");}
-  public void testCCEGenerics_pr113445()       { runTest("Generics ClassCastException");}
+  public void testUnboundFormal_pr112027()    { runTest("unexpected error unboundFormalInPC");}
+  public void testCCEGenerics_pr113445()      { runTest("Generics ClassCastException");}
+  public void testMatthewsAspect_pr113947_1() { runTest("maws generic aspect - 1");}
+  public void testMatthewsAspect_pr113947_2() { runTest("maws generic aspect - 2");}
 
   public void testBadDecp_pr110788_1() { runTest("bad generic decp - 1");}
   public void testBadDecp_pr110788_2() { runTest("bad generic decp - 2");}
@@ -11,7 +11,22 @@
         <compile files="pr112783.aj" options="-1.5"/>
     </ajc-test>
 
-    
+    <ajc-test dir="bugs150/pr113947/case1" title="maws generic aspect - 1">
+        <compile files="AbstractListSupport.java,AnotherItem.java,Item.java,LinkedList.java,LinkedListItem.java,ListItem.java,StringList.java" options="-1.5">
+          <!-- the 'static ref' messages are a bit poor and ought to be eliminated... -->
+          <message kind="error" line="6" text="Cannot make a static reference to the non-static type M"/>
+          <message kind="error" line="6" text="Cannot make inter-type declarations on type variables"/>
+          <message kind="error" line="8" text="Cannot make a static reference to the non-static type I"/>
+          <message kind="error" line="8" text="Cannot make inter-type declarations on type variables"/>
+          <message kind="error" line="12" text="Cannot make a static reference to the non-static type M"/>
+          <message kind="error" line="12" text="Cannot make inter-type declarations on type variables"/>
+        </compile>
+    </ajc-test>
+
+    <ajc-test dir="bugs150/pr113947/case2" title="maws generic aspect - 2">
+        <compile files="AbstractListSupport.java" options="-1.5"/><!--,AnotherItem.java,Item.java,LinkedList.java,LinkedListItem.java,ListItem.java,StringList.java" options="-1.5"/-->
+    </ajc-test>
+ 
     <ajc-test dir="bugs150/pr99191" title="declare annotation on non existent type - 1">
         <compile files="pr99191_1.java" options="-1.5">
         	<message kind="error" line="4" text="The field 'int C.noSuchField' does not exist"/>
@@ -52,7 +67,7 @@
         	<message kind="warning" text="void C.&lt;init&gt;(int) - already has an annotation of type Annotation, cannot add a second instance [Xlint:elementAlreadyAnnotated]"/>
         </compile>
     </ajc-test>
- 
+
     <ajc-test dir="bugs150/pr113630/case1" title="IncompatibleClassChangeError - errorscenario">
         <compile files="Bean.java,BeanTestCase.java,javaBean.java,propertyChanger.java,PropertySupportAspect5.aj" options="-1.5">
           <message kind="warning" line="9" text="Failing match because annotation 'javaBean' on type 'Bean' has SOURCE retention.  Matching allowed when RetentionPolicy is CLASS or RUNTIME"/>
@@ -0,0 +1,16 @@
+
+public abstract aspect AbstractListSupport<I,M extends I> {
+
+	declare parents : @LinkedListItem * implements M;
+
+	private M M.next;
+
+	public I M.getNext () {
+		return next;
+	}
+
+	public void M.setNext (M item) {
+		next = item;
+	}
+
+}
@@ -0,0 +1,5 @@
+
+@LinkedListItem
+public class AnotherItem {
+
+}
@@ -0,0 +1,5 @@
+
+public class Item {
+
+
+}
@@ -0,0 +1,145 @@
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+
+public class LinkedList implements List<ListItem> {
+
+	public boolean add (ListItem item) {
+		MutableListItem listItem = (MutableListItem)item;
+		listItem.setNext(null);
+		
+		return true;
+	}
+
+	public ListItem get (int i) {
+		return new Item();
+	}
+
+	public void add(int index, ListItem element) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	public boolean addAll(Collection<? extends ListItem> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean addAll(int index, Collection<? extends ListItem> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public void clear() {
+		// TODO Auto-generated method stub
+		
+	}
+
+	public boolean contains(Object o) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean containsAll(Collection<?> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public int indexOf(Object o) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	public boolean isEmpty() {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public Iterator<ListItem> iterator() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public int lastIndexOf(Object o) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	public ListIterator<ListItem> listIterator() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public ListIterator<ListItem> listIterator(int index) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public ListItem remove(int index) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public boolean remove(Object o) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean removeAll(Collection<?> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean retainAll(Collection<?> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public ListItem set(int index, ListItem element) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public int size() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	public List<ListItem> subList(int fromIndex, int toIndex) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public Object[] toArray() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public <T> T[] toArray(T[] a) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+	
+	private interface MutableListItem extends ListItem {
+		public void setNext (MutableListItem o);
+	}
+	
+	private static aspect LinkedListSupport {
+		declare parents : Item implements MutableListItem;
+		declare parents : @LinkedListItem * implements MutableListItem;
+
+		private MutableListItem MutableListItem.next;
+		
+		public ListItem MutableListItem.getNext () {
+			return next;
+		}
+		
+		public void MutableListItem.setNext (MutableListItem item) {
+			next = item;
+		}
+	}
+	
+	
+}
@@ -0,0 +1,4 @@
+
+public @interface LinkedListItem {
+
+}
@@ -0,0 +1,5 @@
+
+public interface ListItem {
+
+	public ListItem getNext ();
+}
@@ -0,0 +1,126 @@
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+
+
+public class StringList implements List<ListItem> {
+
+	public void add(int index, ListItem element) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	public boolean add(ListItem o) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean addAll(Collection<? extends ListItem> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean addAll(int index, Collection<? extends ListItem> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public void clear() {
+		// TODO Auto-generated method stub
+		
+	}
+
+	public boolean contains(Object o) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean containsAll(Collection<?> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public ListItem get(int index) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public int indexOf(Object o) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	public boolean isEmpty() {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public Iterator<ListItem> iterator() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public int lastIndexOf(Object o) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	public ListIterator<ListItem> listIterator() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public ListIterator<ListItem> listIterator(int index) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public ListItem remove(int index) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public boolean remove(Object o) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean removeAll(Collection<?> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean retainAll(Collection<?> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public ListItem set(int index, ListItem element) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public int size() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	public List<ListItem> subList(int fromIndex, int toIndex) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public Object[] toArray() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public <T> T[] toArray(T[] a) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+
+}
@@ -0,0 +1,23 @@
+
+public abstract aspect AbstractListSupport<I,M extends I> {
+
+  declare parents : @LinkedListItem * implements M;
+
+
+  // Interface
+  interface ListInterface<Item> {
+    Item getNext();
+    void setNext(Item item);
+  }
+    
+  private K ListInterface<K>.next;
+
+  public K ListInterface<K>.getNext () {
+    return next;
+  }
+
+  public void ListInterface<K>.setNext (K item) {
+    next = item;
+  }
+
+}
@@ -0,0 +1,5 @@
+
+@LinkedListItem
+public class AnotherItem {
+
+}
@@ -0,0 +1,5 @@
+
+public class Item {
+
+
+}
@@ -0,0 +1,145 @@
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+
+public class LinkedList implements List<ListItem> {
+
+	public boolean add (ListItem item) {
+		MutableListItem listItem = (MutableListItem)item;
+		listItem.setNext(null);
+		
+		return true;
+	}
+
+	public ListItem get (int i) {
+		return new Item();
+	}
+
+	public void add(int index, ListItem element) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	public boolean addAll(Collection<? extends ListItem> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean addAll(int index, Collection<? extends ListItem> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public void clear() {
+		// TODO Auto-generated method stub
+		
+	}
+
+	public boolean contains(Object o) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean containsAll(Collection<?> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public int indexOf(Object o) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	public boolean isEmpty() {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public Iterator<ListItem> iterator() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public int lastIndexOf(Object o) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	public ListIterator<ListItem> listIterator() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public ListIterator<ListItem> listIterator(int index) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public ListItem remove(int index) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public boolean remove(Object o) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean removeAll(Collection<?> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean retainAll(Collection<?> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public ListItem set(int index, ListItem element) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public int size() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	public List<ListItem> subList(int fromIndex, int toIndex) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public Object[] toArray() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public <T> T[] toArray(T[] a) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+	
+	private interface MutableListItem extends ListItem {
+		public void setNext (MutableListItem o);
+	}
+	
+	private static aspect LinkedListSupport {
+		declare parents : Item implements MutableListItem;
+		declare parents : @LinkedListItem * implements MutableListItem;
+
+		private MutableListItem MutableListItem.next;
+		
+		public ListItem MutableListItem.getNext () {
+			return next;
+		}
+		
+		public void MutableListItem.setNext (MutableListItem item) {
+			next = item;
+		}
+	}
+	
+	
+}
@@ -0,0 +1,4 @@
+
+public @interface LinkedListItem {
+
+}
@@ -0,0 +1,5 @@
+
+public interface ListItem {
+
+	public ListItem getNext ();
+}
@@ -0,0 +1,126 @@
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+
+
+public class StringList implements List<ListItem> {
+
+	public void add(int index, ListItem element) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	public boolean add(ListItem o) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean addAll(Collection<? extends ListItem> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean addAll(int index, Collection<? extends ListItem> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public void clear() {
+		// TODO Auto-generated method stub
+		
+	}
+
+	public boolean contains(Object o) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean containsAll(Collection<?> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public ListItem get(int index) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public int indexOf(Object o) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	public boolean isEmpty() {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public Iterator<ListItem> iterator() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public int lastIndexOf(Object o) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	public ListIterator<ListItem> listIterator() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public ListIterator<ListItem> listIterator(int index) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public ListItem remove(int index) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public boolean remove(Object o) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean removeAll(Collection<?> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public boolean retainAll(Collection<?> c) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public ListItem set(int index, ListItem element) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public int size() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	public List<ListItem> subList(int fromIndex, int toIndex) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public Object[] toArray() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public <T> T[] toArray(T[] a) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+
+}
