@@ -359,7 +359,6 @@ public class AspectDeclaration extends TypeDeclaration {
 		} else if (perClause.getKind() == PerClause.PEROBJECT) {
 			TypeBinding interfaceType = 
 				generatePerObjectInterface(classFile);
-			world.addTypeBinding(interfaceType);
 			generatePerObjectAspectOfMethod(classFile, interfaceType);
 			generatePerObjectHasAspectMethod(classFile, interfaceType);
 			generatePerObjectBindMethod(classFile, interfaceType);
@@ -541,7 +540,7 @@ public class AspectDeclaration extends TypeDeclaration {
 		    AjcMemberMaker.perObjectInterfaceType(typeX);
 		HelperInterfaceBinding interfaceType =
 			new HelperInterfaceBinding(this.binding, interfaceTypeX);
-		world.addTypeBinding(interfaceType);
+		world.addTypeBindingAndStoreInWorld(interfaceType);
 		interfaceType.addMethod(world, AjcMemberMaker.perObjectInterfaceGet(typeX));
 		interfaceType.addMethod(world, AjcMemberMaker.perObjectInterfaceSet(typeX));
 		interfaceType.generateClass(compilationResult, classFile);
@@ -932,6 +932,11 @@ public class EclipseFactory {
 		typexToBinding.put(fromBinding(binding), binding);
 	}
 
+	public void addTypeBindingAndStoreInWorld(TypeBinding binding) {
+		UnresolvedType ut = fromBinding(binding);
+		typexToBinding.put(ut, binding);
+		world.lookupOrCreateName(ut);
+	}
 
 	public Shadow makeShadow(ASTNode location, ReferenceContext context) {
 		return EclipseShadow.makeShadow(this, location, context);
@@ -46,7 +46,6 @@ import org.aspectj.org.eclipse.jdt.internal.core.builder.StringSet;
 import org.aspectj.util.FileUtil;
 import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.IWeaver;
-import org.aspectj.weaver.ReferenceType;
 import org.aspectj.weaver.ResolvedMember;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
@@ -780,7 +779,7 @@ public class AjState {
 		}
 
 		CompactStructureRepresentation existingStructure = (CompactStructureRepresentation) this.resolvedTypeStructuresFromLastBuild.get(thisTime.getClassName());
-		ReferenceType newResolvedType = (ReferenceType) world.resolve(thisTime.getClassName());
+		ResolvedType newResolvedType = world.resolve(thisTime.getClassName());
 		if (!newResolvedType.isMissing()) {
 			try {
 				ClassFileReader reader = new ClassFileReader(thisTime.getBytes(), null);
@@ -0,0 +1,5 @@
+public abstract aspect A perthis(annotatedClasses()) {
+
+	pointcut annotatedClasses();
+	
+}
@@ -0,0 +1,5 @@
+public aspect A perthis(annotatedClasses()) {
+
+	pointcut annotatedClasses();
+	 
+}
@@ -160,7 +160,16 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		build("P1");
 		checkWasFullBuild();  // adding an aspect makes us go back to the source
 	}
-	
+
+	public void testPr134371() {
+		initialiseProject("PR134371");
+		build("PR134371");
+		alter("PR134371","inc1");
+		build("PR134371");
+		assertTrue("There should be no exceptions handled:\n"+MyErrorHandler.getErrorMessages(),
+				MyErrorHandler.getErrorMessages().isEmpty());		
+
+	}
 
 	/** 
 	 * Setup up two simple projects and build them in turn - check the
@@ -359,7 +359,6 @@ public class AspectDeclaration extends TypeDeclaration {
 		} else if (perClause.getKind() == PerClause.PEROBJECT) {
 			TypeBinding interfaceType = 
 				generatePerObjectInterface(classFile);
-			world.addTypeBinding(interfaceType);
 			generatePerObjectAspectOfMethod(classFile, interfaceType);
 			generatePerObjectHasAspectMethod(classFile, interfaceType);
 			generatePerObjectBindMethod(classFile, interfaceType);
@@ -541,7 +540,7 @@ public class AspectDeclaration extends TypeDeclaration {
 		    AjcMemberMaker.perObjectInterfaceType(typeX);
 		HelperInterfaceBinding interfaceType =
 			new HelperInterfaceBinding(this.binding, interfaceTypeX);
-		world.addTypeBinding(interfaceType);
+		world.addTypeBindingAndStoreInWorld(interfaceType);
 		interfaceType.addMethod(world, AjcMemberMaker.perObjectInterfaceGet(typeX));
 		interfaceType.addMethod(world, AjcMemberMaker.perObjectInterfaceSet(typeX));
 		interfaceType.generateClass(compilationResult, classFile);
@@ -932,6 +932,11 @@ public class EclipseFactory {
 		typexToBinding.put(fromBinding(binding), binding);
 	}
 
+	public void addTypeBindingAndStoreInWorld(TypeBinding binding) {
+		UnresolvedType ut = fromBinding(binding);
+		typexToBinding.put(ut, binding);
+		world.lookupOrCreateName(ut);
+	}
 
 	public Shadow makeShadow(ASTNode location, ReferenceContext context) {
 		return EclipseShadow.makeShadow(this, location, context);
@@ -46,7 +46,6 @@ import org.aspectj.org.eclipse.jdt.internal.core.builder.StringSet;
 import org.aspectj.util.FileUtil;
 import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.IWeaver;
-import org.aspectj.weaver.ReferenceType;
 import org.aspectj.weaver.ResolvedMember;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
@@ -780,7 +779,7 @@ public class AjState {
 		}
 
 		CompactStructureRepresentation existingStructure = (CompactStructureRepresentation) this.resolvedTypeStructuresFromLastBuild.get(thisTime.getClassName());
-		ReferenceType newResolvedType = (ReferenceType) world.resolve(thisTime.getClassName());
+		ResolvedType newResolvedType = world.resolve(thisTime.getClassName());
 		if (!newResolvedType.isMissing()) {
 			try {
 				ClassFileReader reader = new ClassFileReader(thisTime.getBytes(), null);
@@ -0,0 +1,5 @@
+public abstract aspect A perthis(annotatedClasses()) {
+
+	pointcut annotatedClasses();
+	
+}
@@ -0,0 +1,5 @@
+public aspect A perthis(annotatedClasses()) {
+
+	pointcut annotatedClasses();
+	 
+}
@@ -160,7 +160,16 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		build("P1");
 		checkWasFullBuild();  // adding an aspect makes us go back to the source
 	}
-	
+
+	public void testPr134371() {
+		initialiseProject("PR134371");
+		build("PR134371");
+		alter("PR134371","inc1");
+		build("PR134371");
+		assertTrue("There should be no exceptions handled:\n"+MyErrorHandler.getErrorMessages(),
+				MyErrorHandler.getErrorMessages().isEmpty());		
+
+	}
 
 	/** 
 	 * Setup up two simple projects and build them in turn - check the
