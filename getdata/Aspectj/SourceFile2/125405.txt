@@ -69,6 +69,7 @@ import org.aspectj.weaver.TypeVariableReference;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.UnresolvedTypeVariableReferenceType;
 import org.aspectj.weaver.World;
+import org.aspectj.weaver.UnresolvedType.TypeKind;
 
 /**
  * @author Jim Hugunin
@@ -957,7 +958,18 @@ public class EclipseFactory {
 		}else {
 			simpleTx  = UnresolvedType.forName(getName(binding)); 
 		}
+
 		ReferenceType name  = getWorld().lookupOrCreateName(simpleTx);
+		
+		// A type can change from simple > generic > simple across a set of compiles. We need
+		// to ensure the entry in the typemap is promoted and demoted correctly.  The call
+		// to setGenericType() below promotes a simple to a raw. This call demotes it back
+		// to simple
+		// pr125405
+		if (!binding.isRawType() && !binding.isGenericType() && name.getTypekind()==TypeKind.RAW) {
+			name.demoteToSimpleType();
+		}
+
 		EclipseSourceType t = new EclipseSourceType(name, this, binding, decl, unit);
 
 		// For generics, go a bit further - build a typex for the generic type
@@ -282,6 +282,21 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		alter("PR85132","inc1");
 		build("PR85132");
 	}
+
+	// parameterization of generic aspects
+	public void testPr125405() {
+		initialiseProject("PR125405");
+		build("PR125405");
+		checkCompileWeaveCount(1,1);
+		alter("PR125405","inc1");
+		build("PR125405");
+		// "only abstract aspects can have type parameters"
+		checkForError("only abstract aspects can have type parameters");
+		alter("PR125405","inc2");
+		build("PR125405");
+		checkCompileWeaveCount(1,1);
+		assertTrue("Should be no errors, but got "+MyTaskListManager.getErrorMessages(),MyTaskListManager.getErrorMessages().size()==0);		
+	}
 
 	public void testPr92837() {
 		initialiseProject("PR92837");
@@ -566,6 +581,15 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		}
 	}
 
+	public void checkForError(String anError) {
+		List messages = MyTaskListManager.getErrorMessages();
+		for (Iterator iter = messages.iterator(); iter.hasNext();) {
+			IMessage element = (IMessage) iter.next();
+			if (element.getMessage().indexOf(anError)!=-1) return;
+		}
+		fail("Didn't find the error message:\n'"+anError+"'.\nErrors that occurred:\n"+MyTaskListManager.getErrorMessages());
+	}
+
 	private void collectUpFiles(File location,File base,List collectionPoint) {
 		String contents[] = location.list();
 		if (contents==null) return;
@@ -660,6 +660,12 @@ public class ReferenceType extends ResolvedType {
 		}
 	}
 
+	public void demoteToSimpleType() {
+		genericType      = null;
+		typeKind         = TypeKind.SIMPLE;
+		signatureErasure = null;
+	}
+	
 	public ResolvedType getGenericType() {
 		if (isGenericType()) return this;
 		return genericType;
@@ -0,0 +1,9 @@
+package test;
+
+public aspect ATest
+{
+   // main
+   public static void main(String[] args) {
+
+   }
+}
\ No newline at end of file
@@ -0,0 +1,9 @@
+package test;
+
+public aspect ATest<T>
+{
+   // main
+   public static void main(String[] args) {
+
+   }
+}
\ No newline at end of file
@@ -0,0 +1,9 @@
+package test;
+
+public aspect ATest
+{
+   // main
+   public static void main(String[] args) {
+
+   }
+}
\ No newline at end of file
