@@ -79,6 +79,7 @@ public interface IProgramElement extends Serializable {
 	public String getCorrespondingType(boolean getFullyQualifiedType);
 
 	public String toSignatureString();
+	public String toSignatureString(boolean getFullyQualifiedArgTypes);
 
 	public void setRunnable(boolean value);
 	public boolean isRunnable();
@@ -107,11 +108,13 @@ public interface IProgramElement extends Serializable {
 	 * Includes information about the origin of the node.
 	 */
 	public String toLinkLabelString();
+	public String toLinkLabelString(boolean getFullyQualifiedArgTypes);
 
 	/**
 	 * Includes name, parameter types (if any) and details (if any).
 	 */
 	public String toLabelString();
+	public String toLabelString(boolean getFullyQualifiedArgTypes);
 
 	public List getParameterTypes();
 	public void setParameterTypes(List list);
@@ -387,21 +387,34 @@ public class ProgramElement implements IProgramElement {
 	}
 
 	public String toSignatureString() {
+		return toSignatureString(true);
+	}
+
+	public String toSignatureString(boolean getFullyQualifiedArgTypes) {
 		StringBuffer sb = new StringBuffer();
 		sb.append(name);
 
 		if (parameterTypes != null ) {
 			sb.append('('); 
 			for (Iterator it = parameterTypes.iterator(); it.hasNext(); ) {
-				sb.append((String)it.next());
+				String arg = (String)it.next();
+				if (getFullyQualifiedArgTypes) {
+					sb.append(arg);
+				} else {
+					int index = arg.lastIndexOf(".");
+					if (index != -1) {
+						sb.append(arg.substring(index + 1));
+					} else {
+						sb.append(arg);
+					}
+				}
 				if (it.hasNext()) sb.append(", ");
 			}
 			sb.append(')');
 		}
 
-		return sb.toString();
+		return sb.toString();		
 	}
-
 
 	public static boolean shortITDNames = true;
 
@@ -409,6 +422,10 @@ public class ProgramElement implements IProgramElement {
 	 * TODO: move the "parent != null"==>injar heuristic to more explicit 
 	 */
 	public String toLinkLabelString() {
+		return toLinkLabelString(true);
+	}
+
+	public String toLinkLabelString(boolean getFullyQualifiedArgTypes) {
 		String label;
 		if (kind == Kind.CODE || kind == Kind.INITIALIZER) {
 			label = parent.getParent().getName() + ": ";
@@ -435,18 +452,22 @@ public class ProgramElement implements IProgramElement {
 				label = "injar aspect: ";  
 			}
 		}
-		label += toLabelString();
+		label += toLabelString(getFullyQualifiedArgTypes);
 		return label;
 	}
-
+	
 	public String toLabelString() {
-		String label = toSignatureString();
+		return toLabelString(true);
+	}
+
+	public String toLabelString(boolean getFullyQualifiedArgTypes) {
+		String label = toSignatureString(getFullyQualifiedArgTypes);
 		if (details != null) {
 			label += ": " + details;
 		} 
 		return label;
 	}
-
+	
 	private String handle = null;
 	public String getHandleIdentifier() {
 	    if (null == handle) {
@@ -293,7 +293,7 @@ public class AsmElementFormatter {
 		for (int i = 0; i < argArray.length; i++) {
 			String argName = new String(argArray[i].name);
 			String argType = argArray[i].type.resolvedType.debugName();
-			if (acceptArgument(argName, argType)) { 
+			if (acceptArgument(argName, argArray[i].type.toString())) { 
 				names.add(argName);
 				types.add(argType);
 			}   
@@ -0,0 +1,18 @@
+package pkg;
+
+import org.aspectj.lang.JoinPoint;
+
+public aspect A {
+
+	pointcut p() : within(C) && execution(* *(..));
+	
+	before() : p() {
+	}
+	
+	after(): execution(void printParameters(..)) {
+	}
+	
+	static private void printParameters(JoinPoint jp) {
+	}
+	
+}
@@ -0,0 +1,9 @@
+package pkg;
+
+public class C {
+
+	public void foo(int i, Object o) {
+		
+	}
+
+}
@@ -14,6 +14,9 @@ import java.io.File;
 
 import junit.framework.Test;
 
+import org.aspectj.asm.AsmManager;
+import org.aspectj.asm.IHierarchy;
+import org.aspectj.asm.IProgramElement;
 import org.aspectj.systemtest.ajc150.GenericsTests;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 
@@ -45,6 +48,27 @@ public class Ajc151Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	  GenericsTests.verifyClassSignature(ajc,"ConcreteAspect","LAbstractAspect<LStudent;>;");
   }
 
+  public void testIProgramElementMethods_pr125295() {
+	  runTest("new IProgramElement methods");  
+  	  IHierarchy top = AsmManager.getDefault().getHierarchy();
+
+  	  IProgramElement pe = top.findElementForType("pkg","foo");
+  	  assertNotNull("Couldn't find 'foo' element in the tree",pe);
+  	  // check that the defaults return the fully qualified arg
+  	  assertEquals("foo(int, java.lang.Object)",pe.toLabelString());
+  	  assertEquals("C.foo(int, java.lang.Object)",pe.toLinkLabelString());
+  	  assertEquals("foo(int, java.lang.Object)",pe.toSignatureString());
+  	  // check that can get hold of the non qualified args
+  	  assertEquals("foo(int, Object)",pe.toLabelString(false));
+  	  assertEquals("C.foo(int, Object)",pe.toLinkLabelString(false));
+  	  assertEquals("foo(int, Object)",pe.toSignatureString(false));
+
+  	  IProgramElement pe2 = top.findElementForType("pkg","printParameters");
+  	  assertNotNull("Couldn't find 'printParameters' element in the tree",pe2);
+  	  // the argument is org.aspectj.lang.JoinPoint, check that this is added
+  	  assertFalse("printParameters method should have arguments",pe2.getParameterTypes().isEmpty());	  
+  }
+  
   /////////////////////////////////////////
   public static Test suite() {
     return XMLBasedAjcTestCase.loadSuite(Ajc151Tests.class);
@@ -94,4 +94,8 @@
         <run class="ConcreteAspect"/>
     </ajc-test>
 
+    <ajc-test dir="bugs151/pr125295" title="new IProgramElement methods">
+        <compile files="pkg/C.java,pkg/A.aj" options="-emacssym"/>
+    </ajc-test>
+
 </suite>
\ No newline at end of file
