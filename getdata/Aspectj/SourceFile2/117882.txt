@@ -54,8 +54,10 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.aspectj.org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
+import org.aspectj.weaver.AnnotationX;
 import org.aspectj.weaver.AsmRelationshipProvider;
 import org.aspectj.weaver.ConcreteTypeMunger;
+import org.aspectj.weaver.FakeAnnotation;
 import org.aspectj.weaver.ReferenceType;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.TypeVariable;
@@ -726,6 +728,9 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		}
 		TypeBinding tb = factory.makeTypeBinding(aspectType);
 
+		
+		
+		
 		// TODO asc determine if there really is a problem here (see comment below)
 
 		// ClassCastException here means we probably have either a parameterized type or a raw type, we need the
@@ -739,6 +744,54 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		Annotation[] toAdd = methodDecl.annotations; // this is what to add
 		abits = toAdd[0].resolvedType.getAnnotationTagBits();
 
+		if (sourceType instanceof BinaryTypeBinding) {
+			// In this case we can't access the source type binding to add a new annotation, so let's put something
+			// on the weaver type temporarily
+			ResolvedType theTargetType = factory.fromEclipse(sourceType);
+			TypeBinding theAnnotationType = toAdd[0].resolvedType;
+			String name = new String(theAnnotationType.qualifiedPackageName())+"."+new String(theAnnotationType.sourceName());
+			String sig = new String(theAnnotationType.signature());
+			if (theTargetType.hasAnnotation(UnresolvedType.forSignature(sig))) {
+				CompilationAndWeavingContext.leavingPhase(tok);
+				return false;
+			}
+			
+			// FIXME asc tidy up this code that duplicates whats below!
+			// Simple checks on the bits
+			boolean giveupnow = false;
+			if (((abits & TagBits.AnnotationTargetMASK)!=0)) {
+				if ( isAnnotationTargettingSomethingOtherThanAnnotationOrNormal(abits)) {
+					// error will have been already reported
+					giveupnow = true;
+				} else if (  (sourceType.isAnnotationType() && (abits & TagBits.AnnotationForAnnotationType)==0) ||
+				      (!sourceType.isAnnotationType() && (abits & TagBits.AnnotationForType)==0) ) {
+				
+				  if (reportProblems) {
+				    if (decA.isExactPattern()) {
+				      factory.showMessage(IMessage.ERROR,
+						WeaverMessages.format(WeaverMessages.INCORRECT_TARGET_FOR_DECLARE_ANNOTATION,rtx.getName(),toAdd[0].type,stringifyTargets(abits)),
+						decA.getSourceLocation(), null);
+				    } 
+				    // dont put out the lint - the weaving process will do that
+//				    else {
+//					  if (factory.getWorld().getLint().invalidTargetForAnnotation.isEnabled()) {
+//						  factory.getWorld().getLint().invalidTargetForAnnotation.signal(new String[]{rtx.getName(),toAdd[0].type.toString(),stringifyTargets(abits)},decA.getSourceLocation(),null);
+//					  }
+//				    }
+				  }
+				  giveupnow=true;
+			    }
+			}
+			if (giveupnow) { 
+				CompilationAndWeavingContext.leavingPhase(tok);
+				return false;
+			}
+			
+			theTargetType.addAnnotation(new AnnotationX(new FakeAnnotation(name,sig,(abits & TagBits.AnnotationRuntimeRetention)!=0),factory.getWorld()));
+			CompilationAndWeavingContext.leavingPhase(tok);
+			return true;
+		}
+		
 		Annotation currentAnnotations[] = sourceType.scope.referenceContext.annotations;
 		if (currentAnnotations!=null) 
 		for (int i = 0; i < currentAnnotations.length; i++) {
@@ -797,6 +850,10 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		CompilationAndWeavingContext.leavingPhase(tok);
 		return true;
 	}
+
+	private boolean isAnnotationTargettingSomethingOtherThanAnnotationOrNormal(long abits) {
+		return (abits & (TagBits.AnnotationForAnnotationType | TagBits.AnnotationForType))==0;
+	}
 
 
 	private void reportDeclareParentsMessage(WeaveMessage.WeaveMessageKind wmk,SourceTypeBinding sourceType,ResolvedType parent) {
@@ -0,0 +1,81 @@
+/*******************************************************************************
+ * Copyright (c) 2005 Contributors.
+ * All rights reserved.
+ * This program and the accompanying materials are made available
+ * under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution and is available at
+ * http://eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ * initial implementation              Andy Clement
+ *******************************************************************************/
+package org.aspectj.weaver;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.List;
+
+import org.aspectj.apache.bcel.classfile.annotation.Annotation;
+import org.aspectj.apache.bcel.classfile.annotation.ElementNameValuePair;
+
+/**
+ * For implementing declare @type interacting with declare @parents during compilation - we need to be 
+ * able to add an annotation to 'binary type binding' (this is how types are seen during incremental compilation).
+ * Unlike a SourceTypeBinding - a BinaryTypeBinding does not allow easy interaction with its annotations - 
+ * so what we do is take the eclipse annotation, suck out the name/signature and visibility and put that information
+ * in a 'FakeAnnotation'.  The FakeAnnotation is attached to the BCEL delegate for the binary type binding -
+ * this will allow type resolution to succeed correctly.  The FakeAnnotation never makes it to disk, since the weaver
+ * does the job properly, attaching a real annotation.
+ */
+public class FakeAnnotation extends Annotation {
+
+	private String name;
+	private String sig;
+	private boolean isRuntimeVisible;
+	
+	public FakeAnnotation(String name,String sig,boolean isRuntimeVisible) {
+		super(0,null,true);
+		this.name = name;
+		this.sig = sig;
+		this.isRuntimeVisible = isRuntimeVisible;
+	}
+
+	public String getTypeName() {
+		return name;
+	}
+
+	public String getTypeSignature() {
+		return sig;
+	}
+
+	public void addElementNameValuePair(ElementNameValuePair evp) {
+		// doesnt need to know about name/value pairs
+	}
+
+	protected void dump(DataOutputStream dos) throws IOException {
+		// should be serialized
+	}
+
+	public int getTypeIndex() {
+		return 0;
+	}
+
+	public List getValues() {
+		return null;
+	}
+
+	public boolean isRuntimeVisible() {
+		return isRuntimeVisible;
+	}
+
+	protected void isRuntimeVisible(boolean b) {
+	}
+
+	public String toShortString() {
+		return "@"+this.name;
+	}
+
+	public String toString() {
+		return this.name;
+	}
+}
@@ -89,6 +89,10 @@ public class AjdeInteractionTestbed extends TestCase {
 		return AjdeManager.build(projectName,configFile);
 	}
 
+	public boolean fullBuild(String projectName,String configFile) {
+		return AjdeManager.fullBuild(projectName,configFile);
+	}
+	
 	/** Looks after communicating with the singleton Ajde instance */
 	public static class AjdeManager {
 
@@ -152,6 +156,48 @@ public class AjdeInteractionTestbed extends TestCase {
 			return true;
 		}
 
+		private static boolean fullBuild(String projectName,String configFile) {
+			pause(1000); // delay to allow previous runs build stamps to be OK
+			lognoln("Building project '"+projectName+"'");
+			
+			// Ajde.getDefault().enableLogging(System.out);
+			
+			//Ajde.getDefault().getBuildManager().setReportInfoMessages(true); 
+			
+			// Configure the necessary providers and listeners for this compile
+			MyBuildProgressMonitor.reset();
+			MyTaskListManager.reset();
+			MyStateListener.reset();
+			
+			MyProjectPropertiesAdapter.setActiveProject(projectName);
+			//AsmManager.attemptIncrementalModelRepairs=true;
+			//IncrementalStateManager.recordIncrementalStates=true;
+			
+			Ajde.getDefault().getBuildManager().setBuildModelMode(buildModel);
+			
+			// Do the compile
+			Ajde.getDefault().getBuildManager().buildFresh(getFile(projectName,configFile));
+			
+			// Wait for it to complete
+			while (!MyBuildProgressMonitor.hasFinished()) {
+				lognoln(".");
+				pause(100);
+			} 
+			log("");
+		    
+			// What happened?
+			if (MyTaskListManager.hasErrorMessages()) {
+				System.err.println("Build errors:");
+				for (Iterator iter = MyTaskListManager.getErrorMessages().iterator(); iter.hasNext();) {
+					IMessage element = (IMessage) iter.next();
+					System.err.println(element);
+				}
+				System.err.println("---------");
+			}
+			log("Build finished, time taken = "+MyBuildProgressMonitor.getTimeTaken()+"ms");
+			return true;
+		}
+		
 		private static void pause(int millis) {
 			try {
 				Thread.sleep(millis);
@@ -640,7 +686,10 @@ public class AjdeInteractionTestbed extends TestCase {
 		}
 
 		public Map getJavaOptionsMap() {
-			return null;
+			Hashtable ht = new Hashtable();
+			ht.put("org.eclipse.jdt.core.compiler.compliance","1.5");
+			ht.put("org.eclipse.jdt.core.compiler.codegen.targetPlatform","1.5");
+			return ht;
 		}
 
 		public boolean getUseJavacMode() {
@@ -313,6 +313,35 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		checkWasntFullBuild();
 	}
 
+	public void testPr117882() {
+//		AjdeInteractionTestbed.VERBOSE=true;
+//		AjdeInteractionTestbed.configureBuildStructureModel(true);
+		initialiseProject("PR117882");
+		build("PR117882");
+		checkWasFullBuild();
+		alter("PR117882","inc1");
+		build("PR117882");
+		checkWasntFullBuild();
+//		AjdeInteractionTestbed.VERBOSE=false;
+//		AjdeInteractionTestbed.configureBuildStructureModel(false);
+	}
+	
+	public void testPr117882_2() {
+//		AjdeInteractionTestbed.VERBOSE=true;
+//		AjdeInteractionTestbed.configureBuildStructureModel(true);
+		initialiseProject("PR117882_2");
+		build("PR117882_2");
+		checkWasFullBuild();
+		alter("PR117882_2","inc1");
+		build("PR117882_2");
+		checkWasntFullBuild();
+		checkCompileWeaveCount(1,4);
+		//fullBuild("PR117882_2");
+		//checkWasFullBuild();
+//		AjdeInteractionTestbed.VERBOSE=false;
+//		AjdeInteractionTestbed.configureBuildStructureModel(false);
+	}
+	
 	public void testPr115251() {
 		//AjdeInteractionTestbed.VERBOSE=true;
 		initialiseProject("PR115251");
@@ -454,7 +483,11 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		if (AjdeInteractionTestbed.VERBOSE) printBuildReport();
 	}
 
-	
+	public void fullBuild(String projectName) {
+		constructUpToDateLstFile(projectName,"build.lst");
+		fullBuild(projectName,"build.lst");
+		if (AjdeInteractionTestbed.VERBOSE) printBuildReport();
+	}
 
 	private void constructUpToDateLstFile(String pname,String configname) {
 		File projectBase = new File(sandboxDir,pname);
@@ -0,0 +1,7 @@
+package pack;
+
+public aspect A {
+
+	declare @type : C : @Annotation;
+	
+}
@@ -0,0 +1,5 @@
+package pack;
+
+public @interface Annotation {
+	
+}
@@ -0,0 +1,7 @@
+package pack;
+
+public class C {
+
+	public void amethod() {}
+	
+}
@@ -0,0 +1,7 @@
+package pack;
+//comment
+public aspect A {
+
+	declare @type : C : @Annotation;
+	
+}
@@ -0,0 +1,7 @@
+package pack;
+
+public aspect A {
+
+	declare @type : C : @Annotation;
+	
+}
@@ -0,0 +1,8 @@
+package pack;
+
+import java.lang.annotation.*;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Annotation {
+	
+}
@@ -0,0 +1,5 @@
+package pack;
+
+public class C {
+	
+}
@@ -0,0 +1,7 @@
+package pack;
+
+public interface I {
+
+	public void method();
+	
+}
@@ -0,0 +1,18 @@
+package pack;
+
+public aspect A {
+
+	declare @type : C : @Annotation;
+	
+	declare parents : (@Annotation *) implements I;
+	
+	public void I.method() {
+	}
+	
+	public static void main(String []argv) {
+		new C().method();
+          if (C.class.getAnnotation(pack.Annotation.class)==null) 
+            throw new RuntimeException("Class C should have @Annotation on it");
+	}
+
+}
Binary files differ
Binary files differ
@@ -88,12 +88,12 @@ public class Annotation {
 		return typeIndex;
 	}
 
-	public final String getTypeSignature() {
+	public String getTypeSignature() {
 	  ConstantUtf8 c = (ConstantUtf8)cpool.getConstant(typeIndex,Constants.CONSTANT_Utf8);
 	  return c.getBytes();
 	}
 
-	public final String getTypeName() {
+	public String getTypeName() {
 		ConstantUtf8 c = (ConstantUtf8)cpool.getConstant(typeIndex,Constants.CONSTANT_Utf8);
 		return Utility.signatureToString(c.getBytes());
 	}
