@@ -103,7 +103,7 @@ public class Aj implements ClassPreProcessor {
                 	} else {
 	                    // create it and put it back in the weavingAdaptors map but avoid any kind of instantiation
 	                    // within the synchronized block
-	                    ClassLoaderWeavingAdaptor weavingAdaptor = new ClassLoaderWeavingAdaptor(loader, weavingContext);
+	                    ClassLoaderWeavingAdaptor weavingAdaptor = new ClassLoaderWeavingAdaptor();
 	                    adaptor = new ExplicitlyInitializedClassLoaderWeavingAdaptor(weavingAdaptor);
 	                    weavingAdaptors.put(loader, adaptor);
                 	}
@@ -71,23 +71,35 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
     private List m_aspectIncludeStartsWith = new ArrayList();
 
     private StringBuffer namespace;
-    private ClassLoader classLoader;
     private IWeavingContext weavingContext;
 
 	private static Trace trace = TraceFactory.getTraceFactory().getTrace(ClassLoaderWeavingAdaptor.class);
 
-    public ClassLoaderWeavingAdaptor(final ClassLoader loader, IWeavingContext wContext) {
+    public ClassLoaderWeavingAdaptor() {
     	super();
     	if (trace.isTraceEnabled()) trace.enter("<init>",this);
-    	this.classLoader = loader;
-    	this.weavingContext = wContext;
+    	if (trace.isTraceEnabled()) trace.exit("<init>");
+    }
+    
+    /**
+     * We don't need a reference to the class loader and using it during 
+     * construction can cause problems with recursion. It also makes sense
+     * to supply the weaving context during initialization to. 
+     * @deprecated
+     */
+    public ClassLoaderWeavingAdaptor(final ClassLoader deprecatedLoader, final IWeavingContext deprecatedContext) {
+    	super();
+    	if (trace.isTraceEnabled()) trace.enter("<init>",this,new Object[] { deprecatedLoader, deprecatedContext });
     	if (trace.isTraceEnabled()) trace.exit("<init>");
     }
 
-    protected void initialize (final ClassLoader deprecatedLoader, IWeavingContext deprecatedContext) {
+    protected void initialize (final ClassLoader classLoader, IWeavingContext context) {
         //super(null);// at this stage we don't have yet a generatedClassHandler to define to the VM the closures
     	if (initialized) return;
 
+    	if (trace.isTraceEnabled()) trace.enter("initialize",this,new Object[] { classLoader, context });
+
+    	this.weavingContext = context;
         if (weavingContext == null) {
         	weavingContext = new DefaultWeavingContext(classLoader);
         }
@@ -116,6 +128,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 
         List definitions = parseDefinitions(classLoader);
         if (!enabled) {
+        	if (trace.isTraceEnabled()) trace.exit("initialize",enabled);
         	return;
         }
 
@@ -149,6 +162,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
         }
 
         initialized = true;
+    	if (trace.isTraceEnabled()) trace.exit("initialize",enabled);
     }
 
     /**
@@ -115,7 +115,7 @@ public class WeavingURLClassLoader extends ExtensibleURLClassLoader implements W
 
 				};
 
-				ClassLoaderWeavingAdaptor clwAdaptor = new ClassLoaderWeavingAdaptor(this,weavingContext);
+				ClassLoaderWeavingAdaptor clwAdaptor = new ClassLoaderWeavingAdaptor();
 				initializingAdaptor = true;
 				clwAdaptor.initialize(this,weavingContext);
 				initializingAdaptor = false;
@@ -19,26 +19,30 @@ public class ClassLoaderWeavingAdaptorTest extends TestCase {
 
 	public void testClassLoaderWeavingAdaptor() {
 		ClassLoader loader = new URLClassLoader(new URL[] {}, null);
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,null);
 	}
 
 	public void testGetNamespace() {
 		ClassLoader loader = new URLClassLoader(new URL[] {}, null);
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,null);
 		String namespace = adaptor.getNamespace();
 		assertEquals("Namespace should be empty","",namespace);
 	}
 
 	public void testGeneratedClassesExistFor() {
 		ClassLoader loader = new URLClassLoader(new URL[] {}, null);
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,null);
 		boolean exist = adaptor.generatedClassesExistFor("Junk");
 		assertFalse("There should be no generated classes",exist);
 	}
 
 	public void testFlushGeneratedClasses() {
 		ClassLoader loader = new URLClassLoader(new URL[] {}, null);
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,null);
 		adaptor.flushGeneratedClasses();
 		boolean exist = adaptor.generatedClassesExistFor("Junk");
 		assertFalse("There should be no generated classes",exist);
@@ -25,7 +25,8 @@ public class WeavingContextTest extends TestCase {
 	public void testWeavingContext() {
 		URLClassLoader loader = new URLClassLoader(new URL[] {},null);
 		IWeavingContext context = new TestWeavingContext(loader);
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,context);
 	}
 
 	public void testGetResources() {
@@ -38,8 +39,8 @@ public class WeavingContextTest extends TestCase {
 			}
 
 		};
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
-		adaptor.initialize(null,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,context);
 
 		assertTrue("IWeavingContext not called",called);
 	}
@@ -53,9 +54,9 @@ public class WeavingContextTest extends TestCase {
 			}
 
 		};
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
 		try {
-			adaptor.initialize(null,null);
+			adaptor.initialize(loader,context);
 		}
 		catch (UnsupportedOperationException ex) {
 			fail("IWeavingContect.getBundleIdFromURL() is deprecated");
@@ -72,8 +73,8 @@ public class WeavingContextTest extends TestCase {
 			}
 
 		};
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
-		adaptor.initialize(null,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,context);
 
 		assertTrue("IWeavingContext not called",called);
 	}
@@ -90,8 +91,8 @@ public class WeavingContextTest extends TestCase {
 			}
 
 		};
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
-		adaptor.initialize(null,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,context);
 
 		assertTrue("IWeavingContext not called",called);
 	}
@@ -108,8 +109,8 @@ public class WeavingContextTest extends TestCase {
 			}
 
 		};
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
-		adaptor.initialize(null,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,context);
 
 		assertTrue("IWeavingContext not called",called);
 	}
@@ -79,7 +79,6 @@ public class WeavingAdaptor {
 	protected Map generatedClasses = new HashMap(); /* String -> UnwovenClassFile */
 
 	protected WeavingAdaptor () {
-		createMessageHandler();
 	}
 
 
@@ -162,7 +161,7 @@ public class WeavingAdaptor {
 		registerAspectLibraries(aspectPath);
 	}
 
-	private void createMessageHandler() {
+	protected void createMessageHandler() {
 		messageHolder = new WeavingAdaptorMessageHandler(new PrintWriter(System.err));
 		messageHandler = messageHolder;
 		if (verbose) messageHandler.dontIgnore(IMessage.INFO);
@@ -360,6 +359,10 @@ public class WeavingAdaptor {
 	protected boolean error (String message) {
 		return MessageUtil.error(messageHandler,message);
 	}
+	
+	protected String getContextId () {
+		return "WeavingAdaptor";
+	}
 
 	/**
 	 * Dump the given bytcode in _dump/... (dev mode)
@@ -458,6 +461,10 @@ public class WeavingAdaptor {
 			accumulating = false;
 			messages.clear();
 		}
+
+	    protected String render(IMessage message) {
+	    	return "[" + getContextId() + "] " + super.render(message);
+	    }
 	}
 
 	private class WeavingClassFileProvider implements IClassFileProvider {
@@ -55,6 +55,8 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 
     private final static String AOP_XML = "META-INF/aop.xml";
 
+    private boolean initialized;
+    
     private List m_dumpTypePattern = new ArrayList();
     private boolean m_dumpBefore = false;
     private List m_includeTypePattern = new ArrayList();
@@ -67,14 +69,25 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
     private List m_aspectIncludeStartsWith = new ArrayList();
 
     private StringBuffer namespace;
+    private ClassLoader classLoader;
     private IWeavingContext weavingContext;
 
     public ClassLoaderWeavingAdaptor(final ClassLoader loader, IWeavingContext wContext) {
+    	super();
+    	this.classLoader = loader;
     	this.weavingContext = wContext;
     }
 
-    protected void initialize(final ClassLoader loader, IWeavingContext wContext) {
+    protected void initialize (final ClassLoader deprecatedLoader, IWeavingContext deprecatedContext) {
         //super(null);// at this stage we don't have yet a generatedClassHandler to define to the VM the closures
+    	if (initialized) return;
+
+        if (weavingContext == null) {
+        	weavingContext = new DefaultWeavingContext(classLoader);
+        }
+
+        createMessageHandler();
+    	
         this.generatedClassHandler = new GeneratedClassHandler() {
             /**
              * Callback when we need to define a Closure in the JVM
@@ -91,23 +104,17 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
                     throwable.printStackTrace();
                 }
 
-                defineClass(loader, name, bytes);// could be done lazily using the hook
+                defineClass(classLoader, name, bytes);// could be done lazily using the hook
             }
         };
 
-        if(wContext==null){
-        	weavingContext = new DefaultWeavingContext(loader);
-        }else{
-        	weavingContext = wContext ;
-        }
-
-        List definitions = parseDefinitions(loader);
+        List definitions = parseDefinitions(classLoader);
         if (!enabled) {
         	return;
         }
 
         bcelWorld = new LTWWorld(
-                loader, getMessageHandler(), new ICrossReferenceHandler() {
+                classLoader, getMessageHandler(), new ICrossReferenceHandler() {
                     public void addCrossReference(ISourceLocation from, ISourceLocation to, IRelationship.Kind kind, boolean runtimeTest) {
                         ;// for tools only
                     }
@@ -122,7 +129,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
         weaver = new BcelWeaver(bcelWorld);
 
         // register the definitions
-        registerDefinitions(weaver, loader, definitions);
+        registerDefinitions(weaver, classLoader, definitions);
         if (enabled) {
 
             //bcelWorld.setResolutionLoader(loader.getParent());//(ClassLoader)null);//
@@ -134,6 +141,8 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
         	bcelWorld = null;
         	weaver = null;
         }
+        
+        initialized = true;
     }
 
     /**
@@ -312,6 +321,10 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
     	Kind kind = lint.getLintKind(name);
     	kind.signal(infos,null,null);
     }
+	
+	protected String getContextId () {
+		return weavingContext.getId();
+	}
 
     /**
      * Register the aspect, following include / exclude rules
@@ -23,6 +23,8 @@ import java.util.Enumeration;
 public class DefaultWeavingContext implements IWeavingContext {
 
 	protected ClassLoader loader;
+	
+	private String shortName;
 
 	/**
 	 * Construct a new WeavingContext to use the specifed ClassLoader
@@ -60,4 +62,20 @@ public class DefaultWeavingContext implements IWeavingContext {
 	public String getFile(URL url) {
     	return url.getFile();
 	}
+
+	/**
+	 * @return unqualifiedclassname@hashcode 
+	 */
+	public String getId () {
+		if (shortName == null) {
+			shortName = getClassLoaderName();
+			int index = shortName.lastIndexOf(".");
+			shortName = shortName.substring(index + 1);
+		}
+		return shortName;
+	}
+	
+	public String getSuffix () {
+		return getClassLoaderName();
+	}
 }
@@ -39,12 +39,13 @@ public interface IWeavingContext {
 	 * In a non-OSGi environment, implementors should return <code>null<code>.
 	 * @param url
 	 * @return
+	 * @deprecated use getFile() or getClassLoaderName()
 	 */
 	public String getBundleIdFromURL(URL url);
 
 	/**
 	 * In an environment with multiple class loaders allows each to be
-	 * identified using something safer and than toString
+	 * identified using something safer and possibly shorter than toString
 	 * @return name of the associated class loader
 	 */
 	public String getClassLoaderName ();
@@ -54,5 +55,12 @@ public interface IWeavingContext {
 	 * @return filename
 	 */
 	public String getFile(URL url);
+	
+	/**
+	 * In an environment with multiple class loaders allows messages
+	 * to identified according to the weaving context
+	 * @return short name 
+	 */
+	public String getId ();
 
 }
@@ -0,0 +1,3 @@
+<aspectj>
+	<weaver options="-verbose"/>
+</aspectj>
\ No newline at end of file
@@ -0,0 +1,153 @@
+/*******************************************************************************
+ * Copyright (c) 2006 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     Matthew Webster - initial implementation
+ *******************************************************************************/
+package org.aspectj.weaver.loadtime;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.util.Enumeration;
+
+import junit.framework.TestCase;
+
+public class WeavingContextTest extends TestCase {
+
+	private boolean called;
+	
+	public void testWeavingContext() {
+		URLClassLoader loader = new URLClassLoader(new URL[] {},null);
+		IWeavingContext context = new TestWeavingContext(loader);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+	}
+
+	public void testGetResources() {
+		URLClassLoader loader = new URLClassLoader(new URL[] {},null);
+		IWeavingContext context = new TestWeavingContext(loader) {
+
+			public Enumeration getResources(String name) throws IOException {
+				called = true;
+				return super.getResources(name);
+			}
+			
+		};
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+		adaptor.initialize(null,null);
+		
+		assertTrue("IWeavingContext not called",called);
+	}
+
+	public void testGetBundleIdFromURL() {
+		URLClassLoader loader = new URLClassLoader(new URL[] {},null);
+		IWeavingContext context = new TestWeavingContext(loader) {
+
+			public String getBundleIdFromURL(URL url) {
+				throw new UnsupportedOperationException();
+			}
+			
+		};
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+		try {
+			adaptor.initialize(null,null);
+		}
+		catch (UnsupportedOperationException ex) {
+			fail("IWeavingContect.getBundleIdFromURL() is deprecated");
+		}
+	}
+
+	public void testGetClassLoaderName() {
+		URLClassLoader loader = new URLClassLoader(new URL[] {},null);
+		IWeavingContext context = new TestWeavingContext(loader) {
+
+			public String getClassLoaderName () {
+				called = true;
+				return super.getClassLoaderName();
+			}
+			
+		};
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+		adaptor.initialize(null,null);
+		
+		assertTrue("IWeavingContext not called",called);
+	}
+
+	public void testGetFile() throws IOException {
+		File file = new File("../loadtime/testdata");
+		URL fileURL = file.getCanonicalFile().toURL();
+		URLClassLoader loader = new URLClassLoader(new URL[] { fileURL },null);
+		IWeavingContext context = new TestWeavingContext(loader) {
+
+			public String getFile (URL url) {
+				called = true;
+				return super.getFile(url);
+			}
+			
+		};
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+		adaptor.initialize(null,null);
+		
+		assertTrue("IWeavingContext not called",called);
+	}
+
+	public void testGetId() throws IOException {
+		File file = new File("../loadtime/testdata");
+		URL fileURL = file.getCanonicalFile().toURL();
+		URLClassLoader loader = new URLClassLoader(new URL[] { fileURL },null);
+		IWeavingContext context = new TestWeavingContext(loader) {
+
+			public String getId () {
+				called = true;
+				return super.getId();
+			}
+			
+		};
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+		adaptor.initialize(null,null);
+		
+		assertTrue("IWeavingContext not called",called);
+	}
+
+	private static class TestWeavingContext implements IWeavingContext {
+
+		private ClassLoader loader;
+		
+		public TestWeavingContext (ClassLoader classLoader) {
+			this.loader = classLoader;
+		}
+		
+		public String getBundleIdFromURL(URL url) {
+			return null;
+		}
+
+		public String getClassLoaderName() {
+			return "ClassLoaderName";
+		}
+
+		public String getFile(URL url) {
+			return "File";
+		}
+
+		public String getId() {
+			return "Id";
+		}
+
+		public Enumeration getResources(String name) throws IOException {
+			return loader.getResources(name);
+		}
+		
+	}
+
+	protected void setUp() throws Exception {
+		super.setUp();
+
+		this.called = false;
+	}
+	
+}
@@ -103,7 +103,7 @@ public class Aj implements ClassPreProcessor {
                 	} else {
 	                    // create it and put it back in the weavingAdaptors map but avoid any kind of instantiation
 	                    // within the synchronized block
-	                    ClassLoaderWeavingAdaptor weavingAdaptor = new ClassLoaderWeavingAdaptor(loader, weavingContext);
+	                    ClassLoaderWeavingAdaptor weavingAdaptor = new ClassLoaderWeavingAdaptor();
 	                    adaptor = new ExplicitlyInitializedClassLoaderWeavingAdaptor(weavingAdaptor);
 	                    weavingAdaptors.put(loader, adaptor);
                 	}
@@ -71,23 +71,35 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
     private List m_aspectIncludeStartsWith = new ArrayList();
 
     private StringBuffer namespace;
-    private ClassLoader classLoader;
     private IWeavingContext weavingContext;
 
 	private static Trace trace = TraceFactory.getTraceFactory().getTrace(ClassLoaderWeavingAdaptor.class);
 
-    public ClassLoaderWeavingAdaptor(final ClassLoader loader, IWeavingContext wContext) {
+    public ClassLoaderWeavingAdaptor() {
     	super();
     	if (trace.isTraceEnabled()) trace.enter("<init>",this);
-    	this.classLoader = loader;
-    	this.weavingContext = wContext;
+    	if (trace.isTraceEnabled()) trace.exit("<init>");
+    }
+    
+    /**
+     * We don't need a reference to the class loader and using it during 
+     * construction can cause problems with recursion. It also makes sense
+     * to supply the weaving context during initialization to. 
+     * @deprecated
+     */
+    public ClassLoaderWeavingAdaptor(final ClassLoader deprecatedLoader, final IWeavingContext deprecatedContext) {
+    	super();
+    	if (trace.isTraceEnabled()) trace.enter("<init>",this,new Object[] { deprecatedLoader, deprecatedContext });
     	if (trace.isTraceEnabled()) trace.exit("<init>");
     }
 
-    protected void initialize (final ClassLoader deprecatedLoader, IWeavingContext deprecatedContext) {
+    protected void initialize (final ClassLoader classLoader, IWeavingContext context) {
         //super(null);// at this stage we don't have yet a generatedClassHandler to define to the VM the closures
     	if (initialized) return;
 
+    	if (trace.isTraceEnabled()) trace.enter("initialize",this,new Object[] { classLoader, context });
+
+    	this.weavingContext = context;
         if (weavingContext == null) {
         	weavingContext = new DefaultWeavingContext(classLoader);
         }
@@ -116,6 +128,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 
         List definitions = parseDefinitions(classLoader);
         if (!enabled) {
+        	if (trace.isTraceEnabled()) trace.exit("initialize",enabled);
         	return;
         }
 
@@ -149,6 +162,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
         }
 
         initialized = true;
+    	if (trace.isTraceEnabled()) trace.exit("initialize",enabled);
     }
 
     /**
@@ -115,7 +115,7 @@ public class WeavingURLClassLoader extends ExtensibleURLClassLoader implements W
 
 				};
 
-				ClassLoaderWeavingAdaptor clwAdaptor = new ClassLoaderWeavingAdaptor(this,weavingContext);
+				ClassLoaderWeavingAdaptor clwAdaptor = new ClassLoaderWeavingAdaptor();
 				initializingAdaptor = true;
 				clwAdaptor.initialize(this,weavingContext);
 				initializingAdaptor = false;
@@ -19,26 +19,30 @@ public class ClassLoaderWeavingAdaptorTest extends TestCase {
 
 	public void testClassLoaderWeavingAdaptor() {
 		ClassLoader loader = new URLClassLoader(new URL[] {}, null);
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,null);
 	}
 
 	public void testGetNamespace() {
 		ClassLoader loader = new URLClassLoader(new URL[] {}, null);
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,null);
 		String namespace = adaptor.getNamespace();
 		assertEquals("Namespace should be empty","",namespace);
 	}
 
 	public void testGeneratedClassesExistFor() {
 		ClassLoader loader = new URLClassLoader(new URL[] {}, null);
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,null);
 		boolean exist = adaptor.generatedClassesExistFor("Junk");
 		assertFalse("There should be no generated classes",exist);
 	}
 
 	public void testFlushGeneratedClasses() {
 		ClassLoader loader = new URLClassLoader(new URL[] {}, null);
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,null);
 		adaptor.flushGeneratedClasses();
 		boolean exist = adaptor.generatedClassesExistFor("Junk");
 		assertFalse("There should be no generated classes",exist);
@@ -25,7 +25,8 @@ public class WeavingContextTest extends TestCase {
 	public void testWeavingContext() {
 		URLClassLoader loader = new URLClassLoader(new URL[] {},null);
 		IWeavingContext context = new TestWeavingContext(loader);
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,context);
 	}
 
 	public void testGetResources() {
@@ -38,8 +39,8 @@ public class WeavingContextTest extends TestCase {
 			}
 
 		};
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
-		adaptor.initialize(null,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,context);
 
 		assertTrue("IWeavingContext not called",called);
 	}
@@ -53,9 +54,9 @@ public class WeavingContextTest extends TestCase {
 			}
 
 		};
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
 		try {
-			adaptor.initialize(null,null);
+			adaptor.initialize(loader,context);
 		}
 		catch (UnsupportedOperationException ex) {
 			fail("IWeavingContect.getBundleIdFromURL() is deprecated");
@@ -72,8 +73,8 @@ public class WeavingContextTest extends TestCase {
 			}
 
 		};
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
-		adaptor.initialize(null,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,context);
 
 		assertTrue("IWeavingContext not called",called);
 	}
@@ -90,8 +91,8 @@ public class WeavingContextTest extends TestCase {
 			}
 
 		};
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
-		adaptor.initialize(null,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,context);
 
 		assertTrue("IWeavingContext not called",called);
 	}
@@ -108,8 +109,8 @@ public class WeavingContextTest extends TestCase {
 			}
 
 		};
-		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
-		adaptor.initialize(null,null);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
+		adaptor.initialize(loader,context);
 
 		assertTrue("IWeavingContext not called",called);
 	}
@@ -79,7 +79,6 @@ public class WeavingAdaptor {
 	protected Map generatedClasses = new HashMap(); /* String -> UnwovenClassFile */
 
 	protected WeavingAdaptor () {
-		createMessageHandler();
 	}
 
 
@@ -162,7 +161,7 @@ public class WeavingAdaptor {
 		registerAspectLibraries(aspectPath);
 	}
 
-	private void createMessageHandler() {
+	protected void createMessageHandler() {
 		messageHolder = new WeavingAdaptorMessageHandler(new PrintWriter(System.err));
 		messageHandler = messageHolder;
 		if (verbose) messageHandler.dontIgnore(IMessage.INFO);
@@ -360,6 +359,10 @@ public class WeavingAdaptor {
 	protected boolean error (String message) {
 		return MessageUtil.error(messageHandler,message);
 	}
+	
+	protected String getContextId () {
+		return "WeavingAdaptor";
+	}
 
 	/**
 	 * Dump the given bytcode in _dump/... (dev mode)
@@ -458,6 +461,10 @@ public class WeavingAdaptor {
 			accumulating = false;
 			messages.clear();
 		}
+
+	    protected String render(IMessage message) {
+	    	return "[" + getContextId() + "] " + super.render(message);
+	    }
 	}
 
 	private class WeavingClassFileProvider implements IClassFileProvider {
@@ -55,6 +55,8 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
 
     private final static String AOP_XML = "META-INF/aop.xml";
 
+    private boolean initialized;
+    
     private List m_dumpTypePattern = new ArrayList();
     private boolean m_dumpBefore = false;
     private List m_includeTypePattern = new ArrayList();
@@ -67,14 +69,25 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
     private List m_aspectIncludeStartsWith = new ArrayList();
 
     private StringBuffer namespace;
+    private ClassLoader classLoader;
     private IWeavingContext weavingContext;
 
     public ClassLoaderWeavingAdaptor(final ClassLoader loader, IWeavingContext wContext) {
+    	super();
+    	this.classLoader = loader;
     	this.weavingContext = wContext;
     }
 
-    protected void initialize(final ClassLoader loader, IWeavingContext wContext) {
+    protected void initialize (final ClassLoader deprecatedLoader, IWeavingContext deprecatedContext) {
         //super(null);// at this stage we don't have yet a generatedClassHandler to define to the VM the closures
+    	if (initialized) return;
+
+        if (weavingContext == null) {
+        	weavingContext = new DefaultWeavingContext(classLoader);
+        }
+
+        createMessageHandler();
+    	
         this.generatedClassHandler = new GeneratedClassHandler() {
             /**
              * Callback when we need to define a Closure in the JVM
@@ -91,23 +104,17 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
                     throwable.printStackTrace();
                 }
 
-                defineClass(loader, name, bytes);// could be done lazily using the hook
+                defineClass(classLoader, name, bytes);// could be done lazily using the hook
             }
         };
 
-        if(wContext==null){
-        	weavingContext = new DefaultWeavingContext(loader);
-        }else{
-        	weavingContext = wContext ;
-        }
-
-        List definitions = parseDefinitions(loader);
+        List definitions = parseDefinitions(classLoader);
         if (!enabled) {
         	return;
         }
 
         bcelWorld = new LTWWorld(
-                loader, getMessageHandler(), new ICrossReferenceHandler() {
+                classLoader, getMessageHandler(), new ICrossReferenceHandler() {
                     public void addCrossReference(ISourceLocation from, ISourceLocation to, IRelationship.Kind kind, boolean runtimeTest) {
                         ;// for tools only
                     }
@@ -122,7 +129,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
         weaver = new BcelWeaver(bcelWorld);
 
         // register the definitions
-        registerDefinitions(weaver, loader, definitions);
+        registerDefinitions(weaver, classLoader, definitions);
         if (enabled) {
 
             //bcelWorld.setResolutionLoader(loader.getParent());//(ClassLoader)null);//
@@ -134,6 +141,8 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
         	bcelWorld = null;
         	weaver = null;
         }
+        
+        initialized = true;
     }
 
     /**
@@ -312,6 +321,10 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
     	Kind kind = lint.getLintKind(name);
     	kind.signal(infos,null,null);
     }
+	
+	protected String getContextId () {
+		return weavingContext.getId();
+	}
 
     /**
      * Register the aspect, following include / exclude rules
@@ -23,6 +23,8 @@ import java.util.Enumeration;
 public class DefaultWeavingContext implements IWeavingContext {
 
 	protected ClassLoader loader;
+	
+	private String shortName;
 
 	/**
 	 * Construct a new WeavingContext to use the specifed ClassLoader
@@ -60,4 +62,20 @@ public class DefaultWeavingContext implements IWeavingContext {
 	public String getFile(URL url) {
     	return url.getFile();
 	}
+
+	/**
+	 * @return unqualifiedclassname@hashcode 
+	 */
+	public String getId () {
+		if (shortName == null) {
+			shortName = getClassLoaderName();
+			int index = shortName.lastIndexOf(".");
+			shortName = shortName.substring(index + 1);
+		}
+		return shortName;
+	}
+	
+	public String getSuffix () {
+		return getClassLoaderName();
+	}
 }
@@ -39,12 +39,13 @@ public interface IWeavingContext {
 	 * In a non-OSGi environment, implementors should return <code>null<code>.
 	 * @param url
 	 * @return
+	 * @deprecated use getFile() or getClassLoaderName()
 	 */
 	public String getBundleIdFromURL(URL url);
 
 	/**
 	 * In an environment with multiple class loaders allows each to be
-	 * identified using something safer and than toString
+	 * identified using something safer and possibly shorter than toString
 	 * @return name of the associated class loader
 	 */
 	public String getClassLoaderName ();
@@ -54,5 +55,12 @@ public interface IWeavingContext {
 	 * @return filename
 	 */
 	public String getFile(URL url);
+	
+	/**
+	 * In an environment with multiple class loaders allows messages
+	 * to identified according to the weaving context
+	 * @return short name 
+	 */
+	public String getId ();
 
 }
@@ -0,0 +1,3 @@
+<aspectj>
+	<weaver options="-verbose"/>
+</aspectj>
\ No newline at end of file
@@ -0,0 +1,153 @@
+/*******************************************************************************
+ * Copyright (c) 2006 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     Matthew Webster - initial implementation
+ *******************************************************************************/
+package org.aspectj.weaver.loadtime;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.util.Enumeration;
+
+import junit.framework.TestCase;
+
+public class WeavingContextTest extends TestCase {
+
+	private boolean called;
+	
+	public void testWeavingContext() {
+		URLClassLoader loader = new URLClassLoader(new URL[] {},null);
+		IWeavingContext context = new TestWeavingContext(loader);
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+	}
+
+	public void testGetResources() {
+		URLClassLoader loader = new URLClassLoader(new URL[] {},null);
+		IWeavingContext context = new TestWeavingContext(loader) {
+
+			public Enumeration getResources(String name) throws IOException {
+				called = true;
+				return super.getResources(name);
+			}
+			
+		};
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+		adaptor.initialize(null,null);
+		
+		assertTrue("IWeavingContext not called",called);
+	}
+
+	public void testGetBundleIdFromURL() {
+		URLClassLoader loader = new URLClassLoader(new URL[] {},null);
+		IWeavingContext context = new TestWeavingContext(loader) {
+
+			public String getBundleIdFromURL(URL url) {
+				throw new UnsupportedOperationException();
+			}
+			
+		};
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+		try {
+			adaptor.initialize(null,null);
+		}
+		catch (UnsupportedOperationException ex) {
+			fail("IWeavingContect.getBundleIdFromURL() is deprecated");
+		}
+	}
+
+	public void testGetClassLoaderName() {
+		URLClassLoader loader = new URLClassLoader(new URL[] {},null);
+		IWeavingContext context = new TestWeavingContext(loader) {
+
+			public String getClassLoaderName () {
+				called = true;
+				return super.getClassLoaderName();
+			}
+			
+		};
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+		adaptor.initialize(null,null);
+		
+		assertTrue("IWeavingContext not called",called);
+	}
+
+	public void testGetFile() throws IOException {
+		File file = new File("../loadtime/testdata");
+		URL fileURL = file.getCanonicalFile().toURL();
+		URLClassLoader loader = new URLClassLoader(new URL[] { fileURL },null);
+		IWeavingContext context = new TestWeavingContext(loader) {
+
+			public String getFile (URL url) {
+				called = true;
+				return super.getFile(url);
+			}
+			
+		};
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+		adaptor.initialize(null,null);
+		
+		assertTrue("IWeavingContext not called",called);
+	}
+
+	public void testGetId() throws IOException {
+		File file = new File("../loadtime/testdata");
+		URL fileURL = file.getCanonicalFile().toURL();
+		URLClassLoader loader = new URLClassLoader(new URL[] { fileURL },null);
+		IWeavingContext context = new TestWeavingContext(loader) {
+
+			public String getId () {
+				called = true;
+				return super.getId();
+			}
+			
+		};
+		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor(loader,context);
+		adaptor.initialize(null,null);
+		
+		assertTrue("IWeavingContext not called",called);
+	}
+
+	private static class TestWeavingContext implements IWeavingContext {
+
+		private ClassLoader loader;
+		
+		public TestWeavingContext (ClassLoader classLoader) {
+			this.loader = classLoader;
+		}
+		
+		public String getBundleIdFromURL(URL url) {
+			return null;
+		}
+
+		public String getClassLoaderName() {
+			return "ClassLoaderName";
+		}
+
+		public String getFile(URL url) {
+			return "File";
+		}
+
+		public String getId() {
+			return "Id";
+		}
+
+		public Enumeration getResources(String name) throws IOException {
+			return loader.getResources(name);
+		}
+		
+	}
+
+	protected void setUp() throws Exception {
+		super.setUp();
+
+		this.called = false;
+	}
+	
+}
