@@ -31,6 +31,7 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.aspectj.org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
@@ -412,6 +413,13 @@ public class AjProblemReporter extends ProblemReporter {
     	if (!(methodDecl instanceof PointcutDeclaration))
     			super.unusedPrivateMethod(methodDecl);
     }
+    
+    public void unusedArgument(LocalDeclaration localDecl) {
+    	// don't warn if this is an aj synthetic arg
+    	String argType = new String(localDecl.type.resolvedType.signature());
+    	if (argType.startsWith("Lorg/aspectj/runtime/internal")) return;
+    	super.unusedArgument(localDecl);
+    }
 
     /**
      * A side-effect of the way that we handle itds on default methods on top-most implementors
@@ -0,0 +1,166 @@
+import java.util.ArrayList;
+import java.util.List;
+
+class PlayList {
+
+    private static PlayList instance;
+    
+    private List<Song> list;
+    
+    private PlayList() {
+        list = new ArrayList<Song>();         
+    }
+
+    public static PlayList instance() {
+        if(instance==null ) {
+            instance = new PlayList();
+        }
+        return instance;
+    }
+
+    public void enqueue(Song song) {
+        list.add(song);
+        if(Player.instance().isIdle()) {
+            new Thread() {
+                public void run() {
+                    System.out.println("Playing playlist...");
+                    for (Song s : list) {
+                        Player.instance().play(s.getName());
+                    }
+                }  
+            }.start();            
+        }
+    }
+
+}
+
+class Song {
+
+    private String name; 
+
+    public Song(String name) {
+        this.name = name;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+}
+
+class Player {
+
+    private static Player instance;
+    
+    private Player() {}
+
+    public static Player instance() {
+        if(instance==null ) {
+            instance = new Player();
+        }
+        return instance;
+    }
+
+    public void play(String name) {
+        System.out.println("Playing Song "+name+"...");
+    }
+
+    public boolean isIdle() {
+        return true;
+    }
+}
+
+class Jukebox {
+    
+	   public void play(Song song) {
+	        Player.instance().play(song.getName());
+	   }
+
+	}
+
+class Main {
+
+    public static void main(String[] args) {
+        Song song = new Song("Merry XMas");
+        Jukebox jukebox = new Jukebox();
+        
+        jukebox.play(song);
+    }
+    
+}
+
+aspect PlaylistAspect {
+    
+    void around(Song song) :
+        call(public void Jukebox.play(Song))
+        && args(song) {
+        PlayList.instance().enqueue(song);
+    }
+
+}
+
+aspect CreditsAspect {
+
+    void around() : call(public void Jukebox.play(Song)) {
+        if(Credits.instance().enoughCredits()) {
+            System.out.println("Withdrawing credit.");
+            Credits.instance().withDraw();
+            proceed();
+        } else {
+            throw new InsufficientCreditsException();
+        }
+    }
+    
+}
+
+class Credits {
+
+    private static final int INITIAL_CREDITS = 10;
+
+    private static Credits instance;
+    
+    private int credits;
+    
+    private Credits() {
+        credits = INITIAL_CREDITS;        
+    }
+    
+    public static Credits instance() {
+        if(instance==null ) {
+            instance = new Credits();
+        }
+        return instance;
+    }
+
+    public boolean enoughCredits() {
+        return credits > 0;
+    }
+    
+    public void withDraw() {
+        credits--;
+    }
+}
+
+@SuppressWarnings("serial")
+class InsufficientCreditsException extends RuntimeException {
+
+    public InsufficientCreditsException() {
+        super();
+    }
+
+    public InsufficientCreditsException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    public InsufficientCreditsException(String message) {
+        super(message);
+    }
+
+    /**
+     * @param cause
+     */
+    public InsufficientCreditsException(Throwable cause) {
+        super(cause);
+    }
+
+}
@@ -405,6 +405,10 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testSuperCallInITD() {
 	  runTest("super call in ITD");
   }
+  
+  public void testNoUnusedParameterWarningsForSyntheticAdviceArgs() {
+	  runTest("no unused parameter warnings for synthetic advice args");
+  }
   // helper methods.....
 
   public SyntheticRepository createRepos(File cpentry) {
@@ -516,6 +516,11 @@
             <message kind="error" line="14" text="The method print() is undefined for the type Object"/>
         </compile>
     </ajc-test>  
+
+    <ajc-test dir="bugs150" pr="109042" title="no unused parameter warnings for synthetic advice args">
+        <compile files="pr109042.aj" options="-warn:+unusedArgument -warn:+unusedPrivate -warn:+unusedImport -1.5">
+        </compile>
+    </ajc-test>  
     <!-- ============================================================================ -->
     <!-- ============================================================================ -->
 
