@@ -27,21 +27,21 @@ public interface OutputLocationManager {
 	 * this method returns "target/classes" the resulting class file will be written
 	 * to "target/classes/a/b/C.class"
 	 * 
-	 * @param compilationUnitName  the fully-qualified name of the compilation unit that has been
+	 * @param compilationUnit  the compilation unit that has been
 	 *  compiled
 	 * @return a File object representing the root directory under which compilation results for this
 	 *  unit should be written
 	 */
-	File getOutputLocationForClass(String compilationUnitName);
+	File getOutputLocationForClass(File compilationUnit);
 
 	/**
 	 * When copying resources from source folders to output location, return the
 	 * root directory under which the resource should be copied.
 	 * 
-	 * @param resourceName the fully-qualified name of the resource to be copied
+	 * @param resource the resource to be copied
 	 * @return a File object representing the root directory under which this resource
 	 * should be copied
 	 */
-	File getOutputLocationForResource(String resourceName);
+	File getOutputLocationForResource(File resource);
 
 }
@@ -578,9 +578,10 @@ public class CompilerAdapter {
         }
 
         // set compilation result destination manager if not set
+        OutputLocationManager outputLocationManager = properties.getOutputLocationManager();
         if (config.getCompilationResultDestinationManager() == null &&
-        	properties.getOutputLocationManager() != null) {
-        	config.setCompilationResultDestinationManager(new OutputLocationAdapter(properties.getOutputLocationManager()));
+        	outputLocationManager != null) {
+        	config.setCompilationResultDestinationManager(new OutputLocationAdapter(outputLocationManager));
         }
 
         join(config.getSourceRoots(), properties.getSourceRoots());
@@ -24,12 +24,12 @@ public class OutputLocationAdapter implements CompilationResultDestinationManage
 		this.locationManager = mgr;
 	}
 
-	public File getOutputLocationForClass(String compilationUnitName) {
-		return this.locationManager.getOutputLocationForClass(compilationUnitName);
+	public File getOutputLocationForClass(File compilationUnit) {
+		return this.locationManager.getOutputLocationForClass(compilationUnit);
 	}
 
-	public File getOutputLocationForResource(String resourceName) {
-		return this.locationManager.getOutputLocationForResource(resourceName);
+	public File getOutputLocationForResource(File resource) {
+		return this.locationManager.getOutputLocationForResource(resource);
 	}
 
 }
@@ -26,21 +26,21 @@ public interface CompilationResultDestinationManager {
 	 * this method returns "target/classes" the resulting class file will be written
 	 * to "target/classes/a/b/C.class"
 	 * 
-	 * @param compilationUnitName  the fully-qualified name of the compilation unit that has been
+	 * @param compilationUnit  the compilation unit that has been
 	 *  compiled
 	 * @return a File object representing the root directory under which compilation results for this
 	 *  unit should be written
 	 */
-	File getOutputLocationForClass(String compilationUnitName);
+	File getOutputLocationForClass(File compilationUnit);
 
 	/**
 	 * When copying resources from source folders to output location, return the
 	 * root directory under which the resource should be copied.
 	 * 
-	 * @param resourceName the fully-qualified name of the resource to be copied
+	 * @param resource the resource to be copied
 	 * @return a File object representing the root directory under which this resource
 	 * should be copied
 	 */
-	File getOutputLocationForResource(String resourceName);
+	File getOutputLocationForResource(File resource);
 
 }
@@ -504,7 +504,7 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 		} else {
 			File destDir = buildConfig.getOutputDir();
 			if (buildConfig.getCompilationResultDestinationManager() != null) {
-				destDir = buildConfig.getCompilationResultDestinationManager().getOutputLocationForResource(srcLocation.getAbsolutePath());
+				destDir = buildConfig.getCompilationResultDestinationManager().getOutputLocationForResource(srcLocation);
 			}
 			try {
 				OutputStream fos = 
@@ -955,7 +955,7 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 				File destinationPath = buildConfig.getOutputDir();
 				if (buildConfig.getCompilationResultDestinationManager() != null) {
 					destinationPath = 
-						buildConfig.getCompilationResultDestinationManager().getOutputLocationForClass(new String(unitResult.fileName));
+						buildConfig.getCompilationResultDestinationManager().getOutputLocationForClass(new File(new String(unitResult.fileName)));
 				}
 				String outFile;
 				if (destinationPath == null) {
@@ -0,0 +1,9 @@
+package a;
+
+public class A {
+	
+	public String capitalize(String in) {
+		return in.toUpperCase();
+	}
+	
+}
\ No newline at end of file
@@ -0,0 +1,13 @@
+package a;
+
+public aspect Aspect {
+
+  // will generate a closure class...
+  String around(String in) : execution(String A.*(..)) && args(in) {
+    String ret = proceed(in.toLowerCase());
+    ret = proceed(in.toUpperCase());
+    return ret+" dada!";
+  }
+
+
+}
\ No newline at end of file
@@ -0,0 +1,9 @@
+package b;
+
+public class B {
+	
+	public int lesser(int x, int y) {
+		return x < y ? x : y;
+	}
+	
+}
\ No newline at end of file
@@ -19,6 +19,7 @@ import org.aspectj.systemtest.design.DesignTests;
 import org.aspectj.systemtest.incremental.IncrementalTests;
 import org.aspectj.systemtest.incremental.model.IncrementalModelTests;
 import org.aspectj.systemtest.incremental.tools.MultiProjectIncrementalTests;
+import org.aspectj.systemtest.incremental.tools.OutputLocationManagerTests;
 import org.aspectj.systemtest.inpath.InPathTests;
 import org.aspectj.systemtest.options.OptionsTests;
 import org.aspectj.systemtest.pre10x.AjcPre10xTests;
@@ -43,6 +44,7 @@ public class AllTests {
 		suite.addTest(DesignTests.suite());
 		suite.addTest(IncrementalTests.suite());
 		suite.addTestSuite(MultiProjectIncrementalTests.class);
+		suite.addTestSuite(OutputLocationManagerTests.class);
 		suite.addTest(IncrementalModelTests.suite());
 		//suite.addTest(KnownLimitationsTests.class);
 		suite.addTest(OptionsTests.suite());
@@ -0,0 +1,128 @@
+package org.aspectj.systemtest.incremental.tools;
+
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.aspectj.ajdt.internal.core.builder.AjState;
+import org.aspectj.bridge.IMessage;
+import org.aspectj.testing.util.FileUtil;
+
+public class AbstractMultiProjectIncrementalAjdeInteractionTestbed extends
+		AjdeInteractionTestbed {
+
+	public static boolean VERBOSE = false;
+
+	protected void setUp() throws Exception {
+		super.setUp();
+		AjdeInteractionTestbed.VERBOSE = VERBOSE;
+		AjState.FORCE_INCREMENTAL_DURING_TESTING = true;
+	}
+
+	protected void tearDown() throws Exception {
+		super.tearDown();
+		AjState.FORCE_INCREMENTAL_DURING_TESTING = false;
+	}
+
+	public void build(String projectName) {
+		constructUpToDateLstFile(projectName,"build.lst");
+		build(projectName,"build.lst");
+		if (AjdeInteractionTestbed.VERBOSE) printBuildReport();
+	}
+
+	public void fullBuild(String projectName) {
+		constructUpToDateLstFile(projectName,"build.lst");
+		fullBuild(projectName,"build.lst");
+		if (AjdeInteractionTestbed.VERBOSE) printBuildReport();
+	}
+
+	private void constructUpToDateLstFile(String pname, String configname) {
+		File projectBase = new File(sandboxDir,pname);
+		File toConstruct = new File(projectBase,configname);
+		List filesForCompilation = new ArrayList();
+		collectUpFiles(projectBase,projectBase,filesForCompilation);
+	
+		try {
+			FileOutputStream fos = new FileOutputStream(toConstruct);
+			DataOutputStream dos = new DataOutputStream(fos);
+			for (Iterator iter = filesForCompilation.iterator(); iter.hasNext();) {
+				String file = (String) iter.next();
+				dos.writeBytes(file+"\n");
+			}
+			dos.close();
+		} catch (IOException ioe) {
+			ioe.printStackTrace();
+		}
+	}
+
+	public void checkForError(String anError) {
+		List messages = MyTaskListManager.getErrorMessages();
+		for (Iterator iter = messages.iterator(); iter.hasNext();) {
+			IMessage element = (IMessage) iter.next();
+			if (element.getMessage().indexOf(anError)!=-1) return;
+		}
+		fail("Didn't find the error message:\n'"+anError+"'.\nErrors that occurred:\n"+MyTaskListManager.getErrorMessages());
+	}
+
+	private void collectUpFiles(File location, File base, List collectionPoint) {
+		String contents[] = location.list();
+		if (contents==null) return;
+		for (int i = 0; i < contents.length; i++) {
+			String string = contents[i];
+			File f = new File(location,string);
+			if (f.isDirectory()) {
+				collectUpFiles(f,base,collectionPoint);
+			} else if (f.isFile() && (f.getName().endsWith(".aj") || f.getName().endsWith(".java"))) {
+				String fileFound;
+				try {
+					fileFound = f.getCanonicalPath();
+					String toRemove  = base.getCanonicalPath();
+					if (!fileFound.startsWith(toRemove)) throw new RuntimeException("eh? "+fileFound+"   "+toRemove);
+					collectionPoint.add(fileFound.substring(toRemove.length()+1));//+1 captures extra separator
+				} catch (IOException e) {
+					e.printStackTrace();
+				}
+			}
+		}
+	}
+
+	/**
+	 * Fill in the working directory with the project base files,
+	 * from the 'base' folder.
+	 */
+	protected void initialiseProject(String p) {
+		File projectSrc=new File(testdataSrcDir+File.separatorChar+p+File.separatorChar+"base");
+		File destination=new File(getWorkingDir(),p);
+		if (!destination.exists()) {destination.mkdir();}
+		copy(projectSrc,destination);//,false);
+	}
+
+	/**
+	 * Copy the contents of some directory to another location - the
+	 * copy is recursive.
+	 */
+	protected void copy(File from, File to) {
+		String contents[] = from.list();
+		if (contents==null) return;
+		for (int i = 0; i < contents.length; i++) {
+			String string = contents[i];
+			File f = new File(from,string);
+			File t = new File(to,string);
+			
+			if (f.isDirectory() && !f.getName().startsWith("inc")) {
+				t.mkdir();
+				copy(f,t);
+			} else if (f.isFile()) {
+				StringBuffer sb = new StringBuffer();
+				//if (VERBOSE) System.err.println("Copying "+f+" to "+t);
+				FileUtil.copyFile(f,t,sb);
+				if (sb.length()!=0) { System.err.println(sb.toString());}
+			} 
+		}
+	}
+
+}
@@ -74,6 +74,14 @@ public class AjdeInteractionTestbed extends TestCase {
 	public static void configureAspectPath(Set aspectpath) {
 		MyProjectPropertiesAdapter.setAspectpath(aspectpath);
 	} 
+	
+	public static void configureOutputLocationManager(OutputLocationManager mgr) {
+		MyProjectPropertiesAdapter.setOutputLocationManager(mgr);
+	}
+	
+	public static void configureResourceMap(Map resourcesMap) {
+		MyProjectPropertiesAdapter.setSourcePathResources(resourcesMap);
+	}
 	// End of methods for configuring the build
 
 
@@ -385,6 +393,7 @@ public class AjdeInteractionTestbed extends TestCase {
 		private String classPath = "";
 		private Set aspectPath = null;
 		private Map sourcePathResources = null;
+		private OutputLocationManager outputLocationManager = null;
 
 		public static void setActiveProject(String n) {
 			_instance.projectName = n;
@@ -403,8 +412,8 @@ public class AjdeInteractionTestbed extends TestCase {
 			}
 		}
 
-		public void setSourcePathResources(Map m) {
-			this.sourcePathResources = m;
+		public static void setSourcePathResources(Map m) {
+			_instance.sourcePathResources = m;
 		}
 
 		public void setClasspath(String path) {
@@ -488,8 +497,12 @@ public class AjdeInteractionTestbed extends TestCase {
 			return dir;
 		}
 
+		public static void setOutputLocationManager(OutputLocationManager mgr) {
+			_instance.outputLocationManager = mgr;
+		}
+		
 	    public OutputLocationManager getOutputLocationManager() {
-	    	return null;
+	    	return this.outputLocationManager;
 	    }
 
 		public String getBootClasspath() {
@@ -12,9 +12,7 @@
 package org.aspectj.systemtest.incremental.tools;
 
 import java.io.BufferedReader;
-import java.io.DataOutputStream;
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -33,7 +31,6 @@ import org.aspectj.asm.IRelationship;
 import org.aspectj.asm.IRelationshipMap;
 import org.aspectj.asm.internal.Relationship;
 import org.aspectj.bridge.IMessage;
-import org.aspectj.testing.util.FileUtil;
 import org.aspectj.weaver.World;
 
 /**
@@ -53,21 +50,7 @@ import org.aspectj.weaver.World;
  * ones) - you can then drive a new build and check it behaves as
  * expected.
  */
-public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
-
-	public static boolean VERBOSE = false;
-	
-	protected void setUp() throws Exception {
-		super.setUp();
-		AjdeInteractionTestbed.VERBOSE = VERBOSE;
-		AjState.FORCE_INCREMENTAL_DURING_TESTING = true;
-	}
-	
-	protected void tearDown() throws Exception {
-		super.tearDown();
-		AjState.FORCE_INCREMENTAL_DURING_TESTING = false;
-	}
-	
+public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementalAjdeInteractionTestbed {
 
 	/*
 	A.aj
@@ -1406,80 +1389,6 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 	}
 
 
-	public void build(String projectName) {
-		constructUpToDateLstFile(projectName,"build.lst");
-		build(projectName,"build.lst");
-		if (AjdeInteractionTestbed.VERBOSE) printBuildReport();
-	}
-	
-	public void fullBuild(String projectName) {
-		constructUpToDateLstFile(projectName,"build.lst");
-		fullBuild(projectName,"build.lst");
-		if (AjdeInteractionTestbed.VERBOSE) printBuildReport();
-	}
-
-	private void constructUpToDateLstFile(String pname,String configname) {
-		File projectBase = new File(sandboxDir,pname);
-		File toConstruct = new File(projectBase,configname);
-		List filesForCompilation = new ArrayList();
-		collectUpFiles(projectBase,projectBase,filesForCompilation);
-
-		try {
-			FileOutputStream fos = new FileOutputStream(toConstruct);
-			DataOutputStream dos = new DataOutputStream(fos);
-			for (Iterator iter = filesForCompilation.iterator(); iter.hasNext();) {
-				String file = (String) iter.next();
-				dos.writeBytes(file+"\n");
-			}
-			dos.close();
-		} catch (IOException ioe) {
-			ioe.printStackTrace();
-		}
-	}
-	
-	public void checkForError(String anError) {
-		List messages = MyTaskListManager.getErrorMessages();
-		for (Iterator iter = messages.iterator(); iter.hasNext();) {
-			IMessage element = (IMessage) iter.next();
-			if (element.getMessage().indexOf(anError)!=-1) return;
-		}
-		fail("Didn't find the error message:\n'"+anError+"'.\nErrors that occurred:\n"+MyTaskListManager.getErrorMessages());
-	}
-
-	private void collectUpFiles(File location,File base,List collectionPoint) {
-		String contents[] = location.list();
-		if (contents==null) return;
-		for (int i = 0; i < contents.length; i++) {
-			String string = contents[i];
-			File f = new File(location,string);
-			if (f.isDirectory()) {
-				collectUpFiles(f,base,collectionPoint);
-			} else if (f.isFile() && (f.getName().endsWith(".aj") || f.getName().endsWith(".java"))) {
-				String fileFound;
-				try {
-					fileFound = f.getCanonicalPath();
-					String toRemove  = base.getCanonicalPath();
-					if (!fileFound.startsWith(toRemove)) throw new RuntimeException("eh? "+fileFound+"   "+toRemove);
-					collectionPoint.add(fileFound.substring(toRemove.length()+1));//+1 captures extra separator
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-		}
-	}
-	
-	
-	/**
-	 * Fill in the working directory with the project base files,
-	 * from the 'base' folder.
-	 */
-	protected void initialiseProject(String p) {
-		File projectSrc=new File(testdataSrcDir+File.separatorChar+p+File.separatorChar+"base");
-		File destination=new File(getWorkingDir(),p);
-		if (!destination.exists()) {destination.mkdir();}
-		copy(projectSrc,destination);//,false);
-	}
-
 	/*
 	 * Applies an overlay onto the project being tested - copying
 	 * the contents of the specified overlay directory.
@@ -1491,31 +1400,6 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		copy(projectSrc,destination);
 	}
 
-	/**
-	 * Copy the contents of some directory to another location - the
-	 * copy is recursive.
-	 */
-	private void copy(File from, File to) {
-		String contents[] = from.list();
-		if (contents==null) return;
-		for (int i = 0; i < contents.length; i++) {
-			String string = contents[i];
-			File f = new File(from,string);
-			File t = new File(to,string);
-			
-			if (f.isDirectory() && !f.getName().startsWith("inc")) {
-				t.mkdir();
-				copy(f,t);
-			} else if (f.isFile()) {
-				StringBuffer sb = new StringBuffer();
-				//if (VERBOSE) System.err.println("Copying "+f+" to "+t);
-				FileUtil.copyFile(f,t,sb);
-				if (sb.length()!=0) { System.err.println(sb.toString());}
-			} 
-		}
-	}
-	
-
 	private static void log(String msg) {
 		if (VERBOSE) System.out.println(msg);
 	}
@@ -0,0 +1,100 @@
+/* *******************************************************************
+ * Copyright (c) 2006 Contributors.
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ * Adrian Colyer          initial implementation
+* ******************************************************************/
+package org.aspectj.systemtest.incremental.tools;
+
+import java.io.File;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.aspectj.ajde.OutputLocationManager;
+
+/**
+ * Test the OutputLocationManager support used to enable multiple output folders.
+ * These aren't true "multi-project incremental" tests, but that superclass has some
+ * handy methods over and above AjdeInteractionTestCase that I want to use.
+ */
+public class OutputLocationManagerTests extends AbstractMultiProjectIncrementalAjdeInteractionTestbed {
+
+	private static final String PROJECT_NAME = "MultipleOutputFolders";
+	private MyOutputLocationManager outputLocationManager;
+	
+	protected void setUp() throws Exception {
+		super.setUp();
+		initialiseProject(PROJECT_NAME);
+		this.outputLocationManager = new MyOutputLocationManager(new File(getFile(PROJECT_NAME, "")));
+		configureOutputLocationManager(this.outputLocationManager);
+	}
+	
+	public void testDefaultOutputLocationUsedWhenNoOutputLocationManager() {
+		configureOutputLocationManager(null);
+		build(PROJECT_NAME);
+		assertFileExists(PROJECT_NAME,"bin/a/A.class");
+		assertFileExists(PROJECT_NAME,"bin/b/B.class");
+	}
+	
+	public void testTwoSourceRootsWithSeparateOutputLocations() {
+		build(PROJECT_NAME);
+		assertFileExists(PROJECT_NAME,"target/main/classes/a/A.class");
+		assertFileExists(PROJECT_NAME,"target/test/classes/b/B.class");
+	}
+	
+	public void testResourceCopying() {
+		Map resourceMap = new HashMap();
+		resourceMap.put("resourceOne.txt", new File(getFile(PROJECT_NAME,"srcRootOne/resourceOne.txt")));
+		resourceMap.put("resourceTwo.txt", new File(getFile(PROJECT_NAME,"srcRootTwo/resourceTwo.txt")));
+		configureResourceMap(resourceMap);
+		build(PROJECT_NAME);
+		assertFileExists(PROJECT_NAME,"target/main/classes/resourceOne.txt");
+		assertFileExists(PROJECT_NAME,"target/test/classes/resourceTwo.txt");		
+	}
+	
+	public void testGeneratedClassesPlacedInAppropriateOutputFolder() {
+		configureNonStandardCompileOptions("-XnoInline");
+		build(PROJECT_NAME);
+		assertFileExists(PROJECT_NAME,"target/main/classes/a/A.class");
+		assertFileExists(PROJECT_NAME,"target/main/classes/a/A$AjcClosure1.class");		
+	}
+	
+	protected void assertFileExists(String project, String relativePath) {
+		assertTrue("file " + relativePath + " should have been created as a result of building " + project,
+				    new File(getFile(project, relativePath)).exists());
+	}
+	
+	private static class MyOutputLocationManager implements OutputLocationManager {
+		
+		private File projectHome;
+		
+		public MyOutputLocationManager(File projectHome) {
+			this.projectHome = projectHome;
+		}
+
+		public File getOutputLocationForClass(File compilationUnit) {
+			String relativePath = "";
+			String compilationUnitName = compilationUnit.getAbsolutePath();
+			if (compilationUnitName.indexOf("srcRootOne") != -1) {
+				relativePath = "target/main/classes";
+			} else if (compilationUnitName.indexOf("srcRootTwo") != -1) {
+				relativePath = "target/test/classes";
+			}
+			File ret =  new File(projectHome,relativePath);
+			if (!ret.exists()) {
+				ret.mkdirs();
+			}
+			return ret;
+		}
+
+		public File getOutputLocationForResource(File resource) {
+			return getOutputLocationForClass(resource);
+		}
+		
+	}
+}
@@ -113,6 +113,10 @@ public class BrowserProperties implements ProjectPropertiesAdapter {
     public void setOutputPath(String path) {
         preferencesAdapter.setProjectPreference("build.outputpath", path);
     }
+    
+    public OutputLocationManager getOutputLocationManager() {
+    	return null;
+    }
 
     public String getUserClasspath() {
         return preferencesAdapter.getProjectPreference("build.classpath");
@@ -0,0 +1,47 @@
+/* *******************************************************************
+ * Copyright (c) 2006 Contributors.
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *   Adrian Colyer			Initial implementation
+ * ******************************************************************/
+package org.aspectj.ajde;
+
+import java.io.File;
+
+/**
+ * Interface to be implemented by clients that wish to control the output
+ * folder used to write the results of compiling individual source files.
+ * @author adrian colyer
+ *
+ */
+public interface OutputLocationManager {
+
+	/**
+	 * Return the directory root under which the results of compiling the given
+	 * source file. For example, if the source file contains the type a.b.C, and
+	 * this method returns "target/classes" the resulting class file will be written
+	 * to "target/classes/a/b/C.class"
+	 * 
+	 * @param compilationUnitName  the fully-qualified name of the compilation unit that has been
+	 *  compiled
+	 * @return a File object representing the root directory under which compilation results for this
+	 *  unit should be written
+	 */
+	File getOutputLocationForClass(String compilationUnitName);
+	
+	/**
+	 * When copying resources from source folders to output location, return the
+	 * root directory under which the resource should be copied.
+	 * 
+	 * @param resourceName the fully-qualified name of the resource to be copied
+	 * @return a File object representing the root directory under which this resource
+	 * should be copied
+	 */
+	File getOutputLocationForResource(String resourceName);
+	
+}
@@ -44,6 +44,12 @@ public interface ProjectPropertiesAdapter {
     public String getClasspath();
 
     public String getOutputPath();
+    
+    /** 
+     * A non-null OutputLocationManager takes precedence over getOutputPath...
+     * @return
+     */
+    public OutputLocationManager getOutputLocationManager();
 
 //    public String getAjcWorkingDir();
 
@@ -576,6 +576,12 @@ public class CompilerAdapter {
                 config.setOutputJar(new File( outJar ) );  
             }
         }
+        
+        // set compilation result destination manager if not set
+        if (config.getCompilationResultDestinationManager() == null &&
+        	properties.getOutputLocationManager() != null) {
+        	config.setCompilationResultDestinationManager(new OutputLocationAdapter(properties.getOutputLocationManager()));
+        }
 
         join(config.getSourceRoots(), properties.getSourceRoots());
         join(config.getInJars(), properties.getInJars());
@@ -0,0 +1,35 @@
+/* *******************************************************************
+ * Copyright (c) 2006 Contributors.
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *   Adrian Colyer			Initial implementation
+ * ******************************************************************/
+package org.aspectj.ajde.internal;
+
+import java.io.File;
+
+import org.aspectj.ajde.OutputLocationManager;
+import org.aspectj.ajdt.internal.compiler.CompilationResultDestinationManager;
+
+public class OutputLocationAdapter implements CompilationResultDestinationManager {
+
+	private OutputLocationManager locationManager;
+	
+	public OutputLocationAdapter(OutputLocationManager mgr) {
+		this.locationManager = mgr;
+	}
+	
+	public File getOutputLocationForClass(String compilationUnitName) {
+		return this.locationManager.getOutputLocationForClass(compilationUnitName);
+	}
+
+	public File getOutputLocationForResource(String resourceName) {
+		return this.locationManager.getOutputLocationForResource(resourceName);
+	}
+
+}
@@ -83,6 +83,10 @@ public class NullIdeProperties implements ProjectPropertiesAdapter {
     	this.outputPath = outputPath;
     }
 
+    public OutputLocationManager getOutputLocationManager() {
+    	return null;
+    }
+
     public String getAjcWorkingDir() {
     	return testProjectPath + "/ajworkingdir";	
     }
@@ -0,0 +1,46 @@
+/* *******************************************************************
+ * Copyright (c) 2006 Contributors.
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: 
+ *   Adrian Colyer			Initial implementation
+ * ******************************************************************/
+package org.aspectj.ajdt.internal.compiler;
+
+import java.io.File;
+
+/**
+ * acts as a bridge from ajde's OutputLocationManager interface to the compiler internals
+ * @author adrian
+ *
+ */
+public interface CompilationResultDestinationManager {
+
+	/**
+	 * Return the directory root under which the results of compiling the given
+	 * source file. For example, if the source file contains the type a.b.C, and
+	 * this method returns "target/classes" the resulting class file will be written
+	 * to "target/classes/a/b/C.class"
+	 * 
+	 * @param compilationUnitName  the fully-qualified name of the compilation unit that has been
+	 *  compiled
+	 * @return a File object representing the root directory under which compilation results for this
+	 *  unit should be written
+	 */
+	File getOutputLocationForClass(String compilationUnitName);
+	
+	/**
+	 * When copying resources from source folders to output location, return the
+	 * root directory under which the resource should be copied.
+	 * 
+	 * @param resourceName the fully-qualified name of the resource to be copied
+	 * @return a File object representing the root directory under which this resource
+	 * should be copied
+	 */
+	File getOutputLocationForResource(String resourceName);
+	
+}
@@ -25,6 +25,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
+import org.aspectj.ajdt.internal.compiler.CompilationResultDestinationManager;
 import org.aspectj.util.FileUtil;
 
 /**
@@ -43,6 +44,7 @@ public class AjBuildConfig {
 	private File outputDir;
 	private File outputJar;
 	private String outxmlName;
+	private CompilationResultDestinationManager compilationResultDestinationManager = null;
 	private List/*File*/ sourceRoots = new ArrayList();
 	private List/*File*/ files = new ArrayList();
 	private List /*File*/ binaryFiles = new ArrayList();  // .class files in indirs...
@@ -131,7 +133,15 @@ public class AjBuildConfig {
 	public File getOutputDir() {  
 		return outputDir;
 	}
+	
+	public CompilationResultDestinationManager getCompilationResultDestinationManager() {
+		return this.compilationResultDestinationManager;
+	}
 
+	public void setCompilationResultDestinationManager(CompilationResultDestinationManager mgr) {
+		this.compilationResultDestinationManager = mgr;
+	}
+	
 	public void setFiles(List files) {
 		this.files = files;
 	}
@@ -501,8 +501,12 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 			zos.write(content);
 			zos.closeEntry();
 		} else {
+			File destDir = buildConfig.getOutputDir();
+			if (buildConfig.getCompilationResultDestinationManager() != null) {
+				destDir = buildConfig.getCompilationResultDestinationManager().getOutputLocationForResource(srcLocation.getAbsolutePath());
+			}
 			OutputStream fos = 
-				FileUtil.makeOutputStream(new File(buildConfig.getOutputDir(),filename));
+				FileUtil.makeOutputStream(new File(destDir,filename));
 			fos.write(content);
 			fos.close();
 		}
@@ -940,6 +944,10 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 					String filename) 
 			throws IOException {
 				File destinationPath = buildConfig.getOutputDir();
+				if (buildConfig.getCompilationResultDestinationManager() != null) {
+					destinationPath = 
+						buildConfig.getCompilationResultDestinationManager().getOutputLocationForClass(new String(unitResult.fileName));
+				}
 				String outFile;
 				if (destinationPath == null) {
 					outFile = new File(filename).getName();
@@ -23,7 +23,6 @@ import org.aspectj.ajde.ui.*;
 import org.aspectj.ajde.ui.internal.*;
 import org.aspectj.ajde.ui.swing.*;
 import org.aspectj.asm.*;
-import org.aspectj.asm.IProgramElement;
 import org.aspectj.bridge.*;
 import org.aspectj.util.FileUtil;
 
@@ -376,6 +375,10 @@ class ProjectProperties implements ProjectPropertiesAdapter {
     public void setOutJar(String input){ outJar = input; }
     public String getOutJar() { return outJar; }
     public String getOutputPath() { return outputDir; }
+    
+    public OutputLocationManager getOutputLocationManager() {
+    	return null;
+    }
 
     // not known if used - log any calls to it
     public List getBuildConfigFiles() { return logs("buildConfigFiles"); }
@@ -27,6 +27,7 @@ import org.aspectj.ajde.Ajde;
 import org.aspectj.ajde.BuildOptionsAdapter;
 import org.aspectj.ajde.BuildProgressMonitor;
 import org.aspectj.ajde.ErrorHandler;
+import org.aspectj.ajde.OutputLocationManager;
 import org.aspectj.ajde.ProjectPropertiesAdapter;
 import org.aspectj.ajde.TaskListManager;
 import org.aspectj.ajdt.internal.core.builder.AbstractStateListener;
@@ -480,6 +481,10 @@ public class AjdeInteractionTestbed extends TestCase {
 			log("MyProjectProperties.getOutputPath() [returning "+dir+"]");
 			return dir;
 		}
+		
+	    public OutputLocationManager getOutputLocationManager() {
+	    	return null;
+	    }
 
 		public String getBootClasspath() {
 			log("MyProjectProperties.getBootClasspath()");
