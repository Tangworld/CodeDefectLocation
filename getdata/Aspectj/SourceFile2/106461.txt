@@ -0,0 +1,18 @@
+public aspect PR106461 {
+	
+	pointcut missingNamePattern() : call(* Foo+(..));
+	
+	pointcut missingNamePatternInField() : get(* Foo+);
+	
+	pointcut missingNamePatternInConstructor() : call(Foo+(..));
+	
+	pointcut butThisIsAllowedOfCourse() : call(* *(..));
+	
+	pointcut asIsThis() : call(* foo(..));
+}
+
+class Foo {
+	
+	void foo() {}
+	
+}
\ No newline at end of file
@@ -192,6 +192,8 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
   public void testSyntaxErrorNPE_pr103266() {runTest("NPE on syntax error");}
 
+  public void testMissingNamePattern_pr106461() { runTest("missing name pattern"); }
+  
   // helper methods.....
 
   public SyntheticRepository createRepos(File cpentry) {
@@ -173,6 +173,14 @@
     <ajc-test dir="bugs150" title="bad asm for enums" vm="1.5">
         <compile files="Rainbow.java" options="-emacssym,-1.5"/>
     </ajc-test>
+    
+    <ajc-test dir="bugs150" title="missing name pattern">
+        <compile files="PR106461.aj">
+            <message kind="error" line="3" text="Syntax error on token &quot;(&quot;, &quot;name pattern&quot; expected"/>
+            <message kind="error" line="5" text="Syntax error on token &quot;)&quot;, &quot;name pattern&quot; expected"/>
+            <message kind="error" line="7" text="Syntax error on token &quot;.&quot;, &quot;name pattern&quot; expected"/>
+        </compile>
+    </ajc-test>
 
     <ajc-test dir="../docs/dist/doc/examples/introduction" title="introduction sample" vm="1.5">
         <compile files="CloneablePoint.java,ComparablePoint.java,HashablePoint.java,Point.java" options="-1.5"/>
@@ -1111,6 +1111,7 @@ public class PatternParser {
 		    name = parseNamePattern();
 	    } else {
 	    	name = tryToExtractName(declaringType);
+	    	if (name == null) throw new ParserException("name pattern",tokenSource.peek());
 	    	if (declaringType.toString().equals("")) {
 	    		declaringType = TypePattern.ANY;
 	    	}
@@ -455,6 +455,11 @@ public class WildTypePattern extends TypePattern {
 	}
 
 	public NamePattern extractName() {
+		if (isIncludeSubtypes() || isVarArgs() || isArray()) {
+			// we can't extract a name, the pattern is something like Foo+ and therefore
+			// it is not ok to treat Foo as a method name!
+			return null;
+		}
 		//System.err.println("extract from : " + Arrays.asList(namePatterns));
 		int len = namePatterns.length;
 		NamePattern ret = namePatterns[len-1];
