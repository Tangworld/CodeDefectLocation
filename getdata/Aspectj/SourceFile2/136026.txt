@@ -203,7 +203,6 @@ public class CflowPointcut extends Pointcut {
 		List innerCflowEntries = new ArrayList(xcut.getCflowEntries());
 		innerCflowEntries.removeAll(previousCflowEntries);
 
-		Object field = getCflowfield(concreteEntry,concreteAspect);
 
 		// Four routes of interest through this code (did I hear someone say refactor??)
 		// 1) no state in the cflow - we can use a counter *and* we have seen this pointcut
@@ -218,6 +217,8 @@ public class CflowPointcut extends Pointcut {
 		if (freeVars==null || freeVars.length == 0) { // No state, so don't use a stack, use a counter.
 		  ResolvedMember localCflowField = null;
 
+		  Object field = getCflowfield(concreteEntry,concreteAspect,"counter");
+		  
 		  // Check if we have already got a counter for this cflow pointcut
 		  if (field != null) {
 		   	localCflowField = (ResolvedMember)field; // Use the one we already have
@@ -235,7 +236,7 @@ public class CflowPointcut extends Pointcut {
 		  	concreteAspect.crosscuttingMembers.addConcreteShadowMunger(
 		    Advice.makeCflowEntry(world,concreteEntry,isBelow,localCflowField,freeVars==null?0:freeVars.length,innerCflowEntries,inAspect));
 
-			putCflowfield(concreteEntry,concreteAspect,localCflowField); // Remember it
+			putCflowfield(concreteEntry,concreteAspect,localCflowField,"counter"); // Remember it
 	      }
 
 		  Pointcut ret = new ConcreteCflowPointcut(localCflowField, null,true);
@@ -275,6 +276,7 @@ public class CflowPointcut extends Pointcut {
 				slots.add(slot);
 			}
 			ResolvedMember localCflowField = null;
+			Object field = getCflowfield(concreteEntry,concreteAspect,"stack");
 			if (field != null) {
 				localCflowField = (ResolvedMember)field;
 			} else {
@@ -293,7 +295,7 @@ public class CflowPointcut extends Pointcut {
 
 			  concreteAspect.crosscuttingMembers.addTypeMunger(
 				world.makeCflowStackFieldAdder(localCflowField));
-			  putCflowfield(concreteEntry,concreteAspect,localCflowField);
+			  putCflowfield(concreteEntry,concreteAspect,localCflowField,"stack");
 		    }
 			Pointcut ret = new ConcreteCflowPointcut(localCflowField, slots,false);
 			ret.copyLocationFrom(this);
@@ -307,28 +309,27 @@ public class CflowPointcut extends Pointcut {
 		cflowBelowFields.clear();
 	}
 
-	private String getKey(Pointcut p,ResolvedType a) {
+	private String getKey(Pointcut p,ResolvedType a,String stackOrCounter) {
 	  StringBuffer sb = new StringBuffer();
 	  sb.append(a.getName());
 	  sb.append("::");
 	  sb.append(p.toString());
+	  sb.append("::");
+	  sb.append(stackOrCounter);
 	  return sb.toString();
 	}
 
-	private Object getCflowfield(Pointcut pcutkey, ResolvedType concreteAspect) {
-		String key = getKey(pcutkey,concreteAspect);
+	private Object getCflowfield(Pointcut pcutkey, ResolvedType concreteAspect,String stackOrCounter) {
+		String key = getKey(pcutkey,concreteAspect,stackOrCounter);
 		Object o =null;
-		if (isBelow) {
-			o = cflowBelowFields.get(key);
-		} else {
-			o = cflowFields.get(key);
-		}
+		if (isBelow) o = cflowBelowFields.get(key);
+		else         o = cflowFields.get(key);
 		//System.err.println("Retrieving for key "+key+" returning "+o);
 		return o;
 	}
 
-	private void putCflowfield(Pointcut pcutkey,ResolvedType concreteAspect,Object o) {
-		String key = getKey(pcutkey,concreteAspect);
+	private void putCflowfield(Pointcut pcutkey,ResolvedType concreteAspect,Object o,String stackOrCounter) {
+		String key = getKey(pcutkey,concreteAspect,stackOrCounter);
 		//System.err.println("Storing cflow field for key"+key);
 		if (isBelow) {
 			cflowBelowFields.put(key,o);
@@ -0,0 +1,42 @@
+import java.io.PrintStream;
+import java.lang.annotation.*;
+
+@Retention(RetentionPolicy.RUNTIME) @interface Marker {}
+
+class A {
+	@Marker void foo() { }
+    public static void main(String[] args) {
+        new A().foo();
+    }
+}
+
+public class CflowOrder {
+
+    public static void main(String[] args) {
+        A.main(null);
+    }
+
+    
+    
+    
+    static aspect MyAspect  {
+
+        pointcut annotated(Marker a) :  execution(@Marker * *(..)) && @annotation(a);
+
+        pointcut belowAnnotated() :         cflowbelow(annotated(Marker));
+        
+//        pointcut belowAnnotated() :         cflowbelow(execution(@Marker * *(..)) && @annotation(Marker));
+        
+      pointcut topAnnotated(Marker a) : annotated(a) && !belowAnnotated();
+
+      pointcut notTopAnnotated(/*Marker a,*/ Marker aTop) : 
+    	                                       /* annotated(a) &&*/ cflowbelow(annotated(aTop));
+      
+        // if this first, then no nonTopAnnotated advice
+        before(Marker a) : topAnnotated(a) { }
+        
+        // if topAnnotated is first, this does not run
+        before(Marker aTop) : notTopAnnotated( aTop) { }
+    }
+}
+
@@ -0,0 +1,98 @@
+package bugs;
+
+import java.io.PrintStream;
+import java.lang.annotation.*;
+
+import org.aspectj.lang.JoinPoint;
+
+public class CflowOrderOriginal {
+
+    public static void main(String[] args) {
+        Log.print("Starting CflowOrder.main(..)");
+        A.main(null);
+        Log.print("Ending CflowOrder.main(..)");
+    }
+
+    @Retention(value = RetentionPolicy.RUNTIME)
+    @interface Annotation {
+        String value();
+    }
+
+    static class A {
+        @Annotation("A.foo")
+        void foo() {
+            new B().foo();
+            Log.print("A.foo()");
+        }
+
+        public static void main(String[] args) {
+            new A().foo();
+            Log.print("A.main(..)");
+        }
+    }
+
+    static class B {
+        @Annotation("B.foo")
+        void foo() {
+            Log.print("B.foo()");
+        }
+    }
+
+    static class Log implements IAspect {
+        static final PrintStream out = System.err;
+
+        static void print(String label) {
+            out.println(label);
+        }
+
+        static void print(String label, JoinPoint tjp, JoinPoint.StaticPart sp,
+                Object a) {
+            out.println(label);
+//            out.println(" Join point: " + tjp);
+//            out.println(" Enclosing join point: " + sp);
+//            out.println(" Annotation: " + a);
+        }
+    }
+    static aspect Logger implements IAspect {
+
+        //declare error: execution(* *(..)) && !within(Log) : "er";
+
+//        before() : cflow(execution(void CflowOrder.main(String[]))) 
+//            && !call(* IAspect+.*(..)) && ! within(IAspect+) {
+//            Log.print("cflow(..main(..))", thisJoinPoint,
+//                    thisEnclosingJoinPointStaticPart, null);
+//        }
+    }
+
+    interface IAspect {}
+    static aspect MyAspect  implements IAspect {
+
+        pointcut annotated(Annotation a) :
+            call(@Annotation * *(..)) && @annotation(a);
+
+        pointcut belowAnnotated() :
+            cflowbelow(annotated(Annotation));
+      pointcut topAnnotated(Annotation a) : annotated(a) 
+            && !belowAnnotated();
+
+      pointcut notTopAnnotated(Annotation a, Annotation aTop) : annotated(a) 
+      && cflowbelow(annotated(aTop));
+//        pointcut topAnnotated(Annotation a) : annotated(a) 
+//            && !cflowbelow(annotated(Annotation));
+//
+//        pointcut notTopAnnotated(Annotation a, Annotation aTop) : annotated(a) 
+//            &&  cflowbelow(topAnnotated(aTop));
+
+        // if this first, then no nonTopAnnotated advice
+        before(Annotation a) : topAnnotated(a) {
+            Log.print("topAnnotated", thisJoinPoint,
+                    thisEnclosingJoinPointStaticPart, a);
+        }
+        // if topAnnotated is first, this does not run
+        before(Annotation a, Annotation aTop) : notTopAnnotated(a, aTop) {
+            Log.print("nonTopAnnotated", thisJoinPoint,
+                    thisEnclosingJoinPointStaticPart, a);
+        }
+    }
+}
+
@@ -17,6 +17,8 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+  public void testVerifyErrorForComplexCflow_pr136026() { runTest("verifyerror");}
+  public void testVerifyErrorForComplexCflow_pr136026_2() { runTest("verifyerror - 2");}
   public void testAnnotationsAndGenericsBCException_pr129704() { runTest("annotations and generics leading to BCException");}
   public void testMethodTooBigAfterWeaving_pr138384() { runTest("method too big"); }
   public void testNotAtWithincode_pr138158_1() { runTest("not at withincode - 1");}
@@ -24,6 +24,32 @@
       </run>
     </ajc-test>
 
+    <ajc-test dir="bugs152/pr136026" title="verifyerror">
+      <compile files="CflowOrder.java" options="-1.5"/>
+      <run class="CflowOrder"/>
+    </ajc-test>
+    
+    <ajc-test dir="bugs152/pr136026" title="verifyerror - 2">
+      <compile files="CflowOrderOriginal.java" options="-1.5"/>
+      <run class="bugs.CflowOrderOriginal">
+        <stderr>
+          <line text="Starting CflowOrder.main(..)"/>
+          <line text="topAnnotated"/>
+          <!--line text=" Join point: call(void bugs.CflowOrderOriginal.A.foo())"/>
+          <line text=" Enclosing join point: execution(void bugs.CflowOrderOriginal.A.main(String[]))"/>
+          <line text=" Annotation: @bugs.CflowOrderOriginal$Annotation(value=A.foo)"/-->
+          <line text="nonTopAnnotated"/>
+          <!--line text=" Join point: call(void bugs.CflowOrderOriginal.B.foo())"/>
+          <line text=" Enclosing join point: execution(void bugs.CflowOrderOriginal.A.foo())"/>
+          <line text=" Annotation: @bugs.CflowOrderOriginal$Annotation(value=B.foo)"/-->
+          <line text="B.foo()"/>
+          <line text="A.foo()"/>
+          <line text="A.main(..)"/>
+          <line text="Ending CflowOrder.main(..)"/>
+        </stderr>
+      </run>
+    </ajc-test>
+    
     <ajc-test dir="bugs152/pr136258" title="stack overflow">
       <compile files="StatisticsTypeImpl.java" options="-1.5"/>
       <run class="StatisticsTypeImpl"/>
