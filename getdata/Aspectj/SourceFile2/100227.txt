@@ -199,13 +199,18 @@ public class EclipseFactory {
 				return TypeX.forRawTypeNames(getName(binding));
 			}
 			ParameterizedTypeBinding ptb = (ParameterizedTypeBinding) binding;
-			String[] arguments = new String[ptb.arguments.length];
-			for (int i = 0; i < arguments.length; i++) {
-				if (ptb.arguments[i] instanceof WildcardBinding) {
-					WildcardBinding wcb = (WildcardBinding) ptb.arguments[i];
-					arguments[i] = getName(((TypeVariableBinding)wcb.typeVariable()).firstBound);
-				}  else {
-					arguments[i] = fromBinding(ptb.arguments[i]).getName();
+			
+			String[] arguments = null;
+			
+			if (ptb.arguments!=null) { // null can mean this is an inner type of a Parameterized Type with no bounds of its own (pr100227)
+				arguments = new String[ptb.arguments.length];
+				for (int i = 0; i < arguments.length; i++) {
+					if (ptb.arguments[i] instanceof WildcardBinding) {
+						WildcardBinding wcb = (WildcardBinding) ptb.arguments[i];
+						arguments[i] = getName(((TypeVariableBinding)wcb.typeVariable()).firstBound);
+					}  else {
+						arguments[i] = fromBinding(ptb.arguments[i]).getName();
+					}
 				}
 			}
 			return TypeX.forParameterizedTypeNames(getName(binding), arguments);
@@ -0,0 +1,33 @@
+class Outer {
+  class Inner {public void p() {System.err.println("Outer.Inner.p() executing");} }
+  public void m() { new Inner().p(); }
+}
+
+class Generic_Outer<T> {
+  class Inner {public void p() {System.err.println("Generic_Outer.Inner.p() executing");} }
+
+  public void m() { new Inner().p(); }
+}
+
+aspect Injector {
+  int Outer.outer = 1;
+  int Outer.Inner.inner = 2;
+  int Generic_Outer.outer = 3; 
+  int Generic_Outer.Inner.inner = 4;
+
+  before(Object o): execution(* p()) && this(o) {
+    if (o instanceof Outer.Inner) {
+      System.err.println("Outer.Inner.inner="+((Outer.Inner)o).inner);
+    }
+    if (o instanceof Generic_Outer.Inner) {
+      System.err.println("Generic_Outer.Inner.inner="+((Generic_Outer.Inner)o).inner);
+    }
+  }
+}
+
+public class pr100227 {
+  public static void main(String []argv) {
+    new Outer().m();
+    new Generic_Outer<String>().m();
+  }
+}
@@ -180,9 +180,10 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
   public void testGenerics_pr99089() {runTest("ArrayIndexOutOfBoundsException - Generics in privileged aspects");}
 
-  public void testItdGenerics_pr99228() {runTest("ITD of a field into a generic class");}
-  public void testItdGenerics_pr98320() {runTest("intertype with nested generic type");}
-  
+  public void testItdGenerics_pr99228()  {runTest("ITD of a field into a generic class");}
+  public void testItdGenerics_pr98320()  {runTest("intertype with nested generic type");}
+  public void testItdGenerics_pr100227() {runTest("inner class with generic enclosing class");}
+
   // helper methods.....
 
   public SyntheticRepository createRepos(File cpentry) {
@@ -2275,6 +2275,18 @@
      <compile files="PR95992.java" options="-1.5"/>
    </ajc-test>
 
+   <ajc-test dir="bugs150" pr="100227" title="inner class with generic enclosing class">
+     <compile files="pr100227.aj" options="-1.5"/>
+     <run class="pr100227">
+	     <stderr>
+	    	 <line text="Outer.Inner.inner=2"/>
+	    	 <line text="Outer.Inner.p() executing"/>
+	    	 <line text="Generic_Outer.Inner.inner=4"/>
+	    	 <line text="Generic_Outer.Inner.p() executing"/>
+	     </stderr>
+     </run>
+   </ajc-test>
+   
    // end of generic bugs
 
    // generic aspects
@@ -21,6 +21,7 @@ import java.util.Iterator;
 import java.util.List;
 
 
+
 public class TypeX implements AnnotatedElement {
 
 	/**
@@ -34,11 +35,13 @@ public class TypeX implements AnnotatedElement {
 	 */
 	protected String rawTypeSignature;
 
-	/**
-	 * If this is a parameterized type, these are its parameters
-	 */
+	// It is not sufficient to say that a parameterized type with no type parameters in fact
+	// represents a raw type - a parameterized type with no type parameters can represent
+	// an inner type of a parameterized type that specifies no type parameters of its own.
 	protected TypeX[] typeParameters;
 	private boolean isParameterized = false;
+	private boolean isRawtype = false;
+	
 
 	/**
 	 * @param      signature   the bytecode string representation of this Type
@@ -194,26 +197,32 @@ public class TypeX implements AnnotatedElement {
     public static TypeX forParameterizedTypeNames(String name, String[] paramTypeNames) {
 		TypeX ret = TypeX.forName(name);
 		ret.setParameterized(true);
-		ret.typeParameters = new TypeX[paramTypeNames.length];
-		for (int i = 0; i < paramTypeNames.length; i++) {
-			ret.typeParameters[i] = TypeX.forName(paramTypeNames[i]);
+		ret.typeParameters = null;
+		if (paramTypeNames!=null) {
+			ret.typeParameters = new TypeX[paramTypeNames.length];
+			for (int i = 0; i < paramTypeNames.length; i++) {
+				ret.typeParameters[i] = TypeX.forName(paramTypeNames[i]);
+			}
 		}
 		ret.rawTypeSignature = ret.signature;
 		// sig for e.g. List<String> is Ljava/util/List<Ljava/lang/String;>;
-		StringBuffer sigAddition = new StringBuffer();
-		sigAddition.append("<");
-		for (int i = 0; i < ret.typeParameters.length; i++) {
-			sigAddition.append(ret.typeParameters[i].signature);			
+		if (ret.typeParameters!=null) {
+			StringBuffer sigAddition = new StringBuffer();
+			sigAddition.append("<");
+			for (int i = 0; i < ret.typeParameters.length; i++) {
+				sigAddition.append(ret.typeParameters[i].signature);			
+			}
+			sigAddition.append(">");
+			sigAddition.append(";");
+			ret.signature = ret.signature.substring(0,ret.signature.length()-1) + sigAddition.toString();
 		}
-		sigAddition.append(">");
-		sigAddition.append(";");
-		ret.signature = ret.signature.substring(0,ret.signature.length()-1) + sigAddition.toString();
 		return ret;
     }
 
 	public static TypeX forRawTypeNames(String name) {
 		TypeX ret = TypeX.forName(name);
 		ret.setParameterized(true);
+		ret.setRawtype(true);
 		// FIXME asc  no need to mess up the signature is there?
 		// ret.signature = ret.signature+"#RAW";
 		return ret;
@@ -324,7 +333,10 @@ public class TypeX implements AnnotatedElement {
 		String name = getName();
 		if (isParameterized()) {
 			if (isRawType()) return name;
-			else             return name.substring(0,name.indexOf("<"));
+			else {
+				if (typeParameters==null) return name;
+				else                      return name.substring(0,name.indexOf("<"));
+			}
 		} else {
 			return name;
 		}
@@ -387,23 +399,24 @@ public class TypeX implements AnnotatedElement {
         return signature.startsWith("[");
     }
 
-	/**
-	 * Determines if this represents a parameterized type.
-	 */
 	public final boolean isParameterized() {
 		return isParameterized;
-//		return signature.indexOf("<") != -1; 
-//		//(typeParameters != null) && (typeParameters.length > 0);
 	}
 
 	public final boolean isRawType() { 
-	    return isParameterized && typeParameters==null;
+		return isRawtype;
+//	    return isParameterized && typeParameters==null;
 	}
 
 	private final void setParameterized(boolean b) { 
 		isParameterized=b;
 	}
 
+    private final void setRawtype(boolean b) {
+		isRawtype=b;
+    }
+	
+	
 
     /**
      * Returns a TypeX object representing the effective outermost enclosing type
