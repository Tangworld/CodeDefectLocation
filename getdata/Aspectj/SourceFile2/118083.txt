@@ -80,9 +80,8 @@ public class Ajc {
 	private int incrementalStage = 10;
 	private boolean shouldEmptySandbox = true;
 	private AjcCommandController controller;
-	private static boolean verbose = true; //(!System.getProperty("org.aspectj.tools.ajc.Ajc.verbose","false").equals("false"));
+	private static boolean verbose = System.getProperty("org.aspectj.tools.ajc.Ajc.verbose","false").equals("true");
 
-	
 	/**
 	 * Constructs a new Ajc instance, with a new AspectJ compiler
 	 * inside. 
@@ -14,6 +14,7 @@ package org.aspectj.tools.ajc;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
+import java.io.OutputStream;
 import java.io.PrintStream;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -25,13 +26,13 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.StringTokenizer;
 
+import junit.framework.TestCase;
+
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.testing.util.TestUtil;
 import org.aspectj.weaver.loadtime.WeavingURLClassLoader;
 
-import junit.framework.TestCase;
-
 /**
  * A TestCase class that acts as the superclass for all test cases wishing
  * to drive the ajc compiler.
@@ -51,9 +52,8 @@ import junit.framework.TestCase;
  * @see org.aspectj.testing.XMLBasedAjcTestCase
  */
 public class AjcTestCase extends TestCase {
-
-	private RunResult lastRunResult;
 
+	private RunResult lastRunResult;
 
 	/**
 	 * The Ajc (compiler) instance used for thet test. Created afresh
@@ -85,6 +85,17 @@ public class AjcTestCase extends TestCase {
 		+ File.pathSeparator+".."+File.separator+"lib"     +File.separator+"test"+File.separator+"aspectjrt.jar"
         ;
 
+	/*
+	 * Save reference to real stderr and stdout before starting redirection
+	 */
+	public final static PrintStream err = System.err;
+	public final static PrintStream out = System.out;
+	private final static DelegatingOutputStream delegatingErr;
+	private final static DelegatingOutputStream delegatingOut;
+	public final static boolean DEFAULT_VERBOSE = getBoolean("org.aspectj.tools.ajc.AjcTestCase.verbose",false); 
+	public final static boolean DEFAULT_ERR_VERBOSE = getBoolean("org.aspectj.tools.ajc.AjcTestCase.verbose.err",DEFAULT_VERBOSE); 
+	public final static boolean DEFAULT_OUT_VERBOSE = getBoolean("org.aspectj.tools.ajc.AjcTestCase.verbose.out",DEFAULT_VERBOSE); 
+
 	/**
 	 * Helper class that represents the specification of an individual
 	 * message expected to be produced during a compilation run.
@@ -562,8 +573,6 @@ public class AjcTestCase extends TestCase {
 			command.append(" ");
 			command.append(args[i]);
 		}
-		PrintStream systemOut = System.out;
-		PrintStream systemErr = System.err;
 		ByteArrayOutputStream baosOut = new ByteArrayOutputStream();
 		ByteArrayOutputStream baosErr = new ByteArrayOutputStream();
 		StringTokenizer strTok = new StringTokenizer(classpath,File.pathSeparator);
@@ -593,8 +602,8 @@ public class AjcTestCase extends TestCase {
 			} catch (Exception ex) {
 				fail ("Unable to prepare org.aspectj.testing.Tester for test run: " + ex);
 			}
-			System.setOut(new PrintStream(baosOut));
-			System.setErr(new PrintStream(baosErr));
+			startCapture(baosErr,baosOut);
+			
 			Class toRun = cLoader.loadClass(className);
 			Method mainMethod = toRun.getMethod("main",new Class[] {String[].class});
 			mainMethod.invoke(null,new Object[] {args});
@@ -609,8 +618,7 @@ public class AjcTestCase extends TestCase {
 			// the main method threw an exception...
             fail("Exception thrown by " + className + ".main(String[]) :" + invTgt.getTargetException());
 		} finally {
-			System.setOut(systemOut);
-			System.setErr(systemErr);
+			stopCapture(baosErr,baosOut);
 		}
 		return lastRunResult;
 	}
@@ -733,6 +741,28 @@ public class AjcTestCase extends TestCase {
 		}
 	}
 
+	private static void startCapture (OutputStream errOS, OutputStream outOS) {
+		delegatingErr.add(errOS);
+		delegatingOut.add(outOS);
+
+		delegatingErr.setVerbose(DEFAULT_ERR_VERBOSE);
+		delegatingOut.setVerbose(DEFAULT_OUT_VERBOSE);
+	}
+	
+	private static void stopCapture (OutputStream errOS, OutputStream outOS) {
+		delegatingErr.setVerbose(true);
+		delegatingOut.setVerbose(true);
+
+		delegatingErr.remove(errOS);
+		delegatingOut.remove(outOS);
+	}
+	
+	private static boolean getBoolean (String name, boolean def) {
+		String defaultValue = String.valueOf(def);
+		String value = System.getProperty(name,defaultValue);
+		return Boolean.valueOf(value).booleanValue();
+	}
+	
 	/* (non-Javadoc)
 	 * @see junit.framework.TestCase#setUp()
 	 */
@@ -747,4 +777,12 @@ public class AjcTestCase extends TestCase {
 		super.tearDown();
         //ajc = null;
 	}
+	
+	static {
+//		new RuntimeException("*** AjcTestCase.<clinit>()").printStackTrace();
+		delegatingErr = new DelegatingOutputStream(err);
+		System.setErr(new PrintStream(delegatingErr));
+		delegatingOut = new DelegatingOutputStream(out);
+		System.setOut(new PrintStream(delegatingOut));
+	}
 }
@@ -0,0 +1,91 @@
+/*******************************************************************************
+ * Copyright (c) 2005 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Common Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/cpl-v10.html
+ * 
+ * Contributors:
+ *     Matthew Webster - initial implementation
+ *******************************************************************************/
+package org.aspectj.tools.ajc;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+
+public class DelegatingOutputStream extends OutputStream {
+
+	private boolean verbose = true;
+	private OutputStream target;
+	private List delegates;
+	
+	public DelegatingOutputStream (OutputStream os) {
+		this.target = os;
+		this.delegates = new LinkedList();
+	}
+	
+	public void close() throws IOException {
+		target.close();
+		
+		for (Iterator i = delegates.iterator(); i.hasNext();) {
+			OutputStream delegate = (OutputStream)i.next();
+			delegate.close();
+		}
+	}
+
+	public void flush() throws IOException {
+		target.flush();
+		
+		for (Iterator i = delegates.iterator(); i.hasNext();) {
+			OutputStream delegate = (OutputStream)i.next();
+			delegate.flush();
+		}
+	}
+
+	public void write(byte[] b, int off, int len) throws IOException {
+		if (verbose) target.write(b, off, len);
+		
+		for (Iterator i = delegates.iterator(); i.hasNext();) {
+			OutputStream delegate = (OutputStream)i.next();
+			delegate.write(b,off,len);
+		}
+	}
+
+	public void write(byte[] b) throws IOException {
+		if (verbose) target.write(b);
+		
+		for (Iterator i = delegates.iterator(); i.hasNext();) {
+			OutputStream delegate = (OutputStream)i.next();
+			delegate.write(b);
+		}
+	}
+
+	public void write(int b) throws IOException {
+		if (verbose) target.write(b);
+		
+		for (Iterator i = delegates.iterator(); i.hasNext();) {
+			OutputStream delegate = (OutputStream)i.next();
+			delegate.write(b);
+		}
+	}
+	
+	public boolean add (OutputStream delegate) {
+		return delegates.add(delegate);
+	}
+	
+	public boolean remove (OutputStream delegate) {
+		return delegates.remove(delegate);
+	}
+
+	public boolean isVerbose() {
+		return verbose;
+	}
+
+	public void setVerbose(boolean verbose) {
+		this.verbose = verbose;
+	}
+	
+}
