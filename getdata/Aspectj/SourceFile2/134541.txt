@@ -0,0 +1,8 @@
+public aspect A {
+	
+	pointcut p() : execution(* *.*(..));
+	
+	before() : p() {
+	}
+	
+}
@@ -0,0 +1,10 @@
+public aspect A {
+	
+	pointcut p() : execution(* *.*(..));
+	
+	
+	
+	before() : p() {
+	}
+	
+}
@@ -846,6 +846,20 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 				  decisions.indexOf(expect)!=-1);
 	}
 
+	public void testPr134541() {
+		initialiseProject("PR134541");
+		build("PR134541");
+		assertEquals("[Xlint:adviceDidNotMatch] should be associated with line 5",5,
+				((IMessage)MyTaskListManager.getWarningMessages().get(0)).getSourceLocation().getLine());
+		alter("PR134541","inc1");
+		build("PR134541");
+		checkWasntFullBuild(); // we've only added a white space therefore we 
+		                       // shouldn't be doing a full build
+		assertEquals("[Xlint:adviceDidNotMatch] should now be associated with line 7",7,
+				((IMessage)MyTaskListManager.getWarningMessages().get(0)).getSourceLocation().getLine());
+	}
+	
+	
 	// other possible tests:
 	// - memory usage (freemem calls?)
 	// - relationship map
@@ -238,8 +238,12 @@ public class CrosscuttingMembers {
 			}
 			if (!theseShadowMungers.equals(otherShadowMungers)) {
 				changed = true;
-				shadowMungers = other.shadowMungers;
 			}
+			// replace the existing list of shadowmungers with the 
+			// new ones in case anything like the sourcelocation has
+			// changed, however, don't want this flagged as a change
+			// which will force a full build - bug 134541
+			shadowMungers = other.shadowMungers;
   	    }
 
 		// bug 129163: use set equality rather than list equality and
@@ -76,6 +76,11 @@ public class CrosscuttingMembersSet {
 				CflowPointcut.clearCaches(aspectType);
 				change = true;
 			} else {
+				if (careAboutShadowMungers) {
+					// bug 134541 - even though we haven't changed we may have updated the 
+					// sourcelocation for the shadowMunger which we need to pick up
+					shadowMungers = null;
+				}
 				change = false;
 			}
 		}
