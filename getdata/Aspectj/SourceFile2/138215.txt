@@ -34,7 +34,7 @@ public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testIncorrectOverridesEvaluation15() { runTest("incorrect overrides evaluation - 1.5"); }
 
   // known failures, uncomment when working.
-//  public void testReferencePCutInDeclareWarning_pr138215() { runTest("Reference pointcut fails inside @DeclareWarning");}
+  public void testReferencePCutInDeclareWarning_pr138215() { runTest("Reference pointcut fails inside @DeclareWarning");}
 //  public void testReferencePCutInPerClause_pr138219() { runTest("Can't use a FQ Reference pointcut in any pointcut expression referenced by a per-clause");}
 //  public void testDoubleAnnotationMatching_pr138223() { runTest("Double at annotation matching (no binding)");}
 
@@ -1236,17 +1236,10 @@ public class AtAjAttributes {
                     reportError("@DeclareError used on a non String constant field", struct);
                     return false;
                 }
-                FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
-                IScope binding = new BindingScope(
-                        struct.enclosingType,
-                        struct.context,
-                        bindings
-                );
                 Pointcut pc = parsePointcut(declareError.getValue().stringifyValue(), struct, false);
                 if (pc == null) {
                     hasError = false;//cannot parse pointcut
-                } else {
-                    pc .resolve(binding);
+                } else {                	 
                     DeclareErrorOrWarning deow = new DeclareErrorOrWarning(true, pc, struct.field.getConstantValue().toString());
                     setDeclareErrorOrWarningLocation(deow,struct);
                     struct.ajAttributes.add(new AjAttribute.DeclareAttribute(deow));
@@ -1263,17 +1256,10 @@ public class AtAjAttributes {
                     reportError("@DeclareWarning used on a non String constant field", struct);
                     return false;
                 }
-                FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
-                IScope binding = new BindingScope(
-                        struct.enclosingType,
-                        struct.context,
-                        bindings
-                );
                 Pointcut pc = parsePointcut(declareWarning.getValue().stringifyValue(), struct, false);
                 if (pc == null) {
                     hasWarning = false;//cannot parse pointcut
                 } else {
-                    pc.resolve(binding);
                     DeclareErrorOrWarning deow = new DeclareErrorOrWarning(false, pc, struct.field.getConstantValue().toString());
                     setDeclareErrorOrWarningLocation(deow,struct);
                     struct.ajAttributes.add(new AjAttribute.DeclareAttribute(deow));
@@ -48,7 +48,12 @@ import org.aspectj.weaver.TypeVariable;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.WeaverStateInfo;
 import org.aspectj.weaver.World;
+import org.aspectj.weaver.bcel.AtAjAttributes.BindingScope;
 import org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.GenericSignatureFormatException;
+import org.aspectj.weaver.patterns.Declare;
+import org.aspectj.weaver.patterns.DeclareErrorOrWarning;
+import org.aspectj.weaver.patterns.FormalBinding;
+import org.aspectj.weaver.patterns.IScope;
 import org.aspectj.weaver.patterns.PerClause;
 
 public class BcelObjectType extends AbstractReferenceTypeDelegate {
@@ -304,6 +309,8 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 
 		this.pointcuts = (ResolvedPointcutDefinition[]) 
 			pointcuts.toArray(new ResolvedPointcutDefinition[pointcuts.size()]);
+		
+		resolveAnnotationDeclares(l);
 
 		if (deferredAspectAttribute != null) {
 			// we can finally process the aspect and its associated perclause...
@@ -348,6 +355,29 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 		}
 		return deferredAspectAttribute;
 	}
+    
+    /**
+     * Extra processing step needed because declares that come from annotations are not pre-resolved.
+     * We can't do the resolution until *after* the pointcuts have been resolved.
+     * @param attributeList
+     */
+    private void resolveAnnotationDeclares(List attributeList) {
+    	FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
+        IScope bindingScope = new BindingScope(
+                getResolvedTypeX(),
+                getResolvedTypeX().getSourceContext(),
+                bindings
+        );
+		for (Iterator iter = attributeList.iterator(); iter.hasNext();) {
+			AjAttribute a = (AjAttribute) iter.next();
+			if (a instanceof AjAttribute.DeclareAttribute) {
+				Declare decl = (((AjAttribute.DeclareAttribute)a).getDeclare());
+				if (decl instanceof DeclareErrorOrWarning) {
+				  decl.resolve(bindingScope);
+				}
+			}
+		}    	
+    }
 
 	public PerClause getPerClause() {
         ensureAspectJAttributesUnpacked();
