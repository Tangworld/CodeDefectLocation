@@ -0,0 +1,35 @@
+/**
+ * Copyright (c) 2005 IBM and other contributors
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Common Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://www.eclipse.org/legal/cpl-v10.html 
+ *  
+ * Contributors: 
+ *     Andy Clement     initial implementation 
+ * ******************************************************************/
+package org.aspectj.ajdt.internal.core.builder;
+
+import java.io.File;
+import java.util.List;
+
+/**
+ * Subtypes can override whatever they want...
+ * 
+ * @author AndyClement
+ *
+ */
+public abstract class AbstractStateListener implements IStateListener {
+
+	public void detectedClassChangeInThisDir(File f) {	}
+
+	public void aboutToCompareClasspaths(List oldClasspath, List newClasspath) {	}
+
+	public void pathChangeDetected() {	}
+
+	public void detectedAspectDeleted(File f) {	}
+
+	public void buildSuccessful(boolean wasFullBuild) {	}
+
+}
@@ -38,6 +38,7 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.classfmt.ClassFormatExcepti
 import org.aspectj.org.eclipse.jdt.internal.core.builder.ReferenceCollection;
 import org.aspectj.org.eclipse.jdt.internal.core.builder.StringSet;
 import org.aspectj.util.FileUtil;
+import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.bcel.BcelWeaver;
 import org.aspectj.weaver.bcel.BcelWorld;
 import org.aspectj.weaver.bcel.UnwovenClassFile;
@@ -147,11 +148,44 @@ public class AjState {
 		addedBinaryFiles.removeAll(oldBinaryFiles);
 		deletedBinaryFiles = new HashSet(oldBinaryFiles);
 		deletedBinaryFiles.removeAll(newBinaryFiles);
+			
+		boolean couldStillBeIncremental = processDeletedFiles(deletedFiles);
+		
+		if (!couldStillBeIncremental) return false;
 
 		this.newBuildConfig = newBuildConfig;
 
 		return true;
 	}
+		
+	/**
+	 * Checks if any of the files in the set passed in contains an aspect declaration.  If one is found
+	 * then we start the process of batch building, i.e. we remove all the results of the last build,
+	 * call any registered listener to tell them whats happened and return false.
+	 * 
+	 * @return false if we discovered an aspect declaration
+	 */
+    private boolean processDeletedFiles(Set deletedFiles) {
+		for (Iterator iter = deletedFiles.iterator(); iter.hasNext();) {
+			File  aDeletedFile = (File ) iter.next();
+			InterimCompilationResult cr = (InterimCompilationResult)resultsFromFile.get(aDeletedFile);
+			if (cr!=null) {
+				Map compiledTypes = cr.result().compiledTypes;
+				if (compiledTypes!=null) {
+					for (Iterator iterator = compiledTypes.keySet().iterator(); iterator.hasNext();) {
+						char[] className = (char[])iterator.next();
+						ResolvedType rt = world.resolve(new String(className).replace('/','.'));
+						if (rt.isAspect()) { 
+							removeAllResultsOfLastBuild();
+							if (stateListener!=null) stateListener.detectedAspectDeleted(aDeletedFile);
+							return false;
+						}
+					}
+				}
+			}
+		}
+		return true;
+    }
 
 	private Collection getModifiedFiles() {		
 		return getModifiedFiles(lastSuccessfulBuildTime);
@@ -32,6 +32,12 @@ public interface IStateListener {
 	public void aboutToCompareClasspaths(List oldClasspath, List newClasspath);
 
 	public void pathChangeDetected();
+	
+	/**
+	 * Called if state processing detects a file was deleted that contained an aspect declaration.
+	 * Incremental compilation will not be attempted if this occurs.
+	 */
+	public void detectedAspectDeleted(File f);
 
 	public void buildSuccessful(boolean wasFullBuild);
 
@@ -14,8 +14,8 @@ import java.util.List;
 
 import junit.framework.Test;
 
+import org.aspectj.ajdt.internal.core.builder.AbstractStateListener;
 import org.aspectj.ajdt.internal.core.builder.AjState;
-import org.aspectj.ajdt.internal.core.builder.IStateListener;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class IncrementalTests extends org.aspectj.testing.XMLBasedAjcTestCase {
@@ -112,7 +112,7 @@ public class IncrementalTests extends org.aspectj.testing.XMLBasedAjcTestCase {
    * being on the classpath.  This test verifies the fix is OK
    */
   public void testIncrementalOKWithOutputPathOnClasspath() throws Exception {
-	  class MyStateListener implements IStateListener {
+	  class MyStateListener extends AbstractStateListener {
   	    public boolean pathChange = false;
 		public void pathChangeDetected() {pathChange = true;}
 		public void aboutToCompareClasspaths(List oldClasspath, List newClasspath) {}
@@ -29,8 +29,8 @@ import org.aspectj.ajde.BuildProgressMonitor;
 import org.aspectj.ajde.ErrorHandler;
 import org.aspectj.ajde.ProjectPropertiesAdapter;
 import org.aspectj.ajde.TaskListManager;
+import org.aspectj.ajdt.internal.core.builder.AbstractStateListener;
 import org.aspectj.ajdt.internal.core.builder.AjState;
-import org.aspectj.ajdt.internal.core.builder.IStateListener;
 import org.aspectj.ajdt.internal.core.builder.IncrementalStateManager;
 import org.aspectj.asm.AsmManager;
 import org.aspectj.bridge.IMessage;
@@ -694,7 +694,7 @@ public class AjdeInteractionTestbed extends TestCase {
 		}
 	}
 
-	static class MyStateListener implements IStateListener {
+	static class MyStateListener extends AbstractStateListener {
 
 		private static MyStateListener _instance = new MyStateListener();
 		private MyStateListener() {reset();}
@@ -368,17 +368,17 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 					.getMessage());
 	}
 
-//	public void testPr112736() {
-//		AjdeInteractionTestbed.VERBOSE = true;
-//		initialiseProject("PR112736");
-//		build("PR112736");
-//		checkWasFullBuild();
-//		String fileC2 = getWorkingDir().getAbsolutePath() + File.separatorChar + "PR112736" + File.separatorChar + "src" + File.separatorChar + "pack" + File.separatorChar + "A.java";
-//		(new File(fileC2)).delete();
-//		alter("PR112736","inc1");
-//		build("PR112736");
-//		checkWasntFullBuild();
-//	}
+	public void testPr112736() {
+		AjdeInteractionTestbed.VERBOSE = true;
+		initialiseProject("PR112736");
+		build("PR112736");
+		checkWasFullBuild();
+		String fileC2 = getWorkingDir().getAbsolutePath() + File.separatorChar + "PR112736" + File.separatorChar + "src" + File.separatorChar + "pack" + File.separatorChar + "A.java";
+		(new File(fileC2)).delete();
+		alter("PR112736","inc1");
+		build("PR112736");
+		checkWasFullBuild();
+	}
 
 
 	// other possible tests:
