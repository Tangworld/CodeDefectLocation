@@ -661,7 +661,11 @@ public abstract class World implements Dump.INode {
 	}
 
 	public boolean isTargettingAspectJRuntime12() {
-		return getTargetAspectjRuntimeLevel().equals(org.aspectj.weaver.Constants.RUNTIME_LEVEL_12);
+		boolean b = false; // pr116679
+		if (!isInJava5Mode()) b=true;
+		else b = getTargetAspectjRuntimeLevel().equals(org.aspectj.weaver.Constants.RUNTIME_LEVEL_12);
+		//System.err.println("Asked if targetting runtime 1.2 , returning: "+b);
+		return b;
 	}
 
 	/*
@@ -30,6 +30,16 @@ public class TjpWeaveTestCase extends WeaveTestCase {
 	public TjpWeaveTestCase(String name) {
 		super(name);
 	}
+	
+	public void setUp() {
+		super.setUp();
+		behave15=true;
+	}
+
+	public void tearDown() throws Exception {
+		super.tearDown();
+		behave15=false;
+	}
 
 
     public void testStaticTjp() throws IOException {
@@ -28,6 +28,7 @@ public abstract class WeaveTestCase extends TestCase {
 
 	public boolean regenerate = false;
 	public boolean runTests = true;
+	public boolean behave15 = false;
 
     File outDir;
     String outDirPath;
@@ -75,12 +76,17 @@ public abstract class WeaveTestCase extends TestCase {
 
 	public void weaveTest(String name, String outName, List planners) throws IOException {
         BcelWeaver weaver = new BcelWeaver(world);
+        try {
+          if (behave15) world.setBehaveInJava5Way(true);
 
-        UnwovenClassFile classFile = makeUnwovenClassFile(classDir, name, outDirPath); 
+          UnwovenClassFile classFile = makeUnwovenClassFile(classDir, name, outDirPath); 
 
-        weaver.addClassFile(classFile);
-        weaver.setShadowMungers(planners);
-        weaveTestInner(weaver, classFile, name, outName);
+          weaver.addClassFile(classFile);
+          weaver.setShadowMungers(planners);
+          weaveTestInner(weaver, classFile, name, outName);
+        } finally {
+         if (behave15)  world.setBehaveInJava5Way(false);
+        }
 	}
 
 
@@ -0,0 +1,20 @@
+public class A {
+  public static void main(String []argv) {
+    try {
+      new A().foo();
+    } catch (Exception e) {
+    }
+  }
+
+  public void foo() {
+    try {
+    } catch (Exception e) {
+    }
+  }
+}
+ 
+
+aspect ComplexSub extends TrackingErrors {
+  public pointcut errorScope(): within(A);
+}
+  
@@ -0,0 +1,86 @@
+import org.aspectj.lang.*;
+
+import org.aspectj.lang.JoinPoint;
+
+public abstract aspect TrackingErrors {
+
+   protected abstract pointcut errorScope ();
+
+   private pointcut staticContext () : !this(Object);
+   private pointcut nonStaticContext (Object obj) : this(obj);
+   private pointcut caughtThrowable (Throwable th) : handler(Throwable+)
+           && args(th);
+
+
+
+   private pointcut excluded () : within(TrackingErrors+);
+
+   before (Throwable th) : caughtThrowable(th) && errorScope() &&
+           !excluded() && staticContext() {
+
+           processStaticTrackingErrors(th,thisJoinPointStaticPart,thisEnclosingJoinPointStaticPart);
+   }
+
+   before (Throwable th, Object obj) : caughtThrowable(th) && errorScope()
+           && !excluded() && nonStaticContext(obj) {
+
+           processNonStaticTrackingErrors(th,obj,thisJoinPointStaticPart,thisEnclosingJoinPointStaticPart);
+   }
+
+   protected  void processStaticTrackingErrors (Throwable th,
+           JoinPoint.StaticPart tjp, JoinPoint.StaticPart ejp) {}
+
+   protected void processNonStaticTrackingErrors (Throwable th, Object obj,
+           JoinPoint.StaticPart tjp, JoinPoint.StaticPart ejp) {}
+
+   protected String getSourceId (JoinPoint.StaticPart ejp) {
+                 String typeName =
+           ejp.getSignature().getDeclaringTypeName();
+                 String name = ejp.getSignature().getName();
+           return typeName + "." + name;
+   }
+
+   protected String getProbeId (JoinPoint.StaticPart tjp) {
+                 String sourceLocation =
+           tjp.getSourceLocation().toString();
+           return sourceLocation;
+   }
+
+}
+/*public abstract aspect Complex {
+    
+    protected abstract pointcut scope ();
+    
+    private pointcut staticContext () : !this(Object);
+    private pointcut nonStaticContext (Object obj) : this(obj);
+    private pointcut caughtThrowable (Throwable th) : handler(Throwable+) && args(th);
+ 
+    private pointcut excluded () : within(Complex+);
+ 
+    before (Throwable th) : caughtThrowable(th) && scope() && !excluded() && staticContext() {
+       processStaticData(th,thisJoinPointStaticPart,thisEnclosingJoinPointStaticPart);
+    }
+ 
+    before (Throwable th, Object obj) : caughtThrowable(th) && scope() && !excluded() && nonStaticContext(obj) {
+       processNonStaticData(th,obj,thisJoinPointStaticPart,thisEnclosingJoinPointStaticPart);
+    }
+    
+    private void processStaticData (Throwable th, JoinPoint.StaticPart tjp, JoinPoint.StaticPart ejp) {
+    }
+ 
+    private void processNonStaticData (Throwable th, Object obj, JoinPoint.StaticPart tjp, JoinPoint.StaticPart ejp) {
+    }
+ 
+    protected String getSourceId (JoinPoint.StaticPart ejp) {
+        String typeName = ejp.getSignature().getDeclaringTypeName();
+        String name = ejp.getSignature().getName();
+        return typeName + "." + name;
+    }
+ 
+    protected String getProbeId (JoinPoint.StaticPart tjp) {
+        String sourceLocation = String.valueOf(tjp.getSourceLocation().getLine());
+        return sourceLocation;
+    }
+ 
+}
+*/
@@ -48,7 +48,8 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testCunningDeclareParents_pr92311() { runTest("cunning declare parents");}
   public void testGenericITDsAndAbstractMethodError_pr102357() { runTest("generic itds and abstract method error");}
   */
-  public void testGeneratingCodeForAnOldRuntime_pr116679() { runTest("generating code for a 1.2.1 runtime");}
+  public void testGeneratingCodeForAnOldRuntime_pr116679_1() { runTest("generating code for a 1.2.1 runtime - 1");}
+  public void testGeneratingCodeForAnOldRuntime_pr116679_2() { runTest("generating code for a 1.2.1 runtime - 2");}
 
   public void testAtDeclareParents_pr117681() { runTest("at declare parents");}
   public void testPrivilegeProblem_pr87525() { runTest("privilege problem with switch");}
@@ -113,17 +113,21 @@
 		<run class="ReflectOnAjcCompiledPointcuts" classpath="../lib/bcel/bcel.jar"/>
 	</ajc-test>
 
-	<ajc-test dir="compatibility" title="generating code for a 1.2.1 runtime">
-		<compile files="Simple.java" options="-Xajruntimetarget:1.2"></compile>
+	<ajc-test dir="compatibility/case1" title="generating code for a 1.2.1 runtime - 1">
+		<compile files="Simple.java" options="-Xajruntimetarget:1.2"/>
 		<run class="Simple" classpath="../lib/aspectj/lib/aspectjrt121.jar"/>
 	</ajc-test>
-	
+
+	<ajc-test dir="compatibility/case2" title="generating code for a 1.2.1 runtime - 2">
+		<compile files="TrackingErrors.aj,A.java" options="-Xajruntimetarget:1.2"/>
+		<run class="A" classpath="../lib/aspectj/lib/aspectjrt121.jar"/>
+	</ajc-test>
+		
 	<ajc-test dir="java5/reflection" title="arg names in advice annotations">
 		<compile files="AdviceWithArgs.aj" options="-1.5"></compile>
 		<run class="AdviceWithArgs"/>
 	</ajc-test>
-	
-	
+
 	<ajc-test dir="java5/reflection" pr="114322" title="reflection on abstract ITDs (Billing example)">
 		<compile files="ReflectBilling.java,Billing.aj" options="-1.5"/>
 		<run class="ReflectBilling">
@@ -1179,11 +1179,17 @@ public class BcelShadow extends Shadow {
     public BcelVar getThisJoinPointStaticPartBcelVar(final boolean isEnclosingJp) {
     	if (thisJoinPointStaticPartVar == null) {
     		Field field = getEnclosingClass().getTjpField(this, isEnclosingJp);
-    		thisJoinPointStaticPartVar =
-    			new BcelFieldRef(
-    				isEnclosingJp?
-                        world.getCoreType(UnresolvedType.forName("org.aspectj.lang.JoinPoint$EnclosingStaticPart")):
-                        world.getCoreType(UnresolvedType.forName("org.aspectj.lang.JoinPoint$StaticPart")),
+    		
+    			ResolvedType sjpType = null;
+    	       	if (world.isTargettingAspectJRuntime12()) { // TAG:SUPPORTING12: We didn't have different jpsp types in 1.2	
+    		    	sjpType = world.getCoreType(UnresolvedType.forName("org.aspectj.lang.JoinPoint$StaticPart"));
+    		    } else {
+    		    	sjpType = isEnclosingJp?
+                              world.getCoreType(UnresolvedType.forName("org.aspectj.lang.JoinPoint$EnclosingStaticPart")):
+                              world.getCoreType(UnresolvedType.forName("org.aspectj.lang.JoinPoint$StaticPart"));
+    		    }
+    		    thisJoinPointStaticPartVar = new BcelFieldRef(
+    				sjpType,
     				getEnclosingClass().getClassName(),
     				field.getName());
 //    		getEnclosingClass().warnOnAddedStaticInitializer(this,munger.getSourceLocation());
@@ -901,10 +901,13 @@ public final class LazyClassGen {
 		else {
 			modifiers |= Modifier.PRIVATE;
 		}
-		ret = new FieldGen(modifiers,
-    		isEnclosingJp?enclosingStaticTjpType:staticTjpType,
-    		"ajc$tjp_" + tjpFields.size(),
-    		getConstantPoolGen()).getField();
+		ObjectType jpType = null;
+		if (world.isTargettingAspectJRuntime12()) { // TAG:SUPPORTING12: We didn't have different staticjp types in 1.2
+			jpType = staticTjpType;
+		} else {
+			jpType = isEnclosingJp?enclosingStaticTjpType:staticTjpType;
+		}
+		ret = new FieldGen(modifiers,jpType,"ajc$tjp_" + tjpFields.size(),getConstantPoolGen()).getField();
     	addField(ret);
     	tjpFields.put(shadow, ret);
     	return ret;
@@ -999,7 +1002,7 @@ public final class LazyClassGen {
     	// create the signature
     	list.append(InstructionFactory.createLoad(factoryType, 0));
 
-    	if (world.getTargetAspectjRuntimeLevel().equals(org.aspectj.weaver.Constants.RUNTIME_LEVEL_12)) {
+    	if (world.isTargettingAspectJRuntime12()) { // TAG:SUPPORTING12: We didn't have optimized factory methods in 1.2
         	list.append(new PUSH(getConstantPoolGen(), sig.getSignatureString(shadow.getWorld())));
     		list.append(fact.createInvoke(factoryType.getClassName(), 
     					sig.getSignatureMakerName(),
@@ -1091,21 +1094,31 @@ public final class LazyClassGen {
     	list.append(Utility.createConstant(fact, shadow.getSourceLine()));
 
         final String factoryMethod;
-        if (staticTjpType.equals(field.getType())) {
-            factoryMethod = "makeSJP";
-        } else if (enclosingStaticTjpType.equals(field.getType())) {
-            factoryMethod = "makeESJP";
+        
+       	if (world.isTargettingAspectJRuntime12()) { // TAG:SUPPORTING12: We didn't have makeESJP() in 1.2    	
+        	list.append(fact.createInvoke(factoryType.getClassName(),
+        			"makeSJP", staticTjpType, 
+        			new Type[] { Type.STRING, sigType, Type.INT},
+        			Constants.INVOKEVIRTUAL));
+        	
+        	// put it in the field	
+        	list.append(fact.createFieldAccess(getClassName(), field.getName(),staticTjpType, Constants.PUTSTATIC));
+        
         } else {
-            throw new Error("should not happen");
-        }
-    	list.append(fact.createInvoke(factoryType.getClassName(),
-    			factoryMethod, field.getType(),
-    			new Type[] { Type.STRING, sigType, Type.INT},
-    			Constants.INVOKEVIRTUAL));
-    	
-    	// put it in the field	
-    	list.append(fact.createFieldAccess(getClassName(), field.getName(),
-    		field.getType(), Constants.PUTSTATIC));
+	        if (staticTjpType.equals(field.getType())) {
+	            factoryMethod = "makeSJP";
+	        } else if (enclosingStaticTjpType.equals(field.getType())) {
+	            factoryMethod = "makeESJP";
+	        } else {
+	            throw new Error("should not happen");
+	        }
+	    	list.append(fact.createInvoke(factoryType.getClassName(),
+	    			factoryMethod, field.getType(),
+	    			new Type[] { Type.STRING, sigType, Type.INT},
+	    			Constants.INVOKEVIRTUAL));
+	    	// put it in the field	
+	    	list.append(fact.createFieldAccess(getClassName(), field.getName(), field.getType(), Constants.PUTSTATIC));
+    	}
     }
 
 
