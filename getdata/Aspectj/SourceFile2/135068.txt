@@ -282,6 +282,7 @@ public class ValidateAtAspectJAnnotationsVisitor extends ASTVisitor {
 	 * 3) Advice must not have any other @AspectJ annotations
 	 * 4) After throwing advice must declare the thrown formal
 	 * 5) After returning advice must declare the returning formal
+	 * 6) Advice must not be static
 	 */
 	private void validateAdvice(MethodDeclaration methodDeclaration) {
 
@@ -295,6 +296,11 @@ public class ValidateAtAspectJAnnotationsVisitor extends ASTVisitor {
 			methodDeclaration.scope.problemReporter()
 				.signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,"advice must be public");
 		}
+
+		if (Modifier.isStatic(methodDeclaration.modifiers)) {
+			methodDeclaration.scope.problemReporter()
+				.signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,"advice can not be declared static");
+		}
 
 		if (ajAnnotations.hasMultipleAdviceAnnotations) {
 			methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.duplicateAdviceAnnotation);
@@ -0,0 +1,3 @@
+aspect A {
+  static before(): call(* *(..)) {}
+}
@@ -0,0 +1,8 @@
+import java.net.InetAddress;
+
+public aspect Aaj {
+
+	InetAddress around() throws java.net.UnknownHostException : call(public java.net.InetAddress C.getAddress() throws java.net.UnknownHostException) {
+		return InetAddress.getLocalHost();
+	}
+}
@@ -0,0 +1,16 @@
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
+import org.aspectj.lang.annotation.Around;
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.*;
+
+@Aspect
+public class Ajava {
+
+	@Around("call(public java.net.InetAddress C.getAddress() throws java.net.UnknownHostException)")
+	public InetAddress getAddress() throws UnknownHostException {
+		return InetAddress.getLocalHost();
+	}
+}
@@ -0,0 +1,16 @@
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
+import org.aspectj.lang.annotation.Around;
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.*;
+
+@Aspect
+public class Ajava2 {
+
+	@Around("call(public java.net.InetAddress C2.getAddress() throws java.net.UnknownHostException)")
+	public static InetAddress getAddress() throws UnknownHostException {
+		return InetAddress.getLocalHost();
+	}
+}
@@ -0,0 +1,14 @@
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
+public class C {
+
+	public static InetAddress getAddress() throws UnknownHostException {
+		return null;
+	}
+	
+	public static void main(String[] args) throws Exception {
+		System.out.println(getAddress().toString());
+	}
+}
@@ -0,0 +1,14 @@
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
+public class C2 {
+
+	public static InetAddress getAddress() throws UnknownHostException {
+		return null;
+	}
+	
+	public static void main(String[] args) throws Exception {
+		System.out.println(getAddress().toString());
+	}
+}
@@ -0,0 +1,9 @@
+<aspectj>
+  <aspects>
+    <aspect name="t.Ajava"/>
+  </aspects>
+
+  <weaver>
+    <include within="t..*"/>
+  </weaver>
+</aspectj>
@@ -0,0 +1,10 @@
+package t;
+
+import java.net.InetAddress;
+
+public aspect Aaj {
+
+	InetAddress around() throws java.net.UnknownHostException : call(public java.net.InetAddress t.C.getAddress() throws java.net.UnknownHostException) {
+		return InetAddress.getLocalHost();
+	}
+}
@@ -0,0 +1,16 @@
+package t;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
+import org.aspectj.lang.annotation.Around;
+import org.aspectj.lang.annotation.Aspect;
+
+@Aspect
+public class Ajava {
+
+	@Around("call(public java.net.InetAddress t.C.getAddress() throws java.net.UnknownHostException)")
+	public InetAddress getAddress() throws UnknownHostException {
+		return InetAddress.getLocalHost();
+	}
+}
@@ -0,0 +1,16 @@
+package t;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
+import org.aspectj.lang.annotation.Around;
+import org.aspectj.lang.annotation.Aspect;
+
+@Aspect
+public class Ajava2 {
+
+	@Around("call(public java.net.InetAddress t.C2.getAddress() throws java.net.UnknownHostException)")
+	public static InetAddress getAddress() throws UnknownHostException {
+		return InetAddress.getLocalHost();
+	}
+}
@@ -0,0 +1,20 @@
+package t;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
+public class C {
+
+	public InetAddress getAddress() throws UnknownHostException {
+		return null;
+	}
+	
+	private void test() throws UnknownHostException {
+		System.out.println(getAddress().toString());
+	}
+
+	public static void main(String[] args) throws Exception {
+		C c = new C();
+		c.test();
+	}
+}
@@ -0,0 +1,20 @@
+package t;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
+public class C2 {
+
+	public InetAddress getAddress() throws UnknownHostException {
+		return null;
+	}
+	
+	private void test() throws UnknownHostException {
+		System.out.println(getAddress().toString());
+	}
+
+	public static void main(String[] args) throws Exception {
+		C2 c = new C2();
+		c.test();
+	}
+}
@@ -17,6 +17,10 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+  public void testVerifyErrorLTW_pr135068() { runTest("ltw verifyerror");}
+  public void testVerifyErrorLTW_pr135068_2() { runTest("ltw verifyerror - 2");}
+  public void testVerifyErrorLTW_pr135068_3() { runTest("ltw verifyerror - 3");}
+  public void testVerifyErrorLTW_pr135068_4() { runTest("ltw verifyerror - 4");}
   public void testVerifyErrorForComplexCflow_pr136026() { runTest("verifyerror");}
   public void testVerifyErrorForComplexCflow_pr136026_2() { runTest("verifyerror - 2");}
   public void testAnnotationsAndGenericsBCException_pr129704() { runTest("annotations and generics leading to BCException");}
@@ -272,4 +272,31 @@
 	    <message kind="error" line="16" text="Stystems cannot be resolved"/>
 	  </compile>
 	</ajc-test>
+	
+	<ajc-test dir="bugs152/pr135068" title="ltw verifyerror">
+	    <compile files="C.java,Ajava.java" options="-1.5 -XnoInline"/>
+	    <run class="C"/>
+    </ajc-test>
+    
+    	<ajc-test dir="bugs152/pr135068" title="ltw verifyerror - 2">
+	    <compile files="C2.java,Ajava2.java" options="-1.5 -XnoInline">
+	      <message kind="error" line="13" text="advice can not be declared static"/>
+	    </compile>
+    </ajc-test>
+    
+    	<ajc-test dir="bugs152/pr135068" title="ltw verifyerror - 3">
+	    <compile files="t/C.java" options="-1.5"/>
+        <compile files="t/Ajava.java" options="-1.5">
+          <message kind="warning" line="13" text="advice defined"/>
+        </compile>
+        <run class="t.C" ltw="aop.xml"/>
+    </ajc-test>
+    
+    	<ajc-test dir="bugs152/pr135068" title="ltw verifyerror - 4">
+	    <compile files="t/C2.java" options="-1.5"/>
+        <compile files="t/Ajava2.java" options="-1.5">
+	      <message kind="error" line="13" text="advice can not be declared static"/>
+        </compile>
+    </ajc-test>
+    
 </suite>
\ No newline at end of file
@@ -40,6 +40,7 @@ import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.IMessageHandler;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.bridge.Message;
+import org.aspectj.bridge.MessageUtil;
 import org.aspectj.weaver.Advice;
 import org.aspectj.weaver.AdviceKind;
 import org.aspectj.weaver.AjAttribute;
@@ -435,6 +436,20 @@ public class AtAjAttributes {
             );
             ;// go ahead
         }
+        
+        // semantic check - advice must not be static
+        if (hasAtAspectJAnnotation && struct.method.isStatic()) {
+            msgHandler.handleMessage(MessageUtil.error("Advice cannot be declared static '" + methodToString(struct.method) + "'",type.getSourceLocation()));
+//                    new Message(
+//                            "Advice cannot be declared static '" + methodToString(struct.method) + "'",
+//                            IMessage.ERROR,
+//                            null,
+//                            type.getSourceLocation()
+//                    )
+//            );
+            ;// go ahead
+        }
+        
         // semantic check for non around advice must return void
         if (hasAtAspectJAnnotationMustReturnVoid && !Type.VOID.equals(struct.method.getReturnType())) {
             msgHandler.handleMessage(
