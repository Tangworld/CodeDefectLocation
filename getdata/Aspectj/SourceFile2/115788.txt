@@ -81,7 +81,10 @@ public class EclipseFactory {
 	private boolean xSerializableAspects;
 	private World world;
 
+	// We can get clashes if we don't treat raw types differently - we end up looking
+	// up a raw and getting the generic type (pr115788)
 	private Map/*UnresolvedType, TypeBinding*/ typexToBinding = new HashMap();
+	private Map/*UnresolvedType, TypeBinding*/ rawTypeXToBinding = new HashMap();
 	//XXX currently unused
 //	private Map/*TypeBinding, ResolvedType*/ bindingToResolvedTypeX = new HashMap();
 
@@ -447,7 +450,7 @@ public class EclipseFactory {
 	public ResolvedMember makeResolvedMember(MethodBinding binding) {
 		return makeResolvedMember(binding, binding.declaringClass);
 	}
-	
+
 	public ResolvedMember makeResolvedMember(MethodBinding binding, Shadow.Kind shadowKind) {
 		Member.Kind memberKind = binding.isConstructor() ? Member.CONSTRUCTOR : Member.METHOD;
 		if (shadowKind == Shadow.AdviceExecution) memberKind = Member.ADVICE;
@@ -486,7 +489,7 @@ public class EclipseFactory {
 		}
 		return result;
 	}
-	
+
 	public ResolvedMember makeResolvedMember(MethodBinding binding, TypeBinding declaringType) {
 		return makeResolvedMember(binding,declaringType,
 				binding.isConstructor() ? Member.CONSTRUCTOR : Member.METHOD);
@@ -556,21 +559,31 @@ public class EclipseFactory {
 		TypeBinding ret = null;
 
 		// looking up type variables can get us into trouble
-		if (!typeX.isTypeVariableReference())
-			ret = (TypeBinding)typexToBinding.get(typeX);
-			
+		if (!typeX.isTypeVariableReference()) {
+			if (typeX.isRawType()) {
+				ret = (TypeBinding)rawTypeXToBinding.get(typeX);
+			} else {
+				ret = (TypeBinding)typexToBinding.get(typeX);
+			}
+		}
+
 		if (ret == null) {
 			ret = makeTypeBinding1(typeX);
-			// FIXME asc keep type variables *out* of the map for now, they go in typeVariableToTypeBinding
-			if (!(typeX instanceof BoundedReferenceType) && !(typeX instanceof UnresolvedTypeVariableReferenceType)) 
-			  typexToBinding.put(typeX, ret);
+			if (!(typeX instanceof BoundedReferenceType) && 
+				!(typeX instanceof UnresolvedTypeVariableReferenceType)
+				) {
+			  if (typeX.isRawType()) {
+				  rawTypeXToBinding.put(typeX,ret);
+			  } else {
+				  typexToBinding.put(typeX, ret);
+			  }
+			}
 		}
 		if (ret == null) {
 			System.out.println("can't find: " + typeX);
 		}
 		return ret;
 	}
-	
 	// When converting a parameterized type from our world to the eclipse world, these get set so that
 	// resolution of the type parameters may known in what context it is occurring (pr114744)
 	private ReferenceBinding baseTypeForParameterizedType;
@@ -435,6 +435,19 @@ public class AjProblemReporter extends ProblemReporter {
     }
 
     /**
+     * The method verifier is a bit 'keen' and doesn't cope well with ITDMs which are
+     * of course to be considered a 'default' implementation if the target type doesn't
+     * supply one.  This test may not be complete - it is possible that it should read if
+     * *either* is an ITD...but I dont have a testcase that shows that is required. yet.
+     * (pr115788)
+     */
+    public void duplicateInheritedMethods(SourceTypeBinding type, MethodBinding inheritedMethod1, MethodBinding inheritedMethod2) {
+    	if (!(inheritedMethod1 instanceof InterTypeMethodBinding && 
+    	      inheritedMethod2 instanceof InterTypeMethodBinding)) 
+    		super.duplicateInheritedMethods(type,inheritedMethod1,inheritedMethod2);
+    }
+    
+    /**
      * All problems end up routed through here at some point...
      */
     public IProblem createProblem(char[] fileName, int problemId, String[] problemArguments, String[] messageArguments, int severity, int problemStartPosition, int problemEndPosition, int lineNumber) {
@@ -838,6 +838,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
             super(signature, null);
             this.size = size;
             this.index = index;
+            this.typeKind=TypeKind.PRIMITIVE;
         }
         public final int getSize() {
             return size;
@@ -116,6 +116,18 @@ public class TypeFactory {
 			UnresolvedType componentType = createTypeFromSignature(signature.substring(dims));
 			return new UnresolvedType(signature,
 					signature.substring(0,dims)+componentType.getErasureSignature());
+		} else if (signature.length()==1) { // could be a primitive
+		  switch (signature.charAt(0)) {
+		  	  case 'V': return ResolvedType.VOID;
+		  	  case 'Z': return ResolvedType.BOOLEAN;
+			  case 'B': return ResolvedType.BYTE;
+			  case 'C': return ResolvedType.CHAR;
+			  case 'D': return ResolvedType.DOUBLE;
+			  case 'F': return ResolvedType.FLOAT;
+			  case 'I': return ResolvedType.INT;
+			  case 'J': return ResolvedType.LONG;
+			  case 'S': return ResolvedType.SHORT;
+		  }
 		}
 		return new UnresolvedType(signature);
 	}
@@ -0,0 +1,4 @@
+package a;
+
+public aspect AAA perthis(this(Screen)) { }
+
@@ -49,6 +49,7 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testGenericITDsAndAbstractMethodError_pr102357() { runTest("generic itds and abstract method error");}
   */
 
+  public void testParserException_pr115788() { runTest("parser exception");}
   public void testPossibleStaticImports_pr113066_1() { runTest("possible static imports bug - 1");}
   public void testPossibleStaticImports_pr113066_2() { runTest("possible static imports bug - 2");}
   public void testPossibleStaticImports_pr113066_3() { runTest("possible static imports bug - 3");}
@@ -57,6 +57,12 @@
         <compile files="Consts.java,TestNPE.java" options="-1.5"/>
     </ajc-test>
 
+    <ajc-test dir="bugs150/pr115788" title="parser exception">
+        <compile files="AAA.java">
+          <message kind="warning" line="3" text="no match for this type name: Screen"/>
+        </compile>
+    </ajc-test>
+    
     <ajc-test dir="bugs150/pr113066" title="possible static imports bug - 2">
         <compile files="Consts2.java,TestNPE2.java" options="-1.5">
           <message kind="error" line="2" text="The import a.Consts2.A_CONST cannot be resolved"/>
@@ -134,10 +134,16 @@ public class PerThisOrTargetPointcutVisitor extends IdentityPointcutVisitor {
     public Object visit(ThisOrTargetPointcut node, Object data) {
         if ((m_isTarget && !node.isThis())
             || (!m_isTarget && node.isThis())) {
+        	String pointcutString = node.getType().toString();
+        	// see pr115788 "<nothing>" means there was a problem resolving types - that will be reported so dont blow up
+        	// the parser here..
+        	if (pointcutString.equals("<nothing>")) {
+        		return new NoTypePattern();
+        	}
             //pertarget(target(Foo)) => Foo+ for type pattern matching
             //perthis(this(Foo)) => Foo+ for type pattern matching
             // TODO AV - we do like a deep copy by parsing it again.. quite dirty, would need a clean deep copy
-            TypePattern copy = new PatternParser(node.getType().toString().replace('$', '.')).parseTypePattern();
+            TypePattern copy = new PatternParser(pointcutString.replace('$', '.')).parseTypePattern();
             // TODO AV - see dirty replace from $ to . here as inner classes are with $ instead (#108488)
             copy.includeSubtypes = true;
             return copy;
