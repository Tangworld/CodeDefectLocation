@@ -289,6 +289,19 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 
 	}
 
+	public void doSupertypesFirst(ReferenceBinding rb,Collection yetToProcess) {
+	    if (rb instanceof SourceTypeBinding) {
+		    if (yetToProcess.contains(rb)) {
+		    	collectAllITDsAndDeclares((SourceTypeBinding)rb, yetToProcess);
+		    }
+	    } else if (rb instanceof ParameterizedTypeBinding) {
+	        // If its a PTB we need to pull the SourceTypeBinding out of it.
+	    	ParameterizedTypeBinding ptb = (ParameterizedTypeBinding)rb;
+	    	if (ptb.type instanceof SourceTypeBinding && yetToProcess.contains(ptb.type)) {
+	    		collectAllITDsAndDeclares((SourceTypeBinding)ptb.type, yetToProcess);
+	    	}
+	    }
+	}
 	/**
 	 * Find all the ITDs and Declares, but it is important we do this from the supertypes
 	 * down to the subtypes.
@@ -298,18 +311,18 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 	private void collectAllITDsAndDeclares(SourceTypeBinding sourceType, Collection yetToProcess) {
 		// Look at the supertype first
 		ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.COLLECTING_ITDS_AND_DECLARES, sourceType.sourceName);
-	    ReferenceBinding superType = sourceType.superclass();
-	    if (superType instanceof SourceTypeBinding) {
-		    if (yetToProcess.contains(superType)) {
-		    	collectAllITDsAndDeclares((SourceTypeBinding)superType, yetToProcess);
-		    }
-	    } else if (superType instanceof ParameterizedTypeBinding) {
-	        // If its a PTB we need to pull the SourceTypeBinding out of it.
-	    	ParameterizedTypeBinding ptb = (ParameterizedTypeBinding)superType;
-	    	if (ptb.type instanceof SourceTypeBinding && yetToProcess.contains(ptb.type)) {
-	    		collectAllITDsAndDeclares((SourceTypeBinding)ptb.type, yetToProcess);
-	    	}
-	    }
+		
+		// look out our direct supertype
+		doSupertypesFirst(sourceType.superclass(),yetToProcess);
+	    
+	    // now check our membertypes (pr119570)
+		ReferenceBinding[] memberTypes = sourceType.memberTypes;
+		for (int i = 0, length = memberTypes.length; i < length; i++) {
+			SourceTypeBinding rb = (SourceTypeBinding)memberTypes[i];
+			if (!rb.superclass().equals(sourceType))
+			  doSupertypesFirst(rb.superclass(),yetToProcess);
+		}
+		
         buildInterTypeAndPerClause(sourceType.scope);
         addCrosscuttingStructures(sourceType.scope);
         yetToProcess.remove(sourceType);
@@ -22,6 +22,6 @@ class TaggedTexts {
         // unneeded declare-parents duplicates one in NodeImpl
         // when here, get spurious error message
         // when commented out, d-p fails and get compiler error at 1) above
-        declare parents : Tag implements INode<Tag,Tag>;
+//        declare parents : Tag implements INode<Tag,Tag>;
     }
-}
\ No newline at end of file
+}
@@ -51,6 +51,7 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testCunningDeclareParents_pr92311() { runTest("cunning declare parents");}
   public void testGenericITDsAndAbstractMethodError_pr102357() { runTest("generic itds and abstract method error");}
   */
+  //public void testIncorrectSignatureMatchingWithExceptions_pr119749() { runTest("incorrect exception signature matching");}
   public void testGeneratingCodeForAnOldRuntime_pr116679_1() { runTest("generating code for a 1.2.1 runtime - 1");}
   public void testGeneratingCodeForAnOldRuntime_pr116679_2() { runTest("generating code for a 1.2.1 runtime - 2");}
   public void testAmbiguousMethod_pr118599_1() { runTest("ambiguous method when binary weaving - 1");}
@@ -86,7 +87,8 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testBadDecp_pr110788_2() { runTest("bad generic decp - 2");}
   public void testBadDecp_pr110788_3() { runTest("bad generic decp - 3");}
   public void testBadDecp_pr110788_4() { runTest("bad generic decp - 4");}
-  public void testSpuriousOverrideMethodWarning_pr119570() { runTest("spurious override method warning");}
+  public void testSpuriousOverrideMethodWarning_pr119570_1() { runTest("spurious override method warning");}
+  public void testSpuriousOverrideMethodWarning_pr119570_2() { runTest("spurious override method warning - 2");}
   public void testBrokenSwitch_pr117854() { runTest("broken switch transform");}
   public void testVarargsITD_pr110906() { runTest("ITD varargs problem");}
   public void testBadRenderer_pr86903() { runTest("bcelrenderer bad");}
@@ -72,6 +72,11 @@
     <ajc-test dir="bugs150/pr119570" pr="119570" title="spurious override method warning">
      <compile files="NodeImpl.java,INode.java,ParameterizedDP.java" options="-1.5"/>
      <run class="bugs.ParameterizedDP"/>
+    </ajc-test>
+    
+    <ajc-test dir="bugs150/pr119570" pr="119570" title="spurious override method warning - 2">
+     <compile files="ParameterizedDP.java,NodeImpl.java,INode.java" options="-1.5"/>
+     <run class="bugs.ParameterizedDP"/>
     </ajc-test>  
 
     <ajc-test dir="bugs150/pr119210" pr="119210" title="autoboxing around advice - 1">
@@ -126,6 +131,13 @@
      <run class="BrokenSwitch"/>
     </ajc-test>  
 
+    <ajc-test dir="bugs150/pr119749" pr="119749" title="incorrect exception signature matching">
+     <compile files="InheritedThrows.java" options="">  
+     	<message kind="warning" line="19" text="one"/>
+     	<message kind="warning" line="27" text="one"/>
+     </compile>
+    </ajc-test>  
+    
     <ajc-test dir="bugs150/pr118599" pr="118599" title="ambiguous method when binary weaving - 1">
      <!-- separate compilation was failing  -->
      <compile files="Attributable.java" outjar="foo.jar" options="-1.5"/>
@@ -293,8 +293,7 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 	public void testPr119570() {
 		initialiseProject("PR119570");
 		build("PR119570");
-		List l = MyTaskListManager.getWarningMessages();
-		assertTrue("Should be no warnings, but got "+l,l.size()==0);
+		assertTrue("Should be no errors, but got "+MyTaskListManager.getErrorMessages(),MyTaskListManager.getErrorMessages().size()==0);		
 	}
 
 	public void testPr119570_2() {
@@ -273,6 +273,11 @@ public class AjProblemReporter extends ProblemReporter {
 		super.disallowedTargetForAnnotation(annotation);
 	}
 
+	public void overridesPackageDefaultMethod(MethodBinding localMethod, MethodBinding inheritedMethod) {
+	  if (new String(localMethod.selector).startsWith("ajc$")) return;
+	  super.overridesPackageDefaultMethod(localMethod,inheritedMethod);
+	}
+	
 	public void handle(
 		int problemId,
 		String[] problemArguments,
@@ -604,11 +604,13 @@ public class AjdeInteractionTestbed extends TestCase {
 		private boolean receivedNonIncrementalBuildMessage = false;
 		private boolean receivedBatchBuildMessage = false;
 		private List errorMessages = new ArrayList();
+		private List warningMessages = new ArrayList();
 
 		public static void reset() {
 			_instance.receivedNonIncrementalBuildMessage=false;
 			_instance.receivedBatchBuildMessage=false;
 			_instance.errorMessages.clear();
+			_instance.warningMessages.clear();
 		}
 
 //		public static boolean defaultedToBatch() {
@@ -627,6 +629,10 @@ public class AjdeInteractionTestbed extends TestCase {
 			return _instance.errorMessages;
 		}
 
+		public static List/*IMessage*/ getWarningMessages() {
+			return _instance.warningMessages;
+		}
+		
 		public static TaskListManager getInstance() { 
 			return _instance;
 		}
@@ -644,12 +650,15 @@ public class AjdeInteractionTestbed extends TestCase {
 			if (message.getKind()==IMessage.ERROR) {
 				errorMessages.add(message);
 			}
+			if (message.getKind()==IMessage.WARNING) {
+				warningMessages.add(message);
+			}
 			log("TaskListManager.addSourcelineTask("+message+")");
 		}
 
 		public boolean hasWarning() {
-			log("TaskListManager.hasWarning() [returning false]");
-			return false;
+			log("TaskListManager.hasWarning() [returning "+(warningMessages.size()==0)+"]");
+			return warningMessages.size()==0;
 		}
 
 		public void addProjectTask(String message, Kind kind) {
@@ -290,6 +290,20 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		build("PR92837");
 	}
 
+	public void testPr119570() {
+		initialiseProject("PR119570");
+		build("PR119570");
+		List l = MyTaskListManager.getWarningMessages();
+		assertTrue("Should be no warnings, but got "+l,l.size()==0);
+	}
+	
+	public void testPr119570_2() {
+		initialiseProject("PR119570_2");
+		build("PR119570_2");
+		List l = MyTaskListManager.getWarningMessages();
+		assertTrue("Should be no warnings, but got "+l,l.size()==0);
+	}
+	
 	// If you fiddle with the compiler options - you must manually reset the options at the end of the test
 	public void testPr117209() {
 		try {
@@ -0,0 +1,27 @@
+package bugs;
+
+import bugsOtherPackage.INode;
+import bugsOtherPackage.NodeImpl;
+
+public class ParameterizedDP {
+
+    public static void main(String[] args) {
+        // 1) compile-time error here without 
+        //    {unneeded} subaspect declare-parent
+        // Tag as INode<Tag, Tag> from PC extends NodeImpl<Tag, Tag>
+        ((TaggedTexts.Tag) null).getParent();       
+    }
+
+}
+class TaggedTexts {
+
+    public static class Text {  }
+
+    public static class Tag {  }
+    static aspect PC extends NodeImpl<Tag, Tag> {
+        // unneeded declare-parents duplicates one in NodeImpl
+        // when here, get spurious error message
+        // when commented out, d-p fails and get compiler error at 1) above
+        declare parents : Tag implements INode<Tag,Tag>;
+    }
+}
\ No newline at end of file
@@ -0,0 +1,6 @@
+package bugsOtherPackage;
+
+public interface INode<Parent, Child> {
+    boolean setParent(INode<Parent, Child> p);
+    INode<Parent, Child> getParent();
+}
\ No newline at end of file
@@ -0,0 +1,21 @@
+package bugsOtherPackage;
+
+import java.util.ArrayList;
+
+public abstract aspect NodeImpl<Parent, Child> {
+
+    declare parents : Child implements INode<Parent, Child>;
+    declare parents : Parent implements INode<Parent, Child>;
+
+    private final ArrayList<INode> INode.fChildren = new ArrayList<INode>();
+
+    // are you not supposed to use type parameters here?
+    private INode<Parent, Child> INode.fParent;
+    public final INode<Parent, Child> INode.getParent() {
+        return fParent;
+    }
+    public final boolean INode.setParent(INode<Parent, Child> newParent) {
+        fParent = newParent;
+        return true; 
+    }
+}
\ No newline at end of file
@@ -0,0 +1,27 @@
+package bugs;
+
+import bugsOtherPackage.INode;
+import bugsOtherPackage.NodeImpl;
+
+public class ParameterizedDP {
+
+    public static void main(String[] args) {
+        // 1) compile-time error here without 
+        //    {unneeded} subaspect declare-parent
+        // Tag as INode<Tag, Tag> from PC extends NodeImpl<Tag, Tag>
+        ((TaggedTexts.Tag) null).getParent();       
+    }
+
+}
+class TaggedTexts {
+
+    public static class Text {  }
+
+    public static class Tag {  }
+    static aspect PC extends NodeImpl<Tag, Tag> {
+        // unneeded declare-parents duplicates one in NodeImpl
+        // when here, get spurious error message
+        // when commented out, d-p fails and get compiler error at 1) above
+       // declare parents : Tag implements INode<Tag,Tag>;
+    }
+}
@@ -0,0 +1,6 @@
+package bugsOtherPackage;
+
+public interface INode<Parent, Child> {
+    boolean setParent(INode<Parent, Child> p);
+    INode<Parent, Child> getParent();
+}
\ No newline at end of file
@@ -0,0 +1,21 @@
+package bugsOtherPackage;
+
+import java.util.ArrayList;
+
+public abstract aspect NodeImpl<Parent, Child> {
+
+    declare parents : Child implements INode<Parent, Child>;
+    declare parents : Parent implements INode<Parent, Child>;
+
+    private final ArrayList<INode> INode.fChildren = new ArrayList<INode>();
+
+    // are you not supposed to use type parameters here?
+    private INode<Parent, Child> INode.fParent;
+    public final INode<Parent, Child> INode.getParent() {
+        return fParent;
+    }
+    public final boolean INode.setParent(INode<Parent, Child> newParent) {
+        fParent = newParent;
+        return true; 
+    }
+}
\ No newline at end of file
@@ -0,0 +1,6 @@
+package bugsOtherPackage;
+
+public interface INode<Parent, Child> {
+    boolean setParent(INode<Parent, Child> p);
+    INode<Parent, Child> getParent();
+}
\ No newline at end of file
@@ -0,0 +1,21 @@
+package bugsOtherPackage;
+
+import java.util.ArrayList;
+
+public abstract aspect NodeImpl<Parent, Child> {
+
+    declare parents : Child implements INode<Parent, Child>;
+    declare parents : Parent implements INode<Parent, Child>;
+
+    private final ArrayList<INode> INode.fChildren = new ArrayList<INode>();
+
+    // are you not supposed to use type parameters here?
+    private INode<Parent, Child> INode.fParent;
+    public final INode<Parent, Child> INode.getParent() {
+        return fParent;
+    }
+    public final boolean INode.setParent(INode<Parent, Child> newParent) {
+        fParent = newParent;
+        return true;
+    }
+}
\ No newline at end of file
@@ -0,0 +1,33 @@
+package bugs;
+
+import bugsOtherPackage.INode;
+import bugsOtherPackage.NodeImpl;
+
+// comments in this bug relate to what happened on AspectJ5 M4
+public class ParameterizedDP {
+
+    public static void main(String[] args) {
+//        // 1) compile-time error here without 
+//        //    {unneeded} subaspect declare-parent
+//        // Tag as INode<Tag, Tag> from PC extends NodeImpl<Tag, Tag>
+//        ((TaggedTexts.Tag) null).getParent();    
+        TaggedTexts.Tag tag1 = new TaggedTexts.Tag();
+        TaggedTexts.Tag tag2 = new TaggedTexts.Tag();
+        tag1.getParent();
+        tag1.setParent(tag2);
+        if (!tag1.getParent().equals(tag2)) throw new RuntimeException("");
+    }
+
+}
+class TaggedTexts {
+
+    public static class Text {  }
+
+    public static class Tag {  }
+    static aspect PC extends NodeImpl<Tag, Tag> {
+//        // unneeded declare-parents duplicates one in NodeImpl
+//        // when here, get spurious error message
+//        // when commented out, d-p fails and get compiler error at 1) above
+//        declare parents : Tag implements INode<Tag,Tag>;
+    }
+}
\ No newline at end of file
@@ -86,7 +86,7 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testBadDecp_pr110788_2() { runTest("bad generic decp - 2");}
   public void testBadDecp_pr110788_3() { runTest("bad generic decp - 3");}
   public void testBadDecp_pr110788_4() { runTest("bad generic decp - 4");}
-
+  public void testSpuriousOverrideMethodWarning_pr119570() { runTest("spurious override method warning");}
   public void testBrokenSwitch_pr117854() { runTest("broken switch transform");}
   public void testVarargsITD_pr110906() { runTest("ITD varargs problem");}
   public void testBadRenderer_pr86903() { runTest("bcelrenderer bad");}
@@ -69,6 +69,11 @@
      <run class="Pr114054"/>
     </ajc-test>  
 
+    <ajc-test dir="bugs150/pr119570" pr="119570" title="spurious override method warning">
+     <compile files="NodeImpl.java,INode.java,ParameterizedDP.java" options="-1.5"/>
+     <run class="bugs.ParameterizedDP"/>
+    </ajc-test>  
+
     <ajc-test dir="bugs150/pr119210" pr="119210" title="autoboxing around advice - 1">
      <compile files="TestLib.java,ThreadAspectLib.java" options="-1.5"/>
      <run class="TestLib">
