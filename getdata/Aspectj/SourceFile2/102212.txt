@@ -0,0 +1,25 @@
+import java.lang.reflect.*;
+
+public class SynchronizedInterfaceMethods  {
+	
+	public static void main(String[] args) throws NoSuchMethodException {
+		Class myClass = SynchronizedInterfaceMethods.class;
+		Method m = myClass.getMethod("foo");
+		if (!Modifier.isSynchronized(m.getModifiers())) throw new RuntimeException("Expecting method on class to be synchronized");
+		Class iClass = I.class;
+		Method im = iClass.getMethod("foo");
+		if (Modifier.isSynchronized(im.getModifiers())) throw new RuntimeException("Interface method must NOT be synchronized");
+	}
+	
+	
+}
+
+interface I {}
+
+
+aspect A {
+	
+	public synchronized void I.foo() {}
+	
+	declare parents : SynchronizedInterfaceMethods implements I;
+}
\ No newline at end of file
@@ -374,6 +374,10 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	  runTest("abstract synchronized itdms not detected");
   }
 
+  public void testSynchronizedITDInterfaceMethods() {
+	  runTest("synchronized itd interface methods");
+  }
+  
   // helper methods.....
 
   public SyntheticRepository createRepos(File cpentry) {
@@ -462,6 +462,12 @@
             <message line="7" kind="error" text="The abstract method _abstract in type Parent can only set a visibility modifier, one of public or protected"/>
         </compile>
     </ajc-test>
+
+    <ajc-test dir="bugs150" pr="102212" title="synchronized itd interface methods">
+        <compile files="SynchronizedInterfaceMethods.aj" options="-1.5">
+        </compile>
+        <run class="SynchronizedInterfaceMethods"/>
+    </ajc-test>
 
     <!-- ============================================================================ -->
     <!-- ============================================================================ -->
@@ -716,6 +716,7 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 		ResolvedMember interMethodDispatcher = munger.getInterMethodDispatcher(aspectType);
 
 		LazyClassGen gen = weaver.getLazyClassGen();
+		boolean mungingInterface = gen.isInterface();
 
 		ResolvedType onType = weaver.getWorld().resolve(unMangledInterMethod.getDeclaringType(),munger.getSourceLocation());
 		if (onType.isRawType()) onType = onType.getGenericType();
@@ -738,6 +739,11 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 
 
 			LazyMethodGen mg = makeMethodGen(gen, mangledInterMethod);
+			if (mungingInterface) {
+				// we want the modifiers of the ITD to be used for all *implementors* of the
+				// interface, but the method itself we add to the interface must be public abstract
+				mg.setAccessFlags(Modifier.PUBLIC | Modifier.ABSTRACT);
+			}
 
 			// pr98901
 		    // For copying the annotations across, we have to discover the real member in the aspect
@@ -829,6 +835,11 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 					AjcMemberMaker.interMethod(unMangledInterMethod, aspectType, false);
 
 			  LazyMethodGen mg = makeMethodGen(gen, mangledInterMethod);
+			  if (mungingInterface) {
+				// we want the modifiers of the ITD to be used for all *implementors* of the
+				// interface, but the method itself we add to the interface must be public abstract
+				mg.setAccessFlags(Modifier.PUBLIC | Modifier.ABSTRACT);
+			  }
 
 			  Type[] paramTypes = BcelWorld.makeBcelTypes(mangledInterMethod.getParameterTypes());
 			  Type returnType = BcelWorld.makeBcelType(mangledInterMethod.getReturnType());
@@ -782,6 +782,10 @@ public final class LazyMethodGen {
     public int getAccessFlags() {
         return accessFlags;
     }
+    
+    public void setAccessFlags(int newFlags) {
+    	this.accessFlags = newFlags;
+    }
 
     public Type[] getArgumentTypes() {
     	initialize();
