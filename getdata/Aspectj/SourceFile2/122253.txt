@@ -0,0 +1,188 @@
+/*******************************************************************************
+ * Copyright (c) 2006 Contributors.
+ * All rights reserved.
+ * This program and the accompanying materials are made available
+ * under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution and is available at
+ * http://eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ * variant of Aspects in the aspectj5rt project - this one isn't Java5   - Andy Clement
+ *******************************************************************************/
+package org.aspectj.lang;
+
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.InvocationTargetException;
+
+/**
+ * For users working on a level of Java prior to Java5, Aspects14 handles generic aspectOf methods when they 
+ * are not available in the aspects but added later on through load time weaving.  Users on Java5 should use
+ * the class Aspects instead.
+ * <p/>
+ * Aspects14.aspectOf(..) is doing reflective calls to the aspect aspectOf, so for better performance
+ * consider using ajc compilation of the aspects and using them as a binary dependancies in your project.
+ */
+public class Aspects14 {
+
+    private final static Class[] EMPTY_CLASS_ARRAY = new Class[0];
+    private final static Class[] PEROBJECT_CLASS_ARRAY = new Class[]{Object.class};
+    private final static Class[] PERTYPEWITHIN_CLASS_ARRAY = new Class[]{Class.class};
+    private final static Object[] EMPTY_OBJECT_ARRAY = new Object[0];
+    private final static String ASPECTOF = "aspectOf";
+    private final static String HASASPECT = "hasAspect";
+
+    /**
+     * Returns the singleton aspect or the percflow / percflowbelow associated with the current thread
+     *
+     * @param aspectClass
+     * @return
+     * @throws NoAspectBoundException if no such aspect
+     */
+    public static Object aspectOf(Class aspectClass) throws NoAspectBoundException {
+        try {
+            return getSingletonOrThreadAspectOf(aspectClass).invoke(null, EMPTY_OBJECT_ARRAY);
+        } catch (InvocationTargetException e) {
+        	//FIXME asc Highly temporary change to see what the build makes of it - dont use 1.4 APIs
+            throw new NoAspectBoundException(aspectClass.getName(), e);//e.getCause());
+        } catch (Exception e) {
+            throw new NoAspectBoundException(aspectClass.getName(), e);
+        }
+    }
+
+    /**
+     * Returns the perthis / pertarget aspect
+     * @param aspectClass
+     * @param perObject
+     * @return
+     * @throws NoAspectBoundException if no such aspect, or no aspect bound
+     */
+    public static Object aspectOf(Class aspectClass, Object perObject) throws NoAspectBoundException {
+        try {
+            return getPerObjectAspectOf(aspectClass).invoke(null, new Object[]{perObject});
+        } catch (InvocationTargetException e) {
+        	//FIXME asc Highly temporary change to see what the build makes of it - dont use 1.4 APIs
+            throw new NoAspectBoundException(aspectClass.getName(), e);//e.getCause());
+        } catch (Exception e) {
+            throw new NoAspectBoundException(aspectClass.getName(), e);
+        }
+    }
+
+    /**
+     * Returns the pertypewithin aspect
+     * @param aspectClass
+     * @param perTypeWithin class
+     * @return
+     * @throws NoAspectBoundException if no such aspect, or no aspect bound
+     */
+    public static Object aspectOf(Class aspectClass, Class perTypeWithin) throws NoAspectBoundException {
+        try {
+            return getPerTypeWithinAspectOf(aspectClass).invoke(null, new Object[]{perTypeWithin});
+        } catch (InvocationTargetException e) {
+//        	FIXME asc Highly temporary change to see what the build makes of it - dont use 1.4 APIs
+            throw new NoAspectBoundException(aspectClass.getName(), e);//e.getCause());
+        } catch (Exception e) {
+            throw new NoAspectBoundException(aspectClass.getName(), e);
+        }
+    }
+
+    /**
+     * Returns true if singleton aspect or percflow / percflowbelow aspect is bound
+     *
+     * @param aspectClass
+     * @return
+     * @throws NoAspectBoundException if not bound
+     */
+    public static boolean hasAspect(Class aspectClass) throws NoAspectBoundException {
+        try {
+            return ((Boolean)getSingletonOrThreadHasAspect(aspectClass).invoke(null, EMPTY_OBJECT_ARRAY)).booleanValue();
+        } catch (Exception e) {
+            return false;
+        }
+    }
+
+    /**
+     * Returns true if the perthis / pertarget aspect is bound
+     * @param aspectClass
+     * @param perObject
+     * @return
+     * @throws NoAspectBoundException if not bound
+     */
+    public static boolean hasAspect(Class aspectClass, Object perObject) throws NoAspectBoundException {
+        try {
+            return ((Boolean)getPerObjectHasAspect(aspectClass).invoke(null, new Object[]{perObject})).booleanValue();
+        } catch (Exception e) {
+            return false;
+        }
+    }
+
+    /**
+     * Returns true if the pertypewithin aspect is bound
+     * @param aspectClass
+     * @param perTypeWithin class
+     * @return
+     * @throws NoAspectBoundException if not bound
+     */
+    public static boolean hasAspect(Class aspectClass, Class perTypeWithin) throws NoAspectBoundException {
+        try {
+            return ((Boolean)getPerTypeWithinHasAspect(aspectClass).invoke(null, new Object[]{perTypeWithin})).booleanValue();
+        } catch (Exception e) {
+            return false;
+        }
+    }
+
+    // -- aspectOf
+
+    private static Method getSingletonOrThreadAspectOf(Class aspectClass) throws NoSuchMethodException {
+        Method method = aspectClass.getDeclaredMethod(ASPECTOF, EMPTY_CLASS_ARRAY);
+        return checkAspectOf(method, aspectClass);
+    }
+
+    private static Method getPerObjectAspectOf(Class aspectClass) throws NoSuchMethodException {
+        Method method = aspectClass.getDeclaredMethod(ASPECTOF, PEROBJECT_CLASS_ARRAY);
+        return checkAspectOf(method, aspectClass);
+    }
+
+    private static Method getPerTypeWithinAspectOf(Class aspectClass) throws NoSuchMethodException {
+        Method method = aspectClass.getDeclaredMethod(ASPECTOF, PERTYPEWITHIN_CLASS_ARRAY);
+        return checkAspectOf(method, aspectClass);
+    }
+
+    private static Method checkAspectOf(Method method, Class aspectClass) throws NoSuchMethodException {
+        method.setAccessible(true);
+        if (!method.isAccessible()
+            || !Modifier.isPublic(method.getModifiers())
+            || !Modifier.isStatic(method.getModifiers())) {            
+            throw new NoSuchMethodException(aspectClass.getName() + ".aspectOf(..) is not accessible public static");
+        }
+        return method;
+    }
+
+    // -- hasAspect
+
+    private static Method getSingletonOrThreadHasAspect(Class aspectClass) throws NoSuchMethodException {
+        Method method = aspectClass.getDeclaredMethod(HASASPECT, EMPTY_CLASS_ARRAY);
+        return checkHasAspect(method, aspectClass);
+    }
+
+    private static Method getPerObjectHasAspect(Class aspectClass) throws NoSuchMethodException {
+        Method method = aspectClass.getDeclaredMethod(HASASPECT, PEROBJECT_CLASS_ARRAY);
+        return checkHasAspect(method, aspectClass);
+    }
+
+    private static Method getPerTypeWithinHasAspect(Class aspectClass) throws NoSuchMethodException {
+        Method method = aspectClass.getDeclaredMethod(HASASPECT, PERTYPEWITHIN_CLASS_ARRAY);
+        return checkHasAspect(method, aspectClass);
+    }
+
+    private static Method checkHasAspect(Method method, Class aspectClass) throws NoSuchMethodException {
+        method.setAccessible(true);
+        if (!method.isAccessible()
+            || !Modifier.isPublic(method.getModifiers())
+            || !Modifier.isStatic(method.getModifiers())) {
+            throw new NoSuchMethodException(aspectClass.getName() + ".hasAspect(..) is not accessible public static");
+        }
+        return method;
+    }
+}
@@ -13,10 +13,15 @@ package org.aspectj.systemtest.ajc152;
 import java.io.File;
 import junit.framework.Test;
 
+//import org.aspectj.systemtest.ajc150.GenericsTests;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+  public void testAspects14PerSingleton_pr122253() { runTest("aspects14 - persingleton");}
+  public void testAspects14PerCflow_pr122253() { runTest("aspects14 - percflow");}
+  public void testAspects14PerThis_pr122253() { runTest("aspects14 - perthis");}
+  public void testAspects14PerTypeWithin_pr122253() { runTest("aspects14 - pertypewithin");}
   public void testFunkyGenericErrorWithITDs_pr126355() { runTest("bizarre generic error with itds");}
   public void testConcretizingAbstractMethods_pr142466() { runTest("aop.xml aspect inheriting but not concretizing abstract method");}
   public void testConcretizingAbstractMethods_pr142466_2() { runTest("aop.xml aspect inheriting but not concretizing abstract method - 2");}
@@ -0,0 +1,28 @@
+import org.aspectj.lang.*;
+
+public aspect PerCflow percflow(execution(* m(..))) {
+
+  before(): execution(* Foo.*(..)) {}
+
+  public static void main(String []argv) {
+	print("before");
+    new Foo().m();
+    print("after");
+  }
+  
+  public static void print(String prefix) {
+    System.err.println(prefix);
+    boolean b1 = Aspects14.hasAspect(PerCflow.class);
+    boolean b2 = PerCflow.hasAspect();
+    Object   o1 = (b1?Aspects14.aspectOf(PerCflow.class):null);
+    Object   o2 = (b2?PerCflow.aspectOf():null);
+    System.err.println("hasAspect?  "+b1+" : "+b2);
+    System.err.println("aspectOf? "+o1+" : "+o2);   
+  }
+  
+  public String toString() { return "PerCflowInstance"; }
+}
+
+class Foo {
+  public void m() { PerCflow.print("during");}
+}
@@ -0,0 +1,37 @@
+import org.aspectj.lang.*;
+
+public aspect PerThis perthis(execution(* m(..))) {
+
+  before(): execution(* Foo.*(..)) {}
+
+  public static void main(String []argv) {
+	print("before");
+    new Foo().m();
+    print("after");
+  }
+  
+  public static void print(String prefix) {
+    System.err.println(prefix);
+    boolean b1 = Aspects14.hasAspect(PerThis.class,null);
+    boolean b2 = PerThis.hasAspect(null);
+    Object   o1 = (b1?Aspects14.aspectOf(PerThis.class,null):null);
+    Object   o2 = (b2?PerThis.aspectOf(null):null);
+    System.err.println("hasAspect?  "+b1+" : "+b2);
+    System.err.println("aspectOf? "+o1+" : "+o2);   
+  }
+  
+  public String toString() { return "PerThisInstance"; }
+}
+
+class Foo {
+  public void m() { print("during");}
+  public void print(String prefix) {
+    System.err.println(prefix);
+    boolean b1 = Aspects14.hasAspect(PerThis.class,this);
+    boolean b2 = PerThis.hasAspect(this);
+    Object   o1 = (b1?Aspects14.aspectOf(PerThis.class,this):null);
+    Object   o2 = (b2?PerThis.aspectOf(this):null);
+    System.err.println("hasAspect?  "+b1+" : "+b2);
+    System.err.println("aspectOf? "+o1+" : "+o2);   
+  }
+}
@@ -0,0 +1,41 @@
+import org.aspectj.lang.*;
+
+public aspect PerTypeWithin pertypewithin(Foo) {
+
+  before(): execution(* Foo.*(..)) {}
+
+  public static void main(String []argv) {
+	print("before");
+    new Foo().m();
+    print("after");
+  }
+  
+  public static void print(String prefix) {
+    System.err.println(prefix);
+    boolean b1 = Aspects14.hasAspect(PerTypeWithin.class,Goo.class);
+    boolean b2 = PerTypeWithin.hasAspect(Goo.class);
+    Object   o1 = (b1?Aspects14.aspectOf(PerTypeWithin.class,Goo.class):null);
+    Object   o2 = (b2?PerTypeWithin.aspectOf(Goo.class):null);
+    System.err.println("hasAspect?  "+b1+" : "+b2);
+    System.err.println("aspectOf? "+o1+" : "+o2);   
+  }
+  
+  public String toString() { return "PerTypeWithinInstance"; }
+}
+
+class Goo {
+
+}
+
+class Foo {
+  public void m() { print("during");}
+  public void print(String prefix) {
+    System.err.println(prefix);
+    boolean b1 = Aspects14.hasAspect(PerTypeWithin.class,this.getClass());
+    boolean b2 = PerTypeWithin.hasAspect(this.getClass());
+    Object   o1 = (b1?Aspects14.aspectOf(PerTypeWithin.class,this.getClass()):null);
+    Object   o2 = (b2?PerTypeWithin.aspectOf(this.getClass()):null);
+    System.err.println("hasAspect?  "+b1+" : "+b2);
+    System.err.println("aspectOf? "+o1+" : "+o2);   
+  }
+}
@@ -0,0 +1,27 @@
+import org.aspectj.lang.*;
+
+public aspect Singleton {
+
+  before(): execution(* Foo.*(..)) {}
+
+  public static void main(String []argv) {
+	print();
+    new Foo().m();
+    print();
+  }
+  
+  public static void print() {
+    boolean b1 = Aspects14.hasAspect(Singleton.class);
+    boolean b2 = Singleton.hasAspect();
+    Object   o1 = (b1?Aspects14.aspectOf(Singleton.class):null);
+    Object   o2 = (b2?Singleton.aspectOf():null);
+    System.err.println("hasAspect?  "+b1+" : "+b2);
+    System.err.println("aspectOf? "+o1+" : "+o2);   
+  }
+  
+  public String toString() { return "SingletonInstance"; }
+}
+
+class Foo {
+  public void m() { }
+}
@@ -14,6 +14,70 @@
          </stderr>
       </run>
     </ajc-test>
+    
+	<ajc-test dir="bugs152/pr122253" title="aspects14 - persingleton">
+     <compile files="Singleton.java"/>
+     <run class="Singleton">
+       <stderr>
+         <line text="hasAspect?  true : true"/>
+         <line text="aspectOf? SingletonInstance : SingletonInstance"/>
+         <line text="hasAspect?  true : true"/>
+         <line text="aspectOf? SingletonInstance : SingletonInstance"/>
+       </stderr>
+     </run>
+    </ajc-test>
+
+	<ajc-test dir="bugs152/pr122253" title="aspects14 - percflow">
+     <compile files="PerCflow.java"/>
+     <run class="PerCflow">
+       <stderr>
+         <line text="before"/>
+         <line text="hasAspect?  false : false"/>
+         <line text="aspectOf? null : null"/>
+         <line text="during"/>
+         <line text="hasAspect?  true : true"/>
+         <line text="aspectOf? PerCflowInstance : PerCflowInstance"/>
+         <line text="after"/>
+         <line text="hasAspect?  false : false"/>
+         <line text="aspectOf? null : null"/>
+       </stderr>
+     </run>
+    </ajc-test>
+     
+     <ajc-test dir="bugs152/pr122253" title="aspects14 - perthis">
+     <compile files="PerThis.java"/>
+     <run class="PerThis">
+       <stderr>
+         <line text="before"/>
+         <line text="hasAspect?  false : false"/>
+         <line text="aspectOf? null : null"/>
+         <line text="during"/>
+         <line text="hasAspect?  true : true"/>
+         <line text="aspectOf? PerThisInstance : PerThisInstance"/>
+         <line text="after"/>
+         <line text="hasAspect?  false : false"/>
+         <line text="aspectOf? null : null"/>
+       </stderr>
+     </run>
+    </ajc-test>
+        
+     <ajc-test dir="bugs152/pr122253" title="aspects14 - pertypewithin">
+     <compile files="PerTypeWithin.java"/>
+     <run class="PerTypeWithin">
+       <stderr>
+         <line text="before"/>
+         <line text="hasAspect?  false : false"/>
+         <line text="aspectOf? null : null"/>
+         <line text="during"/>
+         <line text="hasAspect?  true : true"/>
+         <line text="aspectOf? PerTypeWithinInstance : PerTypeWithinInstance"/>
+         <line text="after"/>
+         <line text="hasAspect?  false : false"/>
+         <line text="aspectOf? null : null"/>
+       </stderr>
+     </run>
+    </ajc-test>
+    
 
 	<ajc-test dir="bugs152/pr126355" title="bizarre generic error with itds">
      <compile files="Pair.java" options="-1.5"/>
