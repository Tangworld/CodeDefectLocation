@@ -58,7 +58,8 @@ public class WildAnnotationTypePattern extends AnnotationTypePattern {
 		// matches if the type of any of the annotations on the AnnotatedElement is
 		// matched by the typePattern.
 		ResolvedType[] annTypes = annotated.getAnnotationTypes();
-		if (annTypes.length!=0) {
+
+		if (annTypes!=null && annTypes.length!=0) {
 			for (int i = 0; i < annTypes.length; i++) {
 				if (typePattern.matches(annTypes[i],TypePattern.STATIC).alwaysTrue()) {
 					return FuzzyBoolean.YES;
@@ -0,0 +1,7 @@
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Target;
+
+@Target(ElementType.TYPE)
+public @interface InjectName {
+
+}
@@ -0,0 +1,32 @@
+import java.io.Serializable;
+@InjectName
+@MarkMyMethods
+public class Main {
+
+	public String name;
+	
+	public Main() {
+		name = "jack";
+	}
+	
+	public String testMethod() {
+		return "Test";
+	}
+	
+	protected String testMethodProtected() {
+		return "Blah!";
+	}
+	
+	/**
+	 * @param args
+	 */
+	public static void main(String[] args) {
+		// TODO Auto-generated method stub
+		Main m = new Main();
+		Class[] cls = Main.class.getInterfaces();		
+		for(Class cl:cls) {
+			System.out.println("Interface : " + cl.getCanonicalName());
+		}
+	}
+
+}
@@ -0,0 +1,7 @@
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Target;
+
+@Target(ElementType.TYPE)
+public @interface MarkMyMethods {
+
+}
@@ -0,0 +1,60 @@
+
+
+public aspect MarkMyMethodsAspect {
+	
+	/* All methods not marked with @Read nor @Write are marked with @Write
+	 * 
+	 * When @MarkMyMethods is present on a Type, all public methods of
+	 * that type must either be marked with @Read or @Write. If neither of 
+	 * @Read or @Write is present on such a method, the method is automatically
+	 * annotated with the default marker, i.e. @Write
+	 * 
+	 * *******************************************************
+	 * BUG 
+	 * internal null pointer exception with the first part
+	 * of the declare statement.
+	 * *******************************************************
+	 * 
+	 */
+	declare @method : !@(Write || Read) public !static * (@MarkMyMethods *).*(..) : @Write;
+	
+	// This one works
+	//declare @method : !@(Read) public !static * (@MarkMyMethods *).*(..) : @Write;
+	// This one too
+	//declare @method : !@(Write) public !static * (@MarkMyMethods *).*(..) : @Write;
+	
+	
+	/* Cannot have @Read or @Write methods without @MarkMyMethods 
+	 *
+	 * When @Read or @Write is present on a method, the enclosing type must
+	 * have the @AccessClassified annotation.
+	 */
+	declare error : execution(@Read public * !@MarkMyMethods *.*(..)) :
+		"Cannot have public @Read methods inside non @AccessClassified types.";
+	declare error : execution(@Write public * !@MarkMyMethods *.*(..)) :
+		"Cannot have public @Write methods inside non @AccessClassified types.";
+	
+	/* Cannot have a method marked with both @Read and @Write
+	 *  
+	 * What would be necessary is to have an annotation that can take
+	 * a parameter to identify which type of access is needed that would prevent
+	 * the user from having the 2 at the same time e.g. @Access(READ). Unfortunately,
+	 * AspectJ 1.5 can currently only work with marker annotations and ignores
+	 * parameter annotations.
+	 */
+	declare error : readMethod() && writeMethod() :
+		"Cannot have both @Read and @Write on the same method.";
+	
+	/*
+	 * public @Read methods inside @MarkMyMethods types
+	 */ 
+	public pointcut readMethod() : 
+		execution(@Read public !static * @MarkMyMethods *.*(..));
+	
+	/*
+	 * public @Write methods inside @MarkMyMethods types
+	 */
+	public pointcut writeMethod() :
+		execution(@Write public !static * @MarkMyMethods *.*(..));
+	
+}
@@ -0,0 +1,18 @@
+
+public aspect NameAspect {
+    
+	
+	declare parents: @InjectName * implements Named;
+	
+	/* 
+	 * The injection of that method interferes with the declare
+	 * statements in MarkMyMethodsAspect
+	 */
+	public  String Named.getName()  { return name; }
+	private String Named.name;
+    
+    after(Named newinstance) : execution(Named+.new(..)) && target(newinstance) {
+    	System.out.println("A new name was created");
+    	newinstance.name = "TikaTikaSlimShady";
+    }
+}
@@ -0,0 +1,5 @@
+
+public interface Named {
+	public String getName();
+	
+}
@@ -0,0 +1,7 @@
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Target;
+
+@Target(ElementType.METHOD)
+public @interface Read {
+
+}
@@ -0,0 +1,7 @@
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Target;
+
+@Target(ElementType.METHOD)
+public @interface Write {
+
+}
