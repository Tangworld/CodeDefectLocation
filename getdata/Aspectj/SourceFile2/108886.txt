@@ -113,7 +113,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
 			SourceTypeBinding[] b = units[i].scope.topLevelTypes;
 			for (int j = 0; j < b.length; j++) {
-				factory.addSourceTypeBinding(b[j]);
+				factory.addSourceTypeBinding(b[j],units[i]);
 			}
 		}
 
@@ -787,7 +787,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 	 * @param aBinding
 	 */
 	public void anonymousTypeBindingCreated(LocalTypeBinding aBinding) {
-		factory.addSourceTypeBinding(aBinding);
+		factory.addSourceTypeBinding(aBinding,null);
 	}
 }
 
@@ -27,6 +27,7 @@ import org.aspectj.ajdt.internal.core.builder.AjBuildManager;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.bridge.IMessage.Kind;
 import org.aspectj.org.eclipse.jdt.core.compiler.CharOperation;
+import org.aspectj.org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
@@ -728,7 +729,7 @@ public class EclipseFactory {
 		return EclipseShadow.makeShadow(this, (ASTNode) context, context);
 	}
 
-	public void addSourceTypeBinding(SourceTypeBinding binding) {
+	public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDeclaration unit) {
 		TypeDeclaration decl = binding.scope.referenceContext;
 
 		// Deal with the raw/basic type to give us an entry in the world type map
@@ -746,7 +747,7 @@ public class EclipseFactory {
 			simpleTx  = UnresolvedType.forName(getName(binding)); 
 		}
 		ReferenceType name  = getWorld().lookupOrCreateName(simpleTx);
-		EclipseSourceType t = new EclipseSourceType(name, this, binding, decl);
+		EclipseSourceType t = new EclipseSourceType(name, this, binding, decl, unit);
 
 		// For generics, go a bit further - build a typex for the generic type
 		// give it the same delegate and link it to the raw type
@@ -766,7 +767,7 @@ public class EclipseFactory {
 
 		ReferenceBinding[] memberTypes = binding.memberTypes;
 		for (int i = 0, length = memberTypes.length; i < length; i++) {
-			addSourceTypeBinding((SourceTypeBinding) memberTypes[i]);
+			addSourceTypeBinding((SourceTypeBinding) memberTypes[i], unit);
 		}
 	}
 
@@ -27,6 +27,7 @@ import org.aspectj.weaver.patterns.PerFromSuper;
 import org.aspectj.org.eclipse.jdt.core.compiler.CharOperation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.StringLiteral;
@@ -52,6 +53,7 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 
 	private SourceTypeBinding binding;
 	private TypeDeclaration declaration;
+	private CompilationUnitDeclaration unit;
 	private boolean annotationsResolved = false;
 	private ResolvedType[] resolvedAnnotations = null;
 
@@ -60,12 +62,14 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 	}
 
 	public EclipseSourceType(ReferenceType resolvedTypeX, EclipseFactory factory,
-								SourceTypeBinding binding, TypeDeclaration declaration)
+								SourceTypeBinding binding, TypeDeclaration declaration,
+								CompilationUnitDeclaration unit)
 	{
 		super(resolvedTypeX, true);
 		this.factory = factory;
 		this.binding = binding;
 		this.declaration = declaration;
+		this.unit = unit;
 
 		resolvedTypeX.setSourceContext(new EclipseSourceContext(declaration.compilationResult));
 		resolvedTypeX.setStartPos(declaration.sourceStart);
@@ -151,7 +155,12 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 					declaredPointcuts.add(df);
 				} else {
 					if (amd.binding == null || !amd.binding.isValidBinding()) continue;
-					declaredMethods.add(factory.makeResolvedMember(amd.binding));
+					ResolvedMember member = factory.makeResolvedMember(amd.binding);
+					if (unit != null) {
+						member.setSourceContext(new EclipseSourceContext(unit.compilationResult,amd.binding.sourceStart()));
+						member.setPosition(amd.binding.sourceStart(),amd.binding.sourceEnd());
+					}
+					declaredMethods.add(member);
 				}
 			}
 		}
@@ -491,6 +491,7 @@
         </compile>
         <compile files="FinalITDMOnInterface2.aj">
             <message kind="error" line="8" text="Cannot override the final method from A.TestInterface"></message>
+            <message kind="error" line="8" text="can't override final void A$TestInterface.m()"></message>
         </compile>
     </ajc-test>
 
@@ -29,6 +29,8 @@
       keywords="from-design">
         <compile files="MultiInheritCF.java">
 			<message kind="error" line="0"/>
+			<message kind="error" line="17"/>
+			<message kind="error" line="18"/>
             <message kind="error" line="21"/>
             <message kind="error" line="41"/>
             <message kind="error" line="42"/>
@@ -534,7 +534,7 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 			parameterizedParameterTypes[i] = 
 				parameterize(getGenericParameterTypes()[i], typeMap,isParameterized);
 		}
-		return new ResolvedMemberImpl(
+		ResolvedMemberImpl ret = new ResolvedMemberImpl(
 					getKind(),
 					newDeclaringType,
 					getModifiers(),
@@ -544,6 +544,8 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 					getExceptions(),
 					this
 				);
+		ret.setSourceContext(getSourceContext());
+		return ret;
 	}
 
 
@@ -1299,9 +1299,6 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 	public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) {
 		//System.err.println("check: " + child.getDeclaringType() + " overrides " + parent.getDeclaringType());
 		if (Modifier.isFinal(parent.getModifiers())) {
-			// XXX horrible test, if we're in eclipes, child.getSourceLocation will be
-			// null, and this message will have already been issued.
-			if (child.getSourceLocation() == null) return false;
 			world.showMessage(Message.ERROR,
 					WeaverMessages.format(WeaverMessages.CANT_OVERRIDE_FINAL_MEMBER,parent),
 					child.getSourceLocation(),null);
