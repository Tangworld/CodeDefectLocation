@@ -88,6 +88,7 @@ public class AsmManager {
 	}
 
 	public static AsmManager getDefault() {
+		new RuntimeException("fetching asm").printStackTrace();
 		return INSTANCE;
 	}
 
@@ -71,18 +71,17 @@ public class AsmManager {
 //	}
 
     protected AsmManager() {
-    	hierarchy = new AspectJElementHierarchy();
-//    	List relationships = new ArrayList();
-		mapper = new RelationshipMap(hierarchy);
-        handleProvider = new OptimizedFullPathHandleProvider(); 
+ 		handleProvider = new OptimizedFullPathHandleProvider();
+    	createNewASM();
     }
 
 	public void createNewASM() {
 		hierarchy = new AspectJElementHierarchy();
 		mapper = new RelationshipMap(hierarchy);
+		// call initialize on the handleProvider when we create a new ASM
+		// to give handleProviders the chance to reset any state
+		handleProvider.initialize();
 	}
-	
-	
 
     public IHierarchy getHierarchy() {
         return hierarchy;	
@@ -490,10 +489,6 @@ public class AsmManager {
 
 	//===================== DELTA PROCESSING CODE ============== start ==========//
 
-	private String getFilename(String hid) {
-		return getHandleProvider().getFileForHandle(hid);
-	}
-	
 	/**
 	 * Removes the hierarchy structure for the specified files from the structure model.
 	 * Returns true if it deleted anything
@@ -515,7 +510,7 @@ public class AsmManager {
 					fw.write("Deleting "+progElem+" node for file "+fileForCompilation+"\n");
 				}
 				removeNode(progElem);
-				deletedNodes.add(getFilename(progElem.getHandleIdentifier()));
+				deletedNodes.add(getCanonicalFilePath(progElem.getSourceLocation().getSourceFile()));
 				if (!model.removeFromFileMap(correctedPath.toString())) 
 						throw new RuntimeException("Whilst repairing model, couldn't remove entry for file: "+correctedPath.toString()+" from the filemap");
 				modelModified = true;
@@ -557,7 +552,7 @@ public class AsmManager {
 					fw.write("Deleting "+progElem+" node for file "+fileForCompilation+"\n");
 				}
 				removeNode(progElem);
-				deletedNodes.add(getFilename(progElem.getHandleIdentifier()));
+				deletedNodes.add(getCanonicalFilePath(progElem.getSourceLocation().getSourceFile()));
 				if (!model.removeFromFileMap(correctedPath.toString())) 
 						throw new RuntimeException("Whilst repairing model, couldn't remove entry for file: "+correctedPath.toString()+" from the filemap");
 				modelModified = true;
@@ -60,4 +60,18 @@ public interface IElementHandleProvider {
 
     public int getOffSetForHandle(String handle);
 
+    // See pr134471 
+    /**
+     * @return true if the handles produced by the provider 
+     * depend on ISourceLocations and false otherwise
+     */
+    public boolean dependsOnLocation();
+    
+    /**
+     * Initializes handle provider state.
+     * 
+     * The initializer is invoked when a new ASM is
+     * created on a full build.
+     */
+    public void initialize();
 }
@@ -406,7 +406,8 @@ public class AspectJElementHierarchy implements IHierarchy {
 		Set k = handleMap.keySet();
 		for (Iterator iter = k.iterator(); iter.hasNext();) {
 			String handle = (String) iter.next();
-			if (deletedFiles.contains(getFilename(handle))) forRemoval.add(handle);
+			IProgramElement ipe = (IProgramElement)handleMap.get(handle);
+			if (deletedFiles.contains(getCanonicalFilePath(ipe)))forRemoval.add(handle); 
 		}
 		for (Iterator iter = forRemoval.iterator(); iter.hasNext();) {
 			String handle = (String) iter.next();
@@ -415,31 +416,37 @@ public class AspectJElementHierarchy implements IHierarchy {
 		forRemoval.clear();
 		k = typeMap.keySet();
 		for (Iterator iter = k.iterator(); iter.hasNext();) {
-			String element = (String) iter.next();
-			IProgramElement ipe = (IProgramElement)typeMap.get(element);
-			if (deletedFiles.contains(getFilename(ipe.getHandleIdentifier()))) forRemoval.add(element);
+			String typeName = (String) iter.next();
+			IProgramElement ipe = (IProgramElement)typeMap.get(typeName);
+			if (deletedFiles.contains(getCanonicalFilePath(ipe))) forRemoval.add(typeName);
 		}
 		for (Iterator iter = forRemoval.iterator(); iter.hasNext();) {
-			String handle = (String) iter.next();
-			typeMap.remove(handle);
+			String typeName = (String) iter.next();
+			typeMap.remove(typeName);
 		}
 		forRemoval.clear();
 		k = fileMap.keySet();
 		for (Iterator iter = k.iterator(); iter.hasNext();) {
-			String element = (String) iter.next();
-			IProgramElement ipe = (IProgramElement)fileMap.get(element);
-			if (deletedFiles.contains(getFilename(ipe.getHandleIdentifier()))) forRemoval.add(element);
+			String filePath = (String) iter.next();
+			IProgramElement ipe = (IProgramElement)fileMap.get(filePath);
+			if (deletedFiles.contains(getCanonicalFilePath(ipe))) forRemoval.add(filePath);
 		}
 		for (Iterator iter = forRemoval.iterator(); iter.hasNext();) {
-			String handle = (String) iter.next();
-			fileMap.remove(handle);
+			String filePath = (String) iter.next();
+			fileMap.remove(filePath);
 		}
-		
 	}
 
 	private String getFilename(String hid) {
 		return AsmManager.getDefault().getHandleProvider().getFileForHandle(hid);
 	}
+	
+	private String getCanonicalFilePath(IProgramElement ipe) {
+		if (ipe.getSourceLocation() != null) {
+			return AsmManager.getDefault().getCanonicalFilePath(ipe.getSourceLocation().getSourceFile());			
+		}
+		return "";
+	}
 
 }
 
@@ -0,0 +1,213 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.asm.internal;
+
+import java.io.File;
+import java.util.Iterator;
+import java.util.List;
+
+import org.aspectj.asm.AsmManager;
+import org.aspectj.asm.IElementHandleProvider;
+import org.aspectj.asm.IProgramElement;
+import org.aspectj.bridge.ISourceLocation;
+import org.aspectj.util.CharOperation;
+import org.aspectj.util.NameConvertor;
+
+/**
+ * Creates JDT-like handles, for example
+ * 
+ * method with string argument:  <tjp{Demo.java[Demo~main~\[QString;
+ * method with generic argument: <pkg{MyClass.java[MyClass~myMethod~QList\<QString;>;
+ * an aspect:					 <pkg*A1.aj}A1
+ * advice with Integer arg:      <pkg*A8.aj}A8&afterReturning&QInteger;
+ * method call:	                 <pkg*A10.aj[C~m1?method-call(void pkg.C.m2())
+ *
+ */
+public class JDTLikeHandleProvider implements IElementHandleProvider {
+ 	
+	// Need to keep our own count of the number of initializers
+	// because this information cannot be gained from the ipe.
+	private int initializerCounter = 0;
+	
+	private char[] empty = new char[]{};
+	private char[] countDelim = new char[]{HandleProviderDelimiter.COUNT.getDelimiter()};
+	
+	private String backslash = "\\";
+	private String emptyString = "";
+	
+	public String createHandleIdentifier(IProgramElement ipe) {
+
+		// AjBuildManager.setupModel --> top of the tree is either
+		// <root> or the .lst file
+		if (ipe == null || 
+				(ipe.getKind().equals(IProgramElement.Kind.FILE_JAVA) 
+						&& ipe.getName().equals("<root>"))) {
+			return "";
+		} else if (ipe.getHandleIdentifier(false) != null) {
+			// have already created the handle for this ipe
+			// therefore just return it
+			return ipe.getHandleIdentifier();
+		} else if (ipe.getKind().equals(IProgramElement.Kind.FILE_LST)) {
+			String configFile = AsmManager.getDefault().getHierarchy().getConfigFile();
+			int start = configFile.lastIndexOf(File.separator);
+			int end = configFile.lastIndexOf(".lst");
+			String fileName = configFile.substring(start + 1,end);
+			ipe.setHandleIdentifier(fileName);
+			return fileName;
+		}
+		IProgramElement parent = ipe.getParent();
+		if (parent != null &&
+				parent.getKind().equals(IProgramElement.Kind.IMPORT_REFERENCE)) {
+			// want to miss out '#import declaration' in the handle
+			parent = ipe.getParent().getParent();
+		}
+		
+		StringBuffer handle = new StringBuffer();
+		// add the handle for the parent
+		handle.append(createHandleIdentifier(parent));
+		// add the correct delimiter for this ipe
+		handle.append(HandleProviderDelimiter.getDelimiter(ipe));
+		// add the name and any parameters unless we're an initializer
+		// (initializer's names are '...')
+		if (!ipe.getKind().equals(IProgramElement.Kind.INITIALIZER)) {
+			handle.append(ipe.getName() + getParameters(ipe));
+		}
+		// add the count, for example '!2' if its the second ipe of its
+		// kind in the aspect
+		handle.append(getCount(ipe));
+
+		ipe.setHandleIdentifier(handle.toString());
+		return handle.toString();
+	}	
+
+	private String getParameters(IProgramElement ipe) {
+		if (ipe.getParameterSignatures() == null || ipe.getParameterSignatures().isEmpty()) return "";
+		StringBuffer sb = new StringBuffer();
+		List parameterTypes = ipe.getParameterSignatures();
+		for (Iterator iter = parameterTypes.iterator(); iter.hasNext();) {
+			char[] element = (char[]) iter.next();
+			sb.append(HandleProviderDelimiter.getDelimiter(ipe));
+			if (element[0] == HandleProviderDelimiter.TYPE.getDelimiter()) {
+				// its an array
+				sb.append(HandleProviderDelimiter.ESCAPE.getDelimiter());
+				sb.append(HandleProviderDelimiter.TYPE.getDelimiter());
+				sb.append(NameConvertor.getTypeName(
+						CharOperation.subarray(element,1,element.length)));
+			} else if (element[0] == NameConvertor.PARAMETERIZED) {
+				// its a parameterized type
+				sb.append(NameConvertor.createShortName(element));
+			} else {
+				sb.append(NameConvertor.getTypeName(element));
+			}
+		}
+		return sb.toString();
+	}
+		
+	private char[] getCount(IProgramElement ipe) {
+		char[] byteCodeName = ipe.getBytecodeName().toCharArray();
+		if (ipe.getKind().isDeclare()) {
+			int index = CharOperation.lastIndexOf('_',byteCodeName);
+			if (index != -1) {
+				return convertCount(CharOperation.subarray(byteCodeName,
+						index+1,byteCodeName.length));
+			}
+		} else if (ipe.getKind().equals(IProgramElement.Kind.ADVICE)) {
+			int lastDollar = CharOperation.lastIndexOf('$',byteCodeName);
+			if (lastDollar != -1) {
+				char[] upToDollar = CharOperation.subarray(byteCodeName,0,lastDollar);
+				int secondToLastDollar = CharOperation.lastIndexOf('$',upToDollar);
+				if (secondToLastDollar != -1) {
+					return convertCount(CharOperation.subarray(upToDollar,
+							secondToLastDollar+1,upToDollar.length));
+				}
+			}		
+		} else if (ipe.getKind().equals(IProgramElement.Kind.INITIALIZER)) {	
+			return String.valueOf(++initializerCounter).toCharArray();
+		}
+		return empty;
+	}
+	
+	/**
+	 * Only returns the count if it's not equal to 1
+	 */
+	private char[] convertCount(char[] c) {
+		if ((c.length == 1 && c[0] != ' ' && c[0] != '1') || c.length > 1) {
+			return CharOperation.concat(countDelim,c);
+		}
+		return empty;
+	}
+	
+    public String getFileForHandle(String handle) {
+    	IProgramElement node = AsmManager.getDefault().getHierarchy().getElement(handle);
+    	if (node != null) {
+        	return AsmManager.getDefault().getCanonicalFilePath(node.getSourceLocation().getSourceFile());			
+		} else if (handle.charAt(0) == HandleProviderDelimiter.ASPECT_CU.getDelimiter() 
+				|| handle.charAt(0) == HandleProviderDelimiter.COMPILATIONUNIT.getDelimiter()) {
+			// it's something like *MyAspect.aj or {MyClass.java. In other words
+			// it's a file node that's been created with no children and no parent
+			return backslash + handle.substring(1);
+		} 
+    	return emptyString;
+    }
+
+    public int getLineNumberForHandle(String handle) {
+    	IProgramElement node = AsmManager.getDefault().getHierarchy().getElement(handle);
+    	if (node != null) {
+    		return node.getSourceLocation().getLine();
+		} else if (handle.charAt(0) == HandleProviderDelimiter.ASPECT_CU.getDelimiter() 
+				|| handle.charAt(0) == HandleProviderDelimiter.COMPILATIONUNIT.getDelimiter()) {
+			// it's something like *MyAspect.aj or {MyClass.java. In other words
+			// it's a file node that's been created with no children and no parent
+			return 1;
+		} 
+    	return -1;
+    }
+
+	public int getOffSetForHandle(String handle) {
+    	IProgramElement node = AsmManager.getDefault().getHierarchy().getElement(handle);
+    	if (node != null) {
+    		return node.getSourceLocation().getOffset();
+		} else if (handle.charAt(0) == HandleProviderDelimiter.ASPECT_CU.getDelimiter() 
+				|| handle.charAt(0) == HandleProviderDelimiter.COMPILATIONUNIT.getDelimiter()) {
+			// it's something like *MyAspect.aj or {MyClass.java. In other words
+			// it's a file node that's been created with no children and no parent
+			return 0;
+		} 		
+    	return -1;
+	}
+
+	public String createHandleIdentifier(ISourceLocation location) {
+		IProgramElement node = AsmManager.getDefault().getHierarchy().findElementForSourceLine(location);
+		if (node != null) {
+			return createHandleIdentifier(node);
+		}
+		return null;
+	}
+
+	public String createHandleIdentifier(File sourceFile, int line, int column, int offset) {
+		IProgramElement node = AsmManager.getDefault().getHierarchy().findElementForOffSet(sourceFile.getAbsolutePath(),line,offset);
+		if (node != null) {
+			return createHandleIdentifier(node);
+		}
+		return null;
+	}
+	
+	public boolean dependsOnLocation() {
+		// handles are independent of soureLocations therefore return false
+		return false;
+	}
+
+	public void initialize() {
+		// reset the initializer count. This ensures we return the
+		// same handle as JDT for initializers.
+		initializerCounter = 0;
+	}
+}
@@ -330,7 +330,8 @@ public class AnnotationBinding extends XMLBasedAjcTestCase {
 			Relationship rel = (Relationship)l.get(0);
 			assertTrue("Should have 1 target but has "+rel.getTargets().size(),rel.getTargets().size()==1);
 			String tgt = (String)rel.getTargets().get(0);
-			assertTrue("Should point to line 10 but doesnt: "+tgt,tgt.indexOf("|10|")!=-1);
+			int lineNumber = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(tgt);
+			assertTrue("Should point to line 10 but doesnt: "+lineNumber,lineNumber == 10);
 	  	}
   }  
 
@@ -360,7 +361,9 @@ public class AnnotationBinding extends XMLBasedAjcTestCase {
 			Relationship rel = (Relationship)l.get(0);
 			assertTrue("Should have 1 target but has "+rel.getTargets().size(),rel.getTargets().size()==1);
 			String tgt = (String)rel.getTargets().get(0);
-			assertTrue("Should point to line 10 but doesnt: "+tgt,tgt.indexOf("|10|")!=-1);
+			int lineNumber = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(tgt);
+			assertTrue("Should point to line 10 but doesnt: "+lineNumber,lineNumber == 10);
+
 	  	}
   }  
 
@@ -390,7 +393,9 @@ public class AnnotationBinding extends XMLBasedAjcTestCase {
 			Relationship rel = (Relationship)l.get(0);
 			assertTrue("Should have 1 target but has "+rel.getTargets().size(),rel.getTargets().size()==1);
 			String tgt = (String)rel.getTargets().get(0);
-			assertTrue("Should point to line 10 but doesnt: "+tgt,tgt.indexOf("|10|")!=-1);
+			int lineNumber = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(tgt);
+			assertTrue("Should point to line 10 but doesnt: "+lineNumber,lineNumber == 10);
+
 	  	}
   }  
 
@@ -19,6 +19,7 @@ public class AllTestsAspectJ153 {
 		TestSuite suite = new TestSuite("AspectJ 1.5.3 tests");
 		//$JUnit-BEGIN$
 		suite.addTest(Ajc153Tests.suite());
+		suite.addTest(JDTLikeHandleProviderTests.suite());
         //$JUnit-END$
 		return suite;
 	}
@@ -0,0 +1,506 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.systemtest.ajc153;
+
+import java.io.File;
+import java.util.Iterator;
+import java.util.List;
+
+import junit.framework.Test;
+
+import org.aspectj.asm.AsmManager;
+import org.aspectj.asm.IElementHandleProvider;
+import org.aspectj.asm.IHierarchy;
+import org.aspectj.asm.IProgramElement;
+import org.aspectj.asm.internal.JDTLikeHandleProvider;
+import org.aspectj.testing.XMLBasedAjcTestCase;
+
+public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
+
+	IElementHandleProvider handleProvider;
+	
+	protected void setUp() throws Exception {
+		super.setUp();
+		handleProvider = AsmManager.getDefault().getHandleProvider();
+		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+	}
+
+	protected void tearDown() throws Exception {
+		super.tearDown();
+		AsmManager.getDefault().setHandleProvider(handleProvider);
+	}
+	
+	public void testMoreThanOneNamedPointcut() {
+		runTest("More than one named pointcut");
+	}
+
+	public void testAspectHandle() {
+		runTest("aspect handle");
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement pe = top.findElementForType("pkg", "A1");
+		String expected = "<pkg*A1.aj}A1";
+		String found = pe.getHandleIdentifier();
+		assertEquals("handleIdentifier - expected " + expected + ", but found "
+				+ found, expected, found);
+	}
+
+	public void testAdviceHandle() {
+		runTest("advice handle");
+		compareHandles(IProgramElement.Kind.ADVICE,
+				"before(): <anonymous pointcut>",
+				"<pkg*A2.aj}A2&before");
+	}
+
+	public void testPointcutHandle() {
+		runTest("pointcut handle");
+		compareHandles(IProgramElement.Kind.POINTCUT,
+				"p()",
+				"<pkg*A4.aj}A4+p");
+	}
+	
+	public void testGetIPEWithAspectHandle() {
+		runTest("get IProgramElement with aspect handle");
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		String handle = "<pkg*A1.aj}A1";
+		IProgramElement ipe = top.getElement(handle);
+		assertNotNull("should have found ipe with handle " + handle, ipe);
+		IProgramElement ipe2 = top.getElement(handle);
+		assertEquals("should be the same IPE",ipe,ipe2);
+	}
+	
+	public void testAdviceHandleWithCrossCutting() {
+		runTest("advice handle with crosscutting");
+		compareHandles(IProgramElement.Kind.ADVICE,
+				"before(): <anonymous pointcut>",
+				"<pkg*A3.aj}A3&before");
+	}
+
+	public void testPointcutHandleWithArgs() {
+		runTest("pointcut handle with args");
+		compareHandles(IProgramElement.Kind.POINTCUT,
+				"p(java.lang.Integer)",
+				"*A6.aj}A6+p+QInteger;");
+	}
+	
+	public void testAdviceHandleWithArgs() {
+		runTest("advice handle with args");
+		compareHandles(IProgramElement.Kind.ADVICE,
+				"afterReturning(java.lang.Integer): p..",
+				"<pkg*A8.aj}A8&afterReturning&QInteger;");
+	}
+
+	public void testFieldITD() {
+		runTest("field itd handle");
+		compareHandles(IProgramElement.Kind.INTER_TYPE_FIELD,
+				"C.x",
+				"<pkg*A9.aj}A9)C.x");
+	}
+	
+	public void testMethodITD() {
+		runTest("method itd handle");
+		compareHandles(IProgramElement.Kind.INTER_TYPE_METHOD,
+				"C.method()",
+				"<pkg*A9.aj}A9)C.method");
+	}
+	
+	public void testMethodITDWithArgs() {
+		runTest("method itd with args handle");
+		compareHandles(IProgramElement.Kind.INTER_TYPE_METHOD,
+				"C.methodWithArgs(int)",
+				"<pkg*A9.aj}A9)C.methodWithArgs)I");
+	}
+	
+	public void testConstructorITDWithArgs() {
+		runTest("constructor itd with args");
+		compareHandles(IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR,
+				"C.C(int,java.lang.String)",
+				"<pkg*A13.aj}A13)C.C)I)QString;");
+	}
+	
+	public void testDeclareParentsHandle() {
+		runTest("declare parents handle");
+		compareHandles(IProgramElement.Kind.DECLARE_PARENTS,
+				"declare parents: implements C2",
+				"<pkg*A7.aj}A7`declare parents");
+	}
+	
+	public void testTwoDeclareParents() {
+		runTest("two declare parents in same file");
+		compareHandles(IProgramElement.Kind.DECLARE_PARENTS,
+				"declare parents: extends C5",
+				"<pkg*A7.aj}A7`declare parents!2");
+	}
+	
+	public void testMethodCallHandle() {
+		runTest("method call handle");
+		compareHandles(IProgramElement.Kind.CODE,
+				"method-call(void pkg.C.m2())",
+				"<pkg*A10.aj[C~m1?method-call(void pkg.C.m2())");
+	}
+	
+	public void testDeclareAtType() {
+		// AJDT: =AJHandleProject/src<pkg*A.aj}A`declare \@type
+		runTest("declare @type");
+		compareHandles(IProgramElement.Kind.DECLARE_ANNOTATION_AT_TYPE,
+				"declare @type: pkg.C : @MyAnnotation",
+				"<pkg*A12.aj}A`declare @type");
+	}
+	
+	public void testDeclareAtField() {
+		// AJDT: =AJHandleProject/src<pkg*A.aj}A`declare \@field
+		runTest("declare @field");
+		compareHandles(IProgramElement.Kind.DECLARE_ANNOTATION_AT_FIELD,
+				"declare @field: int pkg.C.someField : @MyAnnotation",
+				"<pkg*A12.aj}A`declare @field!2");	
+	}
+	
+	public void testDeclareAtMethod() {
+		// AJDT: =AJHandleProject/src<pkg*A.aj}A`declare \@method
+		runTest("declare @method");
+		compareHandles(IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD,
+				"declare @method: public void pkg.C.method1() : @MyAnnotation",
+				"<pkg*A12.aj}A`declare @method!3");	
+	}
+	
+	public void testDeclareAtConstructor() {
+		// AJDT: =AJHandleProject/src<pkg*A.aj}A`declare \@constructor
+		runTest("declare @constructor");
+		compareHandles(IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR,
+				"declare @constructor: pkg.C.new() : @MyAnnotation",
+				"<pkg*A12.aj}A`declare @constructor!4");	
+	}
+	
+	
+	// what about 2 pieces of before advice with the same 
+	// signature and the same pointcut
+	public void testTwoPiecesOfAdviceWithSameSignatureAndPointcut() {
+		runTest("two pieces of advice with the same signature and pointcut");
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement parent = top.findElementForLabel(top.getRoot(),
+				IProgramElement.Kind.ASPECT, "A5");
+		List children = parent.getChildren();
+		String handle1 = null;
+		String handle2 = null;
+		for (Iterator iter = children.iterator(); iter.hasNext();) {
+			IProgramElement element = (IProgramElement) iter.next();
+			if (element.getKind().equals(IProgramElement.Kind.ADVICE)) {
+				if (handle1 == null) {
+					handle1 = element.getHandleIdentifier();
+				} else {
+					handle2 = element.getHandleIdentifier();
+				}
+			}
+		}
+		String expected1 = "<pkg*A5.aj}A5&before";
+		String expected2 = "<pkg*A5.aj}A5&before!2";
+		boolean b = expected1.equals(handle1);
+		if (b) {
+			assertEquals("handleIdentifier - expected " + expected2 + ", but found "
+					+ handle2, expected2, handle2);
+		} else {
+			assertEquals("handleIdentifier - expected " + expected1 + ", but found "
+					+ handle2, expected1, handle2);
+			assertEquals("handleIdentifier - expected " + expected2 + ", but found "
+					+ handle1, expected2, handle1);
+		}
+	}
+	
+	public void testDeclareWarningHandle() {
+		runTest("declare warning handle");
+		compareHandles(IProgramElement.Kind.DECLARE_WARNING,
+				"declare warning: \"Illegal call.\"",
+				"<pkg*A11.aj}A11`declare warning");
+	}
+	
+	public void testTwoDeclareWarningHandles() {
+		runTest("two declare warning handles");
+		compareHandles(IProgramElement.Kind.DECLARE_WARNING,
+				"declare warning: \"blah\"",
+				"<pkg*A11.aj}A11`declare warning!2");
+	}
+	
+	// this is to ensure the logic for not including '1' in the count
+	// works correctly. We don't want a decw ipe with count 1 but we do
+	// want one with count 10.
+	public void testTenDeclareWarningHandles() {
+		runTest("ten declare warning handles");
+		compareHandles(IProgramElement.Kind.DECLARE_WARNING,
+				"declare warning: \"warning 1\"",
+				"*DeclareWarnings.aj}DeclareWarnings`declare warning");
+		compareHandles(IProgramElement.Kind.DECLARE_WARNING,
+				"declare warning: \"warning 10\"",
+				"*DeclareWarnings.aj}DeclareWarnings`declare warning!10");
+
+	}
+	
+	//---------- following tests ensure we produce the same handles as jdt -----//
+	//---------- (apart from the prefix)
+	
+	// NOTES: there is no ipe equivalent to a package fragment root or
+	//        
+	
+	public void testCompilationUnitSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java
+		runTest("compilation unit same as jdt");
+		compareHandles(IProgramElement.Kind.FILE_JAVA,
+				"Demo.java",
+				"<tjp{Demo.java");
+	}
+
+	public void testClassSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{C.java[C
+		runTest("class same as jdt");
+		compareHandles(IProgramElement.Kind.CLASS,
+				"C","<pkg{C.java[C");
+	}
+
+	public void testInterfaceSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{C.java[MyInterface
+		runTest("interface same as jdt");
+		compareHandles(IProgramElement.Kind.INTERFACE,
+				"MyInterface","<pkg{C.java[MyInterface");
+	}
+	
+	public void testConstructorSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{C.java[C~C
+		runTest("constructor same as jdt");
+		compareHandles(IProgramElement.Kind.CONSTRUCTOR,
+				"C()","<pkg{C.java[C~C");
+	}
+	
+	public void testConstructorWithArgsSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{C.java[C~C~QString;
+		runTest("constructor with args same as jdt");
+		compareHandles(IProgramElement.Kind.CONSTRUCTOR,
+				"C(java.lang.String)","<pkg{C.java[C~C~QString;");
+	}
+	
+//	public void testPackageDeclarationSameAsJDT() {
+//		// JDT: =TJP Example/src<tjp{Demo.java%tjp
+//		fail("package declaration isn't the same");
+//		runTest("package declaration same as jdt");
+//		compareHandles(IProgramElement.Kind.PACKAGE,
+//				"tjp",
+//				"<tjp{Demo.java%tjp");
+//	}	
+	
+	public void testImportDeclarationSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java#java.io.*
+		runTest("import declaration same as jdt");
+		compareHandles(IProgramElement.Kind.IMPORT_REFERENCE,
+				"java.io.*",
+				"<tjp{Demo.java#java.io.*");
+	}	
+	
+	public void testTypeSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo
+		runTest("type same as jdt");
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement pe = top.findElementForType("tjp", "Demo");
+		String expected = "<tjp{Demo.java[Demo";
+		String found = pe.getHandleIdentifier();
+		assertEquals("handleIdentifier - expected " + expected + ", but found "
+				+ found, expected, found);
+	}	
+	
+	public void testFieldSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo^d
+		runTest("field same as jdt");
+		compareHandles(IProgramElement.Kind.FIELD,
+				"d",
+				"<tjp{Demo.java[Demo^d");
+	}	
+	public void testInitializationSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo|1 
+		// and =TJP Example/src<tjp{Demo.java[Demo|2
+		runTest("initialization same as jdt");
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement parent = top.findElementForLabel(top.getRoot(),
+				IProgramElement.Kind.CLASS, "Demo");
+		List children = parent.getChildren();
+		String handle1 = null;
+		String handle2 = null;
+		for (Iterator iter = children.iterator(); iter.hasNext();) {
+			IProgramElement element = (IProgramElement) iter.next();
+			if (element.getKind().equals(IProgramElement.Kind.INITIALIZER)) {
+				if (handle1 == null) {
+					handle1 = element.getHandleIdentifier();
+				} else {
+					handle2 = element.getHandleIdentifier();
+				}
+			}
+		}
+		String expected1 = "<tjp{Demo.java[Demo|1";
+		String expected2 = "<tjp{Demo.java[Demo|2";
+		boolean b = expected1.equals(handle1);
+		System.err.println("actual: " + handle1);
+		System.err.println("actual: " + handle2);
+		if (b) {
+			assertEquals("handleIdentifier - expected " + expected2 + ", but found "
+					+ handle2, expected2, handle2);
+		} else {
+			assertEquals("handleIdentifier - expected " + expected1 + ", but found "
+					+ handle2, expected1, handle2);
+			assertEquals("handleIdentifier - expected " + expected2 + ", but found "
+					+ handle1, expected2, handle1);
+		}
+	}	
+	public void testMethodWithStringArrayArgsSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo~main~\[QString;
+		runTest("method with string array as argument same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"main(java.lang.String[])",
+				"<tjp{Demo.java[Demo~main~\\[QString;");
+	}	
+	
+	public void testMethodWithIntArrayArgsSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo~m~\[I
+		runTest("method with int array as argument same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"m(int[])",
+				"<tjp{Demo.java[Demo~m~\\[I");
+	}	
+	
+	public void testMethodWithNoArgsSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo~go
+		runTest("method with no args same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"go()",
+				"<tjp{Demo.java[Demo~go");
+	}	
+	
+	public void testMethodWithTwoArgsSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo~foo~I~QObject;
+		runTest("method with two args same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"foo(int,java.lang.Object)",
+				"<tjp{Demo.java[Demo~foo~I~QObject;");
+	}	
+	
+	public void testMethodWithTwoStringArgsSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo~m2~QString;~QString;
+		runTest("method with two string args same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"m2(java.lang.String,java.lang.String)",
+				"<tjp{Demo.java[Demo~m2~QString;~QString;");		
+	}
+	
+	public void testEnumSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{E.java[E
+		runTest("enum same as jdt");
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement pe = top.findElementForType("pkg", "E");
+		String expected = "<pkg{E.java[E";
+		String found = pe.getHandleIdentifier();
+		assertEquals("handleIdentifier - expected " + expected + ", but found "
+				+ found, expected, found);	
+	}
+	
+	public void testEnumValueSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{E.java[E^A
+		runTest("enum value same as jdt");
+		compareHandles(IProgramElement.Kind.ENUM_VALUE,
+				"A","<pkg{E.java[E^A");
+	}
+	
+	public void testAnnotationSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{MyAnnotation.java[MyAnnotation
+		runTest("annotation same as jdt");
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement pe = top.findElementForType("pkg", "MyAnnotation");
+		String expected = "<pkg{MyAnnotation.java[MyAnnotation";
+		String found = pe.getHandleIdentifier();
+		assertEquals("handleIdentifier - expected " + expected + ", but found "
+				+ found, expected, found);	
+	}
+	
+	public void testMethodWithListArgSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{Java5Class.java[Java5Class~method2~QList;
+		runTest("method with list arg same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"method2(java.util.List)",
+				"<pkg{Java5Class.java[Java5Class~method2~QList;");
+	}
+	
+	public void testMethodWithGenericArgSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{Java5Class.java[Java5Class
+		//       ~genericMethod1~QList\<QString;>;
+		runTest("method with generic arg same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"genericMethod1(java.util.List<java.lang.String>)",
+				"<pkg{Java5Class.java[Java5Class~genericMethod1~QList\\<QString;>;");
+	}
+	
+	public void testMethodWithTwoGenericArgsSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{Java5Class.java[Java5Class
+		//       ~genericMethod2~QList\<QString;>;~QMyGenericClass\<QInteger;>;
+		runTest("method with two generic args same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"genericMethod2(java.util.List<java.lang.String>,"
+					+"pkg.MyGenericClass<java.lang.Integer>)",
+				"<pkg{Java5Class.java[Java5Class~genericMethod2~QList"
+					+"\\<QString;>;~QMyGenericClass\\<QInteger;>;");
+	}
+	
+	public void testMethodWithTwoTypeParametersSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{Java5Class.java[Java5Class~genericMethod4
+		//       ~QMyGenericClass2\<QString;QInteger;>;
+		runTest("method with two type parameters same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"genericMethod4(pkg.MyGenericClass2<java.lang.String,java.lang.Integer>)",
+				"<pkg{Java5Class.java[Java5Class~genericMethod4" +
+				"~QMyGenericClass2\\<QString;QInteger;>;");
+	}
+	
+	public void testMethodWithTwoArgsSameAsJDT_2() {
+		// JDT: =Java5 Handles/src<pkg{Java5Class.java[Java5Class
+		//      ~genericMethod3~I~QList\<QString;>;
+		runTest("method with two args one of which is generic same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"genericMethod3(int,java.util.List<java.lang.String>)",
+				"<pkg{Java5Class.java[Java5Class~genericMethod3~I~QList\\<QString;>;");
+	}
+	
+	/*
+	 * Still to do;
+	 * 				PROJECT,
+				PACKAGE,
+				FILE,
+				FILE_ASPECTJ,
+				FILE_LST,
+				DECLARE_ERROR,
+				DECLARE_SOFT,
+				DECLARE_PRECEDENCE,
+	 */
+	
+	// ----------- helper methods ---------------
+	
+	private void compareHandles(IProgramElement.Kind kind, String ipeName, String expectedHandle) {
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement pe = top.findElementForLabel(top.getRoot(),kind,ipeName);
+		String found = pe.getHandleIdentifier();
+		System.err.println("expected: " + expectedHandle);
+		System.err.println("actual:   " + found);
+		assertEquals("handleIdentifier - expected " + expectedHandle + ", but found "
+				+ found, expectedHandle, found);
+	}
+	
+	// ///////////////////////////////////////
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(JDTLikeHandleProviderTests.class);
+	}
+
+	protected File getSpecFile() {
+		return new File(
+				"../tests/src/org/aspectj/systemtest/ajc152/jdtlikehandleprovider.xml");
+	}
+
+}
@@ -25,13 +25,15 @@ import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.ajdt.internal.core.builder.AjState;
 import org.aspectj.ajdt.internal.core.builder.IncrementalStateManager;
 import org.aspectj.asm.AsmManager;
+import org.aspectj.asm.IElementHandleProvider;
+import org.aspectj.asm.IHierarchy;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.asm.IRelationship;
 import org.aspectj.asm.IRelationshipMap;
+import org.aspectj.asm.internal.JDTLikeHandleProvider;
 import org.aspectj.asm.internal.Relationship;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.tools.ajc.Ajc;
-import org.aspectj.weaver.World;
 
 /**
  * The superclass knows all about talking through Ajde to the compiler.
@@ -1040,7 +1042,7 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 				((IMessage)MyTaskListManager.getWarningMessages().get(0)).getSourceLocation().getLine());
 		alter("PR134541","inc1");
 		build("PR134541");
-		if (World.compareLocations)
+		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
 		  checkWasFullBuild(); // the line number has changed... but nothing structural about the code
 		else 
 		  checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
@@ -1048,6 +1050,131 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 				((IMessage)MyTaskListManager.getWarningMessages().get(0)).getSourceLocation().getLine());
 	}
 
+	public void testJDTLikeHandleProviderWithLstFile_pr141730() {
+		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
+		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+		configureBuildStructureModel(true);
+		try {
+			// The JDTLike-handles should start with the name
+			// of the buildconfig file
+			initialiseProject("JDTLikeHandleProvider");
+			build("JDTLikeHandleProvider");
+			IHierarchy top = AsmManager.getDefault().getHierarchy();
+		  	IProgramElement pe = top.findElementForType("pkg","A");
+		  	String expectedHandle = "build<pkg*A.aj}A";
+		  	assertEquals("expected handle to be " + expectedHandle + ", but found "
+		  			+ pe.getHandleIdentifier(),expectedHandle,pe.getHandleIdentifier());	
+		} finally {
+			AsmManager.getDefault().setHandleProvider(handleProvider);
+		  	configureBuildStructureModel(false);			
+		}
+	}
+	
+	public void testMovingAdviceDoesntChangeHandles_pr141730() {
+		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
+		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+		configureBuildStructureModel(true);
+		try {
+			initialiseProject("JDTLikeHandleProvider");
+			build("JDTLikeHandleProvider");
+			checkWasFullBuild();
+			IHierarchy top = AsmManager.getDefault().getHierarchy();
+			IProgramElement pe = top.findElementForLabel(top.getRoot(),
+					IProgramElement.Kind.ADVICE,"before(): <anonymous pointcut>");
+		  	// add a line which shouldn't change the handle
+			alter("JDTLikeHandleProvider","inc1");
+			build("JDTLikeHandleProvider");
+			checkWasntFullBuild();
+			IHierarchy top2 = AsmManager.getDefault().getHierarchy();
+			IProgramElement pe2 = top.findElementForLabel(top2.getRoot(),
+					IProgramElement.Kind.ADVICE,"before(): <anonymous pointcut>");
+			assertEquals("expected advice to be on line " + pe.getSourceLocation().getLine() + 1 
+					+ " but was on " + pe2.getSourceLocation().getLine(),
+					pe.getSourceLocation().getLine()+1,pe2.getSourceLocation().getLine());
+			assertEquals("expected advice to have handle " + pe.getHandleIdentifier()
+					+ " but found handle " + pe2.getHandleIdentifier(),
+					pe.getHandleIdentifier(),pe2.getHandleIdentifier());		
+		} finally {
+			AsmManager.getDefault().setHandleProvider(handleProvider);
+		  	configureBuildStructureModel(false);			
+		}
+	}
+	
+	public void testSwappingAdviceAndHandles_pr141730() {
+		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
+		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+		configureBuildStructureModel(true);
+		try {
+			initialiseProject("JDTLikeHandleProvider");
+			build("JDTLikeHandleProvider");
+			IHierarchy top = AsmManager.getDefault().getHierarchy();
+
+			IProgramElement call = top.findElementForLabel(top.getRoot(),
+					IProgramElement.Kind.ADVICE, "after(): callPCD..");
+			IProgramElement exec = top.findElementForLabel(top.getRoot(),
+					IProgramElement.Kind.ADVICE, "after(): execPCD..");
+		  	// swap the two after advice statements over. This forces
+			// a full build which means 'after(): callPCD..' will now
+			// be the second after advice in the file and have the same
+			// handle as 'after(): execPCD..' originally did.
+			alter("JDTLikeHandleProvider","inc2");
+			build("JDTLikeHandleProvider");
+			checkWasFullBuild();
+			
+			IHierarchy top2 = AsmManager.getDefault().getHierarchy();
+			IProgramElement newCall = top2.findElementForLabel(top2.getRoot(),
+					IProgramElement.Kind.ADVICE, "after(): callPCD..");
+			IProgramElement newExec = top2.findElementForLabel(top2.getRoot(),
+					IProgramElement.Kind.ADVICE, "after(): execPCD..");
+
+			assertEquals("after swapping places, expected 'after(): callPCD..' " +
+					"to be on line " + newExec.getSourceLocation().getLine() +
+					" but was on line " + call.getSourceLocation().getLine(),
+					newExec.getSourceLocation().getLine(),
+					call.getSourceLocation().getLine());
+			assertEquals("after swapping places, expected 'after(): callPCD..' " +
+					"to have handle " + exec.getHandleIdentifier() +
+					" (because was full build) but had " + newCall.getHandleIdentifier(),
+					exec.getHandleIdentifier(), newCall.getHandleIdentifier());
+		} finally {
+			AsmManager.getDefault().setHandleProvider(handleProvider);
+		  	configureBuildStructureModel(false);			
+		}
+	}
+	
+	public void testInitializerCountForJDTLikeHandleProvider_pr141730() {
+		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
+		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+		configureBuildStructureModel(true);
+		try {
+			initialiseProject("JDTLikeHandleProvider");
+			build("JDTLikeHandleProvider");
+			String expected = "build<pkg*A.aj[C|1";
+
+			IHierarchy top = AsmManager.getDefault().getHierarchy();
+			IProgramElement init = top.findElementForLabel(top.getRoot(),
+					IProgramElement.Kind.INITIALIZER, "...");
+			assertEquals("expected initializers handle to be " + expected + "," +
+					" but found " + init.getHandleIdentifier(true),
+					expected,init.getHandleIdentifier(true));
+			
+			alter("JDTLikeHandleProvider","inc2");
+			build("JDTLikeHandleProvider");
+			checkWasFullBuild();
+			
+			IHierarchy top2 = AsmManager.getDefault().getHierarchy();
+			IProgramElement init2 = top2.findElementForLabel(top2.getRoot(),
+					IProgramElement.Kind.INITIALIZER, "...");
+			assertEquals("expected initializers handle to still be " + expected + "," +
+					" but found " + init2.getHandleIdentifier(true),
+					expected,init2.getHandleIdentifier(true));
+
+		
+		} finally {
+			AsmManager.getDefault().setHandleProvider(handleProvider);
+		  	configureBuildStructureModel(false);			
+		}
+	}
 
 	// 134471 related tests perform incremental compilation and verify features of the structure model post compile
 	public void testPr134471_IncrementalCompilationAndModelUpdates() {
@@ -1105,7 +1232,12 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		// Step3. No structural change to the aspect but the advice has moved down a few lines... (change in source location)
 		alter("PR134471_2","inc1");
 		build("PR134471_2");
-		checkWasFullBuild(); // this is true whilst we consider sourcelocation in the type/shadow munger equals() method - have to until the handles are independent of location
+		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
+			  checkWasFullBuild(); // the line number has changed... but nothing structural about the code
+			else 
+			  checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
+
+		//checkWasFullBuild(); // this is true whilst we consider sourcelocation in the type/shadow munger equals() method - have to until the handles are independent of location
 
 		// Step4. Check we have correctly realised the advice moved to line 11
 		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
@@ -1134,38 +1266,38 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 	public void testPr134471_IncrementallyRecompilingTheAffectedClass() {
 		try {
 			// see pr148027 AsmHierarchyBuilder.shouldAddUsesPointcut=false;
-		configureBuildStructureModel(true);
-		configureNonStandardCompileOptions("-showWeaveInfo -emacssym");
-		
-		// Step1. build the project
-		initialiseProject("PR134471");
-		build("PR134471");
-		
-		// Step2. confirm advice is from correct location
-		IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
-		int line = programElement.getSourceLocation().getLine();
-		assertTrue("advice should be at line 7 - but is at line "+line,line==7);
-
-		// Step3. No change to the aspect at all
-		alter("PR134471","inc1");
-		build("PR134471");
-		
-		// Step4. Quick check that the advice points to something...
-		IProgramElement nodeForTypeA = checkForNode("pkg","A",true);
-		IProgramElement nodeForAdvice = findAdvice(nodeForTypeA);
-		List relatedElements = getRelatedElements(nodeForAdvice,1);
+			configureBuildStructureModel(true);
+			configureNonStandardCompileOptions("-showWeaveInfo -emacssym");
+			
+			// Step1. build the project
+			initialiseProject("PR134471");
+			build("PR134471");
+			
+			// Step2. confirm advice is from correct location
+			IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
+			int line = programElement.getSourceLocation().getLine();
+			assertTrue("advice should be at line 7 - but is at line "+line,line==7);
+	
+			// Step3. No change to the aspect at all
+			alter("PR134471","inc1");
+			build("PR134471");
+			
+			// Step4. Quick check that the advice points to something...
+			IProgramElement nodeForTypeA = checkForNode("pkg","A",true);
+			IProgramElement nodeForAdvice = findAdvice(nodeForTypeA);
+			List relatedElements = getRelatedElements(nodeForAdvice,1);
+			
+		    // Step5. No change to the file C but it should still be advised afterwards
+			alter("PR134471","inc2");
+			build("PR134471");
+			checkWasntFullBuild();
 
-	    // Step5. No change to the file C but it should still be advised afterwards
-		alter("PR134471","inc2");
-		build("PR134471");
-		checkWasntFullBuild();
-	
-		// Step6. confirm advice is from correct location
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
-		line = programElement.getSourceLocation().getLine();
-		assertTrue("advice should be at line 7 - but is at line "+line,line==7);		
-	} finally {
-		// see pr148027 AsmHierarchyBuilder.shouldAddUsesPointcut=true;
+			// Step6. confirm advice is from correct location
+			programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
+			line = programElement.getSourceLocation().getLine();
+			assertTrue("advice should be at line 7 - but is at line "+line,line==7);		
+		} finally {
+			// see pr148027 AsmHierarchyBuilder.shouldAddUsesPointcut=true;
 		}
 
 	}
@@ -1193,7 +1325,12 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		// Step4. Move declare warning in the aspect
 		alter("PR134471_3","inc1");
 		build("PR134471_3");
-		checkWasFullBuild();
+		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
+			  checkWasFullBuild(); // the line number has changed... but nothing structural about the code
+			else 
+			  checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
+
+		//checkWasFullBuild();
 
 		// Step5. confirm declare warning is from correct location, decw (now at line 12) in pkg.A matches line 7 in pkg.C
 		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true),7));
@@ -1210,6 +1347,7 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		line = programElement.getSourceLocation().getLine();
 		assertTrue("declare warning should be at line 12 - but is at line "+line,line==12);
 
+		configureBuildStructureModel(false);
 	}
 
 	// similar to previous test but with 'declare warning' as well as advice
@@ -1235,7 +1373,12 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		// Step4. Move declare warning in the aspect
 		alter("PR134471_3","inc1");
 		build("PR134471_3");
-		checkWasFullBuild();
+		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
+			  checkWasFullBuild(); // the line number has changed... but nothing structural about the code
+			else 
+			  checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
+
+		//checkWasFullBuild();
 
 		// Step5. confirm declare warning is from correct location, decw (now at line 12) in pkg.A matches line 7 in pkg.C
 		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true),7));
@@ -1262,8 +1405,9 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		line = programElement.getSourceLocation().getLine();
 		assertTrue("declare warning should be at line 12 - but is at line "+line,line==12);
 
+		configureBuildStructureModel(false);
 	}
-
+	
 	// --- helper code ---
 
 	/**
@@ -16,6 +16,7 @@ package org.aspectj.weaver;
 import java.util.Collections;
 import java.util.List;
 
+import org.aspectj.asm.AsmManager;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.weaver.bcel.Utility;
@@ -391,7 +392,8 @@ public abstract class Advice extends ShadowMunger {
         return o.kind.equals(kind) 
         	&& ((o.pointcut == null) ? (pointcut == null) : o.pointcut.equals(pointcut))
         	&& ((o.signature == null) ? (signature == null) : o.signature.equals(signature))
-        	&& (World.compareLocations?((o.getSourceLocation()==null) ? (getSourceLocation()==null): o.getSourceLocation().equals(getSourceLocation())):true) // pr134471 - remove when handles are improved to be independent of location
+        	&& (AsmManager.getDefault().getHandleProvider().dependsOnLocation()
+        			?((o.getSourceLocation()==null) ? (getSourceLocation()==null): o.getSourceLocation().equals(getSourceLocation())):true) // pr134471 - remove when handles are improved to be independent of location
         	;
 
     }
@@ -17,6 +17,7 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.Map;
 
+import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IRelationship;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
@@ -114,7 +115,8 @@ public class Checker extends ShadowMunger {
         return  
           o.isError == isError &&
         	 ((o.pointcut == null) ? (pointcut == null) : o.pointcut.equals(pointcut)) &&
-          (World.compareLocations?((o.getSourceLocation()==null) ? (getSourceLocation()==null): o.getSourceLocation().equals(getSourceLocation())):true) // pr134471 - remove when handles are improved to be independent of location
+          (AsmManager.getDefault().getHandleProvider().dependsOnLocation()
+        		  ?((o.getSourceLocation()==null) ? (getSourceLocation()==null): o.getSourceLocation().equals(getSourceLocation())):true) // pr134471 - remove when handles are improved to be independent of location
         	;
     }
 
@@ -21,6 +21,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import org.aspectj.asm.AsmManager;
 import org.aspectj.weaver.patterns.CflowPointcut;
 import org.aspectj.weaver.patterns.DeclareParents;
 import org.aspectj.weaver.patterns.IVerificationRequired;
@@ -76,7 +77,8 @@ public class CrosscuttingMembersSet {
 				CflowPointcut.clearCaches(aspectType);
 				change = true;
 			} else {
-				if (!World.compareLocations && inWeavingPhase) {
+				if (!AsmManager.getDefault().getHandleProvider().dependsOnLocation()
+						&& inWeavingPhase) {
 					// bug 134541 - even though we haven't changed we may have updated the 
 					// sourcelocation for the shadowMunger which we need to pick up
 					shadowMungers = null;
@@ -54,12 +54,7 @@ public abstract class World implements Dump.INode {
 
 	/** The heart of the world, a map from type signatures to resolved types */
     protected TypeMap typeMap = new TypeMap(this); // Signature to ResolvedType
-    
-    // See pr134471 - we would like to set this false but need for handles in the structure model
-    // to be independent of location before we can do that.
-    /** Should we take into account source location when comparing mungers - which may trigger full builds */
-    public final static boolean compareLocations = true;
-  
+
     // see pr145963
     /** Should we create the hierarchy for binary classes and aspects*/
     public static boolean createInjarHierarchy = true;
@@ -31,6 +31,7 @@ import org.aspectj.apache.bcel.generic.InstructionHandle;
 import org.aspectj.apache.bcel.generic.InstructionList;
 import org.aspectj.apache.bcel.generic.Type;
 import org.aspectj.apache.bcel.generic.annotation.AnnotationGen;
+import org.aspectj.asm.AsmManager;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.bridge.Message;
@@ -1679,7 +1680,8 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
         BcelTypeMunger o = (BcelTypeMunger) other;
         return ((o.getMunger() == null) ? (getMunger() == null) : o.getMunger().equals(getMunger()))
                && ((o.getAspectType() == null) ? (getAspectType() == null) : o.getAspectType().equals(getAspectType()))
-               && (World.compareLocations?((o.getSourceLocation()==null)? (getSourceLocation()==null): o.getSourceLocation().equals(getSourceLocation())):true); // pr134471 - remove when handles are improved to be independent of location
+               && (AsmManager.getDefault().getHandleProvider().dependsOnLocation()
+            		   ?((o.getSourceLocation()==null)? (getSourceLocation()==null): o.getSourceLocation().equals(getSourceLocation())):true); // pr134471 - remove when handles are improved to be independent of location
 
     }
 
@@ -21,6 +21,10 @@ public class NameConvertor {
 	private static final char LONG		= 'J';
 	private static final char SHORT		= 'S';
 	private static final char ARRAY		= '[';
+	private static final char RESOLVED = 'L';
+	private static final char UNRESOLVED = 'Q';
+	
+	public static final char PARAMETERIZED = 'P';
 
 	private static final char[] BOOLEAN_NAME = new char[]{'b','o','o','l','e','a','n'};
 	private static final char[] BYTE_NAME = new char[]{'b','y','t','e'};
@@ -35,6 +39,8 @@ public class NameConvertor {
 	private static final char[] GREATER_THAN = new char[]{'>'};
 	private static final char[] LESS_THAN = new char[]{'<'};
 	private static final char[] COMMA = new char[]{','};
+	private static final char[] BACKSLASH_LESSTHAN = new char[]{'\\','<'};
+	private static final char[] SEMICOLON = new char[]{';'};
 
 
 	/**
@@ -135,5 +141,73 @@ public class NameConvertor {
 		}
 	}
 
+	/**
+	 * Given 'Ppkg/MyGenericClass<Ljava/lang/String;Ljava/lang/Integer;>;'
+	 * will return 'QMyGenericClass<QString;QInteger;>;'
+	 */
+	public static char[] createShortName(char[] c) {
+		int lt = CharOperation.indexOf('<',c);
+		int sc = CharOperation.indexOf(';',c);
+		int gt = CharOperation.indexOf('>',c);
+		
+		int smallest = 0;
+		if (lt == -1 && sc == -1 && gt == -1) {
+			// we have something like 'Ljava/lang/String' or 'I'
+			return getTypeName(c);
+		} else if (lt != -1 && (sc == -1 || lt <= sc) && (gt == -1 || lt <= gt)) {
+			// we have something like 'Ljava/lang/String<I'
+			smallest = lt;
+		} else if (sc != -1 && (lt == -1 || sc <= lt) && (gt == -1 || sc <= gt)) {
+			// we have something like 'Ljava/lang/String;I'
+			smallest = sc;
+		} else {
+			// we have something like '>;'
+			smallest = gt;
+		}
+		char[] first = CharOperation.subarray(c,0,smallest);
+		char[] second = CharOperation.subarray(c,smallest+1,c.length);
+		if (smallest == 0 && first.length == 0 && c[0] == '>') {
+			// c = {'>',';'} therefore we just want to return c to
+			// close the generic signature
+			return c;
+		} else if (first.length == 1 && second.length == 0) {
+			return first;
+		} else if (second.length == 0 || (second.length == 1 && second[0] == ';')){
+			// we've reached the end of the array, therefore only care about
+			// the first part
+			return createShortName(first);
+		} else if (smallest == lt) {
+			// if c = 'Ljava/lang/String;<I' then first = 'Ljava/Lang/String;' and
+			// second = 'I'. Want to end up with 'LString<I' and so add
+			// the '<' back.
+			char[] inclLT = CharOperation.concat(createShortName(first),BACKSLASH_LESSTHAN);
+			return CharOperation.concat(inclLT,createShortName(second));
+		} else if (smallest == gt) {
+			char[] inclLT = CharOperation.concat(createShortName(first),GREATER_THAN);
+			return CharOperation.concat(inclLT,createShortName(second));			
+		} else {
+			// if c = 'Ljava/lang/Sting;LMyClass;' then first = 'Ljava/lang/String'
+			// and second = 'LMyClass;'. Want to end up with 'QString;QMyClass;
+			// so add the ';' back
+			char[] firstTypeParam = CharOperation.concat(createShortName(first),SEMICOLON);
+			return CharOperation.concat(firstTypeParam,createShortName(second));
+		}
+	}
 
+	/**
+	 * Given 'Qjava/lang/String;' returns 'QString;'
+	 */
+	public static char[] getTypeName(char[] name) {
+		int i = CharOperation.lastIndexOf('/',name);
+		if (i != -1) {
+			if (name[0] == RESOLVED || name[0] == PARAMETERIZED) {
+				return CharOperation.concat(new char[]{UNRESOLVED},
+						CharOperation.subarray(name,i+1,name.length));
+			} else {
+				return CharOperation.concat(new char[]{name[0]},
+						CharOperation.subarray(name,i+1,name.length));
+			}
+		}
+		return name;
+	}
 }
@@ -88,4 +88,14 @@ public class FullPathHandleProvider implements IElementHandleProvider {
 		ipe.setHandleIdentifier(handle);
 		return handle;
 	}
+
+	public boolean dependsOnLocation() {
+		// handles contain information from the source location therefore 
+		// return true;
+		return true;
+	}
+
+	public void initialize() {
+		// nothing to initialize...
+	}
 }
@@ -112,4 +112,14 @@ public class OptimizedFullPathHandleProvider implements IElementHandleProvider {
 		ipe.setHandleIdentifier(handle);
 		return handle;
 	}
+
+	public boolean dependsOnLocation() {
+		// handles contain information from the source location therefore 
+		// return true;
+		return true;
+	}
+
+	public void initialize() {
+		// nothing to initialize
+	}
 }
@@ -0,0 +1,211 @@
+<!DOCTYPE suite SYSTEM "../tests/ajcTestSuite.dtd"[]>
+
+<!-- AspectJ v1.5.2 Tests -->
+<suite>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="More than one named pointcut">
+      <compile files="HandleProvider.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="aspect handle">
+      <compile files="A1.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="advice handle">
+      <compile files="A2.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="pointcut handle">
+      <compile files="A4.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="get IProgramElement with aspect handle">
+      <compile files="A1.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="advice handle with crosscutting">
+      <compile files="A3.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="two pieces of advice with the same signature and pointcut">
+      <compile files="A5.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="pointcut handle with args">
+      <compile files="A6.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="declare parents handle">
+      <compile files="A7.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="two declare parents in same file">
+      <compile files="A7.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="advice handle with args">
+      <compile files="A8.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="field itd handle">
+      <compile files="A9.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method itd handle">
+      <compile files="A9.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method itd with args handle">
+      <compile files="A9.aj" options="-emacssym"/>
+    </ajc-test>
+
+   <ajc-test dir="features153/jdtlikehandleprovider" title="constructor itd with args">
+      <compile files="A13.aj" options="-emacssym">
+        <message kind="warning" text="inter-type constructor"/>
+      </compile>   
+   </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method call handle">
+      <compile files="A10.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="declare warning handle">
+      <compile files="A11.aj" options="-emacssym">
+        <message kind="warning" text="blah"/>
+        <message kind="warning" text="Illegal call"/>
+      </compile>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="two declare warning handles">
+      <compile files="A11.aj" options="-emacssym">
+        <message kind="warning" text="blah"/>
+        <message kind="warning" text="Illegal call"/>
+      </compile>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="ten declare warning handles">
+      <compile files="DeclareWarnings.aj" options="-emacssym">
+        <message kind="warning" text="warning 1"/>
+        <message kind="warning" text="warning 2"/>
+        <message kind="warning" text="warning 3"/>
+        <message kind="warning" text="warning 4"/>
+        <message kind="warning" text="warning 5"/>
+        <message kind="warning" text="warning 6"/>
+        <message kind="warning" text="warning 7"/>
+        <message kind="warning" text="warning 8"/>
+        <message kind="warning" text="warning 9"/>
+        <message kind="warning" text="warning 10"/>
+      </compile>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="declare @type">
+      <compile files="A12.aj" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="declare @field">
+      <compile files="A12.aj" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="declare @method">
+      <compile files="A12.aj" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="declare @constructor">
+      <compile files="A12.aj" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <!-- tests to ensure handle provider produces same as the jdt -->
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="compilation unit same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="class same as jdt">
+      <compile files="C.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="interface same as jdt">
+      <compile files="C.java" options="-emacssym"/>
+    </ajc-test>
+
+   <ajc-test dir="features153/jdtlikehandleprovider" title="constructor same as jdt">
+      <compile files="C.java" options="-emacssym"/>
+    </ajc-test>
+
+   <ajc-test dir="features153/jdtlikehandleprovider" title="constructor with args same as jdt">
+      <compile files="C.java" options="-emacssym"/>
+    </ajc-test>
+
+<!--    <ajc-test dir="features153/jdtlikehandleprovider" title="package declaration same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+-->
+    <ajc-test dir="features153/jdtlikehandleprovider" title="import declaration same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="type same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="field same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="initialization same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with string array as argument same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with int array as argument same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with no args same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with two args same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with two string args same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="enum same as jdt">
+      <compile files="E.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="enum value same as jdt">
+      <compile files="E.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="annotation same as jdt">
+      <compile files="MyAnnotation.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with list arg same as jdt">
+      <compile files="Java5Class.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with generic arg same as jdt">
+      <compile files="Java5Class.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with two generic args same as jdt">
+      <compile files="Java5Class.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with two type parameters same as jdt">
+      <compile files="Java5Class.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with two args one of which is generic same as jdt">
+      <compile files="Java5Class.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+</suite>
@@ -0,0 +1,125 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.asm.internal;
+
+import org.aspectj.asm.IProgramElement;
+
+/**
+ * Uses "typesafe enum" pattern.
+ */
+public class HandleProviderDelimiter {
+
+	// taken from JavaElement
+	public static final HandleProviderDelimiter JAVAPROJECT = new HandleProviderDelimiter('=');
+	public static final HandleProviderDelimiter PACKAGEFRAGMENT = new HandleProviderDelimiter('<');
+	public static final HandleProviderDelimiter FIELD = new HandleProviderDelimiter('^');
+	public static final HandleProviderDelimiter METHOD = new HandleProviderDelimiter('~');
+	public static final HandleProviderDelimiter INITIALIZER = new HandleProviderDelimiter('|');
+	public static final HandleProviderDelimiter COMPILATIONUNIT = new HandleProviderDelimiter('{');
+	public static final HandleProviderDelimiter CLASSFILE = new HandleProviderDelimiter('(');
+	public static final HandleProviderDelimiter TYPE = new HandleProviderDelimiter('[');
+	public static final HandleProviderDelimiter IMPORTDECLARATION = new HandleProviderDelimiter('#');
+	public static final HandleProviderDelimiter COUNT = new HandleProviderDelimiter('!');
+	public static final HandleProviderDelimiter ESCAPE = new HandleProviderDelimiter('\\');
+	// these below are not currently used because no iprogramelement.kind equivalent
+	public static final HandleProviderDelimiter PACKAGEFRAGMENTROOT = new HandleProviderDelimiter('/');
+	public static final HandleProviderDelimiter PACKAGEDECLARATION = new HandleProviderDelimiter('%');
+	public static final HandleProviderDelimiter LOCALVARIABLE = new HandleProviderDelimiter('@');
+	public static final HandleProviderDelimiter TYPE_PARAMETER = new HandleProviderDelimiter(']');
+	
+	
+	// AspectJ specific ones
+	public static final HandleProviderDelimiter ASPECT_CU = new HandleProviderDelimiter('*');
+	public static final HandleProviderDelimiter ADVICE = new HandleProviderDelimiter('&');
+	public static final HandleProviderDelimiter ASPECT_TYPE = new HandleProviderDelimiter('}');
+	public static final HandleProviderDelimiter CODEELEMENT = new HandleProviderDelimiter('?');
+	public static final HandleProviderDelimiter ITD = new HandleProviderDelimiter(')');
+	public static final HandleProviderDelimiter DECLARE = new HandleProviderDelimiter('`');
+	public static final HandleProviderDelimiter POINTCUT = new HandleProviderDelimiter('+');
+	
+
+	private static char empty = ' ';
+	private final char delim;
+	
+	private HandleProviderDelimiter(char delim) {
+		this.delim = delim;
+	}
+
+	/**
+	 * Returns the delimiter for the HandleProviderDelimiter, 
+	 * for example ASPECT returns '*' and METHOD returns '~'
+	 */
+	public char getDelimiter() {
+		return delim;
+	}
+	
+	/**
+	 * Returns the delimiter for the given IProgramElement for example
+	 * if the IProgramElement is an aspect returns '*' and if the
+	 * IProgramElement is a method returns '~'
+	 */
+	public static char getDelimiter(IProgramElement ipe) {
+		IProgramElement.Kind kind = ipe.getKind();
+		if (kind.equals(IProgramElement.Kind.PROJECT)) {
+			return JAVAPROJECT.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.PACKAGE)) {
+			return PACKAGEFRAGMENT.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.FILE_JAVA)) {
+			if (ipe.getName().endsWith(".aj")) {
+				return ASPECT_CU.getDelimiter();
+			} else {
+				return COMPILATIONUNIT.getDelimiter();				
+			}
+		} else if (kind.equals(IProgramElement.Kind.FILE_ASPECTJ)) {
+			return ASPECT_CU.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.IMPORT_REFERENCE)) {
+			return IMPORTDECLARATION.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.CLASS) 
+				|| kind.equals(IProgramElement.Kind.INTERFACE)
+				|| kind.equals(IProgramElement.Kind.ENUM)
+				|| kind.equals(IProgramElement.Kind.ANNOTATION)) {
+			return TYPE.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.ASPECT)) {
+			return ASPECT_TYPE.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.INITIALIZER)) {
+			return INITIALIZER.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.INTER_TYPE_FIELD)
+				|| kind.equals(IProgramElement.Kind.INTER_TYPE_METHOD)
+				|| kind.equals(IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR)
+				|| kind.equals(IProgramElement.Kind.INTER_TYPE_PARENT)) {
+			return ITD.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.CONSTRUCTOR)
+				|| kind.equals(IProgramElement.Kind.METHOD)) {
+			return METHOD.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.FIELD)
+				|| kind.equals(IProgramElement.Kind.ENUM_VALUE)) {
+			return FIELD.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.POINTCUT)) {
+			return POINTCUT.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.ADVICE)) {
+			return ADVICE.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.DECLARE_PARENTS)
+				|| kind.equals(IProgramElement.Kind.DECLARE_WARNING)
+				|| kind.equals(IProgramElement.Kind.DECLARE_ERROR)
+				|| kind.equals(IProgramElement.Kind.DECLARE_SOFT)
+				|| kind.equals(IProgramElement.Kind.DECLARE_PRECEDENCE)
+				|| kind.equals(IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR)
+				|| kind.equals(IProgramElement.Kind.DECLARE_ANNOTATION_AT_FIELD)
+				|| kind.equals(IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD)
+				|| kind.equals(IProgramElement.Kind.DECLARE_ANNOTATION_AT_TYPE)) {
+			return DECLARE.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.CODE)) {
+			return CODEELEMENT.getDelimiter();
+		} 
+		return empty;
+	}
+	
+}
@@ -48,6 +48,16 @@ public class CharOperation {
 	/**
 	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
 	 */	
+	public static final boolean contains(char character, char[] array) {
+		for (int i = array.length; --i >= 0;)
+			if (array[i] == character)
+				return true;
+		return false;
+	}
+
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
 	public static final int indexOf(char toBeFound, char[] array) {
 		for (int i = 0; i < array.length; i++)
 			if (toBeFound == array[i])
@@ -0,0 +1,23 @@
+package pkg;
+
+aspect A {
+	
+	before() : execution(* *.*(..)) {
+	}
+	
+	after() : callPCD(){
+	}
+	after() : execPCD(){
+	}
+	pointcut callPCD(): call(* *.*(..));
+	pointcut execPCD(): execution(* *.*(..));
+}
+
+class C {
+	
+	public void m() {
+	}
+	
+    static { 	
+    }
+}
@@ -0,0 +1,23 @@
+package pkg;
+
+aspect A {
+	
+	
+	before() : execution(* *.*(..)) {
+	}
+	after() : callPCD(){
+	}
+	after() : execPCD(){
+	}
+	pointcut callPCD(): call(* *.*(..));
+	pointcut execPCD(): execution(* *.*(..));
+}
+
+class C {
+	
+	public void m() {
+	}
+	
+    static { 	
+    }
+}
@@ -0,0 +1,23 @@
+package pkg;
+
+aspect A {
+	
+	before() : execution(* *.*(..)) {
+	}
+	
+	after() : execPCD(){
+	}
+	after() : callPCD(){
+	}
+	pointcut callPCD(): call(* *.*(..));
+	pointcut execPCD(): execution(* *.*(..));
+}
+
+class C {
+	
+	public void m() {
+	}
+	
+    static { 	
+    }	
+}
@@ -0,0 +1,5 @@
+package pkg;
+
+aspect A1 {
+
+}
@@ -0,0 +1,22 @@
+package pkg;
+
+public aspect A10 {
+
+	pointcut p() : call(public void C.m2());
+	
+	before() : p() {
+		
+	}
+	
+}
+
+class C {
+
+	public void m1() {
+		new C().m2();
+	}
+	
+	public void m2() {
+		
+	}
+}
@@ -0,0 +1,18 @@
+package pkg;
+
+public aspect A11 {
+	
+	declare warning: call(* C.setX(..)): "Illegal call.";
+    declare warning : execution(* C.setX(..)) : "blah";
+}
+
+class C {
+	
+	public void setX() {
+	}
+	
+	public void method() {
+		new C().setX();
+	}
+	
+}
@@ -0,0 +1,24 @@
+package pkg;
+
+aspect A {
+
+	declare @type : C : @MyAnnotation;
+	declare @field : int C.someField : @MyAnnotation;
+	declare @method : public void C.method1() : @MyAnnotation;
+	declare @constructor : C.new() : @MyAnnotation;
+	
+}
+
+class C {
+	
+	public C() {
+	}
+	
+	int someField = 3;
+	
+	public void method1() {
+	}
+	
+}
+
+@interface MyAnnotation{}
@@ -0,0 +1,12 @@
+package pkg;
+
+aspect A13 {
+
+	public C.new(int i,String s) {
+	}
+	
+}
+
+class C {
+	
+}
@@ -0,0 +1,8 @@
+package pkg;
+
+aspect A2 {
+	
+	before() : execution(* *.*(..)) {
+	}
+	
+}
@@ -0,0 +1,15 @@
+package pkg;
+
+aspect A3 {
+	
+	before() : execution(* *.*(..)) {
+	}
+	
+}
+
+class C {
+	
+	public void method1() {
+	}
+	
+}
@@ -0,0 +1,7 @@
+package pkg;
+
+aspect A4 {
+	
+	pointcut p() : execution(* *.*(..));
+	
+}
@@ -0,0 +1,12 @@
+package pkg;
+
+aspect A5 {
+	
+	pointcut p() : execution(* *.*(..));
+	
+	before() : p() {
+	}
+	
+	before() : p() {
+	}
+}
@@ -0,0 +1,5 @@
+aspect A6 {
+	
+	pointcut p(Integer value) : set(Integer memory) && args(value); 
+	
+}
@@ -0,0 +1,21 @@
+package pkg;
+
+public aspect A7 {
+	
+	declare parents : C1 implements C2;
+	
+	declare parents : C4 extends C5;
+	
+}
+
+class C1 {
+}
+
+interface C2 {
+}
+
+class C4 {
+}
+
+class C5 {
+}
@@ -0,0 +1,10 @@
+package pkg;
+
+public aspect A8 {
+	
+	pointcut p(Integer value) : set(Integer memory) && args(value); 
+	
+	after(Integer value) returning : p(value) {	
+	}
+	
+}
@@ -0,0 +1,16 @@
+package pkg;
+
+public aspect A9 {
+	
+	public int C.x = 5;
+	
+	private void C.method() {
+	}
+	
+	public String C.methodWithArgs(int i) {
+		return "";
+	}
+}
+
+class C {
+}
@@ -0,0 +1,15 @@
+package pkg;
+
+public class C {
+	
+	public C() {
+	}
+	
+	public C(String s) {
+		
+	}
+}
+
+interface MyInterface {
+	
+}
@@ -0,0 +1,21 @@
+aspect DeclareWarnings {
+	
+	pointcut p() : execution(* C.amethod());
+	
+	declare warning : p() : "warning 1";
+	declare warning : p() : "warning 2";
+	declare warning : p() : "warning 3";
+	declare warning : p() : "warning 4";
+	declare warning : p() : "warning 5";
+	declare warning : p() : "warning 6";
+	declare warning : p() : "warning 7";
+	declare warning : p() : "warning 8";
+	declare warning : p() : "warning 9";
+	declare warning : p() : "warning 10";
+	
+}
+
+class C {
+	
+	public void amethod() {}
+}
@@ -0,0 +1,33 @@
+package tjp;
+
+import java.io.*;
+
+public class Demo {
+    static Demo d;
+
+    static { 	
+    }
+    
+    {
+    }
+    
+    public static void main(String[] args){
+    }
+
+    public void m(int[] args) {
+    }
+    
+    void go(){
+    	int i = 4;
+    }
+
+    void foo(int i, Object o){
+    }
+
+    String bar (Integer j){
+    	return "";
+    }
+    
+    public void m2(String s1, String s2) {
+    }
+}
@@ -0,0 +1,5 @@
+package pkg;
+
+public enum E {
+	A,B;
+}
@@ -0,0 +1,21 @@
+aspect TwoNamedPointcuts {
+	
+	pointcut p1() : execution(* C.method1());
+	
+	pointcut p2() : execution(* C.method2());
+	
+	before() : p1() || p2() {
+		System.out.println("before...");
+	}
+	
+}
+
+class C {
+	
+	public void method1() {
+	}
+	
+	public void method2() {
+	}
+	
+}
@@ -0,0 +1,24 @@
+package pkg;
+
+import java.util.List;
+
+public class Java5Class {
+
+	public void method2(List l) {
+	}
+	
+	public void genericMethod1(List<String> s) {
+	}
+	
+	public void genericMethod2(List<String> s, MyGenericClass<Integer> m) {
+	}
+	
+	public void genericMethod3(int i, List<String> s) {
+	}
+	
+	public void genericMethod4(MyGenericClass2<String,Integer> m) {}
+}
+
+class MyGenericClass<T> {}
+
+class MyGenericClass2<X,Y> {}
@@ -0,0 +1,4 @@
+package pkg;
+
+public @interface MyAnnotation {
+}
@@ -38,6 +38,11 @@ public interface IElementHandleProvider {
     public String createHandleIdentifier(File sourceFile, int line,int column,int offset);
 
     /**
+     * @return  a String uniquely identifying this element
+     */
+	public String createHandleIdentifier(IProgramElement ipe);
+    
+    /**
      * NOTE: this is necessary for the current implementation to look up nodes, 
      * but we may want to consider removing it.
      * 
@@ -127,9 +127,11 @@ public interface IProgramElement extends Serializable {
 	 * The format of the string handle is not specified, but is stable across 
 	 * compilation sessions.
 	 * 
-	 * @return	a string representtaion of this element
+	 * @return	a string representation of this element
 	 */
 	public String getHandleIdentifier();
+	public String getHandleIdentifier(boolean create);
+	public void setHandleIdentifier(String handle);
 
 	/**
 	 * @return	a string representation of this node and all of its children (recursive)
@@ -37,16 +37,7 @@ public class AspectJElementHierarchy implements IHierarchy {
 	public IProgramElement getElement(String handle) {
 		IProgramElement cachedEntry = (IProgramElement)handleMap.get(handle);
 		if (cachedEntry!=null) return cachedEntry;
-		
-//		StringTokenizer st = new StringTokenizer(handle, ProgramElement.ID_DELIM);
-//        int line = new Integer(st.nextToken()).intValue();
-        // int col = new Integer(st.nextToken()).intValue(); TODO: use column number when available
-        String file = AsmManager.getDefault().getHandleProvider().getFileForHandle(handle); // st.nextToken();
-        int line = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(handle); // st.nextToken();
-        int offSet = AsmManager.getDefault().getHandleProvider().getOffSetForHandle(handle); 
-        
-        String canonicalSFP = AsmManager.getDefault().getCanonicalFilePath(new File(file));
-		IProgramElement ret = findNodeForSourceLineHelper(root,canonicalSFP, line, offSet);
+		IProgramElement ret = findElementForHandle(handle);
 		if (ret!=null) {
 			cache(handle,ret);
 		}
@@ -68,7 +59,10 @@ public class AspectJElementHierarchy implements IHierarchy {
 	}
 
 	public boolean removeFromFileMap(Object key) {
-		return (fileMap.remove(key)!=null);
+		if (fileMap.containsKey(key)) {
+			return (fileMap.remove(key)!=null);
+		}
+		return true;	
 	}
 
 	public void setFileMap(HashMap fileMap) {
@@ -344,30 +338,26 @@ public class AspectJElementHierarchy implements IHierarchy {
 		IProgramElement ret = (IProgramElement) handleMap.get(handle);
 		if (ret != null) return ret;
 
-//		StringTokenizer st = new StringTokenizer(handle, ProgramElement.ID_DELIM);
-//		String file = st.nextToken();
-//		int line = new Integer(st.nextToken()).intValue();
-//		int col = new Integer(st.nextToken()).intValue();
-		// TODO: use column number when available
-        String file = AsmManager.getDefault().getHandleProvider().getFileForHandle(handle); // st.nextToken();
-        int line = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(handle); // st.nextToken();
-        int offSet = AsmManager.getDefault().getHandleProvider().getOffSetForHandle(handle);
-        
-		ret = findElementForOffSet(file, line, offSet);
-		if (ret != null) { 
+		ret = findElementForHandle(root,handle);
+		if (ret != null) {
 			cache(handle,(ProgramElement)ret);
 		}
 		return ret;
-		
-//		IProgramElement parent = findElementForType(packageName, typeName);
-//		if (parent == null) return null;
-//		if (kind == IProgramElement.Kind.CLASS ||
-//			kind == IProgramElement.Kind.ASPECT) {
-//				return parent;
-//		} else {
-//			return findElementForSignature(parent, kind, name);	
-//		}	
 	}
+	
+	private IProgramElement findElementForHandle(IProgramElement parent, String handle) {
+		for (Iterator it = parent.getChildren().iterator(); it.hasNext(); ) {
+			IProgramElement node = (IProgramElement)it.next();
+			if (handle.equals(node.getHandleIdentifier())) {
+				return node;
+			} else {
+				IProgramElement childSearch = findElementForHandle(node,handle);
+				if (childSearch != null) return childSearch;
+			}
+		}
+		return null;
+	}
+	
 //	
 //	private IProgramElement findElementForBytecodeInfo(
 //		IProgramElement node, 
@@ -17,9 +17,12 @@ import java.util.StringTokenizer;
 
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IElementHandleProvider;
+import org.aspectj.asm.IProgramElement;
 import org.aspectj.bridge.ISourceLocation;
 
 /**
+ * HandleProvider of the form '<full path to src file>|line|column|offset'
+ * 
  * @author Mik Kersten
  */
 public class FullPathHandleProvider implements IElementHandleProvider {
@@ -70,4 +73,18 @@ public class FullPathHandleProvider implements IElementHandleProvider {
         st.nextToken(); // skip over the column
         return new Integer(st.nextToken()).intValue();
 	}
+
+	public String createHandleIdentifier(IProgramElement ipe) {
+		if (ipe.getHandleIdentifier(false) != null) {
+			return ipe.getHandleIdentifier(false);
+		}
+		String handle = null;  
+		if (ipe.getSourceLocation() != null) {
+			handle = createHandleIdentifier(ipe.getSourceLocation());
+		} else {
+			handle = createHandleIdentifier(ISourceLocation.NO_FILE,-1,-1,-1);
+		}
+		ipe.setHandleIdentifier(handle);
+		return handle;
+	}
 }
@@ -21,10 +21,11 @@ import java.util.StringTokenizer;
 
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IElementHandleProvider;
+import org.aspectj.asm.IProgramElement;
 import org.aspectj.bridge.ISourceLocation;
 
 /**
- * Not currently used - uses int keys rather than the full file path as the first part of the handle.
+ * Uses int keys rather than the full file path as the first part of the handle.
  */
 public class OptimizedFullPathHandleProvider implements IElementHandleProvider {
 
@@ -96,4 +97,18 @@ public class OptimizedFullPathHandleProvider implements IElementHandleProvider {
         st.nextToken(); // skip over the column
         return new Integer(st.nextToken()).intValue();
 	}
+
+	public String createHandleIdentifier(IProgramElement ipe) {
+		if (ipe.getHandleIdentifier(false) != null) {
+			return ipe.getHandleIdentifier(false);
+		}
+		String handle = null;  
+		if (ipe.getSourceLocation() != null) {
+			handle = createHandleIdentifier(ipe.getSourceLocation());
+		} else {
+			handle = createHandleIdentifier(ISourceLocation.NO_FILE,-1,-1,-1);
+		}
+		ipe.setHandleIdentifier(handle);
+		return handle;
+	}
 }
@@ -493,19 +493,25 @@ public class ProgramElement implements IProgramElement {
 	}
 
 	public String getHandleIdentifier() {
-	    if (null == handle) {
-			if (sourceLocation != null) {
-                handle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation);
-//			    return genHandleIdentifier(sourceLocation);
-			} 
-	    }
-	    return handle;
+		return getHandleIdentifier(true);
+	}
+	
+	public String getHandleIdentifier(boolean create) {
+		if (null == handle && create) {
+            handle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(this);			
+		}
+		return handle;
+	}
+	
+	public void setHandleIdentifier(String handle) {
+		this.handle = handle;
 	}
 
 	public List getParameterNames() { 
 		List parameterNames = (List)kvpairs.get("parameterNames");
 		return parameterNames; 
 	}
+	
 	public void setParameterNames(List list) { 
 		if (list==null || list.size()==0) return;
 		if (kvpairs==Collections.EMPTY_MAP) kvpairs = new HashMap();
@@ -15,6 +15,7 @@ package org.aspectj.ajdt.internal.compiler.lookup;
 //import java.io.IOException;
 
 import org.aspectj.asm.AsmManager;
+import org.aspectj.asm.IProgramElement;
 import org.aspectj.asm.IRelationship;
 import org.aspectj.asm.IRelationshipMap;
 import org.aspectj.weaver.ResolvedType;
@@ -48,17 +49,15 @@ public class AsmInterTypeRelationshipProvider {
 
 		if (munger.getSourceLocation() != null
 			&& munger.getSourceLocation() != null) {
-			String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-				munger.getSourceLocation().getSourceFile(),
-				munger.getSourceLocation().getLine(),
-				munger.getSourceLocation().getColumn(),
-				munger.getSourceLocation().getOffset());
-				
-			String targetHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-				onType.getSourceLocation().getSourceFile(),
-				onType.getSourceLocation().getLine(),
-				onType.getSourceLocation().getColumn(),
-				onType.getSourceLocation().getOffset());
+			IProgramElement sourceIPE = AsmManager.getDefault().getHierarchy()
+				.findElementForSourceLine(munger.getSourceLocation());
+			String sourceHandle = AsmManager.getDefault().getHandleProvider()
+				.createHandleIdentifier(sourceIPE);
+			
+			IProgramElement targetIPE = AsmManager.getDefault().getHierarchy()
+				.findElementForSourceLine(onType.getSourceLocation());
+			String targetHandle = AsmManager.getDefault().getHandleProvider()
+				.createHandleIdentifier(targetIPE);
 
 			IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
 			if (sourceHandle != null && targetHandle != null) {
@@ -430,10 +430,18 @@ public class AsmHierarchyBuilder extends ASTVisitor {
             ReferencePointcut rp = (ReferencePointcut) it.next();
             ResolvedMember member = getPointcutDeclaration(rp, declaration);
             if (member != null) {
-                IRelationship foreward = AsmManager.getDefault().getRelationshipMap().get(peNode.getHandleIdentifier(), IRelationship.Kind.USES_POINTCUT, "uses pointcut", false, true);
-                foreward.addTarget(AsmManager.getDefault().getHandleProvider().createHandleIdentifier(member.getSourceLocation()));            
+                IRelationship foreward = AsmManager.getDefault().getRelationshipMap()
+                		.get(peNode.getHandleIdentifier(), 
+                				IRelationship.Kind.USES_POINTCUT, "uses pointcut", false, true);
+                IProgramElement forwardIPE = AsmManager.getDefault().getHierarchy()
+                		.findElementForSourceLine(member.getSourceLocation());
+                foreward.addTarget(AsmManager.getDefault().getHandleProvider()
+                		.createHandleIdentifier(forwardIPE));            
 
-                IRelationship back = AsmManager.getDefault().getRelationshipMap().get(AsmManager.getDefault().getHandleProvider().createHandleIdentifier(member.getSourceLocation()), IRelationship.Kind.USES_POINTCUT, "pointcut used by", false, true);
+                IRelationship back = AsmManager.getDefault().getRelationshipMap()
+                		.get(AsmManager.getDefault().getHandleProvider()
+                				.createHandleIdentifier(forwardIPE), 
+                				IRelationship.Kind.USES_POINTCUT, "pointcut used by", false, true);
                 back.addTarget(peNode.getHandleIdentifier());             
             } 
         }        
@@ -26,6 +26,7 @@ public class AbstractMultiProjectIncrementalAjdeInteractionTestbed extends
 	protected void tearDown() throws Exception {
 		super.tearDown();
 		AjState.FORCE_INCREMENTAL_DURING_TESTING = false;
+		configureBuildStructureModel(false);
 	}
 
 	public void build(String projectName) {
@@ -55,33 +55,25 @@ public class AsmRelationshipProvider {
 
 		// Ensure a node for the target exists
 		IProgramElement targetNode = getNode(AsmManager.getDefault().getHierarchy(), shadow);
-
-		String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-			checker.getSourceLocation().getSourceFile(),
-			checker.getSourceLocation().getLine(),
-			checker.getSourceLocation().getColumn(),
-			checker.getSourceLocation().getOffset());
-
+		IProgramElement sourceNode = AsmManager.getDefault().getHierarchy()
+				.findElementForSourceLine(checker.getSourceLocation());
+		String sourceHandle = AsmManager.getDefault().getHandleProvider()
+				.createHandleIdentifier(sourceNode);
+		String targetHandle = AsmManager.getDefault().getHandleProvider()
+				.createHandleIdentifier(targetNode);
+				
 		if (World.createInjarHierarchy) {
 			checker.createHierarchy();
 		}
 
-		String targetHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-			shadow.getSourceLocation().getSourceFile(),
-			shadow.getSourceLocation().getLine(),
-			shadow.getSourceLocation().getColumn(),
-			shadow.getSourceLocation().getOffset());
-
 		IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
 		if (sourceHandle != null && targetHandle != null) {
 			IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE, MATCHED_BY,false,true);
 			foreward.addTarget(targetHandle);
-//			foreward.getTargets().add(targetHandle);
 
 			IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE, MATCHES_DECLARE,false,true);
 			if (back != null && back.getTargets() != null) {
 				back.addTarget(sourceHandle);
-				//back.getTargets().add(sourceHandle);   
 			}
 		}
 	}
@@ -95,25 +87,21 @@ public class AsmRelationshipProvider {
 	  if (!AsmManager.isCreatingModel()) return;
 		String sourceHandle = "";
 		if (munger.getSourceLocation()!=null && munger.getSourceLocation().getOffset()!=-1) {
-			sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-										munger.getSourceLocation().getSourceFile(),
-										munger.getSourceLocation().getLine(),
-										munger.getSourceLocation().getColumn(),
-										munger.getSourceLocation().getOffset());
+			IProgramElement sourceNode = AsmManager.getDefault().getHierarchy()
+					.findElementForSourceLine(munger.getSourceLocation());
+			sourceHandle = AsmManager.getDefault().getHandleProvider()
+					.createHandleIdentifier(sourceNode);
 		} else {
-			sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-							originatingAspect.getSourceLocation().getSourceFile(),
-							originatingAspect.getSourceLocation().getLine(),
-							originatingAspect.getSourceLocation().getColumn(),
-							originatingAspect.getSourceLocation().getOffset());
+			IProgramElement sourceNode = AsmManager.getDefault().getHierarchy()
+					.findElementForSourceLine(originatingAspect.getSourceLocation());
+			sourceHandle = AsmManager.getDefault().getHandleProvider()
+					.createHandleIdentifier(sourceNode);
 		}
 		if (originatingAspect.getSourceLocation() != null) {
-				
-			String targetHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-				onType.getSourceLocation().getSourceFile(),
-				onType.getSourceLocation().getLine(),
-				onType.getSourceLocation().getColumn(),
-				onType.getSourceLocation().getOffset());
+			IProgramElement targetNode = AsmManager.getDefault().getHierarchy()
+					.findElementForSourceLine(onType.getSourceLocation());
+			String targetHandle = AsmManager.getDefault().getHandleProvider()
+					.createHandleIdentifier(targetNode);
 
 			IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
 			if (sourceHandle != null && targetHandle != null) {
@@ -131,17 +119,15 @@ public class AsmRelationshipProvider {
 	public void addDeclareParentsRelationship(ISourceLocation decp,ResolvedType targetType, List newParents) {
 	    if (!AsmManager.isCreatingModel()) return;
 
-		String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(decp.getSourceFile(),decp.getLine(),decp.getColumn(),decp.getOffset());
-		
-		IProgramElement ipe = AsmManager.getDefault().getHierarchy().findElementForHandle(sourceHandle);
+		IProgramElement sourceNode = AsmManager.getDefault().getHierarchy()
+				.findElementForSourceLine(decp);
+		String sourceHandle = AsmManager.getDefault().getHandleProvider()
+				.createHandleIdentifier(sourceNode);
+		IProgramElement targetNode = AsmManager.getDefault().getHierarchy()
+				.findElementForSourceLine(targetType.getSourceLocation());
+		String targetHandle = AsmManager.getDefault().getHandleProvider()
+				.createHandleIdentifier(targetNode);
 
-	
-		String targetHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-				targetType.getSourceLocation().getSourceFile(),
-				targetType.getSourceLocation().getLine(),
-				targetType.getSourceLocation().getColumn(),
-				targetType.getSourceLocation().getOffset());
-				
 		IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
 		if (sourceHandle != null && targetHandle != null) {
 			IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARES,false,true);
@@ -159,15 +145,16 @@ public class AsmRelationshipProvider {
 	 */
 	public void addDeclareAnnotationRelationship(ISourceLocation declareAnnotationLocation,ISourceLocation annotatedLocation) {
 	    if (!AsmManager.isCreatingModel()) return;
-		String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(declareAnnotationLocation.getSourceFile(),declareAnnotationLocation.getLine(),
-																	declareAnnotationLocation.getColumn(),declareAnnotationLocation.getOffset());
-		IProgramElement declareAnnotationPE = AsmManager.getDefault().getHierarchy().findElementForHandle(sourceHandle);
-		
-		String targetHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-				annotatedLocation.getSourceFile(),
-				annotatedLocation.getLine(),
-				annotatedLocation.getColumn(),
-				annotatedLocation.getOffset());
+	    
+	    IProgramElement sourceNode = AsmManager.getDefault().getHierarchy()
+	    		.findElementForSourceLine(declareAnnotationLocation);
+	    String sourceHandle = AsmManager.getDefault().getHandleProvider()
+	    		.createHandleIdentifier(sourceNode);
+
+	    IProgramElement targetNode = AsmManager.getDefault().getHierarchy()
+				.findElementForSourceLine(annotatedLocation);
+	    String targetHandle = AsmManager.getDefault().getHandleProvider()
+				.createHandleIdentifier(targetNode);
 
 		IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
 		if (sourceHandle != null && targetHandle != null) {
@@ -205,7 +192,9 @@ public class AsmRelationshipProvider {
 			AdviceKind ak = ((Advice)munger).getKind();
 			ai.setExtraAdviceInformation(ak.getName());
 			IProgramElement adviceElement = AsmManager.getDefault().getHierarchy().findElementForHandle(adviceHandle);
-			adviceElement.setExtraInfo(ai);		
+			if (adviceElement != null) {
+				adviceElement.setExtraInfo(ai);	
+			}
 
 			if (adviceHandle != null && targetNode != null) {
 
@@ -392,9 +381,9 @@ public class AsmRelationshipProvider {
 	  if (methodElem == null) return;
 
 	  try {
-	    String sourceHandle = 
-            AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation.getSourceFile(),sourceLocation.getLine(),
-		 	sourceLocation.getColumn(),sourceLocation.getOffset());
+		  
+		  IProgramElement sourceNode = AsmManager.getDefault().getHierarchy().findElementForSourceLine(sourceLocation);
+		  String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceNode);
 
 	    String targetHandle = methodElem.getHandleIdentifier();
 	    IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
@@ -433,9 +422,8 @@ public class AsmRelationshipProvider {
         IProgramElement fieldElem = AsmManager.getDefault().getHierarchy().findElementForSignature(typeElem,IProgramElement.Kind.FIELD,field.getName());
         if (fieldElem== null) return;
 
-		String sourceHandle = 
-            AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation.getSourceFile(),sourceLocation.getLine(),
-		  	sourceLocation.getColumn(),sourceLocation.getOffset());
+		  IProgramElement sourceNode = AsmManager.getDefault().getHierarchy().findElementForSourceLine(sourceLocation);
+		  String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceNode);
 
 		String targetHandle = fieldElem.getHandleIdentifier();
 
@@ -101,11 +101,8 @@ public abstract class ShadowMunger implements PartialOrder.PartialComparable, IH
 				if (World.createInjarHierarchy) {
 					createHierarchy();
 				} 
-				handle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-				            sl.getSourceFile(),
-				            sl.getLine(),
-				            sl.getColumn(),
-							sl.getOffset());					
+				IProgramElement ipe = AsmManager.getDefault().getHierarchy().findElementForSourceLine(sl);
+				handle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(ipe);
 			}
 		}
 		return handle;
@@ -77,9 +77,8 @@ public class AsmManager {
         handleProvider = new OptimizedFullPathHandleProvider(); 
     }
 
-	public void createNewASM(INameConvertor convertor) {
+	public void createNewASM() {
 		hierarchy = new AspectJElementHierarchy();
-		hierarchy.setNameConvertor(convertor);
 		mapper = new RelationshipMap(hierarchy);
 	}
 
@@ -102,7 +102,4 @@ public interface IHierarchy extends Serializable {
 	public void flushHandleMap();
 
 	public void updateHandleMap(Set deletedFiles);
-	
-	public void setNameConvertor(INameConvertor convertor);
-	public INameConvertor getNameConvertor();
 }
\ No newline at end of file
@@ -1,17 +0,0 @@
-/********************************************************************
- * Copyright (c) 2006 Contributors. All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: IBM Corporation - initial API and implementation 
- * 				 Helen Hawkins   - initial version
- *******************************************************************/
-package org.aspectj.asm;
-
-public interface INameConvertor {
-
-	public char[] convertName(char[] name);
-	
-}
@@ -29,7 +29,6 @@ public class AspectJElementHierarchy implements IHierarchy {
 
 	protected  IProgramElement root = null;
     protected String configFile = null;
-    private transient INameConvertor convertor = null;
 
     private Map fileMap = null;
     private Map handleMap = null;
@@ -450,13 +449,5 @@ public class AspectJElementHierarchy implements IHierarchy {
 		return hid.substring(0,hid.indexOf("|"));
 	}
 
-	public void setNameConvertor(INameConvertor convertor) {
-		this.convertor = convertor;
-	}
-
-	public INameConvertor getNameConvertor() {
-		return convertor;
-	}
-
 }
 
@@ -22,11 +22,11 @@ import java.util.Map;
 
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.HierarchyWalker;
-import org.aspectj.asm.INameConvertor;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.util.CharOperation;
+import org.aspectj.util.NameConvertor;
 
 
 /**
@@ -519,12 +519,7 @@ public class ProgramElement implements IProgramElement {
 		List params = new ArrayList();
 		for (Iterator iter = l.iterator(); iter.hasNext();) {
 			char[] param = (char[])iter.next();
-			INameConvertor convertor = AsmManager.getDefault().getHierarchy().getNameConvertor();
-			if (convertor != null) {
-				params.add(convertor.convertName(param));				
-			} else {
-				params.add(param);
-			}
+			params.add(NameConvertor.convertFromSignature(param));
 		}
 		return params;
 	}
@@ -49,7 +49,6 @@ import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter;
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IHierarchy;
-import org.aspectj.asm.INameConvertor;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.asm.internal.ProgramElement;
 import org.aspectj.bridge.AbortException;
@@ -84,8 +83,6 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.problem.DefaultProblemFacto
 import org.aspectj.util.FileUtil;
 import org.aspectj.weaver.Dump;
 import org.aspectj.weaver.ResolvedType;
-import org.aspectj.weaver.TypeFactory;
-import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.bcel.BcelWeaver;
 import org.aspectj.weaver.bcel.BcelWorld;
@@ -634,7 +631,7 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
      	AsmManager.setCreatingModel(config.isEmacsSymMode() || config.isGenerateModelMode());
      	if (!AsmManager.isCreatingModel()) return;
 
-		AsmManager.getDefault().createNewASM(new NameConverter());
+		AsmManager.getDefault().createNewASM();
 		// AsmManager.getDefault().getRelationshipMap().clear();
 		IHierarchy model = AsmManager.getDefault().getHierarchy();
         String rootLabel = "<root>";
@@ -1279,15 +1276,5 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 		}
 
 	}
-	
-	private class NameConverter implements INameConvertor {
-
-		public char[] convertName(char[] name) {
-			UnresolvedType ut = TypeFactory.createTypeFromSignature(new String(name));
-			ResolvedType rt = getWorld().resolve(ut);
-			return rt.getName().toCharArray();
-		}
-		
-	}
 }
 
@@ -52,7 +52,7 @@ public class IncrementalStateManager {
 			element.wipeAllKnowledge();
 		}
 		incrementalStates.clear();
-		AsmManager.getDefault().createNewASM(null); // forget what you know...
+		AsmManager.getDefault().createNewASM(); // forget what you know...
 	}
 
 	public static Set getConfigFilesKnown() {
@@ -21,6 +21,7 @@ import org.aspectj.asm.IHierarchy;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.asm.internal.Relationship;
 import org.aspectj.testing.XMLBasedAjcTestCase;
+import org.aspectj.util.CharOperation;
 
 public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
@@ -150,7 +151,7 @@ public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
       assertNotNull("Couldn't find 'twoArgsMethod(int,java.lang.String)' element in the tree",twoArgsMethod);
       List l = twoArgsMethod.getParameterSignatures();
       assertEquals("",((char[])l.get(0))[0],'I');
-      boolean eq = equals(((char[])l.get(1)),"Ljava/lang/String;".toCharArray());
+      boolean eq = CharOperation.equals(((char[])l.get(1)),"Ljava/lang/String;".toCharArray());
       assertTrue("expected parameter to be 'Ljava/lang/String;' but found '" +
         		new String(((char[])l.get(1))) + "'",eq);
   }
@@ -204,23 +205,6 @@ public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
   // ---------------- helper methods ---------------
 
-   /**
-    * taken from CharOperation
-    */
-	private final boolean equals(char[] first, char[] second) {
-		if (first == second)
-			return true;
-		if (first == null || second == null)
-			return false;
-		if (first.length != second.length)
-			return false;
-
-		for (int i = first.length; --i >= 0;)
-			if (first[i] != second[i])
-				return false;
-		return true;
-	}
-  
 	private void checkParametersForIPE(String ipeLabel, IProgramElement.Kind kind, String expectedParm, boolean getHandles) {
 		IHierarchy top = AsmManager.getDefault().getHierarchy();
 		IProgramElement ipe = top.findElementForLabel(top.getRoot(),kind,ipeLabel);
@@ -231,7 +215,7 @@ public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	    } else {
 	    	l = ipe.getParameterTypes();
 	    }
-	    boolean eq = equals(((char[])l.get(0)),expectedParm.toCharArray());
+	    boolean eq = CharOperation.equals(((char[])l.get(0)),expectedParm.toCharArray());
 	    assertTrue("expected parameter to be '" + expectedParm + "' but found '" +
 	      		new String(((char[])l.get(0))) + "'",eq);
 	}
@@ -45,4 +45,62 @@ public class CharOperation {
 		return -1;
 	}
 
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final int indexOf(char toBeFound, char[] array) {
+		for (int i = 0; i < array.length; i++)
+			if (toBeFound == array[i])
+				return i;
+		return -1;
+	}
+	
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final char[] concat(char[] first, char[] second) {
+		if (first == null)
+			return second;
+		if (second == null)
+			return first;
+
+		int length1 = first.length;
+		int length2 = second.length;
+		char[] result = new char[length1 + length2];
+		System.arraycopy(first, 0, result, 0, length1);
+		System.arraycopy(second, 0, result, length1, length2);
+		return result;
+	}
+	
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final boolean equals(char[] first, char[] second) {
+		if (first == second)
+			return true;
+		if (first == null || second == null)
+			return false;
+		if (first.length != second.length)
+			return false;
+
+		for (int i = first.length; --i >= 0;)
+			if (first[i] != second[i])
+				return false;
+		return true;
+	}
+	
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final void replace(
+		char[] array,
+		char toBeReplaced,
+		char replacementChar) {
+		if (toBeReplaced != replacementChar) {
+			for (int i = 0, max = array.length; i < max; i++) {
+				if (array[i] == toBeReplaced)
+					array[i] = replacementChar;
+			}
+		}
+	}
 }
@@ -0,0 +1,139 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.util;
+
+public class NameConvertor {
+
+	private static final char BOOLEAN 	= 'Z';
+	private static final char BYTE 		= 'B';
+	private static final char CHAR 		= 'C';
+	private static final char DOUBLE 	= 'D';
+	private static final char FLOAT 	= 'F';
+	private static final char INT 		= 'I';
+	private static final char LONG		= 'J';
+	private static final char SHORT		= 'S';
+	private static final char ARRAY		= '[';
+	
+	private static final char[] BOOLEAN_NAME = new char[]{'b','o','o','l','e','a','n'};
+	private static final char[] BYTE_NAME = new char[]{'b','y','t','e'};
+	private static final char[] CHAR_NAME = new char[]{'c','h','a','r'};
+	private static final char[] DOUBLE_NAME = new char[]{'d','o','u','b','l','e'};
+	private static final char[] FLOAT_NAME = new char[]{'f','l','o','a','t'};
+	private static final char[] INT_NAME = new char[]{'i','n','t'};
+	private static final char[] LONG_NAME = new char[]{'l','o','n','g'};
+	private static final char[] SHORT_NAME = new char[]{'s','h','o','r','t'};
+
+	private static final char[] SQUARE_BRACKETS = new char[]{'[',']'};
+	private static final char[] GREATER_THAN = new char[]{'>'};
+	private static final char[] LESS_THAN = new char[]{'<'};
+	private static final char[] COMMA = new char[]{','};
+	
+	
+	/**
+	 * Creates a readable name from the given char array, for example, 
+	 * given 'I' returns 'int'. Moreover, given 
+	 * 'Ljava/lang/String;<Ljava/lang/String;>' returns
+	 * 'java.lang.String<java.lang.String>'
+	 */
+	public static char[] convertFromSignature(char[] c) {
+		int lt = CharOperation.indexOf('<',c);
+		int sc = CharOperation.indexOf(';',c);
+		int gt = CharOperation.indexOf('>',c);
+		
+		int smallest = 0;
+		if (lt  == -1 && sc == -1 && gt == -1) {
+			// we have something like 'Ljava/lang/String' or 'I'
+			return getFullyQualifiedTypeName(c);
+		} else if (lt != -1 && (sc == -1 || lt <= sc) && (gt == -1 || lt <= gt)) {
+			// we have something like 'Ljava/lang/String<I'
+			smallest = lt;
+		} else if (sc != -1 && (lt == -1 || sc <= lt) && (gt == -1 || sc <= gt)) {
+			// we have something like 'Ljava/lang/String;I'
+			smallest = sc;
+		} else {
+			// we have something like '>;'
+			smallest = gt;
+		}
+		char[] first = CharOperation.subarray(c,0,smallest);
+		char[] second = CharOperation.subarray(c,smallest+1,c.length);
+		if (smallest == 0 && first.length == 0 && c[0] == '>') {
+			// c = {'>',';'} therefore we just want to return '>' to
+			// close the generic signature
+			return GREATER_THAN;
+		} else if (first.length == 1 && second.length == 0) {
+			return first;
+		} else if (second.length == 0 || (second.length == 1 && second[0] == ';')){
+			// we've reached the end of the array, therefore only care about
+			// the first part
+			return convertFromSignature(first);
+		} else if (smallest == lt) {
+			// if c = 'Ljava/lang/String;<I' then first = 'Ljava/Lang/String;' and
+			// second = 'I'. Want to end up with 'Ljava.lang.String<I' and so add
+			// the '<' back.
+			char[] inclLT = CharOperation.concat(convertFromSignature(first),LESS_THAN);
+			return CharOperation.concat(inclLT,convertFromSignature(second));
+		} else if (smallest == gt) {
+			char[] inclLT = CharOperation.concat(convertFromSignature(first),GREATER_THAN);
+			return CharOperation.concat(inclLT,convertFromSignature(second));			
+		} else if (second.length != 2) {
+			// if c = 'Ljava/lang/Sting;LMyClass' then first = 'Ljava/lang/String'
+			// and second = 'LMyClass'. Want to end up with 'java.lang.String,MyClass
+			// so want to add a ','. However, only want to do this if we're in the 
+			// middle of a '<...>'
+			char[] inclComma = CharOperation.concat(convertFromSignature(first),COMMA);
+			return CharOperation.concat(inclComma,convertFromSignature(second));
+		}
+		return CharOperation.concat(convertFromSignature(first),convertFromSignature(second));
+	}
+	
+	
+	/**
+	 * Given a char array, returns the type name for this. For example
+	 * 'I' returns 'int', 'Ljava/lang/String' returns 'java.lang.String' and
+	 * '[Ljava/lang/String' returns 'java.lang.String[]'
+	 * 
+	 * NOTE: Doesn't go any deaper so given 'Ljava/lang/String;<Ljava/lang/String;>' 
+	 * it would return 'java.lang.String;<Ljava.lang.String;>', however, only called
+	 * with something like 'Ljava/lang/String'
+	 */
+	private static char[] getFullyQualifiedTypeName(char[] c) {
+		if (c.length == 0) {
+			return c;
+		} 
+		if (c[0] == BOOLEAN) {
+			return BOOLEAN_NAME;
+		} else if (c[0] == BYTE) {
+			return BYTE_NAME;
+		} else if (c[0] == CHAR) {
+			return CHAR_NAME;
+		} else if (c[0] == DOUBLE) {
+			return DOUBLE_NAME;
+		} else if (c[0] == FLOAT) {
+			return FLOAT_NAME;
+		} else if (c[0] == INT) {
+			return INT_NAME;
+		} else if (c[0] == LONG) {
+			return LONG_NAME;
+		} else if (c[0] == SHORT) {
+			return SHORT_NAME;
+		} else if (c[0] == ARRAY) {
+			return CharOperation.concat(
+					getFullyQualifiedTypeName(CharOperation.subarray(c,1,c.length)),
+					SQUARE_BRACKETS);
+		} else {
+			char[] type = CharOperation.subarray(c,1,c.length);
+			CharOperation.replace(type,'/','.');
+			return type;
+		}
+	}
+	
+
+}
@@ -0,0 +1,83 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.util;
+
+import junit.framework.TestCase;
+
+public class NameConvertorTest extends TestCase {
+
+	public void testBoolean() {
+		checkConversion("Z","boolean");
+	}
+	
+	public void testByte() {
+		checkConversion("B","byte");
+	}
+	
+	public void testChar() {
+		checkConversion("C","char");
+	}	
+	
+	public void testDouble() {
+		checkConversion("D","double");
+	}	
+	
+	public void testFloat() {
+		checkConversion("F","float");
+	}
+	
+	public void testInt() {
+		checkConversion("I","int");
+	}
+	
+	public void testLong() {
+		checkConversion("J","long");
+	}	
+	
+	public void testShort() {
+		checkConversion("S","short");
+	}	
+	
+	public void testString() {
+		checkConversion("Ljava/lang/String;","java.lang.String");
+	}
+
+	public void testType() {
+		checkConversion("LMyClass;","MyClass");
+	}
+
+	public void testListPameterizedWithString() {
+		checkConversion("Pjava/util/List<Ljava/lang/String;>;",
+				"java.util.List<java.lang.String>");
+	}
+	public void testClassParameterizedWithStringAndType() {
+		checkConversion("PMyGenericClass<Ljava/lang/String;LMyClass;>;",
+				"MyGenericClass<java.lang.String,MyClass>");
+	}
+	public void testStringArray() {
+		checkConversion("[Ljava/lang/String;","java.lang.String[]");
+	}
+	public void testTwoDimensionalStringArray() {
+		checkConversion("[[Ljava/lang/String;","java.lang.String[][]");
+	}
+	public void testIntArray() {
+		checkConversion("[I","int[]");
+	}
+
+	private void checkConversion(String signature, String expected) {
+		char[] c = NameConvertor.convertFromSignature(signature.toCharArray());
+		assertTrue("converting " + signature + ", expected " + expected + "," +
+				"but found " + String.valueOf(c),
+				CharOperation.equals(c,expected.toCharArray()));
+	}
+
+	
+}
@@ -23,6 +23,7 @@ public class UtilTests extends TestCase {
         //$JUnit-BEGIN$
         suite.addTestSuite(FileUtilTest.class); 
         suite.addTestSuite(LangUtilTest.class); 
+        suite.addTestSuite(NameConvertorTest.class);
         //$JUnit-END$
         return suite;
     }
@@ -1,9 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-    <classpathentry kind="src" path="src"/>
-    <classpathentry kind="src" path="testsrc"/>
-    <classpathentry kind="var" path="JRE_LIB" rootpath="JRE_SRCROOT" sourcepath="JRE_SRC"/>
-    <classpathentry kind="src" path="/bridge"/>
-    <classpathentry kind="lib" path="/lib/junit/junit.jar" sourcepath="/lib/junit/junit-src.jar"/>
-    <classpathentry kind="output" path="bin"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="testsrc"/>
+	<classpathentry sourcepath="JRE_SRC" kind="var" path="JRE_LIB"/>
+	<classpathentry kind="src" path="/bridge"/>
+	<classpathentry sourcepath="/lib/junit/junit-src.jar" kind="lib" path="/lib/junit/junit.jar"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/util"/>
+	<classpathentry kind="output" path="bin"/>
 </classpath>
@@ -77,8 +77,9 @@ public class AsmManager {
         handleProvider = new OptimizedFullPathHandleProvider(); 
     }
 
-	public void createNewASM() {
+	public void createNewASM(INameConvertor convertor) {
 		hierarchy = new AspectJElementHierarchy();
+		hierarchy.setNameConvertor(convertor);
 		mapper = new RelationshipMap(hierarchy);
 	}
 
@@ -102,4 +102,7 @@ public interface IHierarchy extends Serializable {
 	public void flushHandleMap();
 
 	public void updateHandleMap(Set deletedFiles);
+	
+	public void setNameConvertor(INameConvertor convertor);
+	public INameConvertor getNameConvertor();
 }
\ No newline at end of file
@@ -0,0 +1,17 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.asm;
+
+public interface INameConvertor {
+
+	public char[] convertName(char[] name);
+	
+}
@@ -116,12 +116,13 @@ public interface IProgramElement extends Serializable {
 	public String toLabelString();
 	public String toLabelString(boolean getFullyQualifiedArgTypes);
 
-	public List getParameterTypes();
-	public void setParameterTypes(List list);
-
 	public List getParameterNames();
 	public void setParameterNames(List list);
 
+	public List getParameterSignatures();
+	public void setParameterSignatures(List list);
+	public List getParameterTypes();
+	
 	/**
 	 * The format of the string handle is not specified, but is stable across 
 	 * compilation sessions.
@@ -29,6 +29,7 @@ public class AspectJElementHierarchy implements IHierarchy {
 
 	protected  IProgramElement root = null;
     protected String configFile = null;
+    private transient INameConvertor convertor = null;
 
     private Map fileMap = null;
     private Map handleMap = null;
@@ -449,5 +450,13 @@ public class AspectJElementHierarchy implements IHierarchy {
 		return hid.substring(0,hid.indexOf("|"));
 	}
 
+	public void setNameConvertor(INameConvertor convertor) {
+		this.convertor = convertor;
+	}
+
+	public INameConvertor getNameConvertor() {
+		return convertor;
+	}
+
 }
 
@@ -22,9 +22,11 @@ import java.util.Map;
 
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.HierarchyWalker;
+import org.aspectj.asm.INameConvertor;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
+import org.aspectj.util.CharOperation;
 
 
 /**
@@ -408,16 +410,22 @@ public class ProgramElement implements IProgramElement {
 		sb.append(name);
 
 		List ptypes = getParameterTypes();
-		if (ptypes != null) {
+		if (ptypes != null && (!ptypes.isEmpty() 
+				|| this.kind.equals(IProgramElement.Kind.METHOD))
+				|| this.kind.equals(IProgramElement.Kind.CONSTRUCTOR)
+				|| this.kind.equals(IProgramElement.Kind.ADVICE)
+				|| this.kind.equals(IProgramElement.Kind.POINTCUT)
+				|| this.kind.equals(IProgramElement.Kind.INTER_TYPE_METHOD)
+				|| this.kind.equals(IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR)) {
 			sb.append('('); 
 			for (Iterator it = ptypes.iterator(); it.hasNext(); ) {
-				String arg = (String)it.next();
+				char[] arg = (char[])it.next();
 				if (getFullyQualifiedArgTypes) {
 					sb.append(arg);
 				} else {
-					int index = arg.lastIndexOf(".");
+					int index = CharOperation.lastIndexOf('.',arg);
 					if (index != -1) {
-						sb.append(arg.substring(index + 1));
+						sb.append(CharOperation.subarray(arg,index+1,arg.length));
 					} else {
 						sb.append(arg);
 					}
@@ -503,17 +511,35 @@ public class ProgramElement implements IProgramElement {
 		//parameterNames = list; 
 	}
 
-	public List getParameterTypes() { 
-		List parameterTypes = (List)kvpairs.get("parameterTypes");
-		return parameterTypes; 
+	public List getParameterTypes() {
+		List l = getParameterSignatures();
+		if (l == null || l.isEmpty()) {
+			return Collections.EMPTY_LIST;
+		}
+		List params = new ArrayList();
+		for (Iterator iter = l.iterator(); iter.hasNext();) {
+			char[] param = (char[])iter.next();
+			INameConvertor convertor = AsmManager.getDefault().getHierarchy().getNameConvertor();
+			if (convertor != null) {
+				params.add(convertor.convertName(param));				
+			} else {
+				params.add(param);
+			}
+		}
+		return params;
 	}
-	public void setParameterTypes(List list) { 
-		if (kvpairs==Collections.EMPTY_MAP) kvpairs = new HashMap();
-		if (list==null || list.size()==0) kvpairs.put("parameterTypes",Collections.EMPTY_LIST);
-		else                               kvpairs.put("parameterTypes",list);
-//		parameterTypes = list; 
+	
+	public List getParameterSignatures() {
+		List parameters = (List)kvpairs.get("parameterSigs");
+		return parameters;
 	}
 
+	public void setParameterSignatures(List list) {
+		if (kvpairs==Collections.EMPTY_MAP) kvpairs = new HashMap();
+		if (list==null || list.size()==0) kvpairs.put("parameterSigs",Collections.EMPTY_LIST);
+		else kvpairs.put("parameterSigs",list);
+	}
+	
 	public String getDetails() {
 		String details = (String)kvpairs.get("details");
 		return details; 
@@ -49,6 +49,7 @@ import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter;
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IHierarchy;
+import org.aspectj.asm.INameConvertor;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.asm.internal.ProgramElement;
 import org.aspectj.bridge.AbortException;
@@ -83,6 +84,8 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.problem.DefaultProblemFacto
 import org.aspectj.util.FileUtil;
 import org.aspectj.weaver.Dump;
 import org.aspectj.weaver.ResolvedType;
+import org.aspectj.weaver.TypeFactory;
+import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.bcel.BcelWeaver;
 import org.aspectj.weaver.bcel.BcelWorld;
@@ -631,7 +634,7 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
      	AsmManager.setCreatingModel(config.isEmacsSymMode() || config.isGenerateModelMode());
      	if (!AsmManager.isCreatingModel()) return;
 
-		AsmManager.getDefault().createNewASM();
+		AsmManager.getDefault().createNewASM(new NameConverter());
 		// AsmManager.getDefault().getRelationshipMap().clear();
 		IHierarchy model = AsmManager.getDefault().getHierarchy();
         String rootLabel = "<root>";
@@ -1276,5 +1279,15 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 		}
 
 	}
+	
+	private class NameConverter implements INameConvertor {
+
+		public char[] convertName(char[] name) {
+			UnresolvedType ut = TypeFactory.createTypeFromSignature(new String(name));
+			ResolvedType rt = getWorld().resolve(ut);
+			return rt.getName().toCharArray();
+		}
+		
+	}
 }
 
@@ -25,7 +25,14 @@ import org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration;
 import org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration;
 import org.aspectj.ajdt.internal.compiler.ast.PointcutDeclaration;
 import org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment;
+import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.asm.IProgramElement;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Argument;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.aspectj.weaver.AdviceKind;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
@@ -39,13 +46,6 @@ import org.aspectj.weaver.patterns.OrPointcut;
 import org.aspectj.weaver.patterns.ReferencePointcut;
 import org.aspectj.weaver.patterns.TypePattern;
 import org.aspectj.weaver.patterns.TypePatternList;
-import org.aspectj.org.eclipse.jdt.core.compiler.CharOperation;
-import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
-import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Argument;
-import org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
-import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation;
-import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference;
-import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 
 /**
  * @author Mik Kersten
@@ -296,34 +296,31 @@ public class AsmElementFormatter {
 		Argument[] argArray = md.arguments;
 		if (argArray == null) {
 			pe.setParameterNames(Collections.EMPTY_LIST);
-			pe.setParameterTypes(Collections.EMPTY_LIST);
+			pe.setParameterSignatures(Collections.EMPTY_LIST);
 		} else {
 			List names = new ArrayList();
-			List types = new ArrayList();
-			
+			List paramSigs = new ArrayList();
 			for (int i = 0; i < argArray.length; i++) {
 				String argName = new String(argArray[i].name);
-				String argType = "<UnknownType>"; // pr135052
-				TypeReference typeR = argArray[i].type;
-				if (typeR!=null) {
-					TypeBinding typeB = typeR.resolvedType;
-					if (typeB==null) {
-						if (typeR.getTypeName()!=null) 
-							  argType = CharOperation.toString(typeR.getTypeName());						
-					} else {
-						argType = typeB.debugName();
+				//String argType = "<UnknownType>"; // pr135052
+				if (acceptArgument(argName, argArray[i].type.toString())) {
+					TypeReference typeR = argArray[i].type;
+					if (typeR!=null) {
+						TypeBinding typeB = typeR.resolvedType;
+						if (typeB==null) {
+							typeB = typeR.resolveType(md.scope);
+						}
+						EclipseFactory factory = EclipseFactory.fromScopeLookupEnvironment(md.scope);
+						UnresolvedType ut = factory.fromBinding(typeB);
+						paramSigs.add(ut.getSignature().toCharArray());
 					}
-				}
-				
-				
-//				String argType = argArray[i].type.resolvedType.debugName();
-				if (acceptArgument(argName, argArray[i].type.toString())) { 
 					names.add(argName);
-					types.add(argType);
-				}   
+				}
 			}
 			pe.setParameterNames(names);
-			pe.setParameterTypes(types);
+			if (!paramSigs.isEmpty()) {
+				pe.setParameterSignatures(paramSigs);
+			}
 		}
 	}
 
@@ -52,7 +52,7 @@ public class IncrementalStateManager {
 			element.wipeAllKnowledge();
 		}
 		incrementalStates.clear();
-		AsmManager.getDefault().createNewASM(); // forget what you know...
+		AsmManager.getDefault().createNewASM(null); // forget what you know...
 	}
 
 	public static Set getConfigFilesKnown() {
@@ -0,0 +1,46 @@
+import java.util.List;
+
+aspect A {
+
+	pointcut p() : execution(* *.*(..));
+	
+	before() : p() {}
+	
+	public void MyClass.method() {}
+	
+	public MyClass.new() {super();}
+}
+
+class C {
+	
+	public C() {}
+	
+	public void method() {}
+	
+	public void intMethod(int i) {}
+	
+	public void stringMethod(String s) {}
+	
+	public void myClassMethod(MyClass s) {}
+	
+	public void genericMethod(List<String> l) {}
+	
+	public void twoArgsMethod(int i, String s) {}
+	
+	public void genericMethod2(MyGenericClass<String,MyClass> m) {}
+	
+	public static void main(String[] args) {}
+	
+	public void multiMethod(String[][] s) {}
+	
+	public void intArray(int[] i) {}
+	
+}
+
+class MyClass {
+	
+	public MyClass(String s) {}
+	
+}
+
+class MyGenericClass<X,Y> {}
@@ -109,7 +109,7 @@ public class Ajc151Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   	  IProgramElement pe2 = top.findElementForType("pkg","printParameters");
   	  assertNotNull("Couldn't find 'printParameters' element in the tree",pe2);
   	  // the argument is org.aspectj.lang.JoinPoint, check that this is added
-  	  assertFalse("printParameters method should have arguments",pe2.getParameterTypes().isEmpty());	  
+  	  assertFalse("printParameters method should have arguments",pe2.getParameterSignatures().isEmpty());	  
   }
 
   public void testParameterizedEnum_pr126316() {
@@ -156,8 +156,8 @@ public class Ajc151Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   			  IProgramElement.Kind.INTER_TYPE_FIELD,"Bar.children");  	   	 
   	  assertNotNull("Couldn't find 'Bar.children' element in the tree",field);
   	  IProgramElement constructor = top.findElementForLabel(top.getRoot(),
-  			  IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR,"Foo.Foo(List<T>)");  	   	 
-  	  assertNotNull("Couldn't find 'Foo.Foo(List<T>)' element in the tree",constructor);
+  			  IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR,"Foo.Foo(java.util.List<T>)");  	   	 
+  	  assertNotNull("Couldn't find 'Foo.Foo(java.util.List<T>)' element in the tree",constructor);
 
   	  // check that the relationship map has 'itd method declared on bar'
   	  List matches = AsmManager.getDefault().getRelationshipMap().get(method);
@@ -11,6 +11,7 @@
 package org.aspectj.systemtest.ajc152;
 
 import java.io.File;
+import java.util.ArrayList;
 import java.util.List;
 
 import junit.framework.Test;
@@ -128,6 +129,60 @@ public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testJarChecking_pr137235_2() { runTest("directory with .jar extension"); }
   public void testMakePreMethodNPE_pr136393() { runTest("NPE in makePreMethod");}
 
+  public void testGetParameterHandles_pr141730() {
+	  runTest("new IProgramElement handle methods");  
+	  
+	  checkParametersForIPE("intMethod(int)",IProgramElement.Kind.METHOD,"I",true);
+	  checkParametersForIPE("stringMethod(java.lang.String)",IProgramElement.Kind.METHOD,"Ljava/lang/String;",true);
+	  checkParametersForIPE("myClassMethod(MyClass)",IProgramElement.Kind.METHOD,"LMyClass;",true);
+	  checkParametersForIPE("genericMethod(java.util.List<java.lang.String>)",IProgramElement.Kind.METHOD,"Pjava/util/List<Ljava/lang/String;>;",true);
+	  checkParametersForIPE("genericMethod2(MyGenericClass<java.lang.String,MyClass>)",IProgramElement.Kind.METHOD,"PMyGenericClass<Ljava/lang/String;LMyClass;>;",true);
+	  checkParametersForIPE("main(java.lang.String[])",IProgramElement.Kind.METHOD,"[Ljava/lang/String;",true);
+	  checkParametersForIPE("multiMethod(java.lang.String[][])",IProgramElement.Kind.METHOD,"[[Ljava/lang/String;",true);
+	  checkParametersForIPE("intArray(int[])",IProgramElement.Kind.METHOD,"[I",true);
+	  
+  	  IHierarchy top = AsmManager.getDefault().getHierarchy();      
+  	  IProgramElement twoArgsMethod = top.findElementForLabel(
+  			  top.getRoot(),IProgramElement.Kind.METHOD,"twoArgsMethod(int,java.lang.String)");
+      assertNotNull("Couldn't find 'twoArgsMethod(int,java.lang.String)' element in the tree",twoArgsMethod);
+      List l = twoArgsMethod.getParameterSignatures();
+      assertEquals("",((char[])l.get(0))[0],'I');
+      boolean eq = equals(((char[])l.get(1)),"Ljava/lang/String;".toCharArray());
+      assertTrue("expected parameter to be 'Ljava/lang/String;' but found '" +
+        		new String(((char[])l.get(1))) + "'",eq);
+  }
+  
+  public void testGetParameterTypes_pr141730() {
+	  runTest("new IProgramElement handle methods"); 
+	  
+	  checkParametersForIPE("intMethod(int)",IProgramElement.Kind.METHOD,"int",false);
+	  checkParametersForIPE("stringMethod(java.lang.String)",IProgramElement.Kind.METHOD,"java.lang.String",false);
+	  checkParametersForIPE("myClassMethod(MyClass)",IProgramElement.Kind.METHOD,"MyClass",false);
+	  checkParametersForIPE("genericMethod(java.util.List<java.lang.String>)",IProgramElement.Kind.METHOD,"java.util.List<java.lang.String>",false);
+	  checkParametersForIPE("genericMethod2(MyGenericClass<java.lang.String,MyClass>)",IProgramElement.Kind.METHOD,"MyGenericClass<java.lang.String,MyClass>",false);
+	  checkParametersForIPE("main(java.lang.String[])",IProgramElement.Kind.METHOD,"java.lang.String[]",false);
+	  checkParametersForIPE("multiMethod(java.lang.String[][])",IProgramElement.Kind.METHOD,"java.lang.String[][]",false);
+	  checkParametersForIPE("intArray(int[])",IProgramElement.Kind.METHOD,"int[]",false);
+  }
+  
+  public void testToSignatureString_pr141730() {
+	  runTest("new IProgramElement handle methods"); 
+	  
+	  checkSignatureOfIPE("main(java.lang.String[])",IProgramElement.Kind.METHOD);
+	  checkSignatureOfIPE("C",IProgramElement.Kind.CLASS);
+	  checkSignatureOfIPE("C()",IProgramElement.Kind.CONSTRUCTOR);
+	  checkSignatureOfIPE("method()",IProgramElement.Kind.METHOD);
+	  checkSignatureOfIPE("p()",IProgramElement.Kind.POINTCUT);
+	  checkSignatureOfIPE("before(): p..",IProgramElement.Kind.ADVICE,"before()");
+	  checkSignatureOfIPE("MyClass.method()",IProgramElement.Kind.INTER_TYPE_METHOD);
+	  checkSignatureOfIPE("multiMethod(java.lang.String[][])",IProgramElement.Kind.METHOD);
+	  checkSignatureOfIPE("intArray(int[])",IProgramElement.Kind.METHOD);
+	  checkSignatureOfIPE("MyClass.MyClass()",IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR);
+  }
+
+  
+
+  
 //  public void testFunkyGenericErrorWithITDs_pr126355_2() { 
 //	  runTest("bizarre generic error with itds - 2");
 //	  // public class Pair<F,S> affected by pertarget aspect
@@ -143,6 +198,55 @@ public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
   // Not valid whilst the ajc compiler forces debug on (ignores -g:none) - it will be green but is invalid, trust me
   // public void testLongWindedMessages_pr129408() { runTest("long winded ataj messages");}
+
+  // ---------------- helper methods ---------------
+  
+   /**
+    * taken from CharOperation
+    */
+	private final boolean equals(char[] first, char[] second) {
+		if (first == second)
+			return true;
+		if (first == null || second == null)
+			return false;
+		if (first.length != second.length)
+			return false;
+
+		for (int i = first.length; --i >= 0;)
+			if (first[i] != second[i])
+				return false;
+		return true;
+	}
+  
+	private void checkParametersForIPE(String ipeLabel, IProgramElement.Kind kind, String expectedParm, boolean getHandles) {
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement ipe = top.findElementForLabel(top.getRoot(),kind,ipeLabel);
+	    assertNotNull("Couldn't find '" + ipeLabel + "' element in the tree",ipe);
+	    List l = new ArrayList();
+	    if (getHandles) {
+	    	l = ipe.getParameterSignatures();
+	    } else {
+	    	l = ipe.getParameterTypes();
+	    }
+	    boolean eq = equals(((char[])l.get(0)),expectedParm.toCharArray());
+	    assertTrue("expected parameter to be '" + expectedParm + "' but found '" +
+	      		new String(((char[])l.get(0))) + "'",eq);
+	}
+  
+	private void checkSignatureOfIPE(String ipeLabel, IProgramElement.Kind kind) {
+		checkSignatureOfIPE(ipeLabel,kind,ipeLabel);
+	}
+	
+	private void checkSignatureOfIPE(String ipeLabel, IProgramElement.Kind kind, String expectedSig) {
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement ipe = top.findElementForLabel(
+				  top.getRoot(),kind,ipeLabel);
+	    assertNotNull("Couldn't find '" + ipeLabel + "' element in the tree",ipe);
+      	assertEquals("expected signature to be '"+ expectedSig + "' but was " +
+				  ipe.toSignatureString(true),expectedSig,ipe.toSignatureString(true));
+		
+	}
+	
   /////////////////////////////////////////
   public static Test suite() {
     return XMLBasedAjcTestCase.loadSuite(Ajc152Tests.class);
@@ -602,6 +602,10 @@
       <compile files="Covariance.java" options="-1.5"/>
     </ajc-test>
 
+    <ajc-test dir="bugs152" title="new IProgramElement handle methods">
+      <compile files="pr141730.aj" options="-emacssym -1.5"/>
+    </ajc-test>
+
     <ajc-test dir="bugs152" title="declare @method relationship">
      <compile files="pr143924.aj" options="-1.5 -showWeaveInfo -emacssym">
         <message kind="weave" text="'public void BankAccount.debit(String,long)' (pr143924.aj:7) is annotated with @Secured"/>
@@ -0,0 +1,48 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.util;
+
+
+/**
+ * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+ *
+ */
+public class CharOperation {
+	
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final char[] subarray(char[] array, int start, int end) {
+		if (end == -1)
+			end = array.length;
+		if (start > end)
+			return null;
+		if (start < 0)
+			return null;
+		if (end > array.length)
+			return null;
+
+		char[] result = new char[end - start];
+		System.arraycopy(array, start, result, 0, end - start);
+		return result;
+	}
+	
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final int lastIndexOf(char toBeFound, char[] array) {
+		for (int i = array.length; --i >= 0;)
+			if (toBeFound == array[i])
+				return i;
+		return -1;
+	}
+	
+}
@@ -88,6 +88,7 @@ public class AsmManager {
 	}
 
 	public static AsmManager getDefault() {
+		new RuntimeException("fetching asm").printStackTrace();
 		return INSTANCE;
 	}
 
@@ -71,18 +71,17 @@ public class AsmManager {
 //	}
 
     protected AsmManager() {
-    	hierarchy = new AspectJElementHierarchy();
-//    	List relationships = new ArrayList();
-		mapper = new RelationshipMap(hierarchy);
-        handleProvider = new OptimizedFullPathHandleProvider(); 
+ 		handleProvider = new OptimizedFullPathHandleProvider();
+    	createNewASM();
     }
 
 	public void createNewASM() {
 		hierarchy = new AspectJElementHierarchy();
 		mapper = new RelationshipMap(hierarchy);
+		// call initialize on the handleProvider when we create a new ASM
+		// to give handleProviders the chance to reset any state
+		handleProvider.initialize();
 	}
-	
-	
 
     public IHierarchy getHierarchy() {
         return hierarchy;	
@@ -490,10 +489,6 @@ public class AsmManager {
 
 	//===================== DELTA PROCESSING CODE ============== start ==========//
 
-	private String getFilename(String hid) {
-		return getHandleProvider().getFileForHandle(hid);
-	}
-	
 	/**
 	 * Removes the hierarchy structure for the specified files from the structure model.
 	 * Returns true if it deleted anything
@@ -515,7 +510,7 @@ public class AsmManager {
 					fw.write("Deleting "+progElem+" node for file "+fileForCompilation+"\n");
 				}
 				removeNode(progElem);
-				deletedNodes.add(getFilename(progElem.getHandleIdentifier()));
+				deletedNodes.add(getCanonicalFilePath(progElem.getSourceLocation().getSourceFile()));
 				if (!model.removeFromFileMap(correctedPath.toString())) 
 						throw new RuntimeException("Whilst repairing model, couldn't remove entry for file: "+correctedPath.toString()+" from the filemap");
 				modelModified = true;
@@ -557,7 +552,7 @@ public class AsmManager {
 					fw.write("Deleting "+progElem+" node for file "+fileForCompilation+"\n");
 				}
 				removeNode(progElem);
-				deletedNodes.add(getFilename(progElem.getHandleIdentifier()));
+				deletedNodes.add(getCanonicalFilePath(progElem.getSourceLocation().getSourceFile()));
 				if (!model.removeFromFileMap(correctedPath.toString())) 
 						throw new RuntimeException("Whilst repairing model, couldn't remove entry for file: "+correctedPath.toString()+" from the filemap");
 				modelModified = true;
@@ -60,4 +60,18 @@ public interface IElementHandleProvider {
 
     public int getOffSetForHandle(String handle);
 
+    // See pr134471 
+    /**
+     * @return true if the handles produced by the provider 
+     * depend on ISourceLocations and false otherwise
+     */
+    public boolean dependsOnLocation();
+    
+    /**
+     * Initializes handle provider state.
+     * 
+     * The initializer is invoked when a new ASM is
+     * created on a full build.
+     */
+    public void initialize();
 }
@@ -406,7 +406,8 @@ public class AspectJElementHierarchy implements IHierarchy {
 		Set k = handleMap.keySet();
 		for (Iterator iter = k.iterator(); iter.hasNext();) {
 			String handle = (String) iter.next();
-			if (deletedFiles.contains(getFilename(handle))) forRemoval.add(handle);
+			IProgramElement ipe = (IProgramElement)handleMap.get(handle);
+			if (deletedFiles.contains(getCanonicalFilePath(ipe)))forRemoval.add(handle); 
 		}
 		for (Iterator iter = forRemoval.iterator(); iter.hasNext();) {
 			String handle = (String) iter.next();
@@ -415,31 +416,37 @@ public class AspectJElementHierarchy implements IHierarchy {
 		forRemoval.clear();
 		k = typeMap.keySet();
 		for (Iterator iter = k.iterator(); iter.hasNext();) {
-			String element = (String) iter.next();
-			IProgramElement ipe = (IProgramElement)typeMap.get(element);
-			if (deletedFiles.contains(getFilename(ipe.getHandleIdentifier()))) forRemoval.add(element);
+			String typeName = (String) iter.next();
+			IProgramElement ipe = (IProgramElement)typeMap.get(typeName);
+			if (deletedFiles.contains(getCanonicalFilePath(ipe))) forRemoval.add(typeName);
 		}
 		for (Iterator iter = forRemoval.iterator(); iter.hasNext();) {
-			String handle = (String) iter.next();
-			typeMap.remove(handle);
+			String typeName = (String) iter.next();
+			typeMap.remove(typeName);
 		}
 		forRemoval.clear();
 		k = fileMap.keySet();
 		for (Iterator iter = k.iterator(); iter.hasNext();) {
-			String element = (String) iter.next();
-			IProgramElement ipe = (IProgramElement)fileMap.get(element);
-			if (deletedFiles.contains(getFilename(ipe.getHandleIdentifier()))) forRemoval.add(element);
+			String filePath = (String) iter.next();
+			IProgramElement ipe = (IProgramElement)fileMap.get(filePath);
+			if (deletedFiles.contains(getCanonicalFilePath(ipe))) forRemoval.add(filePath);
 		}
 		for (Iterator iter = forRemoval.iterator(); iter.hasNext();) {
-			String handle = (String) iter.next();
-			fileMap.remove(handle);
+			String filePath = (String) iter.next();
+			fileMap.remove(filePath);
 		}
-		
 	}
 
 	private String getFilename(String hid) {
 		return AsmManager.getDefault().getHandleProvider().getFileForHandle(hid);
 	}
+	
+	private String getCanonicalFilePath(IProgramElement ipe) {
+		if (ipe.getSourceLocation() != null) {
+			return AsmManager.getDefault().getCanonicalFilePath(ipe.getSourceLocation().getSourceFile());			
+		}
+		return "";
+	}
 
 }
 
@@ -0,0 +1,213 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.asm.internal;
+
+import java.io.File;
+import java.util.Iterator;
+import java.util.List;
+
+import org.aspectj.asm.AsmManager;
+import org.aspectj.asm.IElementHandleProvider;
+import org.aspectj.asm.IProgramElement;
+import org.aspectj.bridge.ISourceLocation;
+import org.aspectj.util.CharOperation;
+import org.aspectj.util.NameConvertor;
+
+/**
+ * Creates JDT-like handles, for example
+ * 
+ * method with string argument:  <tjp{Demo.java[Demo~main~\[QString;
+ * method with generic argument: <pkg{MyClass.java[MyClass~myMethod~QList\<QString;>;
+ * an aspect:					 <pkg*A1.aj}A1
+ * advice with Integer arg:      <pkg*A8.aj}A8&afterReturning&QInteger;
+ * method call:	                 <pkg*A10.aj[C~m1?method-call(void pkg.C.m2())
+ *
+ */
+public class JDTLikeHandleProvider implements IElementHandleProvider {
+ 	
+	// Need to keep our own count of the number of initializers
+	// because this information cannot be gained from the ipe.
+	private int initializerCounter = 0;
+	
+	private char[] empty = new char[]{};
+	private char[] countDelim = new char[]{HandleProviderDelimiter.COUNT.getDelimiter()};
+	
+	private String backslash = "\\";
+	private String emptyString = "";
+	
+	public String createHandleIdentifier(IProgramElement ipe) {
+
+		// AjBuildManager.setupModel --> top of the tree is either
+		// <root> or the .lst file
+		if (ipe == null || 
+				(ipe.getKind().equals(IProgramElement.Kind.FILE_JAVA) 
+						&& ipe.getName().equals("<root>"))) {
+			return "";
+		} else if (ipe.getHandleIdentifier(false) != null) {
+			// have already created the handle for this ipe
+			// therefore just return it
+			return ipe.getHandleIdentifier();
+		} else if (ipe.getKind().equals(IProgramElement.Kind.FILE_LST)) {
+			String configFile = AsmManager.getDefault().getHierarchy().getConfigFile();
+			int start = configFile.lastIndexOf(File.separator);
+			int end = configFile.lastIndexOf(".lst");
+			String fileName = configFile.substring(start + 1,end);
+			ipe.setHandleIdentifier(fileName);
+			return fileName;
+		}
+		IProgramElement parent = ipe.getParent();
+		if (parent != null &&
+				parent.getKind().equals(IProgramElement.Kind.IMPORT_REFERENCE)) {
+			// want to miss out '#import declaration' in the handle
+			parent = ipe.getParent().getParent();
+		}
+		
+		StringBuffer handle = new StringBuffer();
+		// add the handle for the parent
+		handle.append(createHandleIdentifier(parent));
+		// add the correct delimiter for this ipe
+		handle.append(HandleProviderDelimiter.getDelimiter(ipe));
+		// add the name and any parameters unless we're an initializer
+		// (initializer's names are '...')
+		if (!ipe.getKind().equals(IProgramElement.Kind.INITIALIZER)) {
+			handle.append(ipe.getName() + getParameters(ipe));
+		}
+		// add the count, for example '!2' if its the second ipe of its
+		// kind in the aspect
+		handle.append(getCount(ipe));
+
+		ipe.setHandleIdentifier(handle.toString());
+		return handle.toString();
+	}	
+
+	private String getParameters(IProgramElement ipe) {
+		if (ipe.getParameterSignatures() == null || ipe.getParameterSignatures().isEmpty()) return "";
+		StringBuffer sb = new StringBuffer();
+		List parameterTypes = ipe.getParameterSignatures();
+		for (Iterator iter = parameterTypes.iterator(); iter.hasNext();) {
+			char[] element = (char[]) iter.next();
+			sb.append(HandleProviderDelimiter.getDelimiter(ipe));
+			if (element[0] == HandleProviderDelimiter.TYPE.getDelimiter()) {
+				// its an array
+				sb.append(HandleProviderDelimiter.ESCAPE.getDelimiter());
+				sb.append(HandleProviderDelimiter.TYPE.getDelimiter());
+				sb.append(NameConvertor.getTypeName(
+						CharOperation.subarray(element,1,element.length)));
+			} else if (element[0] == NameConvertor.PARAMETERIZED) {
+				// its a parameterized type
+				sb.append(NameConvertor.createShortName(element));
+			} else {
+				sb.append(NameConvertor.getTypeName(element));
+			}
+		}
+		return sb.toString();
+	}
+		
+	private char[] getCount(IProgramElement ipe) {
+		char[] byteCodeName = ipe.getBytecodeName().toCharArray();
+		if (ipe.getKind().isDeclare()) {
+			int index = CharOperation.lastIndexOf('_',byteCodeName);
+			if (index != -1) {
+				return convertCount(CharOperation.subarray(byteCodeName,
+						index+1,byteCodeName.length));
+			}
+		} else if (ipe.getKind().equals(IProgramElement.Kind.ADVICE)) {
+			int lastDollar = CharOperation.lastIndexOf('$',byteCodeName);
+			if (lastDollar != -1) {
+				char[] upToDollar = CharOperation.subarray(byteCodeName,0,lastDollar);
+				int secondToLastDollar = CharOperation.lastIndexOf('$',upToDollar);
+				if (secondToLastDollar != -1) {
+					return convertCount(CharOperation.subarray(upToDollar,
+							secondToLastDollar+1,upToDollar.length));
+				}
+			}		
+		} else if (ipe.getKind().equals(IProgramElement.Kind.INITIALIZER)) {	
+			return String.valueOf(++initializerCounter).toCharArray();
+		}
+		return empty;
+	}
+	
+	/**
+	 * Only returns the count if it's not equal to 1
+	 */
+	private char[] convertCount(char[] c) {
+		if ((c.length == 1 && c[0] != ' ' && c[0] != '1') || c.length > 1) {
+			return CharOperation.concat(countDelim,c);
+		}
+		return empty;
+	}
+	
+    public String getFileForHandle(String handle) {
+    	IProgramElement node = AsmManager.getDefault().getHierarchy().getElement(handle);
+    	if (node != null) {
+        	return AsmManager.getDefault().getCanonicalFilePath(node.getSourceLocation().getSourceFile());			
+		} else if (handle.charAt(0) == HandleProviderDelimiter.ASPECT_CU.getDelimiter() 
+				|| handle.charAt(0) == HandleProviderDelimiter.COMPILATIONUNIT.getDelimiter()) {
+			// it's something like *MyAspect.aj or {MyClass.java. In other words
+			// it's a file node that's been created with no children and no parent
+			return backslash + handle.substring(1);
+		} 
+    	return emptyString;
+    }
+
+    public int getLineNumberForHandle(String handle) {
+    	IProgramElement node = AsmManager.getDefault().getHierarchy().getElement(handle);
+    	if (node != null) {
+    		return node.getSourceLocation().getLine();
+		} else if (handle.charAt(0) == HandleProviderDelimiter.ASPECT_CU.getDelimiter() 
+				|| handle.charAt(0) == HandleProviderDelimiter.COMPILATIONUNIT.getDelimiter()) {
+			// it's something like *MyAspect.aj or {MyClass.java. In other words
+			// it's a file node that's been created with no children and no parent
+			return 1;
+		} 
+    	return -1;
+    }
+
+	public int getOffSetForHandle(String handle) {
+    	IProgramElement node = AsmManager.getDefault().getHierarchy().getElement(handle);
+    	if (node != null) {
+    		return node.getSourceLocation().getOffset();
+		} else if (handle.charAt(0) == HandleProviderDelimiter.ASPECT_CU.getDelimiter() 
+				|| handle.charAt(0) == HandleProviderDelimiter.COMPILATIONUNIT.getDelimiter()) {
+			// it's something like *MyAspect.aj or {MyClass.java. In other words
+			// it's a file node that's been created with no children and no parent
+			return 0;
+		} 		
+    	return -1;
+	}
+
+	public String createHandleIdentifier(ISourceLocation location) {
+		IProgramElement node = AsmManager.getDefault().getHierarchy().findElementForSourceLine(location);
+		if (node != null) {
+			return createHandleIdentifier(node);
+		}
+		return null;
+	}
+
+	public String createHandleIdentifier(File sourceFile, int line, int column, int offset) {
+		IProgramElement node = AsmManager.getDefault().getHierarchy().findElementForOffSet(sourceFile.getAbsolutePath(),line,offset);
+		if (node != null) {
+			return createHandleIdentifier(node);
+		}
+		return null;
+	}
+	
+	public boolean dependsOnLocation() {
+		// handles are independent of soureLocations therefore return false
+		return false;
+	}
+
+	public void initialize() {
+		// reset the initializer count. This ensures we return the
+		// same handle as JDT for initializers.
+		initializerCounter = 0;
+	}
+}
@@ -330,7 +330,8 @@ public class AnnotationBinding extends XMLBasedAjcTestCase {
 			Relationship rel = (Relationship)l.get(0);
 			assertTrue("Should have 1 target but has "+rel.getTargets().size(),rel.getTargets().size()==1);
 			String tgt = (String)rel.getTargets().get(0);
-			assertTrue("Should point to line 10 but doesnt: "+tgt,tgt.indexOf("|10|")!=-1);
+			int lineNumber = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(tgt);
+			assertTrue("Should point to line 10 but doesnt: "+lineNumber,lineNumber == 10);
 	  	}
   }  
 
@@ -360,7 +361,9 @@ public class AnnotationBinding extends XMLBasedAjcTestCase {
 			Relationship rel = (Relationship)l.get(0);
 			assertTrue("Should have 1 target but has "+rel.getTargets().size(),rel.getTargets().size()==1);
 			String tgt = (String)rel.getTargets().get(0);
-			assertTrue("Should point to line 10 but doesnt: "+tgt,tgt.indexOf("|10|")!=-1);
+			int lineNumber = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(tgt);
+			assertTrue("Should point to line 10 but doesnt: "+lineNumber,lineNumber == 10);
+
 	  	}
   }  
 
@@ -390,7 +393,9 @@ public class AnnotationBinding extends XMLBasedAjcTestCase {
 			Relationship rel = (Relationship)l.get(0);
 			assertTrue("Should have 1 target but has "+rel.getTargets().size(),rel.getTargets().size()==1);
 			String tgt = (String)rel.getTargets().get(0);
-			assertTrue("Should point to line 10 but doesnt: "+tgt,tgt.indexOf("|10|")!=-1);
+			int lineNumber = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(tgt);
+			assertTrue("Should point to line 10 but doesnt: "+lineNumber,lineNumber == 10);
+
 	  	}
   }  
 
@@ -19,6 +19,7 @@ public class AllTestsAspectJ153 {
 		TestSuite suite = new TestSuite("AspectJ 1.5.3 tests");
 		//$JUnit-BEGIN$
 		suite.addTest(Ajc153Tests.suite());
+		suite.addTest(JDTLikeHandleProviderTests.suite());
         //$JUnit-END$
 		return suite;
 	}
@@ -0,0 +1,506 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.systemtest.ajc153;
+
+import java.io.File;
+import java.util.Iterator;
+import java.util.List;
+
+import junit.framework.Test;
+
+import org.aspectj.asm.AsmManager;
+import org.aspectj.asm.IElementHandleProvider;
+import org.aspectj.asm.IHierarchy;
+import org.aspectj.asm.IProgramElement;
+import org.aspectj.asm.internal.JDTLikeHandleProvider;
+import org.aspectj.testing.XMLBasedAjcTestCase;
+
+public class JDTLikeHandleProviderTests extends XMLBasedAjcTestCase {
+
+	IElementHandleProvider handleProvider;
+	
+	protected void setUp() throws Exception {
+		super.setUp();
+		handleProvider = AsmManager.getDefault().getHandleProvider();
+		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+	}
+
+	protected void tearDown() throws Exception {
+		super.tearDown();
+		AsmManager.getDefault().setHandleProvider(handleProvider);
+	}
+	
+	public void testMoreThanOneNamedPointcut() {
+		runTest("More than one named pointcut");
+	}
+
+	public void testAspectHandle() {
+		runTest("aspect handle");
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement pe = top.findElementForType("pkg", "A1");
+		String expected = "<pkg*A1.aj}A1";
+		String found = pe.getHandleIdentifier();
+		assertEquals("handleIdentifier - expected " + expected + ", but found "
+				+ found, expected, found);
+	}
+
+	public void testAdviceHandle() {
+		runTest("advice handle");
+		compareHandles(IProgramElement.Kind.ADVICE,
+				"before(): <anonymous pointcut>",
+				"<pkg*A2.aj}A2&before");
+	}
+
+	public void testPointcutHandle() {
+		runTest("pointcut handle");
+		compareHandles(IProgramElement.Kind.POINTCUT,
+				"p()",
+				"<pkg*A4.aj}A4+p");
+	}
+	
+	public void testGetIPEWithAspectHandle() {
+		runTest("get IProgramElement with aspect handle");
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		String handle = "<pkg*A1.aj}A1";
+		IProgramElement ipe = top.getElement(handle);
+		assertNotNull("should have found ipe with handle " + handle, ipe);
+		IProgramElement ipe2 = top.getElement(handle);
+		assertEquals("should be the same IPE",ipe,ipe2);
+	}
+	
+	public void testAdviceHandleWithCrossCutting() {
+		runTest("advice handle with crosscutting");
+		compareHandles(IProgramElement.Kind.ADVICE,
+				"before(): <anonymous pointcut>",
+				"<pkg*A3.aj}A3&before");
+	}
+
+	public void testPointcutHandleWithArgs() {
+		runTest("pointcut handle with args");
+		compareHandles(IProgramElement.Kind.POINTCUT,
+				"p(java.lang.Integer)",
+				"*A6.aj}A6+p+QInteger;");
+	}
+	
+	public void testAdviceHandleWithArgs() {
+		runTest("advice handle with args");
+		compareHandles(IProgramElement.Kind.ADVICE,
+				"afterReturning(java.lang.Integer): p..",
+				"<pkg*A8.aj}A8&afterReturning&QInteger;");
+	}
+
+	public void testFieldITD() {
+		runTest("field itd handle");
+		compareHandles(IProgramElement.Kind.INTER_TYPE_FIELD,
+				"C.x",
+				"<pkg*A9.aj}A9)C.x");
+	}
+	
+	public void testMethodITD() {
+		runTest("method itd handle");
+		compareHandles(IProgramElement.Kind.INTER_TYPE_METHOD,
+				"C.method()",
+				"<pkg*A9.aj}A9)C.method");
+	}
+	
+	public void testMethodITDWithArgs() {
+		runTest("method itd with args handle");
+		compareHandles(IProgramElement.Kind.INTER_TYPE_METHOD,
+				"C.methodWithArgs(int)",
+				"<pkg*A9.aj}A9)C.methodWithArgs)I");
+	}
+	
+	public void testConstructorITDWithArgs() {
+		runTest("constructor itd with args");
+		compareHandles(IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR,
+				"C.C(int,java.lang.String)",
+				"<pkg*A13.aj}A13)C.C)I)QString;");
+	}
+	
+	public void testDeclareParentsHandle() {
+		runTest("declare parents handle");
+		compareHandles(IProgramElement.Kind.DECLARE_PARENTS,
+				"declare parents: implements C2",
+				"<pkg*A7.aj}A7`declare parents");
+	}
+	
+	public void testTwoDeclareParents() {
+		runTest("two declare parents in same file");
+		compareHandles(IProgramElement.Kind.DECLARE_PARENTS,
+				"declare parents: extends C5",
+				"<pkg*A7.aj}A7`declare parents!2");
+	}
+	
+	public void testMethodCallHandle() {
+		runTest("method call handle");
+		compareHandles(IProgramElement.Kind.CODE,
+				"method-call(void pkg.C.m2())",
+				"<pkg*A10.aj[C~m1?method-call(void pkg.C.m2())");
+	}
+	
+	public void testDeclareAtType() {
+		// AJDT: =AJHandleProject/src<pkg*A.aj}A`declare \@type
+		runTest("declare @type");
+		compareHandles(IProgramElement.Kind.DECLARE_ANNOTATION_AT_TYPE,
+				"declare @type: pkg.C : @MyAnnotation",
+				"<pkg*A12.aj}A`declare @type");
+	}
+	
+	public void testDeclareAtField() {
+		// AJDT: =AJHandleProject/src<pkg*A.aj}A`declare \@field
+		runTest("declare @field");
+		compareHandles(IProgramElement.Kind.DECLARE_ANNOTATION_AT_FIELD,
+				"declare @field: int pkg.C.someField : @MyAnnotation",
+				"<pkg*A12.aj}A`declare @field!2");	
+	}
+	
+	public void testDeclareAtMethod() {
+		// AJDT: =AJHandleProject/src<pkg*A.aj}A`declare \@method
+		runTest("declare @method");
+		compareHandles(IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD,
+				"declare @method: public void pkg.C.method1() : @MyAnnotation",
+				"<pkg*A12.aj}A`declare @method!3");	
+	}
+	
+	public void testDeclareAtConstructor() {
+		// AJDT: =AJHandleProject/src<pkg*A.aj}A`declare \@constructor
+		runTest("declare @constructor");
+		compareHandles(IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR,
+				"declare @constructor: pkg.C.new() : @MyAnnotation",
+				"<pkg*A12.aj}A`declare @constructor!4");	
+	}
+	
+	
+	// what about 2 pieces of before advice with the same 
+	// signature and the same pointcut
+	public void testTwoPiecesOfAdviceWithSameSignatureAndPointcut() {
+		runTest("two pieces of advice with the same signature and pointcut");
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement parent = top.findElementForLabel(top.getRoot(),
+				IProgramElement.Kind.ASPECT, "A5");
+		List children = parent.getChildren();
+		String handle1 = null;
+		String handle2 = null;
+		for (Iterator iter = children.iterator(); iter.hasNext();) {
+			IProgramElement element = (IProgramElement) iter.next();
+			if (element.getKind().equals(IProgramElement.Kind.ADVICE)) {
+				if (handle1 == null) {
+					handle1 = element.getHandleIdentifier();
+				} else {
+					handle2 = element.getHandleIdentifier();
+				}
+			}
+		}
+		String expected1 = "<pkg*A5.aj}A5&before";
+		String expected2 = "<pkg*A5.aj}A5&before!2";
+		boolean b = expected1.equals(handle1);
+		if (b) {
+			assertEquals("handleIdentifier - expected " + expected2 + ", but found "
+					+ handle2, expected2, handle2);
+		} else {
+			assertEquals("handleIdentifier - expected " + expected1 + ", but found "
+					+ handle2, expected1, handle2);
+			assertEquals("handleIdentifier - expected " + expected2 + ", but found "
+					+ handle1, expected2, handle1);
+		}
+	}
+	
+	public void testDeclareWarningHandle() {
+		runTest("declare warning handle");
+		compareHandles(IProgramElement.Kind.DECLARE_WARNING,
+				"declare warning: \"Illegal call.\"",
+				"<pkg*A11.aj}A11`declare warning");
+	}
+	
+	public void testTwoDeclareWarningHandles() {
+		runTest("two declare warning handles");
+		compareHandles(IProgramElement.Kind.DECLARE_WARNING,
+				"declare warning: \"blah\"",
+				"<pkg*A11.aj}A11`declare warning!2");
+	}
+	
+	// this is to ensure the logic for not including '1' in the count
+	// works correctly. We don't want a decw ipe with count 1 but we do
+	// want one with count 10.
+	public void testTenDeclareWarningHandles() {
+		runTest("ten declare warning handles");
+		compareHandles(IProgramElement.Kind.DECLARE_WARNING,
+				"declare warning: \"warning 1\"",
+				"*DeclareWarnings.aj}DeclareWarnings`declare warning");
+		compareHandles(IProgramElement.Kind.DECLARE_WARNING,
+				"declare warning: \"warning 10\"",
+				"*DeclareWarnings.aj}DeclareWarnings`declare warning!10");
+
+	}
+	
+	//---------- following tests ensure we produce the same handles as jdt -----//
+	//---------- (apart from the prefix)
+	
+	// NOTES: there is no ipe equivalent to a package fragment root or
+	//        
+	
+	public void testCompilationUnitSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java
+		runTest("compilation unit same as jdt");
+		compareHandles(IProgramElement.Kind.FILE_JAVA,
+				"Demo.java",
+				"<tjp{Demo.java");
+	}
+
+	public void testClassSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{C.java[C
+		runTest("class same as jdt");
+		compareHandles(IProgramElement.Kind.CLASS,
+				"C","<pkg{C.java[C");
+	}
+
+	public void testInterfaceSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{C.java[MyInterface
+		runTest("interface same as jdt");
+		compareHandles(IProgramElement.Kind.INTERFACE,
+				"MyInterface","<pkg{C.java[MyInterface");
+	}
+	
+	public void testConstructorSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{C.java[C~C
+		runTest("constructor same as jdt");
+		compareHandles(IProgramElement.Kind.CONSTRUCTOR,
+				"C()","<pkg{C.java[C~C");
+	}
+	
+	public void testConstructorWithArgsSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{C.java[C~C~QString;
+		runTest("constructor with args same as jdt");
+		compareHandles(IProgramElement.Kind.CONSTRUCTOR,
+				"C(java.lang.String)","<pkg{C.java[C~C~QString;");
+	}
+	
+//	public void testPackageDeclarationSameAsJDT() {
+//		// JDT: =TJP Example/src<tjp{Demo.java%tjp
+//		fail("package declaration isn't the same");
+//		runTest("package declaration same as jdt");
+//		compareHandles(IProgramElement.Kind.PACKAGE,
+//				"tjp",
+//				"<tjp{Demo.java%tjp");
+//	}	
+	
+	public void testImportDeclarationSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java#java.io.*
+		runTest("import declaration same as jdt");
+		compareHandles(IProgramElement.Kind.IMPORT_REFERENCE,
+				"java.io.*",
+				"<tjp{Demo.java#java.io.*");
+	}	
+	
+	public void testTypeSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo
+		runTest("type same as jdt");
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement pe = top.findElementForType("tjp", "Demo");
+		String expected = "<tjp{Demo.java[Demo";
+		String found = pe.getHandleIdentifier();
+		assertEquals("handleIdentifier - expected " + expected + ", but found "
+				+ found, expected, found);
+	}	
+	
+	public void testFieldSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo^d
+		runTest("field same as jdt");
+		compareHandles(IProgramElement.Kind.FIELD,
+				"d",
+				"<tjp{Demo.java[Demo^d");
+	}	
+	public void testInitializationSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo|1 
+		// and =TJP Example/src<tjp{Demo.java[Demo|2
+		runTest("initialization same as jdt");
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement parent = top.findElementForLabel(top.getRoot(),
+				IProgramElement.Kind.CLASS, "Demo");
+		List children = parent.getChildren();
+		String handle1 = null;
+		String handle2 = null;
+		for (Iterator iter = children.iterator(); iter.hasNext();) {
+			IProgramElement element = (IProgramElement) iter.next();
+			if (element.getKind().equals(IProgramElement.Kind.INITIALIZER)) {
+				if (handle1 == null) {
+					handle1 = element.getHandleIdentifier();
+				} else {
+					handle2 = element.getHandleIdentifier();
+				}
+			}
+		}
+		String expected1 = "<tjp{Demo.java[Demo|1";
+		String expected2 = "<tjp{Demo.java[Demo|2";
+		boolean b = expected1.equals(handle1);
+		System.err.println("actual: " + handle1);
+		System.err.println("actual: " + handle2);
+		if (b) {
+			assertEquals("handleIdentifier - expected " + expected2 + ", but found "
+					+ handle2, expected2, handle2);
+		} else {
+			assertEquals("handleIdentifier - expected " + expected1 + ", but found "
+					+ handle2, expected1, handle2);
+			assertEquals("handleIdentifier - expected " + expected2 + ", but found "
+					+ handle1, expected2, handle1);
+		}
+	}	
+	public void testMethodWithStringArrayArgsSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo~main~\[QString;
+		runTest("method with string array as argument same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"main(java.lang.String[])",
+				"<tjp{Demo.java[Demo~main~\\[QString;");
+	}	
+	
+	public void testMethodWithIntArrayArgsSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo~m~\[I
+		runTest("method with int array as argument same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"m(int[])",
+				"<tjp{Demo.java[Demo~m~\\[I");
+	}	
+	
+	public void testMethodWithNoArgsSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo~go
+		runTest("method with no args same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"go()",
+				"<tjp{Demo.java[Demo~go");
+	}	
+	
+	public void testMethodWithTwoArgsSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo~foo~I~QObject;
+		runTest("method with two args same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"foo(int,java.lang.Object)",
+				"<tjp{Demo.java[Demo~foo~I~QObject;");
+	}	
+	
+	public void testMethodWithTwoStringArgsSameAsJDT() {
+		// JDT: =TJP Example/src<tjp{Demo.java[Demo~m2~QString;~QString;
+		runTest("method with two string args same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"m2(java.lang.String,java.lang.String)",
+				"<tjp{Demo.java[Demo~m2~QString;~QString;");		
+	}
+	
+	public void testEnumSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{E.java[E
+		runTest("enum same as jdt");
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement pe = top.findElementForType("pkg", "E");
+		String expected = "<pkg{E.java[E";
+		String found = pe.getHandleIdentifier();
+		assertEquals("handleIdentifier - expected " + expected + ", but found "
+				+ found, expected, found);	
+	}
+	
+	public void testEnumValueSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{E.java[E^A
+		runTest("enum value same as jdt");
+		compareHandles(IProgramElement.Kind.ENUM_VALUE,
+				"A","<pkg{E.java[E^A");
+	}
+	
+	public void testAnnotationSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{MyAnnotation.java[MyAnnotation
+		runTest("annotation same as jdt");
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement pe = top.findElementForType("pkg", "MyAnnotation");
+		String expected = "<pkg{MyAnnotation.java[MyAnnotation";
+		String found = pe.getHandleIdentifier();
+		assertEquals("handleIdentifier - expected " + expected + ", but found "
+				+ found, expected, found);	
+	}
+	
+	public void testMethodWithListArgSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{Java5Class.java[Java5Class~method2~QList;
+		runTest("method with list arg same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"method2(java.util.List)",
+				"<pkg{Java5Class.java[Java5Class~method2~QList;");
+	}
+	
+	public void testMethodWithGenericArgSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{Java5Class.java[Java5Class
+		//       ~genericMethod1~QList\<QString;>;
+		runTest("method with generic arg same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"genericMethod1(java.util.List<java.lang.String>)",
+				"<pkg{Java5Class.java[Java5Class~genericMethod1~QList\\<QString;>;");
+	}
+	
+	public void testMethodWithTwoGenericArgsSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{Java5Class.java[Java5Class
+		//       ~genericMethod2~QList\<QString;>;~QMyGenericClass\<QInteger;>;
+		runTest("method with two generic args same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"genericMethod2(java.util.List<java.lang.String>,"
+					+"pkg.MyGenericClass<java.lang.Integer>)",
+				"<pkg{Java5Class.java[Java5Class~genericMethod2~QList"
+					+"\\<QString;>;~QMyGenericClass\\<QInteger;>;");
+	}
+	
+	public void testMethodWithTwoTypeParametersSameAsJDT() {
+		// JDT: =Java5 Handles/src<pkg{Java5Class.java[Java5Class~genericMethod4
+		//       ~QMyGenericClass2\<QString;QInteger;>;
+		runTest("method with two type parameters same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"genericMethod4(pkg.MyGenericClass2<java.lang.String,java.lang.Integer>)",
+				"<pkg{Java5Class.java[Java5Class~genericMethod4" +
+				"~QMyGenericClass2\\<QString;QInteger;>;");
+	}
+	
+	public void testMethodWithTwoArgsSameAsJDT_2() {
+		// JDT: =Java5 Handles/src<pkg{Java5Class.java[Java5Class
+		//      ~genericMethod3~I~QList\<QString;>;
+		runTest("method with two args one of which is generic same as jdt");
+		compareHandles(IProgramElement.Kind.METHOD,
+				"genericMethod3(int,java.util.List<java.lang.String>)",
+				"<pkg{Java5Class.java[Java5Class~genericMethod3~I~QList\\<QString;>;");
+	}
+	
+	/*
+	 * Still to do;
+	 * 				PROJECT,
+				PACKAGE,
+				FILE,
+				FILE_ASPECTJ,
+				FILE_LST,
+				DECLARE_ERROR,
+				DECLARE_SOFT,
+				DECLARE_PRECEDENCE,
+	 */
+	
+	// ----------- helper methods ---------------
+	
+	private void compareHandles(IProgramElement.Kind kind, String ipeName, String expectedHandle) {
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement pe = top.findElementForLabel(top.getRoot(),kind,ipeName);
+		String found = pe.getHandleIdentifier();
+		System.err.println("expected: " + expectedHandle);
+		System.err.println("actual:   " + found);
+		assertEquals("handleIdentifier - expected " + expectedHandle + ", but found "
+				+ found, expectedHandle, found);
+	}
+	
+	// ///////////////////////////////////////
+	public static Test suite() {
+		return XMLBasedAjcTestCase.loadSuite(JDTLikeHandleProviderTests.class);
+	}
+
+	protected File getSpecFile() {
+		return new File(
+				"../tests/src/org/aspectj/systemtest/ajc152/jdtlikehandleprovider.xml");
+	}
+
+}
@@ -25,13 +25,15 @@ import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.ajdt.internal.core.builder.AjState;
 import org.aspectj.ajdt.internal.core.builder.IncrementalStateManager;
 import org.aspectj.asm.AsmManager;
+import org.aspectj.asm.IElementHandleProvider;
+import org.aspectj.asm.IHierarchy;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.asm.IRelationship;
 import org.aspectj.asm.IRelationshipMap;
+import org.aspectj.asm.internal.JDTLikeHandleProvider;
 import org.aspectj.asm.internal.Relationship;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.tools.ajc.Ajc;
-import org.aspectj.weaver.World;
 
 /**
  * The superclass knows all about talking through Ajde to the compiler.
@@ -1040,7 +1042,7 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 				((IMessage)MyTaskListManager.getWarningMessages().get(0)).getSourceLocation().getLine());
 		alter("PR134541","inc1");
 		build("PR134541");
-		if (World.compareLocations)
+		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
 		  checkWasFullBuild(); // the line number has changed... but nothing structural about the code
 		else 
 		  checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
@@ -1048,6 +1050,131 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 				((IMessage)MyTaskListManager.getWarningMessages().get(0)).getSourceLocation().getLine());
 	}
 
+	public void testJDTLikeHandleProviderWithLstFile_pr141730() {
+		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
+		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+		configureBuildStructureModel(true);
+		try {
+			// The JDTLike-handles should start with the name
+			// of the buildconfig file
+			initialiseProject("JDTLikeHandleProvider");
+			build("JDTLikeHandleProvider");
+			IHierarchy top = AsmManager.getDefault().getHierarchy();
+		  	IProgramElement pe = top.findElementForType("pkg","A");
+		  	String expectedHandle = "build<pkg*A.aj}A";
+		  	assertEquals("expected handle to be " + expectedHandle + ", but found "
+		  			+ pe.getHandleIdentifier(),expectedHandle,pe.getHandleIdentifier());	
+		} finally {
+			AsmManager.getDefault().setHandleProvider(handleProvider);
+		  	configureBuildStructureModel(false);			
+		}
+	}
+	
+	public void testMovingAdviceDoesntChangeHandles_pr141730() {
+		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
+		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+		configureBuildStructureModel(true);
+		try {
+			initialiseProject("JDTLikeHandleProvider");
+			build("JDTLikeHandleProvider");
+			checkWasFullBuild();
+			IHierarchy top = AsmManager.getDefault().getHierarchy();
+			IProgramElement pe = top.findElementForLabel(top.getRoot(),
+					IProgramElement.Kind.ADVICE,"before(): <anonymous pointcut>");
+		  	// add a line which shouldn't change the handle
+			alter("JDTLikeHandleProvider","inc1");
+			build("JDTLikeHandleProvider");
+			checkWasntFullBuild();
+			IHierarchy top2 = AsmManager.getDefault().getHierarchy();
+			IProgramElement pe2 = top.findElementForLabel(top2.getRoot(),
+					IProgramElement.Kind.ADVICE,"before(): <anonymous pointcut>");
+			assertEquals("expected advice to be on line " + pe.getSourceLocation().getLine() + 1 
+					+ " but was on " + pe2.getSourceLocation().getLine(),
+					pe.getSourceLocation().getLine()+1,pe2.getSourceLocation().getLine());
+			assertEquals("expected advice to have handle " + pe.getHandleIdentifier()
+					+ " but found handle " + pe2.getHandleIdentifier(),
+					pe.getHandleIdentifier(),pe2.getHandleIdentifier());		
+		} finally {
+			AsmManager.getDefault().setHandleProvider(handleProvider);
+		  	configureBuildStructureModel(false);			
+		}
+	}
+	
+	public void testSwappingAdviceAndHandles_pr141730() {
+		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
+		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+		configureBuildStructureModel(true);
+		try {
+			initialiseProject("JDTLikeHandleProvider");
+			build("JDTLikeHandleProvider");
+			IHierarchy top = AsmManager.getDefault().getHierarchy();
+
+			IProgramElement call = top.findElementForLabel(top.getRoot(),
+					IProgramElement.Kind.ADVICE, "after(): callPCD..");
+			IProgramElement exec = top.findElementForLabel(top.getRoot(),
+					IProgramElement.Kind.ADVICE, "after(): execPCD..");
+		  	// swap the two after advice statements over. This forces
+			// a full build which means 'after(): callPCD..' will now
+			// be the second after advice in the file and have the same
+			// handle as 'after(): execPCD..' originally did.
+			alter("JDTLikeHandleProvider","inc2");
+			build("JDTLikeHandleProvider");
+			checkWasFullBuild();
+			
+			IHierarchy top2 = AsmManager.getDefault().getHierarchy();
+			IProgramElement newCall = top2.findElementForLabel(top2.getRoot(),
+					IProgramElement.Kind.ADVICE, "after(): callPCD..");
+			IProgramElement newExec = top2.findElementForLabel(top2.getRoot(),
+					IProgramElement.Kind.ADVICE, "after(): execPCD..");
+
+			assertEquals("after swapping places, expected 'after(): callPCD..' " +
+					"to be on line " + newExec.getSourceLocation().getLine() +
+					" but was on line " + call.getSourceLocation().getLine(),
+					newExec.getSourceLocation().getLine(),
+					call.getSourceLocation().getLine());
+			assertEquals("after swapping places, expected 'after(): callPCD..' " +
+					"to have handle " + exec.getHandleIdentifier() +
+					" (because was full build) but had " + newCall.getHandleIdentifier(),
+					exec.getHandleIdentifier(), newCall.getHandleIdentifier());
+		} finally {
+			AsmManager.getDefault().setHandleProvider(handleProvider);
+		  	configureBuildStructureModel(false);			
+		}
+	}
+	
+	public void testInitializerCountForJDTLikeHandleProvider_pr141730() {
+		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
+		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
+		configureBuildStructureModel(true);
+		try {
+			initialiseProject("JDTLikeHandleProvider");
+			build("JDTLikeHandleProvider");
+			String expected = "build<pkg*A.aj[C|1";
+
+			IHierarchy top = AsmManager.getDefault().getHierarchy();
+			IProgramElement init = top.findElementForLabel(top.getRoot(),
+					IProgramElement.Kind.INITIALIZER, "...");
+			assertEquals("expected initializers handle to be " + expected + "," +
+					" but found " + init.getHandleIdentifier(true),
+					expected,init.getHandleIdentifier(true));
+			
+			alter("JDTLikeHandleProvider","inc2");
+			build("JDTLikeHandleProvider");
+			checkWasFullBuild();
+			
+			IHierarchy top2 = AsmManager.getDefault().getHierarchy();
+			IProgramElement init2 = top2.findElementForLabel(top2.getRoot(),
+					IProgramElement.Kind.INITIALIZER, "...");
+			assertEquals("expected initializers handle to still be " + expected + "," +
+					" but found " + init2.getHandleIdentifier(true),
+					expected,init2.getHandleIdentifier(true));
+
+		
+		} finally {
+			AsmManager.getDefault().setHandleProvider(handleProvider);
+		  	configureBuildStructureModel(false);			
+		}
+	}
 
 	// 134471 related tests perform incremental compilation and verify features of the structure model post compile
 	public void testPr134471_IncrementalCompilationAndModelUpdates() {
@@ -1105,7 +1232,12 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		// Step3. No structural change to the aspect but the advice has moved down a few lines... (change in source location)
 		alter("PR134471_2","inc1");
 		build("PR134471_2");
-		checkWasFullBuild(); // this is true whilst we consider sourcelocation in the type/shadow munger equals() method - have to until the handles are independent of location
+		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
+			  checkWasFullBuild(); // the line number has changed... but nothing structural about the code
+			else 
+			  checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
+
+		//checkWasFullBuild(); // this is true whilst we consider sourcelocation in the type/shadow munger equals() method - have to until the handles are independent of location
 
 		// Step4. Check we have correctly realised the advice moved to line 11
 		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
@@ -1134,38 +1266,38 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 	public void testPr134471_IncrementallyRecompilingTheAffectedClass() {
 		try {
 			// see pr148027 AsmHierarchyBuilder.shouldAddUsesPointcut=false;
-		configureBuildStructureModel(true);
-		configureNonStandardCompileOptions("-showWeaveInfo -emacssym");
-		
-		// Step1. build the project
-		initialiseProject("PR134471");
-		build("PR134471");
-		
-		// Step2. confirm advice is from correct location
-		IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
-		int line = programElement.getSourceLocation().getLine();
-		assertTrue("advice should be at line 7 - but is at line "+line,line==7);
-
-		// Step3. No change to the aspect at all
-		alter("PR134471","inc1");
-		build("PR134471");
-		
-		// Step4. Quick check that the advice points to something...
-		IProgramElement nodeForTypeA = checkForNode("pkg","A",true);
-		IProgramElement nodeForAdvice = findAdvice(nodeForTypeA);
-		List relatedElements = getRelatedElements(nodeForAdvice,1);
+			configureBuildStructureModel(true);
+			configureNonStandardCompileOptions("-showWeaveInfo -emacssym");
+			
+			// Step1. build the project
+			initialiseProject("PR134471");
+			build("PR134471");
+			
+			// Step2. confirm advice is from correct location
+			IProgramElement programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
+			int line = programElement.getSourceLocation().getLine();
+			assertTrue("advice should be at line 7 - but is at line "+line,line==7);
+	
+			// Step3. No change to the aspect at all
+			alter("PR134471","inc1");
+			build("PR134471");
+			
+			// Step4. Quick check that the advice points to something...
+			IProgramElement nodeForTypeA = checkForNode("pkg","A",true);
+			IProgramElement nodeForAdvice = findAdvice(nodeForTypeA);
+			List relatedElements = getRelatedElements(nodeForAdvice,1);
+			
+		    // Step5. No change to the file C but it should still be advised afterwards
+			alter("PR134471","inc2");
+			build("PR134471");
+			checkWasntFullBuild();
 
-	    // Step5. No change to the file C but it should still be advised afterwards
-		alter("PR134471","inc2");
-		build("PR134471");
-		checkWasntFullBuild();
-	
-		// Step6. confirm advice is from correct location
-		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
-		line = programElement.getSourceLocation().getLine();
-		assertTrue("advice should be at line 7 - but is at line "+line,line==7);		
-	} finally {
-		// see pr148027 AsmHierarchyBuilder.shouldAddUsesPointcut=true;
+			// Step6. confirm advice is from correct location
+			programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true)));
+			line = programElement.getSourceLocation().getLine();
+			assertTrue("advice should be at line 7 - but is at line "+line,line==7);		
+		} finally {
+			// see pr148027 AsmHierarchyBuilder.shouldAddUsesPointcut=true;
 		}
 
 	}
@@ -1193,7 +1325,12 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		// Step4. Move declare warning in the aspect
 		alter("PR134471_3","inc1");
 		build("PR134471_3");
-		checkWasFullBuild();
+		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
+			  checkWasFullBuild(); // the line number has changed... but nothing structural about the code
+			else 
+			  checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
+
+		//checkWasFullBuild();
 
 		// Step5. confirm declare warning is from correct location, decw (now at line 12) in pkg.A matches line 7 in pkg.C
 		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true),7));
@@ -1210,6 +1347,7 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		line = programElement.getSourceLocation().getLine();
 		assertTrue("declare warning should be at line 12 - but is at line "+line,line==12);
 
+		configureBuildStructureModel(false);
 	}
 
 	// similar to previous test but with 'declare warning' as well as advice
@@ -1235,7 +1373,12 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		// Step4. Move declare warning in the aspect
 		alter("PR134471_3","inc1");
 		build("PR134471_3");
-		checkWasFullBuild();
+		if (AsmManager.getDefault().getHandleProvider().dependsOnLocation())
+			  checkWasFullBuild(); // the line number has changed... but nothing structural about the code
+			else 
+			  checkWasntFullBuild(); // the line number has changed... but nothing structural about the code
+
+		//checkWasFullBuild();
 
 		// Step5. confirm declare warning is from correct location, decw (now at line 12) in pkg.A matches line 7 in pkg.C
 		programElement = getFirstRelatedElement(findCode(checkForNode("pkg","C",true),7));
@@ -1262,8 +1405,9 @@ public class MultiProjectIncrementalTests extends AbstractMultiProjectIncrementa
 		line = programElement.getSourceLocation().getLine();
 		assertTrue("declare warning should be at line 12 - but is at line "+line,line==12);
 
+		configureBuildStructureModel(false);
 	}
-
+	
 	// --- helper code ---
 
 	/**
@@ -16,6 +16,7 @@ package org.aspectj.weaver;
 import java.util.Collections;
 import java.util.List;
 
+import org.aspectj.asm.AsmManager;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.weaver.bcel.Utility;
@@ -391,7 +392,8 @@ public abstract class Advice extends ShadowMunger {
         return o.kind.equals(kind) 
         	&& ((o.pointcut == null) ? (pointcut == null) : o.pointcut.equals(pointcut))
         	&& ((o.signature == null) ? (signature == null) : o.signature.equals(signature))
-        	&& (World.compareLocations?((o.getSourceLocation()==null) ? (getSourceLocation()==null): o.getSourceLocation().equals(getSourceLocation())):true) // pr134471 - remove when handles are improved to be independent of location
+        	&& (AsmManager.getDefault().getHandleProvider().dependsOnLocation()
+        			?((o.getSourceLocation()==null) ? (getSourceLocation()==null): o.getSourceLocation().equals(getSourceLocation())):true) // pr134471 - remove when handles are improved to be independent of location
         	;
 
     }
@@ -17,6 +17,7 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.Map;
 
+import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IRelationship;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
@@ -114,7 +115,8 @@ public class Checker extends ShadowMunger {
         return  
           o.isError == isError &&
         	 ((o.pointcut == null) ? (pointcut == null) : o.pointcut.equals(pointcut)) &&
-          (World.compareLocations?((o.getSourceLocation()==null) ? (getSourceLocation()==null): o.getSourceLocation().equals(getSourceLocation())):true) // pr134471 - remove when handles are improved to be independent of location
+          (AsmManager.getDefault().getHandleProvider().dependsOnLocation()
+        		  ?((o.getSourceLocation()==null) ? (getSourceLocation()==null): o.getSourceLocation().equals(getSourceLocation())):true) // pr134471 - remove when handles are improved to be independent of location
         	;
     }
 
@@ -21,6 +21,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import org.aspectj.asm.AsmManager;
 import org.aspectj.weaver.patterns.CflowPointcut;
 import org.aspectj.weaver.patterns.DeclareParents;
 import org.aspectj.weaver.patterns.IVerificationRequired;
@@ -76,7 +77,8 @@ public class CrosscuttingMembersSet {
 				CflowPointcut.clearCaches(aspectType);
 				change = true;
 			} else {
-				if (!World.compareLocations && inWeavingPhase) {
+				if (!AsmManager.getDefault().getHandleProvider().dependsOnLocation()
+						&& inWeavingPhase) {
 					// bug 134541 - even though we haven't changed we may have updated the 
 					// sourcelocation for the shadowMunger which we need to pick up
 					shadowMungers = null;
@@ -54,12 +54,7 @@ public abstract class World implements Dump.INode {
 
 	/** The heart of the world, a map from type signatures to resolved types */
     protected TypeMap typeMap = new TypeMap(this); // Signature to ResolvedType
-    
-    // See pr134471 - we would like to set this false but need for handles in the structure model
-    // to be independent of location before we can do that.
-    /** Should we take into account source location when comparing mungers - which may trigger full builds */
-    public final static boolean compareLocations = true;
-  
+
     // see pr145963
     /** Should we create the hierarchy for binary classes and aspects*/
     public static boolean createInjarHierarchy = true;
@@ -31,6 +31,7 @@ import org.aspectj.apache.bcel.generic.InstructionHandle;
 import org.aspectj.apache.bcel.generic.InstructionList;
 import org.aspectj.apache.bcel.generic.Type;
 import org.aspectj.apache.bcel.generic.annotation.AnnotationGen;
+import org.aspectj.asm.AsmManager;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.bridge.Message;
@@ -1679,7 +1680,8 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
         BcelTypeMunger o = (BcelTypeMunger) other;
         return ((o.getMunger() == null) ? (getMunger() == null) : o.getMunger().equals(getMunger()))
                && ((o.getAspectType() == null) ? (getAspectType() == null) : o.getAspectType().equals(getAspectType()))
-               && (World.compareLocations?((o.getSourceLocation()==null)? (getSourceLocation()==null): o.getSourceLocation().equals(getSourceLocation())):true); // pr134471 - remove when handles are improved to be independent of location
+               && (AsmManager.getDefault().getHandleProvider().dependsOnLocation()
+            		   ?((o.getSourceLocation()==null)? (getSourceLocation()==null): o.getSourceLocation().equals(getSourceLocation())):true); // pr134471 - remove when handles are improved to be independent of location
 
     }
 
@@ -21,6 +21,10 @@ public class NameConvertor {
 	private static final char LONG		= 'J';
 	private static final char SHORT		= 'S';
 	private static final char ARRAY		= '[';
+	private static final char RESOLVED = 'L';
+	private static final char UNRESOLVED = 'Q';
+	
+	public static final char PARAMETERIZED = 'P';
 
 	private static final char[] BOOLEAN_NAME = new char[]{'b','o','o','l','e','a','n'};
 	private static final char[] BYTE_NAME = new char[]{'b','y','t','e'};
@@ -35,6 +39,8 @@ public class NameConvertor {
 	private static final char[] GREATER_THAN = new char[]{'>'};
 	private static final char[] LESS_THAN = new char[]{'<'};
 	private static final char[] COMMA = new char[]{','};
+	private static final char[] BACKSLASH_LESSTHAN = new char[]{'\\','<'};
+	private static final char[] SEMICOLON = new char[]{';'};
 
 
 	/**
@@ -135,5 +141,73 @@ public class NameConvertor {
 		}
 	}
 
+	/**
+	 * Given 'Ppkg/MyGenericClass<Ljava/lang/String;Ljava/lang/Integer;>;'
+	 * will return 'QMyGenericClass<QString;QInteger;>;'
+	 */
+	public static char[] createShortName(char[] c) {
+		int lt = CharOperation.indexOf('<',c);
+		int sc = CharOperation.indexOf(';',c);
+		int gt = CharOperation.indexOf('>',c);
+		
+		int smallest = 0;
+		if (lt == -1 && sc == -1 && gt == -1) {
+			// we have something like 'Ljava/lang/String' or 'I'
+			return getTypeName(c);
+		} else if (lt != -1 && (sc == -1 || lt <= sc) && (gt == -1 || lt <= gt)) {
+			// we have something like 'Ljava/lang/String<I'
+			smallest = lt;
+		} else if (sc != -1 && (lt == -1 || sc <= lt) && (gt == -1 || sc <= gt)) {
+			// we have something like 'Ljava/lang/String;I'
+			smallest = sc;
+		} else {
+			// we have something like '>;'
+			smallest = gt;
+		}
+		char[] first = CharOperation.subarray(c,0,smallest);
+		char[] second = CharOperation.subarray(c,smallest+1,c.length);
+		if (smallest == 0 && first.length == 0 && c[0] == '>') {
+			// c = {'>',';'} therefore we just want to return c to
+			// close the generic signature
+			return c;
+		} else if (first.length == 1 && second.length == 0) {
+			return first;
+		} else if (second.length == 0 || (second.length == 1 && second[0] == ';')){
+			// we've reached the end of the array, therefore only care about
+			// the first part
+			return createShortName(first);
+		} else if (smallest == lt) {
+			// if c = 'Ljava/lang/String;<I' then first = 'Ljava/Lang/String;' and
+			// second = 'I'. Want to end up with 'LString<I' and so add
+			// the '<' back.
+			char[] inclLT = CharOperation.concat(createShortName(first),BACKSLASH_LESSTHAN);
+			return CharOperation.concat(inclLT,createShortName(second));
+		} else if (smallest == gt) {
+			char[] inclLT = CharOperation.concat(createShortName(first),GREATER_THAN);
+			return CharOperation.concat(inclLT,createShortName(second));			
+		} else {
+			// if c = 'Ljava/lang/Sting;LMyClass;' then first = 'Ljava/lang/String'
+			// and second = 'LMyClass;'. Want to end up with 'QString;QMyClass;
+			// so add the ';' back
+			char[] firstTypeParam = CharOperation.concat(createShortName(first),SEMICOLON);
+			return CharOperation.concat(firstTypeParam,createShortName(second));
+		}
+	}
 
+	/**
+	 * Given 'Qjava/lang/String;' returns 'QString;'
+	 */
+	public static char[] getTypeName(char[] name) {
+		int i = CharOperation.lastIndexOf('/',name);
+		if (i != -1) {
+			if (name[0] == RESOLVED || name[0] == PARAMETERIZED) {
+				return CharOperation.concat(new char[]{UNRESOLVED},
+						CharOperation.subarray(name,i+1,name.length));
+			} else {
+				return CharOperation.concat(new char[]{name[0]},
+						CharOperation.subarray(name,i+1,name.length));
+			}
+		}
+		return name;
+	}
 }
@@ -88,4 +88,14 @@ public class FullPathHandleProvider implements IElementHandleProvider {
 		ipe.setHandleIdentifier(handle);
 		return handle;
 	}
+
+	public boolean dependsOnLocation() {
+		// handles contain information from the source location therefore 
+		// return true;
+		return true;
+	}
+
+	public void initialize() {
+		// nothing to initialize...
+	}
 }
@@ -112,4 +112,14 @@ public class OptimizedFullPathHandleProvider implements IElementHandleProvider {
 		ipe.setHandleIdentifier(handle);
 		return handle;
 	}
+
+	public boolean dependsOnLocation() {
+		// handles contain information from the source location therefore 
+		// return true;
+		return true;
+	}
+
+	public void initialize() {
+		// nothing to initialize
+	}
 }
@@ -0,0 +1,211 @@
+<!DOCTYPE suite SYSTEM "../tests/ajcTestSuite.dtd"[]>
+
+<!-- AspectJ v1.5.2 Tests -->
+<suite>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="More than one named pointcut">
+      <compile files="HandleProvider.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="aspect handle">
+      <compile files="A1.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="advice handle">
+      <compile files="A2.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="pointcut handle">
+      <compile files="A4.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="get IProgramElement with aspect handle">
+      <compile files="A1.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="advice handle with crosscutting">
+      <compile files="A3.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="two pieces of advice with the same signature and pointcut">
+      <compile files="A5.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="pointcut handle with args">
+      <compile files="A6.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="declare parents handle">
+      <compile files="A7.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="two declare parents in same file">
+      <compile files="A7.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="advice handle with args">
+      <compile files="A8.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="field itd handle">
+      <compile files="A9.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method itd handle">
+      <compile files="A9.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method itd with args handle">
+      <compile files="A9.aj" options="-emacssym"/>
+    </ajc-test>
+
+   <ajc-test dir="features153/jdtlikehandleprovider" title="constructor itd with args">
+      <compile files="A13.aj" options="-emacssym">
+        <message kind="warning" text="inter-type constructor"/>
+      </compile>   
+   </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method call handle">
+      <compile files="A10.aj" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="declare warning handle">
+      <compile files="A11.aj" options="-emacssym">
+        <message kind="warning" text="blah"/>
+        <message kind="warning" text="Illegal call"/>
+      </compile>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="two declare warning handles">
+      <compile files="A11.aj" options="-emacssym">
+        <message kind="warning" text="blah"/>
+        <message kind="warning" text="Illegal call"/>
+      </compile>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="ten declare warning handles">
+      <compile files="DeclareWarnings.aj" options="-emacssym">
+        <message kind="warning" text="warning 1"/>
+        <message kind="warning" text="warning 2"/>
+        <message kind="warning" text="warning 3"/>
+        <message kind="warning" text="warning 4"/>
+        <message kind="warning" text="warning 5"/>
+        <message kind="warning" text="warning 6"/>
+        <message kind="warning" text="warning 7"/>
+        <message kind="warning" text="warning 8"/>
+        <message kind="warning" text="warning 9"/>
+        <message kind="warning" text="warning 10"/>
+      </compile>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="declare @type">
+      <compile files="A12.aj" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="declare @field">
+      <compile files="A12.aj" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="declare @method">
+      <compile files="A12.aj" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="declare @constructor">
+      <compile files="A12.aj" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <!-- tests to ensure handle provider produces same as the jdt -->
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="compilation unit same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="class same as jdt">
+      <compile files="C.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="interface same as jdt">
+      <compile files="C.java" options="-emacssym"/>
+    </ajc-test>
+
+   <ajc-test dir="features153/jdtlikehandleprovider" title="constructor same as jdt">
+      <compile files="C.java" options="-emacssym"/>
+    </ajc-test>
+
+   <ajc-test dir="features153/jdtlikehandleprovider" title="constructor with args same as jdt">
+      <compile files="C.java" options="-emacssym"/>
+    </ajc-test>
+
+<!--    <ajc-test dir="features153/jdtlikehandleprovider" title="package declaration same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+-->
+    <ajc-test dir="features153/jdtlikehandleprovider" title="import declaration same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="type same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="field same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="initialization same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with string array as argument same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with int array as argument same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with no args same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with two args same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with two string args same as jdt">
+      <compile files="Demo.java" options="-emacssym"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="enum same as jdt">
+      <compile files="E.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="enum value same as jdt">
+      <compile files="E.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="annotation same as jdt">
+      <compile files="MyAnnotation.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with list arg same as jdt">
+      <compile files="Java5Class.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with generic arg same as jdt">
+      <compile files="Java5Class.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with two generic args same as jdt">
+      <compile files="Java5Class.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with two type parameters same as jdt">
+      <compile files="Java5Class.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="features153/jdtlikehandleprovider" title="method with two args one of which is generic same as jdt">
+      <compile files="Java5Class.java" options="-emacssym -1.5"/>
+    </ajc-test>
+
+</suite>
@@ -0,0 +1,125 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.asm.internal;
+
+import org.aspectj.asm.IProgramElement;
+
+/**
+ * Uses "typesafe enum" pattern.
+ */
+public class HandleProviderDelimiter {
+
+	// taken from JavaElement
+	public static final HandleProviderDelimiter JAVAPROJECT = new HandleProviderDelimiter('=');
+	public static final HandleProviderDelimiter PACKAGEFRAGMENT = new HandleProviderDelimiter('<');
+	public static final HandleProviderDelimiter FIELD = new HandleProviderDelimiter('^');
+	public static final HandleProviderDelimiter METHOD = new HandleProviderDelimiter('~');
+	public static final HandleProviderDelimiter INITIALIZER = new HandleProviderDelimiter('|');
+	public static final HandleProviderDelimiter COMPILATIONUNIT = new HandleProviderDelimiter('{');
+	public static final HandleProviderDelimiter CLASSFILE = new HandleProviderDelimiter('(');
+	public static final HandleProviderDelimiter TYPE = new HandleProviderDelimiter('[');
+	public static final HandleProviderDelimiter IMPORTDECLARATION = new HandleProviderDelimiter('#');
+	public static final HandleProviderDelimiter COUNT = new HandleProviderDelimiter('!');
+	public static final HandleProviderDelimiter ESCAPE = new HandleProviderDelimiter('\\');
+	// these below are not currently used because no iprogramelement.kind equivalent
+	public static final HandleProviderDelimiter PACKAGEFRAGMENTROOT = new HandleProviderDelimiter('/');
+	public static final HandleProviderDelimiter PACKAGEDECLARATION = new HandleProviderDelimiter('%');
+	public static final HandleProviderDelimiter LOCALVARIABLE = new HandleProviderDelimiter('@');
+	public static final HandleProviderDelimiter TYPE_PARAMETER = new HandleProviderDelimiter(']');
+	
+	
+	// AspectJ specific ones
+	public static final HandleProviderDelimiter ASPECT_CU = new HandleProviderDelimiter('*');
+	public static final HandleProviderDelimiter ADVICE = new HandleProviderDelimiter('&');
+	public static final HandleProviderDelimiter ASPECT_TYPE = new HandleProviderDelimiter('}');
+	public static final HandleProviderDelimiter CODEELEMENT = new HandleProviderDelimiter('?');
+	public static final HandleProviderDelimiter ITD = new HandleProviderDelimiter(')');
+	public static final HandleProviderDelimiter DECLARE = new HandleProviderDelimiter('`');
+	public static final HandleProviderDelimiter POINTCUT = new HandleProviderDelimiter('+');
+	
+
+	private static char empty = ' ';
+	private final char delim;
+	
+	private HandleProviderDelimiter(char delim) {
+		this.delim = delim;
+	}
+
+	/**
+	 * Returns the delimiter for the HandleProviderDelimiter, 
+	 * for example ASPECT returns '*' and METHOD returns '~'
+	 */
+	public char getDelimiter() {
+		return delim;
+	}
+	
+	/**
+	 * Returns the delimiter for the given IProgramElement for example
+	 * if the IProgramElement is an aspect returns '*' and if the
+	 * IProgramElement is a method returns '~'
+	 */
+	public static char getDelimiter(IProgramElement ipe) {
+		IProgramElement.Kind kind = ipe.getKind();
+		if (kind.equals(IProgramElement.Kind.PROJECT)) {
+			return JAVAPROJECT.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.PACKAGE)) {
+			return PACKAGEFRAGMENT.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.FILE_JAVA)) {
+			if (ipe.getName().endsWith(".aj")) {
+				return ASPECT_CU.getDelimiter();
+			} else {
+				return COMPILATIONUNIT.getDelimiter();				
+			}
+		} else if (kind.equals(IProgramElement.Kind.FILE_ASPECTJ)) {
+			return ASPECT_CU.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.IMPORT_REFERENCE)) {
+			return IMPORTDECLARATION.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.CLASS) 
+				|| kind.equals(IProgramElement.Kind.INTERFACE)
+				|| kind.equals(IProgramElement.Kind.ENUM)
+				|| kind.equals(IProgramElement.Kind.ANNOTATION)) {
+			return TYPE.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.ASPECT)) {
+			return ASPECT_TYPE.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.INITIALIZER)) {
+			return INITIALIZER.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.INTER_TYPE_FIELD)
+				|| kind.equals(IProgramElement.Kind.INTER_TYPE_METHOD)
+				|| kind.equals(IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR)
+				|| kind.equals(IProgramElement.Kind.INTER_TYPE_PARENT)) {
+			return ITD.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.CONSTRUCTOR)
+				|| kind.equals(IProgramElement.Kind.METHOD)) {
+			return METHOD.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.FIELD)
+				|| kind.equals(IProgramElement.Kind.ENUM_VALUE)) {
+			return FIELD.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.POINTCUT)) {
+			return POINTCUT.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.ADVICE)) {
+			return ADVICE.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.DECLARE_PARENTS)
+				|| kind.equals(IProgramElement.Kind.DECLARE_WARNING)
+				|| kind.equals(IProgramElement.Kind.DECLARE_ERROR)
+				|| kind.equals(IProgramElement.Kind.DECLARE_SOFT)
+				|| kind.equals(IProgramElement.Kind.DECLARE_PRECEDENCE)
+				|| kind.equals(IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR)
+				|| kind.equals(IProgramElement.Kind.DECLARE_ANNOTATION_AT_FIELD)
+				|| kind.equals(IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD)
+				|| kind.equals(IProgramElement.Kind.DECLARE_ANNOTATION_AT_TYPE)) {
+			return DECLARE.getDelimiter();
+		} else if (kind.equals(IProgramElement.Kind.CODE)) {
+			return CODEELEMENT.getDelimiter();
+		} 
+		return empty;
+	}
+	
+}
@@ -48,6 +48,16 @@ public class CharOperation {
 	/**
 	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
 	 */	
+	public static final boolean contains(char character, char[] array) {
+		for (int i = array.length; --i >= 0;)
+			if (array[i] == character)
+				return true;
+		return false;
+	}
+
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
 	public static final int indexOf(char toBeFound, char[] array) {
 		for (int i = 0; i < array.length; i++)
 			if (toBeFound == array[i])
@@ -0,0 +1,23 @@
+package pkg;
+
+aspect A {
+	
+	before() : execution(* *.*(..)) {
+	}
+	
+	after() : callPCD(){
+	}
+	after() : execPCD(){
+	}
+	pointcut callPCD(): call(* *.*(..));
+	pointcut execPCD(): execution(* *.*(..));
+}
+
+class C {
+	
+	public void m() {
+	}
+	
+    static { 	
+    }
+}
@@ -0,0 +1,23 @@
+package pkg;
+
+aspect A {
+	
+	
+	before() : execution(* *.*(..)) {
+	}
+	after() : callPCD(){
+	}
+	after() : execPCD(){
+	}
+	pointcut callPCD(): call(* *.*(..));
+	pointcut execPCD(): execution(* *.*(..));
+}
+
+class C {
+	
+	public void m() {
+	}
+	
+    static { 	
+    }
+}
@@ -0,0 +1,23 @@
+package pkg;
+
+aspect A {
+	
+	before() : execution(* *.*(..)) {
+	}
+	
+	after() : execPCD(){
+	}
+	after() : callPCD(){
+	}
+	pointcut callPCD(): call(* *.*(..));
+	pointcut execPCD(): execution(* *.*(..));
+}
+
+class C {
+	
+	public void m() {
+	}
+	
+    static { 	
+    }	
+}
@@ -0,0 +1,5 @@
+package pkg;
+
+aspect A1 {
+
+}
@@ -0,0 +1,22 @@
+package pkg;
+
+public aspect A10 {
+
+	pointcut p() : call(public void C.m2());
+	
+	before() : p() {
+		
+	}
+	
+}
+
+class C {
+
+	public void m1() {
+		new C().m2();
+	}
+	
+	public void m2() {
+		
+	}
+}
@@ -0,0 +1,18 @@
+package pkg;
+
+public aspect A11 {
+	
+	declare warning: call(* C.setX(..)): "Illegal call.";
+    declare warning : execution(* C.setX(..)) : "blah";
+}
+
+class C {
+	
+	public void setX() {
+	}
+	
+	public void method() {
+		new C().setX();
+	}
+	
+}
@@ -0,0 +1,24 @@
+package pkg;
+
+aspect A {
+
+	declare @type : C : @MyAnnotation;
+	declare @field : int C.someField : @MyAnnotation;
+	declare @method : public void C.method1() : @MyAnnotation;
+	declare @constructor : C.new() : @MyAnnotation;
+	
+}
+
+class C {
+	
+	public C() {
+	}
+	
+	int someField = 3;
+	
+	public void method1() {
+	}
+	
+}
+
+@interface MyAnnotation{}
@@ -0,0 +1,12 @@
+package pkg;
+
+aspect A13 {
+
+	public C.new(int i,String s) {
+	}
+	
+}
+
+class C {
+	
+}
@@ -0,0 +1,8 @@
+package pkg;
+
+aspect A2 {
+	
+	before() : execution(* *.*(..)) {
+	}
+	
+}
@@ -0,0 +1,15 @@
+package pkg;
+
+aspect A3 {
+	
+	before() : execution(* *.*(..)) {
+	}
+	
+}
+
+class C {
+	
+	public void method1() {
+	}
+	
+}
@@ -0,0 +1,7 @@
+package pkg;
+
+aspect A4 {
+	
+	pointcut p() : execution(* *.*(..));
+	
+}
@@ -0,0 +1,12 @@
+package pkg;
+
+aspect A5 {
+	
+	pointcut p() : execution(* *.*(..));
+	
+	before() : p() {
+	}
+	
+	before() : p() {
+	}
+}
@@ -0,0 +1,5 @@
+aspect A6 {
+	
+	pointcut p(Integer value) : set(Integer memory) && args(value); 
+	
+}
@@ -0,0 +1,21 @@
+package pkg;
+
+public aspect A7 {
+	
+	declare parents : C1 implements C2;
+	
+	declare parents : C4 extends C5;
+	
+}
+
+class C1 {
+}
+
+interface C2 {
+}
+
+class C4 {
+}
+
+class C5 {
+}
@@ -0,0 +1,10 @@
+package pkg;
+
+public aspect A8 {
+	
+	pointcut p(Integer value) : set(Integer memory) && args(value); 
+	
+	after(Integer value) returning : p(value) {	
+	}
+	
+}
@@ -0,0 +1,16 @@
+package pkg;
+
+public aspect A9 {
+	
+	public int C.x = 5;
+	
+	private void C.method() {
+	}
+	
+	public String C.methodWithArgs(int i) {
+		return "";
+	}
+}
+
+class C {
+}
@@ -0,0 +1,15 @@
+package pkg;
+
+public class C {
+	
+	public C() {
+	}
+	
+	public C(String s) {
+		
+	}
+}
+
+interface MyInterface {
+	
+}
@@ -0,0 +1,21 @@
+aspect DeclareWarnings {
+	
+	pointcut p() : execution(* C.amethod());
+	
+	declare warning : p() : "warning 1";
+	declare warning : p() : "warning 2";
+	declare warning : p() : "warning 3";
+	declare warning : p() : "warning 4";
+	declare warning : p() : "warning 5";
+	declare warning : p() : "warning 6";
+	declare warning : p() : "warning 7";
+	declare warning : p() : "warning 8";
+	declare warning : p() : "warning 9";
+	declare warning : p() : "warning 10";
+	
+}
+
+class C {
+	
+	public void amethod() {}
+}
@@ -0,0 +1,33 @@
+package tjp;
+
+import java.io.*;
+
+public class Demo {
+    static Demo d;
+
+    static { 	
+    }
+    
+    {
+    }
+    
+    public static void main(String[] args){
+    }
+
+    public void m(int[] args) {
+    }
+    
+    void go(){
+    	int i = 4;
+    }
+
+    void foo(int i, Object o){
+    }
+
+    String bar (Integer j){
+    	return "";
+    }
+    
+    public void m2(String s1, String s2) {
+    }
+}
@@ -0,0 +1,5 @@
+package pkg;
+
+public enum E {
+	A,B;
+}
@@ -0,0 +1,21 @@
+aspect TwoNamedPointcuts {
+	
+	pointcut p1() : execution(* C.method1());
+	
+	pointcut p2() : execution(* C.method2());
+	
+	before() : p1() || p2() {
+		System.out.println("before...");
+	}
+	
+}
+
+class C {
+	
+	public void method1() {
+	}
+	
+	public void method2() {
+	}
+	
+}
@@ -0,0 +1,24 @@
+package pkg;
+
+import java.util.List;
+
+public class Java5Class {
+
+	public void method2(List l) {
+	}
+	
+	public void genericMethod1(List<String> s) {
+	}
+	
+	public void genericMethod2(List<String> s, MyGenericClass<Integer> m) {
+	}
+	
+	public void genericMethod3(int i, List<String> s) {
+	}
+	
+	public void genericMethod4(MyGenericClass2<String,Integer> m) {}
+}
+
+class MyGenericClass<T> {}
+
+class MyGenericClass2<X,Y> {}
@@ -0,0 +1,4 @@
+package pkg;
+
+public @interface MyAnnotation {
+}
@@ -38,6 +38,11 @@ public interface IElementHandleProvider {
     public String createHandleIdentifier(File sourceFile, int line,int column,int offset);
 
     /**
+     * @return  a String uniquely identifying this element
+     */
+	public String createHandleIdentifier(IProgramElement ipe);
+    
+    /**
      * NOTE: this is necessary for the current implementation to look up nodes, 
      * but we may want to consider removing it.
      * 
@@ -127,9 +127,11 @@ public interface IProgramElement extends Serializable {
 	 * The format of the string handle is not specified, but is stable across 
 	 * compilation sessions.
 	 * 
-	 * @return	a string representtaion of this element
+	 * @return	a string representation of this element
 	 */
 	public String getHandleIdentifier();
+	public String getHandleIdentifier(boolean create);
+	public void setHandleIdentifier(String handle);
 
 	/**
 	 * @return	a string representation of this node and all of its children (recursive)
@@ -37,16 +37,7 @@ public class AspectJElementHierarchy implements IHierarchy {
 	public IProgramElement getElement(String handle) {
 		IProgramElement cachedEntry = (IProgramElement)handleMap.get(handle);
 		if (cachedEntry!=null) return cachedEntry;
-		
-//		StringTokenizer st = new StringTokenizer(handle, ProgramElement.ID_DELIM);
-//        int line = new Integer(st.nextToken()).intValue();
-        // int col = new Integer(st.nextToken()).intValue(); TODO: use column number when available
-        String file = AsmManager.getDefault().getHandleProvider().getFileForHandle(handle); // st.nextToken();
-        int line = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(handle); // st.nextToken();
-        int offSet = AsmManager.getDefault().getHandleProvider().getOffSetForHandle(handle); 
-        
-        String canonicalSFP = AsmManager.getDefault().getCanonicalFilePath(new File(file));
-		IProgramElement ret = findNodeForSourceLineHelper(root,canonicalSFP, line, offSet);
+		IProgramElement ret = findElementForHandle(handle);
 		if (ret!=null) {
 			cache(handle,ret);
 		}
@@ -68,7 +59,10 @@ public class AspectJElementHierarchy implements IHierarchy {
 	}
 
 	public boolean removeFromFileMap(Object key) {
-		return (fileMap.remove(key)!=null);
+		if (fileMap.containsKey(key)) {
+			return (fileMap.remove(key)!=null);
+		}
+		return true;	
 	}
 
 	public void setFileMap(HashMap fileMap) {
@@ -344,30 +338,26 @@ public class AspectJElementHierarchy implements IHierarchy {
 		IProgramElement ret = (IProgramElement) handleMap.get(handle);
 		if (ret != null) return ret;
 
-//		StringTokenizer st = new StringTokenizer(handle, ProgramElement.ID_DELIM);
-//		String file = st.nextToken();
-//		int line = new Integer(st.nextToken()).intValue();
-//		int col = new Integer(st.nextToken()).intValue();
-		// TODO: use column number when available
-        String file = AsmManager.getDefault().getHandleProvider().getFileForHandle(handle); // st.nextToken();
-        int line = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(handle); // st.nextToken();
-        int offSet = AsmManager.getDefault().getHandleProvider().getOffSetForHandle(handle);
-        
-		ret = findElementForOffSet(file, line, offSet);
-		if (ret != null) { 
+		ret = findElementForHandle(root,handle);
+		if (ret != null) {
 			cache(handle,(ProgramElement)ret);
 		}
 		return ret;
-		
-//		IProgramElement parent = findElementForType(packageName, typeName);
-//		if (parent == null) return null;
-//		if (kind == IProgramElement.Kind.CLASS ||
-//			kind == IProgramElement.Kind.ASPECT) {
-//				return parent;
-//		} else {
-//			return findElementForSignature(parent, kind, name);	
-//		}	
 	}
+	
+	private IProgramElement findElementForHandle(IProgramElement parent, String handle) {
+		for (Iterator it = parent.getChildren().iterator(); it.hasNext(); ) {
+			IProgramElement node = (IProgramElement)it.next();
+			if (handle.equals(node.getHandleIdentifier())) {
+				return node;
+			} else {
+				IProgramElement childSearch = findElementForHandle(node,handle);
+				if (childSearch != null) return childSearch;
+			}
+		}
+		return null;
+	}
+	
 //	
 //	private IProgramElement findElementForBytecodeInfo(
 //		IProgramElement node, 
@@ -17,9 +17,12 @@ import java.util.StringTokenizer;
 
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IElementHandleProvider;
+import org.aspectj.asm.IProgramElement;
 import org.aspectj.bridge.ISourceLocation;
 
 /**
+ * HandleProvider of the form '<full path to src file>|line|column|offset'
+ * 
  * @author Mik Kersten
  */
 public class FullPathHandleProvider implements IElementHandleProvider {
@@ -70,4 +73,18 @@ public class FullPathHandleProvider implements IElementHandleProvider {
         st.nextToken(); // skip over the column
         return new Integer(st.nextToken()).intValue();
 	}
+
+	public String createHandleIdentifier(IProgramElement ipe) {
+		if (ipe.getHandleIdentifier(false) != null) {
+			return ipe.getHandleIdentifier(false);
+		}
+		String handle = null;  
+		if (ipe.getSourceLocation() != null) {
+			handle = createHandleIdentifier(ipe.getSourceLocation());
+		} else {
+			handle = createHandleIdentifier(ISourceLocation.NO_FILE,-1,-1,-1);
+		}
+		ipe.setHandleIdentifier(handle);
+		return handle;
+	}
 }
@@ -21,10 +21,11 @@ import java.util.StringTokenizer;
 
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IElementHandleProvider;
+import org.aspectj.asm.IProgramElement;
 import org.aspectj.bridge.ISourceLocation;
 
 /**
- * Not currently used - uses int keys rather than the full file path as the first part of the handle.
+ * Uses int keys rather than the full file path as the first part of the handle.
  */
 public class OptimizedFullPathHandleProvider implements IElementHandleProvider {
 
@@ -96,4 +97,18 @@ public class OptimizedFullPathHandleProvider implements IElementHandleProvider {
         st.nextToken(); // skip over the column
         return new Integer(st.nextToken()).intValue();
 	}
+
+	public String createHandleIdentifier(IProgramElement ipe) {
+		if (ipe.getHandleIdentifier(false) != null) {
+			return ipe.getHandleIdentifier(false);
+		}
+		String handle = null;  
+		if (ipe.getSourceLocation() != null) {
+			handle = createHandleIdentifier(ipe.getSourceLocation());
+		} else {
+			handle = createHandleIdentifier(ISourceLocation.NO_FILE,-1,-1,-1);
+		}
+		ipe.setHandleIdentifier(handle);
+		return handle;
+	}
 }
@@ -493,19 +493,25 @@ public class ProgramElement implements IProgramElement {
 	}
 
 	public String getHandleIdentifier() {
-	    if (null == handle) {
-			if (sourceLocation != null) {
-                handle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation);
-//			    return genHandleIdentifier(sourceLocation);
-			} 
-	    }
-	    return handle;
+		return getHandleIdentifier(true);
+	}
+	
+	public String getHandleIdentifier(boolean create) {
+		if (null == handle && create) {
+            handle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(this);			
+		}
+		return handle;
+	}
+	
+	public void setHandleIdentifier(String handle) {
+		this.handle = handle;
 	}
 
 	public List getParameterNames() { 
 		List parameterNames = (List)kvpairs.get("parameterNames");
 		return parameterNames; 
 	}
+	
 	public void setParameterNames(List list) { 
 		if (list==null || list.size()==0) return;
 		if (kvpairs==Collections.EMPTY_MAP) kvpairs = new HashMap();
@@ -15,6 +15,7 @@ package org.aspectj.ajdt.internal.compiler.lookup;
 //import java.io.IOException;
 
 import org.aspectj.asm.AsmManager;
+import org.aspectj.asm.IProgramElement;
 import org.aspectj.asm.IRelationship;
 import org.aspectj.asm.IRelationshipMap;
 import org.aspectj.weaver.ResolvedType;
@@ -48,17 +49,15 @@ public class AsmInterTypeRelationshipProvider {
 
 		if (munger.getSourceLocation() != null
 			&& munger.getSourceLocation() != null) {
-			String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-				munger.getSourceLocation().getSourceFile(),
-				munger.getSourceLocation().getLine(),
-				munger.getSourceLocation().getColumn(),
-				munger.getSourceLocation().getOffset());
-				
-			String targetHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-				onType.getSourceLocation().getSourceFile(),
-				onType.getSourceLocation().getLine(),
-				onType.getSourceLocation().getColumn(),
-				onType.getSourceLocation().getOffset());
+			IProgramElement sourceIPE = AsmManager.getDefault().getHierarchy()
+				.findElementForSourceLine(munger.getSourceLocation());
+			String sourceHandle = AsmManager.getDefault().getHandleProvider()
+				.createHandleIdentifier(sourceIPE);
+			
+			IProgramElement targetIPE = AsmManager.getDefault().getHierarchy()
+				.findElementForSourceLine(onType.getSourceLocation());
+			String targetHandle = AsmManager.getDefault().getHandleProvider()
+				.createHandleIdentifier(targetIPE);
 
 			IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
 			if (sourceHandle != null && targetHandle != null) {
@@ -430,10 +430,18 @@ public class AsmHierarchyBuilder extends ASTVisitor {
             ReferencePointcut rp = (ReferencePointcut) it.next();
             ResolvedMember member = getPointcutDeclaration(rp, declaration);
             if (member != null) {
-                IRelationship foreward = AsmManager.getDefault().getRelationshipMap().get(peNode.getHandleIdentifier(), IRelationship.Kind.USES_POINTCUT, "uses pointcut", false, true);
-                foreward.addTarget(AsmManager.getDefault().getHandleProvider().createHandleIdentifier(member.getSourceLocation()));            
+                IRelationship foreward = AsmManager.getDefault().getRelationshipMap()
+                		.get(peNode.getHandleIdentifier(), 
+                				IRelationship.Kind.USES_POINTCUT, "uses pointcut", false, true);
+                IProgramElement forwardIPE = AsmManager.getDefault().getHierarchy()
+                		.findElementForSourceLine(member.getSourceLocation());
+                foreward.addTarget(AsmManager.getDefault().getHandleProvider()
+                		.createHandleIdentifier(forwardIPE));            
 
-                IRelationship back = AsmManager.getDefault().getRelationshipMap().get(AsmManager.getDefault().getHandleProvider().createHandleIdentifier(member.getSourceLocation()), IRelationship.Kind.USES_POINTCUT, "pointcut used by", false, true);
+                IRelationship back = AsmManager.getDefault().getRelationshipMap()
+                		.get(AsmManager.getDefault().getHandleProvider()
+                				.createHandleIdentifier(forwardIPE), 
+                				IRelationship.Kind.USES_POINTCUT, "pointcut used by", false, true);
                 back.addTarget(peNode.getHandleIdentifier());             
             } 
         }        
@@ -26,6 +26,7 @@ public class AbstractMultiProjectIncrementalAjdeInteractionTestbed extends
 	protected void tearDown() throws Exception {
 		super.tearDown();
 		AjState.FORCE_INCREMENTAL_DURING_TESTING = false;
+		configureBuildStructureModel(false);
 	}
 
 	public void build(String projectName) {
@@ -55,33 +55,25 @@ public class AsmRelationshipProvider {
 
 		// Ensure a node for the target exists
 		IProgramElement targetNode = getNode(AsmManager.getDefault().getHierarchy(), shadow);
-
-		String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-			checker.getSourceLocation().getSourceFile(),
-			checker.getSourceLocation().getLine(),
-			checker.getSourceLocation().getColumn(),
-			checker.getSourceLocation().getOffset());
-
+		IProgramElement sourceNode = AsmManager.getDefault().getHierarchy()
+				.findElementForSourceLine(checker.getSourceLocation());
+		String sourceHandle = AsmManager.getDefault().getHandleProvider()
+				.createHandleIdentifier(sourceNode);
+		String targetHandle = AsmManager.getDefault().getHandleProvider()
+				.createHandleIdentifier(targetNode);
+				
 		if (World.createInjarHierarchy) {
 			checker.createHierarchy();
 		}
 
-		String targetHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-			shadow.getSourceLocation().getSourceFile(),
-			shadow.getSourceLocation().getLine(),
-			shadow.getSourceLocation().getColumn(),
-			shadow.getSourceLocation().getOffset());
-
 		IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
 		if (sourceHandle != null && targetHandle != null) {
 			IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE, MATCHED_BY,false,true);
 			foreward.addTarget(targetHandle);
-//			foreward.getTargets().add(targetHandle);
 
 			IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE, MATCHES_DECLARE,false,true);
 			if (back != null && back.getTargets() != null) {
 				back.addTarget(sourceHandle);
-				//back.getTargets().add(sourceHandle);   
 			}
 		}
 	}
@@ -95,25 +87,21 @@ public class AsmRelationshipProvider {
 	  if (!AsmManager.isCreatingModel()) return;
 		String sourceHandle = "";
 		if (munger.getSourceLocation()!=null && munger.getSourceLocation().getOffset()!=-1) {
-			sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-										munger.getSourceLocation().getSourceFile(),
-										munger.getSourceLocation().getLine(),
-										munger.getSourceLocation().getColumn(),
-										munger.getSourceLocation().getOffset());
+			IProgramElement sourceNode = AsmManager.getDefault().getHierarchy()
+					.findElementForSourceLine(munger.getSourceLocation());
+			sourceHandle = AsmManager.getDefault().getHandleProvider()
+					.createHandleIdentifier(sourceNode);
 		} else {
-			sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-							originatingAspect.getSourceLocation().getSourceFile(),
-							originatingAspect.getSourceLocation().getLine(),
-							originatingAspect.getSourceLocation().getColumn(),
-							originatingAspect.getSourceLocation().getOffset());
+			IProgramElement sourceNode = AsmManager.getDefault().getHierarchy()
+					.findElementForSourceLine(originatingAspect.getSourceLocation());
+			sourceHandle = AsmManager.getDefault().getHandleProvider()
+					.createHandleIdentifier(sourceNode);
 		}
 		if (originatingAspect.getSourceLocation() != null) {
-				
-			String targetHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-				onType.getSourceLocation().getSourceFile(),
-				onType.getSourceLocation().getLine(),
-				onType.getSourceLocation().getColumn(),
-				onType.getSourceLocation().getOffset());
+			IProgramElement targetNode = AsmManager.getDefault().getHierarchy()
+					.findElementForSourceLine(onType.getSourceLocation());
+			String targetHandle = AsmManager.getDefault().getHandleProvider()
+					.createHandleIdentifier(targetNode);
 
 			IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
 			if (sourceHandle != null && targetHandle != null) {
@@ -131,17 +119,15 @@ public class AsmRelationshipProvider {
 	public void addDeclareParentsRelationship(ISourceLocation decp,ResolvedType targetType, List newParents) {
 	    if (!AsmManager.isCreatingModel()) return;
 
-		String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(decp.getSourceFile(),decp.getLine(),decp.getColumn(),decp.getOffset());
-		
-		IProgramElement ipe = AsmManager.getDefault().getHierarchy().findElementForHandle(sourceHandle);
+		IProgramElement sourceNode = AsmManager.getDefault().getHierarchy()
+				.findElementForSourceLine(decp);
+		String sourceHandle = AsmManager.getDefault().getHandleProvider()
+				.createHandleIdentifier(sourceNode);
+		IProgramElement targetNode = AsmManager.getDefault().getHierarchy()
+				.findElementForSourceLine(targetType.getSourceLocation());
+		String targetHandle = AsmManager.getDefault().getHandleProvider()
+				.createHandleIdentifier(targetNode);
 
-	
-		String targetHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-				targetType.getSourceLocation().getSourceFile(),
-				targetType.getSourceLocation().getLine(),
-				targetType.getSourceLocation().getColumn(),
-				targetType.getSourceLocation().getOffset());
-				
 		IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
 		if (sourceHandle != null && targetHandle != null) {
 			IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARES,false,true);
@@ -159,15 +145,16 @@ public class AsmRelationshipProvider {
 	 */
 	public void addDeclareAnnotationRelationship(ISourceLocation declareAnnotationLocation,ISourceLocation annotatedLocation) {
 	    if (!AsmManager.isCreatingModel()) return;
-		String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(declareAnnotationLocation.getSourceFile(),declareAnnotationLocation.getLine(),
-																	declareAnnotationLocation.getColumn(),declareAnnotationLocation.getOffset());
-		IProgramElement declareAnnotationPE = AsmManager.getDefault().getHierarchy().findElementForHandle(sourceHandle);
-		
-		String targetHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-				annotatedLocation.getSourceFile(),
-				annotatedLocation.getLine(),
-				annotatedLocation.getColumn(),
-				annotatedLocation.getOffset());
+	    
+	    IProgramElement sourceNode = AsmManager.getDefault().getHierarchy()
+	    		.findElementForSourceLine(declareAnnotationLocation);
+	    String sourceHandle = AsmManager.getDefault().getHandleProvider()
+	    		.createHandleIdentifier(sourceNode);
+
+	    IProgramElement targetNode = AsmManager.getDefault().getHierarchy()
+				.findElementForSourceLine(annotatedLocation);
+	    String targetHandle = AsmManager.getDefault().getHandleProvider()
+				.createHandleIdentifier(targetNode);
 
 		IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
 		if (sourceHandle != null && targetHandle != null) {
@@ -205,7 +192,9 @@ public class AsmRelationshipProvider {
 			AdviceKind ak = ((Advice)munger).getKind();
 			ai.setExtraAdviceInformation(ak.getName());
 			IProgramElement adviceElement = AsmManager.getDefault().getHierarchy().findElementForHandle(adviceHandle);
-			adviceElement.setExtraInfo(ai);		
+			if (adviceElement != null) {
+				adviceElement.setExtraInfo(ai);	
+			}
 
 			if (adviceHandle != null && targetNode != null) {
 
@@ -392,9 +381,9 @@ public class AsmRelationshipProvider {
 	  if (methodElem == null) return;
 
 	  try {
-	    String sourceHandle = 
-            AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation.getSourceFile(),sourceLocation.getLine(),
-		 	sourceLocation.getColumn(),sourceLocation.getOffset());
+		  
+		  IProgramElement sourceNode = AsmManager.getDefault().getHierarchy().findElementForSourceLine(sourceLocation);
+		  String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceNode);
 
 	    String targetHandle = methodElem.getHandleIdentifier();
 	    IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
@@ -433,9 +422,8 @@ public class AsmRelationshipProvider {
         IProgramElement fieldElem = AsmManager.getDefault().getHierarchy().findElementForSignature(typeElem,IProgramElement.Kind.FIELD,field.getName());
         if (fieldElem== null) return;
 
-		String sourceHandle = 
-            AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation.getSourceFile(),sourceLocation.getLine(),
-		  	sourceLocation.getColumn(),sourceLocation.getOffset());
+		  IProgramElement sourceNode = AsmManager.getDefault().getHierarchy().findElementForSourceLine(sourceLocation);
+		  String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceNode);
 
 		String targetHandle = fieldElem.getHandleIdentifier();
 
@@ -101,11 +101,8 @@ public abstract class ShadowMunger implements PartialOrder.PartialComparable, IH
 				if (World.createInjarHierarchy) {
 					createHierarchy();
 				} 
-				handle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
-				            sl.getSourceFile(),
-				            sl.getLine(),
-				            sl.getColumn(),
-							sl.getOffset());					
+				IProgramElement ipe = AsmManager.getDefault().getHierarchy().findElementForSourceLine(sl);
+				handle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(ipe);
 			}
 		}
 		return handle;
@@ -77,9 +77,8 @@ public class AsmManager {
         handleProvider = new OptimizedFullPathHandleProvider(); 
     }
 
-	public void createNewASM(INameConvertor convertor) {
+	public void createNewASM() {
 		hierarchy = new AspectJElementHierarchy();
-		hierarchy.setNameConvertor(convertor);
 		mapper = new RelationshipMap(hierarchy);
 	}
 
@@ -102,7 +102,4 @@ public interface IHierarchy extends Serializable {
 	public void flushHandleMap();
 
 	public void updateHandleMap(Set deletedFiles);
-	
-	public void setNameConvertor(INameConvertor convertor);
-	public INameConvertor getNameConvertor();
 }
\ No newline at end of file
@@ -1,17 +0,0 @@
-/********************************************************************
- * Copyright (c) 2006 Contributors. All rights reserved. 
- * This program and the accompanying materials are made available 
- * under the terms of the Eclipse Public License v1.0 
- * which accompanies this distribution and is available at 
- * http://eclipse.org/legal/epl-v10.html 
- *  
- * Contributors: IBM Corporation - initial API and implementation 
- * 				 Helen Hawkins   - initial version
- *******************************************************************/
-package org.aspectj.asm;
-
-public interface INameConvertor {
-
-	public char[] convertName(char[] name);
-	
-}
@@ -29,7 +29,6 @@ public class AspectJElementHierarchy implements IHierarchy {
 
 	protected  IProgramElement root = null;
     protected String configFile = null;
-    private transient INameConvertor convertor = null;
 
     private Map fileMap = null;
     private Map handleMap = null;
@@ -450,13 +449,5 @@ public class AspectJElementHierarchy implements IHierarchy {
 		return hid.substring(0,hid.indexOf("|"));
 	}
 
-	public void setNameConvertor(INameConvertor convertor) {
-		this.convertor = convertor;
-	}
-
-	public INameConvertor getNameConvertor() {
-		return convertor;
-	}
-
 }
 
@@ -22,11 +22,11 @@ import java.util.Map;
 
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.HierarchyWalker;
-import org.aspectj.asm.INameConvertor;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.util.CharOperation;
+import org.aspectj.util.NameConvertor;
 
 
 /**
@@ -519,12 +519,7 @@ public class ProgramElement implements IProgramElement {
 		List params = new ArrayList();
 		for (Iterator iter = l.iterator(); iter.hasNext();) {
 			char[] param = (char[])iter.next();
-			INameConvertor convertor = AsmManager.getDefault().getHierarchy().getNameConvertor();
-			if (convertor != null) {
-				params.add(convertor.convertName(param));				
-			} else {
-				params.add(param);
-			}
+			params.add(NameConvertor.convertFromSignature(param));
 		}
 		return params;
 	}
@@ -49,7 +49,6 @@ import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter;
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IHierarchy;
-import org.aspectj.asm.INameConvertor;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.asm.internal.ProgramElement;
 import org.aspectj.bridge.AbortException;
@@ -84,8 +83,6 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.problem.DefaultProblemFacto
 import org.aspectj.util.FileUtil;
 import org.aspectj.weaver.Dump;
 import org.aspectj.weaver.ResolvedType;
-import org.aspectj.weaver.TypeFactory;
-import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.bcel.BcelWeaver;
 import org.aspectj.weaver.bcel.BcelWorld;
@@ -634,7 +631,7 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
      	AsmManager.setCreatingModel(config.isEmacsSymMode() || config.isGenerateModelMode());
      	if (!AsmManager.isCreatingModel()) return;
 
-		AsmManager.getDefault().createNewASM(new NameConverter());
+		AsmManager.getDefault().createNewASM();
 		// AsmManager.getDefault().getRelationshipMap().clear();
 		IHierarchy model = AsmManager.getDefault().getHierarchy();
         String rootLabel = "<root>";
@@ -1279,15 +1276,5 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 		}
 
 	}
-	
-	private class NameConverter implements INameConvertor {
-
-		public char[] convertName(char[] name) {
-			UnresolvedType ut = TypeFactory.createTypeFromSignature(new String(name));
-			ResolvedType rt = getWorld().resolve(ut);
-			return rt.getName().toCharArray();
-		}
-		
-	}
 }
 
@@ -52,7 +52,7 @@ public class IncrementalStateManager {
 			element.wipeAllKnowledge();
 		}
 		incrementalStates.clear();
-		AsmManager.getDefault().createNewASM(null); // forget what you know...
+		AsmManager.getDefault().createNewASM(); // forget what you know...
 	}
 
 	public static Set getConfigFilesKnown() {
@@ -21,6 +21,7 @@ import org.aspectj.asm.IHierarchy;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.asm.internal.Relationship;
 import org.aspectj.testing.XMLBasedAjcTestCase;
+import org.aspectj.util.CharOperation;
 
 public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
@@ -150,7 +151,7 @@ public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
       assertNotNull("Couldn't find 'twoArgsMethod(int,java.lang.String)' element in the tree",twoArgsMethod);
       List l = twoArgsMethod.getParameterSignatures();
       assertEquals("",((char[])l.get(0))[0],'I');
-      boolean eq = equals(((char[])l.get(1)),"Ljava/lang/String;".toCharArray());
+      boolean eq = CharOperation.equals(((char[])l.get(1)),"Ljava/lang/String;".toCharArray());
       assertTrue("expected parameter to be 'Ljava/lang/String;' but found '" +
         		new String(((char[])l.get(1))) + "'",eq);
   }
@@ -204,23 +205,6 @@ public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
   // ---------------- helper methods ---------------
 
-   /**
-    * taken from CharOperation
-    */
-	private final boolean equals(char[] first, char[] second) {
-		if (first == second)
-			return true;
-		if (first == null || second == null)
-			return false;
-		if (first.length != second.length)
-			return false;
-
-		for (int i = first.length; --i >= 0;)
-			if (first[i] != second[i])
-				return false;
-		return true;
-	}
-  
 	private void checkParametersForIPE(String ipeLabel, IProgramElement.Kind kind, String expectedParm, boolean getHandles) {
 		IHierarchy top = AsmManager.getDefault().getHierarchy();
 		IProgramElement ipe = top.findElementForLabel(top.getRoot(),kind,ipeLabel);
@@ -231,7 +215,7 @@ public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	    } else {
 	    	l = ipe.getParameterTypes();
 	    }
-	    boolean eq = equals(((char[])l.get(0)),expectedParm.toCharArray());
+	    boolean eq = CharOperation.equals(((char[])l.get(0)),expectedParm.toCharArray());
 	    assertTrue("expected parameter to be '" + expectedParm + "' but found '" +
 	      		new String(((char[])l.get(0))) + "'",eq);
 	}
@@ -45,4 +45,62 @@ public class CharOperation {
 		return -1;
 	}
 
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final int indexOf(char toBeFound, char[] array) {
+		for (int i = 0; i < array.length; i++)
+			if (toBeFound == array[i])
+				return i;
+		return -1;
+	}
+	
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final char[] concat(char[] first, char[] second) {
+		if (first == null)
+			return second;
+		if (second == null)
+			return first;
+
+		int length1 = first.length;
+		int length2 = second.length;
+		char[] result = new char[length1 + length2];
+		System.arraycopy(first, 0, result, 0, length1);
+		System.arraycopy(second, 0, result, length1, length2);
+		return result;
+	}
+	
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final boolean equals(char[] first, char[] second) {
+		if (first == second)
+			return true;
+		if (first == null || second == null)
+			return false;
+		if (first.length != second.length)
+			return false;
+
+		for (int i = first.length; --i >= 0;)
+			if (first[i] != second[i])
+				return false;
+		return true;
+	}
+	
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final void replace(
+		char[] array,
+		char toBeReplaced,
+		char replacementChar) {
+		if (toBeReplaced != replacementChar) {
+			for (int i = 0, max = array.length; i < max; i++) {
+				if (array[i] == toBeReplaced)
+					array[i] = replacementChar;
+			}
+		}
+	}
 }
@@ -0,0 +1,139 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.util;
+
+public class NameConvertor {
+
+	private static final char BOOLEAN 	= 'Z';
+	private static final char BYTE 		= 'B';
+	private static final char CHAR 		= 'C';
+	private static final char DOUBLE 	= 'D';
+	private static final char FLOAT 	= 'F';
+	private static final char INT 		= 'I';
+	private static final char LONG		= 'J';
+	private static final char SHORT		= 'S';
+	private static final char ARRAY		= '[';
+	
+	private static final char[] BOOLEAN_NAME = new char[]{'b','o','o','l','e','a','n'};
+	private static final char[] BYTE_NAME = new char[]{'b','y','t','e'};
+	private static final char[] CHAR_NAME = new char[]{'c','h','a','r'};
+	private static final char[] DOUBLE_NAME = new char[]{'d','o','u','b','l','e'};
+	private static final char[] FLOAT_NAME = new char[]{'f','l','o','a','t'};
+	private static final char[] INT_NAME = new char[]{'i','n','t'};
+	private static final char[] LONG_NAME = new char[]{'l','o','n','g'};
+	private static final char[] SHORT_NAME = new char[]{'s','h','o','r','t'};
+
+	private static final char[] SQUARE_BRACKETS = new char[]{'[',']'};
+	private static final char[] GREATER_THAN = new char[]{'>'};
+	private static final char[] LESS_THAN = new char[]{'<'};
+	private static final char[] COMMA = new char[]{','};
+	
+	
+	/**
+	 * Creates a readable name from the given char array, for example, 
+	 * given 'I' returns 'int'. Moreover, given 
+	 * 'Ljava/lang/String;<Ljava/lang/String;>' returns
+	 * 'java.lang.String<java.lang.String>'
+	 */
+	public static char[] convertFromSignature(char[] c) {
+		int lt = CharOperation.indexOf('<',c);
+		int sc = CharOperation.indexOf(';',c);
+		int gt = CharOperation.indexOf('>',c);
+		
+		int smallest = 0;
+		if (lt  == -1 && sc == -1 && gt == -1) {
+			// we have something like 'Ljava/lang/String' or 'I'
+			return getFullyQualifiedTypeName(c);
+		} else if (lt != -1 && (sc == -1 || lt <= sc) && (gt == -1 || lt <= gt)) {
+			// we have something like 'Ljava/lang/String<I'
+			smallest = lt;
+		} else if (sc != -1 && (lt == -1 || sc <= lt) && (gt == -1 || sc <= gt)) {
+			// we have something like 'Ljava/lang/String;I'
+			smallest = sc;
+		} else {
+			// we have something like '>;'
+			smallest = gt;
+		}
+		char[] first = CharOperation.subarray(c,0,smallest);
+		char[] second = CharOperation.subarray(c,smallest+1,c.length);
+		if (smallest == 0 && first.length == 0 && c[0] == '>') {
+			// c = {'>',';'} therefore we just want to return '>' to
+			// close the generic signature
+			return GREATER_THAN;
+		} else if (first.length == 1 && second.length == 0) {
+			return first;
+		} else if (second.length == 0 || (second.length == 1 && second[0] == ';')){
+			// we've reached the end of the array, therefore only care about
+			// the first part
+			return convertFromSignature(first);
+		} else if (smallest == lt) {
+			// if c = 'Ljava/lang/String;<I' then first = 'Ljava/Lang/String;' and
+			// second = 'I'. Want to end up with 'Ljava.lang.String<I' and so add
+			// the '<' back.
+			char[] inclLT = CharOperation.concat(convertFromSignature(first),LESS_THAN);
+			return CharOperation.concat(inclLT,convertFromSignature(second));
+		} else if (smallest == gt) {
+			char[] inclLT = CharOperation.concat(convertFromSignature(first),GREATER_THAN);
+			return CharOperation.concat(inclLT,convertFromSignature(second));			
+		} else if (second.length != 2) {
+			// if c = 'Ljava/lang/Sting;LMyClass' then first = 'Ljava/lang/String'
+			// and second = 'LMyClass'. Want to end up with 'java.lang.String,MyClass
+			// so want to add a ','. However, only want to do this if we're in the 
+			// middle of a '<...>'
+			char[] inclComma = CharOperation.concat(convertFromSignature(first),COMMA);
+			return CharOperation.concat(inclComma,convertFromSignature(second));
+		}
+		return CharOperation.concat(convertFromSignature(first),convertFromSignature(second));
+	}
+	
+	
+	/**
+	 * Given a char array, returns the type name for this. For example
+	 * 'I' returns 'int', 'Ljava/lang/String' returns 'java.lang.String' and
+	 * '[Ljava/lang/String' returns 'java.lang.String[]'
+	 * 
+	 * NOTE: Doesn't go any deaper so given 'Ljava/lang/String;<Ljava/lang/String;>' 
+	 * it would return 'java.lang.String;<Ljava.lang.String;>', however, only called
+	 * with something like 'Ljava/lang/String'
+	 */
+	private static char[] getFullyQualifiedTypeName(char[] c) {
+		if (c.length == 0) {
+			return c;
+		} 
+		if (c[0] == BOOLEAN) {
+			return BOOLEAN_NAME;
+		} else if (c[0] == BYTE) {
+			return BYTE_NAME;
+		} else if (c[0] == CHAR) {
+			return CHAR_NAME;
+		} else if (c[0] == DOUBLE) {
+			return DOUBLE_NAME;
+		} else if (c[0] == FLOAT) {
+			return FLOAT_NAME;
+		} else if (c[0] == INT) {
+			return INT_NAME;
+		} else if (c[0] == LONG) {
+			return LONG_NAME;
+		} else if (c[0] == SHORT) {
+			return SHORT_NAME;
+		} else if (c[0] == ARRAY) {
+			return CharOperation.concat(
+					getFullyQualifiedTypeName(CharOperation.subarray(c,1,c.length)),
+					SQUARE_BRACKETS);
+		} else {
+			char[] type = CharOperation.subarray(c,1,c.length);
+			CharOperation.replace(type,'/','.');
+			return type;
+		}
+	}
+	
+
+}
@@ -0,0 +1,83 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.util;
+
+import junit.framework.TestCase;
+
+public class NameConvertorTest extends TestCase {
+
+	public void testBoolean() {
+		checkConversion("Z","boolean");
+	}
+	
+	public void testByte() {
+		checkConversion("B","byte");
+	}
+	
+	public void testChar() {
+		checkConversion("C","char");
+	}	
+	
+	public void testDouble() {
+		checkConversion("D","double");
+	}	
+	
+	public void testFloat() {
+		checkConversion("F","float");
+	}
+	
+	public void testInt() {
+		checkConversion("I","int");
+	}
+	
+	public void testLong() {
+		checkConversion("J","long");
+	}	
+	
+	public void testShort() {
+		checkConversion("S","short");
+	}	
+	
+	public void testString() {
+		checkConversion("Ljava/lang/String;","java.lang.String");
+	}
+
+	public void testType() {
+		checkConversion("LMyClass;","MyClass");
+	}
+
+	public void testListPameterizedWithString() {
+		checkConversion("Pjava/util/List<Ljava/lang/String;>;",
+				"java.util.List<java.lang.String>");
+	}
+	public void testClassParameterizedWithStringAndType() {
+		checkConversion("PMyGenericClass<Ljava/lang/String;LMyClass;>;",
+				"MyGenericClass<java.lang.String,MyClass>");
+	}
+	public void testStringArray() {
+		checkConversion("[Ljava/lang/String;","java.lang.String[]");
+	}
+	public void testTwoDimensionalStringArray() {
+		checkConversion("[[Ljava/lang/String;","java.lang.String[][]");
+	}
+	public void testIntArray() {
+		checkConversion("[I","int[]");
+	}
+
+	private void checkConversion(String signature, String expected) {
+		char[] c = NameConvertor.convertFromSignature(signature.toCharArray());
+		assertTrue("converting " + signature + ", expected " + expected + "," +
+				"but found " + String.valueOf(c),
+				CharOperation.equals(c,expected.toCharArray()));
+	}
+
+	
+}
@@ -23,6 +23,7 @@ public class UtilTests extends TestCase {
         //$JUnit-BEGIN$
         suite.addTestSuite(FileUtilTest.class); 
         suite.addTestSuite(LangUtilTest.class); 
+        suite.addTestSuite(NameConvertorTest.class);
         //$JUnit-END$
         return suite;
     }
@@ -1,9 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-    <classpathentry kind="src" path="src"/>
-    <classpathentry kind="src" path="testsrc"/>
-    <classpathentry kind="var" path="JRE_LIB" rootpath="JRE_SRCROOT" sourcepath="JRE_SRC"/>
-    <classpathentry kind="src" path="/bridge"/>
-    <classpathentry kind="lib" path="/lib/junit/junit.jar" sourcepath="/lib/junit/junit-src.jar"/>
-    <classpathentry kind="output" path="bin"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="testsrc"/>
+	<classpathentry sourcepath="JRE_SRC" kind="var" path="JRE_LIB"/>
+	<classpathentry kind="src" path="/bridge"/>
+	<classpathentry sourcepath="/lib/junit/junit-src.jar" kind="lib" path="/lib/junit/junit.jar"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/util"/>
+	<classpathentry kind="output" path="bin"/>
 </classpath>
@@ -77,8 +77,9 @@ public class AsmManager {
         handleProvider = new OptimizedFullPathHandleProvider(); 
     }
 
-	public void createNewASM() {
+	public void createNewASM(INameConvertor convertor) {
 		hierarchy = new AspectJElementHierarchy();
+		hierarchy.setNameConvertor(convertor);
 		mapper = new RelationshipMap(hierarchy);
 	}
 
@@ -102,4 +102,7 @@ public interface IHierarchy extends Serializable {
 	public void flushHandleMap();
 
 	public void updateHandleMap(Set deletedFiles);
+	
+	public void setNameConvertor(INameConvertor convertor);
+	public INameConvertor getNameConvertor();
 }
\ No newline at end of file
@@ -0,0 +1,17 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.asm;
+
+public interface INameConvertor {
+
+	public char[] convertName(char[] name);
+	
+}
@@ -116,12 +116,13 @@ public interface IProgramElement extends Serializable {
 	public String toLabelString();
 	public String toLabelString(boolean getFullyQualifiedArgTypes);
 
-	public List getParameterTypes();
-	public void setParameterTypes(List list);
-
 	public List getParameterNames();
 	public void setParameterNames(List list);
 
+	public List getParameterSignatures();
+	public void setParameterSignatures(List list);
+	public List getParameterTypes();
+	
 	/**
 	 * The format of the string handle is not specified, but is stable across 
 	 * compilation sessions.
@@ -29,6 +29,7 @@ public class AspectJElementHierarchy implements IHierarchy {
 
 	protected  IProgramElement root = null;
     protected String configFile = null;
+    private transient INameConvertor convertor = null;
 
     private Map fileMap = null;
     private Map handleMap = null;
@@ -449,5 +450,13 @@ public class AspectJElementHierarchy implements IHierarchy {
 		return hid.substring(0,hid.indexOf("|"));
 	}
 
+	public void setNameConvertor(INameConvertor convertor) {
+		this.convertor = convertor;
+	}
+
+	public INameConvertor getNameConvertor() {
+		return convertor;
+	}
+
 }
 
@@ -22,9 +22,11 @@ import java.util.Map;
 
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.HierarchyWalker;
+import org.aspectj.asm.INameConvertor;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.ISourceLocation;
+import org.aspectj.util.CharOperation;
 
 
 /**
@@ -408,16 +410,22 @@ public class ProgramElement implements IProgramElement {
 		sb.append(name);
 
 		List ptypes = getParameterTypes();
-		if (ptypes != null) {
+		if (ptypes != null && (!ptypes.isEmpty() 
+				|| this.kind.equals(IProgramElement.Kind.METHOD))
+				|| this.kind.equals(IProgramElement.Kind.CONSTRUCTOR)
+				|| this.kind.equals(IProgramElement.Kind.ADVICE)
+				|| this.kind.equals(IProgramElement.Kind.POINTCUT)
+				|| this.kind.equals(IProgramElement.Kind.INTER_TYPE_METHOD)
+				|| this.kind.equals(IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR)) {
 			sb.append('('); 
 			for (Iterator it = ptypes.iterator(); it.hasNext(); ) {
-				String arg = (String)it.next();
+				char[] arg = (char[])it.next();
 				if (getFullyQualifiedArgTypes) {
 					sb.append(arg);
 				} else {
-					int index = arg.lastIndexOf(".");
+					int index = CharOperation.lastIndexOf('.',arg);
 					if (index != -1) {
-						sb.append(arg.substring(index + 1));
+						sb.append(CharOperation.subarray(arg,index+1,arg.length));
 					} else {
 						sb.append(arg);
 					}
@@ -503,17 +511,35 @@ public class ProgramElement implements IProgramElement {
 		//parameterNames = list; 
 	}
 
-	public List getParameterTypes() { 
-		List parameterTypes = (List)kvpairs.get("parameterTypes");
-		return parameterTypes; 
+	public List getParameterTypes() {
+		List l = getParameterSignatures();
+		if (l == null || l.isEmpty()) {
+			return Collections.EMPTY_LIST;
+		}
+		List params = new ArrayList();
+		for (Iterator iter = l.iterator(); iter.hasNext();) {
+			char[] param = (char[])iter.next();
+			INameConvertor convertor = AsmManager.getDefault().getHierarchy().getNameConvertor();
+			if (convertor != null) {
+				params.add(convertor.convertName(param));				
+			} else {
+				params.add(param);
+			}
+		}
+		return params;
 	}
-	public void setParameterTypes(List list) { 
-		if (kvpairs==Collections.EMPTY_MAP) kvpairs = new HashMap();
-		if (list==null || list.size()==0) kvpairs.put("parameterTypes",Collections.EMPTY_LIST);
-		else                               kvpairs.put("parameterTypes",list);
-//		parameterTypes = list; 
+	
+	public List getParameterSignatures() {
+		List parameters = (List)kvpairs.get("parameterSigs");
+		return parameters;
 	}
 
+	public void setParameterSignatures(List list) {
+		if (kvpairs==Collections.EMPTY_MAP) kvpairs = new HashMap();
+		if (list==null || list.size()==0) kvpairs.put("parameterSigs",Collections.EMPTY_LIST);
+		else kvpairs.put("parameterSigs",list);
+	}
+	
 	public String getDetails() {
 		String details = (String)kvpairs.get("details");
 		return details; 
@@ -49,6 +49,7 @@ import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter;
 import org.aspectj.asm.AsmManager;
 import org.aspectj.asm.IHierarchy;
+import org.aspectj.asm.INameConvertor;
 import org.aspectj.asm.IProgramElement;
 import org.aspectj.asm.internal.ProgramElement;
 import org.aspectj.bridge.AbortException;
@@ -83,6 +84,8 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.problem.DefaultProblemFacto
 import org.aspectj.util.FileUtil;
 import org.aspectj.weaver.Dump;
 import org.aspectj.weaver.ResolvedType;
+import org.aspectj.weaver.TypeFactory;
+import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.World;
 import org.aspectj.weaver.bcel.BcelWeaver;
 import org.aspectj.weaver.bcel.BcelWorld;
@@ -631,7 +634,7 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
      	AsmManager.setCreatingModel(config.isEmacsSymMode() || config.isGenerateModelMode());
      	if (!AsmManager.isCreatingModel()) return;
 
-		AsmManager.getDefault().createNewASM();
+		AsmManager.getDefault().createNewASM(new NameConverter());
 		// AsmManager.getDefault().getRelationshipMap().clear();
 		IHierarchy model = AsmManager.getDefault().getHierarchy();
         String rootLabel = "<root>";
@@ -1276,5 +1279,15 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 		}
 
 	}
+	
+	private class NameConverter implements INameConvertor {
+
+		public char[] convertName(char[] name) {
+			UnresolvedType ut = TypeFactory.createTypeFromSignature(new String(name));
+			ResolvedType rt = getWorld().resolve(ut);
+			return rt.getName().toCharArray();
+		}
+		
+	}
 }
 
@@ -25,7 +25,14 @@ import org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration;
 import org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration;
 import org.aspectj.ajdt.internal.compiler.ast.PointcutDeclaration;
 import org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment;
+import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
 import org.aspectj.asm.IProgramElement;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Argument;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.aspectj.weaver.AdviceKind;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
@@ -39,13 +46,6 @@ import org.aspectj.weaver.patterns.OrPointcut;
 import org.aspectj.weaver.patterns.ReferencePointcut;
 import org.aspectj.weaver.patterns.TypePattern;
 import org.aspectj.weaver.patterns.TypePatternList;
-import org.aspectj.org.eclipse.jdt.core.compiler.CharOperation;
-import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
-import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Argument;
-import org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
-import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation;
-import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference;
-import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 
 /**
  * @author Mik Kersten
@@ -296,34 +296,31 @@ public class AsmElementFormatter {
 		Argument[] argArray = md.arguments;
 		if (argArray == null) {
 			pe.setParameterNames(Collections.EMPTY_LIST);
-			pe.setParameterTypes(Collections.EMPTY_LIST);
+			pe.setParameterSignatures(Collections.EMPTY_LIST);
 		} else {
 			List names = new ArrayList();
-			List types = new ArrayList();
-			
+			List paramSigs = new ArrayList();
 			for (int i = 0; i < argArray.length; i++) {
 				String argName = new String(argArray[i].name);
-				String argType = "<UnknownType>"; // pr135052
-				TypeReference typeR = argArray[i].type;
-				if (typeR!=null) {
-					TypeBinding typeB = typeR.resolvedType;
-					if (typeB==null) {
-						if (typeR.getTypeName()!=null) 
-							  argType = CharOperation.toString(typeR.getTypeName());						
-					} else {
-						argType = typeB.debugName();
+				//String argType = "<UnknownType>"; // pr135052
+				if (acceptArgument(argName, argArray[i].type.toString())) {
+					TypeReference typeR = argArray[i].type;
+					if (typeR!=null) {
+						TypeBinding typeB = typeR.resolvedType;
+						if (typeB==null) {
+							typeB = typeR.resolveType(md.scope);
+						}
+						EclipseFactory factory = EclipseFactory.fromScopeLookupEnvironment(md.scope);
+						UnresolvedType ut = factory.fromBinding(typeB);
+						paramSigs.add(ut.getSignature().toCharArray());
 					}
-				}
-				
-				
-//				String argType = argArray[i].type.resolvedType.debugName();
-				if (acceptArgument(argName, argArray[i].type.toString())) { 
 					names.add(argName);
-					types.add(argType);
-				}   
+				}
 			}
 			pe.setParameterNames(names);
-			pe.setParameterTypes(types);
+			if (!paramSigs.isEmpty()) {
+				pe.setParameterSignatures(paramSigs);
+			}
 		}
 	}
 
@@ -52,7 +52,7 @@ public class IncrementalStateManager {
 			element.wipeAllKnowledge();
 		}
 		incrementalStates.clear();
-		AsmManager.getDefault().createNewASM(); // forget what you know...
+		AsmManager.getDefault().createNewASM(null); // forget what you know...
 	}
 
 	public static Set getConfigFilesKnown() {
@@ -0,0 +1,46 @@
+import java.util.List;
+
+aspect A {
+
+	pointcut p() : execution(* *.*(..));
+	
+	before() : p() {}
+	
+	public void MyClass.method() {}
+	
+	public MyClass.new() {super();}
+}
+
+class C {
+	
+	public C() {}
+	
+	public void method() {}
+	
+	public void intMethod(int i) {}
+	
+	public void stringMethod(String s) {}
+	
+	public void myClassMethod(MyClass s) {}
+	
+	public void genericMethod(List<String> l) {}
+	
+	public void twoArgsMethod(int i, String s) {}
+	
+	public void genericMethod2(MyGenericClass<String,MyClass> m) {}
+	
+	public static void main(String[] args) {}
+	
+	public void multiMethod(String[][] s) {}
+	
+	public void intArray(int[] i) {}
+	
+}
+
+class MyClass {
+	
+	public MyClass(String s) {}
+	
+}
+
+class MyGenericClass<X,Y> {}
@@ -109,7 +109,7 @@ public class Ajc151Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   	  IProgramElement pe2 = top.findElementForType("pkg","printParameters");
   	  assertNotNull("Couldn't find 'printParameters' element in the tree",pe2);
   	  // the argument is org.aspectj.lang.JoinPoint, check that this is added
-  	  assertFalse("printParameters method should have arguments",pe2.getParameterTypes().isEmpty());	  
+  	  assertFalse("printParameters method should have arguments",pe2.getParameterSignatures().isEmpty());	  
   }
 
   public void testParameterizedEnum_pr126316() {
@@ -156,8 +156,8 @@ public class Ajc151Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   			  IProgramElement.Kind.INTER_TYPE_FIELD,"Bar.children");  	   	 
   	  assertNotNull("Couldn't find 'Bar.children' element in the tree",field);
   	  IProgramElement constructor = top.findElementForLabel(top.getRoot(),
-  			  IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR,"Foo.Foo(List<T>)");  	   	 
-  	  assertNotNull("Couldn't find 'Foo.Foo(List<T>)' element in the tree",constructor);
+  			  IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR,"Foo.Foo(java.util.List<T>)");  	   	 
+  	  assertNotNull("Couldn't find 'Foo.Foo(java.util.List<T>)' element in the tree",constructor);
 
   	  // check that the relationship map has 'itd method declared on bar'
   	  List matches = AsmManager.getDefault().getRelationshipMap().get(method);
@@ -11,6 +11,7 @@
 package org.aspectj.systemtest.ajc152;
 
 import java.io.File;
+import java.util.ArrayList;
 import java.util.List;
 
 import junit.framework.Test;
@@ -128,6 +129,60 @@ public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testJarChecking_pr137235_2() { runTest("directory with .jar extension"); }
   public void testMakePreMethodNPE_pr136393() { runTest("NPE in makePreMethod");}
 
+  public void testGetParameterHandles_pr141730() {
+	  runTest("new IProgramElement handle methods");  
+	  
+	  checkParametersForIPE("intMethod(int)",IProgramElement.Kind.METHOD,"I",true);
+	  checkParametersForIPE("stringMethod(java.lang.String)",IProgramElement.Kind.METHOD,"Ljava/lang/String;",true);
+	  checkParametersForIPE("myClassMethod(MyClass)",IProgramElement.Kind.METHOD,"LMyClass;",true);
+	  checkParametersForIPE("genericMethod(java.util.List<java.lang.String>)",IProgramElement.Kind.METHOD,"Pjava/util/List<Ljava/lang/String;>;",true);
+	  checkParametersForIPE("genericMethod2(MyGenericClass<java.lang.String,MyClass>)",IProgramElement.Kind.METHOD,"PMyGenericClass<Ljava/lang/String;LMyClass;>;",true);
+	  checkParametersForIPE("main(java.lang.String[])",IProgramElement.Kind.METHOD,"[Ljava/lang/String;",true);
+	  checkParametersForIPE("multiMethod(java.lang.String[][])",IProgramElement.Kind.METHOD,"[[Ljava/lang/String;",true);
+	  checkParametersForIPE("intArray(int[])",IProgramElement.Kind.METHOD,"[I",true);
+	  
+  	  IHierarchy top = AsmManager.getDefault().getHierarchy();      
+  	  IProgramElement twoArgsMethod = top.findElementForLabel(
+  			  top.getRoot(),IProgramElement.Kind.METHOD,"twoArgsMethod(int,java.lang.String)");
+      assertNotNull("Couldn't find 'twoArgsMethod(int,java.lang.String)' element in the tree",twoArgsMethod);
+      List l = twoArgsMethod.getParameterSignatures();
+      assertEquals("",((char[])l.get(0))[0],'I');
+      boolean eq = equals(((char[])l.get(1)),"Ljava/lang/String;".toCharArray());
+      assertTrue("expected parameter to be 'Ljava/lang/String;' but found '" +
+        		new String(((char[])l.get(1))) + "'",eq);
+  }
+  
+  public void testGetParameterTypes_pr141730() {
+	  runTest("new IProgramElement handle methods"); 
+	  
+	  checkParametersForIPE("intMethod(int)",IProgramElement.Kind.METHOD,"int",false);
+	  checkParametersForIPE("stringMethod(java.lang.String)",IProgramElement.Kind.METHOD,"java.lang.String",false);
+	  checkParametersForIPE("myClassMethod(MyClass)",IProgramElement.Kind.METHOD,"MyClass",false);
+	  checkParametersForIPE("genericMethod(java.util.List<java.lang.String>)",IProgramElement.Kind.METHOD,"java.util.List<java.lang.String>",false);
+	  checkParametersForIPE("genericMethod2(MyGenericClass<java.lang.String,MyClass>)",IProgramElement.Kind.METHOD,"MyGenericClass<java.lang.String,MyClass>",false);
+	  checkParametersForIPE("main(java.lang.String[])",IProgramElement.Kind.METHOD,"java.lang.String[]",false);
+	  checkParametersForIPE("multiMethod(java.lang.String[][])",IProgramElement.Kind.METHOD,"java.lang.String[][]",false);
+	  checkParametersForIPE("intArray(int[])",IProgramElement.Kind.METHOD,"int[]",false);
+  }
+  
+  public void testToSignatureString_pr141730() {
+	  runTest("new IProgramElement handle methods"); 
+	  
+	  checkSignatureOfIPE("main(java.lang.String[])",IProgramElement.Kind.METHOD);
+	  checkSignatureOfIPE("C",IProgramElement.Kind.CLASS);
+	  checkSignatureOfIPE("C()",IProgramElement.Kind.CONSTRUCTOR);
+	  checkSignatureOfIPE("method()",IProgramElement.Kind.METHOD);
+	  checkSignatureOfIPE("p()",IProgramElement.Kind.POINTCUT);
+	  checkSignatureOfIPE("before(): p..",IProgramElement.Kind.ADVICE,"before()");
+	  checkSignatureOfIPE("MyClass.method()",IProgramElement.Kind.INTER_TYPE_METHOD);
+	  checkSignatureOfIPE("multiMethod(java.lang.String[][])",IProgramElement.Kind.METHOD);
+	  checkSignatureOfIPE("intArray(int[])",IProgramElement.Kind.METHOD);
+	  checkSignatureOfIPE("MyClass.MyClass()",IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR);
+  }
+
+  
+
+  
 //  public void testFunkyGenericErrorWithITDs_pr126355_2() { 
 //	  runTest("bizarre generic error with itds - 2");
 //	  // public class Pair<F,S> affected by pertarget aspect
@@ -143,6 +198,55 @@ public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
   // Not valid whilst the ajc compiler forces debug on (ignores -g:none) - it will be green but is invalid, trust me
   // public void testLongWindedMessages_pr129408() { runTest("long winded ataj messages");}
+
+  // ---------------- helper methods ---------------
+  
+   /**
+    * taken from CharOperation
+    */
+	private final boolean equals(char[] first, char[] second) {
+		if (first == second)
+			return true;
+		if (first == null || second == null)
+			return false;
+		if (first.length != second.length)
+			return false;
+
+		for (int i = first.length; --i >= 0;)
+			if (first[i] != second[i])
+				return false;
+		return true;
+	}
+  
+	private void checkParametersForIPE(String ipeLabel, IProgramElement.Kind kind, String expectedParm, boolean getHandles) {
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement ipe = top.findElementForLabel(top.getRoot(),kind,ipeLabel);
+	    assertNotNull("Couldn't find '" + ipeLabel + "' element in the tree",ipe);
+	    List l = new ArrayList();
+	    if (getHandles) {
+	    	l = ipe.getParameterSignatures();
+	    } else {
+	    	l = ipe.getParameterTypes();
+	    }
+	    boolean eq = equals(((char[])l.get(0)),expectedParm.toCharArray());
+	    assertTrue("expected parameter to be '" + expectedParm + "' but found '" +
+	      		new String(((char[])l.get(0))) + "'",eq);
+	}
+  
+	private void checkSignatureOfIPE(String ipeLabel, IProgramElement.Kind kind) {
+		checkSignatureOfIPE(ipeLabel,kind,ipeLabel);
+	}
+	
+	private void checkSignatureOfIPE(String ipeLabel, IProgramElement.Kind kind, String expectedSig) {
+		IHierarchy top = AsmManager.getDefault().getHierarchy();
+		IProgramElement ipe = top.findElementForLabel(
+				  top.getRoot(),kind,ipeLabel);
+	    assertNotNull("Couldn't find '" + ipeLabel + "' element in the tree",ipe);
+      	assertEquals("expected signature to be '"+ expectedSig + "' but was " +
+				  ipe.toSignatureString(true),expectedSig,ipe.toSignatureString(true));
+		
+	}
+	
   /////////////////////////////////////////
   public static Test suite() {
     return XMLBasedAjcTestCase.loadSuite(Ajc152Tests.class);
@@ -602,6 +602,10 @@
       <compile files="Covariance.java" options="-1.5"/>
     </ajc-test>
 
+    <ajc-test dir="bugs152" title="new IProgramElement handle methods">
+      <compile files="pr141730.aj" options="-emacssym -1.5"/>
+    </ajc-test>
+
     <ajc-test dir="bugs152" title="declare @method relationship">
      <compile files="pr143924.aj" options="-1.5 -showWeaveInfo -emacssym">
         <message kind="weave" text="'public void BankAccount.debit(String,long)' (pr143924.aj:7) is annotated with @Secured"/>
@@ -0,0 +1,48 @@
+/********************************************************************
+ * Copyright (c) 2006 Contributors. All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ *  
+ * Contributors: IBM Corporation - initial API and implementation 
+ * 				 Helen Hawkins   - initial version
+ *******************************************************************/
+package org.aspectj.util;
+
+
+/**
+ * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+ *
+ */
+public class CharOperation {
+	
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final char[] subarray(char[] array, int start, int end) {
+		if (end == -1)
+			end = array.length;
+		if (start > end)
+			return null;
+		if (start < 0)
+			return null;
+		if (end > array.length)
+			return null;
+
+		char[] result = new char[end - start];
+		System.arraycopy(array, start, result, 0, end - start);
+		return result;
+	}
+	
+	/**
+	 * Taken from org.aspectj.org.eclipse.jdt.core.compiler.CharOperation
+	 */	
+	public static final int lastIndexOf(char toBeFound, char[] array) {
+		for (int i = array.length; --i >= 0;)
+			if (toBeFound == array[i])
+				return i;
+		return -1;
+	}
+	
+}
