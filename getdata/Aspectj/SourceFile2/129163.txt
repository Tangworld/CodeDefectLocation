@@ -0,0 +1,37 @@
+/*
+
+Copyright (c) Xerox Corporation 1998-2002.  All rights reserved.
+
+Use and copying of this software and preparation of derivative works based
+upon this software are permitted.  Any distribution of this software or
+derivative works must comply with all applicable United States export control
+laws.
+
+This software is made available AS IS, and Xerox Corporation makes no warranty
+about the software, its performance or its conformity to any specification.
+
+*/
+package tjp;
+
+public class Demo {
+    static Demo d;
+
+    public static void main(String[] args){
+        new Demo().go();
+    }
+
+    void go(){
+        d = new Demo();
+        d.foo(1,d);
+        System.out.println(d.bar(new Integer(3)));
+    }
+
+    void foo(int i, Object o){
+        System.out.println("Demo.foo(" + i + ", " + o + ")\n");
+    }
+
+    String bar (Integer j){
+        System.out.println("Demo.bar(" + j + ")\n");
+        return "Demo.bar(" + j  + ")";
+    }
+}
@@ -0,0 +1,49 @@
+/*
+Copyright (c) Xerox Corporation 1998-2002.  All rights reserved.
+
+Use and copying of this software and preparation of derivative works based
+upon this software are permitted.  Any distribution of this software or
+derivative works must comply with all applicable United States export control
+laws.
+
+This software is made available AS IS, and Xerox Corporation makes no warranty
+about the software, its performance or its conformity to any specification.
+*/
+
+package tjp;
+
+import org.aspectj.lang.JoinPoint;
+import org.aspectj.lang.reflect.CodeSignature;
+
+aspect GetInfo {
+
+   static final void println(String s){ System.out.println(s); }
+
+   pointcut goCut(): cflow(this(Demo) && execution(void go()));
+
+   pointcut demoExecs(): within(Demo) && execution(* *(..));
+
+   Object around(): demoExecs() && !execution(* go()) && goCut() {
+      println("Intercepted message: " +
+          thisJoinPointStaticPart.getSignature().getName());
+      println("in class: " +
+          thisJoinPointStaticPart.getSignature().getDeclaringType().getName());
+      printParameters(thisJoinPoint);
+      println("Running original method: \n" );
+      Object result = proceed();
+      println("  result: " + result );
+      return result;
+   }
+
+   static private void printParameters(JoinPoint jp) {
+      println("Arguments: " );
+      Object[] args = jp.getArgs();
+      String[] names = ((CodeSignature)jp.getSignature()).getParameterNames();
+      Class[] types = ((CodeSignature)jp.getSignature()).getParameterTypes();
+      for (int i = 0; i < args.length; i++) {
+         println("  "  + i + ". " + names[i] +
+             " : " +            types[i].getName() +
+             " = " +            args[i]);
+      }
+   }
+}
@@ -0,0 +1,37 @@
+/*
+
+Copyright (c) Xerox Corporation 1998-2002.  All rights reserved.
+
+Use and copying of this software and preparation of derivative works based
+upon this software are permitted.  Any distribution of this software or
+derivative works must comply with all applicable United States export control
+laws.
+
+This software is made available AS IS, and Xerox Corporation makes no warranty
+about the software, its performance or its conformity to any specification.
+
+*/
+package tjp;
+
+public class Demo {
+    static Demo d;
+    /* blah blah blah */
+    public static void main(String[] args){
+        new Demo().go();
+    }
+
+    void go(){
+        d = new Demo();
+        d.foo(1,d);
+        System.out.println(d.bar(new Integer(3)));
+    }
+
+    void foo(int i, Object o){
+        System.out.println("Demo.foo(" + i + ", " + o + ")\n");
+    }
+
+    String bar (Integer j){
+        System.out.println("Demo.bar(" + j + ")\n");
+        return "Demo.bar(" + j  + ")";
+    }
+}
@@ -0,0 +1,49 @@
+/*
+Copyright (c) Xerox Corporation 1998-2002.  All rights reserved.
+
+Use and copying of this software and preparation of derivative works based
+upon this software are permitted.  Any distribution of this software or
+derivative works must comply with all applicable United States export control
+laws.
+
+This software is made available AS IS, and Xerox Corporation makes no warranty
+about the software, its performance or its conformity to any specification.
+*/
+
+package tjp;
+
+import org.aspectj.lang.JoinPoint;
+import org.aspectj.lang.reflect.CodeSignature;
+
+aspect GetInfo {
+
+   static final void println(String s){ System.out.println(s); }
+
+   pointcut goCut(): cflow(this(Demo) && execution(void go()));
+
+   pointcut demoExecs(): within(Demo) && execution(* *(..));
+
+   Object around(): demoExecs() && !execution(* go()) && goCut() {
+      println("Intercepted message: " +
+          thisJoinPointStaticPart.getSignature().getName());
+      println("in class: " +
+          thisJoinPointStaticPart.getSignature().getDeclaringType().getName());
+      printParameters(thisJoinPoint);
+      println("Running original method: \n" );
+      Object result = proceed();
+      println("  result: " + result );
+      return result;
+   }
+
+   static private void printParameters(JoinPoint jp) {
+      println("Arguments: " );
+      Object[] args = jp.getArgs();
+      String[] names = ((CodeSignature)jp.getSignature()).getParameterNames();
+      Class[] types = ((CodeSignature)jp.getSignature()).getParameterTypes();
+      for (int i = 0; i < args.length; i++) {
+         println("  "  + i + ". " + names[i] +
+             " : " +            types[i].getName() +
+             " = " +            args[i]);
+      }
+   }
+}
@@ -0,0 +1,7 @@
+package pack;
+import p.C1;
+public class C {
+	public void m() {
+		new C1().m1();
+	}
+}
@@ -0,0 +1,7 @@
+package pack;
+import p.C1;
+public class C {
+	public void m() {
+		new C1().m1();
+	}
+}
@@ -0,0 +1,6 @@
+package p;
+
+public aspect A1 {
+
+	
+}
@@ -0,0 +1,11 @@
+package p;
+
+public class C1 {
+	public void m1() {
+		
+	}
+
+	public void m2() {
+		
+	}
+}
@@ -0,0 +1,6 @@
+package p;
+
+public aspect A1 {
+
+	
+}
@@ -0,0 +1,11 @@
+package p;
+
+public class C1 {
+	public void m1() {
+		System.out.println("Hello");
+	}
+
+	public void m2() {
+		
+	}
+}
@@ -619,6 +619,7 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		}
 	}
 
+	// test for comment #31 - NPE
 	public void testPr129163() {
 		configureBuildStructureModel(true);
 		initialiseProject("PR129613");
@@ -634,6 +635,58 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		configureBuildStructureModel(false);
 	}
 
+	// test for comment #0 - adding a comment to a class file shouldn't
+	// cause us to go back to source and recompile everything. To force this
+	// to behave like AJDT we need to include the aspect in 'inc1' so that
+	// when AjState looks at its timestamp it thinks the aspect has been modified. 
+	// The logic within CrosscuttingMembers should then work out correctly 
+	// that there haven't really been any changes within the aspect and so 
+	// we shouldn't go back to source.
+	public void testPr129163_2() {
+		// want to behave like AJDT
+		configureBuildStructureModel(true);
+		initialiseProject("pr129163_2");
+		build("pr129163_2");
+		checkWasFullBuild();
+		alter("pr129163_2","inc1");
+		build("pr129163_2");
+		checkWasntFullBuild(); // shouldn't be a full build because the 
+		                       // aspect hasn't changed
+		configureBuildStructureModel(false);
+	}
+	
+	// test for comment #6 - simulates AJDT core builder test testBug99133a -
+	// changing the contents of a method within a class shouldn't force a 
+	// full build of a dependant project. To force this to behave like AJDT
+	// 'inc1' of the dependant project should just be a copy of 'base' so that
+	// AjState thinks somethings changed within the dependant project and 
+	// we do a build. Similarly, 'inc1' of the project depended on should 
+	// include the aspect even though nothing's changed within it. This causes
+	// AjState to think that the aspect has changed. Together its then up to 
+	// logic within CrosscuttingMembers and various equals methods to decide
+	// correctly that we don't have to go back to source.
+	public void testPr129163_3() {
+		configureBuildStructureModel(true);
+		initialiseProject("PR129163_4");
+		build("PR129163_4");
+		checkWasFullBuild(); // should be a full build because initializing project
+		initialiseProject("PR129163_3");
+		configureNewProjectDependency("PR129163_3","PR129163_4");
+		build("PR129163_3");
+		checkWasFullBuild(); // should be a full build because initializing project
+		alter("PR129163_4","inc1");
+		build("PR129163_4");
+		checkWasntFullBuild(); // should be an incremental build because although
+		                       // "inc1" includes the aspect A1.aj, it actually hasn't
+							   // changed so we shouldn't go back to source
+		alter("PR129163_3","inc1");
+		build("PR129163_3");
+		checkWasntFullBuild(); // should be an incremental build because nothing has
+			                   // changed within the class and no aspects have changed
+		                       // within the running of the test
+		configureBuildStructureModel(false);
+	}
+	
 	// other possible tests:
 	// - memory usage (freemem calls?)
 	// - relationship map
@@ -116,7 +116,7 @@ public class AjCompilerAdapter implements ICompilerAdapter {
 		IMessageHandler msgHandler = world.getMessageHandler();
 		// Do we need to reset the message handler or create a new one? (This saves a ton of memory lost on incremental compiles...)
 		if (msgHandler instanceof WeaverMessageHandler) {
-			((WeaverMessageHandler)msgHandler).resetCompiler(null);
+			((WeaverMessageHandler)msgHandler).resetCompiler(compiler);
 			weaverMessageHandler = (WeaverMessageHandler)msgHandler;
 		} else {
 			weaverMessageHandler = new WeaverMessageHandler(msgHandler, compiler);
@@ -0,0 +1,5 @@
+package pkg;
+
+public aspect A {
+
+}
@@ -0,0 +1,6 @@
+package pkg;
+
+public aspect A {
+
+	pointcut p2(): call(* File.*(..));
+}
@@ -619,6 +619,21 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		}
 	}
 
+	public void testPr129163() {
+		configureBuildStructureModel(true);
+		initialiseProject("PR129613");
+		build("PR129613");
+		alter("PR129613","inc1");
+		build("PR129613");
+		assertTrue("There should be no exceptions handled:\n"+MyErrorHandler.getErrorMessages(),
+				MyErrorHandler.getErrorMessages().isEmpty());
+		assertEquals("warning message should be 'no match for this type name: File [Xlint:invalidAbsoluteTypeName]' ",
+				"no match for this type name: File [Xlint:invalidAbsoluteTypeName]",
+				((IMessage)MyTaskListManager.getWarningMessages().get(0))
+					.getMessage());
+		configureBuildStructureModel(false);
+	}
+	
 	// other possible tests:
 	// - memory usage (freemem calls?)
 	// - relationship map
@@ -20,6 +20,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
+import org.aspectj.weaver.bcel.BcelTypeMunger;
 import org.aspectj.weaver.patterns.Declare;
 import org.aspectj.weaver.patterns.DeclareAnnotation;
 import org.aspectj.weaver.patterns.DeclareErrorOrWarning;
@@ -240,12 +241,43 @@ public class CrosscuttingMembers {
 				shadowMungers = other.shadowMungers;
 			}
   	    }
-		// bug 129163: use set equality rather than list equality
+  	    
+		// bug 129163: use set equality rather than list equality and
+  	    // if we dont care about shadow mungers then ignore those 
+  	    // typeMungers which are created to help with the implementation 
+  	    // of shadowMungers
 		Set theseTypeMungers = new HashSet();
-		theseTypeMungers.addAll(typeMungers);
 		Set otherTypeMungers = new HashSet();
-		otherTypeMungers.addAll(other.typeMungers);
-		if (!theseTypeMungers.equals(otherTypeMungers)) {
+		if (!careAboutShadowMungers) {
+			for (Iterator iter = typeMungers.iterator(); iter.hasNext();) {
+				Object o = iter.next();
+				if (o instanceof BcelTypeMunger) {
+					BcelTypeMunger typeMunger = (BcelTypeMunger) o;
+					if (!typeMunger.existsToSupportShadowMunging()) {
+						theseTypeMungers.add(typeMunger);
+					}				
+				} else {
+					theseTypeMungers.add(o);
+				}
+			}
+			
+			for (Iterator iter = other.typeMungers.iterator(); iter.hasNext();) {
+				Object o = iter.next();
+				if (o instanceof BcelTypeMunger) {
+					BcelTypeMunger typeMunger = (BcelTypeMunger) o;
+					if (!typeMunger.existsToSupportShadowMunging()) {
+						otherTypeMungers.add(typeMunger);
+					}
+				} else {
+					otherTypeMungers.add(o);
+				}
+			}
+		} else {
+			theseTypeMungers.addAll(typeMungers);
+			otherTypeMungers.addAll(other.typeMungers);
+		}
+  	    
+  	    if (!theseTypeMungers.equals(otherTypeMungers)) {
 			changed = true;
 			typeMungers = other.typeMungers;
 		}
@@ -63,4 +63,7 @@ public class PrivilegedAccessMunger extends ResolvedTypeMunger {
         return result;
     }
 
+ 	public boolean existsToSupportShadowMunging() {
+		return true;
+	}
 }
@@ -407,5 +407,20 @@ public abstract class ResolvedTypeMunger {
 		return false;
 	}
 
+	/**
+	 * Some type mungers are created purely to help with the implementation of shadow mungers.  
+	 * For example to support the cflow() pointcut we create a new cflow field in the aspect, and
+	 * that is added via a BcelCflowCounterFieldAdder.
+	 * 
+	 * During compilation we need to compare sets of type mungers, and if some only come into
+	 * existence after the 'shadowy' type things have been processed, we need to ignore
+	 * them during the comparison.
+	 * 
+	 * Returning true from this method indicates the type munger exists to support 'shadowy' stuff -
+	 * and so can be ignored in some comparison.
+	 */
+	public boolean existsToSupportShadowMunging() {
+		return false;
+	}
 
 }
@@ -1677,7 +1677,10 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 	 * and so can be ignored in some comparison.
 	 */
 	public boolean existsToSupportShadowMunging() {
-		return false; // Does this need to delegate to the ResolvedTypeMunger field held in the BcelTypeMunger?
+		if (munger != null) {
+			return munger.existsToSupportShadowMunging();
+		}
+		return false; 
 	}
 }
 		
\ No newline at end of file
@@ -240,6 +240,8 @@ public abstract class Advice extends ShadowMunger {
 	// only called as part of parameterization....
 	public void setSignature(Member signature) {
 		this.signature = signature;
+		// reset hashCode value so it can be recalculated next time
+		hashCode = 0;
 	}
 
 	public boolean hasExtraParameter() {
@@ -366,22 +368,26 @@ public abstract class Advice extends ShadowMunger {
 //			+ signature
 //			+ ")";
 	}
+	
+	// XXX this perhaps ought to take account of the other fields in advice ...
     public boolean equals(Object other) {
         if (! (other instanceof Advice)) return false;
         Advice o = (Advice) other;
-        return o.attribute.equals(attribute) 
-        	&& o.pointcut.equals(pointcut) 
-        	&& o.signature.equals(signature);
+        return o.kind.equals(kind) 
+        	&& ((o.pointcut == null) ? (pointcut == null) : o.pointcut.equals(pointcut))
+        	&& ((o.signature == null) ? (signature == null) : o.signature.equals(signature));
+
     }
-    private volatile int hashCode = 0;
+
+	private volatile int hashCode = 0;
     public int hashCode() {
-        if (hashCode == 0) {
+    	if (hashCode == 0) {
             int result = 17;
             result = 37*result + kind.hashCode();
-            result = 37*result + pointcut.hashCode();
-            if (signature != null) result = 37*result + signature.hashCode();
-            hashCode = result;
-        }
+            result = 37*result + ((pointcut == null) ? 0 : pointcut.hashCode());
+            result = 37*result + ((signature == null) ? 0 : signature.hashCode());
+            hashCode = result;			
+		}
         return hashCode;
     }
 
@@ -35,4 +35,21 @@ public class AnnotationOnTypeMunger extends ResolvedTypeMunger {
 	public AnnotationX getNewAnnotation() {
 		return newAnnotation;
 	}
+
+    public boolean equals(Object other) {
+    	if (!(other instanceof AnnotationOnTypeMunger)) return false;
+    	AnnotationOnTypeMunger o = (AnnotationOnTypeMunger)other;
+    	return newAnnotation.getSignature().equals(o.newAnnotation.getSignature());
+    }
+
+    private volatile int hashCode = 0;
+    public int hashCode() {
+    	if (hashCode == 0) {
+    		int result = 17;
+    	    result = 37*result + newAnnotation.getSignature().hashCode();
+    	    hashCode = result;
+		}
+	    return hashCode;
+    }
+	
 }
@@ -365,22 +365,10 @@ public class MemberImpl implements Comparable, AnnotatedElement,Member {
     public boolean equals(Object other) {
         if (! (other instanceof Member)) return false;
         Member o = (Member) other;
-
-        return (kind == o.getKind() 
-            && name.equals(o.getName()) 
-            && signature.equals(o.getSignature())
-            && declaringType.equals(o.getDeclaringType()));
-    }
-    
-    /* (non-Javadoc)
-	 * @see org.aspectj.weaver.Member#compareTo(java.lang.Object)
-	 */
-    public int compareTo(Object other) {
-    	Member o = (Member) other;
-    	
-    	int i = getName().compareTo(o.getName());
-    	if (i != 0) return i;
-    	return getSignature().compareTo(o.getSignature());
+        return (getKind() == o.getKind() 
+            && getName().equals(o.getName()) 
+            && getSignature().equals(o.getSignature())
+            && getDeclaringType().equals(o.getDeclaringType()));
     }
 
     /** 
@@ -392,15 +380,26 @@ public class MemberImpl implements Comparable, AnnotatedElement,Member {
     public int hashCode() {
         if (hashCode == 0) {
             int result = 17;
-            result = 37*result + kind.hashCode();
-            result = 37*result + name.hashCode();
-            result = 37*result + signature.hashCode();
-            result = 37*result + declaringType.hashCode();
+            result = 37*result + getKind().hashCode();
+            result = 37*result + getName().hashCode();
+            result = 37*result + getSignature().hashCode();
+            result = 37*result + getDeclaringType().hashCode();
             hashCode = result;
         } 
         return hashCode;
     }
 
+    /* (non-Javadoc)
+	 * @see org.aspectj.weaver.Member#compareTo(java.lang.Object)
+	 */
+    public int compareTo(Object other) {
+    	Member o = (Member) other;
+    	
+    	int i = getName().compareTo(o.getName());
+    	if (i != 0) return i;
+    	return getSignature().compareTo(o.getSignature());
+    }
+    
     public String toString() {
     	StringBuffer buf = new StringBuffer();
     	buf.append(returnType.getName());
@@ -55,6 +55,26 @@ public class MethodDelegateTypeMunger extends ResolvedTypeMunger {
         this.implClassName = implClassName;
     }
 
+    public boolean equals(Object other) {
+    	if (!(other instanceof MethodDelegateTypeMunger)) return false;
+    	MethodDelegateTypeMunger o = (MethodDelegateTypeMunger)other;
+    	return ((o.aspect == null) ? (aspect == null ) : aspect.equals(o.aspect))
+    			&& ((o.typePattern == null) ? (typePattern == null ) : typePattern.equals(o.typePattern))
+    			&& ((o.implClassName == null) ? (implClassName == null) : implClassName.equals(o.implClassName));
+    }
+
+    private volatile int hashCode = 0;
+    public int hashCode() {
+    	if (hashCode == 0) {
+    	 	int result = 17;
+    	    result = 37*result + ((aspect == null) ? 0 : aspect.hashCode());
+    	    result = 37*result + ((typePattern == null) ? 0 : typePattern.hashCode());
+    	    result = 37*result + ((implClassName == null) ? 0 : implClassName.hashCode());
+    	    hashCode = result;
+		}
+	    return hashCode;
+    }
+    
     public ResolvedMember getDelegate(ResolvedType targetType) {
         return AjcMemberMaker.itdAtDeclareParentsField(
                 targetType,
@@ -130,6 +150,20 @@ public class MethodDelegateTypeMunger extends ResolvedTypeMunger {
             this.typePattern = typePattern;
         }
 
+        public boolean equals(Object other) {
+        	if (!(other instanceof FieldHostTypeMunger)) return false;
+        	FieldHostTypeMunger o = (FieldHostTypeMunger)other;
+        	return ((o.aspect == null) ? (aspect == null ) : aspect.equals(o.aspect))
+        			&& ((o.typePattern == null) ? (typePattern == null ) : typePattern.equals(o.typePattern));
+        }
+
+        public int hashCode() {
+    	 	int result = 17;
+    	    result = 37*result + ((aspect == null) ? 0 : aspect.hashCode());
+    	    result = 37*result + ((typePattern == null) ? 0 : typePattern.hashCode());
+    	    return result;
+        }
+        
         public void write(DataOutputStream s) throws IOException {
             kind.write(s);
             signature.write(s);
@@ -40,6 +40,26 @@ public class NewConstructorTypeMunger extends ResolvedTypeMunger {
 
 	}
 
+    public boolean equals(Object other) {
+    	if (!(other instanceof NewConstructorTypeMunger)) return false;
+    	NewConstructorTypeMunger o = (NewConstructorTypeMunger)other;	
+    	return ((o.syntheticConstructor == null) ? (syntheticConstructor == null ) 
+    				: syntheticConstructor.equals(o.syntheticConstructor))
+    			& ((o.explicitConstructor == null) ? (explicitConstructor == null ) 
+    				: explicitConstructor.equals(o.explicitConstructor));
+    }
+
+    private volatile int hashCode = 0;
+    public int hashCode() {
+    	if (hashCode == 0) {
+    	 	int result = 17;
+    	    result = 37*result + ((syntheticConstructor == null) ? 0 : syntheticConstructor.hashCode());
+    	    result = 37*result + ((explicitConstructor == null) ? 0 : explicitConstructor.hashCode());
+    	    hashCode = result;
+		}
+	    return hashCode;
+    }
+	
 	// doesnt seem required....
 //	public ResolvedMember getDispatchMethod(UnresolvedType aspectType) {
 //		return AjcMemberMaker.interMethodBody(signature, aspectType);
@@ -78,6 +98,8 @@ public class NewConstructorTypeMunger extends ResolvedTypeMunger {
 
 	public void setExplicitConstructor(ResolvedMember explicitConstructor) {
 		this.explicitConstructor = explicitConstructor;
+		// reset hashCode so that its recalculated with new value
+		hashCode = 0;
 	}
 
 	public ResolvedMember getMatchingSyntheticMember(Member member, ResolvedType aspectType) {
@@ -93,4 +93,22 @@ public class NewFieldTypeMunger extends ResolvedTypeMunger {
 	    return nftm;
 	}
 
+    public boolean equals(Object other) {
+        if (! (other instanceof NewFieldTypeMunger)) return false;
+        NewFieldTypeMunger o = (NewFieldTypeMunger) other;
+        return kind.equals(o.kind)
+        		&& ((o.signature == null) ? (signature == null ) : signature.equals(o.signature))
+        		&& ((o.declaredSignature == null) ? (declaredSignature == null ) : declaredSignature.equals(o.declaredSignature))
+        		&& ((o.typeVariableAliases == null) ? (typeVariableAliases == null ) : typeVariableAliases.equals(o.typeVariableAliases));
+    }
+	   
+    public int hashCode() {
+    	int result = 17;
+        result = 37*result + kind.hashCode();
+        result = 37*result + ((signature == null) ? 0 : signature.hashCode());
+        result = 37*result + ((declaredSignature == null) ? 0 : declaredSignature.hashCode());
+        result = 37*result + ((typeVariableAliases == null) ? 0 : typeVariableAliases.hashCode());
+        return result;
+    }
+	
 }
@@ -110,5 +110,22 @@ public class NewMethodTypeMunger extends ResolvedTypeMunger {
 		return nmtm;
 	}
 
+    public boolean equals(Object other) {
+        if (! (other instanceof NewMethodTypeMunger)) return false;
+        NewMethodTypeMunger o = (NewMethodTypeMunger) other;
+        return kind.equals(o.kind)
+        		&& ((o.signature == null) ? (signature == null ) : signature.equals(o.signature))
+        		&& ((o.declaredSignature == null) ? (declaredSignature == null ) : declaredSignature.equals(o.declaredSignature))
+        		&& ((o.typeVariableAliases == null) ? (typeVariableAliases == null ) : typeVariableAliases.equals(o.typeVariableAliases));
+    }
+	   
+    public int hashCode() {
+    	int result = 17;
+        result = 37*result + kind.hashCode();
+        result = 37*result + ((signature == null) ? 0 : signature.hashCode());
+        result = 37*result + ((declaredSignature == null) ? 0 : declaredSignature.hashCode());
+        result = 37*result + ((typeVariableAliases == null) ? 0 : typeVariableAliases.hashCode());
+        return result;
+    }
 
 }
@@ -33,5 +33,19 @@ public class NewParentTypeMunger extends ResolvedTypeMunger {
 		return newParent;
 	}
 
-
+    public boolean equals(Object other) {
+        if (! (other instanceof NewParentTypeMunger)) return false;
+        NewParentTypeMunger o = (NewParentTypeMunger) other;
+        return newParent.equals(o.newParent);
+    }
+	   
+    private volatile int hashCode = 0;
+    public int hashCode() {
+	    if (hashCode == 0) {
+	    	int result = 17;
+	    	result = 37*result + newParent.hashCode();
+	    	hashCode = result;
+	    }
+        return hashCode;
+    }
 }
@@ -26,7 +26,25 @@ public class PerObjectInterfaceTypeMunger extends ResolvedTypeMunger {
     private final UnresolvedType interfaceType;
     private final Pointcut testPointcut;
     private TypePattern lazyTestTypePattern;
+    
+    public boolean equals(Object other) {
+    	if (!(other instanceof PerObjectInterfaceTypeMunger)) return false;
+  		PerObjectInterfaceTypeMunger o = (PerObjectInterfaceTypeMunger)other;
+    	return ((o.testPointcut == null) ? (testPointcut == null ) : testPointcut.equals(o.testPointcut))
+    			&& ((o.lazyTestTypePattern == null) ? (lazyTestTypePattern == null ) : lazyTestTypePattern.equals(o.lazyTestTypePattern));
+    }
 
+    private volatile int hashCode = 0;
+    public int hashCode() {
+    	if (hashCode == 0) {
+    	 	int result = 17;
+    	    result = 37*result + ((testPointcut == null) ? 0 : testPointcut.hashCode());
+    	    result = 37*result + ((lazyTestTypePattern == null) ? 0 : lazyTestTypePattern.hashCode());
+    	    hashCode = result;
+		}
+	    return hashCode;
+    }
+    
     public PerObjectInterfaceTypeMunger(UnresolvedType aspectType, Pointcut testPointcut) {
         super(PerObjectInterface, null);
         this.testPointcut = testPointcut;
@@ -44,6 +62,8 @@ public class PerObjectInterfaceTypeMunger extends ResolvedTypeMunger {
             }
             PerThisOrTargetPointcutVisitor v = new PerThisOrTargetPointcutVisitor(!isPerThis, aspectType);
             lazyTestTypePattern = v.getPerTypePointcut(testPointcut);
+            // reset hashCode so that its recalculated with the new lazyTestTypePattern
+            hashCode = 0;
         }
         return lazyTestTypePattern;
     }
@@ -30,6 +30,24 @@ public class PerTypeWithinTargetTypeMunger extends ResolvedTypeMunger {
 		this.testPointcut  = testPointcut;
 	}
 
+	public boolean equals(Object other) {
+	  	if (!(other instanceof PerTypeWithinTargetTypeMunger)) return false;
+	  	PerTypeWithinTargetTypeMunger o = (PerTypeWithinTargetTypeMunger)other;
+	   	return ((o.testPointcut == null) ? (testPointcut == null ) : testPointcut.equals(o.testPointcut))
+	   			&& ((o.aspectType == null) ? (aspectType == null ) : aspectType.equals(o.aspectType));
+	}
+
+	private volatile int hashCode = 0;
+	public int hashCode() {
+		if (hashCode == 0) {
+			int result = 17;
+		    result = 37*result + ((testPointcut == null) ? 0 : testPointcut.hashCode());
+		    result = 37*result + ((aspectType == null) ? 0 : aspectType.hashCode());
+		    hashCode = result;
+		}
+	    return hashCode;
+	}
+	
 	public void write(DataOutputStream s) throws IOException {
 		throw new RuntimeException("shouldn't be serialized");
 	}
@@ -45,4 +45,22 @@ public class PrivilegedAccessMunger extends ResolvedTypeMunger {
 		return null;
 	}
 
+    public boolean equals(Object other) {
+        if (! (other instanceof PrivilegedAccessMunger)) return false;
+        PrivilegedAccessMunger o = (PrivilegedAccessMunger) other;
+        return kind.equals(o.kind)
+        		&& ((o.signature == null) ? (signature == null ) : signature.equals(o.signature))
+        		&& ((o.declaredSignature == null) ? (declaredSignature == null ) : declaredSignature.equals(o.declaredSignature))
+        		&& ((o.typeVariableAliases == null) ? (typeVariableAliases == null ) : typeVariableAliases.equals(o.typeVariableAliases));
+    }
+	   
+    public int hashCode() {
+    	int result = 17;
+        result = 37*result + kind.hashCode();
+        result = 37*result + ((signature == null) ? 0 : signature.hashCode());
+        result = 37*result + ((declaredSignature == null) ? 0 : declaredSignature.hashCode());
+        result = 37*result + ((typeVariableAliases == null) ? 0 : typeVariableAliases.hashCode());
+        return result;
+    }
+	
 }
@@ -1645,6 +1645,25 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 		return munger.getTypeVariableAliases();
 	}
 
+	public boolean equals(Object other) {
+        if (! (other instanceof BcelTypeMunger))  return false;
+        BcelTypeMunger o = (BcelTypeMunger) other;
+        return ((o.getMunger() == null) ? (getMunger() == null) : o.getMunger().equals(getMunger()))
+               && ((o.getAspectType() == null) ? (getAspectType() == null) : o.getAspectType().equals(getAspectType()));
+    }
+	   
+    private volatile int hashCode = 0;
+    public int hashCode() {
+       if (hashCode == 0) {
+            int result = 17;
+	        result = 37*result + ((getMunger() == null) ? 0 : getMunger().hashCode());
+	        result = 37*result + ((getAspectType() == null) ? 0 : getAspectType().hashCode());
+            hashCode = result;
+       }
+       return hashCode;
+    }
+	
+	
 	/**
 	 * Some type mungers are created purely to help with the implementation of shadow mungers.  
 	 * For example to support the cflow() pointcut we create a new cflow field in the aspect, and
@@ -165,7 +165,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 				typesToProcess.add(stb);
 			}
 		}
-
+		factory.getWorld().getCrosscuttingMembersSet().reset();
 		while (typesToProcess.size()>0) {
 			// removes types from the list as they are processed...
 			collectAllITDsAndDeclares((SourceTypeBinding)typesToProcess.get(0),typesToProcess);
@@ -391,10 +391,10 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 
         if (dec instanceof AspectDeclaration) {
             ResolvedType typeX = factory.fromEclipse(dec.binding);
-            factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX);
+            factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX,false);
 
             if (typeX.getSuperclass().isAspect() && !typeX.getSuperclass().isExposedToWeaver()) {
-                factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX.getSuperclass());
+                factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX.getSuperclass(),false);
             }
         }
 
@@ -560,10 +560,7 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		build("PR113257");
 		alter("PR113257","inc1");
 		build("PR113257");
-		// THIS should be a full build, however, so that the patches
-		// for bug 129163 can be applied incrementally have changed this...
-		//checkWasFullBuild();  // back to the source
-		checkWasntFullBuild();
+		checkWasFullBuild();  // back to the source
 		alter("PR113257","inc1");
 		build("PR113257");
 	}
@@ -573,10 +570,7 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		build("PR123612");
 		alter("PR123612","inc1");
 		build("PR123612");
-		// THIS should be a full build, however, so that the patches
-		// for bug 129163 can be applied incrementally have changed this...
-		//checkWasFullBuild(); // back to the source
-		checkWasntFullBuild();
+		checkWasFullBuild(); // back to the source
 	}
 
 
@@ -15,8 +15,10 @@ package org.aspectj.weaver;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Set;
 
 import org.aspectj.weaver.patterns.Declare;
 import org.aspectj.weaver.patterns.DeclareAnnotation;
@@ -26,6 +28,7 @@ import org.aspectj.weaver.patterns.DeclarePrecedence;
 import org.aspectj.weaver.patterns.DeclareSoft;
 import org.aspectj.weaver.patterns.PerClause;
 import org.aspectj.weaver.patterns.Pointcut;
+import org.aspectj.weaver.patterns.PointcutRewriter;
 
 
 /**
@@ -192,7 +195,22 @@ public class CrosscuttingMembers {
 		return ret;
 	}
 
-	public boolean replaceWith(CrosscuttingMembers other) {
+	/**
+	 * Updates the records if something has changed. This is called at most twice, firstly
+	 * whilst collecting ITDs and declares. At this point the CrosscuttingMembers we're 
+	 * comparing ourselves with doesn't know about shadowmungers. Therefore a straight comparison
+	 * with the existing list of shadowmungers would return that something has changed
+	 * even though it might not have, so in this first round we ignore the shadowMungers. 
+	 * The second time this is called is whilst we're preparing to weave. At this point 
+	 * we know everything in the system and so we're able to compare the shadowMunger list.
+	 * (see bug 129163)
+	 * 
+	 * @param other
+	 * @param careAboutShadowMungers
+	 * @return true if something has changed since the last time this method was
+	 *         called, false otherwise
+	 */
+	public boolean replaceWith(CrosscuttingMembers other,boolean careAboutShadowMungers) {
 		boolean changed = false;
 
 		if (perClause == null || !perClause.equals(other.perClause)) {
@@ -202,12 +220,32 @@ public class CrosscuttingMembers {
 
 		//XXX all of the below should be set equality rather than list equality
 		//System.err.println("old: " + shadowMungers + " new: " + other.shadowMungers);
-		if (!shadowMungers.equals(other.shadowMungers)) {
-			changed = true;
-			shadowMungers = other.shadowMungers;
-		}
 
-		if (!typeMungers.equals(other.typeMungers)) {
+  	    if (careAboutShadowMungers) {
+		    // bug 129163: use set equality rather than list equality 
+			Set theseShadowMungers = new HashSet();
+			theseShadowMungers.addAll(shadowMungers);
+			Set otherShadowMungers = new HashSet();
+			otherShadowMungers.addAll(other.shadowMungers);
+			
+			PointcutRewriter pr = new PointcutRewriter();
+			for (Iterator iter = otherShadowMungers.iterator(); iter.hasNext();) {
+				ShadowMunger munger = (ShadowMunger) iter.next();
+				Pointcut p = munger.getPointcut();
+				Pointcut newP = pr.rewrite(p);
+				munger.setPointcut(newP);
+			}
+			if (!theseShadowMungers.equals(otherShadowMungers)) {
+				changed = true;
+				shadowMungers = other.shadowMungers;
+			}
+  	    }
+		// bug 129163: use set equality rather than list equality
+		Set theseTypeMungers = new HashSet();
+		theseTypeMungers.addAll(typeMungers);
+		Set otherTypeMungers = new HashSet();
+		otherTypeMungers.addAll(other.typeMungers);
+		if (!theseTypeMungers.equals(otherTypeMungers)) {
 			changed = true;
 			typeMungers = other.typeMungers;
 		}
@@ -44,17 +44,21 @@ public class CrosscuttingMembersSet {
 	private List declareAnnotationOnFields = null; 
 	private List declareAnnotationOnMethods= null; // includes ctors
 	private List declareDominates          = null;
+	private boolean changedSinceLastReset = false;
 
 	public CrosscuttingMembersSet(World world) {
 		this.world = world;
 	}
 
+	public boolean addOrReplaceAspect(ResolvedType aspectType) {
+		return addOrReplaceAspect(aspectType,true);
+	}
 
 	/**
 	 * @return whether or not that was a change to the global signature
 	 * 			XXX for efficiency we will need a richer representation than this
 	 */
-	public boolean addOrReplaceAspect(ResolvedType aspectType) {
+	public boolean addOrReplaceAspect(ResolvedType aspectType,boolean careAboutShadowMungers) {
 		boolean change = false;
 		CrosscuttingMembers xcut = (CrosscuttingMembers)members.get(aspectType);
 		if (xcut == null) {
@@ -63,7 +67,7 @@ public class CrosscuttingMembersSet {
 			CflowPointcut.clearCaches(aspectType);
 			change = true;
 		} else {
-			if (xcut.replaceWith(aspectType.collectCrosscuttingMembers())) {
+			if (xcut.replaceWith(aspectType.collectCrosscuttingMembers(),careAboutShadowMungers)) {
 				clearCaches();
 
 				CflowPointcut.clearCaches(aspectType);
@@ -74,13 +78,14 @@ public class CrosscuttingMembersSet {
 		}
 		if (aspectType.isAbstract()) {
 			// we might have sub-aspects that need to re-collect their crosscutting members from us
-			boolean ancestorChange = addOrReplaceDescendantsOf(aspectType); 
+			boolean ancestorChange = addOrReplaceDescendantsOf(aspectType,careAboutShadowMungers); 
 			change = change || ancestorChange;
 		}
+		changedSinceLastReset = changedSinceLastReset || change;
 		return change;
 	}
 
-	private boolean addOrReplaceDescendantsOf(ResolvedType aspectType) {
+	private boolean addOrReplaceDescendantsOf(ResolvedType aspectType,boolean careAboutShadowMungers) {
 		//System.err.println("Looking at descendants of "+aspectType.getName());
 		Set knownAspects = members.keySet();
 		Set toBeReplaced = new HashSet();
@@ -93,7 +98,7 @@ public class CrosscuttingMembersSet {
 		boolean change = false;
 		for (Iterator it = toBeReplaced.iterator(); it.hasNext(); ) {
 			ResolvedType next = (ResolvedType)it.next();
-			boolean thisChange = addOrReplaceAspect(next);
+			boolean thisChange = addOrReplaceAspect(next,careAboutShadowMungers);
 			change = change || thisChange;
 		}
 		return change;
@@ -255,5 +260,13 @@ public class CrosscuttingMembersSet {
 		return null;
 	}
 
+	public void reset() {
+		changedSinceLastReset = false;
+	}
+	
+	public boolean hasChangedSinceLastReset() {
+		return changedSinceLastReset;
+	}
+	
 
 }
@@ -430,7 +430,7 @@ public class BcelWeaver implements IWeaver {
 	// ---- weave preparation
 
     public void prepareForWeave() {
-    	needToReweaveWorld = false;
+    	needToReweaveWorld = xcutSet.hasChangedSinceLastReset();
 
     	CflowPointcut.clearCaches();
 
@@ -226,11 +226,21 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 		return resolvedPointcutDeclaration;
 	}
 
+	/**
+	 * This method may not return all fields, for example it may
+	 * not include the ajc$initFailureCause or ajc$perSingletonInstance
+	 * fields - see bug 129613
+	 */
 	public ResolvedMember[] getDeclaredFields() {
 		if (declaredFields == null) fillDeclaredMembers();
 		return declaredFields;
 	}
 
+	/**
+	 * This method may not return all methods, for example it may
+	 * not include clinit, aspectOf, hasAspect or ajc$postClinit 
+	 * methods - see bug 129613
+	 */
 	public ResolvedMember[] getDeclaredMethods() {
 		if (declaredMethods == null) fillDeclaredMembers();
 		return declaredMethods;
@@ -34,6 +34,7 @@ import org.aspectj.asm.IRelationshipMap;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.Message;
 import org.aspectj.bridge.SourceLocation;
+import org.aspectj.org.eclipse.jdt.core.compiler.CharOperation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.aspectj.org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.aspectj.org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
@@ -44,6 +45,7 @@ import org.aspectj.org.eclipse.jdt.internal.core.builder.ReferenceCollection;
 import org.aspectj.org.eclipse.jdt.internal.core.builder.StringSet;
 import org.aspectj.util.FileUtil;
 import org.aspectj.weaver.IWeaver;
+import org.aspectj.weaver.NameMangler;
 import org.aspectj.weaver.ReferenceType;
 import org.aspectj.weaver.ResolvedMember;
 import org.aspectj.weaver.ResolvedType;
@@ -816,12 +818,12 @@ public class AjState {
 		}
 
 		// generic signature
-		if (!equal(reader.getGenericSignature(),existingType.genericSignature)) {
+		if (!CharOperation.equals(reader.getGenericSignature(),existingType.genericSignature)) {
 			return true;
 		}
 
 		// superclass name
-		if (!equal(reader.getSuperclassName(),existingType.superclassName)) {
+		if (!CharOperation.equals(reader.getSuperclassName(),existingType.superclassName)) {
 			return true;
 		}
 
@@ -835,7 +837,7 @@ public class AjState {
 		}
 		new_interface_loop: for (int i = 0; i < newIfs.length; i++) {
 			for (int j = 0; j < existingIfs.length; j++) {
-				if (equal(existingIfs[j],newIfs[i])) {
+				if (CharOperation.equals(existingIfs[j],newIfs[i])) {
 					continue new_interface_loop;
 				}
 			}
@@ -846,17 +848,27 @@ public class AjState {
 		MemberStructure[] existingFields = existingType.fields;
 		IBinaryField[] newFields = reader.getFields();
 		if (newFields == null) { newFields = new IBinaryField[0]; }
-		if (newFields.length != existingFields.length) {
+		// remove any ajc$XXX fields from those we compare with
+		// the existing fields - bug 129163
+		List nonGenFields = new ArrayList();
+		for (int i = 0; i < newFields.length; i++) {
+			IBinaryField field = newFields[i];
+			if (!CharOperation.prefixEquals(NameMangler.AJC_DOLLAR_PREFIX,field.getName())) {
+					nonGenFields.add(field);
+			}
+		}
+		if (nonGenFields.size() != existingFields.length) {
 			return true;
 		}
-		new_field_loop: for (int i = 0; i < newFields.length; i++) {
-			char[] fieldName = newFields[i].getName();
+		new_field_loop: for (Iterator iter = nonGenFields.iterator(); iter.hasNext();) {
+			IBinaryField field = (IBinaryField) iter.next();
+			char[] fieldName = field.getName();
 			for (int j = 0; j < existingFields.length; j++) {
-				if (equal(existingFields[j].name,fieldName)) {
-					if (!modifiersEqual(newFields[i].getModifiers(),existingFields[j].modifiers)) {
+				if (CharOperation.equals(existingFields[j].name,fieldName)) {
+					if (!modifiersEqual(field.getModifiers(),existingFields[j].modifiers)) {
 						return true;
 					}
-					if (!equal(existingFields[j].signature,newFields[i].getTypeName())) {
+					if (!CharOperation.equals(existingFields[j].signature,field.getTypeName())) {
 						return true;
 					}
 					continue new_field_loop;
@@ -869,20 +881,34 @@ public class AjState {
 		MemberStructure[] existingMethods = existingType.methods;
 		IBinaryMethod[] newMethods = reader.getMethods();
 		if (newMethods == null) { newMethods = new IBinaryMethod[0]; }
-		if (newMethods.length != existingMethods.length) {
+		// remove the aspectOf, hasAspect, clinit and ajc$XXX methods 
+		// from those we compare with the existing methods - bug 129163
+		List nonGenMethods = new ArrayList();
+		for (int i = 0; i < newMethods.length; i++) {
+			IBinaryMethod method = newMethods[i];
+			char[] methodName = method.getSelector();
+			if (!CharOperation.equals(methodName,NameMangler.METHOD_ASPECTOF) && 
+				!CharOperation.equals(methodName,NameMangler.METHOD_HASASPECT) &&
+				!CharOperation.equals(methodName,NameMangler.STATIC_INITIALIZER) && 
+				!CharOperation.prefixEquals(NameMangler.AJC_DOLLAR_PREFIX,methodName)) {
+				nonGenMethods.add(method);
+			}
+		}
+		if (nonGenMethods.size() != existingMethods.length) {
 			return true;
 		}
-		new_method_loop: for (int i = 0; i < newMethods.length; i++) {
-			char[] methodName = newMethods[i].getSelector();
+		new_method_loop: for (Iterator iter = nonGenMethods.iterator(); iter.hasNext();) {
+			IBinaryMethod method = (IBinaryMethod) iter.next();
+			char[] methodName = method.getSelector();
 			for (int j = 0; j < existingMethods.length; j++) {
-				if (equal(existingMethods[j].name,methodName)) {
+				if (CharOperation.equals(existingMethods[j].name,methodName)) {
 					// candidate match
-					if (!equal(newMethods[i].getMethodDescriptor(),existingMethods[j].signature)) {
+					if (!CharOperation.equals(method.getMethodDescriptor(),existingMethods[j].signature)) {
 						continue; // might be overloading
 					} 
 					else {
 						// matching sigs
-						if (!modifiersEqual(newMethods[i].getModifiers(),existingMethods[j].modifiers)) {
+						if (!modifiersEqual(method.getModifiers(),existingMethods[j].modifiers)) {
 							return true;
 						}
 						continue new_method_loop;
@@ -904,22 +930,6 @@ public class AjState {
 		return (eclipseModifiers == resolvedTypeModifiers);
 	}
 
-	private boolean equal(char[] c1, char[] c2) {
-		if (c1 == null && c2 == null) {
-			return true;
-		}
-		if (c1 == null || c2 == null) {
-			return false;
-		}
-		if (c1.length != c2.length) {
-			return false;
-		}
-		for (int i = 0; i < c1.length; i++) {
-			if (c1[i] != c2[i]) return false;
-		}
-		return true;
-	}
-	
 	private static StringSet makeStringSet(List strings) {
 		StringSet ret = new StringSet(strings.size());
 		for (Iterator iter = strings.iterator(); iter.hasNext();) {
@@ -20,9 +20,12 @@ public class NameMangler {
 	private NameMangler() {
 		throw new RuntimeException("static");
 	}
-	
+	public static final char[] AJC_DOLLAR_PREFIX = {'a', 'j', 'c','$'};
 	public static final String PREFIX = "ajc$";
 	public static final String ITD_PREFIX = PREFIX + "interType$";
+	public static final char[] METHOD_ASPECTOF = {'a', 's', 'p','e','c','t','O','f'};
+	public static final char[] METHOD_HASASPECT = {'h', 'a', 's','A','s','p','e','c','t'};
+	public static final char[] STATIC_INITIALIZER = {'<', 'c', 'l','i','n','i','t','>'};
 
 	public static final String CFLOW_STACK_TYPE = "org.aspectj.runtime.internal.CFlowStack";
 	public static final String CFLOW_COUNTER_TYPE="org.aspectj.runtime.internal.CFlowCounter";
@@ -406,4 +406,6 @@ public abstract class ResolvedTypeMunger {
 	public boolean isLateMunger() {
 		return false;
 	}
+	
+	
 }
@@ -85,5 +85,8 @@ public class BcelCflowCounterFieldAdder extends BcelTypeMunger {
 	public boolean matches(ResolvedType onType) {
 		return onType.equals(cflowCounterField.getDeclaringType());
 	}
+	public boolean existsToSupportShadowMunging() {
+		return true;
+	}
 
 }
@@ -74,5 +74,8 @@ public class BcelCflowStackFieldAdder extends BcelTypeMunger {
 	public boolean matches(ResolvedType onType) {
 		return onType.equals(cflowStackField.getDeclaringType());
 	}
+	public boolean existsToSupportShadowMunging() {
+		return true;
+	}
 
 }
@@ -1644,5 +1644,21 @@ public class BcelTypeMunger extends ConcreteTypeMunger {
 	public List /*String*/ getTypeVariableAliases() {
 		return munger.getTypeVariableAliases();
 	}
+	
+	/**
+	 * Some type mungers are created purely to help with the implementation of shadow mungers.  
+	 * For example to support the cflow() pointcut we create a new cflow field in the aspect, and
+	 * that is added via a BcelCflowCounterFieldAdder.
+	 * 
+	 * During compilation we need to compare sets of type mungers, and if some only come into
+	 * existence after the 'shadowy' type things have been processed, we need to ignore
+	 * them during the comparison.
+	 * 
+	 * Returning true from this method indicates the type munger exists to support 'shadowy' stuff -
+	 * and so can be ignored in some comparison.
+	 */
+	public boolean existsToSupportShadowMunging() {
+		return false; // Does this need to delegate to the ResolvedTypeMunger field held in the BcelTypeMunger?
+	}
 }
 		
\ No newline at end of file
@@ -316,7 +316,7 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		checkForError("only abstract aspects can have type parameters");
 		alter("PR125405","inc2");
 		build("PR125405");
-		checkCompileWeaveCount(2,1);
+		checkCompileWeaveCount(1,1);
 		assertTrue("Should be no errors, but got "+MyTaskListManager.getErrorMessages(),MyTaskListManager.getErrorMessages().size()==0);		
 	}
 
@@ -560,7 +560,10 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		build("PR113257");
 		alter("PR113257","inc1");
 		build("PR113257");
-		checkWasFullBuild();  // back to the source
+		// THIS should be a full build, however, so that the patches
+		// for bug 129163 can be applied incrementally have changed this...
+		//checkWasFullBuild();  // back to the source
+		checkWasntFullBuild();
 		alter("PR113257","inc1");
 		build("PR113257");
 	}
@@ -570,7 +573,10 @@ public class MultiProjectIncrementalTests extends AjdeInteractionTestbed {
 		build("PR123612");
 		alter("PR123612","inc1");
 		build("PR123612");
-		checkWasFullBuild(); // back to the source
+		// THIS should be a full build, however, so that the patches
+		// for bug 129163 can be applied incrementally have changed this...
+		//checkWasFullBuild(); // back to the source
+		checkWasntFullBuild();
 	}
 
 
@@ -151,4 +151,21 @@ public class PerCflow extends PerClause {
 		if (isBelow) return  "percflowbelow(" + entry + ")";
 		return "percflow(" + entry + ")";
 	}
+	
+    public boolean equals(Object other) {
+    	if (!(other instanceof PerCflow)) return false;
+    	PerCflow pc = (PerCflow)other;   
+    	return (pc.isBelow && isBelow)
+    			&& ((pc.inAspect == null) ? (inAspect == null) : pc.inAspect.equals(inAspect))
+    			&& ((pc.entry == null) ? (entry == null) : pc.entry.equals(entry));
+    }
+    
+    public int hashCode() {
+        int result = 17;
+        result = 37*result + (isBelow?0:1);
+        result = 37*result + ((inAspect == null) ? 0 : inAspect.hashCode());
+        result = 37*result + ((entry == null) ? 0 : entry.hashCode());   
+        return result;
+    }
+	
 }
@@ -116,4 +116,19 @@ public class PerFromSuper extends PerClause {
 		return kind;
 	}
 
+    public boolean equals(Object other) {
+    	if (!(other instanceof PerFromSuper)) return false;
+    	PerFromSuper pc = (PerFromSuper)other;   
+    	return pc.kind.equals(kind) 
+    			&& ((pc.inAspect == null) ? (inAspect == null) : pc.inAspect.equals(inAspect));
+    }
+    
+    public int hashCode() {
+        int result = 17;
+        result = 37*result + kind.hashCode();
+        result = 37*result + ((inAspect == null) ? 0 : inAspect.hashCode());     
+        return result;
+    }
+    
+	
 }
@@ -171,4 +171,20 @@ public class PerObject extends PerClause {
 	public Pointcut getEntry() {
 		return entry;
 	}
+	
+    public boolean equals(Object other) {
+    	if (!(other instanceof PerObject)) return false;
+    	PerObject pc = (PerObject)other;   
+    	return (pc.isThis && isThis)
+    			&& ((pc.inAspect == null) ? (inAspect == null) : pc.inAspect.equals(inAspect))
+    			&& ((pc.entry == null) ? (entry == null) : pc.entry.equals(entry));
+    }
+    
+    public int hashCode() {
+        int result = 17;
+        result = 37*result + (isThis?0:1);
+        result = 37*result + ((inAspect == null) ? 0 : inAspect.hashCode());
+        result = 37*result + ((entry == null) ? 0 : entry.hashCode());   
+        return result;
+    }
 }
@@ -144,4 +144,16 @@ public class PerSingleton extends PerClause {
 		return "";
 	}
 
+    public boolean equals(Object other) {
+    	if (!(other instanceof PerSingleton)) return false;
+    	PerSingleton pc = (PerSingleton)other;   
+    	return ((pc.inAspect == null) ? (inAspect == null) : pc.inAspect.equals(inAspect));
+    }
+    
+    public int hashCode() {
+        int result = 17;
+        result = 37*result + ((inAspect == null) ? 0 : inAspect.hashCode());
+        return result;
+    }
+	
 }
@@ -209,4 +209,19 @@ public class PerTypeWithin extends PerClause {
 		}
 		return FuzzyBoolean.NO;
 	}
+	
+    public boolean equals(Object other) {
+    	if (!(other instanceof PerTypeWithin)) return false;
+    	PerTypeWithin pc = (PerTypeWithin)other;   
+    	return ((pc.inAspect == null) ? (inAspect == null) : pc.inAspect.equals(inAspect))
+    	   		&& ((pc.typePattern == null) ? (typePattern == null) : pc.typePattern.equals(typePattern));
+    }
+    
+    public int hashCode() {
+        int result = 17;
+        result = 37*result + ((inAspect == null) ? 0 : inAspect.hashCode());
+        result = 37*result + ((typePattern == null) ? 0 : typePattern.hashCode());
+        return result;
+    }
+	
 }
