@@ -0,0 +1,11 @@
+import java.util.*;
+
+interface AspectInterface<T, S> { }
+
+abstract aspect AbstractAspect<T> implements AspectInterface<T, Integer> {}	
+
+aspect ConcreteAspect extends AbstractAspect<String> { 
+
+  public static void main(String []argv) {
+  }
+}
@@ -0,0 +1,20 @@
+import java.util.*;
+
+abstract aspect AbstractAspect<T> implements AspectInterface<T, Integer> {}	
+
+interface AspectInterface<T, S extends Number> { }
+
+aspect ConcreteAspect extends AbstractAspect<Student> { 
+  public static void main(String []argv) {
+  }
+}
+
+class Student {
+    private String name;
+    
+    public Student(String n) {
+	name = n;
+    }
+    
+    public String toString() { return name; }
+}
@@ -14,6 +14,7 @@ import java.io.File;
 
 import junit.framework.Test;
 
+import org.aspectj.systemtest.ajc150.GenericsTests;
 import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc151Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
@@ -30,6 +31,19 @@ public class Ajc151Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   //public void testIncorrectlyReferencingPointcuts_pr122452()    { runTest("incorrectly referencing pointcuts");}
   //public void testIncorrectlyReferencingPointcuts_pr122452_2()    { runTest("incorrectly referencing pointcuts - 2");}
 
+  public void testMixingNumbersOfTypeParameters_pr125080()   { 
+	  runTest("mixing numbers of type parameters");    
+	  GenericsTests.verifyClassSignature(ajc,"AspectInterface","<T:Ljava/lang/Object;S:Ljava/lang/Object;>Ljava/lang/Object;");
+	  GenericsTests.verifyClassSignature(ajc,"AbstractAspect","<T:Ljava/lang/Object;>Ljava/lang/Object;LAspectInterface<TT;Ljava/lang/Integer;>;");
+	  GenericsTests.verifyClassSignature(ajc,"ConcreteAspect","LAbstractAspect<Ljava/lang/String;>;");
+  }
+  
+  public void testMixingNumbersOfTypeParameters_pr125080_2() { 
+	  runTest("mixing numbers of type parameters - 2"); 
+	  GenericsTests.verifyClassSignature(ajc,"AspectInterface","<T:Ljava/lang/Object;S:Ljava/lang/Number;>Ljava/lang/Object;");
+	  GenericsTests.verifyClassSignature(ajc,"AbstractAspect","<T:Ljava/lang/Object;>Ljava/lang/Object;LAspectInterface<TT;Ljava/lang/Integer;>;");
+	  GenericsTests.verifyClassSignature(ajc,"ConcreteAspect","LAbstractAspect<LStudent;>;");
+  }
 
   /////////////////////////////////////////
   public static Test suite() {
@@ -77,5 +77,15 @@
     <ajc-test dir="bugs151" title="incorrectly referencing pointcuts - 2">
         <compile files="pr122452_2.aj" options="-1.5"/>
     </ajc-test>
+    
+    <ajc-test dir="bugs151/pr125080" title="mixing numbers of type parameters">
+        <compile files="Test.java" options="-1.5"/>
+        <run class="ConcreteAspect"/>
+    </ajc-test>
+    
+    <ajc-test dir="bugs151/pr125080" title="mixing numbers of type parameters - 2">
+        <compile files="Test2.java" options="-1.5"/>
+        <run class="ConcreteAspect"/>
+    </ajc-test>
 
 </suite>
\ No newline at end of file
@@ -386,28 +386,14 @@ public class ReferenceType extends ResolvedType {
 			UnresolvedType[] paramTypes = getTypesForMemberParameterization();
 			parameterizedInterfaces = new ResolvedType[delegateInterfaces.length];
 			for (int i = 0; i < delegateInterfaces.length; i++) {
-				// We may have to subset the set of parametertypes if the implemented interface
-				// needs less than this type does. (pr124803)
+				// We may have to sub/super set the set of parametertypes if the implemented interface
+				// needs more or less than this type does. (pr124803/pr125080)
 
-				// wonder if this could be done with getMemberParameterizationMap() like it is in getSuperclass()?? Something like:
-//				parameterizedInterfaces[i] = delegateInterfaces[i].parameterize(getMemberParameterizationMap()).resolve(world);
-				TypeVariable[] tvarsOnImplementedInterface = delegateInterfaces[i].getTypeVariables();
-				TypeVariable[] tvarsOnThisGenericType = this.genericType.getTypeVariables();
-				ResolvedType parameterizedInterface = null;
-				if (tvarsOnImplementedInterface!=null && tvarsOnThisGenericType!=null) {
-					if (tvarsOnImplementedInterface.length<tvarsOnThisGenericType.length) {
-						// implemented interface is something like 'Generic<T>' where thisGenericType is something like 'Generic<T,Y>'
-						// we need to subset the type parameters based on their name
-						UnresolvedType[] subsetParameterTypes = new ResolvedType[tvarsOnImplementedInterface.length];
-						for (int j = 0; j < subsetParameterTypes.length; j++) {
-							subsetParameterTypes[j] = findTypeParameterInList(tvarsOnImplementedInterface[j].getName(),tvarsOnThisGenericType,paramTypes);
-						}
-						parameterizedInterface = delegateInterfaces[i].parameterizedWith(subsetParameterTypes);
-					}
+				if (delegateInterfaces[i].isParameterizedType()) {
+					parameterizedInterfaces[i] = delegateInterfaces[i].parameterize(getMemberParameterizationMap()).resolve(world);
+				} else {
+					parameterizedInterfaces[i] = delegateInterfaces[i];
 				}
-				if (parameterizedInterface==null) parameterizedInterface = delegateInterfaces[i].parameterizedWith(paramTypes);
-				
-				parameterizedInterfaces[i] = parameterizedInterface;
 			}
 			return parameterizedInterfaces;
 		} else if (isRawType()){
