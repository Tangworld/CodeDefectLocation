@@ -13,7 +13,7 @@
 	<classpathentry sourcepath="/lib/bcel/bcel-src.zip" kind="lib" path="/lib/bcel/bcel.jar"/>
 	<classpathentry kind="lib" path="/lib/ant/lib/ant-launcher.jar"/>
 	<classpathentry kind="src" path="testsrc"/>
-	<classpathentry kind="var" path="JAVA_HOME/lib/tools.jar"/>
+	<classpathentry kind="var" path="JAVA_HOME/lib/dt.jar"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/weaver"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
@@ -0,0 +1,66 @@
+public aspect Pr103157 {
+	
+	// verify after returning behaviour with join points that have no "return" value
+	
+	// these are: 
+	// ConstructorExecution
+	// FieldSet
+	// StaticInitialization
+	// Initialization
+	// PreInitialization
+	// ExceptionHandler  -- but handler can't have after returning advice anyway
+	// arguably all adviceexecution join points except for around, but allow this for now
+	
+	after() returning(Object obj) : execution(C.new(..)) {
+		System.out.println("returning obj on cons exe " + obj);
+	}
+	
+	after() returning : execution(C.new(..)) {
+		System.out.println("returning from cons exe");
+	}
+	
+	after() returning(Object obj) : set(* C.*) {
+		System.out.println("returning obj on set " + obj);		
+	}
+	
+	after() returning : set(* C.*) {
+		System.out.println("returning from set");		
+	}
+	
+	after() returning(Object obj) : staticinitialization(C) {
+		System.out.println("returning obj on staticinit " + obj);		
+	}
+	
+	after() returning : staticinitialization(C) {
+		System.out.println("returning from staticinit");		
+	}	
+	
+	after() returning(Object obj) : initialization(C.new(..)) {
+		System.out.println("returning obj on init " + obj);
+	}
+	
+	after() returning : initialization(C.new(..)) {
+		System.out.println("returning from init");
+	}
+
+	after() returning(Object obj) : preinitialization(C.new(..)) {
+		System.out.println("returning obj on preinit " + obj);
+	}
+	
+	after() returning : preinitialization(C.new(..)) {
+		System.out.println("returning from preinit");
+	}
+	
+	public static void main(String[] args) {
+		new C();
+	}
+
+}
+
+class C {
+
+	String s;
+	
+	public C() { this.s = "xxx"; }
+	
+}
\ No newline at end of file
@@ -1,36 +1,52 @@
+
 public aspect Pr113368 {
-	
-	private pointcut managedBeanConstruction(ManagedBean bean) : 
-        execution(ManagedBean+.new(..)) && this(bean); 
+    
+    public static void main(String[] args) {
+    	try {
+    		aspectOf().hook();
+    	}  catch (ExceptionInInitializerError ex) {
+    		Throwable cause = ex.getCause();
+    		if (! (cause instanceof org.aspectj.lang.NoAspectBoundException)) {
+    			throw new RuntimeException("Unexpected exception: " + cause);
+    		}
+    	}
+    }
+    
+    void hook() {}
 
+    private pointcut managedBeanConstruction(ManagedBean bean) : 
+        execution(ManagedBean+.new(..)) && this(bean); 
+    
     //NPE's on the if pointcut below    
     private pointcut topLevelManagedBeanConstruction(ManagedBean bean) : 
         managedBeanConstruction(bean) && 
         if(thisJoinPointStaticPart.getSignature().getDeclaringType() == bean.getClass()); 
 
     after(ManagedBean bean) returning: topLevelManagedBeanConstruction(bean) {
-    		System.out.println("I just constructed " + bean);
+            System.out.println("I just constructed " + bean);
     }
 
-    public static void main(String[] args) {
-    		new ManagedBean("super-bean");
-    		new ManagedSubBean();
+}
+
+abstract aspect ManagedBean {
+}
+
+
+aspect ManagedSubBean extends ManagedBean {
+
+    before() : execution(* hook()) {        
     }
 
 }
 
-class ManagedBean {
-	
-	public ManagedBean(String s) {
-		System.out.println(s);
-	}
+aspect AutoStart {
+    before() : staticinitialization(ManagedBean) {
+        ManagedSubBean.aspectOf();
+    }
 }
 
-
-class ManagedSubBean extends ManagedBean {
-	
-	public ManagedSubBean() {
-		super("sub-bean");
-	}
-	
-}
\ No newline at end of file
+aspect Tracer {
+    before() : !within(Tracer) {
+		System.out.println(thisJoinPoint);
+}
+}
@@ -4,7 +4,8 @@ public class AfterReturningParam {
     public static void main(String[] args) {
 
         AfterReturningParam p = new AfterReturningParam();
-        Tester.checkAndClearEvents(new String[] { "constr exec as Object null" });
+ //       Tester.checkAndClearEvents(new String[] { "constr exec as Object null" });
+ //        see pr 103157 for reason why this no longer matches
 
         p.mInt();
         Tester.checkAndClearEvents(new String[] { "int as Object 2" });
@@ -36,6 +37,7 @@ aspect A {
         callEvent("constr exec as constd object", o); 
     }
     after() returning (Object o) : execution(AfterReturningParam.new()) {  // CW 38 in 1.0.4, does match
+    	                                                                       // in 1.5 does not match - no return value for this jp
         callEvent("constr exec as Object", o);
     }
     after() returning (String o) : execution(AfterReturningParam.new()) {  // CW 41 in 1.0.4, no match
@@ -20,7 +20,7 @@ aspect A {
     after (Object target) : execution(*.new(..)) && target(target) && !within(A) { 
         Tester.event("execution");
     }
-    after () returning (Object target) : initialization(new(..)) && !this(A) { 
+    after () returning : initialization(new(..)) && !this(A) { 
         Tester.event("initialization");
     }
 }
@@ -35,7 +35,7 @@ abstract aspect A {
 	 //&& initialization(new(..)) ;
          && initialization(I.new(..)) ;
 
-     after() returning(Object o): j() {
+     after() returning: j() {
 	 Tester.note("advised default constructor");
 	 count++;
      }
@@ -734,6 +734,10 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	  runTest("declare soft and exclusions");
   }
 
+  public void testReturningObjectBinding() {
+	  runTest("returning(Object) binding");
+  }
+  
   /*
    * Load-time weaving bugs
    */
@@ -60,7 +60,8 @@
 
     <ajc-test dir="bugs150" pr="113368" title="thisJoinPointStaticPart in if test">
     		<compile files="Pr113368.aj"/>
-    		<run class="Pr113368"/>
+    		<run class="Pr113368">
+    		</run>
     </ajc-test>
 
     <ajc-test dir="bugs150/pr87525" pr="87525" title="privilege problem with switch">
@@ -88,6 +89,19 @@
 		</run>
 	</ajc-test>
 
+	<ajc-test dir="bugs150" pr="103157" title="returning(Object) binding">
+		<compile files="Pr103157.aj"/>
+		<run class="Pr103157">
+			<stdout>
+				<line text="returning from staticinit"/>
+				<line text="returning from preinit"/>
+				<line text="returning from set"/>
+				<line text="returning from cons exe"/>
+				<line text="returning from init"/>
+			</stdout>
+		</run>
+	</ajc-test>
+	
 	<ajc-test dir="bugs150" title="declare soft and adviceexecution" pr="103051">
 		<compile files="Pr103051.aj" options="-Xdev:Pinpoint"/>
 	</ajc-test>
@@ -120,7 +120,9 @@ public abstract class Advice extends ShadowMunger {
     		if (hasExtraParameter() && kind == AdviceKind.AfterReturning) {
     			ResolvedType resolvedExtraParameterType = getExtraParameterType().resolve(world);
     			ResolvedType shadowReturnType = shadow.getReturnType().resolve(world);
-    			boolean matches = resolvedExtraParameterType.isConvertableFrom(shadowReturnType);
+    			boolean matches = 
+    				(resolvedExtraParameterType.isConvertableFrom(shadowReturnType) &&
+    				 shadow.getKind().hasReturnValue());
     			if (matches && resolvedExtraParameterType.isParameterizedType()) {
     				maybeIssueUncheckedMatchWarning(resolvedExtraParameterType,shadowReturnType,shadow,world);
     			}
@@ -280,6 +280,20 @@ public abstract class Shadow {
 			return !isTargetSameAsThis();
 		}
 
+		/**
+		 * These shadow kinds have return values that can be bound in
+		 * after returning(Dooberry doo) advice.
+		 * @return
+		 */
+		public boolean hasReturnValue() {
+			return 
+				this == MethodCall ||
+				this == ConstructorCall ||
+				this == MethodExecution ||
+				this == FieldGet ||
+				this == AdviceExecution;
+		}
+		
 
 		/**
 		 * These are all the shadows that contains other shadows within them and
