@@ -122,14 +122,22 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		AnonymousClassPublisher.aspectOf().setAnonymousClassCreationListener(this);
 
 		// need to build inter-type declarations for all AspectDeclarations at this point
-        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
-            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
-            for (int j = 0; j < b.length; j++) {
-                buildInterTypeAndPerClause(b[j].scope);
-                addCrosscuttingStructures(b[j].scope);
-            }
-        }        
+		// this MUST be done in order from super-types to subtypes
+		List typesToProcess = new ArrayList();
+		for (int i=lastCompletedUnitIndex+1; i<=lastUnitIndex; i++) {
+			CompilationUnitScope cus = units[i].scope;
+			SourceTypeBinding[] stbs = cus.topLevelTypes;
+			for (int j=0; j<stbs.length; j++) {
+				SourceTypeBinding stb = stbs[j];
+				typesToProcess.add(stb);
+			}
+		}
 
+		while (typesToProcess.size()>0) {
+			// removes types from the list as they are processed...
+			collectAllITDsAndDeclares((SourceTypeBinding)typesToProcess.get(0),typesToProcess);
+		}		
+				
 		factory.finishTypeMungers();
 
 		// now do weaving
@@ -156,7 +164,7 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		boolean typeProcessingOrderIsImportant = declareParents.size()>0 || declareAnnotationOnTypes.size()>0; //DECAT
 
 		if (typeProcessingOrderIsImportant) {
-			List typesToProcess = new ArrayList();
+			typesToProcess = new ArrayList();
 			for (int i=lastCompletedUnitIndex+1; i<=lastUnitIndex; i++) {
 				CompilationUnitScope cus = units[i].scope;
 				SourceTypeBinding[] stbs = cus.topLevelTypes;
@@ -201,6 +209,24 @@ public class AjLookupEnvironment extends LookupEnvironment implements AnonymousC
 		lastCompletedUnitIndex = lastUnitIndex;
 	}
 
+	
+	/**
+	 * Find all the ITDs and Declares, but it is important we do this from the supertypes
+	 * down to the subtypes.
+	 * @param sourceType
+	 * @param yetToProcess
+	 */
+	private void collectAllITDsAndDeclares(SourceTypeBinding sourceType, Collection yetToProcess) {
+		// Look at the supertype first
+	    ReferenceBinding superType = sourceType.superclass();
+	    if (yetToProcess.contains(superType) && superType instanceof SourceTypeBinding) {
+	    	collectAllITDsAndDeclares((SourceTypeBinding)superType, yetToProcess);
+	    }
+        buildInterTypeAndPerClause(sourceType.scope);
+        addCrosscuttingStructures(sourceType.scope);
+        yetToProcess.remove(sourceType);
+	}
+	
 	/**
 	 * Weave the parents and intertype decls into a given type.  This method looks at the
 	 * supertype and superinterfaces for the specified type and recurses to weave those first
@@ -27,7 +27,6 @@ import org.aspectj.ajdt.internal.core.builder.AjBuildManager;
 import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.bridge.IMessage.Kind;
 import org.aspectj.org.eclipse.jdt.core.compiler.CharOperation;
-import org.aspectj.org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
@@ -0,0 +1,19 @@
+/**
+ * 
+ */
+package com.designpattern.decorator;
+
+public aspect HeaderDecorator extends OrderDecorator 
+{
+	
+	void around(Order order) : print(order)
+	{
+		printHeader(order);
+		proceed(order);
+	}
+
+	private void printHeader(Order order)
+	{
+		System.out.println("XYZ Incorporated\nDate of Sale:");
+	}
+}
@@ -0,0 +1,11 @@
+package com.designpattern.decorator;
+
+public class Main {
+	private static Order order;
+
+	public static void main(String[] args) {
+		order = new SalesOrder();
+		order.print();
+
+	}
+}
@@ -0,0 +1,9 @@
+package com.designpattern.decorator;
+
+public abstract class Order {
+
+	public void print() {
+        System.out.print("Order.print()") ;
+	}
+
+}
@@ -0,0 +1,17 @@
+/**
+ * 
+ */
+package com.designpattern.decorator;
+
+public abstract aspect OrderDecorator
+{
+    protected pointcut print(Order order) : target(order) && call(public void print());
+
+    declare parents : SalesOrder extends Order ;
+
+    public void SalesOrder.print()
+    {
+        super.print();
+    }
+
+}
@@ -0,0 +1,5 @@
+package com.designpattern.decorator;
+
+public class SalesOrder {
+
+}
@@ -405,7 +405,11 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testSuperCallInITD() {
 	  runTest("super call in ITD");
   }
-  
+
+  public void testSuperCallInITDPart2() {
+	  runTest("super call in ITD - part 2");
+  }
+
   public void testNoUnusedParameterWarningsForSyntheticAdviceArgs() {
 	  runTest("no unused parameter warnings for synthetic advice args");
   }
@@ -417,6 +421,8 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testCantFindTypeErrorWithGenericReturnTypeOrParameter() {
 	  runTest("cant find type error with generic return type or parameter");
   }
+
+ 
 
 // currently failing...
 //  public void testNoVerifyErrorOnGenericCollectionMemberAccess() {
@@ -542,7 +542,12 @@
         </compile>
         <run class="pr105181"/>
     </ajc-test> 
-       
+
+    <ajc-test dir="bugs150/pr108903" pr="108903" title="super call in ITD - part 2">
+        <compile files="com/designpattern/decorator/HeaderDecorator.aj,com/designpattern/decorator/Main.java,com/designpattern/decorator/Order.java,com/designpattern/decorator/OrderDecorator.aj,com/designpattern/decorator/SalesOrder.java" options="-1.5" >
+        </compile>
+    </ajc-test> 
+        
     <!-- ============================================================================ -->
     <!-- ============================================================================ -->
 
