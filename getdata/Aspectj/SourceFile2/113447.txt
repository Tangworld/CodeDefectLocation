@@ -437,6 +437,9 @@ public class BcelWeaver implements IWeaver {
 
 		shadowMungerList = xcutSet.getShadowMungers();
 		rewritePointcuts(shadowMungerList);
+		// Sometimes an error occurs during rewriting pointcuts (for example, if ambiguous bindings
+		// are detected) - we ought to fail the prepare when this happens because continuing with
+		// inconsistent pointcuts could lead to problems
 		typeMungerList = xcutSet.getTypeMungers();
         lateTypeMungerList = xcutSet.getLateTypeMungers();
 		declareParentsList = xcutSet.getDeclareParents();
@@ -197,18 +197,7 @@ public class AnnotationPointcut extends NameBindingPointcut {
 			if (var == null) throw new BCException("Impossible! annotation=["+annotationType+
 					                               "]  shadow=["+shadow+" at "+shadow.getSourceLocation()+
 												   "]    pointcut is at ["+getSourceLocation()+"]");//return Literal.FALSE;
-			// Check if we have already bound something to this formal
-			if ((state.get(btp.getFormalIndex())!=null) &&(lastMatchedShadowId == shadow.shadowId)) {
-//				ISourceLocation pcdSloc = getSourceLocation(); 
-//				ISourceLocation shadowSloc = shadow.getSourceLocation();
-//				Message errorMessage = new Message(
-//					"Cannot use @pointcut to match at this location and bind a formal to type '"+var.getType()+
-//					"' - the formal is already bound to type '"+state.get(btp.getFormalIndex()).getType()+"'"+
-//					".  The secondary source location points to the problematic binding.",
-//					shadowSloc,true,new ISourceLocation[]{pcdSloc}); 
-//				shadow.getIWorld().getMessageHandler().handleMessage(errorMessage);
-				state.setErroneousVar(btp.getFormalIndex());
-			}
+
 			state.set(btp.getFormalIndex(),var);
 		}
 		if (matchInternal(shadow).alwaysTrue()) 
@@ -212,19 +212,6 @@ public class ArgsPointcut extends NameBindingPointcut {
 				if (type.matchesInstanceof(argRTX).alwaysTrue()) {
 					continue;
 				}
-			} else {
-			  BindingTypePattern btp = (BindingTypePattern)type;
-			  // Check if we have already bound something to this formal
-			  if ((state.get(btp.getFormalIndex())!=null) &&(lastMatchedShadowId != shadow.shadowId)) {
-//			  	ISourceLocation isl = getSourceLocation();
-//				Message errorMessage = new Message(
-//                    "Ambiguous binding of type "+type.getExactType().toString()+
-//                    " using args(..) at this line - formal is already bound"+
-//                    ".  See secondary source location for location of args(..)",
-//					shadow.getSourceLocation(),true,new ISourceLocation[]{getSourceLocation()});
-//				shadow.getIWorld().getMessageHandler().handleMessage(errorMessage);
-				state.setErroneousVar(btp.getFormalIndex());
-			  }
 			}
 
 			World world = shadow.getIWorld();
@@ -16,6 +16,8 @@ package org.aspectj.weaver.patterns;
 import java.util.Arrays;
 
 import org.aspectj.weaver.Member;
+import org.aspectj.weaver.ResolvedType;
+import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.ast.Expr;
 import org.aspectj.weaver.ast.Var;
 
@@ -23,6 +25,7 @@ public class ExposedState {
 	public Var[] vars;
 	private boolean[] erroneousVars;
 	private Expr aspectInstance;
+	private UnresolvedType[] expectedVarTypes; // enables us to check that binding is occurring with the *right* types
 
 	public ExposedState(int size) {
 		super();
@@ -33,6 +36,13 @@ public class ExposedState {
 	public ExposedState(Member signature) {
 		// XXX there maybe something about target for non-static sigs
 		this(signature.getParameterTypes().length);
+		expectedVarTypes = new UnresolvedType[signature.getParameterTypes().length];
+		if (expectedVarTypes.length>0) {
+			for (int i = 0; i < signature.getParameterTypes().length; i++) {
+				expectedVarTypes[i] = signature.getParameterTypes()[i];
+			}
+		}
+		
 	}
 
 	public boolean isFullySetUp() {
@@ -43,12 +53,18 @@ public class ExposedState {
 	}
 
 	public void set(int i, Var var) {
-		//XXX add sanity checks
-		// Some checks added in ArgsPointcut and ThisOrTargetPointcut
-//		if (vars[i]!=null) {
-//			if (!var.getType().equals(vars[i].getType()))
-//			  throw new RuntimeException("Shouldn't allow a slot to change type! Currently="+var.getType()+"   New="+vars[i].getType());
-//		}
+		// check the type is OK if we can... these are the same rules as in matchesInstanceOf() processing
+		if (expectedVarTypes!=null) {
+			ResolvedType expected = expectedVarTypes[i].resolve(var.getType().getWorld());
+			if (!expected.equals(ResolvedType.OBJECT)) {
+				if (!expected.isAssignableFrom(var.getType())) {
+					if (!var.getType().isCoerceableFrom(expected)) {
+//						throw new BCException("Expected type "+expectedVarTypes[i]+" in slot "+i+" but attempt to put "+var.getType()+" into it");
+						return;
+					}
+				}
+			}
+		}
 		vars[i] = var;
 	}
     public Var get(int i) {
@@ -192,18 +192,7 @@ public class ThisOrTargetAnnotationPointcut extends NameBindingPointcut {
 				shadow.getTargetAnnotationVar(annotationType);
 			if (annVar == null)
 				throw new RuntimeException("Impossible!");
-			// Check if we have already bound something to this formal
-			if ((state.get(btp.getFormalIndex())!=null) &&(lastMatchedShadowId == shadow.shadowId)) {
-//				ISourceLocation pcdSloc = getSourceLocation(); 
-//				ISourceLocation shadowSloc = shadow.getSourceLocation();
-//				Message errorMessage = new Message(
-//					"Cannot use @pointcut to match at this location and bind a formal to type '"+annVar.getType()+
-//					"' - the formal is already bound to type '"+state.get(btp.getFormalIndex()).getType()+"'"+
-//					".  The secondary source location points to the problematic binding.",
-//					shadowSloc,true,new ISourceLocation[]{pcdSloc}); 
-//				shadow.getIWorld().getMessageHandler().handleMessage(errorMessage);
-				state.setErroneousVar(btp.getFormalIndex());
-			}
+
 			state.set(btp.getFormalIndex(),annVar);
 		}
 
@@ -169,31 +169,19 @@ public class ThisOrTargetPointcut extends NameBindingPointcut {
 		return (isThis ? "this(" : "target(") + type + ")";
 	}
 
+	/** 
+	 * Residue is the remainder of the pointcut match that couldn't be
+	 * performed with the purely static information at compile time and
+	 * this method returns the residue of a pointcut at a particular shadow.
+	 */
 	protected Test findResidueInternal(Shadow shadow, ExposedState state) {
 		if (!couldMatch(shadow)) return Literal.FALSE;
 
+		// if no preference is specified, just say TRUE which means no residue
 		if (type == TypePattern.ANY) return Literal.TRUE;
 
 		Var var = isThis ? shadow.getThisVar() : shadow.getTargetVar();	
 
-		if (type instanceof BindingTypePattern) {
-		  BindingTypePattern btp = (BindingTypePattern)type;
-		  // Check if we have already bound something to this formal
-		  Var existingVarInThisSlot = state.get(btp.getFormalIndex());
-		  
-		  if (existingVarInThisSlot != null ) {
-			  
-			// Is it already bound to exactly the same thing?
-			if (existingVarInThisSlot.equals(var)) return Literal.TRUE;
-			
-			// If state.get() returned non-null then someone has already bound the variable in that slot at
-			// the shadow 'shadow.shadowId'.  If our 'lastMatchedShadowId' is not the same as 'shadow.shadowId'
-			// then this pointcut wasn't involved in matching and so shouldn't contribute to binding - so just
-			// return Literal.TRUE meaning 'no residue'
-		    if (lastMatchedShadowId != shadow.shadowId) return Literal.TRUE;
-			state.setErroneousVar(btp.getFormalIndex());
-		  }
-		}
 		return exposeStateForVar(var, type, state, shadow.getIWorld());
 	}
 
@@ -137,18 +137,6 @@ public class WithinAnnotationPointcut extends NameBindingPointcut {
                         "]  shadow=["+shadow+" at "+shadow.getSourceLocation()+
 						   "]    pointcut is at ["+getSourceLocation()+"]");
 
-			// Check if we have already bound something to this formal
-			if ((state.get(btp.getFormalIndex())!=null)  &&(lastMatchedShadowId == shadow.shadowId)) {
-//				ISourceLocation pcdSloc = getSourceLocation(); 
-//				ISourceLocation shadowSloc = shadow.getSourceLocation();
-//				Message errorMessage = new Message(
-//					"Cannot use @pointcut to match at this location and bind a formal to type '"+var.getType()+
-//					"' - the formal is already bound to type '"+state.get(btp.getFormalIndex()).getType()+"'"+
-//					".  The secondary source location points to the problematic binding.",
-//					shadowSloc,true,new ISourceLocation[]{pcdSloc}); 
-//				shadow.getIWorld().getMessageHandler().handleMessage(errorMessage);
-				state.setErroneousVar(btp.getFormalIndex());
-			}
 			state.set(btp.getFormalIndex(),var);
 		} 
 		return Literal.TRUE;
@@ -150,18 +150,6 @@ public class WithinCodeAnnotationPointcut extends NameBindingPointcut {
                         "]  shadow=["+shadow+" at "+shadow.getSourceLocation()+
 						   "]    pointcut is at ["+getSourceLocation()+"]");
 
-			// Check if we have already bound something to this formal
-			if ((state.get(btp.getFormalIndex())!=null)  &&(lastMatchedShadowId == shadow.shadowId)) {
-//				ISourceLocation pcdSloc = getSourceLocation(); 
-//				ISourceLocation shadowSloc = shadow.getSourceLocation();
-//				Message errorMessage = new Message(
-//					"Cannot use @pointcut to match at this location and bind a formal to type '"+var.getType()+
-//					"' - the formal is already bound to type '"+state.get(btp.getFormalIndex()).getType()+"'"+
-//					".  The secondary source location points to the problematic binding.",
-//					shadowSloc,true,new ISourceLocation[]{pcdSloc}); 
-//				shadow.getIWorld().getMessageHandler().handleMessage(errorMessage);
-				state.setErroneousVar(btp.getFormalIndex());
-			}
 			state.set(btp.getFormalIndex(),var);
 		} 
 		return Literal.TRUE;
@@ -15,12 +15,13 @@ aspect Super {
 
 	// second method doesn't exist
 	pointcut pc1(PR113447 s) : 
-		(this(s) && execution(void method1()))
-		|| (this(s) && execution(void method2()));
+		(this(PR113447) && this(s) && execution(void method1()) && this(PR113447))
+		|| (this(s) && execution(void method2()) && this(PR113447));
 
 	before(PR113447 s) : pc1(s) {
 	}
 
+/*
 	// second method does exist
 	pointcut pc2(PR113447 s) : 
 		(this(s) && execution(void method1()))
@@ -36,5 +37,6 @@ aspect Super {
 
 	before(PR113447 s) : pc3(s) {
 	}
+*/
 
 }
@@ -0,0 +1,65 @@
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Annotation{};
+
+@Annotation
+public class PR113447a {
+
+	public static void main(String[] args) {
+		PR113447a me = new PR113447a();
+		me.method1();
+		me.method3();
+		me.method4(2);
+	}
+	
+	public void method1(){}
+
+	public void method3(){}
+	
+	public void method4(int i){}
+	public void method5(int i){}
+}
+
+aspect Super {
+
+	// second method doesn't exist
+	pointcut pc1(Annotation a) : 
+		(@this(a) && execution(void method1()))
+		|| (@this(a) && execution(void method2()));
+
+	before(Annotation a) : pc1(a) {}
+	
+	// second method does exist
+	pointcut pc2(Annotation a) : 
+		(@this(a) && execution(void method1()))
+		|| (@this(a) && execution(void method3()));
+
+	before(Annotation a) : pc2(a) {}
+	
+	// second method doesn't exist
+	pointcut pc3(Annotation a) : 
+		(@target(a) && call(void method1()))
+		|| (@target(a) && call(void method2()));
+
+	before(Annotation a) : pc3(a) {
+	}
+	
+	// second method does exist
+	pointcut pc4(Annotation a) : 
+		(@target(a) && call(void method1()))
+		|| (@target(a) && call(void method3()));
+
+	before(Annotation a) : pc4(a) {
+	}
+	
+	// @this equivalent of BaseTests.test024 which was affected by
+	// the fix for the non annotation version
+	pointcut p(Annotation a) : 
+		@target(a) && (call(void method4(int)) 
+				|| call(void method5(int)));
+
+	before(Annotation a) : p(a) {}
+	after(Annotation a): p(a) {}
+}
@@ -0,0 +1,27 @@
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Annotation{};
+
+@Annotation
+public class PR113447b {
+
+	public static void main(String[] args) {
+		PR113447b me = new PR113447b();
+		me.method4(1);
+	}
+	
+	public void method4(int i){}
+	public void method5(int i){}
+}
+
+aspect Super {
+
+	pointcut p(Annotation a) : 
+		@within(a) && (call(void method4(int)) 
+				|| call(void method5(int)));
+
+	before(Annotation a) : p(a) {}
+
+}
@@ -0,0 +1,27 @@
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Annotation{};
+
+public class PR113447c {
+
+	@Annotation
+	public static void main(String[] args) {
+		PR113447c me = new PR113447c();
+		me.method4(1);
+	}
+
+	public void method4(int i){}
+	public void method5(int i){}
+}
+
+aspect Super {
+
+	pointcut p(Annotation a) : 
+		@withincode(a) && (call(void method4(int)) 
+				|| call(void method5(int)));
+
+	before(Annotation a) : p(a) {}
+
+}
@@ -0,0 +1,25 @@
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+@interface Annotation{};
+
+public class PR113447d {
+
+	public static void main(String[] args) {
+		PR113447d me = new PR113447d();
+		me.method4(1);
+	}
+	
+	@Annotation public void method4(int i){}
+	@Annotation public void method5(int i){}
+}
+
+aspect Super {
+	
+	pointcut p(Annotation a) : 
+		@annotation(a) && (call(void method4(int)) 
+				|| call(void method5(int)));
+
+	before(Annotation a) : p(a) {}
+}
@@ -0,0 +1,36 @@
+public class PR113447e {
+
+	public static void main(String[] args) {
+		PR113447e me = new PR113447e();
+		me.method1(1);
+		me.method3(2);
+	}
+	
+	public void method1(int i){}
+
+	public void method3(int i){}
+}
+
+aspect Super {
+
+	// second method doesn't exist
+	pointcut pc1(int i) : 
+		(args(i) && call(void method1(int)))
+		|| (args(i) && call(void method2(int)));
+
+	before(int i) : pc1(i) {}
+	
+	// second method does exist
+	pointcut pc2(int i) : 
+		(args(i) && call(void method1(int)))
+		|| (args(i) && call(void method3(int)));
+
+	before(int i) : pc2(i) {}
+	
+	// ensure this still works
+	pointcut pc3(int i) :
+		args(i) && (call(void method1(int)) || call(void method2(int)));
+	
+	before(int i) : pc3(i) {}
+	after(int i) : pc3(i) {}
+}
@@ -658,10 +658,6 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	  runTest("weaveinfo message for declare at method on an ITDd method");
   }
 
-  public void testNoVerifyErrorWithTwoThisPCDs_pr113447() {
-	  runTest("no verify error with two this pcds");
-  }
-  
   public void testITDCWithNoExplicitConsCall() {
 	  runTest("ITDC with no explicit cons call");
   }
@@ -682,6 +678,31 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	  runTest("pointcut expression containing 'assert'");
   }
 
+  public void testNoVerifyErrorWithTwoThisPCDs_pr113447() {
+	  runTest("no verify error with two this pcds");
+  }
+
+  public void testNoVerifyErrorWithTwoAtThisPCDs_pr113447() {
+	  runTest("no verify error with two at this pcds");
+  }
+  
+  public void testNoVerifyErrorWithAtWithinPCDs_pr113447() {
+	  runTest("no verify error with at within pcds");
+  }
+  
+  public void testNoVerifyErrorWithAtWithincodePCDs_pr113447() {
+	  runTest("no verify error with at withincode pcds");
+  }
+  
+  public void testNoVerifyErrorWithAtAnnotationPCDs_pr113447() {
+	  runTest("no verify error with at annotation pcds");
+  }
+  
+  public void testNoVerifyErrorWithTwoArgsPCDs_pr113447() {
+	  runTest("no verify error with two args pcds");
+  }
+  
+  
   // helper methods.....
 
   public SyntheticRepository createRepos(File cpentry) {
@@ -934,12 +934,42 @@
         </compile>
     </ajc-test> 
 
-    <ajc-test dir="bugs150" title="no verify error with two this pcds">
+    <ajc-test dir="bugs150/pr113447" title="no verify error with two this pcds">
         <compile files="PR113447.java">
         </compile>
         <run class="PR113447"/>
     </ajc-test> 
 
+	<ajc-test dir="bugs150/pr113447" title="no verify error with two at this pcds">
+        <compile files="PR113447a.java" options="-1.5">
+        </compile>
+        <run class="PR113447a"/>
+    </ajc-test>
+
+	<ajc-test dir="bugs150/pr113447" title="no verify error with at within pcds">
+        <compile files="PR113447b.java" options="-1.5">
+        </compile>
+        <run class="PR113447b"/>
+    </ajc-test>
+
+	<ajc-test dir="bugs150/pr113447" title="no verify error with at withincode pcds">
+        <compile files="PR113447c.java" options="-1.5">
+        </compile>
+        <run class="PR113447c"/>
+    </ajc-test>
+
+	<ajc-test dir="bugs150/pr113447" title="no verify error with at annotation pcds">
+        <compile files="PR113447d.java" options="-1.5">
+        </compile>
+        <run class="PR113447d"/>
+    </ajc-test>
+
+	<ajc-test dir="bugs150/pr113447" title="no verify error with two args pcds">
+        <compile files="PR113447e.java" options="-1.5">
+        </compile>
+        <run class="PR113447e"/>
+    </ajc-test>
+
     <!-- ============================================================================ -->
     <!-- ============================================================================ -->
 
@@ -0,0 +1,40 @@
+public class PR113447 {
+
+	public static void main(String[] args) {
+		PR113447 me = new PR113447();
+		me.method1();
+		me.method3();
+	}
+	
+	public void method1(){}
+
+	public void method3(){}
+}
+
+aspect Super {
+
+	// second method doesn't exist
+	pointcut pc1(PR113447 s) : 
+		(this(s) && execution(void method1()))
+		|| (this(s) && execution(void method2()));
+
+	before(PR113447 s) : pc1(s) {
+	}
+	
+	// second method does exist
+	pointcut pc2(PR113447 s) : 
+		(this(s) && execution(void method1()))
+		|| (this(s) && execution(void method3()));
+
+	before(PR113447 s) : pc2(s) {
+	}
+	
+	// second method doesn't exist
+	pointcut pc3(PR113447 s) : 
+		(args(s) && execution(void method1()))
+		|| (args(s) && execution(void method2()));
+
+	before(PR113447 s) : pc3(s) {
+	}
+
+}
@@ -632,6 +632,10 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 	  runTest("weaveinfo message for declare at method on an ITDd method");
   }
 
+  public void testNoVerifyErrorWithTwoThisPCDs_pr113447() {
+	  runTest("no verify error with two this pcds");
+  }
+  
   // helper methods.....
 
   public SyntheticRepository createRepos(File cpentry) {
@@ -698,6 +698,12 @@
         </compile>
     </ajc-test> 
 
+    <ajc-test dir="bugs150" title="no verify error with two this pcds">
+        <compile files="PR113447.java">
+        </compile>
+        <run class="PR113447"/>
+    </ajc-test> 
+
     <!-- ============================================================================ -->
     <!-- ============================================================================ -->
 
@@ -179,17 +179,19 @@ public class ThisOrTargetPointcut extends NameBindingPointcut {
 		if (type instanceof BindingTypePattern) {
 		  BindingTypePattern btp = (BindingTypePattern)type;
 		  // Check if we have already bound something to this formal
-		  if ((state.get(btp.getFormalIndex())!=null) && (lastMatchedShadowId != shadow.shadowId)){
-//		  	ISourceLocation pcdSloc = getSourceLocation(); 
-//		  	ISourceLocation shadowSloc = shadow.getSourceLocation();
-//			Message errorMessage = new Message(
-//				"Cannot use "+(isThis?"this()":"target()")+" to match at this location and bind a formal to type '"+var.getType()+
-//				"' - the formal is already bound to type '"+state.get(btp.getFormalIndex()).getType()+"'"+
-//				".  The secondary source location points to the problematic "+(isThis?"this()":"target()")+".",
-//				shadowSloc,true,new ISourceLocation[]{pcdSloc}); 
-//			shadow.getIWorld().getMessageHandler().handleMessage(errorMessage);
+		  Var existingVarInThisSlot = state.get(btp.getFormalIndex());
+		  
+		  if (existingVarInThisSlot != null ) {
+			  
+			// Is it already bound to exactly the same thing?
+			if (existingVarInThisSlot.equals(var)) return Literal.TRUE;
+			
+			// If state.get() returned non-null then someone has already bound the variable in that slot at
+			// the shadow 'shadow.shadowId'.  If our 'lastMatchedShadowId' is not the same as 'shadow.shadowId'
+			// then this pointcut wasn't involved in matching and so shouldn't contribute to binding - so just
+			// return Literal.TRUE meaning 'no residue'
+		    if (lastMatchedShadowId != shadow.shadowId) return Literal.TRUE;
 			state.setErroneousVar(btp.getFormalIndex());
-			//return null;
 		  }
 		}
 		return exposeStateForVar(var, type, state, shadow.getIWorld());
