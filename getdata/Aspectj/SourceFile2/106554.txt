@@ -97,6 +97,8 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   	runTest("compiler error when mixing inheritance, overriding and polymorphism");
   }
 
+  public void testPerTypeWithin_pr106554() {runTest("Problem in staticinitialization with pertypewithin aspect");}
+  
   public void testPerTypeWithinMissesNamedInnerTypes() {
   	runTest("pertypewithin() handing of inner classes (1)");
   }
@@ -554,6 +554,17 @@
 	   <message kind="weave" text="Join point 'method-execution(void C.m3())' in Type 'C' (AroundAdvice.aj:14) advised by before advice from 'ErrorHandling' (AroundAdvice.aj:8)"/>
 	 </compile>
     </ajc-test>
+    
+    <ajc-test dir="bugs150/pr106554" pr="106554" title="Problem in staticinitialization with pertypewithin aspect">
+        <compile files="A.aj" options="-showWeaveInfo">
+          <message kind="weave" text="Join point 'staticinitialization(void A.&lt;clinit&gt;())' in Type 'A' (A.aj:1) advised by before advice from 'StopsInit' (A.aj:21)"/>
+        </compile>
+        <run class="A">
+          <stdout>
+            <line text="test = 1"/>
+          </stdout>
+        </run>
+    </ajc-test> 
 
     <ajc-test dir="bugs150/SimpleInsuranceFailure" title="raw and generic type conversion with itd cons">
         <compile files="" options=" -emacssym, -sourceroots ." >
@@ -0,0 +1,24 @@
+public aspect A {
+  interface I { 
+    // These fields will have their initialization logic stuffed in a static
+    // initializer in A$I
+    public static final String[] str = new String[] { "a","b"};
+    public static final String[] str2 = str;
+  }
+
+  static Class[] classes = { I.class };
+
+  static Object f = new Integer(1);
+
+  public static void main(String args[]) {
+    System.out.println("test = "+f);
+    System.err.println("A:"+A.aspectOf());
+  }
+}
+
+aspect StopsInit pertypewithin(A) {
+  // These should match nothing in A$I
+  before() : staticinitialization(*) {}
+  before() : set(* *) && within(A$I) {}
+  before() : get(* *) && within(A$I) {}
+}
@@ -84,6 +84,12 @@ public class PerTypeWithin extends PerClause {
 					shadow.getSourceLocation(),true,new ISourceLocation[]{getSourceLocation()});
     		shadow.getIWorld().getMessageHandler().handleMessage(msg);
     	}
+    	
+    	// See pr106554 - we can't put advice calls in an interface when the advice is defined
+    	// in a pertypewithin aspect - the JPs only exist in the static initializer and can't 
+    	// call the localAspectOf() method.
+    	if (enclosingType.isInterface()) return FuzzyBoolean.NO;
+    	
     	typePattern.resolve(shadow.getIWorld());
     	return isWithinType(enclosingType);
     }
