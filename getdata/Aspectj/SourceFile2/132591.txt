@@ -0,0 +1 @@
+-outxml
@@ -0,0 +1,2 @@
+<aspectj>
+</aspectj>
\ No newline at end of file
@@ -120,19 +120,32 @@ public class NullIdeProperties implements ProjectPropertiesAdapter {
     }
 
 	public Map getSourcePathResources() {
-		File srcBase = new File(getProjectSourcePath());
-		File[] fromResources = FileUtil.listFiles(srcBase, new FileFilter() {
-			public boolean accept(File pathname) {
-				String name = pathname.getName().toLowerCase();
-				return !name.endsWith(".class") && !name.endsWith(".java") && !name.endsWith(".aj");
-			}
-		});
 		Map map = new HashMap();
-		for (int i = 0; i < fromResources.length; i++) {
-			String normPath = FileUtil.normalizedPath(fromResources[i] ,srcBase);
-			map.put(normPath, fromResources[i]);
 
+		/* Allow the user to override the testProjectPath by using sourceRoots */ 
+		File[] srcBase;
+		if (sourceRoots == null || sourceRoots.isEmpty()) {
+			srcBase = new File[] { new File(getProjectSourcePath()) };
+		}
+		else {
+			srcBase = new File[sourceRoots.size()];
+			sourceRoots.toArray(srcBase);
+		}
+		
+		for (int j = 0; j < srcBase.length; j++) {
+			File[] fromResources = FileUtil.listFiles(srcBase[j], new FileFilter() {
+				public boolean accept(File pathname) {
+					String name = pathname.getName().toLowerCase();
+					return !name.endsWith(".class") && !name.endsWith(".java") && !name.endsWith(".aj");
+				}
+			});
+			for (int i = 0; i < fromResources.length; i++) {
+				String normPath = FileUtil.normalizedPath(fromResources[i] ,srcBase[j]);
+				map.put(normPath, fromResources[i]);
+
+			}
 		}
+		
 		return map;
 	}
 
@@ -13,6 +13,9 @@ package org.aspectj.ajde;
 
 import java.io.File;
 import java.io.IOException;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 
@@ -103,6 +106,30 @@ public class OutxmlTest extends AjdeTestCase {
 		assertJarContainsEntry(outjar,CUSTOM_AOPXML_NAME);
 	}
 
+	/**
+	 * Aim: Test "-outxml" option produces a warning if "META-INF/aop.xml 
+	 * already exists in source
+	 * 
+	 */
+	public void testOutxmlToOutjarWithAop_xml () {
+		File f = new File( AjdeTests.testDataPath(PROJECT_DIR + "/src-resources"));
+		Set roots = new HashSet();
+		roots.add(f);
+		ideManager.getProjectProperties().setSourceRoots(roots);
+		File outjar = openFile(OUTJAR_NAME);
+		ideManager.getProjectProperties().setOutJar(outjar.getAbsolutePath());
+		assertTrue("Build failed: " + ideManager.getCompilationSourceLineTasks(),doSynchronousBuild("outxml-to-outjar-with-aop_xml.lst"));
+//		assertTrue("Build warnings: " + ideManager.getCompilationSourceLineTasks(),ideManager.getCompilationSourceLineTasks().isEmpty());
+		assertFalse("Build warnings for exisiting resource expected",ideManager.getCompilationSourceLineTasks().isEmpty());
+		List msgs = NullIdeManager.getIdeManager().getCompilationSourceLineTasks();
+		String msg = ((NullIdeTaskListManager.SourceLineTask)msgs.get(0)).message.getMessage();
+		assertTrue("Wrong message: " + msg,msg.startsWith("-outxml/-outxmlfile option ignored because resource already exists:"));
+		
+		File aopxml = openFile(BIN_DIR + "/" + DEFAULT_AOPXML_NAME);
+		assertFalse(DEFAULT_AOPXML_NAME + " should not exisit",aopxml.exists());
+		assertJarContainsEntry(outjar,DEFAULT_AOPXML_NAME);
+	}
+
 	private void assertJarContainsEntry (File file, String entryName) {
 
 		try {
@@ -132,6 +132,7 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 	// FIXME asc should this really be in here?
 	private IHierarchy structureModel;
 	public AjBuildConfig buildConfig;
+	private boolean ignoreOutxml;
 
 	AjState state = new AjState(this);
 
@@ -495,6 +496,14 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 			handler.handleMessage(msg);
 			return;
 		}
+		if (filename.equals(buildConfig.getOutxmlName())) {
+			ignoreOutxml = true;
+			IMessage msg = new Message("-outxml/-outxmlfile option ignored because resource already exists: '" + filename + "'",
+					   IMessage.WARNING,
+					   null,
+					   new SourceLocation(srcLocation,0));
+			handler.handleMessage(msg);
+		}
 		if (zos != null) {
 			ZipEntry newEntry = new ZipEntry(filename);  //??? get compression scheme right
 
@@ -555,6 +564,8 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 	}
 
 	private void writeOutxmlFile () throws IOException {
+		if (ignoreOutxml) return;
+		
 		String filename = buildConfig.getOutxmlName();
 //		System.err.println("? AjBuildManager.writeOutxmlFile() outxml=" + filename);
 //		System.err.println("? AjBuildManager.writeOutxmlFile() outputDir=" + buildConfig.getOutputDir());
@@ -0,0 +1 @@
+-outxml
@@ -0,0 +1,2 @@
+<aspectj>
+</aspectj>
\ No newline at end of file
@@ -120,19 +120,32 @@ public class NullIdeProperties implements ProjectPropertiesAdapter {
     }
 
 	public Map getSourcePathResources() {
-		File srcBase = new File(getProjectSourcePath());
-		File[] fromResources = FileUtil.listFiles(srcBase, new FileFilter() {
-			public boolean accept(File pathname) {
-				String name = pathname.getName().toLowerCase();
-				return !name.endsWith(".class") && !name.endsWith(".java") && !name.endsWith(".aj");
-			}
-		});
 		Map map = new HashMap();
-		for (int i = 0; i < fromResources.length; i++) {
-			String normPath = FileUtil.normalizedPath(fromResources[i] ,srcBase);
-			map.put(normPath, fromResources[i]);
 
+		/* Allow the user to override the testProjectPath by using sourceRoots */ 
+		File[] srcBase;
+		if (sourceRoots == null || sourceRoots.isEmpty()) {
+			srcBase = new File[] { new File(getProjectSourcePath()) };
+		}
+		else {
+			srcBase = new File[sourceRoots.size()];
+			sourceRoots.toArray(srcBase);
+		}
+		
+		for (int j = 0; j < srcBase.length; j++) {
+			File[] fromResources = FileUtil.listFiles(srcBase[j], new FileFilter() {
+				public boolean accept(File pathname) {
+					String name = pathname.getName().toLowerCase();
+					return !name.endsWith(".class") && !name.endsWith(".java") && !name.endsWith(".aj");
+				}
+			});
+			for (int i = 0; i < fromResources.length; i++) {
+				String normPath = FileUtil.normalizedPath(fromResources[i] ,srcBase[j]);
+				map.put(normPath, fromResources[i]);
+
+			}
 		}
+		
 		return map;
 	}
 
@@ -13,6 +13,9 @@ package org.aspectj.ajde;
 
 import java.io.File;
 import java.io.IOException;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 
@@ -103,6 +106,30 @@ public class OutxmlTest extends AjdeTestCase {
 		assertJarContainsEntry(outjar,CUSTOM_AOPXML_NAME);
 	}
 
+	/**
+	 * Aim: Test "-outxml" option produces a warning if "META-INF/aop.xml 
+	 * already exists in source
+	 * 
+	 */
+	public void testOutxmlToOutjarWithAop_xml () {
+		File f = new File( AjdeTests.testDataPath(PROJECT_DIR + "/src-resources"));
+		Set roots = new HashSet();
+		roots.add(f);
+		ideManager.getProjectProperties().setSourceRoots(roots);
+		File outjar = openFile(OUTJAR_NAME);
+		ideManager.getProjectProperties().setOutJar(outjar.getAbsolutePath());
+		assertTrue("Build failed: " + ideManager.getCompilationSourceLineTasks(),doSynchronousBuild("outxml-to-outjar-with-aop_xml.lst"));
+//		assertTrue("Build warnings: " + ideManager.getCompilationSourceLineTasks(),ideManager.getCompilationSourceLineTasks().isEmpty());
+		assertFalse("Build warnings for exisiting resource expected",ideManager.getCompilationSourceLineTasks().isEmpty());
+		List msgs = NullIdeManager.getIdeManager().getCompilationSourceLineTasks();
+		String msg = ((NullIdeTaskListManager.SourceLineTask)msgs.get(0)).message.getMessage();
+		assertTrue("Wrong message: " + msg,msg.startsWith("-outxml/-outxmlfile option ignored because resource already exists:"));
+		
+		File aopxml = openFile(BIN_DIR + "/" + DEFAULT_AOPXML_NAME);
+		assertFalse(DEFAULT_AOPXML_NAME + " should not exisit",aopxml.exists());
+		assertJarContainsEntry(outjar,DEFAULT_AOPXML_NAME);
+	}
+
 	private void assertJarContainsEntry (File file, String entryName) {
 
 		try {
@@ -132,6 +132,7 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 	// FIXME asc should this really be in here?
 	private IHierarchy structureModel;
 	public AjBuildConfig buildConfig;
+	private boolean ignoreOutxml;
 
 	AjState state = new AjState(this);
 
@@ -495,6 +496,14 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 			handler.handleMessage(msg);
 			return;
 		}
+		if (filename.equals(buildConfig.getOutxmlName())) {
+			ignoreOutxml = true;
+			IMessage msg = new Message("-outxml/-outxmlfile option ignored because resource already exists: '" + filename + "'",
+					   IMessage.WARNING,
+					   null,
+					   new SourceLocation(srcLocation,0));
+			handler.handleMessage(msg);
+		}
 		if (zos != null) {
 			ZipEntry newEntry = new ZipEntry(filename);  //??? get compression scheme right
 
@@ -555,6 +564,8 @@ public class AjBuildManager implements IOutputClassFileNameProvider,IBinarySourc
 	}
 
 	private void writeOutxmlFile () throws IOException {
+		if (ignoreOutxml) return;
+		
 		String filename = buildConfig.getOutxmlName();
 //		System.err.println("? AjBuildManager.writeOutxmlFile() outxml=" + filename);
 //		System.err.println("? AjBuildManager.writeOutxmlFile() outputDir=" + buildConfig.getOutputDir());
