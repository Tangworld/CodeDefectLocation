@@ -0,0 +1,16 @@
+package pkg1;
+
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.annotation.DeclareWarning;
+import org.aspectj.lang.annotation.DeclareError;
+
+@Aspect
+public class A {
+
+	@DeclareWarning("execution(* C.warningMethod())")
+    static final String warning = "warning";
+
+    @DeclareError("execution(* C.badMethod())")
+    static final String error = "error";
+	
+}
@@ -0,0 +1,11 @@
+package pkg1;
+
+public class C {
+
+	public void warningMethod() {
+	}
+	
+	public void badMethod() {
+	}
+	
+}
@@ -0,0 +1,27 @@
+package pkg2;
+
+import org.aspectj.lang.annotation.Aspect;
+import org.aspectj.lang.annotation.DeclareWarning;
+import org.aspectj.lang.annotation.DeclareError;
+
+public class InOneFile {
+
+    public void hello() {}
+
+    public void hi() {}
+
+    public void target() {
+        hello();
+        hi();
+    }
+
+    @Aspect
+    public static class DeowAspect {
+
+        @DeclareWarning("call(* InOneFile.hello())")
+        final static String onHello = "call hello";
+
+        @DeclareError("call(* InOneFile.hi())")
+        final static String onHi = "call hi";
+    }
+}
@@ -0,0 +1,8 @@
+public class TopLevelType<E> {
+        public static class NestedType {}
+}
+
+aspect SomeAspect {
+        public void TopLevelType.NestedType.someMethod() {
+        }
+}
\ No newline at end of file
@@ -25,6 +25,7 @@ import org.aspectj.testing.XMLBasedAjcTestCase;
 
 public class Ajc151Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
+ // public void testItdOnInnerTypeOfGenericType_pr132349() { runTest("ITD on inner type of generic type");}
   public void testAnnotationsAndItds_pr98901() { runTest("annotations and itds");}
   public void testAnnotationsAndItds_pr98901_2() { runTest("annotations and itds - 2");}
   public void testCircularGenerics_pr133307() { runTest("circular generics");}
@@ -52,6 +53,15 @@ public class Ajc151Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testAtAspectInheritsAdviceWithTJPAndThis_pr125699 () { runTest("inherit advice with this() and thisJoinPoint");  }
   public void testAtAspectInheritsAdviceWithTJPAndThis_pr125699_2 () {runTest("inherit advice with this() and thisJoinPoint - 2");  }
   public void testBrokenLTW_pr128744() { runTest("broken ltw"); }
+  
+  public void testAtAspectNoInvalidAbsoluteTypeName_pr126560() {
+	  runTest("@AJ deow doesn't throw an invalidAbsoluteTypeName when specify type in the same package");
+  }
+  
+  public void testAtAspectNoInvalidAbsoluteTypeName_pr126560_2() {
+	  runTest("@AJ deow doesn't throw an invalidAbsoluteTypeName when specify type in the same file");
+  }
+  
   public void testArrayindexoutofbounds_pr129566() { 
 	  runTest("arrayindexoutofbounds");
 	  // public class SkipList<T extends Comparable> extends Object implements Set<T>, Iterable<T>
@@ -3,6 +3,24 @@
 <!-- AspectJ v1.5.1 Tests -->
 <suite>
 
+    <ajc-test dir="bugs151/pr132349" title="ITD on inner type of generic type">
+     <compile files="TopLevelType.java" options="-1.5"/>
+    </ajc-test>
+
+    <ajc-test dir="bugs151/pr126560" title="@AJ deow doesn't throw an invalidAbsoluteTypeName when specify type in the same package">
+        <compile files="pkg1/C.java, pkg1/A.java" options="-1.5">
+          <message kind="error" line="8" text="error"/>
+          <message kind="warning" line="5" text="warning"/>
+	    </compile>
+    </ajc-test>
+
+    <ajc-test dir="bugs151/pr126560" title="@AJ deow doesn't throw an invalidAbsoluteTypeName when specify type in the same file">
+        <compile files="pkg2/InOneFile.java" options="-1.5">
+          <message kind="warning" line="14" text="call hello"/>
+          <message kind="error" line="15" text="call hi"/>
+	    </compile>
+    </ajc-test>
+
     <ajc-test dir="bugs151/pr98901" title="annotations and itds">
      <compile files="Failing.java" options="-1.5"/>
      <run class="Failing">
@@ -1587,6 +1587,26 @@ public class AtAjAttributes {
         public ISourceLocation makeSourceLocation(IHasPosition location) {
             return m_sourceContext.makeSourceLocation(location);
         }
+        
+        public UnresolvedType lookupType(String name, IHasPosition location) {
+        	// bug 126560  
+        	if (m_enclosingType != null) {
+        		// add the package we're in to the list of imported
+            	// prefixes so that we can find types in the same package 
+			String pkgName = m_enclosingType.getPackageName();
+			if (pkgName != null && !pkgName.equals("")) {
+				String[] currentImports = getImportedPrefixes();
+				String[] newImports = new String[currentImports.length + 1];
+				for (int i = 0; i < currentImports.length; i++) {
+					newImports[i] = currentImports[i];
+				}
+				newImports[currentImports.length] = pkgName.concat(".");
+				setImportedPrefixes(newImports);
+			}
+		}
+        	return super.lookupType(name,location);
+        }
+        
     }
 
     /**
@@ -44,6 +44,9 @@ public class SimpleScope implements IScope {
 	public UnresolvedType lookupType(String name, IHasPosition location) {
 		for (int i=0; i<importedNames.length; i++) {
 			String importedName = importedNames[i];
+//			// make sure we're matching against the
+//			// type name rather than part of it
+//			if (importedName.endsWith("." + name)) {
 			if (importedName.endsWith(name)) {
 				return world.resolve(importedName);
 			}
