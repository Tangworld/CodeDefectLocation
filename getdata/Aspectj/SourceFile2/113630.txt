@@ -14,25 +14,45 @@
 
 package org.aspectj.ajdt.internal.compiler.lookup;
 
-import java.util.*;
-
-import org.aspectj.ajdt.internal.compiler.ast.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+import org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration;
+import org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration;
+import org.aspectj.ajdt.internal.compiler.ast.DeclareAnnotationDeclaration;
+import org.aspectj.ajdt.internal.compiler.ast.DeclareDeclaration;
+import org.aspectj.ajdt.internal.compiler.ast.InterTypeDeclaration;
+import org.aspectj.ajdt.internal.compiler.ast.PointcutDeclaration;
 import org.aspectj.ajdt.internal.core.builder.EclipseSourceContext;
 import org.aspectj.bridge.IMessage;
-//import org.aspectj.bridge.ISourceLocation;
-import org.aspectj.weaver.*;
-import org.aspectj.weaver.patterns.PerClause;
-import org.aspectj.weaver.patterns.PerSingleton;
-import org.aspectj.weaver.patterns.PerFromSuper;
 import org.aspectj.org.eclipse.jdt.core.compiler.CharOperation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
-import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.StringLiteral;
+import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeParameter;
-import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.*;
+import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding;
+import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilerModifiers;
+import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
+import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
+import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
+import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.TagBits;
+import org.aspectj.weaver.AbstractReferenceTypeDelegate;
+import org.aspectj.weaver.AnnotationX;
+import org.aspectj.weaver.ReferenceType;
+import org.aspectj.weaver.ResolvedMember;
+import org.aspectj.weaver.ResolvedPointcutDefinition;
+import org.aspectj.weaver.ResolvedType;
+import org.aspectj.weaver.TypeVariable;
+import org.aspectj.weaver.UnresolvedType;
+import org.aspectj.weaver.WeaverStateInfo;
+import org.aspectj.weaver.patterns.PerClause;
+import org.aspectj.weaver.patterns.PerFromSuper;
+import org.aspectj.weaver.patterns.PerSingleton;
 
 /**
  * Supports viewing eclipse TypeDeclarations/SourceTypeBindings as a ResolvedType
@@ -301,6 +321,15 @@ public class EclipseSourceType extends AbstractReferenceTypeDelegate {
 	    }
 	}
 
+	public String getRetentionPolicy() {
+		if (isAnnotation()) {
+			if ((binding.getAnnotationTagBits() & TagBits.AnnotationRetentionMASK) == TagBits.AnnotationRuntimeRetention) return "RUNTIME";
+			if ((binding.getAnnotationTagBits() & TagBits.AnnotationRetentionMASK) == TagBits.AnnotationSourceRetention) return "SOURCE";
+			if ((binding.getAnnotationTagBits() & TagBits.AnnotationRetentionMASK) == TagBits.AnnotationClassRetention) return "CLASS";
+		}
+		return null;
+	}
+	
 	public boolean hasAnnotation(UnresolvedType ofType) {
 
 		// Make sure they are resolved
@@ -61,6 +61,9 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
 
   public void testVarargsITD_pr110906() { runTest("ITD varargs problem");}
 
+  public void testIncompatibleClassChangeError_pr113630_1() {runTest("IncompatibleClassChangeError - errorscenario");}
+  public void testIncompatibleClassChangeError_pr113630_2() {runTest("IncompatibleClassChangeError - workingscenario");}
+  
   public void testBadGenericSigAttribute_pr110927() { 
 	runTest("cant create signature attribute");
 	Signature sig = GenericsTests.getClassSignature(ajc,"I");
@@ -219,10 +219,7 @@ public class GenericsTests extends XMLBasedAjcTestCase {
     public void testGenericsBang_pr95993() {
 	    runTest("NPE at ClassScope.java:660 when compiling generic class");
     }    
-	
-//    public void testIncompatibleClassChangeError_pr113630() {
-//    	runTest("IncompatibleClassChangeError");
-//    }
+    
 
 	// generic aspects
 	public void testPR96220_GenericAspects1() {runTest("generic aspects - 1");}
@@ -892,23 +889,16 @@ public class GenericsTests extends XMLBasedAjcTestCase {
 	}
 
 	public static Signature getClassSignature(Ajc ajc,String classname) {
-		try {
-			ClassPath cp = 
-				new ClassPath(ajc.getSandboxDirectory() + File.pathSeparator + System.getProperty("java.class.path"));
-		    SyntheticRepository sRepos =  SyntheticRepository.getInstance(cp);
-			JavaClass clazz = sRepos.loadClass(classname);
-			Signature sigAttr = null;
-			Attribute[] attrs = clazz.getAttributes();
-			for (int i = 0; i < attrs.length; i++) {
-				Attribute attribute = attrs[i];
-				if (attribute.getName().equals("Signature")) sigAttr = (Signature)attribute;
-			}
-			return sigAttr;
-		} catch (ClassNotFoundException e) {
-			fail("Couldn't find class "+classname+" in the sandbox directory.");
+	    JavaClass clazz = getClass(ajc,classname);
+		Signature sigAttr = null;
+		Attribute[] attrs = clazz.getAttributes();
+		for (int i = 0; i < attrs.length; i++) {
+			Attribute attribute = attrs[i];
+			if (attribute.getName().equals("Signature")) sigAttr = (Signature)attribute;
 		}
-		return null;
+		return sigAttr;
 	}
+	
 	// Check the signature attribute on a class is correct
 	public static void verifyClassSignature(Ajc ajc,String classname,String sig) {
 		Signature sigAttr = getClassSignature(ajc,classname);
@@ -11,9 +11,16 @@
         <compile files="pr112783.aj" options="-1.5"/>
     </ajc-test>
 
-    <ajc-test dir="bugs150/pr113630" title="IncompatibleClassChangeError">
-        <compile files="Bean.java,BeanSupportAspectj.aj,BeanTestCase.java,javaBean.java,propertyChanger.java,PropertySupportAspect5.aj" options="-1.5"/>
-        <run class="com.blueprint.util.aspectj5.test.BeanTestCase"/>
+    <ajc-test dir="bugs150/pr113630/case1" title="IncompatibleClassChangeError - errorscenario">
+        <compile files="Bean.java,BeanTestCase.java,javaBean.java,propertyChanger.java,PropertySupportAspect5.aj" options="-1.5">
+          <message kind="warning" line="9" text="Failing match because annotation 'javaBean' on type 'Bean' has SOURCE retention.  Matching allowed when RetentionPolicy is CLASS or RUNTIME"/>
+          <message kind="error" line="18" text="The method addPropertyChangeListener(String, BeanTestCase) is undefined for the type Bean"/>
+        </compile>
+    </ajc-test>  
+
+    <ajc-test dir="bugs150/pr113630/case2" title="IncompatibleClassChangeError - workingscenario">
+        <compile files="Bean.java,BeanTestCase.java,javaBean.java,propertyChanger.java,PropertySupportAspect5.aj" options="-1.5"/>
+        <run class="BeanTestCase"/>
     </ajc-test>  
 
     <ajc-test dir="bugs150" title="Generics ClassCastException">
@@ -176,6 +176,10 @@ public class BoundedReferenceType extends ReferenceType {
 		public boolean isAnnotationWithRuntimeRetention() {
 			return resolvedTypeX.isAnnotationWithRuntimeRetention();
 		}
+		
+		public String getRetentionPolicy() {
+			return resolvedTypeX.getRetentionPolicy();
+		}
 
 		public boolean isGeneric() {
 			return resolvedTypeX.isGenericType();
@@ -147,6 +147,10 @@ public class ReferenceType extends ResolvedType {
     	return delegate.isAnnotation();
     }
 
+    public String getRetentionPolicy() {
+    	return delegate.getRetentionPolicy();
+    }
+    
     public boolean isAnnotationWithRuntimeRetention() {
         return delegate.isAnnotationWithRuntimeRetention();
     }
@@ -33,6 +33,7 @@ public interface ReferenceTypeDelegate {
     public boolean isInterface();
     public boolean isEnum();
     public boolean isAnnotation();
+    public String getRetentionPolicy();
     public boolean isAnnotationWithRuntimeRetention();
 	public boolean isClass();
 	public boolean isGeneric();
@@ -86,6 +86,10 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 	private String declaredSignature = null;
 	private boolean isGenericType = false;
 
+	private boolean discoveredRetentionPolicy = false;
+	private String retentionPolicy;
+	
+	
 	/**
 	 * A BcelObjectType is 'damaged' if it has been modified from what was original constructed from
 	 * the bytecode.  This currently happens if the parents are modified or an annotation is added -
@@ -416,9 +420,34 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 	}
 
 	public boolean isAnnotationWithRuntimeRetention() {
-	    if (!isAnnotation()) {
-	        return false;
-	    } else {
+		return getRetentionPolicy().equals("RUNTIME");
+//	    if (!isAnnotation()) {
+//	        return false;
+//	    } else {
+//	        Annotation[] annotationsOnThisType = javaClass.getAnnotations();
+//	        for (int i = 0; i < annotationsOnThisType.length; i++) {
+//	            Annotation a = annotationsOnThisType[i];
+//	            if (a.getTypeName().equals(UnresolvedType.AT_RETENTION.getName())) {
+//	                List values = a.getValues();
+//	                boolean isRuntime = false;
+//	                for (Iterator it = values.iterator(); it.hasNext();) {
+//                        ElementNameValuePair element = (ElementNameValuePair) it.next();
+//                        ElementValue v = element.getValue();
+//                        isRuntime = v.stringifyValue().equals("RUNTIME");
+//                    }
+//	                return isRuntime;
+//	            }
+//	        }
+//		}
+//	    return false;
+	}
+	
+	
+	public String getRetentionPolicy() {
+		if (discoveredRetentionPolicy) return retentionPolicy;
+		discoveredRetentionPolicy=true;
+        retentionPolicy=null; // null means we have no idea
+		if (isAnnotation()) {
 	        Annotation[] annotationsOnThisType = javaClass.getAnnotations();
 	        for (int i = 0; i < annotationsOnThisType.length; i++) {
 	            Annotation a = annotationsOnThisType[i];
@@ -428,13 +457,13 @@ public class BcelObjectType extends AbstractReferenceTypeDelegate {
 	                for (Iterator it = values.iterator(); it.hasNext();) {
                         ElementNameValuePair element = (ElementNameValuePair) it.next();
                         ElementValue v = element.getValue();
-                        isRuntime = v.stringifyValue().equals("RUNTIME");
+                        retentionPolicy = v.stringifyValue();
+                        return retentionPolicy;
                     }
-	                return isRuntime;
 	            }
 	        }
 		}
-	    return false;
+	    return retentionPolicy;
 	}
 
 	public boolean isSynthetic() {
@@ -19,6 +19,7 @@ import org.aspectj.util.FuzzyBoolean;
 import org.aspectj.weaver.AnnotatedElement;
 import org.aspectj.weaver.BCException;
 import org.aspectj.weaver.ISourceContext;
+import org.aspectj.weaver.ReferenceType;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.TypeVariableReference;
 import org.aspectj.weaver.UnresolvedType;
@@ -79,6 +80,14 @@ public class ExactAnnotationTypePattern extends AnnotationTypePattern {
 		}
 
 		if (annotated.hasAnnotation(annotationType)) {
+			if (annotationType instanceof ReferenceType) {
+				ReferenceType rt = (ReferenceType)annotationType;
+				if (rt.getRetentionPolicy()!=null && rt.getRetentionPolicy().equals("SOURCE")) {
+					rt.getWorld().getMessageHandler().handleMessage(
+					  MessageUtil.warn(WeaverMessages.format(WeaverMessages.NO_MATCH_BECAUSE_SOURCE_RETENTION,annotationType,annotated),getSourceLocation()));
+					return FuzzyBoolean.NO;
+				}
+			}
 			return FuzzyBoolean.YES;
 		} else if (checkSupers) {
 			ResolvedType toMatchAgainst = ((ResolvedType) annotated).getSuperclass();
@@ -92,7 +92,9 @@ public class WildAnnotationTypePattern extends AnnotationTypePattern {
 				scope.getWorld().getMessageHandler().handleMessage(m);
 				resolved = false;
 			}
-    		return new ExactAnnotationTypePattern(et.getExactType().resolve(scope.getWorld()));
+    		ExactAnnotationTypePattern eatp =  new ExactAnnotationTypePattern(et.getExactType().resolve(scope.getWorld()));
+    		eatp.copyLocationFrom(this);
+    		return eatp;
     	} else {
     		return this;
     	}
@@ -126,6 +126,11 @@ public class ReflectionBasedReferenceTypeDelegate implements ReferenceTypeDelega
 		// cant be an annotation in Java 1.4 or prior
 		return false;
 	}
+	
+	public String getRetentionPolicy() {
+		// cant be an annotation in Java 1.4 or prior
+		return null;
+	}
 
 	/* (non-Javadoc)
 	 * @see org.aspectj.weaver.ReferenceTypeDelegate#isClass()
@@ -1,17 +0,0 @@
-package com.blueprint.util.aspectj5.test;
-
-import java.io.Serializable;
-
-@javaBean()
-public class Bean implements Serializable{
-		
-		private String name;
-
-		public String getName() {
-			return name;
-		}
-		@propertyChanger()
-		public void setName( String name ) {
-			this.name = name;
-		}
-}
\ No newline at end of file
@@ -1,10 +0,0 @@
-/**
- * 
- */
-package com.blueprint.util.aspectj5.test;
-
-import com.blueprint.util.aspectj5.test.PropertySupportAspect5.PropertySupport;
-
-public aspect BeanSupportAspectj {
-     declare parents: @javaBean * implements PropertySupport;
-}
@@ -1,34 +0,0 @@
-package com.blueprint.util.aspectj5.test;
-
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-
-import junit.framework.TestCase;
-
-public class BeanTestCase extends TestCase implements PropertyChangeListener{
-
-	public void setUp() throws Exception{
-		super.setUp();
-	}
-
-	public void TearDown() throws Exception{
-		super.setUp();
-	}
-	
-	public void propertyChange(PropertyChangeEvent e){
-	      System.out.println("Property [" + e.getPropertyName() + "[ changed from " +
-	    		  							e.getOldValue() + " to " + e.getNewValue() );
-    }
-	
-    public static void main(String [] argv) {
-      new BeanTestCase().testPropertyChange();
-    }
-	public void testPropertyChange(){
-		Bean b = new Bean();
-		b.addPropertyChangeListener( "name", this );
-		b.setName( "Test" );
-		assertEquals( b.getName() , "Test" );
-		b.setName( "Test1" );
-		assertEquals( b.getName() , "Test1" );
-	}
-}
@@ -1,90 +0,0 @@
-package com.blueprint.util.aspectj5.test;
-
-import java.beans.PropertyChangeListener;
-import java.beans.PropertyChangeSupport;
-import java.lang.reflect.Field;
-import org.aspectj.lang.Signature;
-
-public aspect PropertySupportAspect5 {
-		
-			PropertyChangeSupport PropertySupport.support = new PropertyChangeSupport(this);
-
-			public interface PropertySupport{
-				  public void addPropertyChangeListener( PropertyChangeListener listener );
-				  public void addPropertyChangeListener( String propertyName,
-					                                     PropertyChangeListener listener );
-				  public void removePropertyChangeListener( String propertyName,
-					                                        PropertyChangeListener listener );
-				  public void removePropertyChangeListener( PropertyChangeListener listener );
-				  public void hasListeners( String propertyName );
-				  public void firePropertyChange( Bean b,
-							 					  String property,
-							 					  String oldval,
-							 					  String newval );
-			}
-			
-			public void PropertySupport.addPropertyChangeListener(PropertyChangeListener listener){
-			    support.addPropertyChangeListener(listener);
-			}
-			
-			public void PropertySupport.addPropertyChangeListener( String propertyName,
-			                                                       PropertyChangeListener listener){
-
-				support.addPropertyChangeListener(propertyName, listener);
-		    }
-		    
-			public void PropertySupport.removePropertyChangeListener( String propertyName,
-				                                                      PropertyChangeListener listener) {
-				support.removePropertyChangeListener(propertyName, listener);
-		    }
-			
-			public void PropertySupport.removePropertyChangeListener(PropertyChangeListener listener) {
-			    support.removePropertyChangeListener(listener);
-			}
-			
-			public void PropertySupport.hasListeners(String propertyName) {
-			    support.hasListeners(propertyName);
-			}
-
-			pointcut callSetter( Bean b ) 
-		    : call( @propertyChanger * *(..) ) && target( b );
-			
-			void around( Bean b ) : callSetter( b )  {
-			    String propertyName = getField( thisJoinPointStaticPart.getSignature() ).
-			    																getName();
-				System.out.println( "The property is [" + propertyName + "]" );
-				String oldValue = b.getName();
-			    proceed( b );
-			    b.firePropertyChange( b, propertyName, oldValue, b.getName());
-			}
-
-		    private Field getField( Signature signature ){
-		    	Field field = null;
-				System.out.println( "Getting the field name of [" +signature.getName() + "]" );
-		    	
-		    	try{
-		    		String methodName = signature.getName();
-		    		field = signature.getDeclaringType().
-									getDeclaredField( methodName.
-													   substring( 3,
-												                  methodName.length() ).
-												                  			toLowerCase());
-		    		field.setAccessible(true);
-		    	}catch( NoSuchFieldException nsfe ){
-		    		nsfe.printStackTrace();
-		    	}
-				return field;
-			}
-
-			public void PropertySupport.firePropertyChange( Bean b,
-									 						String property,
-									 						String oldval,
-									 						String newval) {
-				System.out.println( "The property is [" + property + "]");
-				System.out.println( "The old value is [" + oldval + "]");
-				System.out.println( "The new value is [" + newval + "]");
-				b.support.firePropertyChange( property,
-							( oldval == null ) ? oldval : new String(oldval),
-				            new String(newval));
-			}
-}
\ No newline at end of file
@@ -0,0 +1,17 @@
+
+import java.io.Serializable;
+
+@javaBean()
+public class Bean implements Serializable{
+		
+  private String name;
+
+  public String getName() { 
+    return name; 
+  }
+
+  @propertyChanger()
+  public void setName( String n ) {
+    name = n;
+  }
+}
@@ -0,0 +1,24 @@
+
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
+
+public class BeanTestCase implements PropertyChangeListener{
+
+  public void propertyChange(PropertyChangeEvent e){
+    System.out.println("Property [" + e.getPropertyName() + "[ changed from " +
+			e.getOldValue() + " to " + e.getNewValue() );
+  }
+	
+  public static void main(String [] argv) {
+    new BeanTestCase().testPropertyChange();
+  }
+
+  public void testPropertyChange(){
+    Bean b = new Bean();
+    b.addPropertyChangeListener( "name", this );
+    b.setName( "Test" );
+    if (!b.getName().equals("Test")) throw new RuntimeException("");
+    b.setName( "Test1" );
+    if (!b.getName().equals("Test1")) throw new RuntimeException("");
+  }
+}
@@ -0,0 +1,24 @@
+
+import java.beans.PropertyChangeListener;
+import java.beans.PropertyChangeSupport;
+import java.lang.reflect.Field;
+import org.aspectj.lang.Signature;
+
+public aspect PropertySupportAspect5 {
+  
+  declare parents: @javaBean * implements PropertySupport;
+	
+  public interface PropertySupport{  }
+			
+  public void PropertySupport.addPropertyChangeListener(PropertyChangeListener listener){  }
+			
+  public void PropertySupport.addPropertyChangeListener( String propertyName,PropertyChangeListener listener){  }
+		    
+  public void PropertySupport.removePropertyChangeListener( String propertyName, PropertyChangeListener listener) {  }
+			
+  public void PropertySupport.removePropertyChangeListener(PropertyChangeListener listener) {  }
+			
+  public void PropertySupport.hasListeners(String propertyName) {  }
+
+  public void PropertySupport.firePropertyChange( Bean b, String property, String oldval, String newval) {  }
+}
@@ -1,4 +1,3 @@
-package com.blueprint.util.aspectj5.test;
 
 import java.lang.annotation.*;
 import java.lang.*;
@@ -1,4 +1,3 @@
-package com.blueprint.util.aspectj5.test;
 
 import java.lang.annotation.*;
 import java.lang.*;
@@ -0,0 +1,17 @@
+
+import java.io.Serializable;
+
+@javaBean()
+public class Bean implements Serializable{
+		
+  private String name;
+
+  public String getName() { 
+    return name; 
+  }
+
+  @propertyChanger()
+  public void setName( String n ) {
+    name = n;
+  }
+}
@@ -0,0 +1,24 @@
+
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
+
+public class BeanTestCase implements PropertyChangeListener{
+
+  public void propertyChange(PropertyChangeEvent e){
+    System.out.println("Property [" + e.getPropertyName() + "[ changed from " +
+			e.getOldValue() + " to " + e.getNewValue() );
+  }
+	
+  public static void main(String [] argv) {
+    new BeanTestCase().testPropertyChange();
+  }
+
+  public void testPropertyChange(){
+    Bean b = new Bean();
+    b.addPropertyChangeListener( "name", this );
+    b.setName( "Test" );
+    if (!b.getName().equals("Test")) throw new RuntimeException("");
+    b.setName( "Test1" );
+    if (!b.getName().equals("Test1")) throw new RuntimeException("");
+  }
+}
@@ -0,0 +1,24 @@
+
+import java.beans.PropertyChangeListener;
+import java.beans.PropertyChangeSupport;
+import java.lang.reflect.Field;
+import org.aspectj.lang.Signature;
+
+public aspect PropertySupportAspect5 {
+  
+  declare parents: @javaBean * implements PropertySupport;
+	
+  public interface PropertySupport{  }
+			
+  public void PropertySupport.addPropertyChangeListener(PropertyChangeListener listener){  }
+			
+  public void PropertySupport.addPropertyChangeListener( String propertyName,PropertyChangeListener listener){  }
+		    
+  public void PropertySupport.removePropertyChangeListener( String propertyName, PropertyChangeListener listener) {  }
+			
+  public void PropertySupport.removePropertyChangeListener(PropertyChangeListener listener) {  }
+			
+  public void PropertySupport.hasListeners(String propertyName) {  }
+
+  public void PropertySupport.firePropertyChange( Bean b, String property, String oldval, String newval) {  }
+}
@@ -0,0 +1,8 @@
+
+import java.lang.annotation.*;
+import java.lang.*;
+
+@Retention(RetentionPolicy.CLASS)
+@Target({ ElementType.TYPE })
+public @interface javaBean {
+}
@@ -0,0 +1,9 @@
+
+import java.lang.annotation.*;
+import java.lang.*;
+
+@Retention( RetentionPolicy.RUNTIME )
+@Target({ ElementType.METHOD })
+public @interface propertyChanger {
+}
+
@@ -140,7 +140,7 @@ public class WeaverMessages {
 	public static final String BINDING_NON_RUNTIME_RETENTION_ANNOTATION = "bindingNonRuntimeRetentionAnnotation";
 
 	public static final String INCORRECT_TARGET_FOR_DECLARE_ANNOTATION = "incorrectTargetForDeclareAnnotation";
-	
+	public static final String NO_MATCH_BECAUSE_SOURCE_RETENTION = "noMatchBecauseSourceRetention";
 
 	// Generics
 	public static final String CANT_DECP_MULTIPLE_PARAMETERIZATIONS="cantDecpMultipleParameterizations";
@@ -151,7 +151,7 @@ incorrectTargetForDeclareAnnotation={0} is not a valid target for annotation {1}
 
 referenceToNonAnnotationType=Type referred to is not an annotation type: {0}
 bindingNonRuntimeRetentionAnnotation=Annotation type {0} does not have runtime retention
-
+noMatchBecauseSourceRetention=Failing match because annotation ''{0}'' on type ''{1}'' has SOURCE retention.  Matching allowed when RetentionPolicy is CLASS or RUNTIME
 
 # Generics
 cantDecpMultipleParameterizations=Cannot declare parent {0} onto type {1} since it already has {2} in its hierarchy
@@ -0,0 +1,17 @@
+package com.blueprint.util.aspectj5.test;
+
+import java.io.Serializable;
+
+@javaBean()
+public class Bean implements Serializable{
+		
+		private String name;
+
+		public String getName() {
+			return name;
+		}
+		@propertyChanger()
+		public void setName( String name ) {
+			this.name = name;
+		}
+}
\ No newline at end of file
@@ -0,0 +1,10 @@
+/**
+ * 
+ */
+package com.blueprint.util.aspectj5.test;
+
+import com.blueprint.util.aspectj5.test.PropertySupportAspect5.PropertySupport;
+
+public aspect BeanSupportAspectj {
+     declare parents: @javaBean * implements PropertySupport;
+}
@@ -0,0 +1,34 @@
+package com.blueprint.util.aspectj5.test;
+
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
+
+import junit.framework.TestCase;
+
+public class BeanTestCase extends TestCase implements PropertyChangeListener{
+
+	public void setUp() throws Exception{
+		super.setUp();
+	}
+
+	public void TearDown() throws Exception{
+		super.setUp();
+	}
+	
+	public void propertyChange(PropertyChangeEvent e){
+	      System.out.println("Property [" + e.getPropertyName() + "[ changed from " +
+	    		  							e.getOldValue() + " to " + e.getNewValue() );
+    }
+	
+    public static void main(String [] argv) {
+      new BeanTestCase().testPropertyChange();
+    }
+	public void testPropertyChange(){
+		Bean b = new Bean();
+		b.addPropertyChangeListener( "name", this );
+		b.setName( "Test" );
+		assertEquals( b.getName() , "Test" );
+		b.setName( "Test1" );
+		assertEquals( b.getName() , "Test1" );
+	}
+}
@@ -0,0 +1,90 @@
+package com.blueprint.util.aspectj5.test;
+
+import java.beans.PropertyChangeListener;
+import java.beans.PropertyChangeSupport;
+import java.lang.reflect.Field;
+import org.aspectj.lang.Signature;
+
+public aspect PropertySupportAspect5 {
+		
+			PropertyChangeSupport PropertySupport.support = new PropertyChangeSupport(this);
+
+			public interface PropertySupport{
+				  public void addPropertyChangeListener( PropertyChangeListener listener );
+				  public void addPropertyChangeListener( String propertyName,
+					                                     PropertyChangeListener listener );
+				  public void removePropertyChangeListener( String propertyName,
+					                                        PropertyChangeListener listener );
+				  public void removePropertyChangeListener( PropertyChangeListener listener );
+				  public void hasListeners( String propertyName );
+				  public void firePropertyChange( Bean b,
+							 					  String property,
+							 					  String oldval,
+							 					  String newval );
+			}
+			
+			public void PropertySupport.addPropertyChangeListener(PropertyChangeListener listener){
+			    support.addPropertyChangeListener(listener);
+			}
+			
+			public void PropertySupport.addPropertyChangeListener( String propertyName,
+			                                                       PropertyChangeListener listener){
+
+				support.addPropertyChangeListener(propertyName, listener);
+		    }
+		    
+			public void PropertySupport.removePropertyChangeListener( String propertyName,
+				                                                      PropertyChangeListener listener) {
+				support.removePropertyChangeListener(propertyName, listener);
+		    }
+			
+			public void PropertySupport.removePropertyChangeListener(PropertyChangeListener listener) {
+			    support.removePropertyChangeListener(listener);
+			}
+			
+			public void PropertySupport.hasListeners(String propertyName) {
+			    support.hasListeners(propertyName);
+			}
+
+			pointcut callSetter( Bean b ) 
+		    : call( @propertyChanger * *(..) ) && target( b );
+			
+			void around( Bean b ) : callSetter( b )  {
+			    String propertyName = getField( thisJoinPointStaticPart.getSignature() ).
+			    																getName();
+				System.out.println( "The property is [" + propertyName + "]" );
+				String oldValue = b.getName();
+			    proceed( b );
+			    b.firePropertyChange( b, propertyName, oldValue, b.getName());
+			}
+
+		    private Field getField( Signature signature ){
+		    	Field field = null;
+				System.out.println( "Getting the field name of [" +signature.getName() + "]" );
+		    	
+		    	try{
+		    		String methodName = signature.getName();
+		    		field = signature.getDeclaringType().
+									getDeclaredField( methodName.
+													   substring( 3,
+												                  methodName.length() ).
+												                  			toLowerCase());
+		    		field.setAccessible(true);
+		    	}catch( NoSuchFieldException nsfe ){
+		    		nsfe.printStackTrace();
+		    	}
+				return field;
+			}
+
+			public void PropertySupport.firePropertyChange( Bean b,
+									 						String property,
+									 						String oldval,
+									 						String newval) {
+				System.out.println( "The property is [" + property + "]");
+				System.out.println( "The old value is [" + oldval + "]");
+				System.out.println( "The new value is [" + newval + "]");
+				b.support.firePropertyChange( property,
+							( oldval == null ) ? oldval : new String(oldval),
+				            new String(newval));
+			}
+}
\ No newline at end of file
@@ -0,0 +1,9 @@
+package com.blueprint.util.aspectj5.test;
+
+import java.lang.annotation.*;
+import java.lang.*;
+
+@Retention(RetentionPolicy.SOURCE)
+@Target({ ElementType.TYPE })
+public @interface javaBean {
+}
@@ -0,0 +1,10 @@
+package com.blueprint.util.aspectj5.test;
+
+import java.lang.annotation.*;
+import java.lang.*;
+
+@Retention( RetentionPolicy.RUNTIME )
+@Target({ ElementType.METHOD })
+public @interface propertyChanger {
+}
+
@@ -217,6 +217,10 @@ public class GenericsTests extends XMLBasedAjcTestCase {
     public void testGenericsBang_pr95993() {
 	    runTest("NPE at ClassScope.java:660 when compiling generic class");
     }    
+    
+//    public void testIncompatibleClassChangeError_pr113630() {
+//    	runTest("IncompatibleClassChangeError");
+//    }
 
 	// generic aspects
 	public void testPR96220_GenericAspects1() {runTest("generic aspects - 1");}
@@ -10,6 +10,11 @@
     <ajc-test dir="bugs150" title="Problem with constructor ITDs">
         <compile files="pr112783.aj" options="-1.5"/>
     </ajc-test>
+    
+    <ajc-test dir="bugs150/pr113630" title="IncompatibleClassChangeError">
+        <compile files="Bean.java,BeanSupportAspectj.aj,BeanTestCase.java,javaBean.java,propertyChanger.java,PropertySupportAspect5.aj" options="-1.5"/>
+        <run class="com.blueprint.util.aspectj5.test.BeanTestCase"/>
+    </ajc-test>  
 
     <ajc-test dir="bugs150" title="Generics ClassCastException">
         <compile files="pr113445.aj" options="-1.5,-emacssym"/>
