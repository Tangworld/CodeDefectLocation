@@ -35,6 +35,7 @@ import org.aspectj.org.eclipse.jdt.internal.compiler.parser.Parser;
 import org.aspectj.org.eclipse.jdt.internal.compiler.problem.AbortCompilationUnit;
 import org.aspectj.weaver.AjAttribute;
 import org.aspectj.weaver.AjcMemberMaker;
+import org.aspectj.weaver.Constants;
 import org.aspectj.weaver.NameMangler;
 import org.aspectj.weaver.NewMethodTypeMunger;
 import org.aspectj.weaver.ResolvedMember;
@@ -188,8 +189,9 @@ public class InterTypeMethodDeclaration extends InterTypeDeclaration {
 		// referred to in the parameters/returntype
 		ResolvedMember sig = world.makeResolvedMember(binding,onTypeBinding);
 		sig.resetName(new String(declaredSelector));
-		sig.resetModifiers(declaredModifiers); 
-		
+		int resetModifiers = declaredModifiers;
+		if (binding.isVarargs())  resetModifiers = resetModifiers | Constants.ACC_VARARGS;
+		sig.resetModifiers(resetModifiers); 
 		NewMethodTypeMunger myMunger = new NewMethodTypeMunger(sig, null);
 		setMunger(myMunger);
 		ResolvedType aspectType = world.fromEclipse(classScope.referenceContext.binding);
@@ -449,7 +449,7 @@ public class EclipseFactory {
 		// AMC these next two lines shouldn't be needed once we sort out generic types properly in the world map
 		ResolvedType realDeclaringType = world.resolve(fromBinding(declaringType));
 		if (realDeclaringType.isRawType()) realDeclaringType = realDeclaringType.getGenericType();
-		ResolvedMember ret =  new ResolvedMemberImpl(
+		ResolvedMemberImpl ret =  new ResolvedMemberImpl(
 			binding.isConstructor() ? Member.CONSTRUCTOR : Member.METHOD,
 			realDeclaringType,
 			binding.modifiers,
@@ -458,6 +458,9 @@ public class EclipseFactory {
 			fromBindings(binding.parameters),
 			fromBindings(binding.thrownExceptions)
 			);
+		if (binding.isVarargs()) {
+			ret.setVarargsMethod();
+		}
 		if (typeVariablesForThisMember.size()!=0) {
 			UnresolvedType[] tvars = new UnresolvedType[typeVariablesForThisMember.size()];
 			int i =0;
@@ -131,7 +131,7 @@ public class EclipseTypeMunger extends ConcreteTypeMunger {
 			binding.modifiers = (binding.modifiers & (IConstants.AccPublic | IConstants.AccProtected | IConstants.AccPrivate));
 			if (isAbstract) binding.modifiers |= IConstants.AccAbstract;
 		}
-		
+		if (munger.getSignature().isVarargsMethod()) binding.modifiers |= IConstants.AccVarargs;
 		findOrCreateInterTypeMemberFinder(sourceType).addInterTypeMethod(binding);
 		return true;
 	}
Binary files differ
Binary files differ
Binary files differ
@@ -0,0 +1,25 @@
+public class pr110906 {
+
+  public static void main(String []argv) {
+    new pr110906().printNames(new Object[]{"a","b","c"});
+    new pr110906().printNames("a","b","c"); // should be allowed!!
+    new pr110906().printNames2("a","b","c"); // should be allowed!!
+  }
+
+}
+
+aspect A {
+
+  private interface HasName {}
+
+  declare parents: (pr110906) implements HasName;
+
+  public void HasName.printNames(Object... names) {
+    System.out.println(names[0]);
+  }
+
+  public void HasName.printNames2(String... names) {
+    System.out.println(names[0]);
+  }
+
+}
@@ -53,6 +53,8 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testBadDecp_pr110788_2() { runTest("bad generic decp - 2");}
   public void testBadDecp_pr110788_3() { runTest("bad generic decp - 3");}
   public void testBadDecp_pr110788_4() { runTest("bad generic decp - 4");}
+
+  public void testVarargsITD_pr110906() { runTest("ITD varargs problem");}
 
   public void testBadGenericSigAttribute_pr110927() { 
 	runTest("cant create signature attribute");
@@ -4900,7 +4900,14 @@
    </ajc-test>
 
    <ajc-test dir="bugs150" title="ITD varargs problem">
-     <compile files="pr110906.aj"/>
+     <compile files="pr110906.aj" options="-1.5"/>
+     <run class="pr110906">
+       <stdout>
+           <line text="a"/>
+           <line text="a"/>
+           <line text="a"/>
+       </stdout>
+     </run>
    </ajc-test>
 
    <ajc-test dir="bugs150" title="generic itds and abstract method error">
@@ -321,10 +321,14 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
     	return (modifiers & Constants.ACC_VARARGS)!=0;
     }
 
+    public void setVarargsMethod() {
+    	modifiers = modifiers | Constants.ACC_VARARGS;
+    }
+    
 	public boolean isSynthetic() {
 		return false;
 	}
-    
+
     public void write(DataOutputStream s) throws IOException {
     	getKind().write(s);
     	getDeclaringType().write(s);
@@ -335,6 +339,7 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 
 		s.writeInt(getStart());
 		s.writeInt(getEnd());
+		s.writeBoolean(isVarargsMethod());
 
 		// Write out any type variables...
 		if (typeVariables==null) {
@@ -356,15 +361,21 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 
 
     public static ResolvedMemberImpl readResolvedMember(VersionedDataInputStream s, ISourceContext sourceContext) throws IOException {
-    	ResolvedMemberImpl m = new ResolvedMemberImpl(Kind.read(s), UnresolvedType.read(s), s.readInt(), s.readUTF(), s.readUTF());
+    	
+    	ResolvedMemberImpl m = new ResolvedMemberImpl(Kind.read(s), UnresolvedType.read(s), s.readInt(), 
+    			s.readUTF(), s.readUTF());
 		m.checkedExceptions = UnresolvedType.readArray(s);
 
 		m.start = s.readInt();
 		m.end = s.readInt();
 		m.sourceContext = sourceContext;
 
-		// Read in the type variables...
+		
 		if (s.getMajorVersion()>=AjAttribute.WeaverVersionInfo.WEAVER_VERSION_MAJOR_AJ150) {
+			
+			boolean isvarargs = s.readBoolean();
+			if (isvarargs) m.setVarargsMethod();
+
 			int tvcount = s.readInt();
 			if (tvcount!=0) {
 				m.typeVariables = new UnresolvedType[tvcount];
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
Binary files differ
