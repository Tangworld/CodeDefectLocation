@@ -19,9 +19,11 @@ import org.aspectj.bridge.Message;
 import org.aspectj.bridge.MessageUtil;
 import org.aspectj.util.LangUtil;
 import org.aspectj.weaver.ICrossReferenceHandler;
+import org.aspectj.weaver.Lint;
 import org.aspectj.weaver.ResolvedType;
 import org.aspectj.weaver.UnresolvedType;
 import org.aspectj.weaver.World;
+import org.aspectj.weaver.Lint.Kind;
 import org.aspectj.weaver.bcel.BcelWeaver;
 import org.aspectj.weaver.bcel.BcelWorld;
 import org.aspectj.weaver.bcel.Utility;
@@ -175,9 +177,8 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
         		info("no configuration found. Disabling weaver for class loader " + getClassLoaderName(loader));
             }
         } catch (Exception e) {
-            weaver.getWorld().getMessageHandler().handleMessage(
-                    new Message("Register definition failed", IMessage.WARNING, e, null)
-            );
+            enabled = false;// will allow very fast skip in shouldWeave()
+            warn("register definition failed",e);
         }
     }
 
@@ -284,6 +285,12 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
         }
     }
 
+    protected void lint (String name, String[] infos) {
+    	Lint lint = bcelWorld.getLint();
+    	Kind kind = lint.getLintKind(name);
+    	kind.signal(infos,null,null);
+    }
+    
     /**
      * Register the aspect, following include / exclude rules
      *
@@ -312,6 +319,10 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
                     	namespace = namespace.append(";"+aspectClassName);
                     }
                 }
+                else {
+//                	warn("aspect excluded: " + aspectClassName);
+                	lint("aspectExcludedByConfiguration", new String[] { aspectClassName, getClassLoaderName(loader) });
+                }
             }
         }
 
@@ -0,0 +1,5 @@
+<aspectj>
+	<aspects>
+		<include within="pakkage.*"/>
+	</aspects>
+</aspectj>
@@ -0,0 +1,8 @@
+<aspectj>
+	<aspects>
+		<include within="pakkage.*"/>
+	</aspects>
+
+	<weaver options="-Xlint:warning">
+	</weaver>
+</aspectj>
@@ -57,6 +57,14 @@ public class LTWTests extends org.aspectj.testing.XMLBasedAjcTestCase {
   		runTest("Use abstract aspect for ITD using aop.xml");
   	}
 
+  	public void testAspectsInclude () {
+  		runTest("Ensure a subset of inherited aspects is used for weaving");
+  	}
+
+  	public void testAspectsIncludeWithLintWarning () {
+  		runTest("Ensure weaver lint warning issued when an aspect is not used for weaving");
+  	}
+
   	/*
   	 * Allow system properties to be set and restored
   	 * TODO maw move to XMLBasedAjcTestCase or RunSpec
@@ -158,4 +158,60 @@
             </stderr>
         </run>
     </ajc-test>
+
+	<ajc-test dir="ltw"
+      title="Ensure a subset of inherited aspects is used for weaving"
+      keywords="aspects, include">
+        <compile
+        	files="Main.java"
+			outjar="main.jar"
+        >
+        </compile>	
+        <compile
+        	classpath="main.jar"
+        	files="Aspect1.aj, Aspect2.aj, pakkage/Aspect3.aj"
+        	outjar="aspects.jar"
+        	options="-outxml"
+        >
+        </compile>	
+        <run class="Main" ltw="aop-aspectsinclude.xml">
+        	<stdout>
+                <line text="Main.main"/>
+                <line text="Main.test1"/>
+                <line text="Main.test2"/>
+            </stdout>
+        	<stderr>
+                <line text="pakkage.Aspect3.before_test2"/>
+            </stderr>
+        </run>
+    </ajc-test>
+
+	<ajc-test dir="ltw"
+      title="Ensure weaver lint warning issued when an aspect is not used for weaving"
+      keywords="aspects, include, lint">
+        <compile
+        	files="Main.java"
+			outjar="main.jar"
+        >
+        </compile>	
+        <compile
+        	classpath="main.jar"
+        	files="Aspect1.aj, Aspect2.aj, pakkage/Aspect3.aj"
+        	outjar="aspects.jar"
+        	options="-outxml"
+        >
+        </compile>	
+        <run class="Main" ltw="aop-aspectsincludewithlintwarning.xml">
+        	<stdout>
+                <line text="Main.main"/>
+                <line text="Main.test1"/>
+                <line text="Main.test2"/>
+            </stdout>
+        	<stderr>
+				<line text="warning aspect Aspect1 exluded for class loader org.aspectj.weaver.loadtime.WeavingURLClassLoader [Xlint:aspectExcludedByConfiguration]"/>
+				<line text="warning aspect Aspect2 exluded for class loader org.aspectj.weaver.loadtime.WeavingURLClassLoader [Xlint:aspectExcludedByConfiguration]"/>
+                <line text="pakkage.Aspect3.before_test2"/>
+            </stderr>
+        </run>
+    </ajc-test>
 
@@ -102,6 +102,9 @@ public class Lint {
 	public final Kind noExplicitConstructorCall = 
 		new Kind("noExplicitConstructorCall","inter-type constructor does not contain explicit constructor call: field initializers in the target type will not be executed");
 
+	public final Kind aspectExcludedByConfiguration = 
+		new Kind("aspectExcludedByConfiguration","aspect {0} exluded for class loader {1}");
+	
     public Lint(World world) {
 		this.world = world;
 	}
@@ -30,3 +30,5 @@ elementAlreadyAnnotated = warning
 runtimeExceptionNotSoftened = warning
 uncheckedArgument = warning
 noExplicitConstructorCall = warning
+
+aspectExcludedByConfiguration = ignore
@@ -31,6 +31,7 @@ import java.util.StringTokenizer;
 import org.aspectj.bridge.AbortException;
 import org.aspectj.bridge.IMessage;
 import org.aspectj.bridge.IMessageHandler;
+import org.aspectj.bridge.Message;
 import org.aspectj.bridge.MessageUtil;
 import org.aspectj.bridge.MessageWriter;
 import org.aspectj.bridge.IMessage.Kind;
@@ -327,6 +328,10 @@ public class WeavingAdaptor {
 		return MessageUtil.warn(messageHandler,message);
 	}
 
+	protected boolean warn (String message, Throwable th) {
+        return messageHandler.handleMessage(new Message("Register definition failed", IMessage.WARNING, th, null));
+	}
+	
 	protected boolean error (String message) {
 		return MessageUtil.error(messageHandler,message);
 	}
@@ -167,11 +167,12 @@
                 <pointcut name="tracingScope" expression="within(org.maw.*)"/>
               </concrete-aspect>
 
-              <!-- Of the set of aspects known to the weaver, use aspects matching
-                   the type pattern "com..*" for weaving. -->
+              <!-- Of the set of aspects declared in this sole aop.xml,
+                   use aspects matching the type pattern "com..*" for weaving. -->
               <include within="com..*"/>
 
-              <!-- Do not use any aspects with the @CoolAspect annotation for weaving -->
+              <!-- Of the set of aspects declared in this sole aop.xml,
+                   do not use any aspects with the @CoolAspect annotation for weaving -->
               <exclude within="@CoolAspect *"/>
 
             </aspects>
@@ -212,14 +213,20 @@
             </para>
 
             <para>
-                The aspects element may optionally contain one or more include and
-                exclude elements (by default, all defined aspects are used for weaving).
+                The <literal>aspects</literal> element may optionally contain one or more <literal>include</literal> and
+                <literal>exclude</literal> elements (by default, all defined aspects are used for weaving).
                 Specifying include or exclude elements restricts the set of defined
                 aspects to be used for weaving to those that are matched by an include
-                pattern, but not by an exclude pattern. The 'within' attribute accepts
+                pattern, but not by an exclude pattern. The <literal>within</literal> attribute accepts
                 a type pattern of the same form as a within pcd, except that &amp;&amp;
                 and || are replaced by 'AND' and 'OR'.
             </para>
+            <para>
+                Note that <literal>include</literal> and <literal>exclude</literal> affects the declared list of aspects (or concrete-aspect) defined in this
+                sole aop.xml and has no side effect on other aop.xml files.
+                Also note it is required to use <literal>aspect</literal> or <literal>concrete-aspect</literal> elements and that include does not
+                mean "pick any aspect you 'll find" - as the aspect list must be known by the weaver.
+            </para>
 
             <para>
                 The weaver element is used to pass options to the weaver and to specify
@@ -518,6 +525,11 @@
             Note that dynamic proxy representations are exposed to the LTW infrastructure and are not considered
             a special case.
         </para>
+
+        <para>
+            Some lint options behave differently when used under load-time weaving. The <literal>adviceDidNotMatch</literal>
+            won't be handled as a warn (as during compile time) but as an info message.
+        </para>
     </sect1>
 
     <sect1 id="ltw-packaging">
@@ -92,16 +92,13 @@ dump
 aspects
 *********************************************************************************************************************************
 [aspects] defines a set of aspects
-TODO we were about to use include but it is already used for weaver scope with "within" which is not relevant
-for aspects. I (AV) decided to use only aspect and provide include= thru name, and exclude= as exclude.
-see sample.
+Note: include only include among Union{aspect, concrete-aspect} WITHIN THIS SOLE aop.xml
 ******************************************************************************************************************************-->
 <!ELEMENT aspects (
-    (aspect | exclude | concrete-aspect)*
+    (aspect | exclude | include | concrete-aspect)*
 )>
 <!--*****************************************************************************************************************************
 aspect
-TODO: did not used include since already used in weaver/include@within and @within does not makes sense
 *********************************************************************************************************************************
 [aspect] defines an aspect to include
     @name   FQN of the aspect, nested class must use $
@@ -59,6 +59,8 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
     private List m_excludeStartsWith = new ArrayList();
     private List m_aspectExcludeTypePattern = new ArrayList();
     private List m_aspectExcludeStartsWith = new ArrayList();
+    private List m_aspectIncludeTypePattern = new ArrayList();
+    private List m_aspectIncludeStartsWith = new ArrayList();
 
     private StringBuffer namespace;
     private IWeavingContext weavingContext;
@@ -66,7 +68,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
     public ClassLoaderWeavingAdaptor(final ClassLoader loader, IWeavingContext wContext) {
         super(null);
     }
-    
+
     void initialize(final ClassLoader loader, IWeavingContext wContext) {
         //super(null);// at this stage we don't have yet a generatedClassHandler to define to the VM the closures
         this.generatedClassHandler = new GeneratedClassHandler() {
@@ -88,7 +90,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
                 Aj.defineClass(loader, name, bytes);// could be done lazily using the hook
             }
         };
-        
+
         if(wContext==null){
         	weavingContext = new DefaultWeavingContext(loader);
         }else{
@@ -142,7 +144,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
                     definitions.add(DocumentParser.parse((new File(file)).toURL()));
                 }
             }
-            
+
             String resourcePath = System.getProperty("org.aspectj.weaver.loadtime.configuration",AOP_XML);
     		StringTokenizer st = new StringTokenizer(resourcePath,";");
 
@@ -164,6 +166,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
             // AV - see #113511
             if (!definitions.isEmpty()) {
                 registerAspectExclude(weaver, loader, definitions);
+                registerAspectInclude(weaver, loader, definitions);
                 registerAspects(weaver, loader, definitions);
                 registerIncludeExclude(weaver, loader, definitions);
                 registerDump(weaver, loader, definitions);
@@ -203,7 +206,6 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
         world.setPinpointMode(weaverOption.pinpoint);
         weaver.setReweavableMode(weaverOption.notReWeavable);
         world.setXnoInline(weaverOption.noInline);
-        //world.setBehaveInJava5Way(weaverOption.java5);//TODO should be autodetected ?
         // AMC - autodetect as per line below, needed for AtAjLTWTests.testLTWUnweavable
         world.setBehaveInJava5Way(LangUtil.is15VMOrGreater());
         //-Xlintfile: first so that lint wins
@@ -261,6 +263,22 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
         }
     }
 
+    private void registerAspectInclude(final BcelWeaver weaver, final ClassLoader loader, final List definitions) {
+        String fastMatchInfo = null;
+        for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
+            Definition definition = (Definition) iterator.next();
+            for (Iterator iterator1 = definition.getAspectIncludePatterns().iterator(); iterator1.hasNext();) {
+                String include = (String) iterator1.next();
+                TypePattern includePattern = new PatternParser(include).parseTypePattern();
+                m_aspectIncludeTypePattern.add(includePattern);
+                fastMatchInfo = looksLikeStartsWith(include);
+                if (fastMatchInfo != null) {
+                    m_aspectIncludeStartsWith.add(fastMatchInfo);
+                }
+            }
+        }
+    }
+
     /**
      * Register the aspect, following include / exclude rules
      *
@@ -464,19 +482,28 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
         return accept;
     }
 
+    //FIXME we don't use include/exclude of others aop.xml
+    //this can be nice but very dangerous as well to change that
     private boolean acceptAspect(String aspectClassName) {
         // avoid ResolvedType if not needed
-        if (m_aspectExcludeTypePattern.isEmpty()) {
+        if (m_aspectExcludeTypePattern.isEmpty() && m_aspectIncludeTypePattern.isEmpty()) {
             return true;
         }
 
         // still try to avoid ResolvedType if we have simple patterns
+        // EXCLUDE: if one match then reject
         String fastClassName = aspectClassName.replace('/', '.').replace('.', '$');
         for (int i = 0; i < m_aspectExcludeStartsWith.size(); i++) {
             if (fastClassName.startsWith((String)m_aspectExcludeStartsWith.get(i))) {
                 return false;
             }
         }
+        //INCLUDE: if one match then accept
+        for (int i = 0; i < m_aspectIncludeStartsWith.size(); i++) {
+            if (fastClassName.startsWith((String)m_aspectIncludeStartsWith.get(i))) {
+                return true;
+            }
+        }
 
         // needs further analysis
         ResolvedType classInfo = weaver.getWorld().resolve(UnresolvedType.forName(aspectClassName), true);
@@ -488,7 +515,17 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
                 return false;
             }
         }
-        return true;
+        //include are "OR"ed
+        boolean accept = true;//defaults to true if no include
+        for (Iterator iterator = m_aspectIncludeTypePattern.iterator(); iterator.hasNext();) {
+            TypePattern typePattern = (TypePattern) iterator.next();
+            accept = typePattern.matchesStatically(classInfo);
+            if (accept) {
+                break;
+            }
+            // goes on if this include did not match ("OR"ed)
+        }
+        return accept;
     }
 
     public boolean shouldDump(String className) {
@@ -508,11 +545,11 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
         }
         return false;
     }
-    
+
     /*
      *  shared classes methods
      */
-    
+
     /**
 	 * @return Returns the key.
 	 */
@@ -532,7 +569,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
     	}
     	return false;
     }
-    
+
     /**
      * Flush the generated classes cache
      */
@@ -33,6 +33,8 @@ public class Definition {
 
     private List m_aspectExcludePatterns;
 
+    private List m_aspectIncludePatterns;
+
     private List m_concreteAspects;
 
     public Definition() {
@@ -42,6 +44,7 @@ public class Definition {
         m_excludePatterns = new ArrayList(0);
         m_aspectClassNames = new ArrayList();
         m_aspectExcludePatterns = new ArrayList(0);
+        m_aspectIncludePatterns = new ArrayList(0);
         m_concreteAspects = new ArrayList(0);
     }
 
@@ -69,6 +72,10 @@ public class Definition {
         return m_aspectExcludePatterns;
     }
 
+    public List getAspectIncludePatterns() {
+        return m_aspectIncludePatterns;
+    }
+
     public List getConcreteAspects() {
         return m_concreteAspects;
     }
@@ -193,6 +193,11 @@ public class DocumentParser extends DefaultHandler {
             if (!isNull(typePattern)) {
                 m_definition.getAspectExcludePatterns().add(typePattern);
             }
+        } else if (INCLUDE_ELEMENT.equals(qName) && m_inAspects) {
+            String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
+            if (!isNull(typePattern)) {
+                m_definition.getAspectIncludePatterns().add(typePattern);
+            }
         } else {
             throw new SAXException("Unknown element while parsing <aspectj> element: " + qName);
         }
@@ -37,6 +37,7 @@ public class DocumentParserTest extends TestCase {
 
         assertEquals("foo..bar.Goo+", def.getIncludePatterns().get(0));
         assertEquals("@Baz", def.getAspectExcludePatterns().get(0));
+        assertEquals("@Whoo", def.getAspectIncludePatterns().get(0));
         assertEquals("foo..*", def.getDumpPatterns().get(0));
     }
 
@@ -7,6 +7,7 @@
     </weaver>
     <aspects>
         <exclude within="@Baz"/>
+        <include within="@Whoo"/>
         <aspect name="test.Aspect"/>
     </aspects>
 </aspectj>
@@ -37,7 +37,7 @@ public class ConcreteAtAspectTest extends TestCase {
     @Aspect
     abstract static class ConcreteAtAspect {
 
-        @Pointcut()
+        @Pointcut
         abstract void pc();
         // must be abstract
         // for concrete-aspect, must further be no-arg, void
