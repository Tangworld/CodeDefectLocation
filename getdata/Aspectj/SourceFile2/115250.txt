@@ -195,7 +195,15 @@ public class GenericsTests extends XMLBasedAjcTestCase {
 	public void testPR91267_1() {
 		runTest("NPE using generic methods in aspects 1");
 	}
+	
+	public void testParameterizedTypeAndAroundAdvice_PR115250() {
+		runTest("parameterized type and around advice");
+	}
 
+	public void testParameterizedTypeAndAroundAdvice_PR115250_2() {
+		runTest("parameterized type and around advice - 2");
+	}
+	
 	public void testPR91267_2() {
 		runTest("NPE using generic methods in aspects 2");
 	}
@@ -2012,6 +2012,11 @@ public class BcelShadow extends Shadow {
 
 		// !!! THIS BLOCK OF CODE SHOULD BE IN A METHOD CALLED weaveAround(...);
         Member mungerSig = munger.getSignature();
+        //Member originalSig = mungerSig; // If mungerSig is on a parameterized type, originalSig is the member on the generic type
+        if (mungerSig instanceof ResolvedMember) {
+        	ResolvedMember rm = (ResolvedMember)mungerSig;
+        	if (rm.hasBackingGenericMember()) mungerSig = rm.getBackingGenericMember();
+        }
         ResolvedType declaringType = world.resolve(mungerSig.getDeclaringType(),true);
         if (declaringType == ResolvedType.MISSING) {
           IMessage msg = new Message(
@@ -2021,7 +2026,7 @@ public class BcelShadow extends Shadow {
           world.getMessageHandler().handleMessage(msg);
         }
         //??? might want some checks here to give better errors
-        BcelObjectType ot = BcelWorld.getBcelObjectType(declaringType); 
+        BcelObjectType ot = BcelWorld.getBcelObjectType((declaringType.isParameterizedType()?declaringType.getGenericType():declaringType)); 
 
 		LazyMethodGen adviceMethod = ot.getLazyClassGen().getLazyMethodGen(mungerSig);
 		if (!adviceMethod.getCanInline()) {
@@ -2142,7 +2147,7 @@ public class BcelShadow extends Shadow {
         LazyMethodGen localAdviceMethod =
 					new LazyMethodGen(
 						Modifier.PRIVATE | Modifier.FINAL | Modifier.STATIC, 
-						adviceMethod.getReturnType(), 
+						BcelWorld.makeBcelType(mungerSig.getReturnType()), 
 						adviceMethodName,
 						parameterTypes,
 						new String[0],
@@ -2208,7 +2213,7 @@ public class BcelShadow extends Shadow {
 			advice.append(
 		        Utility.createConversion(
 		            getFactory(), 
-		            BcelWorld.makeBcelType(munger.getSignature().getReturnType()), 
+		            BcelWorld.makeBcelType(mungerSig.getReturnType()), 
 		            extractedMethod.getReturnType()));
 		    if (! isFallsThrough()) {
 		        advice.append(InstructionFactory.createReturn(extractedMethod.getReturnType()));
@@ -125,8 +125,12 @@ public class Utility {
             kind = Constants.INVOKEVIRTUAL;
         }
 
+        UnresolvedType targetType = signature.getDeclaringType();
+        if (targetType.isParameterizedType()) {
+        	targetType = targetType.resolve(world).getGenericType();
+        }
         return fact.createInvoke(
-            signature.getDeclaringType().getName(),
+            targetType.getName(),
             signature.getName(),
             BcelWorld.makeBcelType(signature.getReturnType()),
             BcelWorld.makeBcelTypes(signature.getParameterTypes()),
@@ -280,9 +280,13 @@ public abstract class Advice extends ShadowMunger {
 	}
 
 	public UnresolvedType getDeclaringAspect() {
-		return signature.getDeclaringType();
+		return getOriginalSignature().getDeclaringType();
 	}
 
+	protected Member getOriginalSignature() { 
+		return signature;
+	}
+	
 	protected String extraParametersToString() {
 		if (getExtraParameterFlags() == 0) {
 			return "";
@@ -48,7 +48,7 @@ public class Checker extends ShadowMunger {
 		throw new RuntimeException("illegal state");
 	}
 
-	public ShadowMunger parameterizeWith(Map typeVariableMap) {
+	public ShadowMunger parameterizeWith(ResolvedType declaringType,Map typeVariableMap) {
 		Checker ret = new Checker(
 							getPointcut().parameterizeWith(typeVariableMap),
 							getStart(),
@@ -684,7 +684,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 			if (munger != null) {
 				if (this.isParameterizedType()) {
 					//munger.setPointcut(munger.getPointcut().parameterizeWith(typeVariableMap));
-					munger = munger.parameterizeWith(typeVariableMap);
+					munger = munger.parameterizeWith(this,typeVariableMap);
 					if (munger instanceof Advice) {
 						Advice advice = (Advice) munger;
 						// update to use the parameterized signature...
@@ -64,7 +64,7 @@ public abstract class ShadowMunger implements PartialOrder.PartialComparable, IH
     	return pointcut.match(shadow).maybeTrue();
     }
 
-    public abstract ShadowMunger parameterizeWith(Map typeVariableMap); 
+    public abstract ShadowMunger parameterizeWith(ResolvedType declaringType,Map typeVariableMap); 
 
 	public int fallbackCompareTo(Object other) {
 		return toString().compareTo(toString());
@@ -87,9 +87,16 @@ public class BcelAdvice extends Advice {
 		return ret;
 	}
 
-	public ShadowMunger parameterizeWith(Map typeVariableMap) {
+	public ShadowMunger parameterizeWith(ResolvedType declaringType,Map typeVariableMap) {
 		Pointcut pc = getPointcut().parameterizeWith(typeVariableMap);
-		BcelAdvice ret = new BcelAdvice(this.attribute,pc,this.signature,this.concreteAspect);
+		
+		BcelAdvice ret = null;
+		Member adviceSignature = signature;		
+		// allows for around advice where the return value is a type variable (see pr115250)
+		if (signature instanceof ResolvedMember) {
+			adviceSignature = ((ResolvedMember)signature).parameterizedWith(declaringType.getTypeParameters(),declaringType,declaringType.isParameterizedType());
+		}
+		ret = new BcelAdvice(this.attribute,pc,adviceSignature,this.concreteAspect);
 		return ret;
 	}
 
@@ -503,7 +510,16 @@ public class BcelAdvice extends Advice {
 
     public InstructionList getNonTestAdviceInstructions(BcelShadow shadow) {
         return new InstructionList(
-            Utility.createInvoke(shadow.getFactory(), shadow.getWorld(), getSignature()));
+            Utility.createInvoke(shadow.getFactory(), shadow.getWorld(), getOriginalSignature()));
+    }
+    
+    public Member getOriginalSignature() {
+    	Member sig = getSignature();
+    	if (sig instanceof ResolvedMember) {
+    		ResolvedMember rsig = (ResolvedMember)sig;
+    		if (rsig.hasBackingGenericMember()) return rsig.getBackingGenericMember();
+    	}
+    	return sig;
     }
 
     public InstructionList getTestInstructions(
@@ -649,6 +649,7 @@ public class ResolvedMemberImpl extends MemberImpl implements IHasPosition, Anno
 		ret.setTypeVariables(getTypeVariables());
 		ret.setSourceContext(getSourceContext());
 		ret.setPosition(getStart(),getEnd());
+		ret.setParameterNames(getParameterNames());
 		return ret;
 	}
 
@@ -69,12 +69,24 @@
     </ajc-test>
 
     <ajc-test dir="bugs150" title="parameterized type and around advice">
-        <compile files="pr115250.aj" options="-1.5 -Xlint:ignore"/>
-        <run class="pr115250"/>
-          <!--stderr>
-            <line text="Advice running"/>
+        <compile files="pr115250.aj" options="-1.5 -Xlint:ignore">
+          <!-- this first error happens twice, once for each piece of around advice -->
+          <message kind="error" line="10" text="incompatible return type applying to constructor-execution(void pr115250$C.&lt;init&gt;())"/>
+          <message kind="error" line="17" text="incompatible return type applying to constructor-execution(void pr115250$C.&lt;init&gt;())"/>
+          <message kind="error" line="27" text="incompatible return type applying to constructor-execution(void pr115250$C.&lt;init&gt;())"/>
+        </compile>
+    </ajc-test>
+    
+    <ajc-test dir="bugs150" title="parameterized type and around advice - 2">
+        <compile files="pr115250_2.aj" options="-1.5 -Xlint:ignore -showWeaveInfo">
+          	<message kind="weave" text="Join point 'method-execution(pr115250_2$C pr115250_2$C.foo())' in Type 'pr115250_2$C' (pr115250_2.aj:7) advised by around advice from 'pr115250_2$A' (pr115250_2.aj:22)"/>
+			<message kind="weave" text="Join point 'method-execution(pr115250_2$C pr115250_2$C.foo())' in Type 'pr115250_2$C' (pr115250_2.aj:7) advised by around advice from 'pr115250_2$Normal' (pr115250_2.aj:12)"/>
+		</compile>
+        <run class="pr115250_2">
+          <stderr>
+            <line text="funky advice running"/>
           </stderr>
-        </run-->
+        </run>
     </ajc-test>
 
     <ajc-test dir="bugs150/pr115788" title="parser exception">
@@ -0,0 +1,36 @@
+public class pr115250 {
+	public static void main(String[] args) {
+		test();
+	}
+	public static void test() {
+		new C();
+	}
+
+	static class C {
+		C() {
+			System.err.println("C.new() running");
+		}		
+	}
+
+	// properly get compiler error wrt return type of join point
+	static aspect Normal {
+		C around() : execution(C.new()) {
+			return proceed();
+		}
+	}
+	
+	
+	// no compiler error wrt return type of join point
+	
+	static abstract aspect SS<Target> {
+		abstract protected pointcut creation();
+		Target around() : creation() { // expect CE for execution(C.new());
+			System.err.println("Advice running");
+			return proceed(); 
+		}
+	}
+	
+	static aspect A extends SS<C> {
+		protected pointcut creation() : execution(C.new());
+	}
+}
@@ -0,0 +1,38 @@
+public class pr115250_2 {
+	public static void main(String[] args) {
+		test();
+	}
+	public static void test() {
+		new C().foo();
+	}
+
+	static class C {
+		C() {
+			System.err.println("C.new() running");
+		}		
+
+                C foo() { return null; }
+	}
+
+	// properly get compiler error wrt return type of join point
+	static aspect Normal {
+		C around() : execution(* C.foo()) {
+			return proceed();
+		}
+	}
+	
+	
+	// no compiler error wrt return type of join point
+	
+	static abstract aspect SS<Target> {
+		abstract protected pointcut creation();
+		Target around() : creation() { // expect CE for execution(C.new());
+			System.err.println("funky advice running");
+			return proceed(); 
+		}
+	}
+	
+	static aspect A extends SS<C> {
+		protected pointcut creation() : execution(* C.foo());
+	}
+}
