@@ -947,8 +947,12 @@ public class BcelWeaver implements IWeaver {
 		for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
 		    UnwovenClassFile classFile = (UnwovenClassFile)i.next();
 			String className = classFile.getClassName();
-		    BcelObjectType classType = getClassType(className);			            
-			processReweavableStateIfPresent(className, classType);
+		    BcelObjectType classType = getClassType(className);
+		    
+		    // null return from getClassType() means the delegate is an eclipse source type - so
+		    // there *cant* be any reweavable state... (he bravely claimed...)
+		    if (classType !=null)
+		    	processReweavableStateIfPresent(className, classType);
 		}
 
 		requestor.addingTypeMungers();
@@ -1120,7 +1124,7 @@ public class BcelWeaver implements IWeaver {
 		}
     }
 
-	// helper method
+	/** helper method - will return NULL if the underlying delegate is an EclipseSourceType and not a BcelObjectType */
     public BcelObjectType getClassType(String forClass) {
         return BcelWorld.getBcelObjectType(world.resolve(forClass));    	
     }
@@ -448,9 +448,18 @@ public class BcelWorld extends World implements Repository {
         return new BcelPerClauseAspectAdder(aspect, kind);
     }
 
+    /**
+     * Retrieve a bcel delegate for an aspect - this will return NULL if the
+     * delegate is an EclipseSourceType and not a BcelObjectType - this happens
+     * quite often when incrementally compiling.
+     */
 	public static BcelObjectType getBcelObjectType(ResolvedType concreteAspect) {
-		//XXX need error checking
-		return (BcelObjectType) ((ReferenceType)concreteAspect).getDelegate();
+		ReferenceTypeDelegate rtDelegate = ((ReferenceType)concreteAspect).getDelegate();
+		if (rtDelegate instanceof BcelObjectType) {
+			return (BcelObjectType)rtDelegate;
+		} else {
+			return null;
+		}
 	}
 
 	public void tidyUp() {
