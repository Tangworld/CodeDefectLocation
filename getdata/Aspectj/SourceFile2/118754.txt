@@ -125,7 +125,7 @@ public class ConcreteAspectCodeGen {
 
         m_parent = m_world.resolve(m_concreteAspect.extend, true);
         // handle inner classes
-        if (m_parent.equals(ResolvedType.MISSING)) {
+        if (m_parent.isMissing()) {
             // fallback on inner class lookup mechanism
             String fixedName = m_concreteAspect.extend;
             int hasDot = fixedName.lastIndexOf('.');
@@ -135,7 +135,7 @@ public class ConcreteAspectCodeGen {
                 fixedName = new String(fixedNameChars);
                 hasDot = fixedName.lastIndexOf('.');
                 m_parent = m_world.resolve(UnresolvedType.forName(fixedName), true);
-                if (!m_parent.equals(ResolvedType.MISSING)) {
+                if (!m_parent.isMissing()) {
                     break;
                 }
             }
@@ -253,7 +253,7 @@ public class EclipseFactory {
 			String baseTypeSignature = null;
 
 			ResolvedType baseType = getWorld().resolve(UnresolvedType.forName(getName(binding)),true);
-			if (baseType != ResolvedType.MISSING) {
+			if (!baseType.isMissing()) {
 				// can legitimately be missing if a bound refers to a type we haven't added to the world yet...
 				if (!baseType.isGenericType() && arguments!=null) baseType = baseType.getGenericType();
 				baseTypeSignature = baseType.getErasureSignature();
@@ -966,7 +966,7 @@ public class EclipseFactory {
 			UnresolvedType complexTx = fromBinding(binding); // fully aware of any generics info
 			ResolvedType cName = world.resolve(complexTx,true);
 			ReferenceType complexName = null;
-			if (cName != ResolvedType.MISSING) {
+			if (!cName.isMissing()) {
 				complexName = (ReferenceType) cName;
 				complexName = (ReferenceType) complexName.getGenericType();
 				if (complexName == null) complexName = new ReferenceType(complexTx,world);
@@ -314,7 +314,7 @@ public class AsmElementFormatter {
 		String label;
 		UnresolvedType typeX = tp.getExactType();
 
-		if (typeX != ResolvedType.MISSING) {
+		if (!ResolvedType.isMissing(typeX)) {
 			label = typeX.getName();
 			if (tp.isIncludeSubtypes()) label += "+";
 		} else {
@@ -60,6 +60,14 @@
         </java>
     </target>
 
+    <target name="ltw.DumpProxyTest">
+        <java fork="yes" classname="ataspectj.TestProxyGenerator" failonerror="yes">
+            <classpath refid="aj.path"/>
+            <jvmarg value="-javaagent:${aj.root}/lib/test/loadtime5.jar"/>
+            <jvmarg value="-Daj5.def=ataspectj/aop-dumpproxy.xml"/>
+        </java>
+    </target>
+
     <target name="javac.ltw" depends="compile:javac, ltw"/>
 
     <target name="ltw.Aspect2MainTest">
@@ -0,0 +1,19 @@
+/*******************************************************************************
+ * Copyright (c) 2005 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Common Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/cpl-v10.html
+ * 
+ * Contributors:
+ *     Matthew Webster - initial implementation
+ *******************************************************************************/
+package ataspectj;
+
+public class Test$$EnhancerByCGLIB$$12345 {
+
+	public static void main(String[] args) {
+		System.out.println("Test$$EnhancerByCGLIB$$12345.main()");
+	}
+
+}
@@ -0,0 +1,16 @@
+/*******************************************************************************
+ * Copyright (c) 2005 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Common Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/cpl-v10.html
+ * 
+ * Contributors:
+ *     Matthew Webster - initial implementation
+ *******************************************************************************/
+package ataspectj;
+
+public interface TestInterface {
+
+	public void testMethod ();
+}
@@ -0,0 +1,26 @@
+/*******************************************************************************
+ * Copyright (c) 2005 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Common Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/cpl-v10.html
+ * 
+ * Contributors:
+ *     Matthew Webster - initial implementation
+ *******************************************************************************/
+package ataspectj;
+
+import java.lang.reflect.Proxy;
+
+public class TestProxyGenerator implements TestInterface {
+
+	public void testMethod() {
+	}
+
+	public static void main(String[] args) {
+		Class clazz = TestProxyGenerator.class;
+		Class proxyClazz = Proxy.getProxyClass(clazz.getClassLoader(),new Class[] { TestInterface.class});
+		System.out.println("TestProxyGenerator.main() proxyClazz=" + proxyClazz + ", proxyClassLoader=" + proxyClazz.getClassLoader());
+	}
+
+}
@@ -1,6 +1,6 @@
 <?xml version="1.0"?>
 <aspectj>
-    <weaver options="-XmessageHandlerClass:ataspectj.TestHelper">
-        <dump within="ataspectj.DumpTestThe*" beforeandafter="true"/> 
+    <weaver options="-verbose">
+        <dump within="ataspectj..*" beforeandafter="true"/> 
     </weaver>
 </aspectj>
@@ -4,6 +4,9 @@
 		<aspect name="ataspectj.TestAroundAspect"/>
 	</aspects>
     <weaver options="-Xnoinline">
-        <dump within="ataspectj.DumpTestThe*" beforeandafter="true"/> 
+        <dump within="ataspectj..*Closure*"/> 
+<!--    
+        <dump within="*"/> 
+-->        
     </weaver>
 </aspectj>
@@ -0,0 +1,9 @@
+<?xml version="1.0"?>
+<aspectj>
+    <weaver>
+<!--    
+        <dump within="*..*Proxy*" beforeandafter="true"/> 
+-->        
+        <dump within="*Proxy*" beforeandafter="true"/> 
+    </weaver>
+</aspectj>
@@ -11,12 +11,13 @@
  *******************************************************************************/
 package org.aspectj.systemtest.ajc150.ataspectj;
 
-import org.aspectj.testing.XMLBasedAjcTestCase;
-import org.aspectj.util.FileUtil;
+import java.io.File;
+import java.io.FilenameFilter;
 
 import junit.framework.Test;
 
-import java.io.File;
+import org.aspectj.testing.XMLBasedAjcTestCase;
+import org.aspectj.util.FileUtil;
 
 /**
  * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
@@ -97,11 +98,9 @@ public class AtAjLTWTests extends XMLBasedAjcTestCase {
     public void testLTWDumpBeforeAndAfter() {
         runTest("LTW DumpTest before and after");
 
-        File f = new File("_ajdump/ataspectj/DumpTest.class");
-        assertFalse(f.exists());
-        f = new File("_ajdump/_before/ataspectj/DumpTestTheDump.class");
+        File f = new File("_ajdump/_before/ataspectj/Test$$EnhancerByCGLIB$$12345.class");
         assertTrue(f.exists());
-        f = new File("_ajdump/ataspectj/DumpTestTheDump.class");
+        f = new File("_ajdump/ataspectj/Test$$EnhancerByCGLIB$$12345.class");
         assertTrue(f.exists());
 
         // tidy up...
@@ -110,23 +109,39 @@ public class AtAjLTWTests extends XMLBasedAjcTestCase {
         f.delete();
     }
 
-      /* FIXME maw currently can't dump closures because the logic in 
-       * ClassLoaderWeavingAdaptor.shouldDump() relies on the World being
-       * able to resolve the name which it can't for closures.
-       */   
-//    public void testLTWDumpClosure() {
-//        runTest("LTW DumpTest closure");
-//
-//        File f = new File("_ajdump/_before/ataspectj/DumpTestTheDump$AjcClosure1.class");
-//        assertTrue(f.exists());
-//        f = new File("_ajdump/ataspectj/DumpTestTheDump$AjcClosure1.class");
-//        assertTrue(f.exists());
-//        
-//        // tidy up...
-//        f = new File("_ajdump");
-//        FileUtil.deleteContents(f);
-//        f.delete();
-//    }
+    public void testLTWDumpClosure() {
+        runTest("LTW DumpTest closure");
+
+        File f = new File("_ajdump/ataspectj/DumpTestTheDump$AjcClosure1.class");
+        assertTrue("Missing dump file " + f.getAbsolutePath(),f.exists());
+        
+        // tidy up...
+        f = new File("_ajdump");
+        FileUtil.deleteContents(f);
+        f.delete();
+    }
+
+    public void testLTWDumpProxy() {
+        runTest("LTW DumpTest proxy");
+
+        // The working directory is different because this test must be forked
+        File dir = new File("../tests/java5/ataspectj");
+        File f = new File(dir,"_ajdump/_before");
+        System.out.println("AtAjLTWTests.testLTWDumpProxy() f=" + f.getAbsolutePath());
+        CountingFilenameFilter cff = new CountingFilenameFilter();
+        f.listFiles(cff);
+        assertEquals("Expected dump file in " + f.getAbsolutePath(),1,cff.getCount());
+        f = new File(dir,"_ajdump");
+        System.out.println("AtAjLTWTests.testLTWDumpProxy() f=" + f.getAbsolutePath());
+        cff = new CountingFilenameFilter();
+        f.listFiles(cff);
+        assertEquals(1,cff.getCount());
+        
+        // tidy up...
+        f = new File(dir,"_ajdump");
+        FileUtil.deleteContents(f);
+        f.delete();
+    }
 
     public void testAjcAspect1LTWAspect2_Xreweavable() {
         runTest("Ajc Aspect1 LTW Aspect2 -Xreweavable");
@@ -185,4 +200,17 @@ public class AtAjLTWTests extends XMLBasedAjcTestCase {
         runTest("AppContainer");
     }
 
+    private static class CountingFilenameFilter implements FilenameFilter {
+    	
+    	private int count;
+    	
+    	public boolean accept(File dir, String name) {
+    		if (name.endsWith(".class")) count++;
+    		return false;
+    	}
+
+		public int getCount() {
+			return count;
+		}
+    }
 }
@@ -95,9 +95,9 @@
 
     <ajc-test dir="java5/ataspectj" title="LTW DumpTest before and after">
         <compile
-                files="ataspectj/DumpTest.java,ataspectj/DumpTestTheDump.java,ataspectj/TestHelper.java"
+                files="ataspectj/Test$$EnhancerByCGLIB$$12345.java"
                 options="-1.5"/>
-        <run class="ataspectj.DumpTest" ltw="ataspectj/aop-dumpbeforeandafter.xml"/>
+        <run class="ataspectj.Test$$EnhancerByCGLIB$$12345" ltw="ataspectj/aop-dumpbeforeandafter.xml"/>
     </ajc-test>
 
     <ajc-test dir="java5/ataspectj" title="LTW DumpTest closure">
@@ -107,6 +107,13 @@
         <run class="ataspectj.DumpTest" ltw="ataspectj/aop-dumpclosure.xml"/>
     </ajc-test>
 
+    <ajc-test dir="java5/ataspectj" title="LTW DumpTest proxy">
+        <compile
+                files="ataspectj/TestProxyGenerator.java,ataspectj/TestInterface.java"
+                options="-1.5"/>
+        <ant file="ajc-ant.xml" target="ltw.DumpProxyTest" verbose="true"/>
+    </ajc-test>
+
     <ajc-test dir="java5/ataspectj" title="Ajc Aspect1 LTW Aspect2 -Xreweavable">
         <compile
                 files="ataspectj/ltwreweavable/Main.java,ataspectj/ltwreweavable/Aspect1.java,ataspectj/ltwreweavable/Advisable.java"
@@ -151,7 +151,7 @@ public class CrosscuttingMembers {
 	}
 
 	public void exposeType(UnresolvedType typeToExpose) {
-		if (typeToExpose == ResolvedType.MISSING) return;
+		if (ResolvedType.isMissing(typeToExpose)) return;
 		if (typeToExpose.isParameterizedType() || typeToExpose.isRawType()) {
 			if (typeToExpose instanceof ResolvedType) {
 				typeToExpose = ((ResolvedType)typeToExpose).getGenericType();
@@ -98,6 +98,16 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
         return false;
     }
 
+    // FIXME asc I wonder if in some circumstances MissingWithKnownSignature should not be considered 
+    // 'really' missing as some code can continue based solely on the signature
+    public static boolean isMissing (UnresolvedType unresolved) {
+    	if (unresolved instanceof ResolvedType) {
+    		ResolvedType resolved = (ResolvedType)unresolved;
+    		return resolved.isMissing();
+    	}
+    	else return (unresolved == MISSING);
+    }
+    
     public ResolvedType[] getAnnotationTypes() {
     	return EMPTY_RESOLVED_TYPE_ARRAY;
     }
@@ -1243,7 +1253,7 @@ public abstract class ResolvedType extends UnresolvedType implements AnnotatedEl
 		int lastDollar = name.lastIndexOf('$');
 		while (lastDollar != -1) {
 			ResolvedType ret = world.resolve(UnresolvedType.forName(name.substring(0, lastDollar)), true);
-			if (ret != ResolvedType.MISSING) return ret;
+			if (!ResolvedType.isMissing(ret)) return ret;
 			lastDollar = name.lastIndexOf('$', lastDollar-1);
 		}
 		return null;
@@ -204,7 +204,7 @@ public class WeaverStateInfo {
 		for (Iterator i = typeMungers.iterator(); i.hasNext();) {
 			Entry entry = (Entry) i.next();
 			ResolvedType aspectType = world.resolve(entry.aspectType, true);
-			if (aspectType == ResolvedType.MISSING) {
+			if (aspectType.isMissing()) {
 				world.showMessage(IMessage.ERROR,
 					WeaverMessages.format(WeaverMessages.ASPECT_NEEDED,entry.aspectType,onType),
 					onType.getSourceLocation(), null);
@@ -144,7 +144,7 @@ public abstract class World implements Dump.INode {
      */
     public ResolvedType resolve(UnresolvedType ty,ISourceLocation isl) {
         ResolvedType ret = resolve(ty,true);
-        if (ty == ResolvedType.MISSING) {
+        if (ResolvedType.isMissing(ty)) {
             //IMessage msg = null;
             getLint().cantFindType.signal(WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE,ty.getName()),isl);
             //if (isl!=null) {
@@ -215,13 +215,13 @@ public abstract class World implements Dump.INode {
             		                     componentType);
         } else {
             ret = resolveToReferenceType(ty);
-            if (!allowMissing && ret == ResolvedType.MISSING) {
+            if (!allowMissing && ret.isMissing()) {
                 ret = handleRequiredMissingTypeDuringResolution(ty);
             }
         }        
 
 		// Pulling in the type may have already put the right entry in the map
-		if (typeMap.get(signature)==null && ret != ResolvedType.MISSING) {
+		if (typeMap.get(signature)==null && !ret.isMissing()) {
 	        typeMap.put(signature, ret);
 		}
         return ret;
@@ -298,7 +298,9 @@ public abstract class World implements Dump.INode {
 			String erasedSignature = ty.getErasureSignature();
     		ReferenceType simpleOrRawType = new ReferenceType(erasedSignature, this);
 	    	ReferenceTypeDelegate delegate = resolveDelegate(simpleOrRawType);
-	    	if (delegate == null) return ResolvedType.MISSING;
+	    	// 117854
+//	    	if (delegate == null) return ResolvedType.MISSING;
+	    	if (delegate == null) return new MissingResolvedTypeWithKnownSignature(ty.getSignature(),erasedSignature,this);//ResolvedType.MISSING;
 
 	    	if (delegate.isGeneric() && behaveInJava5Way) {
 	    		// ======== raw type ===========
@@ -401,7 +403,7 @@ public abstract class World implements Dump.INode {
      */
     public ResolvedType getCoreType(UnresolvedType tx) {
     	ResolvedType coreTy = resolve(tx,true);
-    	if (coreTy == ResolvedType.MISSING) {
+    	if (coreTy.isMissing()) {
     		 MessageUtil.error(messageHandler, 
             	WeaverMessages.format(WeaverMessages.CANT_FIND_CORE_TYPE,tx.getName()));
     	}
@@ -175,7 +175,7 @@ public class BcelAdvice extends Advice {
     private boolean canInline(Shadow s) {
     	if (attribute.isProceedInInners()) return false;
     	//XXX this guard seems to only be needed for bad test cases
-    	if (concreteAspect == null || concreteAspect == ResolvedType.MISSING) return false;
+    	if (concreteAspect == null || concreteAspect.isMissing()) return false;
 
 		if (concreteAspect.getWorld().isXnoInline()) return false;
     	//System.err.println("isWoven? " + ((BcelObjectType)concreteAspect).getLazyClassGen().getWeaverState());
@@ -261,7 +261,7 @@ public class BcelAdvice extends Advice {
 
 		for (int i=0, len=excs.length; i < len; i++) {
 			ResolvedType t = world.resolve(excs[i],true);
-            if (t == ResolvedType.MISSING) {
+            if (t.isMissing()) {
             		world.getLint().cantFindType.signal(
             				WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_EXCEPTION_TYPE,excs[i].getName()),
             				getSourceLocation()
@@ -2030,7 +2030,7 @@ public class BcelShadow extends Shadow {
         	if (rm.hasBackingGenericMember()) mungerSig = rm.getBackingGenericMember();
         }
         ResolvedType declaringType = world.resolve(mungerSig.getDeclaringType(),true);
-        if (declaringType == ResolvedType.MISSING) {
+        if (declaringType.isMissing()) {
         	world.getLint().cantFindType.signal(
         			new String[] {WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE,declaringType.getClassName())},
         			getSourceLocation(),
@@ -2636,7 +2636,7 @@ public class BcelShadow extends Shadow {
 			for (int i = 0, len = stateTypes.length; i < len; i++) {
                 UnresolvedType bcelTX = BcelWorld.fromBcel(stateTypes[i]);
                 ResolvedType stateRTX = world.resolve(bcelTX,true);
-                if (stateRTX == ResolvedType.MISSING) {
+                if (stateRTX.isMissing()) {
                 		world.getLint().cantFindType.signal(
                 				new String[] {WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE_PREINIT,bcelTX.getClassName())},
                 				getSourceLocation(),
@@ -148,7 +148,7 @@ public class BcelWeaver implements IWeaver {
     public ResolvedType addLibraryAspect(String aspectName) {
         // 1 - resolve as is
         ResolvedType type = world.resolve(UnresolvedType.forName(aspectName), true);
-        if (type.equals(ResolvedType.MISSING)) {
+        if (type.isMissing()) {
             // fallback on inner class lookup mechanism
             String fixedName = aspectName;
             int hasDot = fixedName.lastIndexOf('.');
@@ -159,7 +159,7 @@ public class BcelWeaver implements IWeaver {
                 fixedName = new String(fixedNameChars);
                 hasDot = fixedName.lastIndexOf('.');
                 type = world.resolve(UnresolvedType.forName(fixedName), true);
-                if (!type.equals(ResolvedType.MISSING)) {
+                if (!type.isMissing()) {
                     break;
                 }
             }
@@ -1223,7 +1223,7 @@ public class BcelWeaver implements IWeaver {
 					String requiredTypeName = (String) iter.next();
 					if (!alreadyConfirmedReweavableState.contains(requiredTypeName)) {
 						ResolvedType rtx = world.resolve(UnresolvedType.forName(requiredTypeName),true);
-						boolean exists = rtx!=ResolvedType.MISSING;
+						boolean exists = !rtx.isMissing();
 						if (!exists) {
 							world.showMessage(IMessage.ERROR, 
 									WeaverMessages.format(WeaverMessages.MISSING_REWEAVABLE_TYPE,requiredTypeName,className),
@@ -144,7 +144,7 @@ public class ArgsAnnotationPointcut extends NameBindingPointcut {
 				ExactAnnotationTypePattern ap = (ExactAnnotationTypePattern)arguments.get(i);
 				UnresolvedType argType = shadow.getArgType(argsIndex);
 				ResolvedType rArgType = argType.resolve(shadow.getIWorld());
-				if (rArgType == ResolvedType.MISSING) {
+				if (rArgType.isMissing()) {
 					shadow.getIWorld().getLint().cantFindType.signal(
 							new String[] {WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_ARG_TYPE,argType.getName())},
 							shadow.getSourceLocation(),
@@ -204,7 +204,7 @@ public class ArgsPointcut extends NameBindingPointcut {
 			TypePattern type = patterns[i];
             ResolvedType argRTX = shadow.getIWorld().resolve(argType,true);
 			if (!(type instanceof BindingTypePattern)) {
-                if (argRTX == ResolvedType.MISSING) {
+                if (argRTX.isMissing()) {
 					shadow.getIWorld().getLint().cantFindType.signal(
 							new String[] {WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_ARG_TYPE,argType.getName())},
 							shadow.getSourceLocation(),
@@ -93,7 +93,7 @@ public class DeclarePrecedence extends Declare {
     			continue;
     		}
     		ResolvedType exactType = pi.getExactType().resolve(scope.getWorld());
-    		if (exactType == ResolvedType.MISSING) continue;
+    		if (exactType.isMissing()) continue;
 
     		// Cannot do a dec prec specifying a non-aspect types unless suffixed with a '+'
     		if (!exactType.isAspect() && !pi.isIncludeSubtypes() && !exactType.isTypeVariableReference()) {
@@ -99,7 +99,7 @@ public class DeclareSoft extends Declare {
     public void resolve(IScope scope) {
     	exception = exception.resolveBindings(scope, null, false, true);
     	ResolvedType excType = exception.getExactType().resolve(scope.getWorld());
-    	if (excType != ResolvedType.MISSING) {
+    	if (!excType.isMissing()) {
     		if (excType.isTypeVariableReference()) {
     			// a declare soft in a generic abstract aspect, we need to check the upper bound
     			excType = excType.getUpperBound().resolve(scope.getWorld());
@@ -154,9 +154,9 @@ public class ExactAnnotationTypePattern extends AnnotationTypePattern {
 		annotationType = scope.getWorld().resolve(annotationType,true);
 
 		// We may not have found it if it is in a package, lets look it up...
-		if (annotationType == ResolvedType.MISSING) {
+		if (ResolvedType.isMissing(annotationType)) {
 			UnresolvedType type = null;
-			while ((type = scope.lookupType(cleanname,this)) == ResolvedType.MISSING) {
+			while (ResolvedType.isMissing(type = scope.lookupType(cleanname,this))) {
 				int lastDot = cleanname.lastIndexOf('.');
 				if (lastDot == -1) break;
 				cleanname = cleanname.substring(0,lastDot)+"$"+cleanname.substring(lastDot+1);
@@ -83,7 +83,7 @@ public class ExactTypePattern extends TypePattern {
 		if (super.couldEverMatchSameTypesAs(other)) return true;
 		// false is necessary but not sufficient
 		UnresolvedType otherType = other.getExactType();
-		if (otherType != ResolvedType.MISSING) {
+		if (!ResolvedType.isMissing(otherType)) {
 			return type.equals(otherType);
 		} 
 		if (other instanceof WildTypePattern) {
@@ -145,7 +145,7 @@ public class KindedPointcut extends Pointcut {
 			shadow.getSignature().getDeclaringType().resolve(world);
 
 		if (signature.getDeclaringType().isStar()
-			|| exactDeclaringType == ResolvedType.MISSING
+			|| ResolvedType.isMissing(exactDeclaringType)
 			|| exactDeclaringType.resolve(world).isMissing())
 			return;
 
@@ -267,7 +267,7 @@ public class KindedPointcut extends Pointcut {
 			World world = scope.getWorld();
 			UnresolvedType exactType = signature.getDeclaringType().getExactType();
 			if (signature.getKind() == Member.CONSTRUCTOR &&
-				!exactType.equals(ResolvedType.MISSING) &&
+				!ResolvedType.isMissing(exactType) &&
 				exactType.resolve(world).isInterface() &&
 				!signature.getDeclaringType().isIncludeSubtypes()) {
 					world.getLint().noInterfaceCtorJoinpoint.signal(exactType.toString(), getSourceLocation());
@@ -165,7 +165,7 @@ public class PerThisOrTargetPointcutVisitor extends IdentityPointcutVisitor {
         ResolvedType searchStart = m_fromAspectType;
         if (node.onType != null) {
             searchStart = node.onType.resolve(m_fromAspectType.getWorld());
-            if (searchStart == ResolvedType.MISSING) {
+            if (searchStart.isMissing()) {
                 return MAYBE;// this should not happen since concretize will fails but just in case..
             }
         }
@@ -79,7 +79,7 @@ public class PerTypeWithin extends PerClause {
 
     protected FuzzyBoolean matchInternal(Shadow shadow) {
     	ResolvedType enclosingType = shadow.getIWorld().resolve(shadow.getEnclosingType(),true);
-    	if (enclosingType == ResolvedType.MISSING) {
+    	if (enclosingType.isMissing()) {
     		//PTWIMPL ?? Add a proper message
     		IMessage msg = new Message(
     				"Cant find type pertypewithin matching...",
@@ -129,7 +129,7 @@ public class ReferencePointcut extends Pointcut {
 		if (onTypeSymbolic != null) {
 			onType = onTypeSymbolic.resolveExactType(scope, bindings);
 			// in this case we've already signalled an error
-			if (onType == ResolvedType.MISSING) return;		
+			if (ResolvedType.isMissing(onType)) return;		
 		}
 
 		ResolvedType searchType;
@@ -263,7 +263,7 @@ public class ReferencePointcut extends Pointcut {
 			ResolvedPointcutDefinition pointcutDec;
 			if (onType != null) {
 				searchStart = onType.resolve(searchStart.getWorld());
-				if (searchStart == ResolvedType.MISSING) {
+				if (searchStart.isMissing()) {
 					return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
 				}
 			}
@@ -51,8 +51,8 @@ public class SimpleScope implements IScope {
 
 		for (int i=0; i<importedPrefixes.length; i++) {
 			String importedPrefix = importedPrefixes[i];
-			UnresolvedType tryType = world.resolve(UnresolvedType.forName(importedPrefix + name), true);
-			if (tryType != ResolvedType.MISSING) {
+			ResolvedType tryType = world.resolve(UnresolvedType.forName(importedPrefix + name), true);
+			if (!tryType.isMissing()) {
 				return tryType;
 			}
 		}
@@ -125,7 +125,7 @@ public abstract class TypePattern extends PatternNode {
 	public final FuzzyBoolean matches(ResolvedType type, MatchKind kind) {
 		FuzzyBoolean typeMatch = null;
 		//??? This is part of gracefully handling missing references
-		if (type == ResolvedType.MISSING) return FuzzyBoolean.NO;
+		if (type.isMissing()) return FuzzyBoolean.NO;
 
 		if (kind == STATIC) {
 //			typeMatch = FuzzyBoolean.fromBoolean(matchesStatically(type));
@@ -270,7 +270,7 @@ public class TypePatternList extends PatternNode {
 		ArrayList ret = new ArrayList();
 		for (int i=0; i<typePatterns.length; i++) {
 			UnresolvedType t = typePatterns[i].getExactType();
-			if (t != ResolvedType.MISSING) ret.add(t);
+			if (!ResolvedType.isMissing(t)) ret.add(t);
 		}
 		return ret;
 	}
@@ -182,7 +182,7 @@ public class WildTypePattern extends TypePattern {
 		if (super.couldEverMatchSameTypesAs(other)) return true;
 		// false is necessary but not sufficient
 		UnresolvedType otherType = other.getExactType();
-		if (otherType != ResolvedType.MISSING) {
+		if (!ResolvedType.isMissing(otherType)) {
 			if (namePatterns.length > 0) {
 				if (!namePatterns[0].matches(otherType.getName())) return false;
 			}
@@ -703,7 +703,7 @@ public class WildTypePattern extends TypePattern {
 
 	private UnresolvedType lookupTypeInScope(IScope scope, String typeName, IHasPosition location) {
 		UnresolvedType type = null;
-		while ((type = scope.lookupType(typeName, location)) == ResolvedType.MISSING) {
+		while (ResolvedType.isMissing(type = scope.lookupType(typeName, location))) {
 			int lastDot = typeName.lastIndexOf('.');
 			if (lastDot == -1) break;
 			typeName = typeName.substring(0, lastDot) + '$' + typeName.substring(lastDot+1);
@@ -713,7 +713,7 @@ public class WildTypePattern extends TypePattern {
 
 	private ResolvedType lookupTypeInWorld(World world, String typeName) {
 		ResolvedType ret = world.resolve(UnresolvedType.forName(typeName),true);
-		while (ret == ResolvedType.MISSING) {
+		while (ret.isMissing()) {
 			int lastDot = typeName.lastIndexOf('.');
 			if (lastDot == -1) break;
 			typeName = typeName.substring(0, lastDot) + '$' + typeName.substring(lastDot+1);
@@ -744,8 +744,8 @@ public class WildTypePattern extends TypePattern {
 	private TypePattern resolveGenericWildcard(IScope scope, UnresolvedType aType) {
 		if (!aType.getSignature().equals(GENERIC_WILDCARD_CHARACTER)) throw new IllegalStateException("Can only have bounds for a generic wildcard");
 		boolean canBeExact = true;
-		if ((upperBound != null) && (upperBound.getExactType() == ResolvedType.MISSING)) canBeExact = false;
-		if ((lowerBound != null) && (lowerBound.getExactType() == ResolvedType.MISSING)) canBeExact = false;
+		if ((upperBound != null) && ResolvedType.isMissing(upperBound.getExactType())) canBeExact = false;
+		if ((lowerBound != null) && ResolvedType.isMissing(lowerBound.getExactType())) canBeExact = false;
 		if (canBeExact) {
 			ResolvedType type = null;
 			if (upperBound != null) {
@@ -813,7 +813,7 @@ public class WildTypePattern extends TypePattern {
 			return NO;
 		} else if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
 			// Only put the lint warning out if we can't find it in the world
-			if (typeFoundInWholeWorldSearch == ResolvedType.MISSING) {
+			if (typeFoundInWholeWorldSearch.isMissing()) {
 			  scope.getWorld().getLint().invalidAbsoluteTypeName.signal(nameWeLookedFor, getSourceLocation());
 			}
 		}
@@ -854,11 +854,11 @@ public class WildTypePattern extends TypePattern {
 		} else {
 			// we have to set bounds on the TypeVariable held by tvrType before resolving it
 			boolean canCreateExactTypePattern = true;
-			if (upperBound != null && upperBound.getExactType() == ResolvedType.MISSING) canCreateExactTypePattern = false;
-			if (lowerBound != null && lowerBound.getExactType() == ResolvedType.MISSING) canCreateExactTypePattern = false;
+			if (upperBound != null && ResolvedType.isMissing(upperBound.getExactType())) canCreateExactTypePattern = false;
+			if (lowerBound != null && ResolvedType.isMissing(lowerBound.getExactType())) canCreateExactTypePattern = false;
 			if (additionalInterfaceBounds != null) {
 				for (int i = 0; i < additionalInterfaceBounds.length; i++) {
-					if (additionalInterfaceBounds[i].getExactType() == ResolvedType.MISSING) canCreateExactTypePattern = false;
+					if (ResolvedType.isMissing(additionalInterfaceBounds[i].getExactType())) canCreateExactTypePattern = false;
 				}
 			}
 			if (canCreateExactTypePattern) {
@@ -87,7 +87,7 @@ public class WithinAnnotationPointcut extends NameBindingPointcut {
 	 */
 	protected FuzzyBoolean matchInternal(Shadow shadow) {
 		ResolvedType enclosingType = shadow.getIWorld().resolve(shadow.getEnclosingType(),true);
-		if (enclosingType == ResolvedType.MISSING) {
+		if (enclosingType.isMissing()) {
 			shadow.getIWorld().getLint().cantFindType.signal(
 					new String[] {WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_WITHINPCD,
 											shadow.getEnclosingType().getName())},
@@ -71,7 +71,7 @@ public class WithinPointcut extends Pointcut {
 
 	protected FuzzyBoolean matchInternal(Shadow shadow) {
 		ResolvedType enclosingType = shadow.getIWorld().resolve(shadow.getEnclosingType(),true);
-		if (enclosingType == ResolvedType.MISSING) {
+		if (enclosingType.isMissing()) {
 			shadow.getIWorld().getLint().cantFindType.signal(
 					new String[] {WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_WITHINPCD,
 											shadow.getEnclosingType().getName())},
@@ -361,6 +361,7 @@ public class WeavingAdaptor {
 	    dir.mkdirs();
 	    String fileName = dirName + File.separator + className + ".class";
 	    try {
+//	    	System.out.println("WeavingAdaptor.dump() fileName=" + new File(fileName).getAbsolutePath());
 		    FileOutputStream os = new FileOutputStream(fileName);
 		    os.write(b);
 		    os.close();
@@ -78,7 +78,7 @@ public abstract class AbstractWorldTestCase extends TestCase {
     	ResolvedType[] primitives = getWorld().resolve(primitiveTypeXs);
     	UnresolvedType tx = UnresolvedType.forSignature(sig);
         ResolvedType ty = getWorld().resolve(tx,true);
-        assertTrue("Couldnt find type "+tx,ty!=ResolvedType.MISSING);
+        assertTrue("Couldnt find type "+tx,!ty.isMissing());
         ResolvedType[] lowerTyArray = 
             getWorld().resolve(UnresolvedType.forSignatures(lowers));
         List lowerTys = new ArrayList(Arrays.asList(lowerTyArray));
@@ -103,7 +103,7 @@ public abstract class AbstractWorldTestCase extends TestCase {
             ResolvedType ty = primitives[i];
             UnresolvedType tx = UnresolvedType.forSignature("["+ty.getSignature());
             ResolvedType aty = getWorld().resolve(tx,true);
-            assertTrue("Couldnt find type "+tx,aty!=ResolvedType.MISSING);
+            assertTrue("Couldnt find type "+tx,!aty.isMissing());
             modifiersTest(aty, Modifier.PUBLIC | Modifier.FINAL);
             fieldsTest(aty, ResolvedMember.NONE);
             methodsTest(aty, ResolvedMember.NONE);
@@ -121,7 +121,7 @@ public abstract class AbstractWorldTestCase extends TestCase {
                 isCoerceableFromTest(aty, ty1, false);
                 tx = UnresolvedType.forSignature("[" + ty1.getSignature());
                 ResolvedType aty1 = getWorld().resolve(tx,true);
-                assertTrue("Couldnt find type "+tx,aty1!=ResolvedType.MISSING);
+                assertTrue("Couldnt find type "+tx,!aty1.isMissing());
                 if (ty.equals(ty1)) {
                     isCoerceableFromTest(aty, aty1, true);
                     isAssignableFromTest(aty, aty1, true);
@@ -101,7 +101,7 @@ public class ArgsWeaveTestCase extends WeaveTestCase {
 
     private BcelAdvice makeArgsMunger(final String kindx) {
     	ResolvedType rtx = world.resolve(UnresolvedType.forName("Aspect"),true);
-    	assertTrue("Cant find required type Aspect",rtx!=ResolvedType.MISSING);
+    	assertTrue("Cant find required type Aspect",!rtx.isMissing());
         return new BcelAdvice(AdviceKind.stringToKind(kindx), makePointcutNoZeroArg(),
         			MemberImpl.method(UnresolvedType.forName("Aspect"), 0, "foo", "()V"), 0, -1, -1, null,
         			rtx) {
@@ -76,7 +76,7 @@ public class TjpWeaveTestCase extends WeaveTestCase {
 
     public void testAround2Tjp() throws IOException {
     	ResolvedType rtx = world.resolve(UnresolvedType.forName("Aspect"),true);
-    	assertTrue("Couldnt find type Aspect",rtx!=ResolvedType.MISSING);
+    	assertTrue("Couldnt find type Aspect",!rtx.isMissing());
     	BcelAdvice munger1 = new BcelAdvice(
     		AdviceKind.stringToKind("around"),
     		makePointcutAll(), 
@@ -36,7 +36,7 @@ public class WorldTestCase extends AbstractWorldTestCase {
 	// XXX fix the various XXXs before expecting this test to work
     public void xtestTraceJar() {
         ResolvedType trace = world.resolve(UnresolvedType.forName("Trace"),true);
-        assertTrue("Couldnt find type Trace",trace!=ResolvedType.MISSING);
+        assertTrue("Couldnt find type Trace",!trace.isMissing());
         fieldsTest(trace, Member.NONE);
         /*Member constr = */MemberImpl.methodFromString("void Trace.<init>()"); 
         //XXX need attribute fix - 
@@ -69,7 +69,7 @@ public class WorldTestCase extends AbstractWorldTestCase {
             });
 
         ResolvedType myTrace = world.resolve(UnresolvedType.forName("MyTrace"),true);
-        assertTrue("Couldnt find type MyTrace",myTrace!=ResolvedType.MISSING);
+        assertTrue("Couldnt find type MyTrace",!myTrace.isMissing());
 
         interfacesTest(myTrace, ResolvedType.NONE);
         superclassTest(myTrace, trace);
@@ -122,11 +122,11 @@ import org.aspectj.weaver.bcel.BcelWorld;
 
 		 assertTrue("resolves to WildTypePattern",rtp instanceof WildTypePattern);
 		 assertTrue("one type parameter", rtp.typeParameters.size() == 1);
-		 assertEquals("missing",ResolvedType.MISSING,rtp.getExactType());
+		 assertTrue("missing",ResolvedType.isMissing(rtp.getExactType()));
 
 		 WildTypePattern wtp = (WildTypePattern) writeAndRead(rtp);
 		 assertTrue("one type parameter", wtp.typeParameters.size() == 1);
-		 assertEquals("missing",ResolvedType.MISSING,wtp.getExactType());
+		 assertTrue("missing",ResolvedType.isMissing(wtp.getExactType()));
 		 assertEquals("Str*",wtp.getTypeParameters().getTypePatterns()[0].toString());
 
 		 assertFalse("does not match List",wtp.matches(javaUtilList, TypePattern.STATIC).alwaysTrue());
