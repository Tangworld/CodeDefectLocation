@@ -585,7 +585,7 @@ public class AjTypeImpl<T> implements AjType<T> {
 			List<InterTypeMethodDeclaration> itdms = new ArrayList<InterTypeMethodDeclaration>();
 			Method[] baseMethods = clazz.getDeclaredMethods();
 			for (Method m : baseMethods) {
-				if (!m.getName().contains("ajc$interMethod$")) continue;
+				if (!m.getName().contains("ajc$interMethodDispatch1$")) continue;
 				if (m.isAnnotationPresent(ajcITD.class)) {
 					ajcITD ann = m.getAnnotation(ajcITD.class);
 					InterTypeMethodDeclaration itdm = 
@@ -77,5 +77,24 @@ public class InterTypeConstructorDeclarationImpl extends
 		}
 		return ret;
 	}
+	
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		sb.append(java.lang.reflect.Modifier.toString(getModifiers()));
+		sb.append(" ");
+		sb.append(this.targetTypeName);
+		sb.append(".new");
+		sb.append("(");
+		AjType<?>[] pTypes = getParameterTypes();
+		for(int i = 0; i < (pTypes.length - 1); i++) {
+			sb.append(pTypes[i].toString());
+			sb.append(", ");
+		}
+		if (pTypes.length > 0) {
+			sb.append(pTypes[pTypes.length -1].toString());
+		}
+		sb.append(")");
+		return sb.toString();
+	}
 
 }
@@ -21,7 +21,7 @@ import org.aspectj.lang.reflect.InterTypeDeclaration;
 public class InterTypeDeclarationImpl implements InterTypeDeclaration {
 
 	private AjType<?> declaringType;
-	private String targetTypeName;
+	protected String targetTypeName;
 	private AjType<?> targetType;
 	private int modifiers;
 
@@ -74,5 +74,17 @@ public class InterTypeFieldDeclarationImpl extends InterTypeDeclarationImpl
 	public Type getGenericType() {
 		return this.genericType;
 	}
+	
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		sb.append(java.lang.reflect.Modifier.toString(getModifiers()));
+		sb.append(" ");
+		sb.append(getType().toString());
+		sb.append(" ");
+		sb.append(this.targetTypeName);
+		sb.append(".");
+		sb.append(getName());
+		return sb.toString();
+	}
 
 }
@@ -122,5 +122,27 @@ public class InterTypeMethodDeclarationImpl extends InterTypeDeclarationImpl
 		}
 		return ret;
 	}
+	
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		sb.append(java.lang.reflect.Modifier.toString(getModifiers()));
+		sb.append(" ");
+		sb.append(getReturnType().toString());
+		sb.append(" ");
+		sb.append(this.targetTypeName);
+		sb.append(".");
+		sb.append(getName());
+		sb.append("(");
+		AjType<?>[] pTypes = getParameterTypes();
+		for(int i = 0; i < (pTypes.length - 1); i++) {
+			sb.append(pTypes[i].toString());
+			sb.append(", ");
+		}
+		if (pTypes.length > 0) {
+			sb.append(pTypes[pTypes.length -1].toString());
+		}
+		sb.append(")");
+		return sb.toString();
+	}
 
 }
Binary files differ
Binary files differ
@@ -0,0 +1,29 @@
+public aspect Billing {
+
+	public Customer Connection.payer;
+    
+	/**
+     * Connections give the appropriate call rate
+     */
+    public abstract long Connection.callRate();
+
+    public long LongDistance.callRate() { return 1; }
+    public long Local.callRate() { return 2; }
+
+    /**
+     * Customers have a bill paying aspect with state
+     */
+    public long Customer.totalCharge = 0;
+
+    public void Customer.addCharge(long charge){
+        totalCharge += charge;
+    }
+}
+
+class Customer {}
+
+abstract class Connection {}
+
+class LongDistance extends Connection {}
+
+class Local extends Connection {}
@@ -0,0 +1,18 @@
+import org.aspectj.lang.reflect.*;
+
+public class ReflectBilling {
+	
+	public static void main(String[] args) {
+		AjType<Billing> billingType = AjTypeSystem.getAjType(Billing.class);
+		InterTypeMethodDeclaration[] itdms = billingType.getDeclaredITDMethods();
+		for(InterTypeMethodDeclaration itdm : itdms) { 
+			System.out.println(itdm); 
+		}
+		InterTypeFieldDeclaration[] itdfs = billingType.getDeclaredITDFields();
+		for(InterTypeFieldDeclaration itdf : itdfs) { 
+			System.out.println(itdf); 
+		}	
+	}
+	
+	
+}
\ No newline at end of file
@@ -721,6 +721,10 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testPointcutParsingOfCompiledPointcuts() {
 	  runTest("pointcut parsing with ajc compiled pointcut references");
   }
+  
+  public void testReflectionOfAbstractITDs() {
+	  runTest("reflection on abstract ITDs (Billing example)");
+  }
 
   /*
    * Load-time weaving bugs
@@ -66,6 +66,20 @@
 		<compile files="PointcutLibrary.aj,ReflectOnAjcCompiledPointcuts.java" options="-1.5"></compile>
 		<run class="ReflectOnAjcCompiledPointcuts" classpath="../lib/bcel/bcel.jar"/>
 	</ajc-test>
+	
+	<ajc-test dir="java5/reflection" pr="114322" title="reflection on abstract ITDs (Billing example)">
+		<compile files="ReflectBilling.java,Billing.aj" options="-1.5"/>
+		<run class="ReflectBilling">
+			<stdout>
+				<line text="public abstract long Connection.callRate()"/>
+				<line text="public long LongDistance.callRate()"/>
+				<line text="public long Local.callRate()"/>
+				<line text="public void Customer.addCharge(long)"/>
+				<line text="public Customer Connection.payer"/>
+				<line text="public long Customer.totalCharge"/>
+			</stdout>
+		</run>
+	</ajc-test>
 
     <ajc-test dir="bugs150/pr114436" title="ClassFormatError binary weaving perthis">
      <compile files="SimpleTrace.aj,ConcreteSimpleTracing.aj" outjar="aspects.jar"/>
