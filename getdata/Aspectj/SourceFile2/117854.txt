@@ -180,10 +180,14 @@
               <!-- Do not weave types within the "bar" pakage -->
               <exclude within="bar.*"/>
 
-              <!-- Dump all types within the "somepack" package,
-                   both before are after they are woven,
+              <!-- Dump all types within the "com.foo.bar" package
                    to the "./_ajdump" folder on disk (for diagnostic purposes) -->
-              <dump within="somepack.*" />
+              <dump within="com.foo.bar.*"/>
+
+              <!-- Dump all types within the "com.foo.bar" package and sub-packages,
+                   both before are after they are woven,
+                   which can be used for byte-code generated at runtime
+              <dump within="com.foo.bar..*" beforeandafter="true"/> 
             </weaver>
 
           </aspectj>
@@ -191,9 +195,9 @@
 		  ]]></programlisting>
 
             <para>
-                An aop.xml file contains two key sections: "aspects" defines one
+                An aop.xml file contains two key sections: <literal>aspects</literal> defines one
                 or more aspects to the weaver and controls which aspects are to be
-                used in the weaving process; "weaver" defines weaver options and which
+                used in the weaving process; <literal>weaver</literal> defines weaver options and which
                 types should be woven.
             </para>
 
@@ -202,7 +206,7 @@
                 specify the fully-qualified name of the aspect type in an aspect element. 
                 You can also
                 declare (and define to the weaver) aspects inline in the aop.xml file.
-                This is done using the "concrete-aspect" element. A concrete-aspect
+                This is done using the <literal>concrete-aspect</literal> element. A concrete-aspect
                 declaration must provide a pointcut definition for every abstract 
                 pointcut in the abstract aspect it extends. This mechanism is a 
                 useful way of externalizing configuration for infrastructure and
@@ -231,9 +235,11 @@
             </para>
 
             <para>
-                The weaver element is used to pass options to the weaver and to specify
+                The <literal>weaver</literal> element is used to pass options to the weaver and to specify
                 the set of types that should be woven. If no include elements are specified
-                then all types visible to the weaver will be woven.
+                then all types visible to the weaver will be woven. In addition the <literal>dump</literal>
+                element can be used capture on disk byte-code of woven classes for diagnostic purposes both before,
+                in the case of those generated at runtime, and after the weaving process.
             </para>
 
 
@@ -180,10 +180,14 @@
               <!-- Do not weave types within the "bar" pakage -->
               <exclude within="bar.*"/>
 
-              <!-- Dump all types within the "somepack" package,
-                   both before are after they are woven,
+              <!-- Dump all types within the "com.foo.bar" package
                    to the "./_ajdump" folder on disk (for diagnostic purposes) -->
-              <dump within="somepack.*" />
+              <dump within="com.foo.bar.*"/>
+
+              <!-- Dump all types within the "com.foo.bar" package and sub-packages,
+                   both before are after they are woven,
+                   which can be used for byte-code generated at runtime
+              <dump within="com.foo.bar..*" beforeandafter="true"/> 
             </weaver>
 
           </aspectj>
@@ -191,9 +195,9 @@
 		  ]]></programlisting>
 
             <para>
-                An aop.xml file contains two key sections: "aspects" defines one
+                An aop.xml file contains two key sections: <literal>aspects</literal> defines one
                 or more aspects to the weaver and controls which aspects are to be
-                used in the weaving process; "weaver" defines weaver options and which
+                used in the weaving process; <literal>weaver</literal> defines weaver options and which
                 types should be woven.
             </para>
 
@@ -202,7 +206,7 @@
                 specify the fully-qualified name of the aspect type in an aspect element. 
                 You can also
                 declare (and define to the weaver) aspects inline in the aop.xml file.
-                This is done using the "concrete-aspect" element. A concrete-aspect
+                This is done using the <literal>concrete-aspect</literal> element. A concrete-aspect
                 declaration must provide a pointcut definition for every abstract 
                 pointcut in the abstract aspect it extends. This mechanism is a 
                 useful way of externalizing configuration for infrastructure and
@@ -231,9 +235,11 @@
             </para>
 
             <para>
-                The weaver element is used to pass options to the weaver and to specify
+                The <literal>weaver</literal> element is used to pass options to the weaver and to specify
                 the set of types that should be woven. If no include elements are specified
-                then all types visible to the weaver will be woven.
+                then all types visible to the weaver will be woven. In addition the <literal>dump</literal>
+                element can be used capture on disk byte-code of woven classes for diagnostic purposes both before,
+                in the case of those generated at runtime, and after the weaving process.
             </para>
 
 
@@ -59,7 +59,7 @@ package org.aspectj.apache.bcel.generic;
  * TABLESWITCH instruction, depending on whether the match values (int[]) can be
  * sorted with no gaps between the numbers.
  *
- * @version $Id: SWITCH.java,v 1.3 2005/08/25 11:35:49 aclement Exp $
+ * @version $Id: SWITCH.java,v 1.4 2005/12/06 11:28:24 aclement Exp $
  * @author  <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
  */
 public final class SWITCH implements CompoundInstruction {
@@ -170,10 +170,10 @@ public final class SWITCH implements CompoundInstruction {
    * @return match is sorted in ascending order with no gap bigger than max_gap?
    */
   private final boolean matchIsOrdered(int max_gap) {
-    for(int i=1; i < match_length; i++)
-      if(match[i] - match[i-1] > max_gap)
-	return false;
-
+    for(int i=1; i < match_length; i++) {
+      int diff = (match[i]-match[i-1]);
+      if(diff > max_gap || diff<0) return false;
+    }
     return true;
   }
 
Binary files differ
Binary files differ
@@ -0,0 +1,14 @@
+public class BrokenSwitch {
+  public static void main(String []argv) {
+    int i = 1;
+    switch (i) {
+      case -845341380: System.err.println("a");break;
+      case 1730110032: System.err.println("a");break;
+      default: System.err.println("c");break;
+    }
+  }
+}
+
+aspect X {
+  before(): execution(* BrokenSwitch.main(..)) {}
+}
@@ -81,6 +81,7 @@ public class Ajc150Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
   public void testBadDecp_pr110788_3() { runTest("bad generic decp - 3");}
   public void testBadDecp_pr110788_4() { runTest("bad generic decp - 4");}
 
+  public void testBrokenSwitch_pr117854() { runTest("broken switch transform");}
   public void testVarargsITD_pr110906() { runTest("ITD varargs problem");}
   public void testBadRenderer_pr86903() { runTest("bcelrenderer bad");}
   //public void testIllegalInitialization_pr118326_1() { runTest("illegal initialization - 1");}
@@ -69,6 +69,11 @@
      <run class="Pr114054"/>
     </ajc-test>  
 
+    <ajc-test dir="bugs150/pr117854" pr="117854" title="broken switch transform">
+     <compile files="BrokenSwitch.java" options=""/>
+     <run class="BrokenSwitch"/>
+    </ajc-test>  
+    
     <ajc-test dir="bugs150/pr118599" pr="118599" title="ambiguous method when binary weaving - 1">
      <!-- separate compilation was failing  -->
      <compile files="Attributable.java" outjar="foo.jar" options="-1.5"/>
@@ -11,8 +11,6 @@
  *******************************************************************************/
 package org.aspectj.weaver.loadtime;
 
-import java.io.File;
-import java.io.FileOutputStream;
 import java.lang.reflect.Method;
 import java.lang.reflect.InvocationTargetException;
 import java.util.Map;
@@ -63,11 +61,7 @@ public class Aj implements ClassPreProcessor {
 
         try {
             WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader, weavingContext);
-            byte[] weaved = weavingAdaptor.weaveClass(className, bytes);
-            if (weavingAdaptor.shouldDump(className.replace('/', '.'))) {
-                dump(className, weaved);
-            }
-            return weaved;
+            return weavingAdaptor.weaveClass(className, bytes);
         } catch (Throwable t) {
             //FIXME AV wondering if we should have the option to fail (throw runtime exception) here
             // would make sense at least in test f.e. see TestHelper.handleMessage()
@@ -165,32 +159,6 @@ public class Aj implements ClassPreProcessor {
     }
 
     /**
-     * Dump the given bytcode in _dump/... (dev mode)
-     *
-     * @param name
-     * @param b
-     * @throws Throwable
-     */
-    static void dump(String name, byte[] b) throws Throwable {
-        String className = name.replace('.', '/');
-        final File dir;
-        if (className.indexOf('/') > 0) {
-            dir = new File("_ajdump" + File.separator + className.substring(0, className.lastIndexOf('/')));
-        } else {
-            dir = new File("_ajdump");
-        }
-        dir.mkdirs();
-        String fileName = "_ajdump" + File.separator + className + ".class";
-        FileOutputStream os = new FileOutputStream(fileName);
-        os.write(b);
-        os.close();
-    }
-    
-    /*
-     * Shared classes methods
-     */
-
-    /**
      * Returns a namespace based on the contest of the aspects available
      */
     public String getNamespace (ClassLoader loader) {
@@ -54,6 +54,7 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
     private final static String AOP_XML = "META-INF/aop.xml";
 
     private List m_dumpTypePattern = new ArrayList();
+    private boolean m_dumpBefore = false;
     private List m_includeTypePattern = new ArrayList();
     private List m_excludeTypePattern = new ArrayList();
     private List m_includeStartsWith = new ArrayList();
@@ -81,8 +82,8 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
              */
             public void acceptClass(String name, byte[] bytes) {
                 try {
-                    if (shouldDump(name.replace('/', '.'))) {
-                        Aj.dump(name, bytes);
+                    if (shouldDump(name.replace('/', '.'), false)) {
+                        dump(name, bytes, false);
                     }
                 } catch (Throwable throwable) {
                     throwable.printStackTrace();
@@ -438,6 +439,9 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
                 TypePattern pattern = new PatternParser(dump).parseTypePattern();
                 m_dumpTypePattern.add(pattern);
             }
+            if (definition.shouldDumpBefore()) {
+            	m_dumpBefore = true;
+            }
         }
     }
 
@@ -543,11 +547,17 @@ public class ClassLoaderWeavingAdaptor extends WeavingAdaptor {
         return accept;
     }
 
-    public boolean shouldDump(String className) {
+    protected boolean shouldDump(String className, boolean before) {
+    	// Don't dump before weaving unless asked to
+    	if (before && !m_dumpBefore) {
+            return false;
+    	}
+    	
         // avoid ResolvedType if not needed
         if (m_dumpTypePattern.isEmpty()) {
             return false;
         }
+
         //TODO AV - optimize for className.startWith only
         ResolvedType classInfo = weaver.getWorld().resolve(UnresolvedType.forName(className), true);
         //dump
@@ -24,6 +24,7 @@ public class Definition {
     private StringBuffer m_weaverOptions;
 
     private List m_dumpPatterns;
+    private boolean m_dumpBefore;
 
     private List m_includePatterns;
 
@@ -39,6 +40,7 @@ public class Definition {
 
     public Definition() {
         m_weaverOptions = new StringBuffer();
+        m_dumpBefore = false;
         m_dumpPatterns = new ArrayList(0);
         m_includePatterns = new ArrayList(0);
         m_excludePatterns = new ArrayList(0);
@@ -56,6 +58,14 @@ public class Definition {
         return m_dumpPatterns;
     }
 
+	public void setDumpBefore(boolean b) {
+		m_dumpBefore = b;
+	}
+
+	public boolean shouldDumpBefore() {
+		return m_dumpBefore;
+	}
+
     public List getIncludePatterns() {
         return m_includePatterns;
     }
@@ -51,6 +51,7 @@ public class DocumentParser extends DefaultHandler {
     private final static String ASPECTJ_ELEMENT = "aspectj";
     private final static String WEAVER_ELEMENT = "weaver";
     private final static String DUMP_ELEMENT = "dump";
+    private final static String DUMP_BEFOREANDAFTER_ATTRIBUTE = "beforeandafter";
     private final static String INCLUDE_ELEMENT = "include";
     private final static String EXCLUDE_ELEMENT = "exclude";
     private final static String OPTIONS_ATTRIBUTE = "options";
@@ -206,6 +207,10 @@ public class DocumentParser extends DefaultHandler {
             if (!isNull(typePattern)) {
                 m_definition.getDumpPatterns().add(typePattern);
             }
+            String beforeAndAfter = attributes.getValue(DUMP_BEFOREANDAFTER_ATTRIBUTE);
+            if (isTrue(beforeAndAfter)) {
+            	m_definition.setDumpBefore(true);
+            }
         } else if (EXCLUDE_ELEMENT.equals(qName) && m_inAspects) {
             String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
             if (!isNull(typePattern)) {
@@ -258,5 +263,9 @@ public class DocumentParser extends DefaultHandler {
         return (s == null || s.length() <= 0);
     }
 
+    private boolean isTrue(String s) {
+        return (s != null && s.equals("true"));
+    }
+
 
 }
@@ -39,6 +39,7 @@ public class DocumentParserTest extends TestCase {
         assertEquals("@Baz", def.getAspectExcludePatterns().get(0));
         assertEquals("@Whoo", def.getAspectIncludePatterns().get(0));
         assertEquals("foo..*", def.getDumpPatterns().get(0));
+        assertEquals(true,def.shouldDumpBefore());
     }
 
 }
@@ -3,7 +3,7 @@
 <aspectj>
     <weaver options="-showWeaveInfo">
         <include within="foo..bar.Goo+"/>
-        <dump within="foo..*"/>
+        <dump within="foo..*" beforeandafter="true"/>
     </weaver>
     <aspects>
         <exclude within="@Baz"/>
@@ -21,25 +21,7 @@ import java.io.File;
 public class DumpTest extends TestCase {
 
     public static void main(String[] args) {
-        TestHelper.runAndThrowOnFailure(suite());
-    }
-
-    public static junit.framework.Test suite() {
-        return new junit.framework.TestSuite(DumpTest.class);
-    }
-
-    public void testDump() {
-        File f = new File("_ajdump/ataspectj/DumpTest.class");
-        assertFalse(f.exists());
-
-        DumpTestTheDump forceLoad = new DumpTestTheDump();
-        f = new File("_ajdump/ataspectj/DumpTestTheDump.class");
-        assertTrue(f.exists());
-        
-        // tidy up...
-        f.delete();
-        new File("_ajdump/ataspectj").delete();
-        new File("_ajdump").delete();
+    	new DumpTestTheDump().aroundMethod("DumpTest");
     }
 
 }
@@ -15,4 +15,7 @@ package ataspectj;
  * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
  */
 public class DumpTestTheDump {
+	public void aroundMethod (String s) {
+		
+	}
 }
@@ -0,0 +1,18 @@
+/*******************************************************************************
+ * Copyright (c) 2005 Contributors.
+ * All rights reserved. 
+ * This program and the accompanying materials are made available 
+ * under the terms of the Eclipse Public License v1.0 
+ * which accompanies this distribution and is available at 
+ * http://eclipse.org/legal/epl-v10.html 
+ * 
+ * Contributors:
+ *   Matthew Webster         initial implementation
+ *******************************************************************************/
+package ataspectj;
+
+public aspect TestAroundAspect {
+	Object around () : execution(public void aroundMethod(..)) {
+		return proceed();
+	}
+}
@@ -0,0 +1,6 @@
+<?xml version="1.0"?>
+<aspectj>
+    <weaver options="-XmessageHandlerClass:ataspectj.TestHelper">
+        <dump within="ataspectj.DumpTestThe*" beforeandafter="true"/> 
+    </weaver>
+</aspectj>
@@ -0,0 +1,9 @@
+<?xml version="1.0"?>
+<aspectj>
+	<aspects>
+		<aspect name="ataspectj.TestAroundAspect"/>
+	</aspects>
+    <weaver options="-Xnoinline">
+        <dump within="ataspectj.DumpTestThe*" beforeandafter="true"/> 
+    </weaver>
+</aspectj>
@@ -0,0 +1,5 @@
+<?xml version="1.0"?>
+<aspectj>
+    <weaver options="-XmessageHandlerClass:ataspectj.TestHelper">
+    </weaver>
+</aspectj>
@@ -12,6 +12,8 @@
 package org.aspectj.systemtest.ajc150.ataspectj;
 
 import org.aspectj.testing.XMLBasedAjcTestCase;
+import org.aspectj.util.FileUtil;
+
 import junit.framework.Test;
 
 import java.io.File;
@@ -65,9 +67,66 @@ public class AtAjLTWTests extends XMLBasedAjcTestCase {
         runTest("AjcLTW AroundInlineMungerTest2");
     }
 
+    public void testLTWDumpNone() {
+        runTest("LTW DumpTest none");
+
+        File f = new File("_ajdump/ataspectj/DumpTest.class");
+        assertFalse(f.exists());
+        f = new File("_ajdump/_before/ataspectj/DumpTestTheDump.class");
+        assertFalse(f.exists());
+        f = new File("_ajdump/ataspectj/DumpTestTheDump.class");
+        assertFalse(f.exists());
+    }
+
     public void testLTWDump() {
         runTest("LTW DumpTest");
-    }
+        
+        File f = new File("_ajdump/ataspectj/DumpTest.class");
+        assertFalse(f.exists());
+        f = new File("_ajdump/_before/ataspectj/DumpTestTheDump.class");
+        assertFalse(f.exists());
+        f = new File("_ajdump/ataspectj/DumpTestTheDump.class");
+        assertTrue(f.exists());
+        
+        // tidy up...
+        f = new File("_ajdump");
+        FileUtil.deleteContents(f);
+        f.delete();
+    }
+
+    public void testLTWDumpBeforeAndAfter() {
+        runTest("LTW DumpTest before and after");
+
+        File f = new File("_ajdump/ataspectj/DumpTest.class");
+        assertFalse(f.exists());
+        f = new File("_ajdump/_before/ataspectj/DumpTestTheDump.class");
+        assertTrue(f.exists());
+        f = new File("_ajdump/ataspectj/DumpTestTheDump.class");
+        assertTrue(f.exists());
+        
+        // tidy up...
+        f = new File("_ajdump");
+        FileUtil.deleteContents(f);
+        f.delete();
+    }
+
+      /* FIXME maw currently can't dump closures because the logic in 
+       * ClassLoaderWeavingAdaptor.shouldDump() relies on the World being
+       * able to resolve the name which it can't for closures.
+       */   
+//    public void testLTWDumpClosure() {
+//        runTest("LTW DumpTest closure");
+//
+//        File f = new File("_ajdump/_before/ataspectj/DumpTestTheDump$AjcClosure1.class");
+//        assertTrue(f.exists());
+//        f = new File("_ajdump/ataspectj/DumpTestTheDump$AjcClosure1.class");
+//        assertTrue(f.exists());
+//        
+//        // tidy up...
+//        f = new File("_ajdump");
+//        FileUtil.deleteContents(f);
+//        f.delete();
+//    }
 
     public void testAjcAspect1LTWAspect2_Xreweavable() {
         runTest("Ajc Aspect1 LTW Aspect2 -Xreweavable");
@@ -79,11 +79,32 @@
         <ant file="ajc-ant.xml" target="ltw.AroundInlineMungerTest2" verbose="true"/>
     </ajc-test>
 
+    <ajc-test dir="java5/ataspectj" title="LTW DumpTest none">
+        <compile
+                files="ataspectj/DumpTest.java,ataspectj/DumpTestTheDump.java,ataspectj/TestHelper.java"
+                options="-1.5"/>
+        <run class="ataspectj.DumpTest" ltw="ataspectj/aop-dumpnone.xml"/>
+    </ajc-test>
+
     <ajc-test dir="java5/ataspectj" title="LTW DumpTest">
         <compile
                 files="ataspectj/DumpTest.java,ataspectj/DumpTestTheDump.java,ataspectj/TestHelper.java"
                 options="-1.5"/>
-        <ant file="ajc-ant.xml" target="ltw.DumpTest" verbose="true"/>
+        <run class="ataspectj.DumpTest" ltw="ataspectj/aop-dump.xml"/>
+    </ajc-test>
+
+    <ajc-test dir="java5/ataspectj" title="LTW DumpTest before and after">
+        <compile
+                files="ataspectj/DumpTest.java,ataspectj/DumpTestTheDump.java,ataspectj/TestHelper.java"
+                options="-1.5"/>
+        <run class="ataspectj.DumpTest" ltw="ataspectj/aop-dumpbeforeandafter.xml"/>
+    </ajc-test>
+
+    <ajc-test dir="java5/ataspectj" title="LTW DumpTest closure">
+        <compile
+                files="ataspectj/DumpTest.java,ataspectj/DumpTestTheDump.java,ataspectj/TestAroundAspect.aj"
+                options="-1.5"/>
+        <run class="ataspectj.DumpTest" ltw="ataspectj/aop-dumpclosure.xml"/>
     </ajc-test>
 
     <ajc-test dir="java5/ataspectj" title="Ajc Aspect1 LTW Aspect2 -Xreweavable">
@@ -14,6 +14,7 @@
 package org.aspectj.weaver.tools;
 
 import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.net.URL;
@@ -187,6 +188,7 @@ public class WeavingAdaptor {
 	 */
 	public byte[] weaveClass (String name, byte[] bytes) throws IOException {
 		if (enabled) {
+
 			if (shouldWeave(name, bytes)) {
 				info("weaving '" + name + "'");
 				bytes = getWovenBytes(name, bytes);
@@ -220,7 +222,7 @@ public class WeavingAdaptor {
         return true;
     }
 
-    public boolean shouldDump(String name) {
+    protected boolean shouldDump(String name, boolean before) {
         return false;
     }
 
@@ -338,6 +340,37 @@ public class WeavingAdaptor {
 	}
 
 	/**
+	 * Dump the given bytcode in _dump/... (dev mode)
+	 *
+	 * @param name
+	 * @param b
+	 * @param before whether we are dumping before weaving
+	 * @throws Throwable
+	 */
+	protected void dump(String name, byte[] b, boolean before) {
+		String dirName = "_ajdump";
+		if (before) dirName = dirName + File.separator + "_before";
+		
+	    String className = name.replace('.', '/');
+	    final File dir;
+	    if (className.indexOf('/') > 0) {
+	        dir = new File(dirName + File.separator + className.substring(0, className.lastIndexOf('/')));
+	    } else {
+	        dir = new File(dirName);
+	    }
+	    dir.mkdirs();
+	    String fileName = dirName + File.separator + className + ".class";
+	    try {
+		    FileOutputStream os = new FileOutputStream(fileName);
+		    os.write(b);
+		    os.close();
+	    }
+	    catch (IOException ex) {
+	    	warn("unable to dump class " + name + " in directory " + dirName,ex);
+	    }
+	}
+
+	/**
 	 * Processes messages arising from weaver operations. 
 	 * Tell weaver to abort on any message more severe than warning.
 	 */
@@ -396,6 +429,11 @@ public class WeavingAdaptor {
         public WeavingClassFileProvider (String name, byte[] bytes) {
 			this.unwovenClass = new UnwovenClassFile(name,bytes);
 			this.unwovenClasses.add(unwovenClass);
+			
+			if (shouldDump(name.replace('/', '.'),true)) {
+				dump(name, bytes, true);
+			}
+
 			bcelWorld.addSourceObjectType(unwovenClass.getJavaClass());
 		}
 
@@ -422,6 +460,11 @@ public class WeavingAdaptor {
 				public void acceptResult(UnwovenClassFile result) {
 					if (wovenClass == null) {
 						wovenClass = result;
+						
+						String name = result.getClassName();
+						if (shouldDump(name.replace('/', '.'), false)) {
+							dump(name, result.getBytes(), false);
+						}
 					}
 
 					/* Classes generated by weaver e.g. around closure advice */
