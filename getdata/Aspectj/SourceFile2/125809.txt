@@ -31,6 +31,10 @@ public class AjTypeDeclaration extends TypeDeclaration {
 	public static final SimplePropertyDescriptor ASPECT_PROPERTY = 
 		new SimplePropertyDescriptor(TypeDeclaration.class, "aspect", boolean.class, MANDATORY); //$NON-NLS-1$
 
+	protected static List ajPROPERTY_DESCRIPTORS_2_0;
+	protected static List ajPROPERTY_DESCRIPTORS_3_0;
+
+	
 	// Need to fix up the property lists created during the super's static initializer
 	static {
 		// Need to fix up the property lists created during the super's static initializer
@@ -38,13 +42,13 @@ public class AjTypeDeclaration extends TypeDeclaration {
 		createPropertyList(TypeDeclaration.class, temporary);
 		temporary.addAll(PROPERTY_DESCRIPTORS_2_0);
 		addProperty(ASPECT_PROPERTY, temporary);
-		PROPERTY_DESCRIPTORS_2_0 = reapPropertyList(temporary);
+		ajPROPERTY_DESCRIPTORS_2_0 = reapPropertyList(temporary);
 
 		temporary.clear();
 		createPropertyList(TypeDeclaration.class, temporary);
 		temporary.addAll(PROPERTY_DESCRIPTORS_3_0);
 		addProperty(ASPECT_PROPERTY, temporary);
-		PROPERTY_DESCRIPTORS_3_0 = reapPropertyList(temporary);
+		ajPROPERTY_DESCRIPTORS_3_0 = reapPropertyList(temporary);
 	}
 
 	/**
@@ -72,6 +76,37 @@ public class AjTypeDeclaration extends TypeDeclaration {
 		super(ast);
 	}
 
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	ASTNode clone0(AST target) {
+		AjTypeDeclaration result = new AjTypeDeclaration(target);
+		result.setSourceRange(this.getStartPosition(), this.getLength());
+		result.setJavadoc(
+			(Javadoc) ASTNode.copySubtree(target, getJavadoc()));
+		if (this.ast.apiLevel == AST.JLS2_INTERNAL) {
+			result.internalSetModifiers(getModifiers());
+			result.setSuperclass(
+					(Name) ASTNode.copySubtree(target, getSuperclass()));
+			result.superInterfaces().addAll(
+					ASTNode.copySubtrees(target, superInterfaces()));
+		}
+		result.setInterface(isInterface());
+		result.setAspect(isAspect());
+		result.setName((SimpleName) getName().clone(target));
+		if (this.ast.apiLevel >= AST.JLS3) {
+			result.modifiers().addAll(ASTNode.copySubtrees(target, modifiers()));
+			result.typeParameters().addAll(
+					ASTNode.copySubtrees(target, typeParameters()));
+			result.setSuperclassType(
+					(Type) ASTNode.copySubtree(target, getSuperclassType()));
+			result.superInterfaceTypes().addAll(
+					ASTNode.copySubtrees(target, superInterfaceTypes()));
+		}
+		result.bodyDeclarations().addAll(
+			ASTNode.copySubtrees(target, bodyDeclarations()));
+		return result;
+	}
 
 	/* (omit javadoc for this method)
 	 * Method declared on ASTNode.
@@ -89,7 +124,25 @@ public class AjTypeDeclaration extends TypeDeclaration {
 		return super.internalGetSetBooleanProperty(property, get, value);
 	}
 
-	
+ 	/**
+ 	 * Returns a list of structural property descriptors for this node type.
+ 	 * Clients must not modify the result.
+ 	 * 
+ 	 * @param apiLevel the API level; one of the
+ 	 * <code>AST.JLS&ast;</code> constants
+
+ 	 * @return a list of property descriptors (element type: 
+ 	 * {@link StructuralPropertyDescriptor})
+ 	 * @since 3.0
+ 	 */
+ 	public static List propertyDescriptors(int apiLevel) {
+ 		if (apiLevel == AST.JLS2_INTERNAL) {
+ 			return ajPROPERTY_DESCRIPTORS_2_0;
+ 		} else {
+ 			return ajPROPERTY_DESCRIPTORS_3_0;
+ 		}
+ 	}
+ 	
 	/**
 	 * Returns whether this type declaration declares a class or an 
 	 * aspect.
@@ -31,21 +31,24 @@ public class AspectDeclaration extends AjTypeDeclaration {
 
 	public static final SimplePropertyDescriptor PRIVILEGED_PROPERTY = 
 		new SimplePropertyDescriptor(AspectDeclaration.class, "privileged", boolean.class, MANDATORY); //$NON-NLS-1$
+
+	protected static List aspectPROPERTY_DESCRIPTORS_2_0;
+	protected static List aspectPROPERTY_DESCRIPTORS_3_0;
 
 	static {
 		List temporary = new ArrayList();
 		createPropertyList(AspectDeclaration.class, temporary);
-		temporary.addAll(PROPERTY_DESCRIPTORS_2_0);
+		temporary.addAll(ajPROPERTY_DESCRIPTORS_2_0);
 		addProperty(PERCLAUSE_PROPERTY, temporary);
 		addProperty(PRIVILEGED_PROPERTY, temporary);
-		PROPERTY_DESCRIPTORS_2_0 = reapPropertyList(temporary);
+		aspectPROPERTY_DESCRIPTORS_2_0 = reapPropertyList(temporary);
 
 		temporary.clear();
 		createPropertyList(AspectDeclaration.class, temporary);
-		temporary.addAll(PROPERTY_DESCRIPTORS_3_0);
+		temporary.addAll(ajPROPERTY_DESCRIPTORS_3_0);
 		addProperty(PERCLAUSE_PROPERTY, temporary);
 		addProperty(PRIVILEGED_PROPERTY, temporary);
-		PROPERTY_DESCRIPTORS_3_0 = reapPropertyList(temporary);
+		aspectPROPERTY_DESCRIPTORS_3_0 = reapPropertyList(temporary);
 	}
 
 	protected ASTNode perClause = null; // stays null if the aspect is an _implicit_ persingleton()
@@ -165,6 +168,25 @@ public class AspectDeclaration extends AjTypeDeclaration {
 		return super.internalGetSetChildProperty(property,get,child);
 	}
 
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 * 
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS&ast;</code> constants
+
+	 * @return a list of property descriptors (element type: 
+	 * {@link StructuralPropertyDescriptor})
+	 * @since 3.0
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		if (apiLevel == AST.JLS2_INTERNAL) {
+			return aspectPROPERTY_DESCRIPTORS_2_0;
+		} else {
+			return aspectPROPERTY_DESCRIPTORS_3_0;
+		}
+	}
+	
 	public ASTNode getPerClause(){
 		return perClause;
 	}
@@ -62,6 +62,7 @@ import org.aspectj.org.eclipse.jdt.core.dom.SimpleType;
 import org.aspectj.org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.aspectj.org.eclipse.jdt.core.dom.StringLiteral;
 import org.aspectj.org.eclipse.jdt.core.dom.Type;
+import org.aspectj.org.eclipse.jdt.core.dom.TypeDeclaration;
 import org.aspectj.org.eclipse.jdt.core.dom.TypePattern;
 
 /**
@@ -407,6 +408,7 @@ public class AjASTTest extends TestCase {
 		boolean foundJavadoc = false;
 		boolean foundPerClause = false;
 		boolean foundIsPrivileged = false;
+		boolean foundIsAspect = false;
 		for (Iterator iter = props.iterator(); iter.hasNext();) {
 			Object o = iter.next();
 			if ((o instanceof ChildPropertyDescriptor)) {
@@ -417,14 +419,20 @@ public class AjASTTest extends TestCase {
 				} else if (id.equals("perClause")) {
 					foundPerClause = true;
 				}
-			} else if ((o instanceof SimplePropertyDescriptor)
-					&& ((SimplePropertyDescriptor)o).getId().equals("privileged")) {
-				foundIsPrivileged = true;
+			} else if (o instanceof SimplePropertyDescriptor) {
+				SimplePropertyDescriptor element = (SimplePropertyDescriptor)o;
+				String id = element.getId();
+				if (id.equals("privileged")) {
+					foundIsPrivileged = true;
+				} else if (id.equals("aspect")) {
+					foundIsAspect = true;
+				}
 			}
 		}
 		assertTrue("AspectDeclaration should have a javadoc PropertyDescriptor",foundJavadoc);
 		assertTrue("AspectDeclaration should have a perClause PropertyDescriptor",foundPerClause);
-		assertTrue("AspectDeclaration should have an isPrivileged PropertyDescriptor",foundIsPrivileged);
+		assertTrue("AspectDeclaration should have a privileged PropertyDescriptor",foundIsPrivileged);
+		assertTrue("AspectDeclaration should have inherited an aspect PropertyDescriptor",foundIsAspect);
 	}
 
 	public void testCloneAspectDeclaration() {
@@ -690,6 +698,116 @@ public class AjASTTest extends TestCase {
 		assertFalse("AjTypeDeclaration should now be a class",d.isAspect());	
 	}
 
+	public void testPropertyDescriptorsForAjTypeDeclaration() {
+		AjAST ajast = createAjAST();
+		AjTypeDeclaration d = ajast.newAjTypeDeclaration();
+		List props = AjTypeDeclaration.propertyDescriptors(AST.JLS3);
+		boolean foundAspect = false;
+		for (Iterator iter = props.iterator(); iter.hasNext();) {
+			Object o = iter.next();
+			if (o instanceof SimplePropertyDescriptor) {
+				SimplePropertyDescriptor element = (SimplePropertyDescriptor)o;
+				String id = element.getId();
+				if (id.equals("aspect")) {
+					foundAspect = true;
+				}										
+			}
+		}
+		assertTrue("AjTypeDeclaration should have an aspect PropertyDescriptor",foundAspect);
+	}
+		
+	public void testCloneAjTypeDeclaration() {
+		AjAST ajast = createAjAST();
+		AjTypeDeclaration d = ajast.newAjTypeDeclaration();
+		d.setAspect(true);
+		AjTypeDeclaration copy = (AjTypeDeclaration)ASTNode.copySubtree(ajast,d);
+		assertTrue("the AjTypeDeclaration clone should be an aspect",
+				copy.isAspect());
+	}
+	
+	public void testInternalAjTypeDeclaration() {
+		AjAST ajast = createAjAST();
+		AjTypeDeclaration d = ajast.newAjTypeDeclaration();
+		List props = AjTypeDeclaration.propertyDescriptors(AST.JLS3);
+		for (Iterator iter = props.iterator(); iter.hasNext();) {
+			Object o = iter.next();
+			if (o instanceof SimplePropertyDescriptor) {
+				SimplePropertyDescriptor element = (SimplePropertyDescriptor) o;
+				if (element.getId().equals("aspect")) {
+					assertNotNull("AjTypeDeclaration's " + element.getId() + " property" +
+							" should not be null since it is a boolean",
+							d.getStructuralProperty(element));				
+				} 				
+			}
+		}
+		for (Iterator iter = props.iterator(); iter.hasNext();) {
+			Object o = iter.next();
+			if (o instanceof SimplePropertyDescriptor) {
+				SimplePropertyDescriptor element = (SimplePropertyDescriptor) o;
+				if (element.getId().equals("aspect")) {
+					Boolean b = new Boolean(true);
+					d.setStructuralProperty(element,b);
+					assertEquals("AjTypeDeclaration's aspect property should" +
+						" now be a SignaturePattern",b,d.getStructuralProperty(element));
+				}
+			}
+		}
+	}
+
+	// test for bug 125809 - make sure the property descriptors 
+	// associated with the AspectDeclaration aren't consequently
+	// associated with the AjTypeDeclaration
+	public void testPropertyDescriptorsForAjTypeDeclaration2() {
+		AjAST ajast = createAjAST();
+		AspectDeclaration ad = ajast.newAspectDeclaration();
+		List aspectProps = AspectDeclaration.propertyDescriptors(AST.JLS3);
+		AjTypeDeclaration d = ajast.newAjTypeDeclaration();
+		List props = AjTypeDeclaration.propertyDescriptors(AST.JLS3);
+		boolean foundPrivileged = false;
+		boolean foundPerClause = false;
+		boolean foundAspect = false;
+		for (Iterator iter = props.iterator(); iter.hasNext();) {
+			Object o = iter.next();
+			if (o instanceof SimplePropertyDescriptor) {
+				SimplePropertyDescriptor element = (SimplePropertyDescriptor)o;
+				String id = element.getId();
+				if (id.equals("privileged")) {
+					foundPrivileged = true;
+				}										
+			} else if (o instanceof ChildPropertyDescriptor) {
+				ChildPropertyDescriptor element = (ChildPropertyDescriptor)o;
+				if (element.getId().equals("perClause")) {
+					foundPerClause = true;
+				}
+			}
+		}
+		assertFalse("AjTypeDeclaration should not have a privileged PropertyDescriptor",foundPrivileged);
+		assertFalse("AjTypeDeclaration should not have a perClause PropertyDescriptor",foundPerClause);
+	}
+	
+	// test for bug 125809 - make sure the property descriptors 
+	// associated with the AjTypeDeclaration aren't consequently
+	// associated with the TypeDeclaration
+	public void testPropertyDescriptorsForAjTypeDeclaration3() {
+		AjAST ajast = createAjAST();
+		AjTypeDeclaration d = ajast.newAjTypeDeclaration();
+		List ajProps = AjTypeDeclaration.propertyDescriptors(AST.JLS3);
+		TypeDeclaration td = ajast.newTypeDeclaration();
+		List props = TypeDeclaration.propertyDescriptors(AST.JLS3);
+		boolean foundAspect = false;
+		for (Iterator iter = props.iterator(); iter.hasNext();) {
+			Object o = iter.next();
+			if (o instanceof SimplePropertyDescriptor) {
+				SimplePropertyDescriptor element = (SimplePropertyDescriptor)o;
+				String id = element.getId();
+				if (id.equals("aspect")) {
+					foundAspect = true;
+				}										
+			} 
+		}
+		assertFalse("TypeDeclaration should not have an aspect PropertyDescriptor",foundAspect);
+	}
+	
 	// -------------- DeclareAtFieldDeclaration tests ---------------
 
 	public void testNewDeclareAtFieldDeclaration() {
